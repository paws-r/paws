# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include iot_service.R
NULL

#' Accepts a pending certificate transfer
#'
#' Accepts a pending certificate transfer. The default state of the
#' certificate is INACTIVE.
#' 
#' To check for pending certificate transfers, call ListCertificates to
#' enumerate your certificates.
#'
#' @usage
#' iot_accept_certificate_transfer(certificateId, setAsActive)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$accept_certificate_transfer(
#'   certificateId = "string",
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_accept_certificate_transfer
iot_accept_certificate_transfer <- function(certificateId, setAsActive = NULL) {
  op <- new_operation(
    name = "AcceptCertificateTransfer",
    http_method = "PATCH",
    http_path = "/accept-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$accept_certificate_transfer_input(certificateId = certificateId, setAsActive = setAsActive)
  output <- .iot$accept_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$accept_certificate_transfer <- iot_accept_certificate_transfer

#' Adds a thing to a billing group
#'
#' Adds a thing to a billing group.
#'
#' @usage
#' iot_add_thing_to_billing_group(billingGroupName, billingGroupArn,
#'   thingName, thingArn)
#'
#' @param billingGroupName The name of the billing group.
#' @param billingGroupArn The ARN of the billing group.
#' @param thingName The name of the thing to be added to the billing group.
#' @param thingArn The ARN of the thing to be added to the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$add_thing_to_billing_group(
#'   billingGroupName = "string",
#'   billingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_add_thing_to_billing_group
iot_add_thing_to_billing_group <- function(billingGroupName = NULL, billingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "AddThingToBillingGroup",
    http_method = "PUT",
    http_path = "/billing-groups/addThingToBillingGroup",
    paginator = list()
  )
  input <- .iot$add_thing_to_billing_group_input(billingGroupName = billingGroupName, billingGroupArn = billingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$add_thing_to_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$add_thing_to_billing_group <- iot_add_thing_to_billing_group

#' Adds a thing to a thing group
#'
#' Adds a thing to a thing group.
#'
#' @usage
#' iot_add_thing_to_thing_group(thingGroupName, thingGroupArn, thingName,
#'   thingArn, overrideDynamicGroups)
#'
#' @param thingGroupName The name of the group to which you are adding a thing.
#' @param thingGroupArn The ARN of the group to which you are adding a thing.
#' @param thingName The name of the thing to add to a group.
#' @param thingArn The ARN of the thing to add to a group.
#' @param overrideDynamicGroups Override dynamic thing groups with static thing groups when 10-group
#' limit is reached. If a thing belongs to 10 thing groups, and one or more
#' of those groups are dynamic thing groups, adding a thing to a static
#' group removes the thing from the last dynamic group.
#'
#' @section Request syntax:
#' ```
#' svc$add_thing_to_thing_group(
#'   thingGroupName = "string",
#'   thingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string",
#'   overrideDynamicGroups = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_add_thing_to_thing_group
iot_add_thing_to_thing_group <- function(thingGroupName = NULL, thingGroupArn = NULL, thingName = NULL, thingArn = NULL, overrideDynamicGroups = NULL) {
  op <- new_operation(
    name = "AddThingToThingGroup",
    http_method = "PUT",
    http_path = "/thing-groups/addThingToThingGroup",
    paginator = list()
  )
  input <- .iot$add_thing_to_thing_group_input(thingGroupName = thingGroupName, thingGroupArn = thingGroupArn, thingName = thingName, thingArn = thingArn, overrideDynamicGroups = overrideDynamicGroups)
  output <- .iot$add_thing_to_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$add_thing_to_thing_group <- iot_add_thing_to_thing_group

#' Associates a group with a continuous job
#'
#' Associates a group with a continuous job. The following criteria must be
#' met:
#' 
#' -   The job must have been created with the `targetSelection` field set
#'     to \"CONTINUOUS\".
#' 
#' -   The job status must currently be \"IN\\_PROGRESS\".
#' 
#' -   The total number of targets associated with a job must not
#'     exceed 100.
#'
#' @usage
#' iot_associate_targets_with_job(targets, jobId, comment)
#'
#' @param targets &#91;required&#93; A list of thing group ARNs that define the targets of the job.
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param comment An optional comment string describing why the job was associated with
#' the targets.
#'
#' @section Request syntax:
#' ```
#' svc$associate_targets_with_job(
#'   targets = list(
#'     "string"
#'   ),
#'   jobId = "string",
#'   comment = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_associate_targets_with_job
iot_associate_targets_with_job <- function(targets, jobId, comment = NULL) {
  op <- new_operation(
    name = "AssociateTargetsWithJob",
    http_method = "POST",
    http_path = "/jobs/{jobId}/targets",
    paginator = list()
  )
  input <- .iot$associate_targets_with_job_input(targets = targets, jobId = jobId, comment = comment)
  output <- .iot$associate_targets_with_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$associate_targets_with_job <- iot_associate_targets_with_job

#' Attaches a policy to the specified target
#'
#' Attaches a policy to the specified target.
#'
#' @usage
#' iot_attach_policy(policyName, target)
#'
#' @param policyName &#91;required&#93; The name of the policy to attach.
#' @param target &#91;required&#93; The
#' [identity](https://docs.aws.amazon.com/iot/latest/developerguide/iot-security-identity.html)
#' to which the policy is attached.
#'
#' @section Request syntax:
#' ```
#' svc$attach_policy(
#'   policyName = "string",
#'   target = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_policy
iot_attach_policy <- function(policyName, target) {
  op <- new_operation(
    name = "AttachPolicy",
    http_method = "PUT",
    http_path = "/target-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$attach_policy_input(policyName = policyName, target = target)
  output <- .iot$attach_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_policy <- iot_attach_policy

#' Attaches the specified policy to the specified principal (certificate or
#' other credential)
#'
#' Attaches the specified policy to the specified principal (certificate or
#' other credential).
#' 
#' **Note:** This API is deprecated. Please use AttachPolicy instead.
#'
#' @usage
#' iot_attach_principal_policy(policyName, principal)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param principal &#91;required&#93; The principal, which can be a certificate ARN (as returned from the
#' CreateCertificate operation) or an Amazon Cognito ID.
#'
#' @section Request syntax:
#' ```
#' svc$attach_principal_policy(
#'   policyName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_principal_policy
iot_attach_principal_policy <- function(policyName, principal) {
  op <- new_operation(
    name = "AttachPrincipalPolicy",
    http_method = "PUT",
    http_path = "/principal-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$attach_principal_policy_input(policyName = policyName, principal = principal)
  output <- .iot$attach_principal_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_principal_policy <- iot_attach_principal_policy

#' Associates a Device Defender security profile with a thing group or with
#' this account
#'
#' Associates a Device Defender security profile with a thing group or with
#' this account. Each thing group or account can have up to five security
#' profiles associated with it.
#'
#' @usage
#' iot_attach_security_profile(securityProfileName,
#'   securityProfileTargetArn)
#'
#' @param securityProfileName &#91;required&#93; The security profile that is attached.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the target (thing group) to which the security profile is
#' attached.
#'
#' @section Request syntax:
#' ```
#' svc$attach_security_profile(
#'   securityProfileName = "string",
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_security_profile
iot_attach_security_profile <- function(securityProfileName, securityProfileTargetArn) {
  op <- new_operation(
    name = "AttachSecurityProfile",
    http_method = "PUT",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$attach_security_profile_input(securityProfileName = securityProfileName, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$attach_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_security_profile <- iot_attach_security_profile

#' Attaches the specified principal to the specified thing
#'
#' Attaches the specified principal to the specified thing. A principal can
#' be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_attach_thing_principal(thingName, principal)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#' @param principal &#91;required&#93; The principal, such as a certificate or other credential.
#'
#' @section Request syntax:
#' ```
#' svc$attach_thing_principal(
#'   thingName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_thing_principal
iot_attach_thing_principal <- function(thingName, principal) {
  op <- new_operation(
    name = "AttachThingPrincipal",
    http_method = "PUT",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$attach_thing_principal_input(thingName = thingName, principal = principal)
  output <- .iot$attach_thing_principal_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_thing_principal <- iot_attach_thing_principal

#' Cancels an audit that is in progress
#'
#' Cancels an audit that is in progress. The audit can be either scheduled
#' or on-demand. If the audit is not in progress, an
#' \"InvalidRequestException\" occurs.
#'
#' @usage
#' iot_cancel_audit_task(taskId)
#'
#' @param taskId &#91;required&#93; The ID of the audit you want to cancel. You can only cancel an audit
#' that is \"IN\\_PROGRESS\".
#'
#' @section Request syntax:
#' ```
#' svc$cancel_audit_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_audit_task
iot_cancel_audit_task <- function(taskId) {
  op <- new_operation(
    name = "CancelAuditTask",
    http_method = "PUT",
    http_path = "/audit/tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_audit_task_input(taskId = taskId)
  output <- .iot$cancel_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_audit_task <- iot_cancel_audit_task

#' Cancels a pending transfer for the specified certificate
#'
#' Cancels a pending transfer for the specified certificate.
#' 
#' **Note** Only the transfer source account can use this operation to
#' cancel a transfer. (Transfer destinations can use
#' RejectCertificateTransfer instead.) After transfer, AWS IoT returns the
#' certificate to the source account in the INACTIVE state. After the
#' destination account has accepted the transfer, the transfer cannot be
#' cancelled.
#' 
#' After a certificate transfer is cancelled, the status of the certificate
#' changes from PENDING\\_TRANSFER to INACTIVE.
#'
#' @usage
#' iot_cancel_certificate_transfer(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$cancel_certificate_transfer(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_certificate_transfer
iot_cancel_certificate_transfer <- function(certificateId) {
  op <- new_operation(
    name = "CancelCertificateTransfer",
    http_method = "PATCH",
    http_path = "/cancel-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$cancel_certificate_transfer_input(certificateId = certificateId)
  output <- .iot$cancel_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_certificate_transfer <- iot_cancel_certificate_transfer

#' Cancels a job
#'
#' Cancels a job.
#'
#' @usage
#' iot_cancel_job(jobId, reasonCode, comment, force)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param reasonCode (Optional)A reason code string that explains why the job was canceled.
#' @param comment An optional comment string describing why the job was canceled.
#' @param force (Optional) If `true` job executions with status \"IN\\_PROGRESS\" and
#' \"QUEUED\" are canceled, otherwise only job executions with status
#' \"QUEUED\" are canceled. The default is `false`.
#' 
#' Canceling a job which is \"IN\\_PROGRESS\", will cause a device which is
#' executing the job to be unable to update the job execution status. Use
#' caution and ensure that each device executing a job which is canceled is
#' able to recover to a valid state.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job(
#'   jobId = "string",
#'   reasonCode = "string",
#'   comment = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_job
iot_cancel_job <- function(jobId, reasonCode = NULL, comment = NULL, force = NULL) {
  op <- new_operation(
    name = "CancelJob",
    http_method = "PUT",
    http_path = "/jobs/{jobId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_job_input(jobId = jobId, reasonCode = reasonCode, comment = comment, force = force)
  output <- .iot$cancel_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_job <- iot_cancel_job

#' Cancels the execution of a job for a given thing
#'
#' Cancels the execution of a job for a given thing.
#'
#' @usage
#' iot_cancel_job_execution(jobId, thingName, force, expectedVersion,
#'   statusDetails)
#'
#' @param jobId &#91;required&#93; The ID of the job to be canceled.
#' @param thingName &#91;required&#93; The name of the thing whose execution of the job will be canceled.
#' @param force (Optional) If `true` the job execution will be canceled if it has status
#' IN\\_PROGRESS or QUEUED, otherwise the job execution will be canceled
#' only if it has status QUEUED. If you attempt to cancel a job execution
#' that is IN\\_PROGRESS, and you do not set `force` to `true`, then an
#' `InvalidStateTransitionException` will be thrown. The default is
#' `false`.
#' 
#' Canceling a job execution which is \"IN\\_PROGRESS\", will cause the
#' device to be unable to update the job execution status. Use caution and
#' ensure that the device is able to recover to a valid state.
#' @param expectedVersion (Optional) The expected current version of the job execution. Each time
#' you update the job execution, its version is incremented. If the version
#' of the job execution stored in Jobs does not match, the update is
#' rejected with a VersionMismatch error, and an ErrorResponse that
#' contains the current job execution status data is returned. (This makes
#' it unnecessary to perform a separate DescribeJobExecution request in
#' order to obtain the job execution status data.)
#' @param statusDetails A collection of name/value pairs that describe the status of the job
#' execution. If not specified, the statusDetails are unchanged. You can
#' specify at most 10 name/value pairs.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   force = TRUE|FALSE,
#'   expectedVersion = 123,
#'   statusDetails = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_job_execution
iot_cancel_job_execution <- function(jobId, thingName, force = NULL, expectedVersion = NULL, statusDetails = NULL) {
  op <- new_operation(
    name = "CancelJobExecution",
    http_method = "PUT",
    http_path = "/things/{thingName}/jobs/{jobId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_job_execution_input(jobId = jobId, thingName = thingName, force = force, expectedVersion = expectedVersion, statusDetails = statusDetails)
  output <- .iot$cancel_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_job_execution <- iot_cancel_job_execution

#' Clears the default authorizer
#'
#' Clears the default authorizer.
#'
#' @usage
#' iot_clear_default_authorizer()
#'
#' @section Request syntax:
#' ```
#' svc$clear_default_authorizer()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_clear_default_authorizer
iot_clear_default_authorizer <- function() {
  op <- new_operation(
    name = "ClearDefaultAuthorizer",
    http_method = "DELETE",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$clear_default_authorizer_input()
  output <- .iot$clear_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$clear_default_authorizer <- iot_clear_default_authorizer

#' Creates an authorizer
#'
#' Creates an authorizer.
#'
#' @usage
#' iot_create_authorizer(authorizerName, authorizerFunctionArn,
#'   tokenKeyName, tokenSigningPublicKeys, status)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#' @param authorizerFunctionArn &#91;required&#93; The ARN of the authorizer\'s Lambda function.
#' @param tokenKeyName &#91;required&#93; The name of the token key used to extract the token from the HTTP
#' headers.
#' @param tokenSigningPublicKeys &#91;required&#93; The public keys used to verify the digital signature returned by your
#' custom authentication service.
#' @param status The status of the create authorizer request.
#'
#' @section Request syntax:
#' ```
#' svc$create_authorizer(
#'   authorizerName = "string",
#'   authorizerFunctionArn = "string",
#'   tokenKeyName = "string",
#'   tokenSigningPublicKeys = list(
#'     "string"
#'   ),
#'   status = "ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_authorizer
iot_create_authorizer <- function(authorizerName, authorizerFunctionArn, tokenKeyName, tokenSigningPublicKeys, status = NULL) {
  op <- new_operation(
    name = "CreateAuthorizer",
    http_method = "POST",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$create_authorizer_input(authorizerName = authorizerName, authorizerFunctionArn = authorizerFunctionArn, tokenKeyName = tokenKeyName, tokenSigningPublicKeys = tokenSigningPublicKeys, status = status)
  output <- .iot$create_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_authorizer <- iot_create_authorizer

#' Creates a billing group
#'
#' Creates a billing group.
#'
#' @usage
#' iot_create_billing_group(billingGroupName, billingGroupProperties, tags)
#'
#' @param billingGroupName &#91;required&#93; The name you wish to give to the billing group.
#' @param billingGroupProperties The properties of the billing group.
#' @param tags Metadata which can be used to manage the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_billing_group(
#'   billingGroupName = "string",
#'   billingGroupProperties = list(
#'     billingGroupDescription = "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_billing_group
iot_create_billing_group <- function(billingGroupName, billingGroupProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateBillingGroup",
    http_method = "POST",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$create_billing_group_input(billingGroupName = billingGroupName, billingGroupProperties = billingGroupProperties, tags = tags)
  output <- .iot$create_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_billing_group <- iot_create_billing_group

#' Creates an X
#'
#' Creates an X.509 certificate using the specified certificate signing
#' request.
#' 
#' **Note:** The CSR must include a public key that is either an RSA key
#' with a length of at least 2048 bits or an ECC key from NIST P-256 or
#' NIST P-384 curves.
#' 
#' **Note:** Reusing the same certificate signing request (CSR) results in
#' a distinct certificate.
#' 
#' You can create multiple certificates in a batch by creating a directory,
#' copying multiple .csr files into that directory, and then specifying
#' that directory on the command line. The following commands show how to
#' create a batch of certificates given a batch of CSRs.
#' 
#' Assuming a set of CSRs are located inside of the directory
#' my-csr-directory:
#' 
#' On Linux and OS X, the command is:
#' 
#' \\$ ls my-csr-directory/ \\| xargs -I \{\} aws iot
#' create-certificate-from-csr \\--certificate-signing-request
#' file://my-csr-directory/\{\}
#' 
#' This command lists all of the CSRs in my-csr-directory and pipes each
#' CSR file name to the aws iot create-certificate-from-csr AWS CLI command
#' to create a certificate for the corresponding CSR.
#' 
#' The aws iot create-certificate-from-csr part of the command can also be
#' run in parallel to speed up the certificate creation process:
#' 
#' \\$ ls my-csr-directory/ \\| xargs -P 10 -I \{\} aws iot
#' create-certificate-from-csr \\--certificate-signing-request
#' file://my-csr-directory/\{\}
#' 
#' On Windows PowerShell, the command to create certificates for all CSRs
#' in my-csr-directory is:
#' 
#' \\> ls -Name my-csr-directory \\| \%\{aws iot create-certificate-from-csr
#' \\--certificate-signing-request file://my-csr-directory/\\$\\_\}
#' 
#' On a Windows command prompt, the command to create certificates for all
#' CSRs in my-csr-directory is:
#' 
#' \\> forfiles /p my-csr-directory /c \"cmd /c aws iot
#' create-certificate-from-csr \\--certificate-signing-request
#' file://\\@path\"
#'
#' @usage
#' iot_create_certificate_from_csr(certificateSigningRequest, setAsActive)
#'
#' @param certificateSigningRequest &#91;required&#93; The certificate signing request (CSR).
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$create_certificate_from_csr(
#'   certificateSigningRequest = "string",
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_certificate_from_csr
iot_create_certificate_from_csr <- function(certificateSigningRequest, setAsActive = NULL) {
  op <- new_operation(
    name = "CreateCertificateFromCsr",
    http_method = "POST",
    http_path = "/certificates",
    paginator = list()
  )
  input <- .iot$create_certificate_from_csr_input(certificateSigningRequest = certificateSigningRequest, setAsActive = setAsActive)
  output <- .iot$create_certificate_from_csr_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_certificate_from_csr <- iot_create_certificate_from_csr

#' Creates a dynamic thing group
#'
#' Creates a dynamic thing group.
#'
#' @usage
#' iot_create_dynamic_thing_group(thingGroupName, thingGroupProperties,
#'   indexName, queryString, queryVersion, tags)
#'
#' @param thingGroupName &#91;required&#93; The dynamic thing group name to create.
#' @param thingGroupProperties The dynamic thing group properties.
#' @param indexName The dynamic thing group index name.
#' 
#' Currently one index is supported: \"AWS\\_Things\".
#' @param queryString &#91;required&#93; The dynamic thing group search query string.
#' 
#' See [Query
#' Syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html)
#' for information about query string syntax.
#' @param queryVersion The dynamic thing group query version.
#' 
#' Currently one query version is supported: \"2017-09-30\". If not
#' specified, the query version defaults to this value.
#' @param tags Metadata which can be used to manage the dynamic thing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_dynamic_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   indexName = "string",
#'   queryString = "string",
#'   queryVersion = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_dynamic_thing_group
iot_create_dynamic_thing_group <- function(thingGroupName, thingGroupProperties = NULL, indexName = NULL, queryString, queryVersion = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateDynamicThingGroup",
    http_method = "POST",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$create_dynamic_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, indexName = indexName, queryString = queryString, queryVersion = queryVersion, tags = tags)
  output <- .iot$create_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_dynamic_thing_group <- iot_create_dynamic_thing_group

#' Creates a job
#'
#' Creates a job.
#'
#' @usage
#' iot_create_job(jobId, targets, documentSource, document, description,
#'   presignedUrlConfig, targetSelection, jobExecutionsRolloutConfig,
#'   abortConfig, timeoutConfig, tags)
#'
#' @param jobId &#91;required&#93; A job identifier which must be unique for your AWS account. We recommend
#' using a UUID. Alpha-numeric characters, \"-\" and \"\\_\" are valid for
#' use here.
#' @param targets &#91;required&#93; A list of things and thing groups to which the job should be sent.
#' @param documentSource An S3 link to the job document.
#' @param document The job document.
#' 
#' If the job document resides in an S3 bucket, you must use a placeholder
#' link when specifying the document.
#' 
#' The placeholder link is of the following form:
#' 
#' `$\{aws:iot:s3-presigned-url:https://s3.amazonaws.com/<i>bucket</i>/<i>key</i>\}`
#' 
#' where *bucket* is your bucket name and *key* is the object in the bucket
#' to which you are linking.
#' @param description A short text description of the job.
#' @param presignedUrlConfig Configuration information for pre-signed S3 URLs.
#' @param targetSelection Specifies whether the job will continue to run (CONTINUOUS), or will be
#' complete after all those things specified as targets have completed the
#' job (SNAPSHOT). If continuous, the job may also be run on a thing when a
#' change is detected in a target. For example, a job will run on a thing
#' when the thing is added to a target group, even after the job was
#' completed by all things originally in the group.
#' @param jobExecutionsRolloutConfig Allows you to create a staged rollout of the job.
#' @param abortConfig Allows you to create criteria to abort a job.
#' @param timeoutConfig Specifies the amount of time each device has to finish its execution of
#' the job. The timer is started when the job execution status is set to
#' `IN_PROGRESS`. If the job execution status is not set to another
#' terminal state before the time expires, it will be automatically set to
#' `TIMED_OUT`.
#' @param tags Metadata which can be used to manage the job.
#'
#' @section Request syntax:
#' ```
#' svc$create_job(
#'   jobId = "string",
#'   targets = list(
#'     "string"
#'   ),
#'   documentSource = "string",
#'   document = "string",
#'   description = "string",
#'   presignedUrlConfig = list(
#'     roleArn = "string",
#'     expiresInSec = 123
#'   ),
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   jobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123,
#'     exponentialRate = list(
#'       baseRatePerMinute = 123,
#'       incrementFactor = 123.0,
#'       rateIncreaseCriteria = list(
#'         numberOfNotifiedThings = 123,
#'         numberOfSucceededThings = 123
#'       )
#'     )
#'   ),
#'   abortConfig = list(
#'     criteriaList = list(
#'       list(
#'         failureType = "FAILED"|"REJECTED"|"TIMED_OUT"|"ALL",
#'         action = "CANCEL",
#'         thresholdPercentage = 123.0,
#'         minNumberOfExecutedThings = 123
#'       )
#'     )
#'   ),
#'   timeoutConfig = list(
#'     inProgressTimeoutInMinutes = 123
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_job
iot_create_job <- function(jobId, targets, documentSource = NULL, document = NULL, description = NULL, presignedUrlConfig = NULL, targetSelection = NULL, jobExecutionsRolloutConfig = NULL, abortConfig = NULL, timeoutConfig = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateJob",
    http_method = "PUT",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$create_job_input(jobId = jobId, targets = targets, documentSource = documentSource, document = document, description = description, presignedUrlConfig = presignedUrlConfig, targetSelection = targetSelection, jobExecutionsRolloutConfig = jobExecutionsRolloutConfig, abortConfig = abortConfig, timeoutConfig = timeoutConfig, tags = tags)
  output <- .iot$create_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_job <- iot_create_job

#' Creates a 2048-bit RSA key pair and issues an X
#'
#' Creates a 2048-bit RSA key pair and issues an X.509 certificate using
#' the issued public key.
#' 
#' **Note** This is the only time AWS IoT issues the private key for this
#' certificate, so it is important to keep it in a secure location.
#'
#' @usage
#' iot_create_keys_and_certificate(setAsActive)
#'
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$create_keys_and_certificate(
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_keys_and_certificate
iot_create_keys_and_certificate <- function(setAsActive = NULL) {
  op <- new_operation(
    name = "CreateKeysAndCertificate",
    http_method = "POST",
    http_path = "/keys-and-certificate",
    paginator = list()
  )
  input <- .iot$create_keys_and_certificate_input(setAsActive = setAsActive)
  output <- .iot$create_keys_and_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_keys_and_certificate <- iot_create_keys_and_certificate

#' Creates an AWS IoT OTAUpdate on a target group of things or groups
#'
#' Creates an AWS IoT OTAUpdate on a target group of things or groups.
#'
#' @usage
#' iot_create_ota_update(otaUpdateId, description, targets,
#'   targetSelection, awsJobExecutionsRolloutConfig, files, roleArn,
#'   additionalParameters, tags)
#'
#' @param otaUpdateId &#91;required&#93; The ID of the OTA update to be created.
#' @param description The description of the OTA update.
#' @param targets &#91;required&#93; The targeted devices to receive OTA updates.
#' @param targetSelection Specifies whether the update will continue to run (CONTINUOUS), or will
#' be complete after all the things specified as targets have completed the
#' update (SNAPSHOT). If continuous, the update may also be run on a thing
#' when a change is detected in a target. For example, an update will run
#' on a thing when the thing is added to a target group, even after the
#' update was completed by all things originally in the group. Valid
#' values: CONTINUOUS \\| SNAPSHOT.
#' @param awsJobExecutionsRolloutConfig Configuration for the rollout of OTA updates.
#' @param files &#91;required&#93; The files to be streamed by the OTA update.
#' @param roleArn &#91;required&#93; The IAM role that allows access to the AWS IoT Jobs service.
#' @param additionalParameters A list of additional OTA update parameters which are name-value pairs.
#' @param tags Metadata which can be used to manage updates.
#'
#' @section Request syntax:
#' ```
#' svc$create_ota_update(
#'   otaUpdateId = "string",
#'   description = "string",
#'   targets = list(
#'     "string"
#'   ),
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   awsJobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123
#'   ),
#'   files = list(
#'     list(
#'       fileName = "string",
#'       fileVersion = "string",
#'       fileLocation = list(
#'         stream = list(
#'           streamId = "string",
#'           fileId = 123
#'         ),
#'         s3Location = list(
#'           bucket = "string",
#'           key = "string",
#'           version = "string"
#'         )
#'       ),
#'       codeSigning = list(
#'         awsSignerJobId = "string",
#'         startSigningJobParameter = list(
#'           signingProfileParameter = list(
#'             certificateArn = "string",
#'             platform = "string",
#'             certificatePathOnDevice = "string"
#'           ),
#'           signingProfileName = "string",
#'           destination = list(
#'             s3Destination = list(
#'               bucket = "string",
#'               prefix = "string"
#'             )
#'           )
#'         ),
#'         customCodeSigning = list(
#'           signature = list(
#'             inlineDocument = raw
#'           ),
#'           certificateChain = list(
#'             certificateName = "string",
#'             inlineDocument = "string"
#'           ),
#'           hashAlgorithm = "string",
#'           signatureAlgorithm = "string"
#'         )
#'       ),
#'       attributes = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string",
#'   additionalParameters = list(
#'     "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_ota_update
iot_create_ota_update <- function(otaUpdateId, description = NULL, targets, targetSelection = NULL, awsJobExecutionsRolloutConfig = NULL, files, roleArn, additionalParameters = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateOTAUpdate",
    http_method = "POST",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$create_ota_update_input(otaUpdateId = otaUpdateId, description = description, targets = targets, targetSelection = targetSelection, awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig, files = files, roleArn = roleArn, additionalParameters = additionalParameters, tags = tags)
  output <- .iot$create_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_ota_update <- iot_create_ota_update

#' Creates an AWS IoT policy
#'
#' Creates an AWS IoT policy.
#' 
#' The created policy is the default version for the policy. This operation
#' creates a policy version with a version identifier of **1** and sets
#' **1** as the policy\'s default version.
#'
#' @usage
#' iot_create_policy(policyName, policyDocument)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyDocument &#91;required&#93; The JSON document that describes the policy. **policyDocument** must
#' have a minimum length of 1, with a maximum length of 2048, excluding
#' whitespace.
#'
#' @section Request syntax:
#' ```
#' svc$create_policy(
#'   policyName = "string",
#'   policyDocument = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_policy
iot_create_policy <- function(policyName, policyDocument) {
  op <- new_operation(
    name = "CreatePolicy",
    http_method = "POST",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$create_policy_input(policyName = policyName, policyDocument = policyDocument)
  output <- .iot$create_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_policy <- iot_create_policy

#' Creates a new version of the specified AWS IoT policy
#'
#' Creates a new version of the specified AWS IoT policy. To update a
#' policy, create a new policy version. A managed policy can have up to
#' five versions. If the policy has five versions, you must use
#' DeletePolicyVersion to delete an existing version before you create a
#' new one.
#' 
#' Optionally, you can set the new version as the policy\'s default
#' version. The default version is the operative version (that is, the
#' version that is in effect for the certificates to which the policy is
#' attached).
#'
#' @usage
#' iot_create_policy_version(policyName, policyDocument, setAsDefault)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyDocument &#91;required&#93; The JSON document that describes the policy. Minimum length of 1.
#' Maximum length of 2048, excluding whitespace.
#' @param setAsDefault Specifies whether the policy version is set as the default. When this
#' parameter is true, the new policy version becomes the operative version
#' (that is, the version that is in effect for the certificates to which
#' the policy is attached).
#'
#' @section Request syntax:
#' ```
#' svc$create_policy_version(
#'   policyName = "string",
#'   policyDocument = "string",
#'   setAsDefault = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_policy_version
iot_create_policy_version <- function(policyName, policyDocument, setAsDefault = NULL) {
  op <- new_operation(
    name = "CreatePolicyVersion",
    http_method = "POST",
    http_path = "/policies/{policyName}/version",
    paginator = list()
  )
  input <- .iot$create_policy_version_input(policyName = policyName, policyDocument = policyDocument, setAsDefault = setAsDefault)
  output <- .iot$create_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_policy_version <- iot_create_policy_version

#' Creates a role alias
#'
#' Creates a role alias.
#'
#' @usage
#' iot_create_role_alias(roleAlias, roleArn, credentialDurationSeconds)
#'
#' @param roleAlias &#91;required&#93; The role alias that points to a role ARN. This allows you to change the
#' role without having to update the device.
#' @param roleArn &#91;required&#93; The role ARN.
#' @param credentialDurationSeconds How long (in seconds) the credentials will be valid.
#'
#' @section Request syntax:
#' ```
#' svc$create_role_alias(
#'   roleAlias = "string",
#'   roleArn = "string",
#'   credentialDurationSeconds = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_role_alias
iot_create_role_alias <- function(roleAlias, roleArn, credentialDurationSeconds = NULL) {
  op <- new_operation(
    name = "CreateRoleAlias",
    http_method = "POST",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$create_role_alias_input(roleAlias = roleAlias, roleArn = roleArn, credentialDurationSeconds = credentialDurationSeconds)
  output <- .iot$create_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_role_alias <- iot_create_role_alias

#' Creates a scheduled audit that is run at a specified time interval
#'
#' Creates a scheduled audit that is run at a specified time interval.
#'
#' @usage
#' iot_create_scheduled_audit(frequency, dayOfMonth, dayOfWeek,
#'   targetCheckNames, tags, scheduledAuditName)
#'
#' @param frequency &#91;required&#93; How often the scheduled audit takes place. Can be one of \"DAILY\",
#' \"WEEKLY\", \"BIWEEKLY\" or \"MONTHLY\". The actual start time of each
#' audit is determined by the system.
#' @param dayOfMonth The day of the month on which the scheduled audit takes place. Can be
#' \"1\" through \"31\" or \"LAST\". This field is required if the
#' \"frequency\" parameter is set to \"MONTHLY\". If days 29-31 are
#' specified, and the month does not have that many days, the audit takes
#' place on the \"LAST\" day of the month.
#' @param dayOfWeek The day of the week on which the scheduled audit takes place. Can be one
#' of \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\" or \"SAT\". This
#' field is required if the \"frequency\" parameter is set to \"WEEKLY\" or
#' \"BIWEEKLY\".
#' @param targetCheckNames &#91;required&#93; Which checks are performed during the scheduled audit. Checks must be
#' enabled for your account. (Use `DescribeAccountAuditConfiguration` to
#' see the list of all checks including those that are enabled or
#' `UpdateAccountAuditConfiguration` to select which checks are enabled.)
#' @param tags Metadata which can be used to manage the scheduled audit.
#' @param scheduledAuditName &#91;required&#93; The name you want to give to the scheduled audit. (Max. 128 chars)
#'
#' @section Request syntax:
#' ```
#' svc$create_scheduled_audit(
#'   frequency = "DAILY"|"WEEKLY"|"BIWEEKLY"|"MONTHLY",
#'   dayOfMonth = "string",
#'   dayOfWeek = "SUN"|"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT",
#'   targetCheckNames = list(
#'     "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_scheduled_audit
iot_create_scheduled_audit <- function(frequency, dayOfMonth = NULL, dayOfWeek = NULL, targetCheckNames, tags = NULL, scheduledAuditName) {
  op <- new_operation(
    name = "CreateScheduledAudit",
    http_method = "POST",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$create_scheduled_audit_input(frequency = frequency, dayOfMonth = dayOfMonth, dayOfWeek = dayOfWeek, targetCheckNames = targetCheckNames, tags = tags, scheduledAuditName = scheduledAuditName)
  output <- .iot$create_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_scheduled_audit <- iot_create_scheduled_audit

#' Creates a Device Defender security profile
#'
#' Creates a Device Defender security profile.
#'
#' @usage
#' iot_create_security_profile(securityProfileName,
#'   securityProfileDescription, behaviors, alertTargets,
#'   additionalMetricsToRetain, tags)
#'
#' @param securityProfileName &#91;required&#93; The name you are giving to the security profile.
#' @param securityProfileDescription A description of the security profile.
#' @param behaviors Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#' @param alertTargets Specifies the destinations to which alerts are sent. (Alerts are always
#' sent to the console.) Alerts are generated when a device (thing)
#' violates a behavior.
#' @param additionalMetricsToRetain A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile\'s `behaviors` but it is
#' also retained for any metric specified here.
#' @param tags Metadata which can be used to manage the security profile.
#'
#' @section Request syntax:
#' ```
#' svc$create_security_profile(
#'   securityProfileName = "string",
#'   securityProfileDescription = "string",
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         )
#'       )
#'     )
#'   ),
#'   alertTargets = list(
#'     list(
#'       alertTargetArn = "string",
#'       roleArn = "string"
#'     )
#'   ),
#'   additionalMetricsToRetain = list(
#'     "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_security_profile
iot_create_security_profile <- function(securityProfileName, securityProfileDescription = NULL, behaviors = NULL, alertTargets = NULL, additionalMetricsToRetain = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateSecurityProfile",
    http_method = "POST",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$create_security_profile_input(securityProfileName = securityProfileName, securityProfileDescription = securityProfileDescription, behaviors = behaviors, alertTargets = alertTargets, additionalMetricsToRetain = additionalMetricsToRetain, tags = tags)
  output <- .iot$create_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_security_profile <- iot_create_security_profile

#' Creates a stream for delivering one or more large files in chunks over
#' MQTT
#'
#' Creates a stream for delivering one or more large files in chunks over
#' MQTT. A stream transports data bytes in chunks or blocks packaged as
#' MQTT messages from a source like S3. You can have one or more files
#' associated with a stream. The total size of a file associated with the
#' stream cannot exceed more than 2 MB. The stream will be created with
#' version 0. If a stream is created with the same streamID as a stream
#' that existed and was deleted within last 90 days, we will resurrect that
#' old stream by incrementing the version by 1.
#'
#' @usage
#' iot_create_stream(streamId, description, files, roleArn, tags)
#'
#' @param streamId &#91;required&#93; The stream ID.
#' @param description A description of the stream.
#' @param files &#91;required&#93; The files to stream.
#' @param roleArn &#91;required&#93; An IAM role that allows the IoT service principal assumes to access your
#' S3 files.
#' @param tags Metadata which can be used to manage streams.
#'
#' @section Request syntax:
#' ```
#' svc$create_stream(
#'   streamId = "string",
#'   description = "string",
#'   files = list(
#'     list(
#'       fileId = 123,
#'       s3Location = list(
#'         bucket = "string",
#'         key = "string",
#'         version = "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_stream
iot_create_stream <- function(streamId, description = NULL, files, roleArn, tags = NULL) {
  op <- new_operation(
    name = "CreateStream",
    http_method = "POST",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$create_stream_input(streamId = streamId, description = description, files = files, roleArn = roleArn, tags = tags)
  output <- .iot$create_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_stream <- iot_create_stream

#' Creates a thing record in the registry
#'
#' Creates a thing record in the registry. If this call is made multiple
#' times using the same thing name and configuration, the call will
#' succeed. If this call is made with the same thing name but different
#' configuration a `ResourceAlreadyExistsException` is thrown.
#' 
#' This is a control plane operation. See
#' [Authorization](https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html)
#' for information about authorizing control plane actions.
#'
#' @usage
#' iot_create_thing(thingName, thingTypeName, attributePayload,
#'   billingGroupName)
#'
#' @param thingName &#91;required&#93; The name of the thing to create.
#' @param thingTypeName The name of the thing type associated with the new thing.
#' @param attributePayload The attribute payload, which consists of up to three name/value pairs in
#' a JSON document. For example:
#' 
#' `\{\"attributes\":\{\"string1\":\"string2\"\}\}`
#' @param billingGroupName The name of the billing group the thing will be added to.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing(
#'   thingName = "string",
#'   thingTypeName = "string",
#'   attributePayload = list(
#'     attributes = list(
#'       "string"
#'     ),
#'     merge = TRUE|FALSE
#'   ),
#'   billingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing
iot_create_thing <- function(thingName, thingTypeName = NULL, attributePayload = NULL, billingGroupName = NULL) {
  op <- new_operation(
    name = "CreateThing",
    http_method = "POST",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$create_thing_input(thingName = thingName, thingTypeName = thingTypeName, attributePayload = attributePayload, billingGroupName = billingGroupName)
  output <- .iot$create_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing <- iot_create_thing

#' Create a thing group
#'
#' Create a thing group.
#' 
#' This is a control plane operation. See
#' [Authorization](https://docs.aws.amazon.com/iot/latest/developerguide/authorization.html)
#' for information about authorizing control plane actions.
#'
#' @usage
#' iot_create_thing_group(thingGroupName, parentGroupName,
#'   thingGroupProperties, tags)
#'
#' @param thingGroupName &#91;required&#93; The thing group name to create.
#' @param parentGroupName The name of the parent thing group.
#' @param thingGroupProperties The thing group properties.
#' @param tags Metadata which can be used to manage the thing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing_group(
#'   thingGroupName = "string",
#'   parentGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing_group
iot_create_thing_group <- function(thingGroupName, parentGroupName = NULL, thingGroupProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateThingGroup",
    http_method = "POST",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$create_thing_group_input(thingGroupName = thingGroupName, parentGroupName = parentGroupName, thingGroupProperties = thingGroupProperties, tags = tags)
  output <- .iot$create_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing_group <- iot_create_thing_group

#' Creates a new thing type
#'
#' Creates a new thing type.
#'
#' @usage
#' iot_create_thing_type(thingTypeName, thingTypeProperties, tags)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#' @param thingTypeProperties The ThingTypeProperties for the thing type to create. It contains
#' information about the new thing type including a description, and a list
#' of searchable thing attribute names.
#' @param tags Metadata which can be used to manage the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing_type(
#'   thingTypeName = "string",
#'   thingTypeProperties = list(
#'     thingTypeDescription = "string",
#'     searchableAttributes = list(
#'       "string"
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing_type
iot_create_thing_type <- function(thingTypeName, thingTypeProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateThingType",
    http_method = "POST",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$create_thing_type_input(thingTypeName = thingTypeName, thingTypeProperties = thingTypeProperties, tags = tags)
  output <- .iot$create_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing_type <- iot_create_thing_type

#' Creates a rule
#'
#' Creates a rule. Creating rules is an administrator-level action. Any
#' user who has permission to create rules will be able to access data
#' processed by the rule.
#'
#' @usage
#' iot_create_topic_rule(ruleName, topicRulePayload, tags)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#' @param topicRulePayload &#91;required&#93; The rule payload.
#' @param tags Metadata which can be used to manage the topic rule.
#' 
#' For URI Request parameters use format: \\...key1=value1&key2=value2\\...
#' 
#' For the CLI command-line parameter use format: \\--tags
#' \"key1=value1&key2=value2\\...\"
#' 
#' For the cli-input-json file use format: \"tags\":
#' \"key1=value1&key2=value2\\...\"
#'
#' @section Request syntax:
#' ```
#' svc$create_topic_rule(
#'   ruleName = "string",
#'   topicRulePayload = list(
#'     sql = "string",
#'     description = "string",
#'     actions = list(
#'       list(
#'         dynamoDB = list(
#'           tableName = "string",
#'           roleArn = "string",
#'           operation = "string",
#'           hashKeyField = "string",
#'           hashKeyValue = "string",
#'           hashKeyType = "STRING"|"NUMBER",
#'           rangeKeyField = "string",
#'           rangeKeyValue = "string",
#'           rangeKeyType = "STRING"|"NUMBER",
#'           payloadField = "string"
#'         ),
#'         dynamoDBv2 = list(
#'           roleArn = "string",
#'           putItem = list(
#'             tableName = "string"
#'           )
#'         ),
#'         lambda = list(
#'           functionArn = "string"
#'         ),
#'         sns = list(
#'           targetArn = "string",
#'           roleArn = "string",
#'           messageFormat = "RAW"|"JSON"
#'         ),
#'         sqs = list(
#'           roleArn = "string",
#'           queueUrl = "string",
#'           useBase64 = TRUE|FALSE
#'         ),
#'         kinesis = list(
#'           roleArn = "string",
#'           streamName = "string",
#'           partitionKey = "string"
#'         ),
#'         republish = list(
#'           roleArn = "string",
#'           topic = "string"
#'         ),
#'         s3 = list(
#'           roleArn = "string",
#'           bucketName = "string",
#'           key = "string",
#'           cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'         ),
#'         firehose = list(
#'           roleArn = "string",
#'           deliveryStreamName = "string",
#'           separator = "string"
#'         ),
#'         cloudwatchMetric = list(
#'           roleArn = "string",
#'           metricNamespace = "string",
#'           metricName = "string",
#'           metricValue = "string",
#'           metricUnit = "string",
#'           metricTimestamp = "string"
#'         ),
#'         cloudwatchAlarm = list(
#'           roleArn = "string",
#'           alarmName = "string",
#'           stateReason = "string",
#'           stateValue = "string"
#'         ),
#'         elasticsearch = list(
#'           roleArn = "string",
#'           endpoint = "string",
#'           index = "string",
#'           type = "string",
#'           id = "string"
#'         ),
#'         salesforce = list(
#'           token = "string",
#'           url = "string"
#'         ),
#'         iotAnalytics = list(
#'           channelArn = "string",
#'           channelName = "string",
#'           roleArn = "string"
#'         ),
#'         iotEvents = list(
#'           inputName = "string",
#'           messageId = "string",
#'           roleArn = "string"
#'         ),
#'         stepFunctions = list(
#'           executionNamePrefix = "string",
#'           stateMachineName = "string",
#'           roleArn = "string"
#'         )
#'       )
#'     ),
#'     ruleDisabled = TRUE|FALSE,
#'     awsIotSqlVersion = "string",
#'     errorAction = list(
#'       dynamoDB = list(
#'         tableName = "string",
#'         roleArn = "string",
#'         operation = "string",
#'         hashKeyField = "string",
#'         hashKeyValue = "string",
#'         hashKeyType = "STRING"|"NUMBER",
#'         rangeKeyField = "string",
#'         rangeKeyValue = "string",
#'         rangeKeyType = "STRING"|"NUMBER",
#'         payloadField = "string"
#'       ),
#'       dynamoDBv2 = list(
#'         roleArn = "string",
#'         putItem = list(
#'           tableName = "string"
#'         )
#'       ),
#'       lambda = list(
#'         functionArn = "string"
#'       ),
#'       sns = list(
#'         targetArn = "string",
#'         roleArn = "string",
#'         messageFormat = "RAW"|"JSON"
#'       ),
#'       sqs = list(
#'         roleArn = "string",
#'         queueUrl = "string",
#'         useBase64 = TRUE|FALSE
#'       ),
#'       kinesis = list(
#'         roleArn = "string",
#'         streamName = "string",
#'         partitionKey = "string"
#'       ),
#'       republish = list(
#'         roleArn = "string",
#'         topic = "string"
#'       ),
#'       s3 = list(
#'         roleArn = "string",
#'         bucketName = "string",
#'         key = "string",
#'         cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'       ),
#'       firehose = list(
#'         roleArn = "string",
#'         deliveryStreamName = "string",
#'         separator = "string"
#'       ),
#'       cloudwatchMetric = list(
#'         roleArn = "string",
#'         metricNamespace = "string",
#'         metricName = "string",
#'         metricValue = "string",
#'         metricUnit = "string",
#'         metricTimestamp = "string"
#'       ),
#'       cloudwatchAlarm = list(
#'         roleArn = "string",
#'         alarmName = "string",
#'         stateReason = "string",
#'         stateValue = "string"
#'       ),
#'       elasticsearch = list(
#'         roleArn = "string",
#'         endpoint = "string",
#'         index = "string",
#'         type = "string",
#'         id = "string"
#'       ),
#'       salesforce = list(
#'         token = "string",
#'         url = "string"
#'       ),
#'       iotAnalytics = list(
#'         channelArn = "string",
#'         channelName = "string",
#'         roleArn = "string"
#'       ),
#'       iotEvents = list(
#'         inputName = "string",
#'         messageId = "string",
#'         roleArn = "string"
#'       ),
#'       stepFunctions = list(
#'         executionNamePrefix = "string",
#'         stateMachineName = "string",
#'         roleArn = "string"
#'       )
#'     )
#'   ),
#'   tags = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_topic_rule
iot_create_topic_rule <- function(ruleName, topicRulePayload, tags = NULL) {
  op <- new_operation(
    name = "CreateTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$create_topic_rule_input(ruleName = ruleName, topicRulePayload = topicRulePayload, tags = tags)
  output <- .iot$create_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_topic_rule <- iot_create_topic_rule

#' Restores the default settings for Device Defender audits for this
#' account
#'
#' Restores the default settings for Device Defender audits for this
#' account. Any configuration data you entered is deleted and all audit
#' checks are reset to disabled.
#'
#' @usage
#' iot_delete_account_audit_configuration(deleteScheduledAudits)
#'
#' @param deleteScheduledAudits If true, all scheduled audits are deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_account_audit_configuration(
#'   deleteScheduledAudits = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_account_audit_configuration
iot_delete_account_audit_configuration <- function(deleteScheduledAudits = NULL) {
  op <- new_operation(
    name = "DeleteAccountAuditConfiguration",
    http_method = "DELETE",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$delete_account_audit_configuration_input(deleteScheduledAudits = deleteScheduledAudits)
  output <- .iot$delete_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_account_audit_configuration <- iot_delete_account_audit_configuration

#' Deletes an authorizer
#'
#' Deletes an authorizer.
#'
#' @usage
#' iot_delete_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The name of the authorizer to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_authorizer
iot_delete_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "DeleteAuthorizer",
    http_method = "DELETE",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$delete_authorizer_input(authorizerName = authorizerName)
  output <- .iot$delete_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_authorizer <- iot_delete_authorizer

#' Deletes the billing group
#'
#' Deletes the billing group.
#'
#' @usage
#' iot_delete_billing_group(billingGroupName, expectedVersion)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param expectedVersion The expected version of the billing group. If the version of the billing
#' group does not match the expected version specified in the request, the
#' `DeleteBillingGroup` request is rejected with a
#' `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$delete_billing_group(
#'   billingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_billing_group
iot_delete_billing_group <- function(billingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteBillingGroup",
    http_method = "DELETE",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_billing_group_input(billingGroupName = billingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_billing_group <- iot_delete_billing_group

#' Deletes a registered CA certificate
#'
#' Deletes a registered CA certificate.
#'
#' @usage
#' iot_delete_ca_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate to delete. (The last part of the certificate
#' ARN contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$delete_ca_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_ca_certificate
iot_delete_ca_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DeleteCACertificate",
    http_method = "DELETE",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$delete_ca_certificate_input(certificateId = certificateId)
  output <- .iot$delete_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_ca_certificate <- iot_delete_ca_certificate

#' Deletes the specified certificate
#'
#' Deletes the specified certificate.
#' 
#' A certificate cannot be deleted if it has a policy attached to it or if
#' its status is set to ACTIVE. To delete a certificate, first use the
#' DetachPrincipalPolicy API to detach all policies. Next, use the
#' UpdateCertificate API to set the certificate to the INACTIVE status.
#'
#' @usage
#' iot_delete_certificate(certificateId, forceDelete)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param forceDelete Forces a certificate request to be deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_certificate(
#'   certificateId = "string",
#'   forceDelete = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_certificate
iot_delete_certificate <- function(certificateId, forceDelete = NULL) {
  op <- new_operation(
    name = "DeleteCertificate",
    http_method = "DELETE",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$delete_certificate_input(certificateId = certificateId, forceDelete = forceDelete)
  output <- .iot$delete_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_certificate <- iot_delete_certificate

#' Deletes a dynamic thing group
#'
#' Deletes a dynamic thing group.
#'
#' @usage
#' iot_delete_dynamic_thing_group(thingGroupName, expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the dynamic thing group to delete.
#' @param expectedVersion The expected version of the dynamic thing group to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_dynamic_thing_group(
#'   thingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_dynamic_thing_group
iot_delete_dynamic_thing_group <- function(thingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteDynamicThingGroup",
    http_method = "DELETE",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_dynamic_thing_group_input(thingGroupName = thingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_dynamic_thing_group <- iot_delete_dynamic_thing_group

#' Deletes a job and its related job executions
#'
#' Deletes a job and its related job executions.
#' 
#' Deleting a job may take time, depending on the number of job executions
#' created for the job and various other factors. While the job is being
#' deleted, the status of the job will be shown as
#' \"DELETION\\_IN\\_PROGRESS\". Attempting to delete or cancel a job whose
#' status is already \"DELETION\\_IN\\_PROGRESS\" will result in an error.
#' 
#' Only 10 jobs may have status \"DELETION\\_IN\\_PROGRESS\" at the same
#' time, or a LimitExceededException will occur.
#'
#' @usage
#' iot_delete_job(jobId, force)
#'
#' @param jobId &#91;required&#93; The ID of the job to be deleted.
#' 
#' After a job deletion is completed, you may reuse this jobId when you
#' create a new job. However, this is not recommended, and you must ensure
#' that your devices are not using the jobId to refer to the deleted job.
#' @param force (Optional) When true, you can delete a job which is \"IN\\_PROGRESS\".
#' Otherwise, you can only delete a job which is in a terminal state
#' (\"COMPLETED\" or \"CANCELED\") or an exception will occur. The default
#' is false.
#' 
#' Deleting a job which is \"IN\\_PROGRESS\", will cause a device which is
#' executing the job to be unable to access job information or update the
#' job execution status. Use caution and ensure that each device executing
#' a job which is deleted is able to recover to a valid state.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   jobId = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_job
iot_delete_job <- function(jobId, force = NULL) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "DELETE",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$delete_job_input(jobId = jobId, force = force)
  output <- .iot$delete_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_job <- iot_delete_job

#' Deletes a job execution
#'
#' Deletes a job execution.
#'
#' @usage
#' iot_delete_job_execution(jobId, thingName, executionNumber, force)
#'
#' @param jobId &#91;required&#93; The ID of the job whose execution on a particular device will be
#' deleted.
#' @param thingName &#91;required&#93; The name of the thing whose job execution will be deleted.
#' @param executionNumber &#91;required&#93; The ID of the job execution to be deleted. The `executionNumber` refers
#' to the execution of a particular job on a particular device.
#' 
#' Note that once a job execution is deleted, the `executionNumber` may be
#' reused by IoT, so be sure you get and use the correct value here.
#' @param force (Optional) When true, you can delete a job execution which is
#' \"IN\\_PROGRESS\". Otherwise, you can only delete a job execution which
#' is in a terminal state (\"SUCCEEDED\", \"FAILED\", \"REJECTED\",
#' \"REMOVED\" or \"CANCELED\") or an exception will occur. The default is
#' false.
#' 
#' Deleting a job execution which is \"IN\\_PROGRESS\", will cause the
#' device to be unable to access job information or update the job
#' execution status. Use caution and ensure that the device is able to
#' recover to a valid state.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   executionNumber = 123,
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_job_execution
iot_delete_job_execution <- function(jobId, thingName, executionNumber, force = NULL) {
  op <- new_operation(
    name = "DeleteJobExecution",
    http_method = "DELETE",
    http_path = "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    paginator = list()
  )
  input <- .iot$delete_job_execution_input(jobId = jobId, thingName = thingName, executionNumber = executionNumber, force = force)
  output <- .iot$delete_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_job_execution <- iot_delete_job_execution

#' Delete an OTA update
#'
#' Delete an OTA update.
#'
#' @usage
#' iot_delete_ota_update(otaUpdateId, deleteStream, forceDeleteAWSJob)
#'
#' @param otaUpdateId &#91;required&#93; The OTA update ID to delete.
#' @param deleteStream Specifies if the stream associated with an OTA update should be deleted
#' when the OTA update is deleted.
#' @param forceDeleteAWSJob Specifies if the AWS Job associated with the OTA update should be
#' deleted with the OTA update is deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_ota_update(
#'   otaUpdateId = "string",
#'   deleteStream = TRUE|FALSE,
#'   forceDeleteAWSJob = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_ota_update
iot_delete_ota_update <- function(otaUpdateId, deleteStream = NULL, forceDeleteAWSJob = NULL) {
  op <- new_operation(
    name = "DeleteOTAUpdate",
    http_method = "DELETE",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$delete_ota_update_input(otaUpdateId = otaUpdateId, deleteStream = deleteStream, forceDeleteAWSJob = forceDeleteAWSJob)
  output <- .iot$delete_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_ota_update <- iot_delete_ota_update

#' Deletes the specified policy
#'
#' Deletes the specified policy.
#' 
#' A policy cannot be deleted if it has non-default versions or it is
#' attached to any certificate.
#' 
#' To delete a policy, use the DeletePolicyVersion API to delete all
#' non-default versions of the policy; use the DetachPrincipalPolicy API to
#' detach the policy from any certificate; and then use the DeletePolicy
#' API to delete the policy.
#' 
#' When a policy is deleted using DeletePolicy, its default version is
#' deleted with it.
#'
#' @usage
#' iot_delete_policy(policyName)
#'
#' @param policyName &#91;required&#93; The name of the policy to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_policy
iot_delete_policy <- function(policyName) {
  op <- new_operation(
    name = "DeletePolicy",
    http_method = "DELETE",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$delete_policy_input(policyName = policyName)
  output <- .iot$delete_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_policy <- iot_delete_policy

#' Deletes the specified version of the specified policy
#'
#' Deletes the specified version of the specified policy. You cannot delete
#' the default version of a policy using this API. To delete the default
#' version of a policy, use DeletePolicy. To find out which version of a
#' policy is marked as the default version, use ListPolicyVersions.
#'
#' @usage
#' iot_delete_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_policy_version
iot_delete_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "DeletePolicyVersion",
    http_method = "DELETE",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$delete_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$delete_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_policy_version <- iot_delete_policy_version

#' Deletes a CA certificate registration code
#'
#' Deletes a CA certificate registration code.
#'
#' @usage
#' iot_delete_registration_code()
#'
#' @section Request syntax:
#' ```
#' svc$delete_registration_code()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_registration_code
iot_delete_registration_code <- function() {
  op <- new_operation(
    name = "DeleteRegistrationCode",
    http_method = "DELETE",
    http_path = "/registrationcode",
    paginator = list()
  )
  input <- .iot$delete_registration_code_input()
  output <- .iot$delete_registration_code_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_registration_code <- iot_delete_registration_code

#' Deletes a role alias
#'
#' Deletes a role alias
#'
#' @usage
#' iot_delete_role_alias(roleAlias)
#'
#' @param roleAlias &#91;required&#93; The role alias to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_role_alias(
#'   roleAlias = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_role_alias
iot_delete_role_alias <- function(roleAlias) {
  op <- new_operation(
    name = "DeleteRoleAlias",
    http_method = "DELETE",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$delete_role_alias_input(roleAlias = roleAlias)
  output <- .iot$delete_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_role_alias <- iot_delete_role_alias

#' Deletes a scheduled audit
#'
#' Deletes a scheduled audit.
#'
#' @usage
#' iot_delete_scheduled_audit(scheduledAuditName)
#'
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit you want to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_scheduled_audit(
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_scheduled_audit
iot_delete_scheduled_audit <- function(scheduledAuditName) {
  op <- new_operation(
    name = "DeleteScheduledAudit",
    http_method = "DELETE",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$delete_scheduled_audit_input(scheduledAuditName = scheduledAuditName)
  output <- .iot$delete_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_scheduled_audit <- iot_delete_scheduled_audit

#' Deletes a Device Defender security profile
#'
#' Deletes a Device Defender security profile.
#'
#' @usage
#' iot_delete_security_profile(securityProfileName, expectedVersion)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile to be deleted.
#' @param expectedVersion The expected version of the security profile. A new version is generated
#' whenever the security profile is updated. If you specify a value that is
#' different than the actual version, a `VersionConflictException` is
#' thrown.
#'
#' @section Request syntax:
#' ```
#' svc$delete_security_profile(
#'   securityProfileName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_security_profile
iot_delete_security_profile <- function(securityProfileName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteSecurityProfile",
    http_method = "DELETE",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$delete_security_profile_input(securityProfileName = securityProfileName, expectedVersion = expectedVersion)
  output <- .iot$delete_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_security_profile <- iot_delete_security_profile

#' Deletes a stream
#'
#' Deletes a stream.
#'
#' @usage
#' iot_delete_stream(streamId)
#'
#' @param streamId &#91;required&#93; The stream ID.
#'
#' @section Request syntax:
#' ```
#' svc$delete_stream(
#'   streamId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_stream
iot_delete_stream <- function(streamId) {
  op <- new_operation(
    name = "DeleteStream",
    http_method = "DELETE",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$delete_stream_input(streamId = streamId)
  output <- .iot$delete_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_stream <- iot_delete_stream

#' Deletes the specified thing
#'
#' Deletes the specified thing. Returns successfully with no error if the
#' deletion is successful or you specify a thing that doesn\'t exist.
#'
#' @usage
#' iot_delete_thing(thingName, expectedVersion)
#'
#' @param thingName &#91;required&#93; The name of the thing to delete.
#' @param expectedVersion The expected version of the thing record in the registry. If the version
#' of the record in the registry does not match the expected version
#' specified in the request, the `DeleteThing` request is rejected with a
#' `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing(
#'   thingName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing
iot_delete_thing <- function(thingName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteThing",
    http_method = "DELETE",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$delete_thing_input(thingName = thingName, expectedVersion = expectedVersion)
  output <- .iot$delete_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing <- iot_delete_thing

#' Deletes a thing group
#'
#' Deletes a thing group.
#'
#' @usage
#' iot_delete_thing_group(thingGroupName, expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the thing group to delete.
#' @param expectedVersion The expected version of the thing group to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing_group(
#'   thingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing_group
iot_delete_thing_group <- function(thingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteThingGroup",
    http_method = "DELETE",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_thing_group_input(thingGroupName = thingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing_group <- iot_delete_thing_group

#' Deletes the specified thing type
#'
#' Deletes the specified thing type. You cannot delete a thing type if it
#' has things associated with it. To delete a thing type, first mark it as
#' deprecated by calling DeprecateThingType, then remove any associated
#' things by calling UpdateThing to change the thing type on any associated
#' thing, and finally use DeleteThingType to delete the thing type.
#'
#' @usage
#' iot_delete_thing_type(thingTypeName)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing_type(
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing_type
iot_delete_thing_type <- function(thingTypeName) {
  op <- new_operation(
    name = "DeleteThingType",
    http_method = "DELETE",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$delete_thing_type_input(thingTypeName = thingTypeName)
  output <- .iot$delete_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing_type <- iot_delete_thing_type

#' Deletes the rule
#'
#' Deletes the rule.
#'
#' @usage
#' iot_delete_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#'
#' @section Request syntax:
#' ```
#' svc$delete_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_topic_rule
iot_delete_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "DeleteTopicRule",
    http_method = "DELETE",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$delete_topic_rule_input(ruleName = ruleName)
  output <- .iot$delete_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_topic_rule <- iot_delete_topic_rule

#' Deletes a logging level
#'
#' Deletes a logging level.
#'
#' @usage
#' iot_delete_v2_logging_level(targetType, targetName)
#'
#' @param targetType &#91;required&#93; The type of resource for which you are configuring logging. Must be
#' `THING_Group`.
#' @param targetName &#91;required&#93; The name of the resource for which you are configuring logging.
#'
#' @section Request syntax:
#' ```
#' svc$delete_v2_logging_level(
#'   targetType = "DEFAULT"|"THING_GROUP",
#'   targetName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_v2_logging_level
iot_delete_v2_logging_level <- function(targetType, targetName) {
  op <- new_operation(
    name = "DeleteV2LoggingLevel",
    http_method = "DELETE",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$delete_v2_logging_level_input(targetType = targetType, targetName = targetName)
  output <- .iot$delete_v2_logging_level_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_v2_logging_level <- iot_delete_v2_logging_level

#' Deprecates a thing type
#'
#' Deprecates a thing type. You can not associate new things with
#' deprecated thing type.
#'
#' @usage
#' iot_deprecate_thing_type(thingTypeName, undoDeprecate)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type to deprecate.
#' @param undoDeprecate Whether to undeprecate a deprecated thing type. If **true**, the thing
#' type will not be deprecated anymore and you can associate it with
#' things.
#'
#' @section Request syntax:
#' ```
#' svc$deprecate_thing_type(
#'   thingTypeName = "string",
#'   undoDeprecate = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_deprecate_thing_type
iot_deprecate_thing_type <- function(thingTypeName, undoDeprecate = NULL) {
  op <- new_operation(
    name = "DeprecateThingType",
    http_method = "POST",
    http_path = "/thing-types/{thingTypeName}/deprecate",
    paginator = list()
  )
  input <- .iot$deprecate_thing_type_input(thingTypeName = thingTypeName, undoDeprecate = undoDeprecate)
  output <- .iot$deprecate_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$deprecate_thing_type <- iot_deprecate_thing_type

#' Gets information about the Device Defender audit settings for this
#' account
#'
#' Gets information about the Device Defender audit settings for this
#' account. Settings include how audit notifications are sent and which
#' audit checks are enabled or disabled.
#'
#' @usage
#' iot_describe_account_audit_configuration()
#'
#' @section Request syntax:
#' ```
#' svc$describe_account_audit_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_account_audit_configuration
iot_describe_account_audit_configuration <- function() {
  op <- new_operation(
    name = "DescribeAccountAuditConfiguration",
    http_method = "GET",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$describe_account_audit_configuration_input()
  output <- .iot$describe_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_account_audit_configuration <- iot_describe_account_audit_configuration

#' Gets information about a Device Defender audit
#'
#' Gets information about a Device Defender audit.
#'
#' @usage
#' iot_describe_audit_task(taskId)
#'
#' @param taskId &#91;required&#93; The ID of the audit whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_audit_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_audit_task
iot_describe_audit_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeAuditTask",
    http_method = "GET",
    http_path = "/audit/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_audit_task_input(taskId = taskId)
  output <- .iot$describe_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_audit_task <- iot_describe_audit_task

#' Describes an authorizer
#'
#' Describes an authorizer.
#'
#' @usage
#' iot_describe_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The name of the authorizer to describe.
#'
#' @section Request syntax:
#' ```
#' svc$describe_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_authorizer
iot_describe_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "DescribeAuthorizer",
    http_method = "GET",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$describe_authorizer_input(authorizerName = authorizerName)
  output <- .iot$describe_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_authorizer <- iot_describe_authorizer

#' Returns information about a billing group
#'
#' Returns information about a billing group.
#'
#' @usage
#' iot_describe_billing_group(billingGroupName)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$describe_billing_group(
#'   billingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_billing_group
iot_describe_billing_group <- function(billingGroupName) {
  op <- new_operation(
    name = "DescribeBillingGroup",
    http_method = "GET",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$describe_billing_group_input(billingGroupName = billingGroupName)
  output <- .iot$describe_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_billing_group <- iot_describe_billing_group

#' Describes a registered CA certificate
#'
#' Describes a registered CA certificate.
#'
#' @usage
#' iot_describe_ca_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The CA certificate identifier.
#'
#' @section Request syntax:
#' ```
#' svc$describe_ca_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_ca_certificate
iot_describe_ca_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DescribeCACertificate",
    http_method = "GET",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$describe_ca_certificate_input(certificateId = certificateId)
  output <- .iot$describe_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_ca_certificate <- iot_describe_ca_certificate

#' Gets information about the specified certificate
#'
#' Gets information about the specified certificate.
#'
#' @usage
#' iot_describe_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$describe_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_certificate
iot_describe_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DescribeCertificate",
    http_method = "GET",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$describe_certificate_input(certificateId = certificateId)
  output <- .iot$describe_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_certificate <- iot_describe_certificate

#' Describes the default authorizer
#'
#' Describes the default authorizer.
#'
#' @usage
#' iot_describe_default_authorizer()
#'
#' @section Request syntax:
#' ```
#' svc$describe_default_authorizer()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_default_authorizer
iot_describe_default_authorizer <- function() {
  op <- new_operation(
    name = "DescribeDefaultAuthorizer",
    http_method = "GET",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$describe_default_authorizer_input()
  output <- .iot$describe_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_default_authorizer <- iot_describe_default_authorizer

#' Returns a unique endpoint specific to the AWS account making the call
#'
#' Returns a unique endpoint specific to the AWS account making the call.
#'
#' @usage
#' iot_describe_endpoint(endpointType)
#'
#' @param endpointType The endpoint type. Valid endpoint types include:
#' 
#' -   `iot:Data` - Returns a VeriSign signed data endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:Data-ATS` - Returns an ATS signed data endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:CredentialProvider` - Returns an AWS IoT credentials provider
#'     API endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:Jobs` - Returns an AWS IoT device management Jobs API endpoint.
#'
#' @section Request syntax:
#' ```
#' svc$describe_endpoint(
#'   endpointType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_endpoint
iot_describe_endpoint <- function(endpointType = NULL) {
  op <- new_operation(
    name = "DescribeEndpoint",
    http_method = "GET",
    http_path = "/endpoint",
    paginator = list()
  )
  input <- .iot$describe_endpoint_input(endpointType = endpointType)
  output <- .iot$describe_endpoint_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_endpoint <- iot_describe_endpoint

#' Describes event configurations
#'
#' Describes event configurations.
#'
#' @usage
#' iot_describe_event_configurations()
#'
#' @section Request syntax:
#' ```
#' svc$describe_event_configurations()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_event_configurations
iot_describe_event_configurations <- function() {
  op <- new_operation(
    name = "DescribeEventConfigurations",
    http_method = "GET",
    http_path = "/event-configurations",
    paginator = list()
  )
  input <- .iot$describe_event_configurations_input()
  output <- .iot$describe_event_configurations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_event_configurations <- iot_describe_event_configurations

#' Describes a search index
#'
#' Describes a search index.
#'
#' @usage
#' iot_describe_index(indexName)
#'
#' @param indexName &#91;required&#93; The index name.
#'
#' @section Request syntax:
#' ```
#' svc$describe_index(
#'   indexName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_index
iot_describe_index <- function(indexName) {
  op <- new_operation(
    name = "DescribeIndex",
    http_method = "GET",
    http_path = "/indices/{indexName}",
    paginator = list()
  )
  input <- .iot$describe_index_input(indexName = indexName)
  output <- .iot$describe_index_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_index <- iot_describe_index

#' Describes a job
#'
#' Describes a job.
#'
#' @usage
#' iot_describe_job(jobId)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#'
#' @section Request syntax:
#' ```
#' svc$describe_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_job
iot_describe_job <- function(jobId) {
  op <- new_operation(
    name = "DescribeJob",
    http_method = "GET",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$describe_job_input(jobId = jobId)
  output <- .iot$describe_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_job <- iot_describe_job

#' Describes a job execution
#'
#' Describes a job execution.
#'
#' @usage
#' iot_describe_job_execution(jobId, thingName, executionNumber)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param thingName &#91;required&#93; The name of the thing on which the job execution is running.
#' @param executionNumber A string (consisting of the digits \"0\" through \"9\" which is used to
#' specify a particular job execution on a particular device.
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   executionNumber = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_job_execution
iot_describe_job_execution <- function(jobId, thingName, executionNumber = NULL) {
  op <- new_operation(
    name = "DescribeJobExecution",
    http_method = "GET",
    http_path = "/things/{thingName}/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$describe_job_execution_input(jobId = jobId, thingName = thingName, executionNumber = executionNumber)
  output <- .iot$describe_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_job_execution <- iot_describe_job_execution

#' Describes a role alias
#'
#' Describes a role alias.
#'
#' @usage
#' iot_describe_role_alias(roleAlias)
#'
#' @param roleAlias &#91;required&#93; The role alias to describe.
#'
#' @section Request syntax:
#' ```
#' svc$describe_role_alias(
#'   roleAlias = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_role_alias
iot_describe_role_alias <- function(roleAlias) {
  op <- new_operation(
    name = "DescribeRoleAlias",
    http_method = "GET",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$describe_role_alias_input(roleAlias = roleAlias)
  output <- .iot$describe_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_role_alias <- iot_describe_role_alias

#' Gets information about a scheduled audit
#'
#' Gets information about a scheduled audit.
#'
#' @usage
#' iot_describe_scheduled_audit(scheduledAuditName)
#'
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_scheduled_audit(
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_scheduled_audit
iot_describe_scheduled_audit <- function(scheduledAuditName) {
  op <- new_operation(
    name = "DescribeScheduledAudit",
    http_method = "GET",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$describe_scheduled_audit_input(scheduledAuditName = scheduledAuditName)
  output <- .iot$describe_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_scheduled_audit <- iot_describe_scheduled_audit

#' Gets information about a Device Defender security profile
#'
#' Gets information about a Device Defender security profile.
#'
#' @usage
#' iot_describe_security_profile(securityProfileName)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_security_profile(
#'   securityProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_security_profile
iot_describe_security_profile <- function(securityProfileName) {
  op <- new_operation(
    name = "DescribeSecurityProfile",
    http_method = "GET",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$describe_security_profile_input(securityProfileName = securityProfileName)
  output <- .iot$describe_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_security_profile <- iot_describe_security_profile

#' Gets information about a stream
#'
#' Gets information about a stream.
#'
#' @usage
#' iot_describe_stream(streamId)
#'
#' @param streamId &#91;required&#93; The stream ID.
#'
#' @section Request syntax:
#' ```
#' svc$describe_stream(
#'   streamId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_stream
iot_describe_stream <- function(streamId) {
  op <- new_operation(
    name = "DescribeStream",
    http_method = "GET",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$describe_stream_input(streamId = streamId)
  output <- .iot$describe_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_stream <- iot_describe_stream

#' Gets information about the specified thing
#'
#' Gets information about the specified thing.
#'
#' @usage
#' iot_describe_thing(thingName)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing(
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing
iot_describe_thing <- function(thingName) {
  op <- new_operation(
    name = "DescribeThing",
    http_method = "GET",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$describe_thing_input(thingName = thingName)
  output <- .iot$describe_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing <- iot_describe_thing

#' Describe a thing group
#'
#' Describe a thing group.
#'
#' @usage
#' iot_describe_thing_group(thingGroupName)
#'
#' @param thingGroupName &#91;required&#93; The name of the thing group.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_group(
#'   thingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_group
iot_describe_thing_group <- function(thingGroupName) {
  op <- new_operation(
    name = "DescribeThingGroup",
    http_method = "GET",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$describe_thing_group_input(thingGroupName = thingGroupName)
  output <- .iot$describe_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_group <- iot_describe_thing_group

#' Describes a bulk thing provisioning task
#'
#' Describes a bulk thing provisioning task.
#'
#' @usage
#' iot_describe_thing_registration_task(taskId)
#'
#' @param taskId &#91;required&#93; The task ID.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_registration_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_registration_task
iot_describe_thing_registration_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeThingRegistrationTask",
    http_method = "GET",
    http_path = "/thing-registration-tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_thing_registration_task_input(taskId = taskId)
  output <- .iot$describe_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_registration_task <- iot_describe_thing_registration_task

#' Gets information about the specified thing type
#'
#' Gets information about the specified thing type.
#'
#' @usage
#' iot_describe_thing_type(thingTypeName)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_type(
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_type
iot_describe_thing_type <- function(thingTypeName) {
  op <- new_operation(
    name = "DescribeThingType",
    http_method = "GET",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$describe_thing_type_input(thingTypeName = thingTypeName)
  output <- .iot$describe_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_type <- iot_describe_thing_type

#' Detaches a policy from the specified target
#'
#' Detaches a policy from the specified target.
#'
#' @usage
#' iot_detach_policy(policyName, target)
#'
#' @param policyName &#91;required&#93; The policy to detach.
#' @param target &#91;required&#93; The target from which the policy will be detached.
#'
#' @section Request syntax:
#' ```
#' svc$detach_policy(
#'   policyName = "string",
#'   target = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_policy
iot_detach_policy <- function(policyName, target) {
  op <- new_operation(
    name = "DetachPolicy",
    http_method = "POST",
    http_path = "/target-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$detach_policy_input(policyName = policyName, target = target)
  output <- .iot$detach_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_policy <- iot_detach_policy

#' Removes the specified policy from the specified certificate
#'
#' Removes the specified policy from the specified certificate.
#' 
#' **Note:** This API is deprecated. Please use DetachPolicy instead.
#'
#' @usage
#' iot_detach_principal_policy(policyName, principal)
#'
#' @param policyName &#91;required&#93; The name of the policy to detach.
#' @param principal &#91;required&#93; The principal.
#' 
#' If the principal is a certificate, specify the certificate ARN. If the
#' principal is an Amazon Cognito identity, specify the identity ID.
#'
#' @section Request syntax:
#' ```
#' svc$detach_principal_policy(
#'   policyName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_principal_policy
iot_detach_principal_policy <- function(policyName, principal) {
  op <- new_operation(
    name = "DetachPrincipalPolicy",
    http_method = "DELETE",
    http_path = "/principal-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$detach_principal_policy_input(policyName = policyName, principal = principal)
  output <- .iot$detach_principal_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_principal_policy <- iot_detach_principal_policy

#' Disassociates a Device Defender security profile from a thing group or
#' from this account
#'
#' Disassociates a Device Defender security profile from a thing group or
#' from this account.
#'
#' @usage
#' iot_detach_security_profile(securityProfileName,
#'   securityProfileTargetArn)
#'
#' @param securityProfileName &#91;required&#93; The security profile that is detached.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the thing group from which the security profile is detached.
#'
#' @section Request syntax:
#' ```
#' svc$detach_security_profile(
#'   securityProfileName = "string",
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_security_profile
iot_detach_security_profile <- function(securityProfileName, securityProfileTargetArn) {
  op <- new_operation(
    name = "DetachSecurityProfile",
    http_method = "DELETE",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$detach_security_profile_input(securityProfileName = securityProfileName, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$detach_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_security_profile <- iot_detach_security_profile

#' Detaches the specified principal from the specified thing
#'
#' Detaches the specified principal from the specified thing. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#' 
#' This call is asynchronous. It might take several seconds for the
#' detachment to propagate.
#'
#' @usage
#' iot_detach_thing_principal(thingName, principal)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#' @param principal &#91;required&#93; If the principal is a certificate, this value must be ARN of the
#' certificate. If the principal is an Amazon Cognito identity, this value
#' must be the ID of the Amazon Cognito identity.
#'
#' @section Request syntax:
#' ```
#' svc$detach_thing_principal(
#'   thingName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_thing_principal
iot_detach_thing_principal <- function(thingName, principal) {
  op <- new_operation(
    name = "DetachThingPrincipal",
    http_method = "DELETE",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$detach_thing_principal_input(thingName = thingName, principal = principal)
  output <- .iot$detach_thing_principal_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_thing_principal <- iot_detach_thing_principal

#' Disables the rule
#'
#' Disables the rule.
#'
#' @usage
#' iot_disable_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule to disable.
#'
#' @section Request syntax:
#' ```
#' svc$disable_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_disable_topic_rule
iot_disable_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "DisableTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}/disable",
    paginator = list()
  )
  input <- .iot$disable_topic_rule_input(ruleName = ruleName)
  output <- .iot$disable_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$disable_topic_rule <- iot_disable_topic_rule

#' Enables the rule
#'
#' Enables the rule.
#'
#' @usage
#' iot_enable_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the topic rule to enable.
#'
#' @section Request syntax:
#' ```
#' svc$enable_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_enable_topic_rule
iot_enable_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "EnableTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}/enable",
    paginator = list()
  )
  input <- .iot$enable_topic_rule_input(ruleName = ruleName)
  output <- .iot$enable_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$enable_topic_rule <- iot_enable_topic_rule

#' Gets a list of the policies that have an effect on the authorization
#' behavior of the specified device when it connects to the AWS IoT device
#' gateway
#'
#' Gets a list of the policies that have an effect on the authorization
#' behavior of the specified device when it connects to the AWS IoT device
#' gateway.
#'
#' @usage
#' iot_get_effective_policies(principal, cognitoIdentityPoolId, thingName)
#'
#' @param principal The principal.
#' @param cognitoIdentityPoolId The Cognito identity pool ID.
#' @param thingName The thing name.
#'
#' @section Request syntax:
#' ```
#' svc$get_effective_policies(
#'   principal = "string",
#'   cognitoIdentityPoolId = "string",
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_effective_policies
iot_get_effective_policies <- function(principal = NULL, cognitoIdentityPoolId = NULL, thingName = NULL) {
  op <- new_operation(
    name = "GetEffectivePolicies",
    http_method = "POST",
    http_path = "/effective-policies",
    paginator = list()
  )
  input <- .iot$get_effective_policies_input(principal = principal, cognitoIdentityPoolId = cognitoIdentityPoolId, thingName = thingName)
  output <- .iot$get_effective_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_effective_policies <- iot_get_effective_policies

#' Gets the search configuration
#'
#' Gets the search configuration.
#'
#' @usage
#' iot_get_indexing_configuration()
#'
#' @section Request syntax:
#' ```
#' svc$get_indexing_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_indexing_configuration
iot_get_indexing_configuration <- function() {
  op <- new_operation(
    name = "GetIndexingConfiguration",
    http_method = "GET",
    http_path = "/indexing/config",
    paginator = list()
  )
  input <- .iot$get_indexing_configuration_input()
  output <- .iot$get_indexing_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_indexing_configuration <- iot_get_indexing_configuration

#' Gets a job document
#'
#' Gets a job document.
#'
#' @usage
#' iot_get_job_document(jobId)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#'
#' @section Request syntax:
#' ```
#' svc$get_job_document(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_job_document
iot_get_job_document <- function(jobId) {
  op <- new_operation(
    name = "GetJobDocument",
    http_method = "GET",
    http_path = "/jobs/{jobId}/job-document",
    paginator = list()
  )
  input <- .iot$get_job_document_input(jobId = jobId)
  output <- .iot$get_job_document_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_job_document <- iot_get_job_document

#' Gets the logging options
#'
#' Gets the logging options.
#' 
#' NOTE: use of this command is not recommended. Use `GetV2LoggingOptions`
#' instead.
#'
#' @usage
#' iot_get_logging_options()
#'
#' @section Request syntax:
#' ```
#' svc$get_logging_options()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_logging_options
iot_get_logging_options <- function() {
  op <- new_operation(
    name = "GetLoggingOptions",
    http_method = "GET",
    http_path = "/loggingOptions",
    paginator = list()
  )
  input <- .iot$get_logging_options_input()
  output <- .iot$get_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_logging_options <- iot_get_logging_options

#' Gets an OTA update
#'
#' Gets an OTA update.
#'
#' @usage
#' iot_get_ota_update(otaUpdateId)
#'
#' @param otaUpdateId &#91;required&#93; The OTA update ID.
#'
#' @section Request syntax:
#' ```
#' svc$get_ota_update(
#'   otaUpdateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_ota_update
iot_get_ota_update <- function(otaUpdateId) {
  op <- new_operation(
    name = "GetOTAUpdate",
    http_method = "GET",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$get_ota_update_input(otaUpdateId = otaUpdateId)
  output <- .iot$get_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_ota_update <- iot_get_ota_update

#' Gets information about the specified policy with the policy document of
#' the default version
#'
#' Gets information about the specified policy with the policy document of
#' the default version.
#'
#' @usage
#' iot_get_policy(policyName)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#'
#' @section Request syntax:
#' ```
#' svc$get_policy(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_policy
iot_get_policy <- function(policyName) {
  op <- new_operation(
    name = "GetPolicy",
    http_method = "GET",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$get_policy_input(policyName = policyName)
  output <- .iot$get_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_policy <- iot_get_policy

#' Gets information about the specified policy version
#'
#' Gets information about the specified policy version.
#'
#' @usage
#' iot_get_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$get_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_policy_version
iot_get_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "GetPolicyVersion",
    http_method = "GET",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$get_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$get_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_policy_version <- iot_get_policy_version

#' Gets a registration code used to register a CA certificate with AWS IoT
#'
#' Gets a registration code used to register a CA certificate with AWS IoT.
#'
#' @usage
#' iot_get_registration_code()
#'
#' @section Request syntax:
#' ```
#' svc$get_registration_code()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_registration_code
iot_get_registration_code <- function() {
  op <- new_operation(
    name = "GetRegistrationCode",
    http_method = "GET",
    http_path = "/registrationcode",
    paginator = list()
  )
  input <- .iot$get_registration_code_input()
  output <- .iot$get_registration_code_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_registration_code <- iot_get_registration_code

#' Gets statistics about things that match the specified query
#'
#' Gets statistics about things that match the specified query.
#'
#' @usage
#' iot_get_statistics(indexName, queryString, aggregationField,
#'   queryVersion)
#'
#' @param indexName The name of the index to search. The default value is `AWS_Things`.
#' @param queryString &#91;required&#93; The query used to search. You can specify \"\*\" for the query string to
#' get the count of all indexed things in your AWS account.
#' @param aggregationField The aggregation field name. Currently not supported.
#' @param queryVersion The version of the query used to search.
#'
#' @section Request syntax:
#' ```
#' svc$get_statistics(
#'   indexName = "string",
#'   queryString = "string",
#'   aggregationField = "string",
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_statistics
iot_get_statistics <- function(indexName = NULL, queryString, aggregationField = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "GetStatistics",
    http_method = "POST",
    http_path = "/indices/statistics",
    paginator = list()
  )
  input <- .iot$get_statistics_input(indexName = indexName, queryString = queryString, aggregationField = aggregationField, queryVersion = queryVersion)
  output <- .iot$get_statistics_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_statistics <- iot_get_statistics

#' Gets information about the rule
#'
#' Gets information about the rule.
#'
#' @usage
#' iot_get_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#'
#' @section Request syntax:
#' ```
#' svc$get_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_topic_rule
iot_get_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "GetTopicRule",
    http_method = "GET",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$get_topic_rule_input(ruleName = ruleName)
  output <- .iot$get_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_topic_rule <- iot_get_topic_rule

#' Gets the fine grained logging options
#'
#' Gets the fine grained logging options.
#'
#' @usage
#' iot_get_v2_logging_options()
#'
#' @section Request syntax:
#' ```
#' svc$get_v2_logging_options()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_v2_logging_options
iot_get_v2_logging_options <- function() {
  op <- new_operation(
    name = "GetV2LoggingOptions",
    http_method = "GET",
    http_path = "/v2LoggingOptions",
    paginator = list()
  )
  input <- .iot$get_v2_logging_options_input()
  output <- .iot$get_v2_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_v2_logging_options <- iot_get_v2_logging_options

#' Lists the active violations for a given Device Defender security profile
#'
#' Lists the active violations for a given Device Defender security
#' profile.
#'
#' @usage
#' iot_list_active_violations(thingName, securityProfileName, nextToken,
#'   maxResults)
#'
#' @param thingName The name of the thing whose active violations are listed.
#' @param securityProfileName The name of the Device Defender security profile for which violations
#' are listed.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_active_violations(
#'   thingName = "string",
#'   securityProfileName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_active_violations
iot_list_active_violations <- function(thingName = NULL, securityProfileName = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListActiveViolations",
    http_method = "GET",
    http_path = "/active-violations",
    paginator = list()
  )
  input <- .iot$list_active_violations_input(thingName = thingName, securityProfileName = securityProfileName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_active_violations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_active_violations <- iot_list_active_violations

#' Lists the policies attached to the specified thing group
#'
#' Lists the policies attached to the specified thing group.
#'
#' @usage
#' iot_list_attached_policies(target, recursive, marker, pageSize)
#'
#' @param target &#91;required&#93; The group for which the policies will be listed.
#' @param recursive When true, recursively list attached policies.
#' @param marker The token to retrieve the next set of results.
#' @param pageSize The maximum number of results to be returned per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_attached_policies(
#'   target = "string",
#'   recursive = TRUE|FALSE,
#'   marker = "string",
#'   pageSize = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_attached_policies
iot_list_attached_policies <- function(target, recursive = NULL, marker = NULL, pageSize = NULL) {
  op <- new_operation(
    name = "ListAttachedPolicies",
    http_method = "POST",
    http_path = "/attached-policies/{target}",
    paginator = list()
  )
  input <- .iot$list_attached_policies_input(target = target, recursive = recursive, marker = marker, pageSize = pageSize)
  output <- .iot$list_attached_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_attached_policies <- iot_list_attached_policies

#' Lists the findings (results) of a Device Defender audit or of the audits
#' performed during a specified time period
#'
#' Lists the findings (results) of a Device Defender audit or of the audits
#' performed during a specified time period. (Findings are retained for 180
#' days.)
#'
#' @usage
#' iot_list_audit_findings(taskId, checkName, resourceIdentifier,
#'   maxResults, nextToken, startTime, endTime)
#'
#' @param taskId A filter to limit results to the audit with the specified ID. You must
#' specify either the taskId or the startTime and endTime, but not both.
#' @param checkName A filter to limit results to the findings for the specified audit check.
#' @param resourceIdentifier Information identifying the non-compliant resource.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#' @param startTime A filter to limit results to those found after the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#' @param endTime A filter to limit results to those found before the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_findings(
#'   taskId = "string",
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_findings
iot_list_audit_findings <- function(taskId = NULL, checkName = NULL, resourceIdentifier = NULL, maxResults = NULL, nextToken = NULL, startTime = NULL, endTime = NULL) {
  op <- new_operation(
    name = "ListAuditFindings",
    http_method = "POST",
    http_path = "/audit/findings",
    paginator = list()
  )
  input <- .iot$list_audit_findings_input(taskId = taskId, checkName = checkName, resourceIdentifier = resourceIdentifier, maxResults = maxResults, nextToken = nextToken, startTime = startTime, endTime = endTime)
  output <- .iot$list_audit_findings_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_findings <- iot_list_audit_findings

#' Lists the Device Defender audits that have been performed during a given
#' time period
#'
#' Lists the Device Defender audits that have been performed during a given
#' time period.
#'
#' @usage
#' iot_list_audit_tasks(startTime, endTime, taskType, taskStatus,
#'   nextToken, maxResults)
#'
#' @param startTime &#91;required&#93; The beginning of the time period. Note that audit information is
#' retained for a limited time (180 days). Requesting a start time prior to
#' what is retained results in an \"InvalidRequestException\".
#' @param endTime &#91;required&#93; The end of the time period.
#' @param taskType A filter to limit the output to the specified type of audit: can be one
#' of \"ON\\_DEMAND\\_AUDIT\\_TASK\" or \"SCHEDULED\\_\\_AUDIT\\_TASK\".
#' @param taskStatus A filter to limit the output to audits with the specified completion
#' status: can be one of \"IN\\_PROGRESS\", \"COMPLETED\", \"FAILED\" or
#' \"CANCELED\".
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_tasks(
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   taskType = "ON_DEMAND_AUDIT_TASK"|"SCHEDULED_AUDIT_TASK",
#'   taskStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED"|"CANCELED",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_tasks
iot_list_audit_tasks <- function(startTime, endTime, taskType = NULL, taskStatus = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAuditTasks",
    http_method = "GET",
    http_path = "/audit/tasks",
    paginator = list()
  )
  input <- .iot$list_audit_tasks_input(startTime = startTime, endTime = endTime, taskType = taskType, taskStatus = taskStatus, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_audit_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_tasks <- iot_list_audit_tasks

#' Lists the authorizers registered in your account
#'
#' Lists the authorizers registered in your account.
#'
#' @usage
#' iot_list_authorizers(pageSize, marker, ascendingOrder, status)
#'
#' @param pageSize The maximum number of results to return at one time.
#' @param marker A marker used to get the next set of results.
#' @param ascendingOrder Return the list of authorizers in ascending alphabetical order.
#' @param status The status of the list authorizers request.
#'
#' @section Request syntax:
#' ```
#' svc$list_authorizers(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE,
#'   status = "ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_authorizers
iot_list_authorizers <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL, status = NULL) {
  op <- new_operation(
    name = "ListAuthorizers",
    http_method = "GET",
    http_path = "/authorizers/",
    paginator = list()
  )
  input <- .iot$list_authorizers_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder, status = status)
  output <- .iot$list_authorizers_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_authorizers <- iot_list_authorizers

#' Lists the billing groups you have created
#'
#' Lists the billing groups you have created.
#'
#' @usage
#' iot_list_billing_groups(nextToken, maxResults, namePrefixFilter)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return per request.
#' @param namePrefixFilter Limit the results to billing groups whose names have the given prefix.
#'
#' @section Request syntax:
#' ```
#' svc$list_billing_groups(
#'   nextToken = "string",
#'   maxResults = 123,
#'   namePrefixFilter = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_billing_groups
iot_list_billing_groups <- function(nextToken = NULL, maxResults = NULL, namePrefixFilter = NULL) {
  op <- new_operation(
    name = "ListBillingGroups",
    http_method = "GET",
    http_path = "/billing-groups",
    paginator = list()
  )
  input <- .iot$list_billing_groups_input(nextToken = nextToken, maxResults = maxResults, namePrefixFilter = namePrefixFilter)
  output <- .iot$list_billing_groups_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_billing_groups <- iot_list_billing_groups

#' Lists the CA certificates registered for your AWS account
#'
#' Lists the CA certificates registered for your AWS account.
#' 
#' The results are paginated with a default page size of 25. You can use
#' the returned marker to retrieve additional results.
#'
#' @usage
#' iot_list_ca_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Determines the order of the results.
#'
#' @section Request syntax:
#' ```
#' svc$list_ca_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_ca_certificates
iot_list_ca_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCACertificates",
    http_method = "GET",
    http_path = "/cacertificates",
    paginator = list()
  )
  input <- .iot$list_ca_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_ca_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_ca_certificates <- iot_list_ca_certificates

#' Lists the certificates registered in your AWS account
#'
#' Lists the certificates registered in your AWS account.
#' 
#' The results are paginated with a default page size of 25. You can use
#' the returned marker to retrieve additional results.
#'
#' @usage
#' iot_list_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_certificates
iot_list_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCertificates",
    http_method = "GET",
    http_path = "/certificates",
    paginator = list()
  )
  input <- .iot$list_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_certificates <- iot_list_certificates

#' List the device certificates signed by the specified CA certificate
#'
#' List the device certificates signed by the specified CA certificate.
#'
#' @usage
#' iot_list_certificates_by_ca(caCertificateId, pageSize, marker,
#'   ascendingOrder)
#'
#' @param caCertificateId &#91;required&#93; The ID of the CA certificate. This operation will list all registered
#' device certificate that were signed by this CA certificate.
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_certificates_by_ca(
#'   caCertificateId = "string",
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_certificates_by_ca
iot_list_certificates_by_ca <- function(caCertificateId, pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCertificatesByCA",
    http_method = "GET",
    http_path = "/certificates-by-ca/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$list_certificates_by_ca_input(caCertificateId = caCertificateId, pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_certificates_by_ca_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_certificates_by_ca <- iot_list_certificates_by_ca

#' Lists the search indices
#'
#' Lists the search indices.
#'
#' @usage
#' iot_list_indices(nextToken, maxResults)
#'
#' @param nextToken The token used to get the next set of results, or null if there are no
#' additional results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_indices(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_indices
iot_list_indices <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListIndices",
    http_method = "GET",
    http_path = "/indices",
    paginator = list()
  )
  input <- .iot$list_indices_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_indices_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_indices <- iot_list_indices

#' Lists the job executions for a job
#'
#' Lists the job executions for a job.
#'
#' @usage
#' iot_list_job_executions_for_job(jobId, status, maxResults, nextToken)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param status The status of the job.
#' @param maxResults The maximum number of results to be returned per request.
#' @param nextToken The token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_job_executions_for_job(
#'   jobId = "string",
#'   status = "QUEUED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"REJECTED"|"REMOVED"|"CANCELED",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_job_executions_for_job
iot_list_job_executions_for_job <- function(jobId, status = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobExecutionsForJob",
    http_method = "GET",
    http_path = "/jobs/{jobId}/things",
    paginator = list()
  )
  input <- .iot$list_job_executions_for_job_input(jobId = jobId, status = status, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_job_executions_for_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_job_executions_for_job <- iot_list_job_executions_for_job

#' Lists the job executions for the specified thing
#'
#' Lists the job executions for the specified thing.
#'
#' @usage
#' iot_list_job_executions_for_thing(thingName, status, maxResults,
#'   nextToken)
#'
#' @param thingName &#91;required&#93; The thing name.
#' @param status An optional filter that lets you search for jobs that have the specified
#' status.
#' @param maxResults The maximum number of results to be returned per request.
#' @param nextToken The token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_job_executions_for_thing(
#'   thingName = "string",
#'   status = "QUEUED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"REJECTED"|"REMOVED"|"CANCELED",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_job_executions_for_thing
iot_list_job_executions_for_thing <- function(thingName, status = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobExecutionsForThing",
    http_method = "GET",
    http_path = "/things/{thingName}/jobs",
    paginator = list()
  )
  input <- .iot$list_job_executions_for_thing_input(thingName = thingName, status = status, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_job_executions_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_job_executions_for_thing <- iot_list_job_executions_for_thing

#' Lists jobs
#'
#' Lists jobs.
#'
#' @usage
#' iot_list_jobs(status, targetSelection, maxResults, nextToken,
#'   thingGroupName, thingGroupId)
#'
#' @param status An optional filter that lets you search for jobs that have the specified
#' status.
#' @param targetSelection Specifies whether the job will continue to run (CONTINUOUS), or will be
#' complete after all those things specified as targets have completed the
#' job (SNAPSHOT). If continuous, the job may also be run on a thing when a
#' change is detected in a target. For example, a job will run on a thing
#' when the thing is added to a target group, even after the job was
#' completed by all things originally in the group.
#' @param maxResults The maximum number of results to return per request.
#' @param nextToken The token to retrieve the next set of results.
#' @param thingGroupName A filter that limits the returned jobs to those for the specified group.
#' @param thingGroupId A filter that limits the returned jobs to those for the specified group.
#'
#' @section Request syntax:
#' ```
#' svc$list_jobs(
#'   status = "IN_PROGRESS"|"CANCELED"|"COMPLETED"|"DELETION_IN_PROGRESS",
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   maxResults = 123,
#'   nextToken = "string",
#'   thingGroupName = "string",
#'   thingGroupId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_jobs
iot_list_jobs <- function(status = NULL, targetSelection = NULL, maxResults = NULL, nextToken = NULL, thingGroupName = NULL, thingGroupId = NULL) {
  op <- new_operation(
    name = "ListJobs",
    http_method = "GET",
    http_path = "/jobs",
    paginator = list()
  )
  input <- .iot$list_jobs_input(status = status, targetSelection = targetSelection, maxResults = maxResults, nextToken = nextToken, thingGroupName = thingGroupName, thingGroupId = thingGroupId)
  output <- .iot$list_jobs_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_jobs <- iot_list_jobs

#' Lists OTA updates
#'
#' Lists OTA updates.
#'
#' @usage
#' iot_list_ota_updates(maxResults, nextToken, otaUpdateStatus)
#'
#' @param maxResults The maximum number of results to return at one time.
#' @param nextToken A token used to retrieve the next set of results.
#' @param otaUpdateStatus The OTA update job status.
#'
#' @section Request syntax:
#' ```
#' svc$list_ota_updates(
#'   maxResults = 123,
#'   nextToken = "string",
#'   otaUpdateStatus = "CREATE_PENDING"|"CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_ota_updates
iot_list_ota_updates <- function(maxResults = NULL, nextToken = NULL, otaUpdateStatus = NULL) {
  op <- new_operation(
    name = "ListOTAUpdates",
    http_method = "GET",
    http_path = "/otaUpdates",
    paginator = list()
  )
  input <- .iot$list_ota_updates_input(maxResults = maxResults, nextToken = nextToken, otaUpdateStatus = otaUpdateStatus)
  output <- .iot$list_ota_updates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_ota_updates <- iot_list_ota_updates

#' Lists certificates that are being transferred but not yet accepted
#'
#' Lists certificates that are being transferred but not yet accepted.
#'
#' @usage
#' iot_list_outgoing_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_outgoing_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_outgoing_certificates
iot_list_outgoing_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListOutgoingCertificates",
    http_method = "GET",
    http_path = "/certificates-out-going",
    paginator = list()
  )
  input <- .iot$list_outgoing_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_outgoing_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_outgoing_certificates <- iot_list_outgoing_certificates

#' Lists your policies
#'
#' Lists your policies.
#'
#' @usage
#' iot_list_policies(marker, pageSize, ascendingOrder)
#'
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, the results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_policies(
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policies
iot_list_policies <- function(marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPolicies",
    http_method = "GET",
    http_path = "/policies",
    paginator = list()
  )
  input <- .iot$list_policies_input(marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policies <- iot_list_policies

#' Lists the principals associated with the specified policy
#'
#' Lists the principals associated with the specified policy.
#' 
#' **Note:** This API is deprecated. Please use ListTargetsForPolicy
#' instead.
#'
#' @usage
#' iot_list_policy_principals(policyName, marker, pageSize, ascendingOrder)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, the results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_principals(
#'   policyName = "string",
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policy_principals
iot_list_policy_principals <- function(policyName, marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPolicyPrincipals",
    http_method = "GET",
    http_path = "/policy-principals",
    paginator = list()
  )
  input <- .iot$list_policy_principals_input(policyName = policyName, marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_policy_principals_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policy_principals <- iot_list_policy_principals

#' Lists the versions of the specified policy and identifies the default
#' version
#'
#' Lists the versions of the specified policy and identifies the default
#' version.
#'
#' @usage
#' iot_list_policy_versions(policyName)
#'
#' @param policyName &#91;required&#93; The policy name.
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_versions(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policy_versions
iot_list_policy_versions <- function(policyName) {
  op <- new_operation(
    name = "ListPolicyVersions",
    http_method = "GET",
    http_path = "/policies/{policyName}/version",
    paginator = list()
  )
  input <- .iot$list_policy_versions_input(policyName = policyName)
  output <- .iot$list_policy_versions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policy_versions <- iot_list_policy_versions

#' Lists the policies attached to the specified principal
#'
#' Lists the policies attached to the specified principal. If you use an
#' Cognito identity, the ID must be in [AmazonCognito Identity
#' format](https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax).
#' 
#' **Note:** This API is deprecated. Please use ListAttachedPolicies
#' instead.
#'
#' @usage
#' iot_list_principal_policies(principal, marker, pageSize, ascendingOrder)
#'
#' @param principal &#91;required&#93; The principal.
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_principal_policies(
#'   principal = "string",
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_principal_policies
iot_list_principal_policies <- function(principal, marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPrincipalPolicies",
    http_method = "GET",
    http_path = "/principal-policies",
    paginator = list()
  )
  input <- .iot$list_principal_policies_input(principal = principal, marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_principal_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_principal_policies <- iot_list_principal_policies

#' Lists the things associated with the specified principal
#'
#' Lists the things associated with the specified principal. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_list_principal_things(nextToken, maxResults, principal)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param principal &#91;required&#93; The principal.
#'
#' @section Request syntax:
#' ```
#' svc$list_principal_things(
#'   nextToken = "string",
#'   maxResults = 123,
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_principal_things
iot_list_principal_things <- function(nextToken = NULL, maxResults = NULL, principal) {
  op <- new_operation(
    name = "ListPrincipalThings",
    http_method = "GET",
    http_path = "/principals/things",
    paginator = list()
  )
  input <- .iot$list_principal_things_input(nextToken = nextToken, maxResults = maxResults, principal = principal)
  output <- .iot$list_principal_things_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_principal_things <- iot_list_principal_things

#' Lists the role aliases registered in your account
#'
#' Lists the role aliases registered in your account.
#'
#' @usage
#' iot_list_role_aliases(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The maximum number of results to return at one time.
#' @param marker A marker used to get the next set of results.
#' @param ascendingOrder Return the list of role aliases in ascending alphabetical order.
#'
#' @section Request syntax:
#' ```
#' svc$list_role_aliases(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_role_aliases
iot_list_role_aliases <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListRoleAliases",
    http_method = "GET",
    http_path = "/role-aliases",
    paginator = list()
  )
  input <- .iot$list_role_aliases_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_role_aliases_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_role_aliases <- iot_list_role_aliases

#' Lists all of your scheduled audits
#'
#' Lists all of your scheduled audits.
#'
#' @usage
#' iot_list_scheduled_audits(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_scheduled_audits(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_scheduled_audits
iot_list_scheduled_audits <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListScheduledAudits",
    http_method = "GET",
    http_path = "/audit/scheduledaudits",
    paginator = list()
  )
  input <- .iot$list_scheduled_audits_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_scheduled_audits_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_scheduled_audits <- iot_list_scheduled_audits

#' Lists the Device Defender security profiles you have created
#'
#' Lists the Device Defender security profiles you have created. You can
#' use filters to list only those security profiles associated with a thing
#' group or only those associated with your account.
#'
#' @usage
#' iot_list_security_profiles(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_security_profiles(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_security_profiles
iot_list_security_profiles <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListSecurityProfiles",
    http_method = "GET",
    http_path = "/security-profiles",
    paginator = list()
  )
  input <- .iot$list_security_profiles_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_security_profiles_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_security_profiles <- iot_list_security_profiles

#' Lists the Device Defender security profiles attached to a target (thing
#' group)
#'
#' Lists the Device Defender security profiles attached to a target (thing
#' group).
#'
#' @usage
#' iot_list_security_profiles_for_target(nextToken, maxResults, recursive,
#'   securityProfileTargetArn)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#' @param recursive If true, return child groups as well.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the target (thing group) whose attached security profiles you
#' want to get.
#'
#' @section Request syntax:
#' ```
#' svc$list_security_profiles_for_target(
#'   nextToken = "string",
#'   maxResults = 123,
#'   recursive = TRUE|FALSE,
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_security_profiles_for_target
iot_list_security_profiles_for_target <- function(nextToken = NULL, maxResults = NULL, recursive = NULL, securityProfileTargetArn) {
  op <- new_operation(
    name = "ListSecurityProfilesForTarget",
    http_method = "GET",
    http_path = "/security-profiles-for-target",
    paginator = list()
  )
  input <- .iot$list_security_profiles_for_target_input(nextToken = nextToken, maxResults = maxResults, recursive = recursive, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$list_security_profiles_for_target_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_security_profiles_for_target <- iot_list_security_profiles_for_target

#' Lists all of the streams in your AWS account
#'
#' Lists all of the streams in your AWS account.
#'
#' @usage
#' iot_list_streams(maxResults, nextToken, ascendingOrder)
#'
#' @param maxResults The maximum number of results to return at a time.
#' @param nextToken A token used to get the next set of results.
#' @param ascendingOrder Set to true to return the list of streams in ascending order.
#'
#' @section Request syntax:
#' ```
#' svc$list_streams(
#'   maxResults = 123,
#'   nextToken = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_streams
iot_list_streams <- function(maxResults = NULL, nextToken = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListStreams",
    http_method = "GET",
    http_path = "/streams",
    paginator = list()
  )
  input <- .iot$list_streams_input(maxResults = maxResults, nextToken = nextToken, ascendingOrder = ascendingOrder)
  output <- .iot$list_streams_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_streams <- iot_list_streams

#' Lists the tags (metadata) you have assigned to the resource
#'
#' Lists the tags (metadata) you have assigned to the resource.
#'
#' @usage
#' iot_list_tags_for_resource(resourceArn, nextToken)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param nextToken The token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_tags_for_resource
iot_list_tags_for_resource <- function(resourceArn, nextToken = NULL) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags",
    paginator = list()
  )
  input <- .iot$list_tags_for_resource_input(resourceArn = resourceArn, nextToken = nextToken)
  output <- .iot$list_tags_for_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_tags_for_resource <- iot_list_tags_for_resource

#' List targets for the specified policy
#'
#' List targets for the specified policy.
#'
#' @usage
#' iot_list_targets_for_policy(policyName, marker, pageSize)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param marker A marker used to get the next set of results.
#' @param pageSize The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_targets_for_policy(
#'   policyName = "string",
#'   marker = "string",
#'   pageSize = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_targets_for_policy
iot_list_targets_for_policy <- function(policyName, marker = NULL, pageSize = NULL) {
  op <- new_operation(
    name = "ListTargetsForPolicy",
    http_method = "POST",
    http_path = "/policy-targets/{policyName}",
    paginator = list()
  )
  input <- .iot$list_targets_for_policy_input(policyName = policyName, marker = marker, pageSize = pageSize)
  output <- .iot$list_targets_for_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_targets_for_policy <- iot_list_targets_for_policy

#' Lists the targets (thing groups) associated with a given Device Defender
#' security profile
#'
#' Lists the targets (thing groups) associated with a given Device Defender
#' security profile.
#'
#' @usage
#' iot_list_targets_for_security_profile(securityProfileName, nextToken,
#'   maxResults)
#'
#' @param securityProfileName &#91;required&#93; The security profile.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_targets_for_security_profile(
#'   securityProfileName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_targets_for_security_profile
iot_list_targets_for_security_profile <- function(securityProfileName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListTargetsForSecurityProfile",
    http_method = "GET",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$list_targets_for_security_profile_input(securityProfileName = securityProfileName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_targets_for_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_targets_for_security_profile <- iot_list_targets_for_security_profile

#' List the thing groups in your account
#'
#' List the thing groups in your account.
#'
#' @usage
#' iot_list_thing_groups(nextToken, maxResults, parentGroup,
#'   namePrefixFilter, recursive)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#' @param parentGroup A filter that limits the results to those with the specified parent
#' group.
#' @param namePrefixFilter A filter that limits the results to those with the specified name
#' prefix.
#' @param recursive If true, return child groups as well.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_groups(
#'   nextToken = "string",
#'   maxResults = 123,
#'   parentGroup = "string",
#'   namePrefixFilter = "string",
#'   recursive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_groups
iot_list_thing_groups <- function(nextToken = NULL, maxResults = NULL, parentGroup = NULL, namePrefixFilter = NULL, recursive = NULL) {
  op <- new_operation(
    name = "ListThingGroups",
    http_method = "GET",
    http_path = "/thing-groups",
    paginator = list()
  )
  input <- .iot$list_thing_groups_input(nextToken = nextToken, maxResults = maxResults, parentGroup = parentGroup, namePrefixFilter = namePrefixFilter, recursive = recursive)
  output <- .iot$list_thing_groups_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_groups <- iot_list_thing_groups

#' List the thing groups to which the specified thing belongs
#'
#' List the thing groups to which the specified thing belongs.
#'
#' @usage
#' iot_list_thing_groups_for_thing(thingName, nextToken, maxResults)
#'
#' @param thingName &#91;required&#93; The thing name.
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_groups_for_thing(
#'   thingName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_groups_for_thing
iot_list_thing_groups_for_thing <- function(thingName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingGroupsForThing",
    http_method = "GET",
    http_path = "/things/{thingName}/thing-groups",
    paginator = list()
  )
  input <- .iot$list_thing_groups_for_thing_input(thingName = thingName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_thing_groups_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_groups_for_thing <- iot_list_thing_groups_for_thing

#' Lists the principals associated with the specified thing
#'
#' Lists the principals associated with the specified thing. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_list_thing_principals(thingName)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_principals(
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_principals
iot_list_thing_principals <- function(thingName) {
  op <- new_operation(
    name = "ListThingPrincipals",
    http_method = "GET",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$list_thing_principals_input(thingName = thingName)
  output <- .iot$list_thing_principals_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_principals <- iot_list_thing_principals

#' Information about the thing registration tasks
#'
#' Information about the thing registration tasks.
#'
#' @usage
#' iot_list_thing_registration_task_reports(taskId, reportType, nextToken,
#'   maxResults)
#'
#' @param taskId &#91;required&#93; The id of the task.
#' @param reportType &#91;required&#93; The type of task report.
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_registration_task_reports(
#'   taskId = "string",
#'   reportType = "ERRORS"|"RESULTS",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_registration_task_reports
iot_list_thing_registration_task_reports <- function(taskId, reportType, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingRegistrationTaskReports",
    http_method = "GET",
    http_path = "/thing-registration-tasks/{taskId}/reports",
    paginator = list()
  )
  input <- .iot$list_thing_registration_task_reports_input(taskId = taskId, reportType = reportType, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_thing_registration_task_reports_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_registration_task_reports <- iot_list_thing_registration_task_reports

#' List bulk thing provisioning tasks
#'
#' List bulk thing provisioning tasks.
#'
#' @usage
#' iot_list_thing_registration_tasks(nextToken, maxResults, status)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#' @param status The status of the bulk thing provisioning task.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_registration_tasks(
#'   nextToken = "string",
#'   maxResults = 123,
#'   status = "InProgress"|"Completed"|"Failed"|"Cancelled"|"Cancelling"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_registration_tasks
iot_list_thing_registration_tasks <- function(nextToken = NULL, maxResults = NULL, status = NULL) {
  op <- new_operation(
    name = "ListThingRegistrationTasks",
    http_method = "GET",
    http_path = "/thing-registration-tasks",
    paginator = list()
  )
  input <- .iot$list_thing_registration_tasks_input(nextToken = nextToken, maxResults = maxResults, status = status)
  output <- .iot$list_thing_registration_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_registration_tasks <- iot_list_thing_registration_tasks

#' Lists the existing thing types
#'
#' Lists the existing thing types.
#'
#' @usage
#' iot_list_thing_types(nextToken, maxResults, thingTypeName)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param thingTypeName The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_types(
#'   nextToken = "string",
#'   maxResults = 123,
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_types
iot_list_thing_types <- function(nextToken = NULL, maxResults = NULL, thingTypeName = NULL) {
  op <- new_operation(
    name = "ListThingTypes",
    http_method = "GET",
    http_path = "/thing-types",
    paginator = list()
  )
  input <- .iot$list_thing_types_input(nextToken = nextToken, maxResults = maxResults, thingTypeName = thingTypeName)
  output <- .iot$list_thing_types_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_types <- iot_list_thing_types

#' Lists your things
#'
#' Lists your things. Use the **attributeName** and **attributeValue**
#' parameters to filter your things. For example, calling `ListThings` with
#' attributeName=Color and attributeValue=Red retrieves all things in the
#' registry that contain an attribute **Color** with the value **Red**.
#'
#' @usage
#' iot_list_things(nextToken, maxResults, attributeName, attributeValue,
#'   thingTypeName)
#'
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param attributeName The attribute name used to search for things.
#' @param attributeValue The attribute value used to search for things.
#' @param thingTypeName The name of the thing type used to search for things.
#'
#' @section Request syntax:
#' ```
#' svc$list_things(
#'   nextToken = "string",
#'   maxResults = 123,
#'   attributeName = "string",
#'   attributeValue = "string",
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things
iot_list_things <- function(nextToken = NULL, maxResults = NULL, attributeName = NULL, attributeValue = NULL, thingTypeName = NULL) {
  op <- new_operation(
    name = "ListThings",
    http_method = "GET",
    http_path = "/things",
    paginator = list()
  )
  input <- .iot$list_things_input(nextToken = nextToken, maxResults = maxResults, attributeName = attributeName, attributeValue = attributeValue, thingTypeName = thingTypeName)
  output <- .iot$list_things_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things <- iot_list_things

#' Lists the things you have added to the given billing group
#'
#' Lists the things you have added to the given billing group.
#'
#' @usage
#' iot_list_things_in_billing_group(billingGroupName, nextToken,
#'   maxResults)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_things_in_billing_group(
#'   billingGroupName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things_in_billing_group
iot_list_things_in_billing_group <- function(billingGroupName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingsInBillingGroup",
    http_method = "GET",
    http_path = "/billing-groups/{billingGroupName}/things",
    paginator = list()
  )
  input <- .iot$list_things_in_billing_group_input(billingGroupName = billingGroupName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_things_in_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things_in_billing_group <- iot_list_things_in_billing_group

#' Lists the things in the specified group
#'
#' Lists the things in the specified group.
#'
#' @usage
#' iot_list_things_in_thing_group(thingGroupName, recursive, nextToken,
#'   maxResults)
#'
#' @param thingGroupName &#91;required&#93; The thing group name.
#' @param recursive When true, list things in this thing group and in all child groups as
#' well.
#' @param nextToken The token to retrieve the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_things_in_thing_group(
#'   thingGroupName = "string",
#'   recursive = TRUE|FALSE,
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things_in_thing_group
iot_list_things_in_thing_group <- function(thingGroupName, recursive = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingsInThingGroup",
    http_method = "GET",
    http_path = "/thing-groups/{thingGroupName}/things",
    paginator = list()
  )
  input <- .iot$list_things_in_thing_group_input(thingGroupName = thingGroupName, recursive = recursive, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_things_in_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things_in_thing_group <- iot_list_things_in_thing_group

#' Lists the rules for the specific topic
#'
#' Lists the rules for the specific topic.
#'
#' @usage
#' iot_list_topic_rules(topic, maxResults, nextToken, ruleDisabled)
#'
#' @param topic The topic.
#' @param maxResults The maximum number of results to return.
#' @param nextToken A token used to retrieve the next value.
#' @param ruleDisabled Specifies whether the rule is disabled.
#'
#' @section Request syntax:
#' ```
#' svc$list_topic_rules(
#'   topic = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   ruleDisabled = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_topic_rules
iot_list_topic_rules <- function(topic = NULL, maxResults = NULL, nextToken = NULL, ruleDisabled = NULL) {
  op <- new_operation(
    name = "ListTopicRules",
    http_method = "GET",
    http_path = "/rules",
    paginator = list()
  )
  input <- .iot$list_topic_rules_input(topic = topic, maxResults = maxResults, nextToken = nextToken, ruleDisabled = ruleDisabled)
  output <- .iot$list_topic_rules_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_topic_rules <- iot_list_topic_rules

#' Lists logging levels
#'
#' Lists logging levels.
#'
#' @usage
#' iot_list_v2_logging_levels(targetType, nextToken, maxResults)
#'
#' @param targetType The type of resource for which you are configuring logging. Must be
#' `THING_Group`.
#' @param nextToken The token used to get the next set of results, or **null** if there are
#' no additional results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_v2_logging_levels(
#'   targetType = "DEFAULT"|"THING_GROUP",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_v2_logging_levels
iot_list_v2_logging_levels <- function(targetType = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListV2LoggingLevels",
    http_method = "GET",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$list_v2_logging_levels_input(targetType = targetType, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_v2_logging_levels_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_v2_logging_levels <- iot_list_v2_logging_levels

#' Lists the Device Defender security profile violations discovered during
#' the given time period
#'
#' Lists the Device Defender security profile violations discovered during
#' the given time period. You can use filters to limit the results to those
#' alerts issued for a particular security profile, behavior or thing
#' (device).
#'
#' @usage
#' iot_list_violation_events(startTime, endTime, thingName,
#'   securityProfileName, nextToken, maxResults)
#'
#' @param startTime &#91;required&#93; The start time for the alerts to be listed.
#' @param endTime &#91;required&#93; The end time for the alerts to be listed.
#' @param thingName A filter to limit results to those alerts caused by the specified thing.
#' @param securityProfileName A filter to limit results to those alerts generated by the specified
#' security profile.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_violation_events(
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   thingName = "string",
#'   securityProfileName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_violation_events
iot_list_violation_events <- function(startTime, endTime, thingName = NULL, securityProfileName = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListViolationEvents",
    http_method = "GET",
    http_path = "/violation-events",
    paginator = list()
  )
  input <- .iot$list_violation_events_input(startTime = startTime, endTime = endTime, thingName = thingName, securityProfileName = securityProfileName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_violation_events_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_violation_events <- iot_list_violation_events

#' Registers a CA certificate with AWS IoT
#'
#' Registers a CA certificate with AWS IoT. This CA certificate can then be
#' used to sign device certificates, which can be then registered with AWS
#' IoT. You can register up to 10 CA certificates per AWS account that have
#' the same subject field. This enables you to have up to 10 certificate
#' authorities sign your device certificates. If you have more than one CA
#' certificate registered, make sure you pass the CA certificate when you
#' register your device certificates with the RegisterCertificate API.
#'
#' @usage
#' iot_register_ca_certificate(caCertificate, verificationCertificate,
#'   setAsActive, allowAutoRegistration, registrationConfig)
#'
#' @param caCertificate &#91;required&#93; The CA certificate.
#' @param verificationCertificate &#91;required&#93; The private key verification certificate.
#' @param setAsActive A boolean value that specifies if the CA certificate is set to active.
#' @param allowAutoRegistration Allows this CA certificate to be used for auto registration of device
#' certificates.
#' @param registrationConfig Information about the registration configuration.
#'
#' @section Request syntax:
#' ```
#' svc$register_ca_certificate(
#'   caCertificate = "string",
#'   verificationCertificate = "string",
#'   setAsActive = TRUE|FALSE,
#'   allowAutoRegistration = TRUE|FALSE,
#'   registrationConfig = list(
#'     templateBody = "string",
#'     roleArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_ca_certificate
iot_register_ca_certificate <- function(caCertificate, verificationCertificate, setAsActive = NULL, allowAutoRegistration = NULL, registrationConfig = NULL) {
  op <- new_operation(
    name = "RegisterCACertificate",
    http_method = "POST",
    http_path = "/cacertificate",
    paginator = list()
  )
  input <- .iot$register_ca_certificate_input(caCertificate = caCertificate, verificationCertificate = verificationCertificate, setAsActive = setAsActive, allowAutoRegistration = allowAutoRegistration, registrationConfig = registrationConfig)
  output <- .iot$register_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_ca_certificate <- iot_register_ca_certificate

#' Registers a device certificate with AWS IoT
#'
#' Registers a device certificate with AWS IoT. If you have more than one
#' CA certificate that has the same subject field, you must specify the CA
#' certificate that was used to sign the device certificate being
#' registered.
#'
#' @usage
#' iot_register_certificate(certificatePem, caCertificatePem, setAsActive,
#'   status)
#'
#' @param certificatePem &#91;required&#93; The certificate data, in PEM format.
#' @param caCertificatePem The CA certificate used to sign the device certificate being registered.
#' @param setAsActive A boolean value that specifies if the certificate is set to active.
#' @param status The status of the register certificate request.
#'
#' @section Request syntax:
#' ```
#' svc$register_certificate(
#'   certificatePem = "string",
#'   caCertificatePem = "string",
#'   setAsActive = TRUE|FALSE,
#'   status = "ACTIVE"|"INACTIVE"|"REVOKED"|"PENDING_TRANSFER"|"REGISTER_INACTIVE"|"PENDING_ACTIVATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_certificate
iot_register_certificate <- function(certificatePem, caCertificatePem = NULL, setAsActive = NULL, status = NULL) {
  op <- new_operation(
    name = "RegisterCertificate",
    http_method = "POST",
    http_path = "/certificate/register",
    paginator = list()
  )
  input <- .iot$register_certificate_input(certificatePem = certificatePem, caCertificatePem = caCertificatePem, setAsActive = setAsActive, status = status)
  output <- .iot$register_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_certificate <- iot_register_certificate

#' Provisions a thing
#'
#' Provisions a thing.
#'
#' @usage
#' iot_register_thing(templateBody, parameters)
#'
#' @param templateBody &#91;required&#93; The provisioning template. See [Programmatic
#' Provisioning](https://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html)
#' for more information.
#' @param parameters The parameters for provisioning a thing. See [Programmatic
#' Provisioning](https://docs.aws.amazon.com/iot/latest/developerguide/programmatic-provisioning.html)
#' for more information.
#'
#' @section Request syntax:
#' ```
#' svc$register_thing(
#'   templateBody = "string",
#'   parameters = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_thing
iot_register_thing <- function(templateBody, parameters = NULL) {
  op <- new_operation(
    name = "RegisterThing",
    http_method = "POST",
    http_path = "/things",
    paginator = list()
  )
  input <- .iot$register_thing_input(templateBody = templateBody, parameters = parameters)
  output <- .iot$register_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_thing <- iot_register_thing

#' Rejects a pending certificate transfer
#'
#' Rejects a pending certificate transfer. After AWS IoT rejects a
#' certificate transfer, the certificate status changes from
#' **PENDING\\_TRANSFER** to **INACTIVE**.
#' 
#' To check for pending certificate transfers, call ListCertificates to
#' enumerate your certificates.
#' 
#' This operation can only be called by the transfer destination. After it
#' is called, the certificate will be returned to the source\'s account in
#' the INACTIVE state.
#'
#' @usage
#' iot_reject_certificate_transfer(certificateId, rejectReason)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param rejectReason The reason the certificate transfer was rejected.
#'
#' @section Request syntax:
#' ```
#' svc$reject_certificate_transfer(
#'   certificateId = "string",
#'   rejectReason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_reject_certificate_transfer
iot_reject_certificate_transfer <- function(certificateId, rejectReason = NULL) {
  op <- new_operation(
    name = "RejectCertificateTransfer",
    http_method = "PATCH",
    http_path = "/reject-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$reject_certificate_transfer_input(certificateId = certificateId, rejectReason = rejectReason)
  output <- .iot$reject_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$reject_certificate_transfer <- iot_reject_certificate_transfer

#' Removes the given thing from the billing group
#'
#' Removes the given thing from the billing group.
#'
#' @usage
#' iot_remove_thing_from_billing_group(billingGroupName, billingGroupArn,
#'   thingName, thingArn)
#'
#' @param billingGroupName The name of the billing group.
#' @param billingGroupArn The ARN of the billing group.
#' @param thingName The name of the thing to be removed from the billing group.
#' @param thingArn The ARN of the thing to be removed from the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$remove_thing_from_billing_group(
#'   billingGroupName = "string",
#'   billingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_remove_thing_from_billing_group
iot_remove_thing_from_billing_group <- function(billingGroupName = NULL, billingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "RemoveThingFromBillingGroup",
    http_method = "PUT",
    http_path = "/billing-groups/removeThingFromBillingGroup",
    paginator = list()
  )
  input <- .iot$remove_thing_from_billing_group_input(billingGroupName = billingGroupName, billingGroupArn = billingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$remove_thing_from_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$remove_thing_from_billing_group <- iot_remove_thing_from_billing_group

#' Remove the specified thing from the specified group
#'
#' Remove the specified thing from the specified group.
#'
#' @usage
#' iot_remove_thing_from_thing_group(thingGroupName, thingGroupArn,
#'   thingName, thingArn)
#'
#' @param thingGroupName The group name.
#' @param thingGroupArn The group ARN.
#' @param thingName The name of the thing to remove from the group.
#' @param thingArn The ARN of the thing to remove from the group.
#'
#' @section Request syntax:
#' ```
#' svc$remove_thing_from_thing_group(
#'   thingGroupName = "string",
#'   thingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_remove_thing_from_thing_group
iot_remove_thing_from_thing_group <- function(thingGroupName = NULL, thingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "RemoveThingFromThingGroup",
    http_method = "PUT",
    http_path = "/thing-groups/removeThingFromThingGroup",
    paginator = list()
  )
  input <- .iot$remove_thing_from_thing_group_input(thingGroupName = thingGroupName, thingGroupArn = thingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$remove_thing_from_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$remove_thing_from_thing_group <- iot_remove_thing_from_thing_group

#' Replaces the rule
#'
#' Replaces the rule. You must specify all parameters for the new rule.
#' Creating rules is an administrator-level action. Any user who has
#' permission to create rules will be able to access data processed by the
#' rule.
#'
#' @usage
#' iot_replace_topic_rule(ruleName, topicRulePayload)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#' @param topicRulePayload &#91;required&#93; The rule payload.
#'
#' @section Request syntax:
#' ```
#' svc$replace_topic_rule(
#'   ruleName = "string",
#'   topicRulePayload = list(
#'     sql = "string",
#'     description = "string",
#'     actions = list(
#'       list(
#'         dynamoDB = list(
#'           tableName = "string",
#'           roleArn = "string",
#'           operation = "string",
#'           hashKeyField = "string",
#'           hashKeyValue = "string",
#'           hashKeyType = "STRING"|"NUMBER",
#'           rangeKeyField = "string",
#'           rangeKeyValue = "string",
#'           rangeKeyType = "STRING"|"NUMBER",
#'           payloadField = "string"
#'         ),
#'         dynamoDBv2 = list(
#'           roleArn = "string",
#'           putItem = list(
#'             tableName = "string"
#'           )
#'         ),
#'         lambda = list(
#'           functionArn = "string"
#'         ),
#'         sns = list(
#'           targetArn = "string",
#'           roleArn = "string",
#'           messageFormat = "RAW"|"JSON"
#'         ),
#'         sqs = list(
#'           roleArn = "string",
#'           queueUrl = "string",
#'           useBase64 = TRUE|FALSE
#'         ),
#'         kinesis = list(
#'           roleArn = "string",
#'           streamName = "string",
#'           partitionKey = "string"
#'         ),
#'         republish = list(
#'           roleArn = "string",
#'           topic = "string"
#'         ),
#'         s3 = list(
#'           roleArn = "string",
#'           bucketName = "string",
#'           key = "string",
#'           cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'         ),
#'         firehose = list(
#'           roleArn = "string",
#'           deliveryStreamName = "string",
#'           separator = "string"
#'         ),
#'         cloudwatchMetric = list(
#'           roleArn = "string",
#'           metricNamespace = "string",
#'           metricName = "string",
#'           metricValue = "string",
#'           metricUnit = "string",
#'           metricTimestamp = "string"
#'         ),
#'         cloudwatchAlarm = list(
#'           roleArn = "string",
#'           alarmName = "string",
#'           stateReason = "string",
#'           stateValue = "string"
#'         ),
#'         elasticsearch = list(
#'           roleArn = "string",
#'           endpoint = "string",
#'           index = "string",
#'           type = "string",
#'           id = "string"
#'         ),
#'         salesforce = list(
#'           token = "string",
#'           url = "string"
#'         ),
#'         iotAnalytics = list(
#'           channelArn = "string",
#'           channelName = "string",
#'           roleArn = "string"
#'         ),
#'         iotEvents = list(
#'           inputName = "string",
#'           messageId = "string",
#'           roleArn = "string"
#'         ),
#'         stepFunctions = list(
#'           executionNamePrefix = "string",
#'           stateMachineName = "string",
#'           roleArn = "string"
#'         )
#'       )
#'     ),
#'     ruleDisabled = TRUE|FALSE,
#'     awsIotSqlVersion = "string",
#'     errorAction = list(
#'       dynamoDB = list(
#'         tableName = "string",
#'         roleArn = "string",
#'         operation = "string",
#'         hashKeyField = "string",
#'         hashKeyValue = "string",
#'         hashKeyType = "STRING"|"NUMBER",
#'         rangeKeyField = "string",
#'         rangeKeyValue = "string",
#'         rangeKeyType = "STRING"|"NUMBER",
#'         payloadField = "string"
#'       ),
#'       dynamoDBv2 = list(
#'         roleArn = "string",
#'         putItem = list(
#'           tableName = "string"
#'         )
#'       ),
#'       lambda = list(
#'         functionArn = "string"
#'       ),
#'       sns = list(
#'         targetArn = "string",
#'         roleArn = "string",
#'         messageFormat = "RAW"|"JSON"
#'       ),
#'       sqs = list(
#'         roleArn = "string",
#'         queueUrl = "string",
#'         useBase64 = TRUE|FALSE
#'       ),
#'       kinesis = list(
#'         roleArn = "string",
#'         streamName = "string",
#'         partitionKey = "string"
#'       ),
#'       republish = list(
#'         roleArn = "string",
#'         topic = "string"
#'       ),
#'       s3 = list(
#'         roleArn = "string",
#'         bucketName = "string",
#'         key = "string",
#'         cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'       ),
#'       firehose = list(
#'         roleArn = "string",
#'         deliveryStreamName = "string",
#'         separator = "string"
#'       ),
#'       cloudwatchMetric = list(
#'         roleArn = "string",
#'         metricNamespace = "string",
#'         metricName = "string",
#'         metricValue = "string",
#'         metricUnit = "string",
#'         metricTimestamp = "string"
#'       ),
#'       cloudwatchAlarm = list(
#'         roleArn = "string",
#'         alarmName = "string",
#'         stateReason = "string",
#'         stateValue = "string"
#'       ),
#'       elasticsearch = list(
#'         roleArn = "string",
#'         endpoint = "string",
#'         index = "string",
#'         type = "string",
#'         id = "string"
#'       ),
#'       salesforce = list(
#'         token = "string",
#'         url = "string"
#'       ),
#'       iotAnalytics = list(
#'         channelArn = "string",
#'         channelName = "string",
#'         roleArn = "string"
#'       ),
#'       iotEvents = list(
#'         inputName = "string",
#'         messageId = "string",
#'         roleArn = "string"
#'       ),
#'       stepFunctions = list(
#'         executionNamePrefix = "string",
#'         stateMachineName = "string",
#'         roleArn = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_replace_topic_rule
iot_replace_topic_rule <- function(ruleName, topicRulePayload) {
  op <- new_operation(
    name = "ReplaceTopicRule",
    http_method = "PATCH",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$replace_topic_rule_input(ruleName = ruleName, topicRulePayload = topicRulePayload)
  output <- .iot$replace_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$replace_topic_rule <- iot_replace_topic_rule

#' The query search index
#'
#' The query search index.
#'
#' @usage
#' iot_search_index(indexName, queryString, nextToken, maxResults,
#'   queryVersion)
#'
#' @param indexName The search index name.
#' @param queryString &#91;required&#93; The search query string.
#' @param nextToken The token used to get the next set of results, or null if there are no
#' additional results.
#' @param maxResults The maximum number of results to return at one time.
#' @param queryVersion The query version.
#'
#' @section Request syntax:
#' ```
#' svc$search_index(
#'   indexName = "string",
#'   queryString = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_search_index
iot_search_index <- function(indexName = NULL, queryString, nextToken = NULL, maxResults = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "SearchIndex",
    http_method = "POST",
    http_path = "/indices/search",
    paginator = list()
  )
  input <- .iot$search_index_input(indexName = indexName, queryString = queryString, nextToken = nextToken, maxResults = maxResults, queryVersion = queryVersion)
  output <- .iot$search_index_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$search_index <- iot_search_index

#' Sets the default authorizer
#'
#' Sets the default authorizer. This will be used if a websocket connection
#' is made without specifying an authorizer.
#'
#' @usage
#' iot_set_default_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#'
#' @section Request syntax:
#' ```
#' svc$set_default_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_default_authorizer
iot_set_default_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "SetDefaultAuthorizer",
    http_method = "POST",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$set_default_authorizer_input(authorizerName = authorizerName)
  output <- .iot$set_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_default_authorizer <- iot_set_default_authorizer

#' Sets the specified version of the specified policy as the policy's
#' default (operative) version
#'
#' Sets the specified version of the specified policy as the policy\'s
#' default (operative) version. This action affects all certificates to
#' which the policy is attached. To list the principals the policy is
#' attached to, use the ListPrincipalPolicy API.
#'
#' @usage
#' iot_set_default_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$set_default_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_default_policy_version
iot_set_default_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "SetDefaultPolicyVersion",
    http_method = "PATCH",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$set_default_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$set_default_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_default_policy_version <- iot_set_default_policy_version

#' Sets the logging options
#'
#' Sets the logging options.
#' 
#' NOTE: use of this command is not recommended. Use `SetV2LoggingOptions`
#' instead.
#'
#' @usage
#' iot_set_logging_options(loggingOptionsPayload)
#'
#' @param loggingOptionsPayload &#91;required&#93; The logging options payload.
#'
#' @section Request syntax:
#' ```
#' svc$set_logging_options(
#'   loggingOptionsPayload = list(
#'     roleArn = "string",
#'     logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_logging_options
iot_set_logging_options <- function(loggingOptionsPayload) {
  op <- new_operation(
    name = "SetLoggingOptions",
    http_method = "POST",
    http_path = "/loggingOptions",
    paginator = list()
  )
  input <- .iot$set_logging_options_input(loggingOptionsPayload = loggingOptionsPayload)
  output <- .iot$set_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_logging_options <- iot_set_logging_options

#' Sets the logging level
#'
#' Sets the logging level.
#'
#' @usage
#' iot_set_v2_logging_level(logTarget, logLevel)
#'
#' @param logTarget &#91;required&#93; The log target.
#' @param logLevel &#91;required&#93; The log level.
#'
#' @section Request syntax:
#' ```
#' svc$set_v2_logging_level(
#'   logTarget = list(
#'     targetType = "DEFAULT"|"THING_GROUP",
#'     targetName = "string"
#'   ),
#'   logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_v2_logging_level
iot_set_v2_logging_level <- function(logTarget, logLevel) {
  op <- new_operation(
    name = "SetV2LoggingLevel",
    http_method = "POST",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$set_v2_logging_level_input(logTarget = logTarget, logLevel = logLevel)
  output <- .iot$set_v2_logging_level_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_v2_logging_level <- iot_set_v2_logging_level

#' Sets the logging options for the V2 logging service
#'
#' Sets the logging options for the V2 logging service.
#'
#' @usage
#' iot_set_v2_logging_options(roleArn, defaultLogLevel, disableAllLogs)
#'
#' @param roleArn The ARN of the role that allows IoT to write to Cloudwatch logs.
#' @param defaultLogLevel The default logging level.
#' @param disableAllLogs If true all logs are disabled. The default is false.
#'
#' @section Request syntax:
#' ```
#' svc$set_v2_logging_options(
#'   roleArn = "string",
#'   defaultLogLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED",
#'   disableAllLogs = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_v2_logging_options
iot_set_v2_logging_options <- function(roleArn = NULL, defaultLogLevel = NULL, disableAllLogs = NULL) {
  op <- new_operation(
    name = "SetV2LoggingOptions",
    http_method = "POST",
    http_path = "/v2LoggingOptions",
    paginator = list()
  )
  input <- .iot$set_v2_logging_options_input(roleArn = roleArn, defaultLogLevel = defaultLogLevel, disableAllLogs = disableAllLogs)
  output <- .iot$set_v2_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_v2_logging_options <- iot_set_v2_logging_options

#' Starts an on-demand Device Defender audit
#'
#' Starts an on-demand Device Defender audit.
#'
#' @usage
#' iot_start_on_demand_audit_task(targetCheckNames)
#'
#' @param targetCheckNames &#91;required&#93; Which checks are performed during the audit. The checks you specify must
#' be enabled for your account or an exception occurs. Use
#' `DescribeAccountAuditConfiguration` to see the list of all checks
#' including those that are enabled or `UpdateAccountAuditConfiguration` to
#' select which checks are enabled.
#'
#' @section Request syntax:
#' ```
#' svc$start_on_demand_audit_task(
#'   targetCheckNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_on_demand_audit_task
iot_start_on_demand_audit_task <- function(targetCheckNames) {
  op <- new_operation(
    name = "StartOnDemandAuditTask",
    http_method = "POST",
    http_path = "/audit/tasks",
    paginator = list()
  )
  input <- .iot$start_on_demand_audit_task_input(targetCheckNames = targetCheckNames)
  output <- .iot$start_on_demand_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_on_demand_audit_task <- iot_start_on_demand_audit_task

#' Creates a bulk thing provisioning task
#'
#' Creates a bulk thing provisioning task.
#'
#' @usage
#' iot_start_thing_registration_task(templateBody, inputFileBucket,
#'   inputFileKey, roleArn)
#'
#' @param templateBody &#91;required&#93; The provisioning template.
#' @param inputFileBucket &#91;required&#93; The S3 bucket that contains the input file.
#' @param inputFileKey &#91;required&#93; The name of input file within the S3 bucket. This file contains a
#' newline delimited JSON file. Each line contains the parameter values to
#' provision one device (thing).
#' @param roleArn &#91;required&#93; The IAM role ARN that grants permission the input file.
#'
#' @section Request syntax:
#' ```
#' svc$start_thing_registration_task(
#'   templateBody = "string",
#'   inputFileBucket = "string",
#'   inputFileKey = "string",
#'   roleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_thing_registration_task
iot_start_thing_registration_task <- function(templateBody, inputFileBucket, inputFileKey, roleArn) {
  op <- new_operation(
    name = "StartThingRegistrationTask",
    http_method = "POST",
    http_path = "/thing-registration-tasks",
    paginator = list()
  )
  input <- .iot$start_thing_registration_task_input(templateBody = templateBody, inputFileBucket = inputFileBucket, inputFileKey = inputFileKey, roleArn = roleArn)
  output <- .iot$start_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_thing_registration_task <- iot_start_thing_registration_task

#' Cancels a bulk thing provisioning task
#'
#' Cancels a bulk thing provisioning task.
#'
#' @usage
#' iot_stop_thing_registration_task(taskId)
#'
#' @param taskId &#91;required&#93; The bulk thing provisioning task ID.
#'
#' @section Request syntax:
#' ```
#' svc$stop_thing_registration_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_stop_thing_registration_task
iot_stop_thing_registration_task <- function(taskId) {
  op <- new_operation(
    name = "StopThingRegistrationTask",
    http_method = "PUT",
    http_path = "/thing-registration-tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$stop_thing_registration_task_input(taskId = taskId)
  output <- .iot$stop_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$stop_thing_registration_task <- iot_stop_thing_registration_task

#' Adds to or modifies the tags of the given resource
#'
#' Adds to or modifies the tags of the given resource. Tags are metadata
#' which can be used to manage a resource.
#'
#' @usage
#' iot_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param tags &#91;required&#93; The new or modified tags for the resource.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_tag_resource
iot_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags",
    paginator = list()
  )
  input <- .iot$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .iot$tag_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$tag_resource <- iot_tag_resource

#' Tests if a specified principal is authorized to perform an AWS IoT
#' action on a specified resource
#'
#' Tests if a specified principal is authorized to perform an AWS IoT
#' action on a specified resource. Use this to test and debug the
#' authorization behavior of devices that connect to the AWS IoT device
#' gateway.
#'
#' @usage
#' iot_test_authorization(principal, cognitoIdentityPoolId, authInfos,
#'   clientId, policyNamesToAdd, policyNamesToSkip)
#'
#' @param principal The principal.
#' @param cognitoIdentityPoolId The Cognito identity pool ID.
#' @param authInfos &#91;required&#93; A list of authorization info objects. Simulating authorization will
#' create a response for each `authInfo` object in the list.
#' @param clientId The MQTT client ID.
#' @param policyNamesToAdd When testing custom authorization, the policies specified here are
#' treated as if they are attached to the principal being authorized.
#' @param policyNamesToSkip When testing custom authorization, the policies specified here are
#' treated as if they are not attached to the principal being authorized.
#'
#' @section Request syntax:
#' ```
#' svc$test_authorization(
#'   principal = "string",
#'   cognitoIdentityPoolId = "string",
#'   authInfos = list(
#'     list(
#'       actionType = "PUBLISH"|"SUBSCRIBE"|"RECEIVE"|"CONNECT",
#'       resources = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   clientId = "string",
#'   policyNamesToAdd = list(
#'     "string"
#'   ),
#'   policyNamesToSkip = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_test_authorization
iot_test_authorization <- function(principal = NULL, cognitoIdentityPoolId = NULL, authInfos, clientId = NULL, policyNamesToAdd = NULL, policyNamesToSkip = NULL) {
  op <- new_operation(
    name = "TestAuthorization",
    http_method = "POST",
    http_path = "/test-authorization",
    paginator = list()
  )
  input <- .iot$test_authorization_input(principal = principal, cognitoIdentityPoolId = cognitoIdentityPoolId, authInfos = authInfos, clientId = clientId, policyNamesToAdd = policyNamesToAdd, policyNamesToSkip = policyNamesToSkip)
  output <- .iot$test_authorization_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$test_authorization <- iot_test_authorization

#' Tests a custom authorization behavior by invoking a specified custom
#' authorizer
#'
#' Tests a custom authorization behavior by invoking a specified custom
#' authorizer. Use this to test and debug the custom authorization behavior
#' of devices that connect to the AWS IoT device gateway.
#'
#' @usage
#' iot_test_invoke_authorizer(authorizerName, token, tokenSignature)
#'
#' @param authorizerName &#91;required&#93; The custom authorizer name.
#' @param token &#91;required&#93; The token returned by your custom authentication service.
#' @param tokenSignature &#91;required&#93; The signature made with the token and your custom authentication
#' service\'s private key.
#'
#' @section Request syntax:
#' ```
#' svc$test_invoke_authorizer(
#'   authorizerName = "string",
#'   token = "string",
#'   tokenSignature = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_test_invoke_authorizer
iot_test_invoke_authorizer <- function(authorizerName, token, tokenSignature) {
  op <- new_operation(
    name = "TestInvokeAuthorizer",
    http_method = "POST",
    http_path = "/authorizer/{authorizerName}/test",
    paginator = list()
  )
  input <- .iot$test_invoke_authorizer_input(authorizerName = authorizerName, token = token, tokenSignature = tokenSignature)
  output <- .iot$test_invoke_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$test_invoke_authorizer <- iot_test_invoke_authorizer

#' Transfers the specified certificate to the specified AWS account
#'
#' Transfers the specified certificate to the specified AWS account.
#' 
#' You can cancel the transfer until it is acknowledged by the recipient.
#' 
#' No notification is sent to the transfer destination\'s account. It is up
#' to the caller to notify the transfer target.
#' 
#' The certificate being transferred must not be in the ACTIVE state. You
#' can use the UpdateCertificate API to deactivate it.
#' 
#' The certificate must not have any policies attached to it. You can use
#' the DetachPrincipalPolicy API to detach them.
#'
#' @usage
#' iot_transfer_certificate(certificateId, targetAwsAccount,
#'   transferMessage)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param targetAwsAccount &#91;required&#93; The AWS account.
#' @param transferMessage The transfer message.
#'
#' @section Request syntax:
#' ```
#' svc$transfer_certificate(
#'   certificateId = "string",
#'   targetAwsAccount = "string",
#'   transferMessage = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_transfer_certificate
iot_transfer_certificate <- function(certificateId, targetAwsAccount, transferMessage = NULL) {
  op <- new_operation(
    name = "TransferCertificate",
    http_method = "PATCH",
    http_path = "/transfer-certificate/{certificateId}",
    paginator = list()
  )
  input <- .iot$transfer_certificate_input(certificateId = certificateId, targetAwsAccount = targetAwsAccount, transferMessage = transferMessage)
  output <- .iot$transfer_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$transfer_certificate <- iot_transfer_certificate

#' Removes the given tags (metadata) from the resource
#'
#' Removes the given tags (metadata) from the resource.
#'
#' @usage
#' iot_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param tagKeys &#91;required&#93; A list of the keys of the tags to be removed from the resource.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_untag_resource
iot_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/untag",
    paginator = list()
  )
  input <- .iot$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .iot$untag_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$untag_resource <- iot_untag_resource

#' Configures or reconfigures the Device Defender audit settings for this
#' account
#'
#' Configures or reconfigures the Device Defender audit settings for this
#' account. Settings include how audit notifications are sent and which
#' audit checks are enabled or disabled.
#'
#' @usage
#' iot_update_account_audit_configuration(roleArn,
#'   auditNotificationTargetConfigurations, auditCheckConfigurations)
#'
#' @param roleArn The ARN of the role that grants permission to AWS IoT to access
#' information about your devices, policies, certificates and other items
#' as necessary when performing an audit.
#' @param auditNotificationTargetConfigurations Information about the targets to which audit notifications are sent.
#' @param auditCheckConfigurations Specifies which audit checks are enabled and disabled for this account.
#' Use `DescribeAccountAuditConfiguration` to see the list of all checks
#' including those that are currently enabled.
#' 
#' Note that some data collection may begin immediately when certain checks
#' are enabled. When a check is disabled, any data collected so far in
#' relation to the check is deleted.
#' 
#' You cannot disable a check if it is used by any scheduled audit. You
#' must first delete the check from the scheduled audit or delete the
#' scheduled audit itself.
#' 
#' On the first call to `UpdateAccountAuditConfiguration` this parameter is
#' required and must specify at least one enabled check.
#'
#' @section Request syntax:
#' ```
#' svc$update_account_audit_configuration(
#'   roleArn = "string",
#'   auditNotificationTargetConfigurations = list(
#'     list(
#'       targetArn = "string",
#'       roleArn = "string",
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   auditCheckConfigurations = list(
#'     list(
#'       enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_account_audit_configuration
iot_update_account_audit_configuration <- function(roleArn = NULL, auditNotificationTargetConfigurations = NULL, auditCheckConfigurations = NULL) {
  op <- new_operation(
    name = "UpdateAccountAuditConfiguration",
    http_method = "PATCH",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$update_account_audit_configuration_input(roleArn = roleArn, auditNotificationTargetConfigurations = auditNotificationTargetConfigurations, auditCheckConfigurations = auditCheckConfigurations)
  output <- .iot$update_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_account_audit_configuration <- iot_update_account_audit_configuration

#' Updates an authorizer
#'
#' Updates an authorizer.
#'
#' @usage
#' iot_update_authorizer(authorizerName, authorizerFunctionArn,
#'   tokenKeyName, tokenSigningPublicKeys, status)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#' @param authorizerFunctionArn The ARN of the authorizer\'s Lambda function.
#' @param tokenKeyName The key used to extract the token from the HTTP headers.
#' @param tokenSigningPublicKeys The public keys used to verify the token signature.
#' @param status The status of the update authorizer request.
#'
#' @section Request syntax:
#' ```
#' svc$update_authorizer(
#'   authorizerName = "string",
#'   authorizerFunctionArn = "string",
#'   tokenKeyName = "string",
#'   tokenSigningPublicKeys = list(
#'     "string"
#'   ),
#'   status = "ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_authorizer
iot_update_authorizer <- function(authorizerName, authorizerFunctionArn = NULL, tokenKeyName = NULL, tokenSigningPublicKeys = NULL, status = NULL) {
  op <- new_operation(
    name = "UpdateAuthorizer",
    http_method = "PUT",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$update_authorizer_input(authorizerName = authorizerName, authorizerFunctionArn = authorizerFunctionArn, tokenKeyName = tokenKeyName, tokenSigningPublicKeys = tokenSigningPublicKeys, status = status)
  output <- .iot$update_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_authorizer <- iot_update_authorizer

#' Updates information about the billing group
#'
#' Updates information about the billing group.
#'
#' @usage
#' iot_update_billing_group(billingGroupName, billingGroupProperties,
#'   expectedVersion)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param billingGroupProperties &#91;required&#93; The properties of the billing group.
#' @param expectedVersion The expected version of the billing group. If the version of the billing
#' group does not match the expected version specified in the request, the
#' `UpdateBillingGroup` request is rejected with a
#' `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$update_billing_group(
#'   billingGroupName = "string",
#'   billingGroupProperties = list(
#'     billingGroupDescription = "string"
#'   ),
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_billing_group
iot_update_billing_group <- function(billingGroupName, billingGroupProperties, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateBillingGroup",
    http_method = "PATCH",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$update_billing_group_input(billingGroupName = billingGroupName, billingGroupProperties = billingGroupProperties, expectedVersion = expectedVersion)
  output <- .iot$update_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_billing_group <- iot_update_billing_group

#' Updates a registered CA certificate
#'
#' Updates a registered CA certificate.
#'
#' @usage
#' iot_update_ca_certificate(certificateId, newStatus,
#'   newAutoRegistrationStatus, registrationConfig, removeAutoRegistration)
#'
#' @param certificateId &#91;required&#93; The CA certificate identifier.
#' @param newStatus The updated status of the CA certificate.
#' 
#' **Note:** The status value REGISTER\\_INACTIVE is deprecated and should
#' not be used.
#' @param newAutoRegistrationStatus The new value for the auto registration status. Valid values are:
#' \"ENABLE\" or \"DISABLE\".
#' @param registrationConfig Information about the registration configuration.
#' @param removeAutoRegistration If true, remove auto registration.
#'
#' @section Request syntax:
#' ```
#' svc$update_ca_certificate(
#'   certificateId = "string",
#'   newStatus = "ACTIVE"|"INACTIVE",
#'   newAutoRegistrationStatus = "ENABLE"|"DISABLE",
#'   registrationConfig = list(
#'     templateBody = "string",
#'     roleArn = "string"
#'   ),
#'   removeAutoRegistration = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_ca_certificate
iot_update_ca_certificate <- function(certificateId, newStatus = NULL, newAutoRegistrationStatus = NULL, registrationConfig = NULL, removeAutoRegistration = NULL) {
  op <- new_operation(
    name = "UpdateCACertificate",
    http_method = "PUT",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$update_ca_certificate_input(certificateId = certificateId, newStatus = newStatus, newAutoRegistrationStatus = newAutoRegistrationStatus, registrationConfig = registrationConfig, removeAutoRegistration = removeAutoRegistration)
  output <- .iot$update_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_ca_certificate <- iot_update_ca_certificate

#' Updates the status of the specified certificate
#'
#' Updates the status of the specified certificate. This operation is
#' idempotent.
#' 
#' Moving a certificate from the ACTIVE state (including REVOKED) will not
#' disconnect currently connected devices, but these devices will be unable
#' to reconnect.
#' 
#' The ACTIVE state is required to authenticate devices connecting to AWS
#' IoT using a certificate.
#'
#' @usage
#' iot_update_certificate(certificateId, newStatus)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param newStatus &#91;required&#93; The new status.
#' 
#' **Note:** Setting the status to PENDING\\_TRANSFER will result in an
#' exception being thrown. PENDING\\_TRANSFER is a status used internally by
#' AWS IoT. It is not intended for developer use.
#' 
#' **Note:** The status value REGISTER\\_INACTIVE is deprecated and should
#' not be used.
#'
#' @section Request syntax:
#' ```
#' svc$update_certificate(
#'   certificateId = "string",
#'   newStatus = "ACTIVE"|"INACTIVE"|"REVOKED"|"PENDING_TRANSFER"|"REGISTER_INACTIVE"|"PENDING_ACTIVATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_certificate
iot_update_certificate <- function(certificateId, newStatus) {
  op <- new_operation(
    name = "UpdateCertificate",
    http_method = "PUT",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$update_certificate_input(certificateId = certificateId, newStatus = newStatus)
  output <- .iot$update_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_certificate <- iot_update_certificate

#' Updates a dynamic thing group
#'
#' Updates a dynamic thing group.
#'
#' @usage
#' iot_update_dynamic_thing_group(thingGroupName, thingGroupProperties,
#'   expectedVersion, indexName, queryString, queryVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the dynamic thing group to update.
#' @param thingGroupProperties &#91;required&#93; The dynamic thing group properties to update.
#' @param expectedVersion The expected version of the dynamic thing group to update.
#' @param indexName The dynamic thing group index to update.
#' 
#' Currently one index is supported: \'AWS\\_Things\'.
#' @param queryString The dynamic thing group search query string to update.
#' @param queryVersion The dynamic thing group query version to update.
#' 
#' Currently one query version is supported: \"2017-09-30\". If not
#' specified, the query version defaults to this value.
#'
#' @section Request syntax:
#' ```
#' svc$update_dynamic_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   expectedVersion = 123,
#'   indexName = "string",
#'   queryString = "string",
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_dynamic_thing_group
iot_update_dynamic_thing_group <- function(thingGroupName, thingGroupProperties, expectedVersion = NULL, indexName = NULL, queryString = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "UpdateDynamicThingGroup",
    http_method = "PATCH",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$update_dynamic_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, expectedVersion = expectedVersion, indexName = indexName, queryString = queryString, queryVersion = queryVersion)
  output <- .iot$update_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_dynamic_thing_group <- iot_update_dynamic_thing_group

#' Updates the event configurations
#'
#' Updates the event configurations.
#'
#' @usage
#' iot_update_event_configurations(eventConfigurations)
#'
#' @param eventConfigurations The new event configuration values.
#'
#' @section Request syntax:
#' ```
#' svc$update_event_configurations(
#'   eventConfigurations = list(
#'     list(
#'       Enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_event_configurations
iot_update_event_configurations <- function(eventConfigurations = NULL) {
  op <- new_operation(
    name = "UpdateEventConfigurations",
    http_method = "PATCH",
    http_path = "/event-configurations",
    paginator = list()
  )
  input <- .iot$update_event_configurations_input(eventConfigurations = eventConfigurations)
  output <- .iot$update_event_configurations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_event_configurations <- iot_update_event_configurations

#' Updates the search configuration
#'
#' Updates the search configuration.
#'
#' @usage
#' iot_update_indexing_configuration(thingIndexingConfiguration,
#'   thingGroupIndexingConfiguration)
#'
#' @param thingIndexingConfiguration Thing indexing configuration.
#' @param thingGroupIndexingConfiguration Thing group indexing configuration.
#'
#' @section Request syntax:
#' ```
#' svc$update_indexing_configuration(
#'   thingIndexingConfiguration = list(
#'     thingIndexingMode = "OFF"|"REGISTRY"|"REGISTRY_AND_SHADOW",
#'     thingConnectivityIndexingMode = "OFF"|"STATUS"
#'   ),
#'   thingGroupIndexingConfiguration = list(
#'     thingGroupIndexingMode = "OFF"|"ON"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_indexing_configuration
iot_update_indexing_configuration <- function(thingIndexingConfiguration = NULL, thingGroupIndexingConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateIndexingConfiguration",
    http_method = "POST",
    http_path = "/indexing/config",
    paginator = list()
  )
  input <- .iot$update_indexing_configuration_input(thingIndexingConfiguration = thingIndexingConfiguration, thingGroupIndexingConfiguration = thingGroupIndexingConfiguration)
  output <- .iot$update_indexing_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_indexing_configuration <- iot_update_indexing_configuration

#' Updates supported fields of the specified job
#'
#' Updates supported fields of the specified job.
#'
#' @usage
#' iot_update_job(jobId, description, presignedUrlConfig,
#'   jobExecutionsRolloutConfig, abortConfig, timeoutConfig)
#'
#' @param jobId &#91;required&#93; The ID of the job to be updated.
#' @param description A short text description of the job.
#' @param presignedUrlConfig Configuration information for pre-signed S3 URLs.
#' @param jobExecutionsRolloutConfig Allows you to create a staged rollout of the job.
#' @param abortConfig Allows you to create criteria to abort a job.
#' @param timeoutConfig Specifies the amount of time each device has to finish its execution of
#' the job. The timer is started when the job execution status is set to
#' `IN_PROGRESS`. If the job execution status is not set to another
#' terminal state before the time expires, it will be automatically set to
#' `TIMED_OUT`.
#'
#' @section Request syntax:
#' ```
#' svc$update_job(
#'   jobId = "string",
#'   description = "string",
#'   presignedUrlConfig = list(
#'     roleArn = "string",
#'     expiresInSec = 123
#'   ),
#'   jobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123,
#'     exponentialRate = list(
#'       baseRatePerMinute = 123,
#'       incrementFactor = 123.0,
#'       rateIncreaseCriteria = list(
#'         numberOfNotifiedThings = 123,
#'         numberOfSucceededThings = 123
#'       )
#'     )
#'   ),
#'   abortConfig = list(
#'     criteriaList = list(
#'       list(
#'         failureType = "FAILED"|"REJECTED"|"TIMED_OUT"|"ALL",
#'         action = "CANCEL",
#'         thresholdPercentage = 123.0,
#'         minNumberOfExecutedThings = 123
#'       )
#'     )
#'   ),
#'   timeoutConfig = list(
#'     inProgressTimeoutInMinutes = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_job
iot_update_job <- function(jobId, description = NULL, presignedUrlConfig = NULL, jobExecutionsRolloutConfig = NULL, abortConfig = NULL, timeoutConfig = NULL) {
  op <- new_operation(
    name = "UpdateJob",
    http_method = "PATCH",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$update_job_input(jobId = jobId, description = description, presignedUrlConfig = presignedUrlConfig, jobExecutionsRolloutConfig = jobExecutionsRolloutConfig, abortConfig = abortConfig, timeoutConfig = timeoutConfig)
  output <- .iot$update_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_job <- iot_update_job

#' Updates a role alias
#'
#' Updates a role alias.
#'
#' @usage
#' iot_update_role_alias(roleAlias, roleArn, credentialDurationSeconds)
#'
#' @param roleAlias &#91;required&#93; The role alias to update.
#' @param roleArn The role ARN.
#' @param credentialDurationSeconds The number of seconds the credential will be valid.
#'
#' @section Request syntax:
#' ```
#' svc$update_role_alias(
#'   roleAlias = "string",
#'   roleArn = "string",
#'   credentialDurationSeconds = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_role_alias
iot_update_role_alias <- function(roleAlias, roleArn = NULL, credentialDurationSeconds = NULL) {
  op <- new_operation(
    name = "UpdateRoleAlias",
    http_method = "PUT",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$update_role_alias_input(roleAlias = roleAlias, roleArn = roleArn, credentialDurationSeconds = credentialDurationSeconds)
  output <- .iot$update_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_role_alias <- iot_update_role_alias

#' Updates a scheduled audit, including what checks are performed and how
#' often the audit takes place
#'
#' Updates a scheduled audit, including what checks are performed and how
#' often the audit takes place.
#'
#' @usage
#' iot_update_scheduled_audit(frequency, dayOfMonth, dayOfWeek,
#'   targetCheckNames, scheduledAuditName)
#'
#' @param frequency How often the scheduled audit takes place. Can be one of \"DAILY\",
#' \"WEEKLY\", \"BIWEEKLY\" or \"MONTHLY\". The actual start time of each
#' audit is determined by the system.
#' @param dayOfMonth The day of the month on which the scheduled audit takes place. Can be
#' \"1\" through \"31\" or \"LAST\". This field is required if the
#' \"frequency\" parameter is set to \"MONTHLY\". If days 29-31 are
#' specified, and the month does not have that many days, the audit takes
#' place on the \"LAST\" day of the month.
#' @param dayOfWeek The day of the week on which the scheduled audit takes place. Can be one
#' of \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\" or \"SAT\". This
#' field is required if the \"frequency\" parameter is set to \"WEEKLY\" or
#' \"BIWEEKLY\".
#' @param targetCheckNames Which checks are performed during the scheduled audit. Checks must be
#' enabled for your account. (Use `DescribeAccountAuditConfiguration` to
#' see the list of all checks including those that are enabled or
#' `UpdateAccountAuditConfiguration` to select which checks are enabled.)
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit. (Max. 128 chars)
#'
#' @section Request syntax:
#' ```
#' svc$update_scheduled_audit(
#'   frequency = "DAILY"|"WEEKLY"|"BIWEEKLY"|"MONTHLY",
#'   dayOfMonth = "string",
#'   dayOfWeek = "SUN"|"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT",
#'   targetCheckNames = list(
#'     "string"
#'   ),
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_scheduled_audit
iot_update_scheduled_audit <- function(frequency = NULL, dayOfMonth = NULL, dayOfWeek = NULL, targetCheckNames = NULL, scheduledAuditName) {
  op <- new_operation(
    name = "UpdateScheduledAudit",
    http_method = "PATCH",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$update_scheduled_audit_input(frequency = frequency, dayOfMonth = dayOfMonth, dayOfWeek = dayOfWeek, targetCheckNames = targetCheckNames, scheduledAuditName = scheduledAuditName)
  output <- .iot$update_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_scheduled_audit <- iot_update_scheduled_audit

#' Updates a Device Defender security profile
#'
#' Updates a Device Defender security profile.
#'
#' @usage
#' iot_update_security_profile(securityProfileName,
#'   securityProfileDescription, behaviors, alertTargets,
#'   additionalMetricsToRetain, deleteBehaviors, deleteAlertTargets,
#'   deleteAdditionalMetricsToRetain, expectedVersion)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile you want to update.
#' @param securityProfileDescription A description of the security profile.
#' @param behaviors Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#' @param alertTargets Where the alerts are sent. (Alerts are always sent to the console.)
#' @param additionalMetricsToRetain A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile\'s `behaviors` but it is
#' also retained for any metric specified here.
#' @param deleteBehaviors If true, delete all `behaviors` defined for this security profile. If
#' any `behaviors` are defined in the current invocation an exception
#' occurs.
#' @param deleteAlertTargets If true, delete all `alertTargets` defined for this security profile. If
#' any `alertTargets` are defined in the current invocation an exception
#' occurs.
#' @param deleteAdditionalMetricsToRetain If true, delete all `additionalMetricsToRetain` defined for this
#' security profile. If any `additionalMetricsToRetain` are defined in the
#' current invocation an exception occurs.
#' @param expectedVersion The expected version of the security profile. A new version is generated
#' whenever the security profile is updated. If you specify a value that is
#' different than the actual version, a `VersionConflictException` is
#' thrown.
#'
#' @section Request syntax:
#' ```
#' svc$update_security_profile(
#'   securityProfileName = "string",
#'   securityProfileDescription = "string",
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         )
#'       )
#'     )
#'   ),
#'   alertTargets = list(
#'     list(
#'       alertTargetArn = "string",
#'       roleArn = "string"
#'     )
#'   ),
#'   additionalMetricsToRetain = list(
#'     "string"
#'   ),
#'   deleteBehaviors = TRUE|FALSE,
#'   deleteAlertTargets = TRUE|FALSE,
#'   deleteAdditionalMetricsToRetain = TRUE|FALSE,
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_security_profile
iot_update_security_profile <- function(securityProfileName, securityProfileDescription = NULL, behaviors = NULL, alertTargets = NULL, additionalMetricsToRetain = NULL, deleteBehaviors = NULL, deleteAlertTargets = NULL, deleteAdditionalMetricsToRetain = NULL, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateSecurityProfile",
    http_method = "PATCH",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$update_security_profile_input(securityProfileName = securityProfileName, securityProfileDescription = securityProfileDescription, behaviors = behaviors, alertTargets = alertTargets, additionalMetricsToRetain = additionalMetricsToRetain, deleteBehaviors = deleteBehaviors, deleteAlertTargets = deleteAlertTargets, deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetain, expectedVersion = expectedVersion)
  output <- .iot$update_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_security_profile <- iot_update_security_profile

#' Updates an existing stream
#'
#' Updates an existing stream. The stream version will be incremented by
#' one.
#'
#' @usage
#' iot_update_stream(streamId, description, files, roleArn)
#'
#' @param streamId &#91;required&#93; The stream ID.
#' @param description The description of the stream.
#' @param files The files associated with the stream.
#' @param roleArn An IAM role that allows the IoT service principal assumes to access your
#' S3 files.
#'
#' @section Request syntax:
#' ```
#' svc$update_stream(
#'   streamId = "string",
#'   description = "string",
#'   files = list(
#'     list(
#'       fileId = 123,
#'       s3Location = list(
#'         bucket = "string",
#'         key = "string",
#'         version = "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_stream
iot_update_stream <- function(streamId, description = NULL, files = NULL, roleArn = NULL) {
  op <- new_operation(
    name = "UpdateStream",
    http_method = "PUT",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$update_stream_input(streamId = streamId, description = description, files = files, roleArn = roleArn)
  output <- .iot$update_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_stream <- iot_update_stream

#' Updates the data for a thing
#'
#' Updates the data for a thing.
#'
#' @usage
#' iot_update_thing(thingName, thingTypeName, attributePayload,
#'   expectedVersion, removeThingType)
#'
#' @param thingName &#91;required&#93; The name of the thing to update.
#' @param thingTypeName The name of the thing type.
#' @param attributePayload A list of thing attributes, a JSON string containing name-value pairs.
#' For example:
#' 
#' `\{\"attributes\":\{\"name1\":\"value2\"\}\}`
#' 
#' This data is used to add new attributes or update existing attributes.
#' @param expectedVersion The expected version of the thing record in the registry. If the version
#' of the record in the registry does not match the expected version
#' specified in the request, the `UpdateThing` request is rejected with a
#' `VersionConflictException`.
#' @param removeThingType Remove a thing type association. If **true**, the association is
#' removed.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing(
#'   thingName = "string",
#'   thingTypeName = "string",
#'   attributePayload = list(
#'     attributes = list(
#'       "string"
#'     ),
#'     merge = TRUE|FALSE
#'   ),
#'   expectedVersion = 123,
#'   removeThingType = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing
iot_update_thing <- function(thingName, thingTypeName = NULL, attributePayload = NULL, expectedVersion = NULL, removeThingType = NULL) {
  op <- new_operation(
    name = "UpdateThing",
    http_method = "PATCH",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$update_thing_input(thingName = thingName, thingTypeName = thingTypeName, attributePayload = attributePayload, expectedVersion = expectedVersion, removeThingType = removeThingType)
  output <- .iot$update_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing <- iot_update_thing

#' Update a thing group
#'
#' Update a thing group.
#'
#' @usage
#' iot_update_thing_group(thingGroupName, thingGroupProperties,
#'   expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The thing group to update.
#' @param thingGroupProperties &#91;required&#93; The thing group properties.
#' @param expectedVersion The expected version of the thing group. If this does not match the
#' version of the thing group being updated, the update will fail.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing_group
iot_update_thing_group <- function(thingGroupName, thingGroupProperties, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateThingGroup",
    http_method = "PATCH",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$update_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, expectedVersion = expectedVersion)
  output <- .iot$update_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing_group <- iot_update_thing_group

#' Updates the groups to which the thing belongs
#'
#' Updates the groups to which the thing belongs.
#'
#' @usage
#' iot_update_thing_groups_for_thing(thingName, thingGroupsToAdd,
#'   thingGroupsToRemove, overrideDynamicGroups)
#'
#' @param thingName The thing whose group memberships will be updated.
#' @param thingGroupsToAdd The groups to which the thing will be added.
#' @param thingGroupsToRemove The groups from which the thing will be removed.
#' @param overrideDynamicGroups Override dynamic thing groups with static thing groups when 10-group
#' limit is reached. If a thing belongs to 10 thing groups, and one or more
#' of those groups are dynamic thing groups, adding a thing to a static
#' group removes the thing from the last dynamic group.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing_groups_for_thing(
#'   thingName = "string",
#'   thingGroupsToAdd = list(
#'     "string"
#'   ),
#'   thingGroupsToRemove = list(
#'     "string"
#'   ),
#'   overrideDynamicGroups = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing_groups_for_thing
iot_update_thing_groups_for_thing <- function(thingName = NULL, thingGroupsToAdd = NULL, thingGroupsToRemove = NULL, overrideDynamicGroups = NULL) {
  op <- new_operation(
    name = "UpdateThingGroupsForThing",
    http_method = "PUT",
    http_path = "/thing-groups/updateThingGroupsForThing",
    paginator = list()
  )
  input <- .iot$update_thing_groups_for_thing_input(thingName = thingName, thingGroupsToAdd = thingGroupsToAdd, thingGroupsToRemove = thingGroupsToRemove, overrideDynamicGroups = overrideDynamicGroups)
  output <- .iot$update_thing_groups_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing_groups_for_thing <- iot_update_thing_groups_for_thing

#' Validates a Device Defender security profile behaviors specification
#'
#' Validates a Device Defender security profile behaviors specification.
#'
#' @usage
#' iot_validate_security_profile_behaviors(behaviors)
#'
#' @param behaviors &#91;required&#93; Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#'
#' @section Request syntax:
#' ```
#' svc$validate_security_profile_behaviors(
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_validate_security_profile_behaviors
iot_validate_security_profile_behaviors <- function(behaviors) {
  op <- new_operation(
    name = "ValidateSecurityProfileBehaviors",
    http_method = "POST",
    http_path = "/security-profile-behaviors/validate",
    paginator = list()
  )
  input <- .iot$validate_security_profile_behaviors_input(behaviors = behaviors)
  output <- .iot$validate_security_profile_behaviors_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$validate_security_profile_behaviors <- iot_validate_security_profile_behaviors

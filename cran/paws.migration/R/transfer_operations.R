# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include transfer_service.R
NULL

#' Instantiates an autoscaling virtual server based on the selected file
#' transfer protocol in AWS
#'
#' @description
#' Instantiates an autoscaling virtual server based on the selected file
#' transfer protocol in AWS. When you make updates to your file transfer
#' protocol-enabled server or when you work with users, use the
#' service-generated `ServerId` property that is assigned to the newly
#' created server.
#'
#' @usage
#' transfer_create_server(Certificate, Domain, EndpointDetails,
#'   EndpointType, HostKey, IdentityProviderDetails, IdentityProviderType,
#'   LoggingRole, Protocols, SecurityPolicyName, Tags)
#'
#' @param Certificate The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM)
#' certificate. Required when `Protocols` is set to `FTPS`.
#' 
#' To request a new public certificate, see [Request a public
#' certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' To import an existing certificate into ACM, see [Importing certificates
#' into
#' ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' To request a private certificate to use FTPS through private IP
#' addresses, see [Request a private
#' certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' Certificates with the following cryptographic algorithms and key sizes
#' are supported:
#' 
#' -   2048-bit RSA (RSA_2048)
#' 
#' -   4096-bit RSA (RSA_4096)
#' 
#' -   Elliptic Prime Curve 256 bit (EC_prime256v1)
#' 
#' -   Elliptic Prime Curve 384 bit (EC_secp384r1)
#' 
#' -   Elliptic Prime Curve 521 bit (EC_secp521r1)
#' 
#' The certificate must be a valid SSL/TLS X.509 version 3 certificate with
#' FQDN or IP address specified and information about the issuer.
#' @param Domain 
#' @param EndpointDetails The virtual private cloud (VPC) endpoint settings that are configured
#' for your server. When you host your endpoint within your VPC, you can
#' make it accessible only to resources within your VPC, or you can attach
#' Elastic IPs and make it accessible to clients over the internet. Your
#' VPC's default security groups are automatically assigned to your
#' endpoint.
#' @param EndpointType The type of VPC endpoint that you want your server to connect to. You
#' can choose to connect to the public internet or a VPC endpoint. With a
#' VPC endpoint, you can restrict access to your server and resources only
#' within your VPC.
#' 
#' It is recommended that you use `VPC` as the `EndpointType`. With this
#' endpoint type, you have the option to directly associate up to three
#' Elastic IPv4 addresses (BYO IP included) with your server's endpoint and
#' use VPC security groups to restrict traffic by the client's public IP
#' address. This is not possible with `EndpointType` set to `VPC_ENDPOINT`.
#' @param HostKey The RSA private key as generated by the
#' `ssh-keygen -N "" -m PEM -f my-new-server-key` command.
#' 
#' If you aren't planning to migrate existing users from an existing
#' SFTP-enabled server to a new server, don't update the host key.
#' Accidentally changing a server's host key can be disruptive.
#' 
#' For more information, see [Change the host key for your SFTP-enabled
#' server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key)
#' in the *AWS Transfer Family User Guide*.
#' @param IdentityProviderDetails Required when `IdentityProviderType` is set to `API_GATEWAY`. Accepts an
#' array containing all of the information required to call a
#' customer-supplied authentication API, including the API Gateway URL. Not
#' required when `IdentityProviderType` is set to `SERVICE_MANAGED`.
#' @param IdentityProviderType Specifies the mode of authentication for a server. The default value is
#' `SERVICE_MANAGED`, which allows you to store and access user credentials
#' within the AWS Transfer Family service. Use the `API_GATEWAY` value to
#' integrate with an identity provider of your choosing. The `API_GATEWAY`
#' setting requires you to provide an API Gateway endpoint URL to call for
#' authentication using the `IdentityProviderDetails` parameter.
#' @param LoggingRole Allows the service to write your users' activity to your Amazon
#' CloudWatch logs for monitoring and auditing purposes.
#' @param Protocols Specifies the file transfer protocol or protocols over which your file
#' transfer protocol client can connect to your server's endpoint. The
#' available protocols are:
#' 
#' -   `SFTP` (Secure Shell (SSH) File Transfer Protocol): File transfer
#'     over SSH
#' 
#' -   `FTPS` (File Transfer Protocol Secure): File transfer with TLS
#'     encryption
#' 
#' -   `FTP` (File Transfer Protocol): Unencrypted file transfer
#' 
#' If you select `FTPS`, you must choose a certificate stored in AWS
#' Certificate Manager (ACM) which will be used to identify your server
#' when clients connect to it over FTPS.
#' 
#' If `Protocol` includes either `FTP` or `FTPS`, then the `EndpointType`
#' must be `VPC` and the `IdentityProviderType` must be `API_GATEWAY`.
#' 
#' If `Protocol` includes `FTP`, then `AddressAllocationIds` cannot be
#' associated.
#' 
#' If `Protocol` is set only to `SFTP`, the `EndpointType` can be set to
#' `PUBLIC` and the `IdentityProviderType` can be set to `SERVICE_MANAGED`.
#' @param SecurityPolicyName Specifies the name of the security policy that is attached to the
#' server.
#' @param Tags Key-value pairs that can be used to group and search for servers.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_server(
#'   Certificate = "string",
#'   Domain = "S3"|"EFS",
#'   EndpointDetails = list(
#'     AddressAllocationIds = list(
#'       "string"
#'     ),
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     VpcEndpointId = "string",
#'     VpcId = "string",
#'     SecurityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   EndpointType = "PUBLIC"|"VPC"|"VPC_ENDPOINT",
#'   HostKey = "string",
#'   IdentityProviderDetails = list(
#'     Url = "string",
#'     InvocationRole = "string"
#'   ),
#'   IdentityProviderType = "SERVICE_MANAGED"|"API_GATEWAY",
#'   LoggingRole = "string",
#'   Protocols = list(
#'     "SFTP"|"FTP"|"FTPS"
#'   ),
#'   SecurityPolicyName = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_create_server
transfer_create_server <- function(Certificate = NULL, Domain = NULL, EndpointDetails = NULL, EndpointType = NULL, HostKey = NULL, IdentityProviderDetails = NULL, IdentityProviderType = NULL, LoggingRole = NULL, Protocols = NULL, SecurityPolicyName = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$create_server_input(Certificate = Certificate, Domain = Domain, EndpointDetails = EndpointDetails, EndpointType = EndpointType, HostKey = HostKey, IdentityProviderDetails = IdentityProviderDetails, IdentityProviderType = IdentityProviderType, LoggingRole = LoggingRole, Protocols = Protocols, SecurityPolicyName = SecurityPolicyName, Tags = Tags)
  output <- .transfer$create_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$create_server <- transfer_create_server

#' Creates a user and associates them with an existing file transfer
#' protocol-enabled server
#'
#' @description
#' Creates a user and associates them with an existing file transfer
#' protocol-enabled server. You can only create and associate users with
#' servers that have the `IdentityProviderType` set to `SERVICE_MANAGED`.
#' Using parameters for [`create_user`][transfer_create_user], you can
#' specify the user name, set the home directory, store the user's public
#' key, and assign the user's AWS Identity and Access Management (IAM)
#' role. You can also optionally add a scope-down policy, and assign
#' metadata with tags that can be used to group and search for users.
#'
#' @usage
#' transfer_create_user(HomeDirectory, HomeDirectoryType,
#'   HomeDirectoryMappings, Policy, PosixProfile, Role, ServerId,
#'   SshPublicKeyBody, Tags, UserName)
#'
#' @param HomeDirectory The landing directory (folder) for a user when they log in to the server
#' using the client.
#' 
#' An example is *`your-Amazon-S3-bucket-name>/home/username`* .
#' @param HomeDirectoryType The type of landing directory (folder) you want your users' home
#' directory to be when they log into the server. If you set it to `PATH`,
#' the user will see the absolute Amazon S3 bucket paths as is in their
#' file transfer protocol clients. If you set it `LOGICAL`, you will need
#' to provide mappings in the `HomeDirectoryMappings` for how you want to
#' make Amazon S3 paths visible to your users.
#' @param HomeDirectoryMappings Logical directory mappings that specify what Amazon S3 paths and keys
#' should be visible to your user and how you want to make them visible.
#' You will need to specify the "`Entry`" and "`Target`" pair, where
#' `Entry` shows how the path is made visible and `Target` is the actual
#' Amazon S3 path. If you only specify a target, it will be displayed as
#' is. You will need to also make sure that your IAM role provides access
#' to paths in `Target`. The following is an example.
#' 
#' `'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]'`
#' 
#' In most cases, you can use this value instead of the scope-down policy
#' to lock your user down to the designated home directory ("chroot"). To
#' do this, you can set `Entry` to '/' and set `Target` to the
#' HomeDirectory parameter value.
#' 
#' If the target of a logical directory entry does not exist in Amazon S3,
#' the entry will be ignored. As a workaround, you can use the Amazon S3
#' API to create 0 byte objects as place holders for your directory. If
#' using the CLI, use the `s3api` call instead of `s3` so you can use the
#' put-object operation. For example, you use the following:
#' `aws s3api put-object --bucket bucketname --key path/to/folder/`. Make
#' sure that the end of the key name ends in a '/' for it to be considered
#' a folder.
#' @param Policy A scope-down policy for your user so you can use the same IAM role
#' across multiple users. This policy scopes down user access to portions
#' of their Amazon S3 bucket. Variables that you can use inside this policy
#' include `${Transfer:UserName}`, `${Transfer:HomeDirectory}`, and
#' `${Transfer:HomeBucket}`.
#' 
#' For scope-down policies, AWS Transfer Family stores the policy as a JSON
#' blob, instead of the Amazon Resource Name (ARN) of the policy. You save
#' the policy as a JSON blob and pass it in the `Policy` argument.
#' 
#' For an example of a scope-down policy, see [Creating a scope-down
#' policy](https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down).
#' 
#' For more information, see
#' [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html)
#' in the *AWS Security Token Service API Reference*.
#' @param PosixProfile 
#' @param Role &#91;required&#93; The IAM role that controls your users' access to your Amazon S3 bucket.
#' The policies attached to this role will determine the level of access
#' you want to provide your users when transferring files into and out of
#' your Amazon S3 bucket or buckets. The IAM role should also contain a
#' trust relationship that allows the server to access your resources when
#' servicing your users' transfer requests.
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server instance. This is the
#' specific server that you added your user to.
#' @param SshPublicKeyBody The public portion of the Secure Shell (SSH) key used to authenticate
#' the user to the server.
#' @param Tags Key-value pairs that can be used to group and search for users. Tags are
#' metadata attached to users for any purpose.
#' @param UserName &#91;required&#93; A unique string that identifies a user and is associated with a as
#' specified by the `ServerId`. This user name must be a minimum of 3 and a
#' maximum of 100 characters long. The following are valid characters: a-z,
#' A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@@'. The
#' user name can't start with a hyphen, period, or at sign.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_user(
#'   HomeDirectory = "string",
#'   HomeDirectoryType = "PATH"|"LOGICAL",
#'   HomeDirectoryMappings = list(
#'     list(
#'       Entry = "string",
#'       Target = "string"
#'     )
#'   ),
#'   Policy = "string",
#'   PosixProfile = list(
#'     Uid = 123,
#'     Gid = 123,
#'     SecondaryGids = list(
#'       123
#'     )
#'   ),
#'   Role = "string",
#'   ServerId = "string",
#'   SshPublicKeyBody = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_create_user
transfer_create_user <- function(HomeDirectory = NULL, HomeDirectoryType = NULL, HomeDirectoryMappings = NULL, Policy = NULL, PosixProfile = NULL, Role, ServerId, SshPublicKeyBody = NULL, Tags = NULL, UserName) {
  op <- new_operation(
    name = "CreateUser",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$create_user_input(HomeDirectory = HomeDirectory, HomeDirectoryType = HomeDirectoryType, HomeDirectoryMappings = HomeDirectoryMappings, Policy = Policy, PosixProfile = PosixProfile, Role = Role, ServerId = ServerId, SshPublicKeyBody = SshPublicKeyBody, Tags = Tags, UserName = UserName)
  output <- .transfer$create_user_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$create_user <- transfer_create_user

#' Deletes the file transfer protocol-enabled server that you specify
#'
#' @description
#' Deletes the file transfer protocol-enabled server that you specify.
#' 
#' No response returns from this operation.
#'
#' @usage
#' transfer_delete_server(ServerId)
#'
#' @param ServerId &#91;required&#93; A unique system-assigned identifier for a server instance.
#'

#'
#' @section Request syntax:
#' ```
#' svc$delete_server(
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_delete_server
transfer_delete_server <- function(ServerId) {
  op <- new_operation(
    name = "DeleteServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$delete_server_input(ServerId = ServerId)
  output <- .transfer$delete_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$delete_server <- transfer_delete_server

#' Deletes a user's Secure Shell (SSH) public key
#'
#' @description
#' Deletes a user's Secure Shell (SSH) public key.
#' 
#' No response is returned from this operation.
#'
#' @usage
#' transfer_delete_ssh_public_key(ServerId, SshPublicKeyId, UserName)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a file transfer protocol-enabled
#' server instance that has the user assigned to it.
#' @param SshPublicKeyId &#91;required&#93; A unique identifier used to reference your user's specific SSH key.
#' @param UserName &#91;required&#93; A unique string that identifies a user whose public key is being
#' deleted.
#'

#'
#' @section Request syntax:
#' ```
#' svc$delete_ssh_public_key(
#'   ServerId = "string",
#'   SshPublicKeyId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_delete_ssh_public_key
transfer_delete_ssh_public_key <- function(ServerId, SshPublicKeyId, UserName) {
  op <- new_operation(
    name = "DeleteSshPublicKey",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$delete_ssh_public_key_input(ServerId = ServerId, SshPublicKeyId = SshPublicKeyId, UserName = UserName)
  output <- .transfer$delete_ssh_public_key_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$delete_ssh_public_key <- transfer_delete_ssh_public_key

#' Deletes the user belonging to a file transfer protocol-enabled server
#' you specify
#'
#' @description
#' Deletes the user belonging to a file transfer protocol-enabled server
#' you specify.
#' 
#' No response returns from this operation.
#' 
#' When you delete a user from a server, the user's information is lost.
#'
#' @usage
#' transfer_delete_user(ServerId, UserName)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server instance that has the
#' user assigned to it.
#' @param UserName &#91;required&#93; A unique string that identifies a user that is being deleted from a
#' server.
#'

#'
#' @section Request syntax:
#' ```
#' svc$delete_user(
#'   ServerId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_delete_user
transfer_delete_user <- function(ServerId, UserName) {
  op <- new_operation(
    name = "DeleteUser",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$delete_user_input(ServerId = ServerId, UserName = UserName)
  output <- .transfer$delete_user_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$delete_user <- transfer_delete_user

#' Describes the security policy that is attached to your file transfer
#' protocol-enabled server
#'
#' @description
#' Describes the security policy that is attached to your file transfer
#' protocol-enabled server. The response contains a description of the
#' security policy's properties. For more information about security
#' policies, see [Working with security
#' policies](https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html).
#'
#' @usage
#' transfer_describe_security_policy(SecurityPolicyName)
#'
#' @param SecurityPolicyName &#91;required&#93; Specifies the name of the security policy that is attached to the
#' server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SecurityPolicy = list(
#'     Fips = TRUE|FALSE,
#'     SecurityPolicyName = "string",
#'     SshCiphers = list(
#'       "string"
#'     ),
#'     SshKexs = list(
#'       "string"
#'     ),
#'     SshMacs = list(
#'       "string"
#'     ),
#'     TlsCiphers = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_security_policy(
#'   SecurityPolicyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_describe_security_policy
transfer_describe_security_policy <- function(SecurityPolicyName) {
  op <- new_operation(
    name = "DescribeSecurityPolicy",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$describe_security_policy_input(SecurityPolicyName = SecurityPolicyName)
  output <- .transfer$describe_security_policy_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$describe_security_policy <- transfer_describe_security_policy

#' Describes a file transfer protocol-enabled server that you specify by
#' passing the ServerId parameter
#'
#' @description
#' Describes a file transfer protocol-enabled server that you specify by
#' passing the `ServerId` parameter.
#' 
#' The response contains a description of a server's properties. When you
#' set `EndpointType` to VPC, the response will contain the
#' `EndpointDetails`.
#'
#' @usage
#' transfer_describe_server(ServerId)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Server = list(
#'     Arn = "string",
#'     Certificate = "string",
#'     Domain = "S3"|"EFS",
#'     EndpointDetails = list(
#'       AddressAllocationIds = list(
#'         "string"
#'       ),
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       VpcEndpointId = "string",
#'       VpcId = "string",
#'       SecurityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     EndpointType = "PUBLIC"|"VPC"|"VPC_ENDPOINT",
#'     HostKeyFingerprint = "string",
#'     IdentityProviderDetails = list(
#'       Url = "string",
#'       InvocationRole = "string"
#'     ),
#'     IdentityProviderType = "SERVICE_MANAGED"|"API_GATEWAY",
#'     LoggingRole = "string",
#'     Protocols = list(
#'       "SFTP"|"FTP"|"FTPS"
#'     ),
#'     SecurityPolicyName = "string",
#'     ServerId = "string",
#'     State = "OFFLINE"|"ONLINE"|"STARTING"|"STOPPING"|"START_FAILED"|"STOP_FAILED",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     UserCount = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_server(
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_describe_server
transfer_describe_server <- function(ServerId) {
  op <- new_operation(
    name = "DescribeServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$describe_server_input(ServerId = ServerId)
  output <- .transfer$describe_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$describe_server <- transfer_describe_server

#' Describes the user assigned to the specific file transfer
#' protocol-enabled server, as identified by its ServerId property
#'
#' @description
#' Describes the user assigned to the specific file transfer
#' protocol-enabled server, as identified by its `ServerId` property.
#' 
#' The response from this call returns the properties of the user
#' associated with the `ServerId` value that was specified.
#'
#' @usage
#' transfer_describe_user(ServerId, UserName)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server that has this user
#' assigned.
#' @param UserName &#91;required&#93; The name of the user assigned to one or more servers. User names are
#' part of the sign-in credentials to use the AWS Transfer Family service
#' and perform file transfer tasks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string",
#'   User = list(
#'     Arn = "string",
#'     HomeDirectory = "string",
#'     HomeDirectoryMappings = list(
#'       list(
#'         Entry = "string",
#'         Target = "string"
#'       )
#'     ),
#'     HomeDirectoryType = "PATH"|"LOGICAL",
#'     Policy = "string",
#'     PosixProfile = list(
#'       Uid = 123,
#'       Gid = 123,
#'       SecondaryGids = list(
#'         123
#'       )
#'     ),
#'     Role = "string",
#'     SshPublicKeys = list(
#'       list(
#'         DateImported = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         SshPublicKeyBody = "string",
#'         SshPublicKeyId = "string"
#'       )
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     UserName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_user(
#'   ServerId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_describe_user
transfer_describe_user <- function(ServerId, UserName) {
  op <- new_operation(
    name = "DescribeUser",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$describe_user_input(ServerId = ServerId, UserName = UserName)
  output <- .transfer$describe_user_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$describe_user <- transfer_describe_user

#' Adds a Secure Shell (SSH) public key to a user account identified by a
#' UserName value assigned to the specific file transfer protocol-enabled
#' server, identified by ServerId
#'
#' @description
#' Adds a Secure Shell (SSH) public key to a user account identified by a
#' `UserName` value assigned to the specific file transfer protocol-enabled
#' server, identified by `ServerId`.
#' 
#' The response returns the `UserName` value, the `ServerId` value, and the
#' name of the `SshPublicKeyId`.
#'
#' @usage
#' transfer_import_ssh_public_key(ServerId, SshPublicKeyBody, UserName)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server.
#' @param SshPublicKeyBody &#91;required&#93; The public key portion of an SSH key pair.
#' @param UserName &#91;required&#93; The name of the user account that is assigned to one or more servers.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string",
#'   SshPublicKeyId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$import_ssh_public_key(
#'   ServerId = "string",
#'   SshPublicKeyBody = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_import_ssh_public_key
transfer_import_ssh_public_key <- function(ServerId, SshPublicKeyBody, UserName) {
  op <- new_operation(
    name = "ImportSshPublicKey",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$import_ssh_public_key_input(ServerId = ServerId, SshPublicKeyBody = SshPublicKeyBody, UserName = UserName)
  output <- .transfer$import_ssh_public_key_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$import_ssh_public_key <- transfer_import_ssh_public_key

#' Lists the security policies that are attached to your file transfer
#' protocol-enabled servers
#'
#' @description
#' Lists the security policies that are attached to your file transfer
#' protocol-enabled servers.
#'
#' @usage
#' transfer_list_security_policies(MaxResults, NextToken)
#'
#' @param MaxResults Specifies the number of security policies to return as a response to the
#' [`list_security_policies`][transfer_list_security_policies] query.
#' @param NextToken When additional results are obtained from the
#' [`list_security_policies`][transfer_list_security_policies] command, a
#' `NextToken` parameter is returned in the output. You can then pass the
#' `NextToken` parameter in a subsequent command to continue listing
#' additional security policies.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   SecurityPolicyNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_security_policies(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_list_security_policies
transfer_list_security_policies <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListSecurityPolicies",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$list_security_policies_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .transfer$list_security_policies_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$list_security_policies <- transfer_list_security_policies

#' Lists the file transfer protocol-enabled servers that are associated
#' with your AWS account
#'
#' @description
#' Lists the file transfer protocol-enabled servers that are associated
#' with your AWS account.
#'
#' @usage
#' transfer_list_servers(MaxResults, NextToken)
#'
#' @param MaxResults Specifies the number of servers to return as a response to the
#' [`list_servers`][transfer_list_servers] query.
#' @param NextToken When additional results are obtained from the
#' [`list_servers`][transfer_list_servers] command, a `NextToken` parameter
#' is returned in the output. You can then pass the `NextToken` parameter
#' in a subsequent command to continue listing additional servers.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Servers = list(
#'     list(
#'       Arn = "string",
#'       Domain = "S3"|"EFS",
#'       IdentityProviderType = "SERVICE_MANAGED"|"API_GATEWAY",
#'       EndpointType = "PUBLIC"|"VPC"|"VPC_ENDPOINT",
#'       LoggingRole = "string",
#'       ServerId = "string",
#'       State = "OFFLINE"|"ONLINE"|"STARTING"|"STOPPING"|"START_FAILED"|"STOP_FAILED",
#'       UserCount = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_servers(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_list_servers
transfer_list_servers <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListServers",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$list_servers_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .transfer$list_servers_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$list_servers <- transfer_list_servers

#' Lists all of the tags associated with the Amazon Resource Number (ARN)
#' you specify
#'
#' @description
#' Lists all of the tags associated with the Amazon Resource Number (ARN)
#' you specify. The resource can be a user, server, or role.
#'
#' @usage
#' transfer_list_tags_for_resource(Arn, MaxResults, NextToken)
#'
#' @param Arn &#91;required&#93; Requests the tags associated with a particular Amazon Resource Name
#' (ARN). An ARN is an identifier for a specific AWS resource, such as a
#' server, user, or role.
#' @param MaxResults Specifies the number of tags to return as a response to the
#' [`list_tags_for_resource`][transfer_list_tags_for_resource] request.
#' @param NextToken When you request additional results from the
#' [`list_tags_for_resource`][transfer_list_tags_for_resource] operation, a
#' `NextToken` parameter is returned in the input. You can then pass in a
#' subsequent command to the `NextToken` parameter to continue listing
#' additional tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   NextToken = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   Arn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_list_tags_for_resource
transfer_list_tags_for_resource <- function(Arn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$list_tags_for_resource_input(Arn = Arn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .transfer$list_tags_for_resource_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$list_tags_for_resource <- transfer_list_tags_for_resource

#' Lists the users for a file transfer protocol-enabled server that you
#' specify by passing the ServerId parameter
#'
#' @description
#' Lists the users for a file transfer protocol-enabled server that you
#' specify by passing the `ServerId` parameter.
#'
#' @usage
#' transfer_list_users(MaxResults, NextToken, ServerId)
#'
#' @param MaxResults Specifies the number of users to return as a response to the
#' [`list_users`][transfer_list_users] request.
#' @param NextToken When you can get additional results from the
#' [`list_users`][transfer_list_users] call, a `NextToken` parameter is
#' returned in the output. You can then pass in a subsequent command to the
#' `NextToken` parameter to continue listing additional users.
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server that has users assigned
#' to it.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   ServerId = "string",
#'   Users = list(
#'     list(
#'       Arn = "string",
#'       HomeDirectory = "string",
#'       HomeDirectoryType = "PATH"|"LOGICAL",
#'       Role = "string",
#'       SshPublicKeyCount = 123,
#'       UserName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_users(
#'   MaxResults = 123,
#'   NextToken = "string",
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_list_users
transfer_list_users <- function(MaxResults = NULL, NextToken = NULL, ServerId) {
  op <- new_operation(
    name = "ListUsers",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$list_users_input(MaxResults = MaxResults, NextToken = NextToken, ServerId = ServerId)
  output <- .transfer$list_users_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$list_users <- transfer_list_users

#' Changes the state of a file transfer protocol-enabled server from
#' OFFLINE to ONLINE
#'
#' @description
#' Changes the state of a file transfer protocol-enabled server from
#' `OFFLINE` to `ONLINE`. It has no impact on a server that is already
#' `ONLINE`. An `ONLINE` server can accept and process file transfer jobs.
#' 
#' The state of `STARTING` indicates that the server is in an intermediate
#' state, either not fully able to respond, or not fully online. The values
#' of `START_FAILED` can indicate an error condition.
#' 
#' No response is returned from this call.
#'
#' @usage
#' transfer_start_server(ServerId)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server that you start.
#'

#'
#' @section Request syntax:
#' ```
#' svc$start_server(
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_start_server
transfer_start_server <- function(ServerId) {
  op <- new_operation(
    name = "StartServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$start_server_input(ServerId = ServerId)
  output <- .transfer$start_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$start_server <- transfer_start_server

#' Changes the state of a file transfer protocol-enabled server from ONLINE
#' to OFFLINE
#'
#' @description
#' Changes the state of a file transfer protocol-enabled server from
#' `ONLINE` to `OFFLINE`. An `OFFLINE` server cannot accept and process
#' file transfer jobs. Information tied to your server, such as server and
#' user properties, are not affected by stopping your server.
#' 
#' Stopping the server will not reduce or impact your file transfer
#' protocol endpoint billing; you must delete the server to stop being
#' billed.
#' 
#' The state of `STOPPING` indicates that the server is in an intermediate
#' state, either not fully able to respond, or not fully offline. The
#' values of `STOP_FAILED` can indicate an error condition.
#' 
#' No response is returned from this call.
#'
#' @usage
#' transfer_stop_server(ServerId)
#'
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server that you stopped.
#'

#'
#' @section Request syntax:
#' ```
#' svc$stop_server(
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_stop_server
transfer_stop_server <- function(ServerId) {
  op <- new_operation(
    name = "StopServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$stop_server_input(ServerId = ServerId)
  output <- .transfer$stop_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$stop_server <- transfer_stop_server

#' Attaches a key-value pair to a resource, as identified by its Amazon
#' Resource Name (ARN)
#'
#' @description
#' Attaches a key-value pair to a resource, as identified by its Amazon
#' Resource Name (ARN). Resources are users, servers, roles, and other
#' entities.
#' 
#' There is no response returned from this call.
#'
#' @usage
#' transfer_tag_resource(Arn, Tags)
#'
#' @param Arn &#91;required&#93; An Amazon Resource Name (ARN) for a specific AWS resource, such as a
#' server, user, or role.
#' @param Tags &#91;required&#93; Key-value pairs assigned to ARNs that you can use to group and search
#' for resources by type. You can attach this metadata to user accounts for
#' any purpose.
#'

#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   Arn = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_tag_resource
transfer_tag_resource <- function(Arn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$tag_resource_input(Arn = Arn, Tags = Tags)
  output <- .transfer$tag_resource_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$tag_resource <- transfer_tag_resource

#' If the IdentityProviderType of a file transfer protocol-enabled server
#' is API_Gateway, tests whether your API Gateway is set up successfully
#'
#' @description
#' If the `IdentityProviderType` of a file transfer protocol-enabled server
#' is `API_Gateway`, tests whether your API Gateway is set up successfully.
#' We highly recommend that you call this operation to test your
#' authentication method as soon as you create your server. By doing so,
#' you can troubleshoot issues with the API Gateway integration to ensure
#' that your users can successfully use the service.
#'
#' @usage
#' transfer_test_identity_provider(ServerId, ServerProtocol, SourceIp,
#'   UserName, UserPassword)
#'
#' @param ServerId &#91;required&#93; A system-assigned identifier for a specific server. That server's user
#' authentication method is tested with a user name and password.
#' @param ServerProtocol The type of file transfer protocol to be tested.
#' 
#' The available protocols are:
#' 
#' -   Secure Shell (SSH) File Transfer Protocol (SFTP)
#' 
#' -   File Transfer Protocol Secure (FTPS)
#' 
#' -   File Transfer Protocol (FTP)
#' @param SourceIp The source IP address of the user account to be tested.
#' @param UserName &#91;required&#93; The name of the user account to be tested.
#' @param UserPassword The password of the user account to be tested.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Response = "string",
#'   StatusCode = 123,
#'   Message = "string",
#'   Url = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$test_identity_provider(
#'   ServerId = "string",
#'   ServerProtocol = "SFTP"|"FTP"|"FTPS",
#'   SourceIp = "string",
#'   UserName = "string",
#'   UserPassword = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_test_identity_provider
transfer_test_identity_provider <- function(ServerId, ServerProtocol = NULL, SourceIp = NULL, UserName, UserPassword = NULL) {
  op <- new_operation(
    name = "TestIdentityProvider",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$test_identity_provider_input(ServerId = ServerId, ServerProtocol = ServerProtocol, SourceIp = SourceIp, UserName = UserName, UserPassword = UserPassword)
  output <- .transfer$test_identity_provider_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$test_identity_provider <- transfer_test_identity_provider

#' Detaches a key-value pair from a resource, as identified by its Amazon
#' Resource Name (ARN)
#'
#' @description
#' Detaches a key-value pair from a resource, as identified by its Amazon
#' Resource Name (ARN). Resources are users, servers, roles, and other
#' entities.
#' 
#' No response is returned from this call.
#'
#' @usage
#' transfer_untag_resource(Arn, TagKeys)
#'
#' @param Arn &#91;required&#93; The value of the resource that will have the tag removed. An Amazon
#' Resource Name (ARN) is an identifier for a specific AWS resource, such
#' as a server, user, or role.
#' @param TagKeys &#91;required&#93; TagKeys are key-value pairs assigned to ARNs that can be used to group
#' and search for resources by type. This metadata can be attached to
#' resources for any purpose.
#'

#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   Arn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_untag_resource
transfer_untag_resource <- function(Arn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$untag_resource_input(Arn = Arn, TagKeys = TagKeys)
  output <- .transfer$untag_resource_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$untag_resource <- transfer_untag_resource

#' Updates the file transfer protocol-enabled server's properties after
#' that server has been created
#'
#' @description
#' Updates the file transfer protocol-enabled server's properties after
#' that server has been created.
#' 
#' The [`update_server`][transfer_update_server] call returns the
#' `ServerId` of the server you updated.
#'
#' @usage
#' transfer_update_server(Certificate, EndpointDetails, EndpointType,
#'   HostKey, IdentityProviderDetails, LoggingRole, Protocols,
#'   SecurityPolicyName, ServerId)
#'
#' @param Certificate The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM)
#' certificate. Required when `Protocols` is set to `FTPS`.
#' 
#' To request a new public certificate, see [Request a public
#' certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' To import an existing certificate into ACM, see [Importing certificates
#' into
#' ACM](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' To request a private certificate to use FTPS through private IP
#' addresses, see [Request a private
#' certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html)
#' in the *AWS Certificate Manager User Guide*.
#' 
#' Certificates with the following cryptographic algorithms and key sizes
#' are supported:
#' 
#' -   2048-bit RSA (RSA_2048)
#' 
#' -   4096-bit RSA (RSA_4096)
#' 
#' -   Elliptic Prime Curve 256 bit (EC_prime256v1)
#' 
#' -   Elliptic Prime Curve 384 bit (EC_secp384r1)
#' 
#' -   Elliptic Prime Curve 521 bit (EC_secp521r1)
#' 
#' The certificate must be a valid SSL/TLS X.509 version 3 certificate with
#' FQDN or IP address specified and information about the issuer.
#' @param EndpointDetails The virtual private cloud (VPC) endpoint settings that are configured
#' for your server. With a VPC endpoint, you can restrict access to your
#' server to resources only within your VPC. To control incoming internet
#' traffic, you will need to associate one or more Elastic IP addresses
#' with your server's endpoint.
#' @param EndpointType The type of endpoint that you want your server to connect to. You can
#' choose to connect to the public internet or a VPC endpoint. With a VPC
#' endpoint, you can restrict access to your server and resources only
#' within your VPC.
#' 
#' It is recommended that you use `VPC` as the `EndpointType`. With this
#' endpoint type, you have the option to directly associate up to three
#' Elastic IPv4 addresses (BYO IP included) with your server's endpoint and
#' use VPC security groups to restrict traffic by the client's public IP
#' address. This is not possible with `EndpointType` set to `VPC_ENDPOINT`.
#' @param HostKey The RSA private key as generated by
#' `ssh-keygen -N "" -m PEM -f my-new-server-key`.
#' 
#' If you aren't planning to migrate existing users from an existing server
#' to a new server, don't update the host key. Accidentally changing a
#' server's host key can be disruptive.
#' 
#' For more information, see [Change the host key for your SFTP-enabled
#' server](https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key)
#' in the *AWS Transfer Family User Guide*.
#' @param IdentityProviderDetails An array containing all of the information required to call a customer's
#' authentication API method.
#' @param LoggingRole Changes the AWS Identity and Access Management (IAM) role that allows
#' Amazon S3 events to be logged in Amazon CloudWatch, turning logging on
#' or off.
#' @param Protocols Specifies the file transfer protocol or protocols over which your file
#' transfer protocol client can connect to your server's endpoint. The
#' available protocols are:
#' 
#' -   Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over
#'     SSH
#' 
#' -   File Transfer Protocol Secure (FTPS): File transfer with TLS
#'     encryption
#' 
#' -   File Transfer Protocol (FTP): Unencrypted file transfer
#' 
#' If you select `FTPS`, you must choose a certificate stored in AWS
#' Certificate Manager (ACM) which will be used to identify your server
#' when clients connect to it over FTPS.
#' 
#' If `Protocol` includes either `FTP` or `FTPS`, then the `EndpointType`
#' must be `VPC` and the `IdentityProviderType` must be `API_GATEWAY`.
#' 
#' If `Protocol` includes `FTP`, then `AddressAllocationIds` cannot be
#' associated.
#' 
#' If `Protocol` is set only to `SFTP`, the `EndpointType` can be set to
#' `PUBLIC` and the `IdentityProviderType` can be set to `SERVICE_MANAGED`.
#' @param SecurityPolicyName Specifies the name of the security policy that is attached to the
#' server.
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server instance that the user
#' account is assigned to.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_server(
#'   Certificate = "string",
#'   EndpointDetails = list(
#'     AddressAllocationIds = list(
#'       "string"
#'     ),
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     VpcEndpointId = "string",
#'     VpcId = "string",
#'     SecurityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   EndpointType = "PUBLIC"|"VPC"|"VPC_ENDPOINT",
#'   HostKey = "string",
#'   IdentityProviderDetails = list(
#'     Url = "string",
#'     InvocationRole = "string"
#'   ),
#'   LoggingRole = "string",
#'   Protocols = list(
#'     "SFTP"|"FTP"|"FTPS"
#'   ),
#'   SecurityPolicyName = "string",
#'   ServerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_update_server
transfer_update_server <- function(Certificate = NULL, EndpointDetails = NULL, EndpointType = NULL, HostKey = NULL, IdentityProviderDetails = NULL, LoggingRole = NULL, Protocols = NULL, SecurityPolicyName = NULL, ServerId) {
  op <- new_operation(
    name = "UpdateServer",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$update_server_input(Certificate = Certificate, EndpointDetails = EndpointDetails, EndpointType = EndpointType, HostKey = HostKey, IdentityProviderDetails = IdentityProviderDetails, LoggingRole = LoggingRole, Protocols = Protocols, SecurityPolicyName = SecurityPolicyName, ServerId = ServerId)
  output <- .transfer$update_server_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$update_server <- transfer_update_server

#' Assigns new properties to a user
#'
#' @description
#' Assigns new properties to a user. Parameters you pass modify any or all
#' of the following: the home directory, role, and policy for the
#' `UserName` and `ServerId` you specify.
#' 
#' The response returns the `ServerId` and the `UserName` for the updated
#' user.
#'
#' @usage
#' transfer_update_user(HomeDirectory, HomeDirectoryType,
#'   HomeDirectoryMappings, Policy, PosixProfile, Role, ServerId, UserName)
#'
#' @param HomeDirectory Specifies the landing directory (folder) for a user when they log in to
#' the server using their file transfer protocol client.
#' 
#' An example is `your-Amazon-S3-bucket-name>/home/username`.
#' @param HomeDirectoryType The type of landing directory (folder) you want your users' home
#' directory to be when they log into the server. If you set it to `PATH`,
#' the user will see the absolute Amazon S3 bucket paths as is in their
#' file transfer protocol clients. If you set it `LOGICAL`, you will need
#' to provide mappings in the `HomeDirectoryMappings` for how you want to
#' make Amazon S3 paths visible to your users.
#' @param HomeDirectoryMappings Logical directory mappings that specify what Amazon S3 paths and keys
#' should be visible to your user and how you want to make them visible.
#' You will need to specify the "`Entry`" and "`Target`" pair, where
#' `Entry` shows how the path is made visible and `Target` is the actual
#' Amazon S3 path. If you only specify a target, it will be displayed as
#' is. You will need to also make sure that your IAM role provides access
#' to paths in `Target`. The following is an example.
#' 
#' `'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]'`
#' 
#' In most cases, you can use this value instead of the scope-down policy
#' to lock your user down to the designated home directory ("chroot"). To
#' do this, you can set `Entry` to '/' and set `Target` to the
#' HomeDirectory parameter value.
#' 
#' If the target of a logical directory entry does not exist in Amazon S3,
#' the entry will be ignored. As a workaround, you can use the Amazon S3
#' API to create 0 byte objects as place holders for your directory. If
#' using the CLI, use the `s3api` call instead of `s3` so you can use the
#' put-object operation. For example, you use the following:
#' `aws s3api put-object --bucket bucketname --key path/to/folder/`. Make
#' sure that the end of the key name ends in a / for it to be considered a
#' folder.
#' @param Policy Allows you to supply a scope-down policy for your user so you can use
#' the same IAM role across multiple users. The policy scopes down user
#' access to portions of your Amazon S3 bucket. Variables you can use
#' inside this policy include `${Transfer:UserName}`,
#' `${Transfer:HomeDirectory}`, and `${Transfer:HomeBucket}`.
#' 
#' For scope-down policies, AWS Transfer Family stores the policy as a JSON
#' blob, instead of the Amazon Resource Name (ARN) of the policy. You save
#' the policy as a JSON blob and pass it in the `Policy` argument.
#' 
#' For an example of a scope-down policy, see [Creating a scope-down
#' policy](https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down).
#' 
#' For more information, see
#' [AssumeRole](https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html)
#' in the *AWS Security Token Service API Reference*.
#' @param PosixProfile 
#' @param Role The IAM role that controls your users' access to your Amazon S3 bucket.
#' The policies attached to this role will determine the level of access
#' you want to provide your users when transferring files into and out of
#' your Amazon S3 bucket or buckets. The IAM role should also contain a
#' trust relationship that allows the server to access your resources when
#' servicing your users' transfer requests.
#' @param ServerId &#91;required&#93; A system-assigned unique identifier for a server instance that the user
#' account is assigned to.
#' @param UserName &#91;required&#93; A unique string that identifies a user and is associated with a server
#' as specified by the `ServerId`. This user name must be a minimum of 3
#' and a maximum of 100 characters long. The following are valid
#' characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and
#' at sign '@@'. The user name can't start with a hyphen, period, or at
#' sign.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ServerId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_user(
#'   HomeDirectory = "string",
#'   HomeDirectoryType = "PATH"|"LOGICAL",
#'   HomeDirectoryMappings = list(
#'     list(
#'       Entry = "string",
#'       Target = "string"
#'     )
#'   ),
#'   Policy = "string",
#'   PosixProfile = list(
#'     Uid = 123,
#'     Gid = 123,
#'     SecondaryGids = list(
#'       123
#'     )
#'   ),
#'   Role = "string",
#'   ServerId = "string",
#'   UserName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transfer_update_user
transfer_update_user <- function(HomeDirectory = NULL, HomeDirectoryType = NULL, HomeDirectoryMappings = NULL, Policy = NULL, PosixProfile = NULL, Role = NULL, ServerId, UserName) {
  op <- new_operation(
    name = "UpdateUser",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .transfer$update_user_input(HomeDirectory = HomeDirectory, HomeDirectoryType = HomeDirectoryType, HomeDirectoryMappings = HomeDirectoryMappings, Policy = Policy, PosixProfile = PosixProfile, Role = Role, ServerId = ServerId, UserName = UserName)
  output <- .transfer$update_user_output()
  config <- get_config()
  svc <- .transfer$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transfer$operations$update_user <- transfer_update_user

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include mediastoredata_service.R
NULL

#' Deletes an object at the specified path
#'
#' @description
#' Deletes an object at the specified path.
#'
#' @usage
#' mediastoredata_delete_object(Path)
#'
#' @param Path &#91;required&#93; The path (including the file name) where the object is stored in the
#' container. Format: \<folder name\>/\<folder name\>/\<file name\>
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_object(
#'   Path = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mediastoredata_delete_object
mediastoredata_delete_object <- function(Path) {
  op <- new_operation(
    name = "DeleteObject",
    http_method = "DELETE",
    http_path = "/{Path+}",
    paginator = list()
  )
  input <- .mediastoredata$delete_object_input(Path = Path)
  output <- .mediastoredata$delete_object_output()
  config <- get_config()
  svc <- .mediastoredata$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mediastoredata$operations$delete_object <- mediastoredata_delete_object

#' Gets the headers for an object at the specified path
#'
#' @description
#' Gets the headers for an object at the specified path.
#'
#' @usage
#' mediastoredata_describe_object(Path)
#'
#' @param Path &#91;required&#93; The path (including the file name) where the object is stored in the
#' container. Format: \<folder name\>/\<folder name\>/\<file name\>
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ETag = "string",
#'   ContentType = "string",
#'   ContentLength = 123,
#'   CacheControl = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_object(
#'   Path = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mediastoredata_describe_object
mediastoredata_describe_object <- function(Path) {
  op <- new_operation(
    name = "DescribeObject",
    http_method = "HEAD",
    http_path = "/{Path+}",
    paginator = list()
  )
  input <- .mediastoredata$describe_object_input(Path = Path)
  output <- .mediastoredata$describe_object_output()
  config <- get_config()
  svc <- .mediastoredata$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mediastoredata$operations$describe_object <- mediastoredata_describe_object

#' Downloads the object at the specified path
#'
#' @description
#' Downloads the object at the specified path. If the object’s upload
#' availability is set to `streaming`, AWS Elemental MediaStore downloads
#' the object even if it’s still uploading the object.
#'
#' @usage
#' mediastoredata_get_object(Path, Range)
#'
#' @param Path &#91;required&#93; The path (including the file name) where the object is stored in the
#' container. Format: \<folder name\>/\<folder name\>/\<file name\>
#' 
#' For example, to upload the file `mlaw.avi` to the folder path
#' `premium\canada` in the container `movies`, enter the path
#' `premium/canada/mlaw.avi`.
#' 
#' Do not include the container name in this path.
#' 
#' If the path includes any folders that don't exist yet, the service
#' creates them. For example, suppose you have an existing `premium/usa`
#' subfolder. If you specify `premium/canada`, the service creates a
#' `canada` subfolder in the `premium` folder. You then have two
#' subfolders, `usa` and `canada`, in the `premium` folder.
#' 
#' There is no correlation between the path to the source and the path
#' (folders) in the container in AWS Elemental MediaStore.
#' 
#' For more information about folders and how they exist in a container,
#' see the [AWS Elemental MediaStore User
#' Guide](https://docs.aws.amazon.com/mediastore/latest/ug/).
#' 
#' The file name is the name that is assigned to the file that you upload.
#' The file can have the same name inside and outside of AWS Elemental
#' MediaStore, or it can have the same name. The file name can include or
#' omit an extension.
#' @param Range The range bytes of an object to retrieve. For more information about the
#' `Range` header, see
#' <http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35>. AWS
#' Elemental MediaStore ignores this header for partially uploaded objects
#' that have streaming upload availability.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Body = raw,
#'   CacheControl = "string",
#'   ContentRange = "string",
#'   ContentLength = 123,
#'   ContentType = "string",
#'   ETag = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   StatusCode = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_object(
#'   Path = "string",
#'   Range = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mediastoredata_get_object
mediastoredata_get_object <- function(Path, Range = NULL) {
  op <- new_operation(
    name = "GetObject",
    http_method = "GET",
    http_path = "/{Path+}",
    paginator = list()
  )
  input <- .mediastoredata$get_object_input(Path = Path, Range = Range)
  output <- .mediastoredata$get_object_output()
  config <- get_config()
  svc <- .mediastoredata$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mediastoredata$operations$get_object <- mediastoredata_get_object

#' Provides a list of metadata entries about folders and objects in the
#' specified folder
#'
#' @description
#' Provides a list of metadata entries about folders and objects in the
#' specified folder.
#'
#' @usage
#' mediastoredata_list_items(Path, MaxResults, NextToken)
#'
#' @param Path The path in the container from which to retrieve items. Format: \<folder
#' name\>/\<folder name\>/\<file name\>
#' @param MaxResults The maximum number of results to return per API request. For example,
#' you submit a [`list_items`][mediastoredata_list_items] request with
#' `MaxResults` set at 500. Although 2,000 items match your request, the
#' service returns no more than the first 500 items. (The service also
#' returns a `NextToken` value that you can use to fetch the next batch of
#' results.) The service might return fewer results than the `MaxResults`
#' value.
#' 
#' If `MaxResults` is not included in the request, the service defaults to
#' pagination with a maximum of 1,000 results per page.
#' @param NextToken The token that identifies which batch of results that you want to see.
#' For example, you submit a [`list_items`][mediastoredata_list_items]
#' request with `MaxResults` set at 500. The service returns the first
#' batch of results (up to 500) and a `NextToken` value. To see the next
#' batch of results, you can submit the
#' [`list_items`][mediastoredata_list_items] request a second time and
#' specify the `NextToken` value.
#' 
#' Tokens expire after 15 minutes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Items = list(
#'     list(
#'       Name = "string",
#'       Type = "OBJECT"|"FOLDER",
#'       ETag = "string",
#'       LastModified = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ContentType = "string",
#'       ContentLength = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_items(
#'   Path = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mediastoredata_list_items
mediastoredata_list_items <- function(Path = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListItems",
    http_method = "GET",
    http_path = "/",
    paginator = list()
  )
  input <- .mediastoredata$list_items_input(Path = Path, MaxResults = MaxResults, NextToken = NextToken)
  output <- .mediastoredata$list_items_output()
  config <- get_config()
  svc <- .mediastoredata$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mediastoredata$operations$list_items <- mediastoredata_list_items

#' Uploads an object to the specified path
#'
#' @description
#' Uploads an object to the specified path. Object sizes are limited to 25
#' MB for standard upload availability and 10 MB for streaming upload
#' availability.
#'
#' @usage
#' mediastoredata_put_object(Body, Path, ContentType, CacheControl,
#'   StorageClass, UploadAvailability)
#'
#' @param Body &#91;required&#93; The bytes to be stored.
#' @param Path &#91;required&#93; The path (including the file name) where the object is stored in the
#' container. Format: \<folder name\>/\<folder name\>/\<file name\>
#' 
#' For example, to upload the file `mlaw.avi` to the folder path
#' `premium\canada` in the container `movies`, enter the path
#' `premium/canada/mlaw.avi`.
#' 
#' Do not include the container name in this path.
#' 
#' If the path includes any folders that don't exist yet, the service
#' creates them. For example, suppose you have an existing `premium/usa`
#' subfolder. If you specify `premium/canada`, the service creates a
#' `canada` subfolder in the `premium` folder. You then have two
#' subfolders, `usa` and `canada`, in the `premium` folder.
#' 
#' There is no correlation between the path to the source and the path
#' (folders) in the container in AWS Elemental MediaStore.
#' 
#' For more information about folders and how they exist in a container,
#' see the [AWS Elemental MediaStore User
#' Guide](https://docs.aws.amazon.com/mediastore/latest/ug/).
#' 
#' The file name is the name that is assigned to the file that you upload.
#' The file can have the same name inside and outside of AWS Elemental
#' MediaStore, or it can have the same name. The file name can include or
#' omit an extension.
#' @param ContentType The content type of the object.
#' @param CacheControl An optional `CacheControl` header that allows the caller to control the
#' object's cache behavior. Headers can be passed in as specified in the
#' HTTP at
#' <https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9>.
#' 
#' Headers with a custom user-defined value are also accepted.
#' @param StorageClass Indicates the storage class of a `Put` request. Defaults to
#' high-performance temporal storage class, and objects are persisted into
#' durable storage shortly after being received.
#' @param UploadAvailability Indicates the availability of an object while it is still uploading. If
#' the value is set to `streaming`, the object is available for downloading
#' after some initial buffering but before the object is uploaded
#' completely. If the value is set to `standard`, the object is available
#' for downloading only when it is uploaded completely. The default value
#' for this header is `standard`.
#' 
#' To use this header, you must also set the HTTP `Transfer-Encoding`
#' header to `chunked`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ContentSHA256 = "string",
#'   ETag = "string",
#'   StorageClass = "TEMPORAL"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_object(
#'   Body = raw,
#'   Path = "string",
#'   ContentType = "string",
#'   CacheControl = "string",
#'   StorageClass = "TEMPORAL",
#'   UploadAvailability = "STANDARD"|"STREAMING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mediastoredata_put_object
mediastoredata_put_object <- function(Body, Path, ContentType = NULL, CacheControl = NULL, StorageClass = NULL, UploadAvailability = NULL) {
  op <- new_operation(
    name = "PutObject",
    http_method = "PUT",
    http_path = "/{Path+}",
    paginator = list()
  )
  input <- .mediastoredata$put_object_input(Body = Body, Path = Path, ContentType = ContentType, CacheControl = CacheControl, StorageClass = StorageClass, UploadAvailability = UploadAvailability)
  output <- .mediastoredata$put_object_output()
  config <- get_config()
  svc <- .mediastoredata$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mediastoredata$operations$put_object <- mediastoredata_put_object

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common new_operation new_request send_request
#' @include xray_service.R
NULL

#' Retrieves a list of traces specified by ID
#'
#' Retrieves a list of traces specified by ID. Each trace is a collection
#' of segment documents that originates from a single request. Use
#' `GetTraceSummaries` to get a list of trace IDs.
#'
#' @usage
#' xray_batch_get_traces(TraceIds, NextToken)
#'
#' @param TraceIds &#91;required&#93; Specify the trace IDs of requests for which to retrieve segments.
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_traces(
#'   TraceIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_batch_get_traces
xray_batch_get_traces <- function(TraceIds, NextToken = NULL) {
  op <- new_operation(
    name = "BatchGetTraces",
    http_method = "POST",
    http_path = "/Traces",
    paginator = list()
  )
  input <- .xray$batch_get_traces_input(TraceIds = TraceIds, NextToken = NextToken)
  output <- .xray$batch_get_traces_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$batch_get_traces <- xray_batch_get_traces

#' Creates a group resource with a name and a filter expression
#'
#' Creates a group resource with a name and a filter expression.
#'
#' @usage
#' xray_create_group(GroupName, FilterExpression)
#'
#' @param GroupName &#91;required&#93; The case-sensitive name of the new group. Default is a reserved name and
#' names must be unique.
#' @param FilterExpression The filter expression defining criteria by which to group traces.
#'
#' @section Request syntax:
#' ```
#' svc$create_group(
#'   GroupName = "string",
#'   FilterExpression = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_create_group
xray_create_group <- function(GroupName, FilterExpression = NULL) {
  op <- new_operation(
    name = "CreateGroup",
    http_method = "POST",
    http_path = "/CreateGroup",
    paginator = list()
  )
  input <- .xray$create_group_input(GroupName = GroupName, FilterExpression = FilterExpression)
  output <- .xray$create_group_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$create_group <- xray_create_group

#' Creates a rule to control sampling behavior for instrumented
#' applications
#'
#' Creates a rule to control sampling behavior for instrumented
#' applications. Services retrieve rules with GetSamplingRules, and
#' evaluate each rule in ascending order of *priority* for each request. If
#' a rule matches, the service records a trace, borrowing it from the
#' reservoir size. After 10 seconds, the service reports back to X-Ray with
#' GetSamplingTargets to get updated versions of each in-use rule. The
#' updated rule contains a trace quota that the service can use instead of
#' borrowing from the reservoir.
#'
#' @usage
#' xray_create_sampling_rule(SamplingRule)
#'
#' @param SamplingRule &#91;required&#93; The rule definition.
#'
#' @section Request syntax:
#' ```
#' svc$create_sampling_rule(
#'   SamplingRule = list(
#'     RuleName = "string",
#'     RuleARN = "string",
#'     ResourceARN = "string",
#'     Priority = 123,
#'     FixedRate = 123.0,
#'     ReservoirSize = 123,
#'     ServiceName = "string",
#'     ServiceType = "string",
#'     Host = "string",
#'     HTTPMethod = "string",
#'     URLPath = "string",
#'     Version = 123,
#'     Attributes = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_create_sampling_rule
xray_create_sampling_rule <- function(SamplingRule) {
  op <- new_operation(
    name = "CreateSamplingRule",
    http_method = "POST",
    http_path = "/CreateSamplingRule",
    paginator = list()
  )
  input <- .xray$create_sampling_rule_input(SamplingRule = SamplingRule)
  output <- .xray$create_sampling_rule_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$create_sampling_rule <- xray_create_sampling_rule

#' Deletes a group resource
#'
#' Deletes a group resource.
#'
#' @usage
#' xray_delete_group(GroupName, GroupARN)
#'
#' @param GroupName The case-sensitive name of the group.
#' @param GroupARN The ARN of the group that was generated on creation.
#'
#' @section Request syntax:
#' ```
#' svc$delete_group(
#'   GroupName = "string",
#'   GroupARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_delete_group
xray_delete_group <- function(GroupName = NULL, GroupARN = NULL) {
  op <- new_operation(
    name = "DeleteGroup",
    http_method = "POST",
    http_path = "/DeleteGroup",
    paginator = list()
  )
  input <- .xray$delete_group_input(GroupName = GroupName, GroupARN = GroupARN)
  output <- .xray$delete_group_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$delete_group <- xray_delete_group

#' Deletes a sampling rule
#'
#' Deletes a sampling rule.
#'
#' @usage
#' xray_delete_sampling_rule(RuleName, RuleARN)
#'
#' @param RuleName The name of the sampling rule. Specify a rule by either name or ARN, but
#' not both.
#' @param RuleARN The ARN of the sampling rule. Specify a rule by either name or ARN, but
#' not both.
#'
#' @section Request syntax:
#' ```
#' svc$delete_sampling_rule(
#'   RuleName = "string",
#'   RuleARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_delete_sampling_rule
xray_delete_sampling_rule <- function(RuleName = NULL, RuleARN = NULL) {
  op <- new_operation(
    name = "DeleteSamplingRule",
    http_method = "POST",
    http_path = "/DeleteSamplingRule",
    paginator = list()
  )
  input <- .xray$delete_sampling_rule_input(RuleName = RuleName, RuleARN = RuleARN)
  output <- .xray$delete_sampling_rule_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$delete_sampling_rule <- xray_delete_sampling_rule

#' Retrieves the current encryption configuration for X-Ray data
#'
#' Retrieves the current encryption configuration for X-Ray data.
#'
#' @usage
#' xray_get_encryption_config()
#'
#' @section Request syntax:
#' ```
#' svc$get_encryption_config()
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_encryption_config
xray_get_encryption_config <- function() {
  op <- new_operation(
    name = "GetEncryptionConfig",
    http_method = "POST",
    http_path = "/EncryptionConfig",
    paginator = list()
  )
  input <- .xray$get_encryption_config_input()
  output <- .xray$get_encryption_config_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_encryption_config <- xray_get_encryption_config

#' Retrieves group resource details
#'
#' Retrieves group resource details.
#'
#' @usage
#' xray_get_group(GroupName, GroupARN)
#'
#' @param GroupName The case-sensitive name of the group.
#' @param GroupARN The ARN of the group that was generated on creation.
#'
#' @section Request syntax:
#' ```
#' svc$get_group(
#'   GroupName = "string",
#'   GroupARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_group
xray_get_group <- function(GroupName = NULL, GroupARN = NULL) {
  op <- new_operation(
    name = "GetGroup",
    http_method = "POST",
    http_path = "/GetGroup",
    paginator = list()
  )
  input <- .xray$get_group_input(GroupName = GroupName, GroupARN = GroupARN)
  output <- .xray$get_group_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_group <- xray_get_group

#' Retrieves all active group details
#'
#' Retrieves all active group details.
#'
#' @usage
#' xray_get_groups(NextToken)
#'
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_groups(
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_groups
xray_get_groups <- function(NextToken = NULL) {
  op <- new_operation(
    name = "GetGroups",
    http_method = "POST",
    http_path = "/Groups",
    paginator = list()
  )
  input <- .xray$get_groups_input(NextToken = NextToken)
  output <- .xray$get_groups_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_groups <- xray_get_groups

#' Retrieves all sampling rules
#'
#' Retrieves all sampling rules.
#'
#' @usage
#' xray_get_sampling_rules(NextToken)
#'
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_sampling_rules(
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_sampling_rules
xray_get_sampling_rules <- function(NextToken = NULL) {
  op <- new_operation(
    name = "GetSamplingRules",
    http_method = "POST",
    http_path = "/GetSamplingRules",
    paginator = list()
  )
  input <- .xray$get_sampling_rules_input(NextToken = NextToken)
  output <- .xray$get_sampling_rules_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_sampling_rules <- xray_get_sampling_rules

#' Retrieves information about recent sampling results for all sampling
#' rules
#'
#' Retrieves information about recent sampling results for all sampling
#' rules.
#'
#' @usage
#' xray_get_sampling_statistic_summaries(NextToken)
#'
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_sampling_statistic_summaries(
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_sampling_statistic_summaries
xray_get_sampling_statistic_summaries <- function(NextToken = NULL) {
  op <- new_operation(
    name = "GetSamplingStatisticSummaries",
    http_method = "POST",
    http_path = "/SamplingStatisticSummaries",
    paginator = list()
  )
  input <- .xray$get_sampling_statistic_summaries_input(NextToken = NextToken)
  output <- .xray$get_sampling_statistic_summaries_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_sampling_statistic_summaries <- xray_get_sampling_statistic_summaries

#' Requests a sampling quota for rules that the service is using to sample
#' requests
#'
#' Requests a sampling quota for rules that the service is using to sample
#' requests.
#'
#' @usage
#' xray_get_sampling_targets(SamplingStatisticsDocuments)
#'
#' @param SamplingStatisticsDocuments &#91;required&#93; Information about rules that the service is using to sample requests.
#'
#' @section Request syntax:
#' ```
#' svc$get_sampling_targets(
#'   SamplingStatisticsDocuments = list(
#'     list(
#'       RuleName = "string",
#'       ClientID = "string",
#'       Timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RequestCount = 123,
#'       SampledCount = 123,
#'       BorrowCount = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_sampling_targets
xray_get_sampling_targets <- function(SamplingStatisticsDocuments) {
  op <- new_operation(
    name = "GetSamplingTargets",
    http_method = "POST",
    http_path = "/SamplingTargets",
    paginator = list()
  )
  input <- .xray$get_sampling_targets_input(SamplingStatisticsDocuments = SamplingStatisticsDocuments)
  output <- .xray$get_sampling_targets_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_sampling_targets <- xray_get_sampling_targets

#' Retrieves a document that describes services that process incoming
#' requests, and downstream services that they call as a result
#'
#' Retrieves a document that describes services that process incoming
#' requests, and downstream services that they call as a result. Root
#' services process incoming requests and make calls to downstream
#' services. Root services are applications that use the AWS X-Ray SDK.
#' Downstream services can be other applications, AWS resources, HTTP web
#' APIs, or SQL databases.
#'
#' @usage
#' xray_get_service_graph(StartTime, EndTime, GroupName, GroupARN,
#'   NextToken)
#'
#' @param StartTime &#91;required&#93; The start of the time frame for which to generate a graph.
#' @param EndTime &#91;required&#93; The end of the timeframe for which to generate a graph.
#' @param GroupName The name of a group to generate a graph based on.
#' @param GroupARN The ARN of a group to generate a graph based on.
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_service_graph(
#'   StartTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   EndTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   GroupName = "string",
#'   GroupARN = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_service_graph
xray_get_service_graph <- function(StartTime, EndTime, GroupName = NULL, GroupARN = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetServiceGraph",
    http_method = "POST",
    http_path = "/ServiceGraph",
    paginator = list()
  )
  input <- .xray$get_service_graph_input(StartTime = StartTime, EndTime = EndTime, GroupName = GroupName, GroupARN = GroupARN, NextToken = NextToken)
  output <- .xray$get_service_graph_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_service_graph <- xray_get_service_graph

#' Get an aggregation of service statistics defined by a specific time
#' range
#'
#' Get an aggregation of service statistics defined by a specific time
#' range.
#'
#' @usage
#' xray_get_time_series_service_statistics(StartTime, EndTime, GroupName,
#'   GroupARN, EntitySelectorExpression, Period, NextToken)
#'
#' @param StartTime &#91;required&#93; The start of the time frame for which to aggregate statistics.
#' @param EndTime &#91;required&#93; The end of the time frame for which to aggregate statistics.
#' @param GroupName The case-sensitive name of the group for which to pull statistics from.
#' @param GroupARN The ARN of the group for which to pull statistics from.
#' @param EntitySelectorExpression A filter expression defining entities that will be aggregated for
#' statistics. Supports ID, service, and edge functions. If no selector
#' expression is specified, edge statistics are returned.
#' @param Period Aggregation period in seconds.
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_time_series_service_statistics(
#'   StartTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   EndTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   GroupName = "string",
#'   GroupARN = "string",
#'   EntitySelectorExpression = "string",
#'   Period = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_time_series_service_statistics
xray_get_time_series_service_statistics <- function(StartTime, EndTime, GroupName = NULL, GroupARN = NULL, EntitySelectorExpression = NULL, Period = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetTimeSeriesServiceStatistics",
    http_method = "POST",
    http_path = "/TimeSeriesServiceStatistics",
    paginator = list()
  )
  input <- .xray$get_time_series_service_statistics_input(StartTime = StartTime, EndTime = EndTime, GroupName = GroupName, GroupARN = GroupARN, EntitySelectorExpression = EntitySelectorExpression, Period = Period, NextToken = NextToken)
  output <- .xray$get_time_series_service_statistics_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_time_series_service_statistics <- xray_get_time_series_service_statistics

#' Retrieves a service graph for one or more specific trace IDs
#'
#' Retrieves a service graph for one or more specific trace IDs.
#'
#' @usage
#' xray_get_trace_graph(TraceIds, NextToken)
#'
#' @param TraceIds &#91;required&#93; Trace IDs of requests for which to generate a service graph.
#' @param NextToken Pagination token. Not used.
#'
#' @section Request syntax:
#' ```
#' svc$get_trace_graph(
#'   TraceIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_trace_graph
xray_get_trace_graph <- function(TraceIds, NextToken = NULL) {
  op <- new_operation(
    name = "GetTraceGraph",
    http_method = "POST",
    http_path = "/TraceGraph",
    paginator = list()
  )
  input <- .xray$get_trace_graph_input(TraceIds = TraceIds, NextToken = NextToken)
  output <- .xray$get_trace_graph_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_trace_graph <- xray_get_trace_graph

#' Retrieves IDs and metadata for traces available for a specified time
#' frame using an optional filter
#'
#' Retrieves IDs and metadata for traces available for a specified time
#' frame using an optional filter. To get the full traces, pass the trace
#' IDs to `BatchGetTraces`.
#' 
#' A filter expression can target traced requests that hit specific service
#' nodes or edges, have errors, or come from a known user. For example, the
#' following filter expression targets traces that pass through
#' `api.example.com`:
#' 
#' `service("api.example.com")`
#' 
#' This filter expression finds traces that have an annotation named
#' `account` with the value `12345`:
#' 
#' `annotation.account = "12345"`
#' 
#' For a full list of indexed fields and keywords that you can use in
#' filter expressions, see [Using Filter
#' Expressions](https://docs.aws.amazon.com/xray/latest/devguide/xray-console-filters.html)
#' in the *AWS X-Ray Developer Guide*.
#'
#' @usage
#' xray_get_trace_summaries(StartTime, EndTime, TimeRangeType, Sampling,
#'   SamplingStrategy, FilterExpression, NextToken)
#'
#' @param StartTime &#91;required&#93; The start of the time frame for which to retrieve traces.
#' @param EndTime &#91;required&#93; The end of the time frame for which to retrieve traces.
#' @param TimeRangeType A parameter to indicate whether to query trace summaries by TraceId or
#' Event time.
#' @param Sampling Set to `true` to get summaries for only a subset of available traces.
#' @param SamplingStrategy A paramater to indicate whether to enable sampling on trace summaries.
#' Input parameters are Name and Value.
#' @param FilterExpression Specify a filter expression to retrieve trace summaries for services or
#' requests that meet certain requirements.
#' @param NextToken Specify the pagination token returned by a previous request to retrieve
#' the next page of results.
#'
#' @section Request syntax:
#' ```
#' svc$get_trace_summaries(
#'   StartTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   EndTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   TimeRangeType = "TraceId"|"Event",
#'   Sampling = TRUE|FALSE,
#'   SamplingStrategy = list(
#'     Name = "PartialScan"|"FixedRate",
#'     Value = 123.0
#'   ),
#'   FilterExpression = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_get_trace_summaries
xray_get_trace_summaries <- function(StartTime, EndTime, TimeRangeType = NULL, Sampling = NULL, SamplingStrategy = NULL, FilterExpression = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetTraceSummaries",
    http_method = "POST",
    http_path = "/TraceSummaries",
    paginator = list()
  )
  input <- .xray$get_trace_summaries_input(StartTime = StartTime, EndTime = EndTime, TimeRangeType = TimeRangeType, Sampling = Sampling, SamplingStrategy = SamplingStrategy, FilterExpression = FilterExpression, NextToken = NextToken)
  output <- .xray$get_trace_summaries_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$get_trace_summaries <- xray_get_trace_summaries

#' Updates the encryption configuration for X-Ray data
#'
#' Updates the encryption configuration for X-Ray data.
#'
#' @usage
#' xray_put_encryption_config(KeyId, Type)
#'
#' @param KeyId An AWS KMS customer master key (CMK) in one of the following formats:
#' 
#' -   **Alias** - The name of the key. For example, `alias/MyKey`.
#' 
#' -   **Key ID** - The KMS key ID of the key. For example,
#'     `ae4aa6d49-a4d8-9df9-a475-4ff6d7898456`.
#' 
#' -   **ARN** - The full Amazon Resource Name of the key ID or alias. For
#'     example,
#'     `arn:aws:kms:us-east-2:123456789012:key/ae4aa6d49-a4d8-9df9-a475-4ff6d7898456`.
#'     Use this format to specify a key in a different account.
#' 
#' Omit this key if you set `Type` to `NONE`.
#' @param Type &#91;required&#93; The type of encryption. Set to `KMS` to use your own key for encryption.
#' Set to `NONE` for default encryption.
#'
#' @section Request syntax:
#' ```
#' svc$put_encryption_config(
#'   KeyId = "string",
#'   Type = "NONE"|"KMS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_put_encryption_config
xray_put_encryption_config <- function(KeyId = NULL, Type) {
  op <- new_operation(
    name = "PutEncryptionConfig",
    http_method = "POST",
    http_path = "/PutEncryptionConfig",
    paginator = list()
  )
  input <- .xray$put_encryption_config_input(KeyId = KeyId, Type = Type)
  output <- .xray$put_encryption_config_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$put_encryption_config <- xray_put_encryption_config

#' Used by the AWS X-Ray daemon to upload telemetry
#'
#' Used by the AWS X-Ray daemon to upload telemetry.
#'
#' @usage
#' xray_put_telemetry_records(TelemetryRecords, EC2InstanceId, Hostname,
#'   ResourceARN)
#'
#' @param TelemetryRecords &#91;required&#93; 
#' @param EC2InstanceId 
#' @param Hostname 
#' @param ResourceARN 
#'
#' @section Request syntax:
#' ```
#' svc$put_telemetry_records(
#'   TelemetryRecords = list(
#'     list(
#'       Timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       SegmentsReceivedCount = 123,
#'       SegmentsSentCount = 123,
#'       SegmentsSpilloverCount = 123,
#'       SegmentsRejectedCount = 123,
#'       BackendConnectionErrors = list(
#'         TimeoutCount = 123,
#'         ConnectionRefusedCount = 123,
#'         HTTPCode4XXCount = 123,
#'         HTTPCode5XXCount = 123,
#'         UnknownHostCount = 123,
#'         OtherCount = 123
#'       )
#'     )
#'   ),
#'   EC2InstanceId = "string",
#'   Hostname = "string",
#'   ResourceARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_put_telemetry_records
xray_put_telemetry_records <- function(TelemetryRecords, EC2InstanceId = NULL, Hostname = NULL, ResourceARN = NULL) {
  op <- new_operation(
    name = "PutTelemetryRecords",
    http_method = "POST",
    http_path = "/TelemetryRecords",
    paginator = list()
  )
  input <- .xray$put_telemetry_records_input(TelemetryRecords = TelemetryRecords, EC2InstanceId = EC2InstanceId, Hostname = Hostname, ResourceARN = ResourceARN)
  output <- .xray$put_telemetry_records_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$put_telemetry_records <- xray_put_telemetry_records

#' Uploads segment documents to AWS X-Ray
#'
#' Uploads segment documents to AWS X-Ray. The X-Ray SDK generates segment
#' documents and sends them to the X-Ray daemon, which uploads them in
#' batches. A segment document can be a completed segment, an in-progress
#' segment, or an array of subsegments.
#' 
#' Segments must include the following fields. For the full segment
#' document schema, see [AWS X-Ray Segment
#' Documents](https://docs.aws.amazon.com/xray/latest/devguide/xray-api-segmentdocuments.html)
#' in the *AWS X-Ray Developer Guide*.
#' 
#' **Required Segment Document Fields**
#' 
#' -   `name` - The name of the service that handled the request.
#' 
#' -   `id` - A 64-bit identifier for the segment, unique among segments in
#'     the same trace, in 16 hexadecimal digits.
#' 
#' -   `trace_id` - A unique identifier that connects all segments and
#'     subsegments originating from a single client request.
#' 
#' -   `start_time` - Time the segment or subsegment was created, in
#'     floating point seconds in epoch time, accurate to milliseconds. For
#'     example, `1480615200.010` or `1.480615200010E9`.
#' 
#' -   `end_time` - Time the segment or subsegment was closed. For example,
#'     `1480615200.090` or `1.480615200090E9`. Specify either an `end_time`
#'     or `in_progress`.
#' 
#' -   `in_progress` - Set to `true` instead of specifying an `end_time` to
#'     record that a segment has been started, but is not complete. Send an
#'     in progress segment when your application receives a request that
#'     will take a long time to serve, to trace the fact that the request
#'     was received. When the response is sent, send the complete segment
#'     to overwrite the in-progress segment.
#' 
#' A `trace_id` consists of three numbers separated by hyphens. For
#' example, 1-58406520-a006649127e371903a2de979. This includes:
#' 
#' **Trace ID Format**
#' 
#' -   The version number, i.e. `1`.
#' 
#' -   The time of the original request, in Unix epoch time, in 8
#'     hexadecimal digits. For example, 10:00AM December 2nd, 2016 PST in
#'     epoch time is `1480615200` seconds, or `58406520` in hexadecimal.
#' 
#' -   A 96-bit identifier for the trace, globally unique, in 24
#'     hexadecimal digits.
#'
#' @usage
#' xray_put_trace_segments(TraceSegmentDocuments)
#'
#' @param TraceSegmentDocuments &#91;required&#93; A string containing a JSON document defining one or more segments or
#' subsegments.
#'
#' @section Request syntax:
#' ```
#' svc$put_trace_segments(
#'   TraceSegmentDocuments = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_put_trace_segments
xray_put_trace_segments <- function(TraceSegmentDocuments) {
  op <- new_operation(
    name = "PutTraceSegments",
    http_method = "POST",
    http_path = "/TraceSegments",
    paginator = list()
  )
  input <- .xray$put_trace_segments_input(TraceSegmentDocuments = TraceSegmentDocuments)
  output <- .xray$put_trace_segments_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$put_trace_segments <- xray_put_trace_segments

#' Updates a group resource
#'
#' Updates a group resource.
#'
#' @usage
#' xray_update_group(GroupName, GroupARN, FilterExpression)
#'
#' @param GroupName The case-sensitive name of the group.
#' @param GroupARN The ARN that was generated upon creation.
#' @param FilterExpression The updated filter expression defining criteria by which to group
#' traces.
#'
#' @section Request syntax:
#' ```
#' svc$update_group(
#'   GroupName = "string",
#'   GroupARN = "string",
#'   FilterExpression = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_update_group
xray_update_group <- function(GroupName = NULL, GroupARN = NULL, FilterExpression = NULL) {
  op <- new_operation(
    name = "UpdateGroup",
    http_method = "POST",
    http_path = "/UpdateGroup",
    paginator = list()
  )
  input <- .xray$update_group_input(GroupName = GroupName, GroupARN = GroupARN, FilterExpression = FilterExpression)
  output <- .xray$update_group_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$update_group <- xray_update_group

#' Modifies a sampling rule's configuration
#'
#' Modifies a sampling rule\'s configuration.
#'
#' @usage
#' xray_update_sampling_rule(SamplingRuleUpdate)
#'
#' @param SamplingRuleUpdate &#91;required&#93; The rule and fields to change.
#'
#' @section Request syntax:
#' ```
#' svc$update_sampling_rule(
#'   SamplingRuleUpdate = list(
#'     RuleName = "string",
#'     RuleARN = "string",
#'     ResourceARN = "string",
#'     Priority = 123,
#'     FixedRate = 123.0,
#'     ReservoirSize = 123,
#'     Host = "string",
#'     ServiceName = "string",
#'     ServiceType = "string",
#'     HTTPMethod = "string",
#'     URLPath = "string",
#'     Attributes = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname xray_update_sampling_rule
xray_update_sampling_rule <- function(SamplingRuleUpdate) {
  op <- new_operation(
    name = "UpdateSamplingRule",
    http_method = "POST",
    http_path = "/UpdateSamplingRule",
    paginator = list()
  )
  input <- .xray$update_sampling_rule_input(SamplingRuleUpdate = SamplingRuleUpdate)
  output <- .xray$update_sampling_rule_output()
  svc <- .xray$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.xray$operations$update_sampling_rule <- xray_update_sampling_rule

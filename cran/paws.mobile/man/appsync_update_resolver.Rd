% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/appsync_operations.R
\name{appsync_update_resolver}
\alias{appsync_update_resolver}
\title{Updates a Resolver object}
\usage{
appsync_update_resolver(apiId, typeName, fieldName, dataSourceName,
  requestMappingTemplate, responseMappingTemplate, kind, pipelineConfig,
  syncConfig, cachingConfig)
}
\arguments{
\item{apiId}{[required] The API ID.}

\item{typeName}{[required] The new type name.}

\item{fieldName}{[required] The new field name.}

\item{dataSourceName}{The new data source name.}

\item{requestMappingTemplate}{The new request mapping template.

A resolver uses a request mapping template to convert a GraphQL
expression into a format that a data source can understand. Mapping
templates are written in Apache Velocity Template Language (VTL).

VTL request mapping templates are optional when using a Lambda data
source. For all other data sources, VTL request and response mapping
templates are required.}

\item{responseMappingTemplate}{The new response mapping template.}

\item{kind}{The resolver type.
\itemize{
\item \strong{UNIT}: A UNIT resolver type. A UNIT resolver is the default
resolver type. A UNIT resolver enables you to execute a GraphQL
query against a single data source.
\item \strong{PIPELINE}: A PIPELINE resolver type. A PIPELINE resolver enables
you to execute a series of \code{Function} in a serial manner. You can
use a pipeline resolver to execute a GraphQL query against multiple
data sources.
}}

\item{pipelineConfig}{The \code{PipelineConfig}.}

\item{syncConfig}{The \code{SyncConfig} for a resolver attached to a versioned datasource.}

\item{cachingConfig}{The caching configuration for the resolver.}
}
\value{
A list with the following syntax:

\if{html}{\out{<div class="sourceCode">}}\preformatted{list(
  resolver = list(
    typeName = "string",
    fieldName = "string",
    dataSourceName = "string",
    resolverArn = "string",
    requestMappingTemplate = "string",
    responseMappingTemplate = "string",
    kind = "UNIT"|"PIPELINE",
    pipelineConfig = list(
      functions = list(
        "string"
      )
    ),
    syncConfig = list(
      conflictHandler = "OPTIMISTIC_CONCURRENCY"|"LAMBDA"|"AUTOMERGE"|"NONE",
      conflictDetection = "VERSION"|"NONE",
      lambdaConflictHandlerConfig = list(
        lambdaConflictHandlerArn = "string"
      )
    ),
    cachingConfig = list(
      ttl = 123,
      cachingKeys = list(
        "string"
      )
    )
  )
)
}\if{html}{\out{</div>}}
}
\description{
Updates a \code{Resolver} object.
}
\section{Request syntax}{


\if{html}{\out{<div class="sourceCode">}}\preformatted{svc$update_resolver(
  apiId = "string",
  typeName = "string",
  fieldName = "string",
  dataSourceName = "string",
  requestMappingTemplate = "string",
  responseMappingTemplate = "string",
  kind = "UNIT"|"PIPELINE",
  pipelineConfig = list(
    functions = list(
      "string"
    )
  ),
  syncConfig = list(
    conflictHandler = "OPTIMISTIC_CONCURRENCY"|"LAMBDA"|"AUTOMERGE"|"NONE",
    conflictDetection = "VERSION"|"NONE",
    lambdaConflictHandlerConfig = list(
      lambdaConflictHandlerArn = "string"
    )
  ),
  cachingConfig = list(
    ttl = 123,
    cachingKeys = list(
      "string"
    )
  )
)
}\if{html}{\out{</div>}}
}

\keyword{internal}

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/appsync_operations.R
\name{appsync_create_resolver}
\alias{appsync_create_resolver}
\title{Creates a Resolver object}
\usage{
appsync_create_resolver(apiId, typeName, fieldName, dataSourceName,
  requestMappingTemplate, responseMappingTemplate, kind, pipelineConfig,
  syncConfig, cachingConfig)
}
\arguments{
\item{apiId}{[required] The ID for the GraphQL API for which the resolver is being created.}

\item{typeName}{[required] The name of the \code{Type}.}

\item{fieldName}{[required] The name of the field to attach the resolver to.}

\item{dataSourceName}{The name of the data source for which the resolver is being created.}

\item{requestMappingTemplate}{The mapping template to be used for requests.

A resolver uses a request mapping template to convert a GraphQL
expression into a format that a data source can understand. Mapping
templates are written in Apache Velocity Template Language (VTL).

VTL request mapping templates are optional when using a Lambda data
source. For all other data sources, VTL request and response mapping
templates are required.}

\item{responseMappingTemplate}{The mapping template to be used for responses from the data source.}

\item{kind}{The resolver type.
\itemize{
\item \strong{UNIT}: A UNIT resolver type. A UNIT resolver is the default
resolver type. A UNIT resolver enables you to execute a GraphQL
query against a single data source.
\item \strong{PIPELINE}: A PIPELINE resolver type. A PIPELINE resolver enables
you to execute a series of \code{Function} in a serial manner. You can
use a pipeline resolver to execute a GraphQL query against multiple
data sources.
}}

\item{pipelineConfig}{The \code{PipelineConfig}.}

\item{syncConfig}{The \code{SyncConfig} for a resolver attached to a versioned datasource.}

\item{cachingConfig}{The caching configuration for the resolver.}
}
\description{
Creates a \code{Resolver} object.
}
\details{
A resolver converts incoming requests into a format that a data source
can understand and converts the data source's responses into GraphQL.
}
\section{Request syntax}{
\preformatted{svc$create_resolver(
  apiId = "string",
  typeName = "string",
  fieldName = "string",
  dataSourceName = "string",
  requestMappingTemplate = "string",
  responseMappingTemplate = "string",
  kind = "UNIT"|"PIPELINE",
  pipelineConfig = list(
    functions = list(
      "string"
    )
  ),
  syncConfig = list(
    conflictHandler = "OPTIMISTIC_CONCURRENCY"|"LAMBDA"|"AUTOMERGE"|"NONE",
    conflictDetection = "VERSION"|"NONE",
    lambdaConflictHandlerConfig = list(
      lambdaConflictHandlerArn = "string"
    )
  ),
  cachingConfig = list(
    ttl = 123,
    cachingKeys = list(
      "string"
    )
  )
)
}
}

\keyword{internal}

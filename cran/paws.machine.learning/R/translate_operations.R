# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include translate_service.R
NULL

#' Creates a parallel data resource in Amazon Translate by importing an
#' input file from Amazon S3
#'
#' @description
#' Creates a parallel data resource in Amazon Translate by importing an
#' input file from Amazon S3. Parallel data files contain examples of
#' source phrases and their translations from your translation memory. By
#' adding parallel data, you can influence the style, tone, and word choice
#' in your translation output.
#'
#' @usage
#' translate_create_parallel_data(Name, Description, ParallelDataConfig,
#'   EncryptionKey, ClientToken)
#'
#' @param Name &#91;required&#93; A custom name for the parallel data resource in Amazon Translate. You
#' must assign a name that is unique in the account and region.
#' @param Description A custom description for the parallel data resource in Amazon Translate.
#' @param ParallelDataConfig &#91;required&#93; Specifies the format and S3 location of the parallel data input file.
#' @param EncryptionKey 
#' @param ClientToken &#91;required&#93; A unique identifier for the request. This token is automatically
#' generated when you use Amazon Translate through an AWS SDK.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Status = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_parallel_data(
#'   Name = "string",
#'   Description = "string",
#'   ParallelDataConfig = list(
#'     S3Uri = "string",
#'     Format = "TSV"|"CSV"|"TMX"
#'   ),
#'   EncryptionKey = list(
#'     Type = "KMS",
#'     Id = "string"
#'   ),
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_create_parallel_data
translate_create_parallel_data <- function(Name, Description = NULL, ParallelDataConfig, EncryptionKey = NULL, ClientToken) {
  op <- new_operation(
    name = "CreateParallelData",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$create_parallel_data_input(Name = Name, Description = Description, ParallelDataConfig = ParallelDataConfig, EncryptionKey = EncryptionKey, ClientToken = ClientToken)
  output <- .translate$create_parallel_data_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$create_parallel_data <- translate_create_parallel_data

#' Deletes a parallel data resource in Amazon Translate
#'
#' @description
#' Deletes a parallel data resource in Amazon Translate.
#'
#' @usage
#' translate_delete_parallel_data(Name)
#'
#' @param Name &#91;required&#93; The name of the parallel data resource that is being deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Status = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_parallel_data(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_delete_parallel_data
translate_delete_parallel_data <- function(Name) {
  op <- new_operation(
    name = "DeleteParallelData",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$delete_parallel_data_input(Name = Name)
  output <- .translate$delete_parallel_data_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$delete_parallel_data <- translate_delete_parallel_data

#' A synchronous action that deletes a custom terminology
#'
#' @description
#' A synchronous action that deletes a custom terminology.
#'
#' @usage
#' translate_delete_terminology(Name)
#'
#' @param Name &#91;required&#93; The name of the custom terminology being deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_terminology(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_delete_terminology
translate_delete_terminology <- function(Name) {
  op <- new_operation(
    name = "DeleteTerminology",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$delete_terminology_input(Name = Name)
  output <- .translate$delete_terminology_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$delete_terminology <- translate_delete_terminology

#' Gets the properties associated with an asycnhronous batch translation
#' job including name, ID, status, source and target languages,
#' input/output S3 buckets, and so on
#'
#' @description
#' Gets the properties associated with an asycnhronous batch translation
#' job including name, ID, status, source and target languages,
#' input/output S3 buckets, and so on.
#'
#' @usage
#' translate_describe_text_translation_job(JobId)
#'
#' @param JobId &#91;required&#93; The identifier that Amazon Translate generated for the job. The
#' [`start_text_translation_job`][translate_start_text_translation_job]
#' operation returns this identifier in its response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TextTranslationJobProperties = list(
#'     JobId = "string",
#'     JobName = "string",
#'     JobStatus = "SUBMITTED"|"IN_PROGRESS"|"COMPLETED"|"COMPLETED_WITH_ERROR"|"FAILED"|"STOP_REQUESTED"|"STOPPED",
#'     JobDetails = list(
#'       TranslatedDocumentsCount = 123,
#'       DocumentsWithErrorsCount = 123,
#'       InputDocumentsCount = 123
#'     ),
#'     SourceLanguageCode = "string",
#'     TargetLanguageCodes = list(
#'       "string"
#'     ),
#'     TerminologyNames = list(
#'       "string"
#'     ),
#'     ParallelDataNames = list(
#'       "string"
#'     ),
#'     Message = "string",
#'     SubmittedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     InputDataConfig = list(
#'       S3Uri = "string",
#'       ContentType = "string"
#'     ),
#'     OutputDataConfig = list(
#'       S3Uri = "string"
#'     ),
#'     DataAccessRoleArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_text_translation_job(
#'   JobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_describe_text_translation_job
translate_describe_text_translation_job <- function(JobId) {
  op <- new_operation(
    name = "DescribeTextTranslationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$describe_text_translation_job_input(JobId = JobId)
  output <- .translate$describe_text_translation_job_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$describe_text_translation_job <- translate_describe_text_translation_job

#' Provides information about a parallel data resource
#'
#' @description
#' Provides information about a parallel data resource.
#'
#' @usage
#' translate_get_parallel_data(Name)
#'
#' @param Name &#91;required&#93; The name of the parallel data resource that is being retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ParallelDataProperties = list(
#'     Name = "string",
#'     Arn = "string",
#'     Description = "string",
#'     Status = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'     SourceLanguageCode = "string",
#'     TargetLanguageCodes = list(
#'       "string"
#'     ),
#'     ParallelDataConfig = list(
#'       S3Uri = "string",
#'       Format = "TSV"|"CSV"|"TMX"
#'     ),
#'     Message = "string",
#'     ImportedDataSize = 123,
#'     ImportedRecordCount = 123,
#'     FailedRecordCount = 123,
#'     SkippedRecordCount = 123,
#'     EncryptionKey = list(
#'       Type = "KMS",
#'       Id = "string"
#'     ),
#'     CreatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LatestUpdateAttemptStatus = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'     LatestUpdateAttemptAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   DataLocation = list(
#'     RepositoryType = "string",
#'     Location = "string"
#'   ),
#'   AuxiliaryDataLocation = list(
#'     RepositoryType = "string",
#'     Location = "string"
#'   ),
#'   LatestUpdateAttemptAuxiliaryDataLocation = list(
#'     RepositoryType = "string",
#'     Location = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_parallel_data(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_get_parallel_data
translate_get_parallel_data <- function(Name) {
  op <- new_operation(
    name = "GetParallelData",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$get_parallel_data_input(Name = Name)
  output <- .translate$get_parallel_data_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$get_parallel_data <- translate_get_parallel_data

#' Retrieves a custom terminology
#'
#' @description
#' Retrieves a custom terminology.
#'
#' @usage
#' translate_get_terminology(Name, TerminologyDataFormat)
#'
#' @param Name &#91;required&#93; The name of the custom terminology being retrieved.
#' @param TerminologyDataFormat &#91;required&#93; The data format of the custom terminology being retrieved, either CSV or
#' TMX.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TerminologyProperties = list(
#'     Name = "string",
#'     Description = "string",
#'     Arn = "string",
#'     SourceLanguageCode = "string",
#'     TargetLanguageCodes = list(
#'       "string"
#'     ),
#'     EncryptionKey = list(
#'       Type = "KMS",
#'       Id = "string"
#'     ),
#'     SizeBytes = 123,
#'     TermCount = 123,
#'     CreatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   TerminologyDataLocation = list(
#'     RepositoryType = "string",
#'     Location = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_terminology(
#'   Name = "string",
#'   TerminologyDataFormat = "CSV"|"TMX"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_get_terminology
translate_get_terminology <- function(Name, TerminologyDataFormat) {
  op <- new_operation(
    name = "GetTerminology",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$get_terminology_input(Name = Name, TerminologyDataFormat = TerminologyDataFormat)
  output <- .translate$get_terminology_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$get_terminology <- translate_get_terminology

#' Creates or updates a custom terminology, depending on whether or not one
#' already exists for the given terminology name
#'
#' @description
#' Creates or updates a custom terminology, depending on whether or not one
#' already exists for the given terminology name. Importing a terminology
#' with the same name as an existing one will merge the terminologies based
#' on the chosen merge strategy. Currently, the only supported merge
#' strategy is OVERWRITE, and so the imported terminology will overwrite an
#' existing terminology of the same name.
#' 
#' If you import a terminology that overwrites an existing one, the new
#' terminology take up to 10 minutes to fully propagate and be available
#' for use in a translation due to cache policies with the DataPlane
#' service that performs the translations.
#'
#' @usage
#' translate_import_terminology(Name, MergeStrategy, Description,
#'   TerminologyData, EncryptionKey)
#'
#' @param Name &#91;required&#93; The name of the custom terminology being imported.
#' @param MergeStrategy &#91;required&#93; The merge strategy of the custom terminology being imported. Currently,
#' only the OVERWRITE merge strategy is supported. In this case, the
#' imported terminology will overwrite an existing terminology of the same
#' name.
#' @param Description The description of the custom terminology being imported.
#' @param TerminologyData &#91;required&#93; The terminology data for the custom terminology being imported.
#' @param EncryptionKey The encryption key for the custom terminology being imported.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TerminologyProperties = list(
#'     Name = "string",
#'     Description = "string",
#'     Arn = "string",
#'     SourceLanguageCode = "string",
#'     TargetLanguageCodes = list(
#'       "string"
#'     ),
#'     EncryptionKey = list(
#'       Type = "KMS",
#'       Id = "string"
#'     ),
#'     SizeBytes = 123,
#'     TermCount = 123,
#'     CreatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$import_terminology(
#'   Name = "string",
#'   MergeStrategy = "OVERWRITE",
#'   Description = "string",
#'   TerminologyData = list(
#'     File = raw,
#'     Format = "CSV"|"TMX"
#'   ),
#'   EncryptionKey = list(
#'     Type = "KMS",
#'     Id = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_import_terminology
translate_import_terminology <- function(Name, MergeStrategy, Description = NULL, TerminologyData, EncryptionKey = NULL) {
  op <- new_operation(
    name = "ImportTerminology",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$import_terminology_input(Name = Name, MergeStrategy = MergeStrategy, Description = Description, TerminologyData = TerminologyData, EncryptionKey = EncryptionKey)
  output <- .translate$import_terminology_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$import_terminology <- translate_import_terminology

#' Provides a list of your parallel data resources in Amazon Translate
#'
#' @description
#' Provides a list of your parallel data resources in Amazon Translate.
#'
#' @usage
#' translate_list_parallel_data(NextToken, MaxResults)
#'
#' @param NextToken A string that specifies the next page of results to return in a
#' paginated response.
#' @param MaxResults The maximum number of parallel data resources returned for each request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ParallelDataPropertiesList = list(
#'     list(
#'       Name = "string",
#'       Arn = "string",
#'       Description = "string",
#'       Status = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'       SourceLanguageCode = "string",
#'       TargetLanguageCodes = list(
#'         "string"
#'       ),
#'       ParallelDataConfig = list(
#'         S3Uri = "string",
#'         Format = "TSV"|"CSV"|"TMX"
#'       ),
#'       Message = "string",
#'       ImportedDataSize = 123,
#'       ImportedRecordCount = 123,
#'       FailedRecordCount = 123,
#'       SkippedRecordCount = 123,
#'       EncryptionKey = list(
#'         Type = "KMS",
#'         Id = "string"
#'       ),
#'       CreatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LatestUpdateAttemptStatus = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'       LatestUpdateAttemptAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_parallel_data(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_list_parallel_data
translate_list_parallel_data <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListParallelData",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$list_parallel_data_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .translate$list_parallel_data_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$list_parallel_data <- translate_list_parallel_data

#' Provides a list of custom terminologies associated with your account
#'
#' @description
#' Provides a list of custom terminologies associated with your account.
#'
#' @usage
#' translate_list_terminologies(NextToken, MaxResults)
#'
#' @param NextToken If the result of the request to ListTerminologies was truncated, include
#' the NextToken to fetch the next group of custom terminologies.
#' @param MaxResults The maximum number of custom terminologies returned per list request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TerminologyPropertiesList = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Arn = "string",
#'       SourceLanguageCode = "string",
#'       TargetLanguageCodes = list(
#'         "string"
#'       ),
#'       EncryptionKey = list(
#'         Type = "KMS",
#'         Id = "string"
#'       ),
#'       SizeBytes = 123,
#'       TermCount = 123,
#'       CreatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_terminologies(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_list_terminologies
translate_list_terminologies <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListTerminologies",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$list_terminologies_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .translate$list_terminologies_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$list_terminologies <- translate_list_terminologies

#' Gets a list of the batch translation jobs that you have submitted
#'
#' @description
#' Gets a list of the batch translation jobs that you have submitted.
#'
#' @usage
#' translate_list_text_translation_jobs(Filter, NextToken, MaxResults)
#'
#' @param Filter The parameters that specify which batch translation jobs to retrieve.
#' Filters include job name, job status, and submission time. You can only
#' set one filter at a time.
#' @param NextToken The token to request the next page of results.
#' @param MaxResults The maximum number of results to return in each page. The default value
#' is 100.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TextTranslationJobPropertiesList = list(
#'     list(
#'       JobId = "string",
#'       JobName = "string",
#'       JobStatus = "SUBMITTED"|"IN_PROGRESS"|"COMPLETED"|"COMPLETED_WITH_ERROR"|"FAILED"|"STOP_REQUESTED"|"STOPPED",
#'       JobDetails = list(
#'         TranslatedDocumentsCount = 123,
#'         DocumentsWithErrorsCount = 123,
#'         InputDocumentsCount = 123
#'       ),
#'       SourceLanguageCode = "string",
#'       TargetLanguageCodes = list(
#'         "string"
#'       ),
#'       TerminologyNames = list(
#'         "string"
#'       ),
#'       ParallelDataNames = list(
#'         "string"
#'       ),
#'       Message = "string",
#'       SubmittedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       InputDataConfig = list(
#'         S3Uri = "string",
#'         ContentType = "string"
#'       ),
#'       OutputDataConfig = list(
#'         S3Uri = "string"
#'       ),
#'       DataAccessRoleArn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_text_translation_jobs(
#'   Filter = list(
#'     JobName = "string",
#'     JobStatus = "SUBMITTED"|"IN_PROGRESS"|"COMPLETED"|"COMPLETED_WITH_ERROR"|"FAILED"|"STOP_REQUESTED"|"STOPPED",
#'     SubmittedBeforeTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     SubmittedAfterTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_list_text_translation_jobs
translate_list_text_translation_jobs <- function(Filter = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListTextTranslationJobs",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$list_text_translation_jobs_input(Filter = Filter, NextToken = NextToken, MaxResults = MaxResults)
  output <- .translate$list_text_translation_jobs_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$list_text_translation_jobs <- translate_list_text_translation_jobs

#' Starts an asynchronous batch translation job
#'
#' @description
#' Starts an asynchronous batch translation job. Batch translation jobs can
#' be used to translate large volumes of text across multiple documents at
#' once. For more information, see async.
#' 
#' Batch translation jobs can be described with the
#' [`describe_text_translation_job`][translate_describe_text_translation_job]
#' operation, listed with the
#' [`list_text_translation_jobs`][translate_list_text_translation_jobs]
#' operation, and stopped with the
#' [`stop_text_translation_job`][translate_stop_text_translation_job]
#' operation.
#' 
#' Amazon Translate does not support batch translation of multiple source
#' languages at once.
#'
#' @usage
#' translate_start_text_translation_job(JobName, InputDataConfig,
#'   OutputDataConfig, DataAccessRoleArn, SourceLanguageCode,
#'   TargetLanguageCodes, TerminologyNames, ParallelDataNames, ClientToken)
#'
#' @param JobName The name of the batch translation job to be performed.
#' @param InputDataConfig &#91;required&#93; Specifies the format and S3 location of the input documents for the
#' translation job.
#' @param OutputDataConfig &#91;required&#93; Specifies the S3 folder to which your job output will be saved.
#' @param DataAccessRoleArn &#91;required&#93; The Amazon Resource Name (ARN) of an AWS Identity Access and Management
#' (IAM) role that grants Amazon Translate read access to your input data.
#' For more nformation, see identity-and-access-management.
#' @param SourceLanguageCode &#91;required&#93; The language code of the input language. For a list of language codes,
#' see what-is-languages.
#' 
#' Amazon Translate does not automatically detect a source language during
#' batch translation jobs.
#' @param TargetLanguageCodes &#91;required&#93; The language code of the output language.
#' @param TerminologyNames The name of the terminology to use in the batch translation job. For a
#' list of available terminologies, use the
#' [`list_terminologies`][translate_list_terminologies] operation.
#' @param ParallelDataNames The names of the parallel data resources to use in the batch translation
#' job. For a list of available parallel data resources, use the
#' [`list_parallel_data`][translate_list_parallel_data] operation.
#' @param ClientToken &#91;required&#93; A unique identifier for the request. This token is auto-generated when
#' using the Amazon Translate SDK.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string",
#'   JobStatus = "SUBMITTED"|"IN_PROGRESS"|"COMPLETED"|"COMPLETED_WITH_ERROR"|"FAILED"|"STOP_REQUESTED"|"STOPPED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_text_translation_job(
#'   JobName = "string",
#'   InputDataConfig = list(
#'     S3Uri = "string",
#'     ContentType = "string"
#'   ),
#'   OutputDataConfig = list(
#'     S3Uri = "string"
#'   ),
#'   DataAccessRoleArn = "string",
#'   SourceLanguageCode = "string",
#'   TargetLanguageCodes = list(
#'     "string"
#'   ),
#'   TerminologyNames = list(
#'     "string"
#'   ),
#'   ParallelDataNames = list(
#'     "string"
#'   ),
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_start_text_translation_job
translate_start_text_translation_job <- function(JobName = NULL, InputDataConfig, OutputDataConfig, DataAccessRoleArn, SourceLanguageCode, TargetLanguageCodes, TerminologyNames = NULL, ParallelDataNames = NULL, ClientToken) {
  op <- new_operation(
    name = "StartTextTranslationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$start_text_translation_job_input(JobName = JobName, InputDataConfig = InputDataConfig, OutputDataConfig = OutputDataConfig, DataAccessRoleArn = DataAccessRoleArn, SourceLanguageCode = SourceLanguageCode, TargetLanguageCodes = TargetLanguageCodes, TerminologyNames = TerminologyNames, ParallelDataNames = ParallelDataNames, ClientToken = ClientToken)
  output <- .translate$start_text_translation_job_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$start_text_translation_job <- translate_start_text_translation_job

#' Stops an asynchronous batch translation job that is in progress
#'
#' @description
#' Stops an asynchronous batch translation job that is in progress.
#' 
#' If the job's state is `IN_PROGRESS`, the job will be marked for
#' termination and put into the `STOP_REQUESTED` state. If the job
#' completes before it can be stopped, it is put into the `COMPLETED`
#' state. Otherwise, the job is put into the `STOPPED` state.
#' 
#' Asynchronous batch translation jobs are started with the
#' [`start_text_translation_job`][translate_start_text_translation_job]
#' operation. You can use the
#' [`describe_text_translation_job`][translate_describe_text_translation_job]
#' or [`list_text_translation_jobs`][translate_list_text_translation_jobs]
#' operations to get a batch translation job's `JobId`.
#'
#' @usage
#' translate_stop_text_translation_job(JobId)
#'
#' @param JobId &#91;required&#93; The job ID of the job to be stopped.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string",
#'   JobStatus = "SUBMITTED"|"IN_PROGRESS"|"COMPLETED"|"COMPLETED_WITH_ERROR"|"FAILED"|"STOP_REQUESTED"|"STOPPED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_text_translation_job(
#'   JobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_stop_text_translation_job
translate_stop_text_translation_job <- function(JobId) {
  op <- new_operation(
    name = "StopTextTranslationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$stop_text_translation_job_input(JobId = JobId)
  output <- .translate$stop_text_translation_job_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$stop_text_translation_job <- translate_stop_text_translation_job

#' Translates input text from the source language to the target language
#'
#' @description
#' Translates input text from the source language to the target language.
#' For a list of available languages and language codes, see
#' what-is-languages.
#'
#' @usage
#' translate_translate_text(Text, TerminologyNames, SourceLanguageCode,
#'   TargetLanguageCode)
#'
#' @param Text &#91;required&#93; The text to translate. The text string can be a maximum of 5,000 bytes
#' long. Depending on your character set, this may be fewer than 5,000
#' characters.
#' @param TerminologyNames The name of the terminology list file to be used in the TranslateText
#' request. You can use 1 terminology list at most in a
#' [`translate_text`][translate_translate_text] request. Terminology lists
#' can contain a maximum of 256 terms.
#' @param SourceLanguageCode &#91;required&#93; The language code for the language of the source text. The language must
#' be a language supported by Amazon Translate. For a list of language
#' codes, see what-is-languages.
#' 
#' To have Amazon Translate determine the source language of your text, you
#' can specify `auto` in the `SourceLanguageCode` field. If you specify
#' `auto`, Amazon Translate will call [Amazon
#' Comprehend](https://docs.aws.amazon.com/comprehend/latest/dg/comprehend-general.html)
#' to determine the source language.
#' @param TargetLanguageCode &#91;required&#93; The language code requested for the language of the target text. The
#' language must be a language supported by Amazon Translate.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TranslatedText = "string",
#'   SourceLanguageCode = "string",
#'   TargetLanguageCode = "string",
#'   AppliedTerminologies = list(
#'     list(
#'       Name = "string",
#'       Terms = list(
#'         list(
#'           SourceText = "string",
#'           TargetText = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$translate_text(
#'   Text = "string",
#'   TerminologyNames = list(
#'     "string"
#'   ),
#'   SourceLanguageCode = "string",
#'   TargetLanguageCode = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_translate_text
translate_translate_text <- function(Text, TerminologyNames = NULL, SourceLanguageCode, TargetLanguageCode) {
  op <- new_operation(
    name = "TranslateText",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$translate_text_input(Text = Text, TerminologyNames = TerminologyNames, SourceLanguageCode = SourceLanguageCode, TargetLanguageCode = TargetLanguageCode)
  output <- .translate$translate_text_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$translate_text <- translate_translate_text

#' Updates a previously created parallel data resource by importing a new
#' input file from Amazon S3
#'
#' @description
#' Updates a previously created parallel data resource by importing a new
#' input file from Amazon S3.
#'
#' @usage
#' translate_update_parallel_data(Name, Description, ParallelDataConfig,
#'   ClientToken)
#'
#' @param Name &#91;required&#93; The name of the parallel data resource being updated.
#' @param Description A custom description for the parallel data resource in Amazon Translate.
#' @param ParallelDataConfig &#91;required&#93; Specifies the format and S3 location of the parallel data input file.
#' @param ClientToken &#91;required&#93; A unique identifier for the request. This token is automatically
#' generated when you use Amazon Translate through an AWS SDK.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Status = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'   LatestUpdateAttemptStatus = "CREATING"|"UPDATING"|"ACTIVE"|"DELETING"|"FAILED",
#'   LatestUpdateAttemptAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_parallel_data(
#'   Name = "string",
#'   Description = "string",
#'   ParallelDataConfig = list(
#'     S3Uri = "string",
#'     Format = "TSV"|"CSV"|"TMX"
#'   ),
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname translate_update_parallel_data
translate_update_parallel_data <- function(Name, Description = NULL, ParallelDataConfig, ClientToken) {
  op <- new_operation(
    name = "UpdateParallelData",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .translate$update_parallel_data_input(Name = Name, Description = Description, ParallelDataConfig = ParallelDataConfig, ClientToken = ClientToken)
  output <- .translate$update_parallel_data_output()
  config <- get_config()
  svc <- .translate$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.translate$operations$update_parallel_data <- translate_update_parallel_data

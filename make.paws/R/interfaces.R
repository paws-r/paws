#' @include templates.R
#' @importFrom paws.common is_empty tag_add tag_del
NULL

interface_file_template <- template(
  `
  # This file is generated by make.paws. Please do not edit here.
  #' @importFrom paws.common populate
  #' @include ${service}_service.R
  NULL

  ${interfaces}
  `
)

# Return a list of interfaces for an API.
make_interfaces <- function(api) {
  interfaces <- lapply(api$operations, function(op) make_interface_pair(op, api))
  render(
    interface_file_template,
    service = package_name(api),
    interfaces = paste(interfaces, collapse = "\n\n")
  )
}

# A template for turning users' arguments into the shape to submit to the API.
interface_template <- template(
  `
  ${name} <- function(...) {
    args <- c(as.list(environment()), list(...))
    shape <- ${shape}
    return(populate(args, shape))
  }
  `
)

# Returns a function which translates an R object into a given API input/output
# shape.
make_interface <- function(name, shape_data, api) {
  shape_name <- shape_data$shape
  if (is.null(shape_name)) return(make_empty_interface(name))
  shape <- make_shape(list(shape = shape_name), api)
  shape <- tag_del(shape, c("enum", "min", "max", "pattern"))
  for (key in names(shape_data)) {
    if (key == "shape") next
    shape <- tag_add(shape, setNames(shape_data[[key]], key))
  }
  interface <- render(
    interface_template,
    name = name,
    shape = get_structure(shape)
  )
  return(interface)
}

make_interface_pair <- function(operation, api) {
  name <- get_operation_name(operation)
  service <- package_name(api)
  input_name <- glue::glue(".{service}${name}_input")
  output_name <- glue::glue(".{service}${name}_output")

  input <- make_interface(input_name, operation$input, api)
  output <- make_interface(output_name, operation$output, api)

  paste(input, output, sep = "\n\n")
}

# Declare variables to avoid R CMD check notes about templates.
utils::globalVariables(
  "\n    ${name} <- function(...) {\n      list()\n    }\n    "
)

make_empty_interface <- function(name) {
  interface_template <- template(
    `
    ${name} <- function(...) {
      list()
    }
    `
  )
  interface <- render(interface_template, name = name)
  return(interface)
}

#-------------------------------------------------------------------------------

# Make an API shape, including metadata about types and names.
# Usage: `make_shape(list(shape = SHAPE), api)`
make_shape <- function(x, api, path = character(0)) {

  shape <- api$shapes[[x$shape]]

  loop <- x$shape %in% path
  path <- c(path, x$shape)

  maker <- switch(
    shape$type,
    structure = make_shape_structure,
    list = make_shape_list,
    map = make_shape_map,
    make_shape_scalar
  )

  if (!loop) {
    proto <- maker(shape, api, path)
  } else {
    proto <- placeholder()
  }

  proto <- tag_add(proto, make_tags(x))
  proto <- tag_add(proto, make_tags(shape))
  return(proto)
}

make_shape_structure <- function(shape, api, path) {
  proto <- list()
  members <- shape$members
  for (member_name in names(members)) {
    member <- members[[member_name]]
    interface <- make_shape(member, api, path)
    proto[[member_name]] <- interface
  }
  return(proto)
}

make_shape_list <- function(shape, api, path) {
  member <- shape$member
  proto <- list(make_shape(member, api, path))

  if (!is_empty(member$locationName)) {
    proto <- tag_add(proto, list(locationNameList = member$locationName))
  }

  return(proto)
}

make_shape_map <- function(shape, api, path) {
  key <- shape$key
  value <- shape$value
  proto <- list(make_shape(value, api, path))
  if (!is_empty(key$locationName)) {
    proto <- tag_add(proto, list(locationNameKey = key$locationName))
  }
  if (!is_empty(value$locationName)) {
    proto <- tag_add(proto, list(locationNameValue = value$locationName))
  }
  return(proto)
}

make_shape_scalar <- function(shape, api, path) {
  proto <- placeholder()
  return(proto)
}

# Convert a parameter name from an API-facing name (e.g. fooBar) to an
# SDK-facing name (e.g. FooBar).
make_export_name <- function(name) {
  export_name <- paste0(toupper(substring(name, 1, 1)), substring(name, 2))
  return(export_name)
}

# Return a list of a shape's elements that should be kept as tags, e.g. type.
make_tags <- function(shape) {
  if ("enum" %in% names(shape)) {
    shape$enum <- unlist(shape$enum)
  }
  taggable <- sapply(shape, is.atomic)
  ignore <- c("documentation", "shape")
  keep <- !(names(shape) %in% ignore)
  tags <- shape[taggable & keep]
  return(tags)
}

# A placeholder for data values in an AWS API shape.
placeholder <- function() {
  return(logical(0))
}

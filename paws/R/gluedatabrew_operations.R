# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include gluedatabrew_service.R
NULL

#' Deletes one or more versions of a recipe at a time
#'
#' @description
#' Deletes one or more versions of a recipe at a time.
#' 
#' The entire request will be rejected if:
#' 
#' -   The recipe does not exist.
#' 
#' -   There is an invalid version identifier in the list of versions.
#' 
#' -   The version list is empty.
#' 
#' -   The version list size exceeds 50.
#' 
#' -   The version list contains duplicate entries.
#' 
#' The request will complete successfully, but with partial failures, if:
#' 
#' -   A version does not exist.
#' 
#' -   A version is being used by a job.
#' 
#' -   You specify `LATEST_WORKING`, but it's being used by a project.
#' 
#' -   The version fails to be deleted.
#' 
#' The `LATEST_WORKING` version will only be deleted if the recipe has no
#' other versions. If you try to delete `LATEST_WORKING` while other
#' versions exist (or if they can't be deleted), then `LATEST_WORKING` will
#' be listed as partial failure in the response.
#'
#' @usage
#' gluedatabrew_batch_delete_recipe_version(Name, RecipeVersions)
#'
#' @param Name &#91;required&#93; The name of the recipe whose versions are to be deleted.
#' @param RecipeVersions &#91;required&#93; An array of version identifiers, for the recipe versions to be deleted.
#' You can specify numeric versions (`X.Y`) or `LATEST_WORKING`.
#' `LATEST_PUBLISHED` is not supported.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Errors = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string",
#'       RecipeVersion = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_recipe_version(
#'   Name = "string",
#'   RecipeVersions = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_batch_delete_recipe_version
gluedatabrew_batch_delete_recipe_version <- function(Name, RecipeVersions) {
  op <- new_operation(
    name = "BatchDeleteRecipeVersion",
    http_method = "POST",
    http_path = "/recipes/{name}/batchDeleteRecipeVersion",
    paginator = list()
  )
  input <- .gluedatabrew$batch_delete_recipe_version_input(Name = Name, RecipeVersions = RecipeVersions)
  output <- .gluedatabrew$batch_delete_recipe_version_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$batch_delete_recipe_version <- gluedatabrew_batch_delete_recipe_version

#' Creates a new DataBrew dataset
#'
#' @description
#' Creates a new DataBrew dataset.
#'
#' @usage
#' gluedatabrew_create_dataset(Name, Format, FormatOptions, Input,
#'   PathOptions, Tags)
#'
#' @param Name &#91;required&#93; The name of the dataset to be created. Valid characters are alphanumeric
#' (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
#' @param Format The file format of a dataset that is created from an Amazon S3 file or
#' folder.
#' @param FormatOptions 
#' @param Input &#91;required&#93; 
#' @param PathOptions A set of options that defines how DataBrew interprets an Amazon S3 path
#' of the dataset.
#' @param Tags Metadata tags to apply to this dataset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_dataset(
#'   Name = "string",
#'   Format = "CSV"|"JSON"|"PARQUET"|"EXCEL"|"ORC",
#'   FormatOptions = list(
#'     Json = list(
#'       MultiLine = TRUE|FALSE
#'     ),
#'     Excel = list(
#'       SheetNames = list(
#'         "string"
#'       ),
#'       SheetIndexes = list(
#'         123
#'       ),
#'       HeaderRow = TRUE|FALSE
#'     ),
#'     Csv = list(
#'       Delimiter = "string",
#'       HeaderRow = TRUE|FALSE
#'     )
#'   ),
#'   Input = list(
#'     S3InputDefinition = list(
#'       Bucket = "string",
#'       Key = "string",
#'       BucketOwner = "string"
#'     ),
#'     DataCatalogInputDefinition = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       )
#'     ),
#'     DatabaseInputDefinition = list(
#'       GlueConnectionName = "string",
#'       DatabaseTableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       QueryString = "string"
#'     ),
#'     Metadata = list(
#'       SourceArn = "string"
#'     )
#'   ),
#'   PathOptions = list(
#'     LastModifiedDateCondition = list(
#'       Expression = "string",
#'       ValuesMap = list(
#'         "string"
#'       )
#'     ),
#'     FilesLimit = list(
#'       MaxFiles = 123,
#'       OrderedBy = "LAST_MODIFIED_DATE",
#'       Order = "DESCENDING"|"ASCENDING"
#'     ),
#'     Parameters = list(
#'       list(
#'         Name = "string",
#'         Type = "Datetime"|"Number"|"String",
#'         DatetimeOptions = list(
#'           Format = "string",
#'           TimezoneOffset = "string",
#'           LocaleCode = "string"
#'         ),
#'         CreateColumn = TRUE|FALSE,
#'         Filter = list(
#'           Expression = "string",
#'           ValuesMap = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_dataset
gluedatabrew_create_dataset <- function(Name, Format = NULL, FormatOptions = NULL, Input, PathOptions = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateDataset",
    http_method = "POST",
    http_path = "/datasets",
    paginator = list()
  )
  input <- .gluedatabrew$create_dataset_input(Name = Name, Format = Format, FormatOptions = FormatOptions, Input = Input, PathOptions = PathOptions, Tags = Tags)
  output <- .gluedatabrew$create_dataset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_dataset <- gluedatabrew_create_dataset

#' Creates a new job to analyze a dataset and create its data profile
#'
#' @description
#' Creates a new job to analyze a dataset and create its data profile.
#'
#' @usage
#' gluedatabrew_create_profile_job(DatasetName, EncryptionKeyArn,
#'   EncryptionMode, Name, LogSubscription, MaxCapacity, MaxRetries,
#'   OutputLocation, Configuration, ValidationConfigurations, RoleArn, Tags,
#'   Timeout, JobSample)
#'
#' @param DatasetName &#91;required&#93; The name of the dataset that this job is to act upon.
#' @param EncryptionKeyArn The Amazon Resource Name (ARN) of an encryption key that is used to
#' protect the job.
#' @param EncryptionMode The encryption mode for the job, which can be one of the following:
#' 
#' -   `SSE-KMS` - `SSE-KMS` - Server-side encryption with KMS-managed
#'     keys.
#' 
#' -   `SSE-S3` - Server-side encryption with keys managed by Amazon S3.
#' @param Name &#91;required&#93; The name of the job to be created. Valid characters are alphanumeric
#' (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
#' @param LogSubscription Enables or disables Amazon CloudWatch logging for the job. If logging is
#' enabled, CloudWatch writes one log stream for each job run.
#' @param MaxCapacity The maximum number of nodes that DataBrew can use when the job processes
#' data.
#' @param MaxRetries The maximum number of times to retry the job after a job run fails.
#' @param OutputLocation &#91;required&#93; 
#' @param Configuration Configuration for profile jobs. Used to select columns, do evaluations,
#' and override default parameters of evaluations. When configuration is
#' null, the profile job will run with default settings.
#' @param ValidationConfigurations List of validation configurations that are applied to the profile job.
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the Identity and Access Management
#' (IAM) role to be assumed when DataBrew runs the job.
#' @param Tags Metadata tags to apply to this job.
#' @param Timeout The job's timeout in minutes. A job that attempts to run longer than
#' this timeout period ends with a status of `TIMEOUT`.
#' @param JobSample Sample configuration for profile jobs only. Determines the number of
#' rows on which the profile job will be executed. If a JobSample value is
#' not provided, the default value will be used. The default value is
#' CUSTOM_ROWS for the mode parameter and 20000 for the size parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_profile_job(
#'   DatasetName = "string",
#'   EncryptionKeyArn = "string",
#'   EncryptionMode = "SSE-KMS"|"SSE-S3",
#'   Name = "string",
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   MaxCapacity = 123,
#'   MaxRetries = 123,
#'   OutputLocation = list(
#'     Bucket = "string",
#'     Key = "string",
#'     BucketOwner = "string"
#'   ),
#'   Configuration = list(
#'     DatasetStatisticsConfiguration = list(
#'       IncludedStatistics = list(
#'         "string"
#'       ),
#'       Overrides = list(
#'         list(
#'           Statistic = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ProfileColumns = list(
#'       list(
#'         Regex = "string",
#'         Name = "string"
#'       )
#'     ),
#'     ColumnStatisticsConfigurations = list(
#'       list(
#'         Selectors = list(
#'           list(
#'             Regex = "string",
#'             Name = "string"
#'           )
#'         ),
#'         Statistics = list(
#'           IncludedStatistics = list(
#'             "string"
#'           ),
#'           Overrides = list(
#'             list(
#'               Statistic = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     EntityDetectorConfiguration = list(
#'       EntityTypes = list(
#'         "string"
#'       ),
#'       AllowedStatistics = list(
#'         list(
#'           Statistics = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ValidationConfigurations = list(
#'     list(
#'       RulesetArn = "string",
#'       ValidationMode = "CHECK_ALL"
#'     )
#'   ),
#'   RoleArn = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Timeout = 123,
#'   JobSample = list(
#'     Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'     Size = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_profile_job
gluedatabrew_create_profile_job <- function(DatasetName, EncryptionKeyArn = NULL, EncryptionMode = NULL, Name, LogSubscription = NULL, MaxCapacity = NULL, MaxRetries = NULL, OutputLocation, Configuration = NULL, ValidationConfigurations = NULL, RoleArn, Tags = NULL, Timeout = NULL, JobSample = NULL) {
  op <- new_operation(
    name = "CreateProfileJob",
    http_method = "POST",
    http_path = "/profileJobs",
    paginator = list()
  )
  input <- .gluedatabrew$create_profile_job_input(DatasetName = DatasetName, EncryptionKeyArn = EncryptionKeyArn, EncryptionMode = EncryptionMode, Name = Name, LogSubscription = LogSubscription, MaxCapacity = MaxCapacity, MaxRetries = MaxRetries, OutputLocation = OutputLocation, Configuration = Configuration, ValidationConfigurations = ValidationConfigurations, RoleArn = RoleArn, Tags = Tags, Timeout = Timeout, JobSample = JobSample)
  output <- .gluedatabrew$create_profile_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_profile_job <- gluedatabrew_create_profile_job

#' Creates a new DataBrew project
#'
#' @description
#' Creates a new DataBrew project.
#'
#' @usage
#' gluedatabrew_create_project(DatasetName, Name, RecipeName, Sample,
#'   RoleArn, Tags)
#'
#' @param DatasetName &#91;required&#93; The name of an existing dataset to associate this project with.
#' @param Name &#91;required&#93; A unique name for the new project. Valid characters are alphanumeric
#' (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
#' @param RecipeName &#91;required&#93; The name of an existing recipe to associate with the project.
#' @param Sample 
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the Identity and Access Management
#' (IAM) role to be assumed for this request.
#' @param Tags Metadata tags to apply to this project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_project(
#'   DatasetName = "string",
#'   Name = "string",
#'   RecipeName = "string",
#'   Sample = list(
#'     Size = 123,
#'     Type = "FIRST_N"|"LAST_N"|"RANDOM"
#'   ),
#'   RoleArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_project
gluedatabrew_create_project <- function(DatasetName, Name, RecipeName, Sample = NULL, RoleArn, Tags = NULL) {
  op <- new_operation(
    name = "CreateProject",
    http_method = "POST",
    http_path = "/projects",
    paginator = list()
  )
  input <- .gluedatabrew$create_project_input(DatasetName = DatasetName, Name = Name, RecipeName = RecipeName, Sample = Sample, RoleArn = RoleArn, Tags = Tags)
  output <- .gluedatabrew$create_project_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_project <- gluedatabrew_create_project

#' Creates a new DataBrew recipe
#'
#' @description
#' Creates a new DataBrew recipe.
#'
#' @usage
#' gluedatabrew_create_recipe(Description, Name, Steps, Tags)
#'
#' @param Description A description for the recipe.
#' @param Name &#91;required&#93; A unique name for the recipe. Valid characters are alphanumeric (A-Z,
#' a-z, 0-9), hyphen (-), period (.), and space.
#' @param Steps &#91;required&#93; An array containing the steps to be performed by the recipe. Each recipe
#' step consists of one recipe action and (optionally) an array of
#' condition expressions.
#' @param Tags Metadata tags to apply to this recipe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_recipe(
#'   Description = "string",
#'   Name = "string",
#'   Steps = list(
#'     list(
#'       Action = list(
#'         Operation = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       ConditionExpressions = list(
#'         list(
#'           Condition = "string",
#'           Value = "string",
#'           TargetColumn = "string"
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_recipe
gluedatabrew_create_recipe <- function(Description = NULL, Name, Steps, Tags = NULL) {
  op <- new_operation(
    name = "CreateRecipe",
    http_method = "POST",
    http_path = "/recipes",
    paginator = list()
  )
  input <- .gluedatabrew$create_recipe_input(Description = Description, Name = Name, Steps = Steps, Tags = Tags)
  output <- .gluedatabrew$create_recipe_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_recipe <- gluedatabrew_create_recipe

#' Creates a new job to transform input data, using steps defined in an
#' existing Glue DataBrew recipe
#'
#' @description
#' Creates a new job to transform input data, using steps defined in an
#' existing Glue DataBrew recipe
#'
#' @usage
#' gluedatabrew_create_recipe_job(DatasetName, EncryptionKeyArn,
#'   EncryptionMode, Name, LogSubscription, MaxCapacity, MaxRetries, Outputs,
#'   DataCatalogOutputs, DatabaseOutputs, ProjectName, RecipeReference,
#'   RoleArn, Tags, Timeout)
#'
#' @param DatasetName The name of the dataset that this job processes.
#' @param EncryptionKeyArn The Amazon Resource Name (ARN) of an encryption key that is used to
#' protect the job.
#' @param EncryptionMode The encryption mode for the job, which can be one of the following:
#' 
#' -   `SSE-KMS` - Server-side encryption with keys managed by KMS.
#' 
#' -   `SSE-S3` - Server-side encryption with keys managed by Amazon S3.
#' @param Name &#91;required&#93; A unique name for the job. Valid characters are alphanumeric (A-Z, a-z,
#' 0-9), hyphen (-), period (.), and space.
#' @param LogSubscription Enables or disables Amazon CloudWatch logging for the job. If logging is
#' enabled, CloudWatch writes one log stream for each job run.
#' @param MaxCapacity The maximum number of nodes that DataBrew can consume when the job
#' processes data.
#' @param MaxRetries The maximum number of times to retry the job after a job run fails.
#' @param Outputs One or more artifacts that represent the output from running the job.
#' @param DataCatalogOutputs One or more artifacts that represent the Glue Data Catalog output from
#' running the job.
#' @param DatabaseOutputs Represents a list of JDBC database output objects which defines the
#' output destination for a DataBrew recipe job to write to.
#' @param ProjectName Either the name of an existing project, or a combination of a recipe and
#' a dataset to associate with the recipe.
#' @param RecipeReference 
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the Identity and Access Management
#' (IAM) role to be assumed when DataBrew runs the job.
#' @param Tags Metadata tags to apply to this job.
#' @param Timeout The job's timeout in minutes. A job that attempts to run longer than
#' this timeout period ends with a status of `TIMEOUT`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_recipe_job(
#'   DatasetName = "string",
#'   EncryptionKeyArn = "string",
#'   EncryptionMode = "SSE-KMS"|"SSE-S3",
#'   Name = "string",
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   MaxCapacity = 123,
#'   MaxRetries = 123,
#'   Outputs = list(
#'     list(
#'       CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'       Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'       PartitionColumns = list(
#'         "string"
#'       ),
#'       Location = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       Overwrite = TRUE|FALSE,
#'       FormatOptions = list(
#'         Csv = list(
#'           Delimiter = "string"
#'         )
#'       ),
#'       MaxOutputFiles = 123
#'     )
#'   ),
#'   DataCatalogOutputs = list(
#'     list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       S3Options = list(
#'         Location = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         )
#'       ),
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       Overwrite = TRUE|FALSE
#'     )
#'   ),
#'   DatabaseOutputs = list(
#'     list(
#'       GlueConnectionName = "string",
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       DatabaseOutputMode = "NEW_TABLE"
#'     )
#'   ),
#'   ProjectName = "string",
#'   RecipeReference = list(
#'     Name = "string",
#'     RecipeVersion = "string"
#'   ),
#'   RoleArn = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Timeout = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_recipe_job
gluedatabrew_create_recipe_job <- function(DatasetName = NULL, EncryptionKeyArn = NULL, EncryptionMode = NULL, Name, LogSubscription = NULL, MaxCapacity = NULL, MaxRetries = NULL, Outputs = NULL, DataCatalogOutputs = NULL, DatabaseOutputs = NULL, ProjectName = NULL, RecipeReference = NULL, RoleArn, Tags = NULL, Timeout = NULL) {
  op <- new_operation(
    name = "CreateRecipeJob",
    http_method = "POST",
    http_path = "/recipeJobs",
    paginator = list()
  )
  input <- .gluedatabrew$create_recipe_job_input(DatasetName = DatasetName, EncryptionKeyArn = EncryptionKeyArn, EncryptionMode = EncryptionMode, Name = Name, LogSubscription = LogSubscription, MaxCapacity = MaxCapacity, MaxRetries = MaxRetries, Outputs = Outputs, DataCatalogOutputs = DataCatalogOutputs, DatabaseOutputs = DatabaseOutputs, ProjectName = ProjectName, RecipeReference = RecipeReference, RoleArn = RoleArn, Tags = Tags, Timeout = Timeout)
  output <- .gluedatabrew$create_recipe_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_recipe_job <- gluedatabrew_create_recipe_job

#' Creates a new ruleset that can be used in a profile job to validate the
#' data quality of a dataset
#'
#' @description
#' Creates a new ruleset that can be used in a profile job to validate the
#' data quality of a dataset.
#'
#' @usage
#' gluedatabrew_create_ruleset(Name, Description, TargetArn, Rules, Tags)
#'
#' @param Name &#91;required&#93; The name of the ruleset to be created. Valid characters are alphanumeric
#' (A-Z, a-z, 0-9), hyphen (-), period (.), and space.
#' @param Description The description of the ruleset.
#' @param TargetArn &#91;required&#93; The Amazon Resource Name (ARN) of a resource (dataset) that the ruleset
#' is associated with.
#' @param Rules &#91;required&#93; A list of rules that are defined with the ruleset. A rule includes one
#' or more checks to be validated on a DataBrew dataset.
#' @param Tags Metadata tags to apply to the ruleset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_ruleset(
#'   Name = "string",
#'   Description = "string",
#'   TargetArn = "string",
#'   Rules = list(
#'     list(
#'       Name = "string",
#'       Disabled = TRUE|FALSE,
#'       CheckExpression = "string",
#'       SubstitutionMap = list(
#'         "string"
#'       ),
#'       Threshold = list(
#'         Value = 123.0,
#'         Type = "GREATER_THAN_OR_EQUAL"|"LESS_THAN_OR_EQUAL"|"GREATER_THAN"|"LESS_THAN",
#'         Unit = "COUNT"|"PERCENTAGE"
#'       ),
#'       ColumnSelectors = list(
#'         list(
#'           Regex = "string",
#'           Name = "string"
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_ruleset
gluedatabrew_create_ruleset <- function(Name, Description = NULL, TargetArn, Rules, Tags = NULL) {
  op <- new_operation(
    name = "CreateRuleset",
    http_method = "POST",
    http_path = "/rulesets",
    paginator = list()
  )
  input <- .gluedatabrew$create_ruleset_input(Name = Name, Description = Description, TargetArn = TargetArn, Rules = Rules, Tags = Tags)
  output <- .gluedatabrew$create_ruleset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_ruleset <- gluedatabrew_create_ruleset

#' Creates a new schedule for one or more DataBrew jobs
#'
#' @description
#' Creates a new schedule for one or more DataBrew jobs. Jobs can be run at
#' a specific date and time, or at regular intervals.
#'
#' @usage
#' gluedatabrew_create_schedule(JobNames, CronExpression, Tags, Name)
#'
#' @param JobNames The name or names of one or more jobs to be run.
#' @param CronExpression &#91;required&#93; The date or dates and time or times when the jobs are to be run. For
#' more information, see [Cron
#' expressions](https://docs.aws.amazon.com/databrew/latest/dg/) in the
#' *Glue DataBrew Developer Guide*.
#' @param Tags Metadata tags to apply to this schedule.
#' @param Name &#91;required&#93; A unique name for the schedule. Valid characters are alphanumeric (A-Z,
#' a-z, 0-9), hyphen (-), period (.), and space.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_schedule(
#'   JobNames = list(
#'     "string"
#'   ),
#'   CronExpression = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_create_schedule
gluedatabrew_create_schedule <- function(JobNames = NULL, CronExpression, Tags = NULL, Name) {
  op <- new_operation(
    name = "CreateSchedule",
    http_method = "POST",
    http_path = "/schedules",
    paginator = list()
  )
  input <- .gluedatabrew$create_schedule_input(JobNames = JobNames, CronExpression = CronExpression, Tags = Tags, Name = Name)
  output <- .gluedatabrew$create_schedule_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$create_schedule <- gluedatabrew_create_schedule

#' Deletes a dataset from DataBrew
#'
#' @description
#' Deletes a dataset from DataBrew.
#'
#' @usage
#' gluedatabrew_delete_dataset(Name)
#'
#' @param Name &#91;required&#93; The name of the dataset to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_dataset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_dataset
gluedatabrew_delete_dataset <- function(Name) {
  op <- new_operation(
    name = "DeleteDataset",
    http_method = "DELETE",
    http_path = "/datasets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_dataset_input(Name = Name)
  output <- .gluedatabrew$delete_dataset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_dataset <- gluedatabrew_delete_dataset

#' Deletes the specified DataBrew job
#'
#' @description
#' Deletes the specified DataBrew job.
#'
#' @usage
#' gluedatabrew_delete_job(Name)
#'
#' @param Name &#91;required&#93; The name of the job to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_job
gluedatabrew_delete_job <- function(Name) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "DELETE",
    http_path = "/jobs/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_job_input(Name = Name)
  output <- .gluedatabrew$delete_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_job <- gluedatabrew_delete_job

#' Deletes an existing DataBrew project
#'
#' @description
#' Deletes an existing DataBrew project.
#'
#' @usage
#' gluedatabrew_delete_project(Name)
#'
#' @param Name &#91;required&#93; The name of the project to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_project(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_project
gluedatabrew_delete_project <- function(Name) {
  op <- new_operation(
    name = "DeleteProject",
    http_method = "DELETE",
    http_path = "/projects/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_project_input(Name = Name)
  output <- .gluedatabrew$delete_project_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_project <- gluedatabrew_delete_project

#' Deletes a single version of a DataBrew recipe
#'
#' @description
#' Deletes a single version of a DataBrew recipe.
#'
#' @usage
#' gluedatabrew_delete_recipe_version(Name, RecipeVersion)
#'
#' @param Name &#91;required&#93; The name of the recipe.
#' @param RecipeVersion &#91;required&#93; The version of the recipe to be deleted. You can specify a numeric
#' versions (`X.Y`) or `LATEST_WORKING`. `LATEST_PUBLISHED` is not
#' supported.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   RecipeVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_recipe_version(
#'   Name = "string",
#'   RecipeVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_recipe_version
gluedatabrew_delete_recipe_version <- function(Name, RecipeVersion) {
  op <- new_operation(
    name = "DeleteRecipeVersion",
    http_method = "DELETE",
    http_path = "/recipes/{name}/recipeVersion/{recipeVersion}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_recipe_version_input(Name = Name, RecipeVersion = RecipeVersion)
  output <- .gluedatabrew$delete_recipe_version_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_recipe_version <- gluedatabrew_delete_recipe_version

#' Deletes a ruleset
#'
#' @description
#' Deletes a ruleset.
#'
#' @usage
#' gluedatabrew_delete_ruleset(Name)
#'
#' @param Name &#91;required&#93; The name of the ruleset to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_ruleset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_ruleset
gluedatabrew_delete_ruleset <- function(Name) {
  op <- new_operation(
    name = "DeleteRuleset",
    http_method = "DELETE",
    http_path = "/rulesets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_ruleset_input(Name = Name)
  output <- .gluedatabrew$delete_ruleset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_ruleset <- gluedatabrew_delete_ruleset

#' Deletes the specified DataBrew schedule
#'
#' @description
#' Deletes the specified DataBrew schedule.
#'
#' @usage
#' gluedatabrew_delete_schedule(Name)
#'
#' @param Name &#91;required&#93; The name of the schedule to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_schedule(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_delete_schedule
gluedatabrew_delete_schedule <- function(Name) {
  op <- new_operation(
    name = "DeleteSchedule",
    http_method = "DELETE",
    http_path = "/schedules/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$delete_schedule_input(Name = Name)
  output <- .gluedatabrew$delete_schedule_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$delete_schedule <- gluedatabrew_delete_schedule

#' Returns the definition of a specific DataBrew dataset
#'
#' @description
#' Returns the definition of a specific DataBrew dataset.
#'
#' @usage
#' gluedatabrew_describe_dataset(Name)
#'
#' @param Name &#91;required&#93; The name of the dataset to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreatedBy = "string",
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Name = "string",
#'   Format = "CSV"|"JSON"|"PARQUET"|"EXCEL"|"ORC",
#'   FormatOptions = list(
#'     Json = list(
#'       MultiLine = TRUE|FALSE
#'     ),
#'     Excel = list(
#'       SheetNames = list(
#'         "string"
#'       ),
#'       SheetIndexes = list(
#'         123
#'       ),
#'       HeaderRow = TRUE|FALSE
#'     ),
#'     Csv = list(
#'       Delimiter = "string",
#'       HeaderRow = TRUE|FALSE
#'     )
#'   ),
#'   Input = list(
#'     S3InputDefinition = list(
#'       Bucket = "string",
#'       Key = "string",
#'       BucketOwner = "string"
#'     ),
#'     DataCatalogInputDefinition = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       )
#'     ),
#'     DatabaseInputDefinition = list(
#'       GlueConnectionName = "string",
#'       DatabaseTableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       QueryString = "string"
#'     ),
#'     Metadata = list(
#'       SourceArn = "string"
#'     )
#'   ),
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedBy = "string",
#'   Source = "S3"|"DATA-CATALOG"|"DATABASE",
#'   PathOptions = list(
#'     LastModifiedDateCondition = list(
#'       Expression = "string",
#'       ValuesMap = list(
#'         "string"
#'       )
#'     ),
#'     FilesLimit = list(
#'       MaxFiles = 123,
#'       OrderedBy = "LAST_MODIFIED_DATE",
#'       Order = "DESCENDING"|"ASCENDING"
#'     ),
#'     Parameters = list(
#'       list(
#'         Name = "string",
#'         Type = "Datetime"|"Number"|"String",
#'         DatetimeOptions = list(
#'           Format = "string",
#'           TimezoneOffset = "string",
#'           LocaleCode = "string"
#'         ),
#'         CreateColumn = TRUE|FALSE,
#'         Filter = list(
#'           Expression = "string",
#'           ValuesMap = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   ),
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_dataset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_dataset
gluedatabrew_describe_dataset <- function(Name) {
  op <- new_operation(
    name = "DescribeDataset",
    http_method = "GET",
    http_path = "/datasets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_dataset_input(Name = Name)
  output <- .gluedatabrew$describe_dataset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_dataset <- gluedatabrew_describe_dataset

#' Returns the definition of a specific DataBrew job
#'
#' @description
#' Returns the definition of a specific DataBrew job.
#'
#' @usage
#' gluedatabrew_describe_job(Name)
#'
#' @param Name &#91;required&#93; The name of the job to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CreatedBy = "string",
#'   DatasetName = "string",
#'   EncryptionKeyArn = "string",
#'   EncryptionMode = "SSE-KMS"|"SSE-S3",
#'   Name = "string",
#'   Type = "PROFILE"|"RECIPE",
#'   LastModifiedBy = "string",
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   MaxCapacity = 123,
#'   MaxRetries = 123,
#'   Outputs = list(
#'     list(
#'       CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'       Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'       PartitionColumns = list(
#'         "string"
#'       ),
#'       Location = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       Overwrite = TRUE|FALSE,
#'       FormatOptions = list(
#'         Csv = list(
#'           Delimiter = "string"
#'         )
#'       ),
#'       MaxOutputFiles = 123
#'     )
#'   ),
#'   DataCatalogOutputs = list(
#'     list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       S3Options = list(
#'         Location = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         )
#'       ),
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       Overwrite = TRUE|FALSE
#'     )
#'   ),
#'   DatabaseOutputs = list(
#'     list(
#'       GlueConnectionName = "string",
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       DatabaseOutputMode = "NEW_TABLE"
#'     )
#'   ),
#'   ProjectName = "string",
#'   ProfileConfiguration = list(
#'     DatasetStatisticsConfiguration = list(
#'       IncludedStatistics = list(
#'         "string"
#'       ),
#'       Overrides = list(
#'         list(
#'           Statistic = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ProfileColumns = list(
#'       list(
#'         Regex = "string",
#'         Name = "string"
#'       )
#'     ),
#'     ColumnStatisticsConfigurations = list(
#'       list(
#'         Selectors = list(
#'           list(
#'             Regex = "string",
#'             Name = "string"
#'           )
#'         ),
#'         Statistics = list(
#'           IncludedStatistics = list(
#'             "string"
#'           ),
#'           Overrides = list(
#'             list(
#'               Statistic = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     EntityDetectorConfiguration = list(
#'       EntityTypes = list(
#'         "string"
#'       ),
#'       AllowedStatistics = list(
#'         list(
#'           Statistics = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ValidationConfigurations = list(
#'     list(
#'       RulesetArn = "string",
#'       ValidationMode = "CHECK_ALL"
#'     )
#'   ),
#'   RecipeReference = list(
#'     Name = "string",
#'     RecipeVersion = "string"
#'   ),
#'   ResourceArn = "string",
#'   RoleArn = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Timeout = 123,
#'   JobSample = list(
#'     Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'     Size = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_job
gluedatabrew_describe_job <- function(Name) {
  op <- new_operation(
    name = "DescribeJob",
    http_method = "GET",
    http_path = "/jobs/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_job_input(Name = Name)
  output <- .gluedatabrew$describe_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_job <- gluedatabrew_describe_job

#' Represents one run of a DataBrew job
#'
#' @description
#' Represents one run of a DataBrew job.
#'
#' @usage
#' gluedatabrew_describe_job_run(Name, RunId)
#'
#' @param Name &#91;required&#93; The name of the job being processed during this run.
#' @param RunId &#91;required&#93; The unique identifier of the job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Attempt = 123,
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   DatasetName = "string",
#'   ErrorMessage = "string",
#'   ExecutionTime = 123,
#'   JobName = "string",
#'   ProfileConfiguration = list(
#'     DatasetStatisticsConfiguration = list(
#'       IncludedStatistics = list(
#'         "string"
#'       ),
#'       Overrides = list(
#'         list(
#'           Statistic = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ProfileColumns = list(
#'       list(
#'         Regex = "string",
#'         Name = "string"
#'       )
#'     ),
#'     ColumnStatisticsConfigurations = list(
#'       list(
#'         Selectors = list(
#'           list(
#'             Regex = "string",
#'             Name = "string"
#'           )
#'         ),
#'         Statistics = list(
#'           IncludedStatistics = list(
#'             "string"
#'           ),
#'           Overrides = list(
#'             list(
#'               Statistic = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     EntityDetectorConfiguration = list(
#'       EntityTypes = list(
#'         "string"
#'       ),
#'       AllowedStatistics = list(
#'         list(
#'           Statistics = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ValidationConfigurations = list(
#'     list(
#'       RulesetArn = "string",
#'       ValidationMode = "CHECK_ALL"
#'     )
#'   ),
#'   RunId = "string",
#'   State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   LogGroupName = "string",
#'   Outputs = list(
#'     list(
#'       CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'       Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'       PartitionColumns = list(
#'         "string"
#'       ),
#'       Location = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       Overwrite = TRUE|FALSE,
#'       FormatOptions = list(
#'         Csv = list(
#'           Delimiter = "string"
#'         )
#'       ),
#'       MaxOutputFiles = 123
#'     )
#'   ),
#'   DataCatalogOutputs = list(
#'     list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       S3Options = list(
#'         Location = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         )
#'       ),
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       Overwrite = TRUE|FALSE
#'     )
#'   ),
#'   DatabaseOutputs = list(
#'     list(
#'       GlueConnectionName = "string",
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       DatabaseOutputMode = "NEW_TABLE"
#'     )
#'   ),
#'   RecipeReference = list(
#'     Name = "string",
#'     RecipeVersion = "string"
#'   ),
#'   StartedBy = "string",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   JobSample = list(
#'     Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'     Size = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_run(
#'   Name = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_job_run
gluedatabrew_describe_job_run <- function(Name, RunId) {
  op <- new_operation(
    name = "DescribeJobRun",
    http_method = "GET",
    http_path = "/jobs/{name}/jobRun/{runId}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_job_run_input(Name = Name, RunId = RunId)
  output <- .gluedatabrew$describe_job_run_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_job_run <- gluedatabrew_describe_job_run

#' Returns the definition of a specific DataBrew project
#'
#' @description
#' Returns the definition of a specific DataBrew project.
#'
#' @usage
#' gluedatabrew_describe_project(Name)
#'
#' @param Name &#91;required&#93; The name of the project to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CreatedBy = "string",
#'   DatasetName = "string",
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedBy = "string",
#'   Name = "string",
#'   RecipeName = "string",
#'   ResourceArn = "string",
#'   Sample = list(
#'     Size = 123,
#'     Type = "FIRST_N"|"LAST_N"|"RANDOM"
#'   ),
#'   RoleArn = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   SessionStatus = "ASSIGNED"|"FAILED"|"INITIALIZING"|"PROVISIONING"|"READY"|"RECYCLING"|"ROTATING"|"TERMINATED"|"TERMINATING"|"UPDATING",
#'   OpenedBy = "string",
#'   OpenDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_project(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_project
gluedatabrew_describe_project <- function(Name) {
  op <- new_operation(
    name = "DescribeProject",
    http_method = "GET",
    http_path = "/projects/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_project_input(Name = Name)
  output <- .gluedatabrew$describe_project_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_project <- gluedatabrew_describe_project

#' Returns the definition of a specific DataBrew recipe corresponding to a
#' particular version
#'
#' @description
#' Returns the definition of a specific DataBrew recipe corresponding to a
#' particular version.
#'
#' @usage
#' gluedatabrew_describe_recipe(Name, RecipeVersion)
#'
#' @param Name &#91;required&#93; The name of the recipe to be described.
#' @param RecipeVersion The recipe version identifier. If this parameter isn't specified, then
#' the latest published version is returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreatedBy = "string",
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedBy = "string",
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ProjectName = "string",
#'   PublishedBy = "string",
#'   PublishedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   Name = "string",
#'   Steps = list(
#'     list(
#'       Action = list(
#'         Operation = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       ConditionExpressions = list(
#'         list(
#'           Condition = "string",
#'           Value = "string",
#'           TargetColumn = "string"
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   ),
#'   ResourceArn = "string",
#'   RecipeVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_recipe(
#'   Name = "string",
#'   RecipeVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_recipe
gluedatabrew_describe_recipe <- function(Name, RecipeVersion = NULL) {
  op <- new_operation(
    name = "DescribeRecipe",
    http_method = "GET",
    http_path = "/recipes/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_recipe_input(Name = Name, RecipeVersion = RecipeVersion)
  output <- .gluedatabrew$describe_recipe_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_recipe <- gluedatabrew_describe_recipe

#' Retrieves detailed information about the ruleset
#'
#' @description
#' Retrieves detailed information about the ruleset.
#'
#' @usage
#' gluedatabrew_describe_ruleset(Name)
#'
#' @param Name &#91;required&#93; The name of the ruleset to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Description = "string",
#'   TargetArn = "string",
#'   Rules = list(
#'     list(
#'       Name = "string",
#'       Disabled = TRUE|FALSE,
#'       CheckExpression = "string",
#'       SubstitutionMap = list(
#'         "string"
#'       ),
#'       Threshold = list(
#'         Value = 123.0,
#'         Type = "GREATER_THAN_OR_EQUAL"|"LESS_THAN_OR_EQUAL"|"GREATER_THAN"|"LESS_THAN",
#'         Unit = "COUNT"|"PERCENTAGE"
#'       ),
#'       ColumnSelectors = list(
#'         list(
#'           Regex = "string",
#'           Name = "string"
#'         )
#'       )
#'     )
#'   ),
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CreatedBy = "string",
#'   LastModifiedBy = "string",
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ResourceArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_ruleset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_ruleset
gluedatabrew_describe_ruleset <- function(Name) {
  op <- new_operation(
    name = "DescribeRuleset",
    http_method = "GET",
    http_path = "/rulesets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_ruleset_input(Name = Name)
  output <- .gluedatabrew$describe_ruleset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_ruleset <- gluedatabrew_describe_ruleset

#' Returns the definition of a specific DataBrew schedule
#'
#' @description
#' Returns the definition of a specific DataBrew schedule.
#'
#' @usage
#' gluedatabrew_describe_schedule(Name)
#'
#' @param Name &#91;required&#93; The name of the schedule to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreateDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CreatedBy = "string",
#'   JobNames = list(
#'     "string"
#'   ),
#'   LastModifiedBy = "string",
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ResourceArn = "string",
#'   CronExpression = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_schedule(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_describe_schedule
gluedatabrew_describe_schedule <- function(Name) {
  op <- new_operation(
    name = "DescribeSchedule",
    http_method = "GET",
    http_path = "/schedules/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$describe_schedule_input(Name = Name)
  output <- .gluedatabrew$describe_schedule_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$describe_schedule <- gluedatabrew_describe_schedule

#' Lists all of the DataBrew datasets
#'
#' @description
#' Lists all of the DataBrew datasets.
#'
#' @usage
#' gluedatabrew_list_datasets(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Datasets = list(
#'     list(
#'       AccountId = "string",
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Name = "string",
#'       Format = "CSV"|"JSON"|"PARQUET"|"EXCEL"|"ORC",
#'       FormatOptions = list(
#'         Json = list(
#'           MultiLine = TRUE|FALSE
#'         ),
#'         Excel = list(
#'           SheetNames = list(
#'             "string"
#'           ),
#'           SheetIndexes = list(
#'             123
#'           ),
#'           HeaderRow = TRUE|FALSE
#'         ),
#'         Csv = list(
#'           Delimiter = "string",
#'           HeaderRow = TRUE|FALSE
#'         )
#'       ),
#'       Input = list(
#'         S3InputDefinition = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         DataCatalogInputDefinition = list(
#'           CatalogId = "string",
#'           DatabaseName = "string",
#'           TableName = "string",
#'           TempDirectory = list(
#'             Bucket = "string",
#'             Key = "string",
#'             BucketOwner = "string"
#'           )
#'         ),
#'         DatabaseInputDefinition = list(
#'           GlueConnectionName = "string",
#'           DatabaseTableName = "string",
#'           TempDirectory = list(
#'             Bucket = "string",
#'             Key = "string",
#'             BucketOwner = "string"
#'           ),
#'           QueryString = "string"
#'         ),
#'         Metadata = list(
#'           SourceArn = "string"
#'         )
#'       ),
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedBy = "string",
#'       Source = "S3"|"DATA-CATALOG"|"DATABASE",
#'       PathOptions = list(
#'         LastModifiedDateCondition = list(
#'           Expression = "string",
#'           ValuesMap = list(
#'             "string"
#'           )
#'         ),
#'         FilesLimit = list(
#'           MaxFiles = 123,
#'           OrderedBy = "LAST_MODIFIED_DATE",
#'           Order = "DESCENDING"|"ASCENDING"
#'         ),
#'         Parameters = list(
#'           list(
#'             Name = "string",
#'             Type = "Datetime"|"Number"|"String",
#'             DatetimeOptions = list(
#'               Format = "string",
#'               TimezoneOffset = "string",
#'               LocaleCode = "string"
#'             ),
#'             CreateColumn = TRUE|FALSE,
#'             Filter = list(
#'               Expression = "string",
#'               ValuesMap = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       ResourceArn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_datasets(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_datasets
gluedatabrew_list_datasets <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListDatasets",
    http_method = "GET",
    http_path = "/datasets",
    paginator = list()
  )
  input <- .gluedatabrew$list_datasets_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .gluedatabrew$list_datasets_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_datasets <- gluedatabrew_list_datasets

#' Lists all of the previous runs of a particular DataBrew job
#'
#' @description
#' Lists all of the previous runs of a particular DataBrew job.
#'
#' @usage
#' gluedatabrew_list_job_runs(Name, MaxResults, NextToken)
#'
#' @param Name &#91;required&#93; The name of the job.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobRuns = list(
#'     list(
#'       Attempt = 123,
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       DatasetName = "string",
#'       ErrorMessage = "string",
#'       ExecutionTime = 123,
#'       JobName = "string",
#'       RunId = "string",
#'       State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'       LogSubscription = "ENABLE"|"DISABLE",
#'       LogGroupName = "string",
#'       Outputs = list(
#'         list(
#'           CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'           Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'           PartitionColumns = list(
#'             "string"
#'           ),
#'           Location = list(
#'             Bucket = "string",
#'             Key = "string",
#'             BucketOwner = "string"
#'           ),
#'           Overwrite = TRUE|FALSE,
#'           FormatOptions = list(
#'             Csv = list(
#'               Delimiter = "string"
#'             )
#'           ),
#'           MaxOutputFiles = 123
#'         )
#'       ),
#'       DataCatalogOutputs = list(
#'         list(
#'           CatalogId = "string",
#'           DatabaseName = "string",
#'           TableName = "string",
#'           S3Options = list(
#'             Location = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             )
#'           ),
#'           DatabaseOptions = list(
#'             TempDirectory = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             ),
#'             TableName = "string"
#'           ),
#'           Overwrite = TRUE|FALSE
#'         )
#'       ),
#'       DatabaseOutputs = list(
#'         list(
#'           GlueConnectionName = "string",
#'           DatabaseOptions = list(
#'             TempDirectory = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             ),
#'             TableName = "string"
#'           ),
#'           DatabaseOutputMode = "NEW_TABLE"
#'         )
#'       ),
#'       RecipeReference = list(
#'         Name = "string",
#'         RecipeVersion = "string"
#'       ),
#'       StartedBy = "string",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       JobSample = list(
#'         Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'         Size = 123
#'       ),
#'       ValidationConfigurations = list(
#'         list(
#'           RulesetArn = "string",
#'           ValidationMode = "CHECK_ALL"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   Name = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_job_runs
gluedatabrew_list_job_runs <- function(Name, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/jobs/{name}/jobRuns",
    paginator = list()
  )
  input <- .gluedatabrew$list_job_runs_input(Name = Name, MaxResults = MaxResults, NextToken = NextToken)
  output <- .gluedatabrew$list_job_runs_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_job_runs <- gluedatabrew_list_job_runs

#' Lists all of the DataBrew jobs that are defined
#'
#' @description
#' Lists all of the DataBrew jobs that are defined.
#'
#' @usage
#' gluedatabrew_list_jobs(DatasetName, MaxResults, NextToken, ProjectName)
#'
#' @param DatasetName The name of a dataset. Using this parameter indicates to return only
#' those jobs that act on the specified dataset.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken A token generated by DataBrew that specifies where to continue
#' pagination if a previous request was truncated. To get the next set of
#' pages, pass in the NextToken value from the response object of the
#' previous page call.
#' @param ProjectName The name of a project. Using this parameter indicates to return only
#' those jobs that are associated with the specified project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Jobs = list(
#'     list(
#'       AccountId = "string",
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       DatasetName = "string",
#'       EncryptionKeyArn = "string",
#'       EncryptionMode = "SSE-KMS"|"SSE-S3",
#'       Name = "string",
#'       Type = "PROFILE"|"RECIPE",
#'       LastModifiedBy = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LogSubscription = "ENABLE"|"DISABLE",
#'       MaxCapacity = 123,
#'       MaxRetries = 123,
#'       Outputs = list(
#'         list(
#'           CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'           Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'           PartitionColumns = list(
#'             "string"
#'           ),
#'           Location = list(
#'             Bucket = "string",
#'             Key = "string",
#'             BucketOwner = "string"
#'           ),
#'           Overwrite = TRUE|FALSE,
#'           FormatOptions = list(
#'             Csv = list(
#'               Delimiter = "string"
#'             )
#'           ),
#'           MaxOutputFiles = 123
#'         )
#'       ),
#'       DataCatalogOutputs = list(
#'         list(
#'           CatalogId = "string",
#'           DatabaseName = "string",
#'           TableName = "string",
#'           S3Options = list(
#'             Location = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             )
#'           ),
#'           DatabaseOptions = list(
#'             TempDirectory = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             ),
#'             TableName = "string"
#'           ),
#'           Overwrite = TRUE|FALSE
#'         )
#'       ),
#'       DatabaseOutputs = list(
#'         list(
#'           GlueConnectionName = "string",
#'           DatabaseOptions = list(
#'             TempDirectory = list(
#'               Bucket = "string",
#'               Key = "string",
#'               BucketOwner = "string"
#'             ),
#'             TableName = "string"
#'           ),
#'           DatabaseOutputMode = "NEW_TABLE"
#'         )
#'       ),
#'       ProjectName = "string",
#'       RecipeReference = list(
#'         Name = "string",
#'         RecipeVersion = "string"
#'       ),
#'       ResourceArn = "string",
#'       RoleArn = "string",
#'       Timeout = 123,
#'       Tags = list(
#'         "string"
#'       ),
#'       JobSample = list(
#'         Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'         Size = 123
#'       ),
#'       ValidationConfigurations = list(
#'         list(
#'           RulesetArn = "string",
#'           ValidationMode = "CHECK_ALL"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_jobs(
#'   DatasetName = "string",
#'   MaxResults = 123,
#'   NextToken = "string",
#'   ProjectName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_jobs
gluedatabrew_list_jobs <- function(DatasetName = NULL, MaxResults = NULL, NextToken = NULL, ProjectName = NULL) {
  op <- new_operation(
    name = "ListJobs",
    http_method = "GET",
    http_path = "/jobs",
    paginator = list()
  )
  input <- .gluedatabrew$list_jobs_input(DatasetName = DatasetName, MaxResults = MaxResults, NextToken = NextToken, ProjectName = ProjectName)
  output <- .gluedatabrew$list_jobs_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_jobs <- gluedatabrew_list_jobs

#' Lists all of the DataBrew projects that are defined
#'
#' @description
#' Lists all of the DataBrew projects that are defined.
#'
#' @usage
#' gluedatabrew_list_projects(NextToken, MaxResults)
#'
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#' @param MaxResults The maximum number of results to return in this request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Projects = list(
#'     list(
#'       AccountId = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CreatedBy = "string",
#'       DatasetName = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedBy = "string",
#'       Name = "string",
#'       RecipeName = "string",
#'       ResourceArn = "string",
#'       Sample = list(
#'         Size = 123,
#'         Type = "FIRST_N"|"LAST_N"|"RANDOM"
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       RoleArn = "string",
#'       OpenedBy = "string",
#'       OpenDate = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_projects(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_projects
gluedatabrew_list_projects <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListProjects",
    http_method = "GET",
    http_path = "/projects",
    paginator = list()
  )
  input <- .gluedatabrew$list_projects_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .gluedatabrew$list_projects_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_projects <- gluedatabrew_list_projects

#' Lists the versions of a particular DataBrew recipe, except for
#' LATEST_WORKING
#'
#' @description
#' Lists the versions of a particular DataBrew recipe, except for
#' `LATEST_WORKING`.
#'
#' @usage
#' gluedatabrew_list_recipe_versions(MaxResults, NextToken, Name)
#'
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#' @param Name &#91;required&#93; The name of the recipe for which to return version information.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Recipes = list(
#'     list(
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedBy = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ProjectName = "string",
#'       PublishedBy = "string",
#'       PublishedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       Name = "string",
#'       ResourceArn = "string",
#'       Steps = list(
#'         list(
#'           Action = list(
#'             Operation = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           ),
#'           ConditionExpressions = list(
#'             list(
#'               Condition = "string",
#'               Value = "string",
#'               TargetColumn = "string"
#'             )
#'           )
#'         )
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       RecipeVersion = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_recipe_versions(
#'   MaxResults = 123,
#'   NextToken = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_recipe_versions
gluedatabrew_list_recipe_versions <- function(MaxResults = NULL, NextToken = NULL, Name) {
  op <- new_operation(
    name = "ListRecipeVersions",
    http_method = "GET",
    http_path = "/recipeVersions",
    paginator = list()
  )
  input <- .gluedatabrew$list_recipe_versions_input(MaxResults = MaxResults, NextToken = NextToken, Name = Name)
  output <- .gluedatabrew$list_recipe_versions_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_recipe_versions <- gluedatabrew_list_recipe_versions

#' Lists all of the DataBrew recipes that are defined
#'
#' @description
#' Lists all of the DataBrew recipes that are defined.
#'
#' @usage
#' gluedatabrew_list_recipes(MaxResults, NextToken, RecipeVersion)
#'
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#' @param RecipeVersion Return only those recipes with a version identifier of `LATEST_WORKING`
#' or `LATEST_PUBLISHED`. If `RecipeVersion` is omitted,
#' [`list_recipes`][gluedatabrew_list_recipes] returns all of the
#' `LATEST_PUBLISHED` recipe versions.
#' 
#' Valid values: `LATEST_WORKING` | `LATEST_PUBLISHED`
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Recipes = list(
#'     list(
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedBy = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ProjectName = "string",
#'       PublishedBy = "string",
#'       PublishedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       Name = "string",
#'       ResourceArn = "string",
#'       Steps = list(
#'         list(
#'           Action = list(
#'             Operation = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           ),
#'           ConditionExpressions = list(
#'             list(
#'               Condition = "string",
#'               Value = "string",
#'               TargetColumn = "string"
#'             )
#'           )
#'         )
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       RecipeVersion = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_recipes(
#'   MaxResults = 123,
#'   NextToken = "string",
#'   RecipeVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_recipes
gluedatabrew_list_recipes <- function(MaxResults = NULL, NextToken = NULL, RecipeVersion = NULL) {
  op <- new_operation(
    name = "ListRecipes",
    http_method = "GET",
    http_path = "/recipes",
    paginator = list()
  )
  input <- .gluedatabrew$list_recipes_input(MaxResults = MaxResults, NextToken = NextToken, RecipeVersion = RecipeVersion)
  output <- .gluedatabrew$list_recipes_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_recipes <- gluedatabrew_list_recipes

#' List all rulesets available in the current account or rulesets
#' associated with a specific resource (dataset)
#'
#' @description
#' List all rulesets available in the current account or rulesets
#' associated with a specific resource (dataset).
#'
#' @usage
#' gluedatabrew_list_rulesets(TargetArn, MaxResults, NextToken)
#'
#' @param TargetArn The Amazon Resource Name (ARN) of a resource (dataset). Using this
#' parameter indicates to return only those rulesets that are associated
#' with the specified resource.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken A token generated by DataBrew that specifies where to continue
#' pagination if a previous request was truncated. To get the next set of
#' pages, pass in the NextToken value from the response object of the
#' previous page call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Rulesets = list(
#'     list(
#'       AccountId = "string",
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       LastModifiedBy = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Name = "string",
#'       ResourceArn = "string",
#'       RuleCount = 123,
#'       Tags = list(
#'         "string"
#'       ),
#'       TargetArn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_rulesets(
#'   TargetArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_rulesets
gluedatabrew_list_rulesets <- function(TargetArn = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListRulesets",
    http_method = "GET",
    http_path = "/rulesets",
    paginator = list()
  )
  input <- .gluedatabrew$list_rulesets_input(TargetArn = TargetArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .gluedatabrew$list_rulesets_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_rulesets <- gluedatabrew_list_rulesets

#' Lists the DataBrew schedules that are defined
#'
#' @description
#' Lists the DataBrew schedules that are defined.
#'
#' @usage
#' gluedatabrew_list_schedules(JobName, MaxResults, NextToken)
#'
#' @param JobName The name of the job that these schedules apply to.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken The token returned by a previous call to retrieve the next set of
#' results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Schedules = list(
#'     list(
#'       AccountId = "string",
#'       CreatedBy = "string",
#'       CreateDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       JobNames = list(
#'         "string"
#'       ),
#'       LastModifiedBy = "string",
#'       LastModifiedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ResourceArn = "string",
#'       CronExpression = "string",
#'       Tags = list(
#'         "string"
#'       ),
#'       Name = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_schedules(
#'   JobName = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_schedules
gluedatabrew_list_schedules <- function(JobName = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListSchedules",
    http_method = "GET",
    http_path = "/schedules",
    paginator = list()
  )
  input <- .gluedatabrew$list_schedules_input(JobName = JobName, MaxResults = MaxResults, NextToken = NextToken)
  output <- .gluedatabrew$list_schedules_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_schedules <- gluedatabrew_list_schedules

#' Lists all the tags for a DataBrew resource
#'
#' @description
#' Lists all the tags for a DataBrew resource.
#'
#' @usage
#' gluedatabrew_list_tags_for_resource(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) string that uniquely identifies the
#' DataBrew resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_list_tags_for_resource
gluedatabrew_list_tags_for_resource <- function(ResourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{ResourceArn}",
    paginator = list()
  )
  input <- .gluedatabrew$list_tags_for_resource_input(ResourceArn = ResourceArn)
  output <- .gluedatabrew$list_tags_for_resource_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$list_tags_for_resource <- gluedatabrew_list_tags_for_resource

#' Publishes a new version of a DataBrew recipe
#'
#' @description
#' Publishes a new version of a DataBrew recipe.
#'
#' @usage
#' gluedatabrew_publish_recipe(Description, Name)
#'
#' @param Description A description of the recipe to be published, for this version of the
#' recipe.
#' @param Name &#91;required&#93; The name of the recipe to be published.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$publish_recipe(
#'   Description = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_publish_recipe
gluedatabrew_publish_recipe <- function(Description = NULL, Name) {
  op <- new_operation(
    name = "PublishRecipe",
    http_method = "POST",
    http_path = "/recipes/{name}/publishRecipe",
    paginator = list()
  )
  input <- .gluedatabrew$publish_recipe_input(Description = Description, Name = Name)
  output <- .gluedatabrew$publish_recipe_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$publish_recipe <- gluedatabrew_publish_recipe

#' Performs a recipe step within an interactive DataBrew session that's
#' currently open
#'
#' @description
#' Performs a recipe step within an interactive DataBrew session that's
#' currently open.
#'
#' @usage
#' gluedatabrew_send_project_session_action(Preview, Name, RecipeStep,
#'   StepIndex, ClientSessionId, ViewFrame)
#'
#' @param Preview If true, the result of the recipe step will be returned, but not
#' applied.
#' @param Name &#91;required&#93; The name of the project to apply the action to.
#' @param RecipeStep 
#' @param StepIndex The index from which to preview a step. This index is used to preview
#' the result of steps that have already been applied, so that the
#' resulting view frame is from earlier in the view frame stack.
#' @param ClientSessionId A unique identifier for an interactive session that's currently open and
#' ready for work. The action will be performed on this session.
#' @param ViewFrame 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Result = "string",
#'   Name = "string",
#'   ActionId = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$send_project_session_action(
#'   Preview = TRUE|FALSE,
#'   Name = "string",
#'   RecipeStep = list(
#'     Action = list(
#'       Operation = "string",
#'       Parameters = list(
#'         "string"
#'       )
#'     ),
#'     ConditionExpressions = list(
#'       list(
#'         Condition = "string",
#'         Value = "string",
#'         TargetColumn = "string"
#'       )
#'     )
#'   ),
#'   StepIndex = 123,
#'   ClientSessionId = "string",
#'   ViewFrame = list(
#'     StartColumnIndex = 123,
#'     ColumnRange = 123,
#'     HiddenColumns = list(
#'       "string"
#'     ),
#'     StartRowIndex = 123,
#'     RowRange = 123,
#'     Analytics = "ENABLE"|"DISABLE"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_send_project_session_action
gluedatabrew_send_project_session_action <- function(Preview = NULL, Name, RecipeStep = NULL, StepIndex = NULL, ClientSessionId = NULL, ViewFrame = NULL) {
  op <- new_operation(
    name = "SendProjectSessionAction",
    http_method = "PUT",
    http_path = "/projects/{name}/sendProjectSessionAction",
    paginator = list()
  )
  input <- .gluedatabrew$send_project_session_action_input(Preview = Preview, Name = Name, RecipeStep = RecipeStep, StepIndex = StepIndex, ClientSessionId = ClientSessionId, ViewFrame = ViewFrame)
  output <- .gluedatabrew$send_project_session_action_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$send_project_session_action <- gluedatabrew_send_project_session_action

#' Runs a DataBrew job
#'
#' @description
#' Runs a DataBrew job.
#'
#' @usage
#' gluedatabrew_start_job_run(Name)
#'
#' @param Name &#91;required&#93; The name of the job to be run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_start_job_run
gluedatabrew_start_job_run <- function(Name) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/jobs/{name}/startJobRun",
    paginator = list()
  )
  input <- .gluedatabrew$start_job_run_input(Name = Name)
  output <- .gluedatabrew$start_job_run_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$start_job_run <- gluedatabrew_start_job_run

#' Creates an interactive session, enabling you to manipulate data in a
#' DataBrew project
#'
#' @description
#' Creates an interactive session, enabling you to manipulate data in a
#' DataBrew project.
#'
#' @usage
#' gluedatabrew_start_project_session(Name, AssumeControl)
#'
#' @param Name &#91;required&#93; The name of the project to act upon.
#' @param AssumeControl A value that, if true, enables you to take control of a session, even if
#' a different client is currently accessing the project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   ClientSessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_project_session(
#'   Name = "string",
#'   AssumeControl = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_start_project_session
gluedatabrew_start_project_session <- function(Name, AssumeControl = NULL) {
  op <- new_operation(
    name = "StartProjectSession",
    http_method = "PUT",
    http_path = "/projects/{name}/startProjectSession",
    paginator = list()
  )
  input <- .gluedatabrew$start_project_session_input(Name = Name, AssumeControl = AssumeControl)
  output <- .gluedatabrew$start_project_session_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$start_project_session <- gluedatabrew_start_project_session

#' Stops a particular run of a job
#'
#' @description
#' Stops a particular run of a job.
#'
#' @usage
#' gluedatabrew_stop_job_run(Name, RunId)
#'
#' @param Name &#91;required&#93; The name of the job to be stopped.
#' @param RunId &#91;required&#93; The ID of the job run to be stopped.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_job_run(
#'   Name = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_stop_job_run
gluedatabrew_stop_job_run <- function(Name, RunId) {
  op <- new_operation(
    name = "StopJobRun",
    http_method = "POST",
    http_path = "/jobs/{name}/jobRun/{runId}/stopJobRun",
    paginator = list()
  )
  input <- .gluedatabrew$stop_job_run_input(Name = Name, RunId = RunId)
  output <- .gluedatabrew$stop_job_run_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$stop_job_run <- gluedatabrew_stop_job_run

#' Adds metadata tags to a DataBrew resource, such as a dataset, project,
#' recipe, job, or schedule
#'
#' @description
#' Adds metadata tags to a DataBrew resource, such as a dataset, project,
#' recipe, job, or schedule.
#'
#' @usage
#' gluedatabrew_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; The DataBrew resource to which tags should be added. The value for this
#' parameter is an Amazon Resource Name (ARN). For DataBrew, you can tag a
#' dataset, a job, a project, or a recipe.
#' @param Tags &#91;required&#93; One or more tags to be assigned to the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_tag_resource
gluedatabrew_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{ResourceArn}",
    paginator = list()
  )
  input <- .gluedatabrew$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .gluedatabrew$tag_resource_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$tag_resource <- gluedatabrew_tag_resource

#' Removes metadata tags from a DataBrew resource
#'
#' @description
#' Removes metadata tags from a DataBrew resource.
#'
#' @usage
#' gluedatabrew_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; A DataBrew resource from which you want to remove a tag or tags. The
#' value for this parameter is an Amazon Resource Name (ARN).
#' @param TagKeys &#91;required&#93; The tag keys (names) of one or more tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_untag_resource
gluedatabrew_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{ResourceArn}",
    paginator = list()
  )
  input <- .gluedatabrew$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .gluedatabrew$untag_resource_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$untag_resource <- gluedatabrew_untag_resource

#' Modifies the definition of an existing DataBrew dataset
#'
#' @description
#' Modifies the definition of an existing DataBrew dataset.
#'
#' @usage
#' gluedatabrew_update_dataset(Name, Format, FormatOptions, Input,
#'   PathOptions)
#'
#' @param Name &#91;required&#93; The name of the dataset to be updated.
#' @param Format The file format of a dataset that is created from an Amazon S3 file or
#' folder.
#' @param FormatOptions 
#' @param Input &#91;required&#93; 
#' @param PathOptions A set of options that defines how DataBrew interprets an Amazon S3 path
#' of the dataset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_dataset(
#'   Name = "string",
#'   Format = "CSV"|"JSON"|"PARQUET"|"EXCEL"|"ORC",
#'   FormatOptions = list(
#'     Json = list(
#'       MultiLine = TRUE|FALSE
#'     ),
#'     Excel = list(
#'       SheetNames = list(
#'         "string"
#'       ),
#'       SheetIndexes = list(
#'         123
#'       ),
#'       HeaderRow = TRUE|FALSE
#'     ),
#'     Csv = list(
#'       Delimiter = "string",
#'       HeaderRow = TRUE|FALSE
#'     )
#'   ),
#'   Input = list(
#'     S3InputDefinition = list(
#'       Bucket = "string",
#'       Key = "string",
#'       BucketOwner = "string"
#'     ),
#'     DataCatalogInputDefinition = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       )
#'     ),
#'     DatabaseInputDefinition = list(
#'       GlueConnectionName = "string",
#'       DatabaseTableName = "string",
#'       TempDirectory = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       QueryString = "string"
#'     ),
#'     Metadata = list(
#'       SourceArn = "string"
#'     )
#'   ),
#'   PathOptions = list(
#'     LastModifiedDateCondition = list(
#'       Expression = "string",
#'       ValuesMap = list(
#'         "string"
#'       )
#'     ),
#'     FilesLimit = list(
#'       MaxFiles = 123,
#'       OrderedBy = "LAST_MODIFIED_DATE",
#'       Order = "DESCENDING"|"ASCENDING"
#'     ),
#'     Parameters = list(
#'       list(
#'         Name = "string",
#'         Type = "Datetime"|"Number"|"String",
#'         DatetimeOptions = list(
#'           Format = "string",
#'           TimezoneOffset = "string",
#'           LocaleCode = "string"
#'         ),
#'         CreateColumn = TRUE|FALSE,
#'         Filter = list(
#'           Expression = "string",
#'           ValuesMap = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_dataset
gluedatabrew_update_dataset <- function(Name, Format = NULL, FormatOptions = NULL, Input, PathOptions = NULL) {
  op <- new_operation(
    name = "UpdateDataset",
    http_method = "PUT",
    http_path = "/datasets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_dataset_input(Name = Name, Format = Format, FormatOptions = FormatOptions, Input = Input, PathOptions = PathOptions)
  output <- .gluedatabrew$update_dataset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_dataset <- gluedatabrew_update_dataset

#' Modifies the definition of an existing profile job
#'
#' @description
#' Modifies the definition of an existing profile job.
#'
#' @usage
#' gluedatabrew_update_profile_job(Configuration, EncryptionKeyArn,
#'   EncryptionMode, Name, LogSubscription, MaxCapacity, MaxRetries,
#'   OutputLocation, ValidationConfigurations, RoleArn, Timeout, JobSample)
#'
#' @param Configuration Configuration for profile jobs. Used to select columns, do evaluations,
#' and override default parameters of evaluations. When configuration is
#' null, the profile job will run with default settings.
#' @param EncryptionKeyArn The Amazon Resource Name (ARN) of an encryption key that is used to
#' protect the job.
#' @param EncryptionMode The encryption mode for the job, which can be one of the following:
#' 
#' -   `SSE-KMS` - Server-side encryption with keys managed by KMS.
#' 
#' -   `SSE-S3` - Server-side encryption with keys managed by Amazon S3.
#' @param Name &#91;required&#93; The name of the job to be updated.
#' @param LogSubscription Enables or disables Amazon CloudWatch logging for the job. If logging is
#' enabled, CloudWatch writes one log stream for each job run.
#' @param MaxCapacity The maximum number of compute nodes that DataBrew can use when the job
#' processes data.
#' @param MaxRetries The maximum number of times to retry the job after a job run fails.
#' @param OutputLocation &#91;required&#93; 
#' @param ValidationConfigurations List of validation configurations that are applied to the profile job.
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the Identity and Access Management
#' (IAM) role to be assumed when DataBrew runs the job.
#' @param Timeout The job's timeout in minutes. A job that attempts to run longer than
#' this timeout period ends with a status of `TIMEOUT`.
#' @param JobSample Sample configuration for Profile Jobs only. Determines the number of
#' rows on which the Profile job will be executed. If a JobSample value is
#' not provided for profile jobs, the default value will be used. The
#' default value is CUSTOM_ROWS for the mode parameter and 20000 for the
#' size parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_profile_job(
#'   Configuration = list(
#'     DatasetStatisticsConfiguration = list(
#'       IncludedStatistics = list(
#'         "string"
#'       ),
#'       Overrides = list(
#'         list(
#'           Statistic = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ProfileColumns = list(
#'       list(
#'         Regex = "string",
#'         Name = "string"
#'       )
#'     ),
#'     ColumnStatisticsConfigurations = list(
#'       list(
#'         Selectors = list(
#'           list(
#'             Regex = "string",
#'             Name = "string"
#'           )
#'         ),
#'         Statistics = list(
#'           IncludedStatistics = list(
#'             "string"
#'           ),
#'           Overrides = list(
#'             list(
#'               Statistic = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     EntityDetectorConfiguration = list(
#'       EntityTypes = list(
#'         "string"
#'       ),
#'       AllowedStatistics = list(
#'         list(
#'           Statistics = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   EncryptionKeyArn = "string",
#'   EncryptionMode = "SSE-KMS"|"SSE-S3",
#'   Name = "string",
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   MaxCapacity = 123,
#'   MaxRetries = 123,
#'   OutputLocation = list(
#'     Bucket = "string",
#'     Key = "string",
#'     BucketOwner = "string"
#'   ),
#'   ValidationConfigurations = list(
#'     list(
#'       RulesetArn = "string",
#'       ValidationMode = "CHECK_ALL"
#'     )
#'   ),
#'   RoleArn = "string",
#'   Timeout = 123,
#'   JobSample = list(
#'     Mode = "FULL_DATASET"|"CUSTOM_ROWS",
#'     Size = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_profile_job
gluedatabrew_update_profile_job <- function(Configuration = NULL, EncryptionKeyArn = NULL, EncryptionMode = NULL, Name, LogSubscription = NULL, MaxCapacity = NULL, MaxRetries = NULL, OutputLocation, ValidationConfigurations = NULL, RoleArn, Timeout = NULL, JobSample = NULL) {
  op <- new_operation(
    name = "UpdateProfileJob",
    http_method = "PUT",
    http_path = "/profileJobs/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_profile_job_input(Configuration = Configuration, EncryptionKeyArn = EncryptionKeyArn, EncryptionMode = EncryptionMode, Name = Name, LogSubscription = LogSubscription, MaxCapacity = MaxCapacity, MaxRetries = MaxRetries, OutputLocation = OutputLocation, ValidationConfigurations = ValidationConfigurations, RoleArn = RoleArn, Timeout = Timeout, JobSample = JobSample)
  output <- .gluedatabrew$update_profile_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_profile_job <- gluedatabrew_update_profile_job

#' Modifies the definition of an existing DataBrew project
#'
#' @description
#' Modifies the definition of an existing DataBrew project.
#'
#' @usage
#' gluedatabrew_update_project(Sample, RoleArn, Name)
#'
#' @param Sample 
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role to be assumed for this
#' request.
#' @param Name &#91;required&#93; The name of the project to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LastModifiedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_project(
#'   Sample = list(
#'     Size = 123,
#'     Type = "FIRST_N"|"LAST_N"|"RANDOM"
#'   ),
#'   RoleArn = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_project
gluedatabrew_update_project <- function(Sample = NULL, RoleArn, Name) {
  op <- new_operation(
    name = "UpdateProject",
    http_method = "PUT",
    http_path = "/projects/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_project_input(Sample = Sample, RoleArn = RoleArn, Name = Name)
  output <- .gluedatabrew$update_project_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_project <- gluedatabrew_update_project

#' Modifies the definition of the LATEST_WORKING version of a DataBrew
#' recipe
#'
#' @description
#' Modifies the definition of the `LATEST_WORKING` version of a DataBrew
#' recipe.
#'
#' @usage
#' gluedatabrew_update_recipe(Description, Name, Steps)
#'
#' @param Description A description of the recipe.
#' @param Name &#91;required&#93; The name of the recipe to be updated.
#' @param Steps One or more steps to be performed by the recipe. Each step consists of
#' an action, and the conditions under which the action should succeed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_recipe(
#'   Description = "string",
#'   Name = "string",
#'   Steps = list(
#'     list(
#'       Action = list(
#'         Operation = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       ConditionExpressions = list(
#'         list(
#'           Condition = "string",
#'           Value = "string",
#'           TargetColumn = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_recipe
gluedatabrew_update_recipe <- function(Description = NULL, Name, Steps = NULL) {
  op <- new_operation(
    name = "UpdateRecipe",
    http_method = "PUT",
    http_path = "/recipes/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_recipe_input(Description = Description, Name = Name, Steps = Steps)
  output <- .gluedatabrew$update_recipe_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_recipe <- gluedatabrew_update_recipe

#' Modifies the definition of an existing DataBrew recipe job
#'
#' @description
#' Modifies the definition of an existing DataBrew recipe job.
#'
#' @usage
#' gluedatabrew_update_recipe_job(EncryptionKeyArn, EncryptionMode, Name,
#'   LogSubscription, MaxCapacity, MaxRetries, Outputs, DataCatalogOutputs,
#'   DatabaseOutputs, RoleArn, Timeout)
#'
#' @param EncryptionKeyArn The Amazon Resource Name (ARN) of an encryption key that is used to
#' protect the job.
#' @param EncryptionMode The encryption mode for the job, which can be one of the following:
#' 
#' -   `SSE-KMS` - Server-side encryption with keys managed by KMS.
#' 
#' -   `SSE-S3` - Server-side encryption with keys managed by Amazon S3.
#' @param Name &#91;required&#93; The name of the job to update.
#' @param LogSubscription Enables or disables Amazon CloudWatch logging for the job. If logging is
#' enabled, CloudWatch writes one log stream for each job run.
#' @param MaxCapacity The maximum number of nodes that DataBrew can consume when the job
#' processes data.
#' @param MaxRetries The maximum number of times to retry the job after a job run fails.
#' @param Outputs One or more artifacts that represent the output from running the job.
#' @param DataCatalogOutputs One or more artifacts that represent the Glue Data Catalog output from
#' running the job.
#' @param DatabaseOutputs Represents a list of JDBC database output objects which defines the
#' output destination for a DataBrew recipe job to write into.
#' @param RoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the Identity and Access Management
#' (IAM) role to be assumed when DataBrew runs the job.
#' @param Timeout The job's timeout in minutes. A job that attempts to run longer than
#' this timeout period ends with a status of `TIMEOUT`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_recipe_job(
#'   EncryptionKeyArn = "string",
#'   EncryptionMode = "SSE-KMS"|"SSE-S3",
#'   Name = "string",
#'   LogSubscription = "ENABLE"|"DISABLE",
#'   MaxCapacity = 123,
#'   MaxRetries = 123,
#'   Outputs = list(
#'     list(
#'       CompressionFormat = "GZIP"|"LZ4"|"SNAPPY"|"BZIP2"|"DEFLATE"|"LZO"|"BROTLI"|"ZSTD"|"ZLIB",
#'       Format = "CSV"|"JSON"|"PARQUET"|"GLUEPARQUET"|"AVRO"|"ORC"|"XML"|"TABLEAUHYPER",
#'       PartitionColumns = list(
#'         "string"
#'       ),
#'       Location = list(
#'         Bucket = "string",
#'         Key = "string",
#'         BucketOwner = "string"
#'       ),
#'       Overwrite = TRUE|FALSE,
#'       FormatOptions = list(
#'         Csv = list(
#'           Delimiter = "string"
#'         )
#'       ),
#'       MaxOutputFiles = 123
#'     )
#'   ),
#'   DataCatalogOutputs = list(
#'     list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       S3Options = list(
#'         Location = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         )
#'       ),
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       Overwrite = TRUE|FALSE
#'     )
#'   ),
#'   DatabaseOutputs = list(
#'     list(
#'       GlueConnectionName = "string",
#'       DatabaseOptions = list(
#'         TempDirectory = list(
#'           Bucket = "string",
#'           Key = "string",
#'           BucketOwner = "string"
#'         ),
#'         TableName = "string"
#'       ),
#'       DatabaseOutputMode = "NEW_TABLE"
#'     )
#'   ),
#'   RoleArn = "string",
#'   Timeout = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_recipe_job
gluedatabrew_update_recipe_job <- function(EncryptionKeyArn = NULL, EncryptionMode = NULL, Name, LogSubscription = NULL, MaxCapacity = NULL, MaxRetries = NULL, Outputs = NULL, DataCatalogOutputs = NULL, DatabaseOutputs = NULL, RoleArn, Timeout = NULL) {
  op <- new_operation(
    name = "UpdateRecipeJob",
    http_method = "PUT",
    http_path = "/recipeJobs/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_recipe_job_input(EncryptionKeyArn = EncryptionKeyArn, EncryptionMode = EncryptionMode, Name = Name, LogSubscription = LogSubscription, MaxCapacity = MaxCapacity, MaxRetries = MaxRetries, Outputs = Outputs, DataCatalogOutputs = DataCatalogOutputs, DatabaseOutputs = DatabaseOutputs, RoleArn = RoleArn, Timeout = Timeout)
  output <- .gluedatabrew$update_recipe_job_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_recipe_job <- gluedatabrew_update_recipe_job

#' Updates specified ruleset
#'
#' @description
#' Updates specified ruleset.
#'
#' @usage
#' gluedatabrew_update_ruleset(Name, Description, Rules)
#'
#' @param Name &#91;required&#93; The name of the ruleset to be updated.
#' @param Description The description of the ruleset.
#' @param Rules &#91;required&#93; A list of rules that are defined with the ruleset. A rule includes one
#' or more checks to be validated on a DataBrew dataset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_ruleset(
#'   Name = "string",
#'   Description = "string",
#'   Rules = list(
#'     list(
#'       Name = "string",
#'       Disabled = TRUE|FALSE,
#'       CheckExpression = "string",
#'       SubstitutionMap = list(
#'         "string"
#'       ),
#'       Threshold = list(
#'         Value = 123.0,
#'         Type = "GREATER_THAN_OR_EQUAL"|"LESS_THAN_OR_EQUAL"|"GREATER_THAN"|"LESS_THAN",
#'         Unit = "COUNT"|"PERCENTAGE"
#'       ),
#'       ColumnSelectors = list(
#'         list(
#'           Regex = "string",
#'           Name = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_ruleset
gluedatabrew_update_ruleset <- function(Name, Description = NULL, Rules) {
  op <- new_operation(
    name = "UpdateRuleset",
    http_method = "PUT",
    http_path = "/rulesets/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_ruleset_input(Name = Name, Description = Description, Rules = Rules)
  output <- .gluedatabrew$update_ruleset_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_ruleset <- gluedatabrew_update_ruleset

#' Modifies the definition of an existing DataBrew schedule
#'
#' @description
#' Modifies the definition of an existing DataBrew schedule.
#'
#' @usage
#' gluedatabrew_update_schedule(JobNames, CronExpression, Name)
#'
#' @param JobNames The name or names of one or more jobs to be run for this schedule.
#' @param CronExpression &#91;required&#93; The date or dates and time or times when the jobs are to be run. For
#' more information, see [Cron
#' expressions](https://docs.aws.amazon.com/databrew/latest/dg/) in the
#' *Glue DataBrew Developer Guide*.
#' @param Name &#91;required&#93; The name of the schedule to update.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_schedule(
#'   JobNames = list(
#'     "string"
#'   ),
#'   CronExpression = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname gluedatabrew_update_schedule
gluedatabrew_update_schedule <- function(JobNames = NULL, CronExpression, Name) {
  op <- new_operation(
    name = "UpdateSchedule",
    http_method = "PUT",
    http_path = "/schedules/{name}",
    paginator = list()
  )
  input <- .gluedatabrew$update_schedule_input(JobNames = JobNames, CronExpression = CronExpression, Name = Name)
  output <- .gluedatabrew$update_schedule_output()
  config <- get_config()
  svc <- .gluedatabrew$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.gluedatabrew$operations$update_schedule <- gluedatabrew_update_schedule

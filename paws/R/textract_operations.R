# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include textract_service.R
NULL

#' Analyzes an input document for relationships between detected items
#'
#' @description
#' Analyzes an input document for relationships between detected items.
#' 
#' The types of information returned are as follows:
#' 
#' -   Form data (key-value pairs). The related information is returned in
#'     two Block objects, each of type `KEY_VALUE_SET`: a KEY `Block`
#'     object and a VALUE `Block` object. For example, *Name: Ana Silva
#'     Carolina* contains a key and value. *Name:* is the key. *Ana Silva
#'     Carolina* is the value.
#' 
#' -   Table and table cell data. A TABLE `Block` object contains
#'     information about a detected table. A CELL `Block` object is
#'     returned for each cell in a table.
#' 
#' -   Lines and words of text. A LINE `Block` object contains one or more
#'     WORD `Block` objects. All lines and words that are detected in the
#'     document are returned (including text that doesn't have a
#'     relationship with the value of `FeatureTypes`).
#' 
#' -   Signatures. A SIGNATURE `Block` object contains the location
#'     information of a signature in a document. If used in conjunction
#'     with forms or tables, a signature can be given a Key-Value pairing
#'     or be detected in the cell of a table.
#' 
#' -   Query. A QUERY Block object contains the query text, alias and link
#'     to the associated Query results block object.
#' 
#' -   Query Result. A QUERY_RESULT Block object contains the answer to the
#'     query and an ID that connects it to the query asked. This Block also
#'     contains a confidence score.
#' 
#' Selection elements such as check boxes and option buttons (radio
#' buttons) can be detected in form data and in tables. A SELECTION_ELEMENT
#' `Block` object contains information about a selection element, including
#' the selection status.
#' 
#' You can choose which type of analysis to perform by specifying the
#' `FeatureTypes` list.
#' 
#' The output is returned in a list of `Block` objects.
#' 
#' [`analyze_document`][textract_analyze_document] is a synchronous
#' operation. To analyze documents asynchronously, use
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_analyze_document(Document, FeatureTypes, HumanLoopConfig,
#'   QueriesConfig, AdaptersConfig)
#'
#' @param Document &#91;required&#93; The input document as base64-encoded bytes or an Amazon S3 object. If
#' you use the AWS CLI to call Amazon Textract operations, you can't pass
#' image bytes. The document must be an image in JPEG, PNG, PDF, or TIFF
#' format.
#' 
#' If you're using an AWS SDK to call Amazon Textract, you might not need
#' to base64-encode image bytes that are passed using the `Bytes` field.
#' @param FeatureTypes &#91;required&#93; A list of the types of analysis to perform. Add TABLES to the list to
#' return information about the tables that are detected in the input
#' document. Add FORMS to return detected form data. Add SIGNATURES to
#' return the locations of detected signatures. Add LAYOUT to the list to
#' return information about the layout of the document. All lines and words
#' detected in the document are included in the response (including text
#' that isn't related to the value of `FeatureTypes`).
#' @param HumanLoopConfig Sets the configuration for the human in the loop workflow for analyzing
#' documents.
#' @param QueriesConfig Contains Queries and the alias for those Queries, as determined by the
#' input.
#' @param AdaptersConfig Specifies the adapter to be used when analyzing a document.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         ),
#'         RotationAngle = 123.0
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   HumanLoopActivationOutput = list(
#'     HumanLoopArn = "string",
#'     HumanLoopActivationReasons = list(
#'       "string"
#'     ),
#'     HumanLoopActivationConditionsEvaluationResults = "string"
#'   ),
#'   AnalyzeDocumentModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_document(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   HumanLoopConfig = list(
#'     HumanLoopName = "string",
#'     FlowDefinitionArn = "string",
#'     DataAttributes = list(
#'       ContentClassifiers = list(
#'         "FreeOfPersonallyIdentifiableInformation"|"FreeOfAdultContent"
#'       )
#'     )
#'   ),
#'   QueriesConfig = list(
#'     Queries = list(
#'       list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   AdaptersConfig = list(
#'     Adapters = list(
#'       list(
#'         AdapterId = "string",
#'         Pages = list(
#'           "string"
#'         ),
#'         Version = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_document
#'
#' @aliases textract_analyze_document
textract_analyze_document <- function(Document, FeatureTypes, HumanLoopConfig = NULL, QueriesConfig = NULL, AdaptersConfig = NULL) {
  op <- new_operation(
    name = "AnalyzeDocument",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$analyze_document_input(Document = Document, FeatureTypes = FeatureTypes, HumanLoopConfig = HumanLoopConfig, QueriesConfig = QueriesConfig, AdaptersConfig = AdaptersConfig)
  output <- .textract$analyze_document_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_document <- textract_analyze_document

#' AnalyzeExpense synchronously analyzes an input document for financially
#' related relationships between text
#'
#' @description
#' [`analyze_expense`][textract_analyze_expense] synchronously analyzes an
#' input document for financially related relationships between text.
#' 
#' Information is returned as `ExpenseDocuments` and seperated as follows:
#' 
#' -   `LineItemGroups`- A data set containing `LineItems` which store
#'     information about the lines of text, such as an item purchased and
#'     its price on a receipt.
#' 
#' -   `SummaryFields`- Contains all other information a receipt, such as
#'     header information or the vendors name.
#'
#' @usage
#' textract_analyze_expense(Document)
#'
#' @param Document &#91;required&#93; 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   ExpenseDocuments = list(
#'     list(
#'       ExpenseIndex = 123,
#'       SummaryFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             Confidence = 123.0
#'           ),
#'           LabelDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               ),
#'               RotationAngle = 123.0
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               ),
#'               RotationAngle = 123.0
#'             ),
#'             Confidence = 123.0
#'           ),
#'           PageNumber = 123,
#'           Currency = list(
#'             Code = "string",
#'             Confidence = 123.0
#'           ),
#'           GroupProperties = list(
#'             list(
#'               Types = list(
#'                 "string"
#'               ),
#'               Id = "string"
#'             )
#'           )
#'         )
#'       ),
#'       LineItemGroups = list(
#'         list(
#'           LineItemGroupIndex = 123,
#'           LineItems = list(
#'             list(
#'               LineItemExpenseFields = list(
#'                 list(
#'                   Type = list(
#'                     Text = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   LabelDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       ),
#'                       RotationAngle = 123.0
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   ValueDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       ),
#'                       RotationAngle = 123.0
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   PageNumber = 123,
#'                   Currency = list(
#'                     Code = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   GroupProperties = list(
#'                     list(
#'                       Types = list(
#'                         "string"
#'                       ),
#'                       Id = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             ),
#'             RotationAngle = 123.0
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_expense(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_expense
#'
#' @aliases textract_analyze_expense
textract_analyze_expense <- function(Document) {
  op <- new_operation(
    name = "AnalyzeExpense",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$analyze_expense_input(Document = Document)
  output <- .textract$analyze_expense_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_expense <- textract_analyze_expense

#' Analyzes identity documents for relevant information
#'
#' @description
#' Analyzes identity documents for relevant information. This information
#' is extracted and returned as `IdentityDocumentFields`, which records
#' both the normalized field and value of the extracted text. Unlike other
#' Amazon Textract operations, [`analyze_id`][textract_analyze_id] doesn't
#' return any Geometry data.
#'
#' @usage
#' textract_analyze_id(DocumentPages)
#'
#' @param DocumentPages &#91;required&#93; The document being passed to AnalyzeID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   IdentityDocuments = list(
#'     list(
#'       DocumentIndex = 123,
#'       IdentityDocumentFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             NormalizedValue = list(
#'               Value = "string",
#'               ValueType = "DATE"
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             NormalizedValue = list(
#'               Value = "string",
#'               ValueType = "DATE"
#'             ),
#'             Confidence = 123.0
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             ),
#'             RotationAngle = 123.0
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   AnalyzeIDModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_id(
#'   DocumentPages = list(
#'     list(
#'       Bytes = raw,
#'       S3Object = list(
#'         Bucket = "string",
#'         Name = "string",
#'         Version = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_id
#'
#' @aliases textract_analyze_id
textract_analyze_id <- function(DocumentPages) {
  op <- new_operation(
    name = "AnalyzeID",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$analyze_id_input(DocumentPages = DocumentPages)
  output <- .textract$analyze_id_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_id <- textract_analyze_id

#' Creates an adapter, which can be fine-tuned for enhanced performance on
#' user provided documents
#'
#' @description
#' Creates an adapter, which can be fine-tuned for enhanced performance on
#' user provided documents. Takes an AdapterName and FeatureType. Currently
#' the only supported feature type is `QUERIES`. You can also provide a
#' Description, Tags, and a ClientRequestToken. You can choose whether or
#' not the adapter should be AutoUpdated with the AutoUpdate argument. By
#' default, AutoUpdate is set to DISABLED.
#'
#' @usage
#' textract_create_adapter(AdapterName, ClientRequestToken, Description,
#'   FeatureTypes, AutoUpdate, Tags)
#'
#' @param AdapterName &#91;required&#93; The name to be assigned to the adapter being created.
#' @param ClientRequestToken Idempotent token is used to recognize the request. If the same token is
#' used with multiple CreateAdapter requests, the same session is returned.
#' This token is employed to avoid unintentionally creating the same
#' session multiple times.
#' @param Description The description to be assigned to the adapter being created.
#' @param FeatureTypes &#91;required&#93; The type of feature that the adapter is being trained on. Currrenly,
#' supported feature types are: `QUERIES`
#' @param AutoUpdate Controls whether or not the adapter should automatically update.
#' @param Tags A list of tags to be added to the adapter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_adapter(
#'   AdapterName = "string",
#'   ClientRequestToken = "string",
#'   Description = "string",
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   AutoUpdate = "ENABLED"|"DISABLED",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_create_adapter
#'
#' @aliases textract_create_adapter
textract_create_adapter <- function(AdapterName, ClientRequestToken = NULL, Description = NULL, FeatureTypes, AutoUpdate = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateAdapter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$create_adapter_input(AdapterName = AdapterName, ClientRequestToken = ClientRequestToken, Description = Description, FeatureTypes = FeatureTypes, AutoUpdate = AutoUpdate, Tags = Tags)
  output <- .textract$create_adapter_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$create_adapter <- textract_create_adapter

#' Creates a new version of an adapter
#'
#' @description
#' Creates a new version of an adapter. Operates on a provided AdapterId
#' and a specified dataset provided via the DatasetConfig argument.
#' Requires that you specify an Amazon S3 bucket with the OutputConfig
#' argument. You can provide an optional KMSKeyId, an optional
#' ClientRequestToken, and optional tags.
#'
#' @usage
#' textract_create_adapter_version(AdapterId, ClientRequestToken,
#'   DatasetConfig, KMSKeyId, OutputConfig, Tags)
#'
#' @param AdapterId &#91;required&#93; A string containing a unique ID for the adapter that will receive a new
#' version.
#' @param ClientRequestToken Idempotent token is used to recognize the request. If the same token is
#' used with multiple CreateAdapterVersion requests, the same session is
#' returned. This token is employed to avoid unintentionally creating the
#' same session multiple times.
#' @param DatasetConfig &#91;required&#93; Specifies a dataset used to train a new adapter version. Takes a
#' ManifestS3Object as the value.
#' @param KMSKeyId The identifier for your AWS Key Management Service key (AWS KMS key).
#' Used to encrypt your documents.
#' @param OutputConfig &#91;required&#93; 
#' @param Tags A set of tags (key-value pairs) that you want to attach to the adapter
#' version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterId = "string",
#'   AdapterVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_adapter_version(
#'   AdapterId = "string",
#'   ClientRequestToken = "string",
#'   DatasetConfig = list(
#'     ManifestS3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   KMSKeyId = "string",
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_create_adapter_version
#'
#' @aliases textract_create_adapter_version
textract_create_adapter_version <- function(AdapterId, ClientRequestToken = NULL, DatasetConfig, KMSKeyId = NULL, OutputConfig, Tags = NULL) {
  op <- new_operation(
    name = "CreateAdapterVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$create_adapter_version_input(AdapterId = AdapterId, ClientRequestToken = ClientRequestToken, DatasetConfig = DatasetConfig, KMSKeyId = KMSKeyId, OutputConfig = OutputConfig, Tags = Tags)
  output <- .textract$create_adapter_version_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$create_adapter_version <- textract_create_adapter_version

#' Deletes an Amazon Textract adapter
#'
#' @description
#' Deletes an Amazon Textract adapter. Takes an AdapterId and deletes the
#' adapter specified by the ID.
#'
#' @usage
#' textract_delete_adapter(AdapterId)
#'
#' @param AdapterId &#91;required&#93; A string containing a unique ID for the adapter to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_adapter(
#'   AdapterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_delete_adapter
#'
#' @aliases textract_delete_adapter
textract_delete_adapter <- function(AdapterId) {
  op <- new_operation(
    name = "DeleteAdapter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$delete_adapter_input(AdapterId = AdapterId)
  output <- .textract$delete_adapter_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$delete_adapter <- textract_delete_adapter

#' Deletes an Amazon Textract adapter version
#'
#' @description
#' Deletes an Amazon Textract adapter version. Requires that you specify
#' both an AdapterId and a AdapterVersion. Deletes the adapter version
#' specified by the AdapterId and the AdapterVersion.
#'
#' @usage
#' textract_delete_adapter_version(AdapterId, AdapterVersion)
#'
#' @param AdapterId &#91;required&#93; A string containing a unique ID for the adapter version that will be
#' deleted.
#' @param AdapterVersion &#91;required&#93; Specifies the adapter version to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_adapter_version(
#'   AdapterId = "string",
#'   AdapterVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_delete_adapter_version
#'
#' @aliases textract_delete_adapter_version
textract_delete_adapter_version <- function(AdapterId, AdapterVersion) {
  op <- new_operation(
    name = "DeleteAdapterVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$delete_adapter_version_input(AdapterId = AdapterId, AdapterVersion = AdapterVersion)
  output <- .textract$delete_adapter_version_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$delete_adapter_version <- textract_delete_adapter_version

#' Detects text in the input document
#'
#' @description
#' Detects text in the input document. Amazon Textract can detect lines of
#' text and the words that make up a line of text. The input document must
#' be in one of the following image formats: JPEG, PNG, PDF, or TIFF.
#' [`detect_document_text`][textract_detect_document_text] returns the
#' detected text in an array of Block objects.
#' 
#' Each document page has as an associated `Block` of type PAGE. Each PAGE
#' `Block` object is the parent of LINE `Block` objects that represent the
#' lines of detected text on a page. A LINE `Block` object is a parent for
#' each word that makes up the line. Words are represented by `Block`
#' objects of type WORD.
#' 
#' [`detect_document_text`][textract_detect_document_text] is a synchronous
#' operation. To analyze documents asynchronously, use
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_detect_document_text(Document)
#'
#' @param Document &#91;required&#93; The input document as base64-encoded bytes or an Amazon S3 object. If
#' you use the AWS CLI to call Amazon Textract operations, you can't pass
#' image bytes. The document must be an image in JPEG or PNG format.
#' 
#' If you're using an AWS SDK to call Amazon Textract, you might not need
#' to base64-encode image bytes that are passed using the `Bytes` field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         ),
#'         RotationAngle = 123.0
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   DetectDocumentTextModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$detect_document_text(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_detect_document_text
#'
#' @aliases textract_detect_document_text
textract_detect_document_text <- function(Document) {
  op <- new_operation(
    name = "DetectDocumentText",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$detect_document_text_input(Document = Document)
  output <- .textract$detect_document_text_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$detect_document_text <- textract_detect_document_text

#' Gets configuration information for an adapter specified by an AdapterId,
#' returning information on AdapterName, Description, CreationTime,
#' AutoUpdate status, and FeatureTypes
#'
#' @description
#' Gets configuration information for an adapter specified by an AdapterId,
#' returning information on AdapterName, Description, CreationTime,
#' AutoUpdate status, and FeatureTypes.
#'
#' @usage
#' textract_get_adapter(AdapterId)
#'
#' @param AdapterId &#91;required&#93; A string containing a unique ID for the adapter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterId = "string",
#'   AdapterName = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   AutoUpdate = "ENABLED"|"DISABLED",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_adapter(
#'   AdapterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_adapter
#'
#' @aliases textract_get_adapter
textract_get_adapter <- function(AdapterId) {
  op <- new_operation(
    name = "GetAdapter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_adapter_input(AdapterId = AdapterId)
  output <- .textract$get_adapter_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_adapter <- textract_get_adapter

#' Gets configuration information for the specified adapter version,
#' including: AdapterId, AdapterVersion, FeatureTypes, Status,
#' StatusMessage, DatasetConfig, KMSKeyId, OutputConfig, Tags and
#' EvaluationMetrics
#'
#' @description
#' Gets configuration information for the specified adapter version,
#' including: AdapterId, AdapterVersion, FeatureTypes, Status,
#' StatusMessage, DatasetConfig, KMSKeyId, OutputConfig, Tags and
#' EvaluationMetrics.
#'
#' @usage
#' textract_get_adapter_version(AdapterId, AdapterVersion)
#'
#' @param AdapterId &#91;required&#93; A string specifying a unique ID for the adapter version you want to
#' retrieve information for.
#' @param AdapterVersion &#91;required&#93; A string specifying the adapter version you want to retrieve information
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterId = "string",
#'   AdapterVersion = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   Status = "ACTIVE"|"AT_RISK"|"DEPRECATED"|"CREATION_ERROR"|"CREATION_IN_PROGRESS",
#'   StatusMessage = "string",
#'   DatasetConfig = list(
#'     ManifestS3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   KMSKeyId = "string",
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   EvaluationMetrics = list(
#'     list(
#'       Baseline = list(
#'         F1Score = 123.0,
#'         Precision = 123.0,
#'         Recall = 123.0
#'       ),
#'       AdapterVersion = list(
#'         F1Score = 123.0,
#'         Precision = 123.0,
#'         Recall = 123.0
#'       ),
#'       FeatureType = "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_adapter_version(
#'   AdapterId = "string",
#'   AdapterVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_adapter_version
#'
#' @aliases textract_get_adapter_version
textract_get_adapter_version <- function(AdapterId, AdapterVersion) {
  op <- new_operation(
    name = "GetAdapterVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_adapter_version_input(AdapterId = AdapterId, AdapterVersion = AdapterVersion)
  output <- .textract$get_adapter_version_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_adapter_version <- textract_get_adapter_version

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_document_analysis`][textract_start_document_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_document_analysis`][textract_start_document_analysis]. To get
#' the results of the text-detection operation, first check that the status
#' value published to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_document_analysis`][textract_get_document_analysis], and pass the
#' job identifier (`JobId`) from the initial call to
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' [`get_document_analysis`][textract_get_document_analysis] returns an
#' array of Block objects. The following types of information are returned:
#' 
#' -   Form data (key-value pairs). The related information is returned in
#'     two Block objects, each of type `KEY_VALUE_SET`: a KEY `Block`
#'     object and a VALUE `Block` object. For example, *Name: Ana Silva
#'     Carolina* contains a key and value. *Name:* is the key. *Ana Silva
#'     Carolina* is the value.
#' 
#' -   Table and table cell data. A TABLE `Block` object contains
#'     information about a detected table. A CELL `Block` object is
#'     returned for each cell in a table.
#' 
#' -   Lines and words of text. A LINE `Block` object contains one or more
#'     WORD `Block` objects. All lines and words that are detected in the
#'     document are returned (including text that doesn't have a
#'     relationship with the value of the
#'     [`start_document_analysis`][textract_start_document_analysis]
#'     `FeatureTypes` input parameter).
#' 
#' -   Query. A QUERY Block object contains the query text, alias and link
#'     to the associated Query results block object.
#' 
#' -   Query Results. A QUERY_RESULT Block object contains the answer to
#'     the query and an ID that connects it to the query asked. This Block
#'     also contains a confidence score.
#' 
#' While processing a document with queries, look out for
#' `INVALID_REQUEST_PARAMETERS` output. This indicates that either the per
#' page query limit has been exceeded or that the operation is trying to
#' query a page in the document which doesnâ€™t exist.
#' 
#' Selection elements such as check boxes and option buttons (radio
#' buttons) can be detected in form data and in tables. A SELECTION_ELEMENT
#' `Block` object contains information about a selection element, including
#' the selection status.
#' 
#' Use the `MaxResults` parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call [`get_document_analysis`][textract_get_document_analysis],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_document_analysis`][textract_get_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_get_document_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text-detection job. The `JobId` is returned
#' from [`start_document_analysis`][textract_start_document_analysis]. A
#' `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value that you can specify is 1,000. If you specify a value greater than
#' 1,000, a maximum of 1,000 results is returned. The default value is
#' 1,000.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         ),
#'         RotationAngle = 123.0
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeDocumentModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_document_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_document_analysis
#'
#' @aliases textract_get_document_analysis
textract_get_document_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetDocumentAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_document_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_document_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_document_analysis <- textract_get_document_analysis

#' Gets the results for an Amazon Textract asynchronous operation that
#' detects text in a document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' detects text in a document. Amazon Textract can detect lines of text and
#' the words that make up a line of text.
#' 
#' You start asynchronous text detection by calling
#' [`start_document_text_detection`][textract_start_document_text_detection],
#' which returns a job identifier (`JobId`). When the text detection
#' operation finishes, Amazon Textract publishes a completion status to the
#' Amazon Simple Notification Service (Amazon SNS) topic that's registered
#' in the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' To get the results of the text-detection operation, first check that the
#' status value published to the Amazon SNS topic is `SUCCEEDED`. If so,
#' call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' [`get_document_text_detection`][textract_get_document_text_detection]
#' returns an array of Block objects.
#' 
#' Each document page has as an associated `Block` of type PAGE. Each PAGE
#' `Block` object is the parent of LINE `Block` objects that represent the
#' lines of detected text on a page. A LINE `Block` object is a parent for
#' each word that makes up the line. Words are represented by `Block`
#' objects of type WORD.
#' 
#' Use the MaxResults parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_document_text_detection`][textract_get_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_get_document_text_detection(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text detection job. The `JobId` is returned
#' from
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' A `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value you can specify is 1,000. If you specify a value greater than
#' 1,000, a maximum of 1,000 results is returned. The default value is
#' 1,000.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         ),
#'         RotationAngle = 123.0
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   DetectDocumentTextModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_document_text_detection(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_document_text_detection
#'
#' @aliases textract_get_document_text_detection
textract_get_document_text_detection <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetDocumentTextDetection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_document_text_detection_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_document_text_detection_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_document_text_detection <- textract_get_document_text_detection

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes invoices and receipts
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes invoices and receipts. Amazon Textract finds contact
#' information, items purchased, and vendor name, from input invoices and
#' receipts.
#' 
#' You start asynchronous invoice/receipt analysis by calling
#' [`start_expense_analysis`][textract_start_expense_analysis], which
#' returns a job identifier (`JobId`). Upon completion of the
#' invoice/receipt analysis, Amazon Textract publishes the completion
#' status to the Amazon Simple Notification Service (Amazon SNS) topic.
#' This topic must be registered in the initial call to
#' [`start_expense_analysis`][textract_start_expense_analysis]. To get the
#' results of the invoice/receipt analysis operation, first ensure that the
#' status value published to the Amazon SNS topic is `SUCCEEDED`. If so,
#' call [`get_expense_analysis`][textract_get_expense_analysis], and pass
#' the job identifier (`JobId`) from the initial call to
#' [`start_expense_analysis`][textract_start_expense_analysis].
#' 
#' Use the MaxResults parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call [`get_expense_analysis`][textract_get_expense_analysis],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_expense_analysis`][textract_get_expense_analysis].
#' 
#' For more information, see [Analyzing Invoices and
#' Receipts](https://docs.aws.amazon.com/textract/latest/dg/invoices-receipts.html).
#'
#' @usage
#' textract_get_expense_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text detection job. The `JobId` is returned
#' from [`start_expense_analysis`][textract_start_expense_analysis]. A
#' `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value you can specify is 20. If you specify a value greater than 20, a
#' maximum of 20 results is returned. The default value is 20.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   ExpenseDocuments = list(
#'     list(
#'       ExpenseIndex = 123,
#'       SummaryFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             Confidence = 123.0
#'           ),
#'           LabelDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               ),
#'               RotationAngle = 123.0
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               ),
#'               RotationAngle = 123.0
#'             ),
#'             Confidence = 123.0
#'           ),
#'           PageNumber = 123,
#'           Currency = list(
#'             Code = "string",
#'             Confidence = 123.0
#'           ),
#'           GroupProperties = list(
#'             list(
#'               Types = list(
#'                 "string"
#'               ),
#'               Id = "string"
#'             )
#'           )
#'         )
#'       ),
#'       LineItemGroups = list(
#'         list(
#'           LineItemGroupIndex = 123,
#'           LineItems = list(
#'             list(
#'               LineItemExpenseFields = list(
#'                 list(
#'                   Type = list(
#'                     Text = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   LabelDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       ),
#'                       RotationAngle = 123.0
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   ValueDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       ),
#'                       RotationAngle = 123.0
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   PageNumber = 123,
#'                   Currency = list(
#'                     Code = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   GroupProperties = list(
#'                     list(
#'                       Types = list(
#'                         "string"
#'                       ),
#'                       Id = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             ),
#'             RotationAngle = 123.0
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeExpenseModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_expense_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_expense_analysis
#'
#' @aliases textract_get_expense_analysis
textract_get_expense_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetExpenseAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_expense_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_expense_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_expense_analysis <- textract_get_expense_analysis

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a lending document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a lending document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_lending_analysis`][textract_start_lending_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#' 
#' To get the results of the text analysis operation, first check that the
#' status value published to the Amazon SNS topic is SUCCEEDED. If so, call
#' GetLendingAnalysis, and pass the job identifier (`JobId`) from the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#'
#' @usage
#' textract_get_lending_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the lending or text-detection job. The `JobId`
#' is returned from
#' [`start_lending_analysis`][textract_start_lending_analysis]. A `JobId`
#' value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value that you can specify is 30. If you specify a value greater than
#' 30, a maximum of 30 results is returned. The default value is 30.
#' @param NextToken If the previous response was incomplete, Amazon Textract returns a
#' pagination token in the response. You can use this pagination token to
#' retrieve the next set of lending results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Results = list(
#'     list(
#'       Page = 123,
#'       PageClassification = list(
#'         PageType = list(
#'           list(
#'             Value = "string",
#'             Confidence = 123.0
#'           )
#'         ),
#'         PageNumber = list(
#'           list(
#'             Value = "string",
#'             Confidence = 123.0
#'           )
#'         )
#'       ),
#'       Extractions = list(
#'         list(
#'           LendingDocument = list(
#'             LendingFields = list(
#'               list(
#'                 Type = "string",
#'                 KeyDetection = list(
#'                   Text = "string",
#'                   SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     ),
#'                     RotationAngle = 123.0
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetections = list(
#'                   list(
#'                     Text = "string",
#'                     SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       ),
#'                       RotationAngle = 123.0
#'                     ),
#'                     Confidence = 123.0
#'                   )
#'                 )
#'               )
#'             ),
#'             SignatureDetections = list(
#'               list(
#'                 Confidence = 123.0,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   ),
#'                   RotationAngle = 123.0
#'                 )
#'               )
#'             )
#'           ),
#'           ExpenseDocument = list(
#'             ExpenseIndex = 123,
#'             SummaryFields = list(
#'               list(
#'                 Type = list(
#'                   Text = "string",
#'                   Confidence = 123.0
#'                 ),
#'                 LabelDetection = list(
#'                   Text = "string",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     ),
#'                     RotationAngle = 123.0
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetection = list(
#'                   Text = "string",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     ),
#'                     RotationAngle = 123.0
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 PageNumber = 123,
#'                 Currency = list(
#'                   Code = "string",
#'                   Confidence = 123.0
#'                 ),
#'                 GroupProperties = list(
#'                   list(
#'                     Types = list(
#'                       "string"
#'                     ),
#'                     Id = "string"
#'                   )
#'                 )
#'               )
#'             ),
#'             LineItemGroups = list(
#'               list(
#'                 LineItemGroupIndex = 123,
#'                 LineItems = list(
#'                   list(
#'                     LineItemExpenseFields = list(
#'                       list(
#'                         Type = list(
#'                           Text = "string",
#'                           Confidence = 123.0
#'                         ),
#'                         LabelDetection = list(
#'                           Text = "string",
#'                           Geometry = list(
#'                             BoundingBox = list(
#'                               Width = 123.0,
#'                               Height = 123.0,
#'                               Left = 123.0,
#'                               Top = 123.0
#'                             ),
#'                             Polygon = list(
#'                               list(
#'                                 X = 123.0,
#'                                 Y = 123.0
#'                               )
#'                             ),
#'                             RotationAngle = 123.0
#'                           ),
#'                           Confidence = 123.0
#'                         ),
#'                         ValueDetection = list(
#'                           Text = "string",
#'                           Geometry = list(
#'                             BoundingBox = list(
#'                               Width = 123.0,
#'                               Height = 123.0,
#'                               Left = 123.0,
#'                               Top = 123.0
#'                             ),
#'                             Polygon = list(
#'                               list(
#'                                 X = 123.0,
#'                                 Y = 123.0
#'                               )
#'                             ),
#'                             RotationAngle = 123.0
#'                           ),
#'                           Confidence = 123.0
#'                         ),
#'                         PageNumber = 123,
#'                         Currency = list(
#'                           Code = "string",
#'                           Confidence = 123.0
#'                         ),
#'                         GroupProperties = list(
#'                           list(
#'                             Types = list(
#'                               "string"
#'                             ),
#'                             Id = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               )
#'             ),
#'             Blocks = list(
#'               list(
#'                 BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'                 Confidence = 123.0,
#'                 Text = "string",
#'                 TextType = "HANDWRITING"|"PRINTED",
#'                 RowIndex = 123,
#'                 ColumnIndex = 123,
#'                 RowSpan = 123,
#'                 ColumnSpan = 123,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   ),
#'                   RotationAngle = 123.0
#'                 ),
#'                 Id = "string",
#'                 Relationships = list(
#'                   list(
#'                     Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                     Ids = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 EntityTypes = list(
#'                   "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'                 ),
#'                 SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                 Page = 123,
#'                 Query = list(
#'                   Text = "string",
#'                   Alias = "string",
#'                   Pages = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           IdentityDocument = list(
#'             DocumentIndex = 123,
#'             IdentityDocumentFields = list(
#'               list(
#'                 Type = list(
#'                   Text = "string",
#'                   NormalizedValue = list(
#'                     Value = "string",
#'                     ValueType = "DATE"
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetection = list(
#'                   Text = "string",
#'                   NormalizedValue = list(
#'                     Value = "string",
#'                     ValueType = "DATE"
#'                   ),
#'                   Confidence = 123.0
#'                 )
#'               )
#'             ),
#'             Blocks = list(
#'               list(
#'                 BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER"|"LAYOUT_TEXT"|"LAYOUT_TITLE"|"LAYOUT_HEADER"|"LAYOUT_FOOTER"|"LAYOUT_SECTION_HEADER"|"LAYOUT_PAGE_NUMBER"|"LAYOUT_LIST"|"LAYOUT_FIGURE"|"LAYOUT_TABLE"|"LAYOUT_KEY_VALUE",
#'                 Confidence = 123.0,
#'                 Text = "string",
#'                 TextType = "HANDWRITING"|"PRINTED",
#'                 RowIndex = 123,
#'                 ColumnIndex = 123,
#'                 RowSpan = 123,
#'                 ColumnSpan = 123,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   ),
#'                   RotationAngle = 123.0
#'                 ),
#'                 Id = "string",
#'                 Relationships = list(
#'                   list(
#'                     Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                     Ids = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 EntityTypes = list(
#'                   "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'                 ),
#'                 SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                 Page = 123,
#'                 Query = list(
#'                   Text = "string",
#'                   Alias = "string",
#'                   Pages = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeLendingModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lending_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_lending_analysis
#'
#' @aliases textract_get_lending_analysis
textract_get_lending_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetLendingAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_lending_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_lending_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_lending_analysis <- textract_get_lending_analysis

#' Gets summarized results for the StartLendingAnalysis operation, which
#' analyzes text in a lending document
#'
#' @description
#' Gets summarized results for the
#' [`start_lending_analysis`][textract_start_lending_analysis] operation,
#' which analyzes text in a lending document. The returned summary consists
#' of information about documents grouped together by a common document
#' type. Information like detected signatures, page numbers, and split
#' documents is returned with respect to the type of grouped document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_lending_analysis`][textract_start_lending_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#' 
#' To get the results of the text analysis operation, first check that the
#' status value published to the Amazon SNS topic is SUCCEEDED. If so, call
#' [`get_lending_analysis_summary`][textract_get_lending_analysis_summary],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#'
#' @usage
#' textract_get_lending_analysis_summary(JobId)
#'
#' @param JobId &#91;required&#93; A unique identifier for the lending or text-detection job. The `JobId`
#' is returned from StartLendingAnalysis. A `JobId` value is only valid for
#' 7 days.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   Summary = list(
#'     DocumentGroups = list(
#'       list(
#'         Type = "string",
#'         SplitDocuments = list(
#'           list(
#'             Index = 123,
#'             Pages = list(
#'               123
#'             )
#'           )
#'         ),
#'         DetectedSignatures = list(
#'           list(
#'             Page = 123
#'           )
#'         ),
#'         UndetectedSignatures = list(
#'           list(
#'             Page = 123
#'           )
#'         )
#'       )
#'     ),
#'     UndetectedDocumentTypes = list(
#'       "string"
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeLendingModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lending_analysis_summary(
#'   JobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_lending_analysis_summary
#'
#' @aliases textract_get_lending_analysis_summary
textract_get_lending_analysis_summary <- function(JobId) {
  op <- new_operation(
    name = "GetLendingAnalysisSummary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$get_lending_analysis_summary_input(JobId = JobId)
  output <- .textract$get_lending_analysis_summary_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_lending_analysis_summary <- textract_get_lending_analysis_summary

#' List all version of an adapter that meet the specified filtration
#' criteria
#'
#' @description
#' List all version of an adapter that meet the specified filtration
#' criteria.
#'
#' @usage
#' textract_list_adapter_versions(AdapterId, AfterCreationTime,
#'   BeforeCreationTime, MaxResults, NextToken)
#'
#' @param AdapterId A string containing a unique ID for the adapter to match for when
#' listing adapter versions.
#' @param AfterCreationTime Specifies the lower bound for the ListAdapterVersions operation. Ensures
#' ListAdapterVersions returns only adapter versions created after the
#' specified creation time.
#' @param BeforeCreationTime Specifies the upper bound for the ListAdapterVersions operation. Ensures
#' ListAdapterVersions returns only adapter versions created after the
#' specified creation time.
#' @param MaxResults The maximum number of results to return when listing adapter versions.
#' @param NextToken Identifies the next page of results to return when listing adapter
#' versions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterVersions = list(
#'     list(
#'       AdapterId = "string",
#'       AdapterVersion = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       FeatureTypes = list(
#'         "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'       ),
#'       Status = "ACTIVE"|"AT_RISK"|"DEPRECATED"|"CREATION_ERROR"|"CREATION_IN_PROGRESS",
#'       StatusMessage = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_adapter_versions(
#'   AdapterId = "string",
#'   AfterCreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BeforeCreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_list_adapter_versions
#'
#' @aliases textract_list_adapter_versions
textract_list_adapter_versions <- function(AdapterId = NULL, AfterCreationTime = NULL, BeforeCreationTime = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListAdapterVersions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "AdapterVersions"),
    stream_api = FALSE
  )
  input <- .textract$list_adapter_versions_input(AdapterId = AdapterId, AfterCreationTime = AfterCreationTime, BeforeCreationTime = BeforeCreationTime, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$list_adapter_versions_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$list_adapter_versions <- textract_list_adapter_versions

#' Lists all adapters that match the specified filtration criteria
#'
#' @description
#' Lists all adapters that match the specified filtration criteria.
#'
#' @usage
#' textract_list_adapters(AfterCreationTime, BeforeCreationTime,
#'   MaxResults, NextToken)
#'
#' @param AfterCreationTime Specifies the lower bound for the ListAdapters operation. Ensures
#' ListAdapters returns only adapters created after the specified creation
#' time.
#' @param BeforeCreationTime Specifies the upper bound for the ListAdapters operation. Ensures
#' ListAdapters returns only adapters created before the specified creation
#' time.
#' @param MaxResults The maximum number of results to return when listing adapters.
#' @param NextToken Identifies the next page of results to return when listing adapters.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Adapters = list(
#'     list(
#'       AdapterId = "string",
#'       AdapterName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       FeatureTypes = list(
#'         "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_adapters(
#'   AfterCreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BeforeCreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_list_adapters
#'
#' @aliases textract_list_adapters
textract_list_adapters <- function(AfterCreationTime = NULL, BeforeCreationTime = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListAdapters",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Adapters"),
    stream_api = FALSE
  )
  input <- .textract$list_adapters_input(AfterCreationTime = AfterCreationTime, BeforeCreationTime = BeforeCreationTime, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$list_adapters_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$list_adapters <- textract_list_adapters

#' Lists all tags for an Amazon Textract resource
#'
#' @description
#' Lists all tags for an Amazon Textract resource.
#'
#' @usage
#' textract_list_tags_for_resource(ResourceARN)
#'
#' @param ResourceARN &#91;required&#93; The Amazon Resource Name (ARN) that specifies the resource to list tags
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_list_tags_for_resource
#'
#' @aliases textract_list_tags_for_resource
textract_list_tags_for_resource <- function(ResourceARN) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$list_tags_for_resource_input(ResourceARN = ResourceARN)
  output <- .textract$list_tags_for_resource_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$list_tags_for_resource <- textract_list_tags_for_resource

#' Starts the asynchronous analysis of an input document for relationships
#' between detected items such as key-value pairs, tables, and selection
#' elements
#'
#' @description
#' Starts the asynchronous analysis of an input document for relationships
#' between detected items such as key-value pairs, tables, and selection
#' elements.
#' 
#' [`start_document_analysis`][textract_start_document_analysis] can
#' analyze text in documents that are in JPEG, PNG, TIFF, and PDF format.
#' The documents are stored in an Amazon S3 bucket. Use DocumentLocation to
#' specify the bucket name and file name of the document.
#' 
#' [`start_document_analysis`][textract_start_document_analysis] returns a
#' job identifier (`JobId`) that you use to get the results of the
#' operation. When text analysis is finished, Amazon Textract publishes a
#' completion status to the Amazon Simple Notification Service (Amazon SNS)
#' topic that you specify in `NotificationChannel`. To get the results of
#' the text analysis operation, first check that the status value published
#' to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_document_analysis`][textract_get_document_analysis], and pass the
#' job identifier (`JobId`) from the initial call to
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_start_document_analysis(DocumentLocation, FeatureTypes,
#'   ClientRequestToken, JobTag, NotificationChannel, OutputConfig, KMSKeyId,
#'   QueriesConfig, AdaptersConfig)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param FeatureTypes &#91;required&#93; A list of the types of analysis to perform. Add TABLES to the list to
#' return information about the tables that are detected in the input
#' document. Add FORMS to return detected form data. To perform both types
#' of analysis, add TABLES and FORMS to `FeatureTypes`. All lines and words
#' detected in the document are included in the response (including text
#' that isn't related to the value of `FeatureTypes`).
#' @param ClientRequestToken The idempotent token that you use to identify the start request. If you
#' use the same token with multiple
#' [`start_document_analysis`][textract_start_document_analysis] requests,
#' the same `JobId` is returned. Use `ClientRequestToken` to prevent the
#' same job from being accidentally started more than once. For more
#' information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html).
#' @param JobTag An identifier that you specify that's included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default,
#' Amazon Textract will save the results internally to be accessed by the
#' GetDocumentAnalysis operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#' @param QueriesConfig 
#' @param AdaptersConfig Specifies the adapter to be used when analyzing a document.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_document_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string",
#'   QueriesConfig = list(
#'     Queries = list(
#'       list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   AdaptersConfig = list(
#'     Adapters = list(
#'       list(
#'         AdapterId = "string",
#'         Pages = list(
#'           "string"
#'         ),
#'         Version = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_document_analysis
#'
#' @aliases textract_start_document_analysis
textract_start_document_analysis <- function(DocumentLocation, FeatureTypes, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL, QueriesConfig = NULL, AdaptersConfig = NULL) {
  op <- new_operation(
    name = "StartDocumentAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$start_document_analysis_input(DocumentLocation = DocumentLocation, FeatureTypes = FeatureTypes, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId, QueriesConfig = QueriesConfig, AdaptersConfig = AdaptersConfig)
  output <- .textract$start_document_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_document_analysis <- textract_start_document_analysis

#' Starts the asynchronous detection of text in a document
#'
#' @description
#' Starts the asynchronous detection of text in a document. Amazon Textract
#' can detect lines of text and the words that make up a line of text.
#' 
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' can analyze text in documents that are in JPEG, PNG, TIFF, and PDF
#' format. The documents are stored in an Amazon S3 bucket. Use
#' DocumentLocation to specify the bucket name and file name of the
#' document.
#' 
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' returns a job identifier (`JobId`) that you use to get the results of
#' the operation. When text detection is finished, Amazon Textract
#' publishes a completion status to the Amazon Simple Notification Service
#' (Amazon SNS) topic that you specify in `NotificationChannel`. To get the
#' results of the text detection operation, first check that the status
#' value published to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_start_document_text_detection(DocumentLocation,
#'   ClientRequestToken, JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param ClientRequestToken The idempotent token that's used to identify the start request. If you
#' use the same token with multiple
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' requests, the same `JobId` is returned. Use `ClientRequestToken` to
#' prevent the same job from being accidentally started more than once. For
#' more information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html).
#' @param JobTag An identifier that you specify that's included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default
#' Amazon Textract will save the results internally to be accessed with the
#' GetDocumentTextDetection operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_document_text_detection(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_document_text_detection
#'
#' @aliases textract_start_document_text_detection
textract_start_document_text_detection <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartDocumentTextDetection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$start_document_text_detection_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_document_text_detection_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_document_text_detection <- textract_start_document_text_detection

#' Starts the asynchronous analysis of invoices or receipts for data like
#' contact information, items purchased, and vendor names
#'
#' @description
#' Starts the asynchronous analysis of invoices or receipts for data like
#' contact information, items purchased, and vendor names.
#' 
#' [`start_expense_analysis`][textract_start_expense_analysis] can analyze
#' text in documents that are in JPEG, PNG, and PDF format. The documents
#' must be stored in an Amazon S3 bucket. Use the DocumentLocation
#' parameter to specify the name of your S3 bucket and the name of the
#' document in that bucket.
#' 
#' [`start_expense_analysis`][textract_start_expense_analysis] returns a
#' job identifier (`JobId`) that you will provide to
#' [`get_expense_analysis`][textract_get_expense_analysis] to retrieve the
#' results of the operation. When the analysis of the input
#' invoices/receipts is finished, Amazon Textract publishes a completion
#' status to the Amazon Simple Notification Service (Amazon SNS) topic that
#' you provide to the `NotificationChannel`. To obtain the results of the
#' invoice and receipt analysis operation, ensure that the status value
#' published to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_expense_analysis`][textract_get_expense_analysis], and pass the
#' job identifier (`JobId`) that was returned by your call to
#' [`start_expense_analysis`][textract_start_expense_analysis].
#' 
#' For more information, see [Analyzing Invoices and
#' Receipts](https://docs.aws.amazon.com/textract/latest/dg/).
#'
#' @usage
#' textract_start_expense_analysis(DocumentLocation, ClientRequestToken,
#'   JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param ClientRequestToken The idempotent token that's used to identify the start request. If you
#' use the same token with multiple
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' requests, the same `JobId` is returned. Use `ClientRequestToken` to
#' prevent the same job from being accidentally started more than once. For
#' more information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html)
#' @param JobTag An identifier you specify that's included in the completion notification
#' published to the Amazon SNS topic. For example, you can use `JobTag` to
#' identify the type of document that the completion notification
#' corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default,
#' Amazon Textract will save the results internally to be accessed by the
#' [`get_expense_analysis`][textract_get_expense_analysis] operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_expense_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_expense_analysis
#'
#' @aliases textract_start_expense_analysis
textract_start_expense_analysis <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartExpenseAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$start_expense_analysis_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_expense_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_expense_analysis <- textract_start_expense_analysis

#' Starts the classification and analysis of an input document
#'
#' @description
#' Starts the classification and analysis of an input document.
#' [`start_lending_analysis`][textract_start_lending_analysis] initiates
#' the classification and analysis of a packet of lending documents.
#' [`start_lending_analysis`][textract_start_lending_analysis] operates on
#' a document file located in an Amazon S3 bucket.
#' 
#' [`start_lending_analysis`][textract_start_lending_analysis] can analyze
#' text in documents that are in one of the following formats: JPEG, PNG,
#' TIFF, PDF. Use `DocumentLocation` to specify the bucket name and the
#' file name of the document.
#' 
#' [`start_lending_analysis`][textract_start_lending_analysis] returns a
#' job identifier (`JobId`) that you use to get the results of the
#' operation. When the text analysis is finished, Amazon Textract publishes
#' a completion status to the Amazon Simple Notification Service (Amazon
#' SNS) topic that you specify in `NotificationChannel`. To get the results
#' of the text analysis operation, first check that the status value
#' published to the Amazon SNS topic is SUCCEEDED. If the status is
#' SUCCEEDED you can call either
#' [`get_lending_analysis`][textract_get_lending_analysis] or
#' [`get_lending_analysis_summary`][textract_get_lending_analysis_summary]
#' and provide the `JobId` to obtain the results of the analysis.
#' 
#' If using `OutputConfig` to specify an Amazon S3 bucket, the output will
#' be contained within the specified prefix in a directory labeled with the
#' job-id. In the directory there are 3 sub-directories:
#' 
#' -   detailedResponse (contains the GetLendingAnalysis response)
#' 
#' -   summaryResponse (for the GetLendingAnalysisSummary response)
#' 
#' -   splitDocuments (documents split across logical boundaries)
#'
#' @usage
#' textract_start_lending_analysis(DocumentLocation, ClientRequestToken,
#'   JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; 
#' @param ClientRequestToken The idempotent token that you use to identify the start request. If you
#' use the same token with multiple
#' [`start_lending_analysis`][textract_start_lending_analysis] requests,
#' the same `JobId` is returned. Use `ClientRequestToken` to prevent the
#' same job from being accidentally started more than once. For more
#' information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/).
#' @param JobTag An identifier that you specify to be included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel 
#' @param OutputConfig 
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side, using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_lending_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_lending_analysis
#'
#' @aliases textract_start_lending_analysis
textract_start_lending_analysis <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartLendingAnalysis",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$start_lending_analysis_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_lending_analysis_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_lending_analysis <- textract_start_lending_analysis

#' Adds one or more tags to the specified resource
#'
#' @description
#' Adds one or more tags to the specified resource.
#'
#' @usage
#' textract_tag_resource(ResourceARN, Tags)
#'
#' @param ResourceARN &#91;required&#93; The Amazon Resource Name (ARN) that specifies the resource to be tagged.
#' @param Tags &#91;required&#93; A set of tags (key-value pairs) that you want to assign to the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceARN = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_tag_resource
#'
#' @aliases textract_tag_resource
textract_tag_resource <- function(ResourceARN, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$tag_resource_input(ResourceARN = ResourceARN, Tags = Tags)
  output <- .textract$tag_resource_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$tag_resource <- textract_tag_resource

#' Removes any tags with the specified keys from the specified resource
#'
#' @description
#' Removes any tags with the specified keys from the specified resource.
#'
#' @usage
#' textract_untag_resource(ResourceARN, TagKeys)
#'
#' @param ResourceARN &#91;required&#93; The Amazon Resource Name (ARN) that specifies the resource to be
#' untagged.
#' @param TagKeys &#91;required&#93; Specifies the tags to be removed from the resource specified by the
#' ResourceARN.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceARN = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_untag_resource
#'
#' @aliases textract_untag_resource
textract_untag_resource <- function(ResourceARN, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$untag_resource_input(ResourceARN = ResourceARN, TagKeys = TagKeys)
  output <- .textract$untag_resource_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$untag_resource <- textract_untag_resource

#' Update the configuration for an adapter
#'
#' @description
#' Update the configuration for an adapter. FeatureTypes configurations
#' cannot be updated. At least one new parameter must be specified as an
#' argument.
#'
#' @usage
#' textract_update_adapter(AdapterId, Description, AdapterName, AutoUpdate)
#'
#' @param AdapterId &#91;required&#93; A string containing a unique ID for the adapter that will be updated.
#' @param Description The new description to be applied to the adapter.
#' @param AdapterName The new name to be applied to the adapter.
#' @param AutoUpdate The new auto-update status to be applied to the adapter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AdapterId = "string",
#'   AdapterName = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"|"LAYOUT"
#'   ),
#'   AutoUpdate = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_adapter(
#'   AdapterId = "string",
#'   Description = "string",
#'   AdapterName = "string",
#'   AutoUpdate = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_update_adapter
#'
#' @aliases textract_update_adapter
textract_update_adapter <- function(AdapterId, Description = NULL, AdapterName = NULL, AutoUpdate = NULL) {
  op <- new_operation(
    name = "UpdateAdapter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .textract$update_adapter_input(AdapterId = AdapterId, Description = Description, AdapterName = AdapterName, AutoUpdate = AutoUpdate)
  output <- .textract$update_adapter_output()
  config <- get_config()
  svc <- .textract$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$update_adapter <- textract_update_adapter

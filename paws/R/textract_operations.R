# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include textract_service.R
NULL

#' Analyzes an input document for relationships between detected items
#'
#' @description
#' Analyzes an input document for relationships between detected items.
#' 
#' The types of information returned are as follows:
#' 
#' -   Form data (key-value pairs). The related information is returned in
#'     two Block objects, each of type `KEY_VALUE_SET`: a KEY `Block`
#'     object and a VALUE `Block` object. For example, *Name: Ana Silva
#'     Carolina* contains a key and value. *Name:* is the key. *Ana Silva
#'     Carolina* is the value.
#' 
#' -   Table and table cell data. A TABLE `Block` object contains
#'     information about a detected table. A CELL `Block` object is
#'     returned for each cell in a table.
#' 
#' -   Lines and words of text. A LINE `Block` object contains one or more
#'     WORD `Block` objects. All lines and words that are detected in the
#'     document are returned (including text that doesn't have a
#'     relationship with the value of `FeatureTypes`).
#' 
#' -   Signatures. A SIGNATURE `Block` object contains the location
#'     information of a signature in a document. If used in conjunction
#'     with forms or tables, a signature can be given a Key-Value pairing
#'     or be detected in the cell of a table.
#' 
#' -   Query. A QUERY Block object contains the query text, alias and link
#'     to the associated Query results block object.
#' 
#' -   Query Result. A QUERY_RESULT Block object contains the answer to the
#'     query and an ID that connects it to the query asked. This Block also
#'     contains a confidence score.
#' 
#' Selection elements such as check boxes and option buttons (radio
#' buttons) can be detected in form data and in tables. A SELECTION_ELEMENT
#' `Block` object contains information about a selection element, including
#' the selection status.
#' 
#' You can choose which type of analysis to perform by specifying the
#' `FeatureTypes` list.
#' 
#' The output is returned in a list of `Block` objects.
#' 
#' [`analyze_document`][textract_analyze_document] is a synchronous
#' operation. To analyze documents asynchronously, use
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_analyze_document(Document, FeatureTypes, HumanLoopConfig,
#'   QueriesConfig)
#'
#' @param Document &#91;required&#93; The input document as base64-encoded bytes or an Amazon S3 object. If
#' you use the AWS CLI to call Amazon Textract operations, you can't pass
#' image bytes. The document must be an image in JPEG, PNG, PDF, or TIFF
#' format.
#' 
#' If you're using an AWS SDK to call Amazon Textract, you might not need
#' to base64-encode image bytes that are passed using the `Bytes` field.
#' @param FeatureTypes &#91;required&#93; A list of the types of analysis to perform. Add TABLES to the list to
#' return information about the tables that are detected in the input
#' document. Add FORMS to return detected form data. Add SIGNATURES to
#' return the locations of detected signatures. To perform both forms and
#' table analysis, add TABLES and FORMS to `FeatureTypes`. To detect
#' signatures within form data and table data, add SIGNATURES to either
#' TABLES or FORMS. All lines and words detected in the document are
#' included in the response (including text that isn't related to the value
#' of `FeatureTypes`).
#' @param HumanLoopConfig Sets the configuration for the human in the loop workflow for analyzing
#' documents.
#' @param QueriesConfig Contains Queries and the alias for those Queries, as determined by the
#' input.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         )
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   HumanLoopActivationOutput = list(
#'     HumanLoopArn = "string",
#'     HumanLoopActivationReasons = list(
#'       "string"
#'     ),
#'     HumanLoopActivationConditionsEvaluationResults = "string"
#'   ),
#'   AnalyzeDocumentModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_document(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"
#'   ),
#'   HumanLoopConfig = list(
#'     HumanLoopName = "string",
#'     FlowDefinitionArn = "string",
#'     DataAttributes = list(
#'       ContentClassifiers = list(
#'         "FreeOfPersonallyIdentifiableInformation"|"FreeOfAdultContent"
#'       )
#'     )
#'   ),
#'   QueriesConfig = list(
#'     Queries = list(
#'       list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_document
#'
#' @aliases textract_analyze_document
textract_analyze_document <- function(Document, FeatureTypes, HumanLoopConfig = NULL, QueriesConfig = NULL) {
  op <- new_operation(
    name = "AnalyzeDocument",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$analyze_document_input(Document = Document, FeatureTypes = FeatureTypes, HumanLoopConfig = HumanLoopConfig, QueriesConfig = QueriesConfig)
  output <- .textract$analyze_document_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_document <- textract_analyze_document

#' AnalyzeExpense synchronously analyzes an input document for financially
#' related relationships between text
#'
#' @description
#' [`analyze_expense`][textract_analyze_expense] synchronously analyzes an
#' input document for financially related relationships between text.
#' 
#' Information is returned as `ExpenseDocuments` and seperated as follows:
#' 
#' -   `LineItemGroups`- A data set containing `LineItems` which store
#'     information about the lines of text, such as an item purchased and
#'     its price on a receipt.
#' 
#' -   `SummaryFields`- Contains all other information a receipt, such as
#'     header information or the vendors name.
#'
#' @usage
#' textract_analyze_expense(Document)
#'
#' @param Document &#91;required&#93; 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   ExpenseDocuments = list(
#'     list(
#'       ExpenseIndex = 123,
#'       SummaryFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             Confidence = 123.0
#'           ),
#'           LabelDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               )
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               )
#'             ),
#'             Confidence = 123.0
#'           ),
#'           PageNumber = 123,
#'           Currency = list(
#'             Code = "string",
#'             Confidence = 123.0
#'           ),
#'           GroupProperties = list(
#'             list(
#'               Types = list(
#'                 "string"
#'               ),
#'               Id = "string"
#'             )
#'           )
#'         )
#'       ),
#'       LineItemGroups = list(
#'         list(
#'           LineItemGroupIndex = 123,
#'           LineItems = list(
#'             list(
#'               LineItemExpenseFields = list(
#'                 list(
#'                   Type = list(
#'                     Text = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   LabelDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       )
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   ValueDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       )
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   PageNumber = 123,
#'                   Currency = list(
#'                     Code = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   GroupProperties = list(
#'                     list(
#'                       Types = list(
#'                         "string"
#'                       ),
#'                       Id = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             )
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_expense(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_expense
#'
#' @aliases textract_analyze_expense
textract_analyze_expense <- function(Document) {
  op <- new_operation(
    name = "AnalyzeExpense",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$analyze_expense_input(Document = Document)
  output <- .textract$analyze_expense_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_expense <- textract_analyze_expense

#' Analyzes identity documents for relevant information
#'
#' @description
#' Analyzes identity documents for relevant information. This information
#' is extracted and returned as `IdentityDocumentFields`, which records
#' both the normalized field and value of the extracted text. Unlike other
#' Amazon Textract operations, [`analyze_id`][textract_analyze_id] doesn't
#' return any Geometry data.
#'
#' @usage
#' textract_analyze_id(DocumentPages)
#'
#' @param DocumentPages &#91;required&#93; The document being passed to AnalyzeID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   IdentityDocuments = list(
#'     list(
#'       DocumentIndex = 123,
#'       IdentityDocumentFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             NormalizedValue = list(
#'               Value = "string",
#'               ValueType = "DATE"
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             NormalizedValue = list(
#'               Value = "string",
#'               ValueType = "DATE"
#'             ),
#'             Confidence = 123.0
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             )
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   AnalyzeIDModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$analyze_id(
#'   DocumentPages = list(
#'     list(
#'       Bytes = raw,
#'       S3Object = list(
#'         Bucket = "string",
#'         Name = "string",
#'         Version = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_analyze_id
#'
#' @aliases textract_analyze_id
textract_analyze_id <- function(DocumentPages) {
  op <- new_operation(
    name = "AnalyzeID",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$analyze_id_input(DocumentPages = DocumentPages)
  output <- .textract$analyze_id_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$analyze_id <- textract_analyze_id

#' Detects text in the input document
#'
#' @description
#' Detects text in the input document. Amazon Textract can detect lines of
#' text and the words that make up a line of text. The input document must
#' be in one of the following image formats: JPEG, PNG, PDF, or TIFF.
#' [`detect_document_text`][textract_detect_document_text] returns the
#' detected text in an array of Block objects.
#' 
#' Each document page has as an associated `Block` of type PAGE. Each PAGE
#' `Block` object is the parent of LINE `Block` objects that represent the
#' lines of detected text on a page. A LINE `Block` object is a parent for
#' each word that makes up the line. Words are represented by `Block`
#' objects of type WORD.
#' 
#' [`detect_document_text`][textract_detect_document_text] is a synchronous
#' operation. To analyze documents asynchronously, use
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_detect_document_text(Document)
#'
#' @param Document &#91;required&#93; The input document as base64-encoded bytes or an Amazon S3 object. If
#' you use the AWS CLI to call Amazon Textract operations, you can't pass
#' image bytes. The document must be an image in JPEG or PNG format.
#' 
#' If you're using an AWS SDK to call Amazon Textract, you might not need
#' to base64-encode image bytes that are passed using the `Bytes` field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         )
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   DetectDocumentTextModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$detect_document_text(
#'   Document = list(
#'     Bytes = raw,
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_detect_document_text
#'
#' @aliases textract_detect_document_text
textract_detect_document_text <- function(Document) {
  op <- new_operation(
    name = "DetectDocumentText",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$detect_document_text_input(Document = Document)
  output <- .textract$detect_document_text_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$detect_document_text <- textract_detect_document_text

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_document_analysis`][textract_start_document_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_document_analysis`][textract_start_document_analysis]. To get
#' the results of the text-detection operation, first check that the status
#' value published to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_document_analysis`][textract_get_document_analysis], and pass the
#' job identifier (`JobId`) from the initial call to
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' [`get_document_analysis`][textract_get_document_analysis] returns an
#' array of Block objects. The following types of information are returned:
#' 
#' -   Form data (key-value pairs). The related information is returned in
#'     two Block objects, each of type `KEY_VALUE_SET`: a KEY `Block`
#'     object and a VALUE `Block` object. For example, *Name: Ana Silva
#'     Carolina* contains a key and value. *Name:* is the key. *Ana Silva
#'     Carolina* is the value.
#' 
#' -   Table and table cell data. A TABLE `Block` object contains
#'     information about a detected table. A CELL `Block` object is
#'     returned for each cell in a table.
#' 
#' -   Lines and words of text. A LINE `Block` object contains one or more
#'     WORD `Block` objects. All lines and words that are detected in the
#'     document are returned (including text that doesn't have a
#'     relationship with the value of the
#'     [`start_document_analysis`][textract_start_document_analysis]
#'     `FeatureTypes` input parameter).
#' 
#' -   Query. A QUERY Block object contains the query text, alias and link
#'     to the associated Query results block object.
#' 
#' -   Query Results. A QUERY_RESULT Block object contains the answer to
#'     the query and an ID that connects it to the query asked. This Block
#'     also contains a confidence score.
#' 
#' While processing a document with queries, look out for
#' `INVALID_REQUEST_PARAMETERS` output. This indicates that either the per
#' page query limit has been exceeded or that the operation is trying to
#' query a page in the document which doesnâ€™t exist.
#' 
#' Selection elements such as check boxes and option buttons (radio
#' buttons) can be detected in form data and in tables. A SELECTION_ELEMENT
#' `Block` object contains information about a selection element, including
#' the selection status.
#' 
#' Use the `MaxResults` parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call [`get_document_analysis`][textract_get_document_analysis],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_document_analysis`][textract_get_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_get_document_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text-detection job. The `JobId` is returned
#' from [`start_document_analysis`][textract_start_document_analysis]. A
#' `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value that you can specify is 1,000. If you specify a value greater than
#' 1,000, a maximum of 1,000 results is returned. The default value is
#' 1,000.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         )
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeDocumentModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_document_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_document_analysis
#'
#' @aliases textract_get_document_analysis
textract_get_document_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetDocumentAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$get_document_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_document_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_document_analysis <- textract_get_document_analysis

#' Gets the results for an Amazon Textract asynchronous operation that
#' detects text in a document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' detects text in a document. Amazon Textract can detect lines of text and
#' the words that make up a line of text.
#' 
#' You start asynchronous text detection by calling
#' [`start_document_text_detection`][textract_start_document_text_detection],
#' which returns a job identifier (`JobId`). When the text detection
#' operation finishes, Amazon Textract publishes a completion status to the
#' Amazon Simple Notification Service (Amazon SNS) topic that's registered
#' in the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' To get the results of the text-detection operation, first check that the
#' status value published to the Amazon SNS topic is `SUCCEEDED`. If so,
#' call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' [`get_document_text_detection`][textract_get_document_text_detection]
#' returns an array of Block objects.
#' 
#' Each document page has as an associated `Block` of type PAGE. Each PAGE
#' `Block` object is the parent of LINE `Block` objects that represent the
#' lines of detected text on a page. A LINE `Block` object is a parent for
#' each word that makes up the line. Words are represented by `Block`
#' objects of type WORD.
#' 
#' Use the MaxResults parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_document_text_detection`][textract_get_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_get_document_text_detection(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text detection job. The `JobId` is returned
#' from
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' A `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value you can specify is 1,000. If you specify a value greater than
#' 1,000, a maximum of 1,000 results is returned. The default value is
#' 1,000.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Blocks = list(
#'     list(
#'       BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'       Confidence = 123.0,
#'       Text = "string",
#'       TextType = "HANDWRITING"|"PRINTED",
#'       RowIndex = 123,
#'       ColumnIndex = 123,
#'       RowSpan = 123,
#'       ColumnSpan = 123,
#'       Geometry = list(
#'         BoundingBox = list(
#'           Width = 123.0,
#'           Height = 123.0,
#'           Left = 123.0,
#'           Top = 123.0
#'         ),
#'         Polygon = list(
#'           list(
#'             X = 123.0,
#'             Y = 123.0
#'           )
#'         )
#'       ),
#'       Id = "string",
#'       Relationships = list(
#'         list(
#'           Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Ids = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       EntityTypes = list(
#'         "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'       ),
#'       SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'       Page = 123,
#'       Query = list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   DetectDocumentTextModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_document_text_detection(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_document_text_detection
#'
#' @aliases textract_get_document_text_detection
textract_get_document_text_detection <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetDocumentTextDetection",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$get_document_text_detection_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_document_text_detection_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_document_text_detection <- textract_get_document_text_detection

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes invoices and receipts
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes invoices and receipts. Amazon Textract finds contact
#' information, items purchased, and vendor name, from input invoices and
#' receipts.
#' 
#' You start asynchronous invoice/receipt analysis by calling
#' [`start_expense_analysis`][textract_start_expense_analysis], which
#' returns a job identifier (`JobId`). Upon completion of the
#' invoice/receipt analysis, Amazon Textract publishes the completion
#' status to the Amazon Simple Notification Service (Amazon SNS) topic.
#' This topic must be registered in the initial call to
#' [`start_expense_analysis`][textract_start_expense_analysis]. To get the
#' results of the invoice/receipt analysis operation, first ensure that the
#' status value published to the Amazon SNS topic is `SUCCEEDED`. If so,
#' call [`get_expense_analysis`][textract_get_expense_analysis], and pass
#' the job identifier (`JobId`) from the initial call to
#' [`start_expense_analysis`][textract_start_expense_analysis].
#' 
#' Use the MaxResults parameter to limit the number of blocks that are
#' returned. If there are more results than specified in `MaxResults`, the
#' value of `NextToken` in the operation response contains a pagination
#' token for getting the next set of results. To get the next page of
#' results, call [`get_expense_analysis`][textract_get_expense_analysis],
#' and populate the `NextToken` request parameter with the token value
#' that's returned from the previous call to
#' [`get_expense_analysis`][textract_get_expense_analysis].
#' 
#' For more information, see [Analyzing Invoices and
#' Receipts](https://docs.aws.amazon.com/textract/latest/dg/invoices-receipts.html).
#'
#' @usage
#' textract_get_expense_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the text detection job. The `JobId` is returned
#' from [`start_expense_analysis`][textract_start_expense_analysis]. A
#' `JobId` value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value you can specify is 20. If you specify a value greater than 20, a
#' maximum of 20 results is returned. The default value is 20.
#' @param NextToken If the previous response was incomplete (because there are more blocks
#' to retrieve), Amazon Textract returns a pagination token in the
#' response. You can use this pagination token to retrieve the next set of
#' blocks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   ExpenseDocuments = list(
#'     list(
#'       ExpenseIndex = 123,
#'       SummaryFields = list(
#'         list(
#'           Type = list(
#'             Text = "string",
#'             Confidence = 123.0
#'           ),
#'           LabelDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               )
#'             ),
#'             Confidence = 123.0
#'           ),
#'           ValueDetection = list(
#'             Text = "string",
#'             Geometry = list(
#'               BoundingBox = list(
#'                 Width = 123.0,
#'                 Height = 123.0,
#'                 Left = 123.0,
#'                 Top = 123.0
#'               ),
#'               Polygon = list(
#'                 list(
#'                   X = 123.0,
#'                   Y = 123.0
#'                 )
#'               )
#'             ),
#'             Confidence = 123.0
#'           ),
#'           PageNumber = 123,
#'           Currency = list(
#'             Code = "string",
#'             Confidence = 123.0
#'           ),
#'           GroupProperties = list(
#'             list(
#'               Types = list(
#'                 "string"
#'               ),
#'               Id = "string"
#'             )
#'           )
#'         )
#'       ),
#'       LineItemGroups = list(
#'         list(
#'           LineItemGroupIndex = 123,
#'           LineItems = list(
#'             list(
#'               LineItemExpenseFields = list(
#'                 list(
#'                   Type = list(
#'                     Text = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   LabelDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       )
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   ValueDetection = list(
#'                     Text = "string",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       )
#'                     ),
#'                     Confidence = 123.0
#'                   ),
#'                   PageNumber = 123,
#'                   Currency = list(
#'                     Code = "string",
#'                     Confidence = 123.0
#'                   ),
#'                   GroupProperties = list(
#'                     list(
#'                       Types = list(
#'                         "string"
#'                       ),
#'                       Id = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Blocks = list(
#'         list(
#'           BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'           Confidence = 123.0,
#'           Text = "string",
#'           TextType = "HANDWRITING"|"PRINTED",
#'           RowIndex = 123,
#'           ColumnIndex = 123,
#'           RowSpan = 123,
#'           ColumnSpan = 123,
#'           Geometry = list(
#'             BoundingBox = list(
#'               Width = 123.0,
#'               Height = 123.0,
#'               Left = 123.0,
#'               Top = 123.0
#'             ),
#'             Polygon = list(
#'               list(
#'                 X = 123.0,
#'                 Y = 123.0
#'               )
#'             )
#'           ),
#'           Id = "string",
#'           Relationships = list(
#'             list(
#'               Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'               Ids = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           EntityTypes = list(
#'             "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'           ),
#'           SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'           Page = 123,
#'           Query = list(
#'             Text = "string",
#'             Alias = "string",
#'             Pages = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeExpenseModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_expense_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_expense_analysis
#'
#' @aliases textract_get_expense_analysis
textract_get_expense_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetExpenseAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$get_expense_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_expense_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_expense_analysis <- textract_get_expense_analysis

#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a lending document
#'
#' @description
#' Gets the results for an Amazon Textract asynchronous operation that
#' analyzes text in a lending document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_lending_analysis`][textract_start_lending_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#' 
#' To get the results of the text analysis operation, first check that the
#' status value published to the Amazon SNS topic is SUCCEEDED. If so, call
#' GetLendingAnalysis, and pass the job identifier (`JobId`) from the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#'
#' @usage
#' textract_get_lending_analysis(JobId, MaxResults, NextToken)
#'
#' @param JobId &#91;required&#93; A unique identifier for the lending or text-detection job. The `JobId`
#' is returned from
#' [`start_lending_analysis`][textract_start_lending_analysis]. A `JobId`
#' value is only valid for 7 days.
#' @param MaxResults The maximum number of results to return per paginated call. The largest
#' value that you can specify is 30. If you specify a value greater than
#' 30, a maximum of 30 results is returned. The default value is 30.
#' @param NextToken If the previous response was incomplete, Amazon Textract returns a
#' pagination token in the response. You can use this pagination token to
#' retrieve the next set of lending results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   NextToken = "string",
#'   Results = list(
#'     list(
#'       Page = 123,
#'       PageClassification = list(
#'         PageType = list(
#'           list(
#'             Value = "string",
#'             Confidence = 123.0
#'           )
#'         ),
#'         PageNumber = list(
#'           list(
#'             Value = "string",
#'             Confidence = 123.0
#'           )
#'         )
#'       ),
#'       Extractions = list(
#'         list(
#'           LendingDocument = list(
#'             LendingFields = list(
#'               list(
#'                 Type = "string",
#'                 KeyDetection = list(
#'                   Text = "string",
#'                   SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     )
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetections = list(
#'                   list(
#'                     Text = "string",
#'                     SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                     Geometry = list(
#'                       BoundingBox = list(
#'                         Width = 123.0,
#'                         Height = 123.0,
#'                         Left = 123.0,
#'                         Top = 123.0
#'                       ),
#'                       Polygon = list(
#'                         list(
#'                           X = 123.0,
#'                           Y = 123.0
#'                         )
#'                       )
#'                     ),
#'                     Confidence = 123.0
#'                   )
#'                 )
#'               )
#'             ),
#'             SignatureDetections = list(
#'               list(
#'                 Confidence = 123.0,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           ExpenseDocument = list(
#'             ExpenseIndex = 123,
#'             SummaryFields = list(
#'               list(
#'                 Type = list(
#'                   Text = "string",
#'                   Confidence = 123.0
#'                 ),
#'                 LabelDetection = list(
#'                   Text = "string",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     )
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetection = list(
#'                   Text = "string",
#'                   Geometry = list(
#'                     BoundingBox = list(
#'                       Width = 123.0,
#'                       Height = 123.0,
#'                       Left = 123.0,
#'                       Top = 123.0
#'                     ),
#'                     Polygon = list(
#'                       list(
#'                         X = 123.0,
#'                         Y = 123.0
#'                       )
#'                     )
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 PageNumber = 123,
#'                 Currency = list(
#'                   Code = "string",
#'                   Confidence = 123.0
#'                 ),
#'                 GroupProperties = list(
#'                   list(
#'                     Types = list(
#'                       "string"
#'                     ),
#'                     Id = "string"
#'                   )
#'                 )
#'               )
#'             ),
#'             LineItemGroups = list(
#'               list(
#'                 LineItemGroupIndex = 123,
#'                 LineItems = list(
#'                   list(
#'                     LineItemExpenseFields = list(
#'                       list(
#'                         Type = list(
#'                           Text = "string",
#'                           Confidence = 123.0
#'                         ),
#'                         LabelDetection = list(
#'                           Text = "string",
#'                           Geometry = list(
#'                             BoundingBox = list(
#'                               Width = 123.0,
#'                               Height = 123.0,
#'                               Left = 123.0,
#'                               Top = 123.0
#'                             ),
#'                             Polygon = list(
#'                               list(
#'                                 X = 123.0,
#'                                 Y = 123.0
#'                               )
#'                             )
#'                           ),
#'                           Confidence = 123.0
#'                         ),
#'                         ValueDetection = list(
#'                           Text = "string",
#'                           Geometry = list(
#'                             BoundingBox = list(
#'                               Width = 123.0,
#'                               Height = 123.0,
#'                               Left = 123.0,
#'                               Top = 123.0
#'                             ),
#'                             Polygon = list(
#'                               list(
#'                                 X = 123.0,
#'                                 Y = 123.0
#'                               )
#'                             )
#'                           ),
#'                           Confidence = 123.0
#'                         ),
#'                         PageNumber = 123,
#'                         Currency = list(
#'                           Code = "string",
#'                           Confidence = 123.0
#'                         ),
#'                         GroupProperties = list(
#'                           list(
#'                             Types = list(
#'                               "string"
#'                             ),
#'                             Id = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               )
#'             ),
#'             Blocks = list(
#'               list(
#'                 BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                 Confidence = 123.0,
#'                 Text = "string",
#'                 TextType = "HANDWRITING"|"PRINTED",
#'                 RowIndex = 123,
#'                 ColumnIndex = 123,
#'                 RowSpan = 123,
#'                 ColumnSpan = 123,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   )
#'                 ),
#'                 Id = "string",
#'                 Relationships = list(
#'                   list(
#'                     Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                     Ids = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 EntityTypes = list(
#'                   "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'                 ),
#'                 SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                 Page = 123,
#'                 Query = list(
#'                   Text = "string",
#'                   Alias = "string",
#'                   Pages = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           IdentityDocument = list(
#'             DocumentIndex = 123,
#'             IdentityDocumentFields = list(
#'               list(
#'                 Type = list(
#'                   Text = "string",
#'                   NormalizedValue = list(
#'                     Value = "string",
#'                     ValueType = "DATE"
#'                   ),
#'                   Confidence = 123.0
#'                 ),
#'                 ValueDetection = list(
#'                   Text = "string",
#'                   NormalizedValue = list(
#'                     Value = "string",
#'                     ValueType = "DATE"
#'                   ),
#'                   Confidence = 123.0
#'                 )
#'               )
#'             ),
#'             Blocks = list(
#'               list(
#'                 BlockType = "KEY_VALUE_SET"|"PAGE"|"LINE"|"WORD"|"TABLE"|"CELL"|"SELECTION_ELEMENT"|"MERGED_CELL"|"TITLE"|"QUERY"|"QUERY_RESULT"|"SIGNATURE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                 Confidence = 123.0,
#'                 Text = "string",
#'                 TextType = "HANDWRITING"|"PRINTED",
#'                 RowIndex = 123,
#'                 ColumnIndex = 123,
#'                 RowSpan = 123,
#'                 ColumnSpan = 123,
#'                 Geometry = list(
#'                   BoundingBox = list(
#'                     Width = 123.0,
#'                     Height = 123.0,
#'                     Left = 123.0,
#'                     Top = 123.0
#'                   ),
#'                   Polygon = list(
#'                     list(
#'                       X = 123.0,
#'                       Y = 123.0
#'                     )
#'                   )
#'                 ),
#'                 Id = "string",
#'                 Relationships = list(
#'                   list(
#'                     Type = "VALUE"|"CHILD"|"COMPLEX_FEATURES"|"MERGED_CELL"|"TITLE"|"ANSWER"|"TABLE"|"TABLE_TITLE"|"TABLE_FOOTER",
#'                     Ids = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 EntityTypes = list(
#'                   "KEY"|"VALUE"|"COLUMN_HEADER"|"TABLE_TITLE"|"TABLE_FOOTER"|"TABLE_SECTION_TITLE"|"TABLE_SUMMARY"|"STRUCTURED_TABLE"|"SEMI_STRUCTURED_TABLE"
#'                 ),
#'                 SelectionStatus = "SELECTED"|"NOT_SELECTED",
#'                 Page = 123,
#'                 Query = list(
#'                   Text = "string",
#'                   Alias = "string",
#'                   Pages = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeLendingModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lending_analysis(
#'   JobId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_lending_analysis
#'
#' @aliases textract_get_lending_analysis
textract_get_lending_analysis <- function(JobId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetLendingAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$get_lending_analysis_input(JobId = JobId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .textract$get_lending_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_lending_analysis <- textract_get_lending_analysis

#' Gets summarized results for the StartLendingAnalysis operation, which
#' analyzes text in a lending document
#'
#' @description
#' Gets summarized results for the
#' [`start_lending_analysis`][textract_start_lending_analysis] operation,
#' which analyzes text in a lending document. The returned summary consists
#' of information about documents grouped together by a common document
#' type. Information like detected signatures, page numbers, and split
#' documents is returned with respect to the type of grouped document.
#' 
#' You start asynchronous text analysis by calling
#' [`start_lending_analysis`][textract_start_lending_analysis], which
#' returns a job identifier (`JobId`). When the text analysis operation
#' finishes, Amazon Textract publishes a completion status to the Amazon
#' Simple Notification Service (Amazon SNS) topic that's registered in the
#' initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#' 
#' To get the results of the text analysis operation, first check that the
#' status value published to the Amazon SNS topic is SUCCEEDED. If so, call
#' [`get_lending_analysis_summary`][textract_get_lending_analysis_summary],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_lending_analysis`][textract_start_lending_analysis].
#'
#' @usage
#' textract_get_lending_analysis_summary(JobId)
#'
#' @param JobId &#91;required&#93; A unique identifier for the lending or text-detection job. The `JobId`
#' is returned from StartLendingAnalysis. A `JobId` value is only valid for
#' 7 days.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DocumentMetadata = list(
#'     Pages = 123
#'   ),
#'   JobStatus = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"PARTIAL_SUCCESS",
#'   Summary = list(
#'     DocumentGroups = list(
#'       list(
#'         Type = "string",
#'         SplitDocuments = list(
#'           list(
#'             Index = 123,
#'             Pages = list(
#'               123
#'             )
#'           )
#'         ),
#'         DetectedSignatures = list(
#'           list(
#'             Page = 123
#'           )
#'         ),
#'         UndetectedSignatures = list(
#'           list(
#'             Page = 123
#'           )
#'         )
#'       )
#'     ),
#'     UndetectedDocumentTypes = list(
#'       "string"
#'     )
#'   ),
#'   Warnings = list(
#'     list(
#'       ErrorCode = "string",
#'       Pages = list(
#'         123
#'       )
#'     )
#'   ),
#'   StatusMessage = "string",
#'   AnalyzeLendingModelVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lending_analysis_summary(
#'   JobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_get_lending_analysis_summary
#'
#' @aliases textract_get_lending_analysis_summary
textract_get_lending_analysis_summary <- function(JobId) {
  op <- new_operation(
    name = "GetLendingAnalysisSummary",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$get_lending_analysis_summary_input(JobId = JobId)
  output <- .textract$get_lending_analysis_summary_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$get_lending_analysis_summary <- textract_get_lending_analysis_summary

#' Starts the asynchronous analysis of an input document for relationships
#' between detected items such as key-value pairs, tables, and selection
#' elements
#'
#' @description
#' Starts the asynchronous analysis of an input document for relationships
#' between detected items such as key-value pairs, tables, and selection
#' elements.
#' 
#' [`start_document_analysis`][textract_start_document_analysis] can
#' analyze text in documents that are in JPEG, PNG, TIFF, and PDF format.
#' The documents are stored in an Amazon S3 bucket. Use DocumentLocation to
#' specify the bucket name and file name of the document.
#' 
#' [`start_document_analysis`][textract_start_document_analysis] returns a
#' job identifier (`JobId`) that you use to get the results of the
#' operation. When text analysis is finished, Amazon Textract publishes a
#' completion status to the Amazon Simple Notification Service (Amazon SNS)
#' topic that you specify in `NotificationChannel`. To get the results of
#' the text analysis operation, first check that the status value published
#' to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_document_analysis`][textract_get_document_analysis], and pass the
#' job identifier (`JobId`) from the initial call to
#' [`start_document_analysis`][textract_start_document_analysis].
#' 
#' For more information, see [Document Text
#' Analysis](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-analyzing.html).
#'
#' @usage
#' textract_start_document_analysis(DocumentLocation, FeatureTypes,
#'   ClientRequestToken, JobTag, NotificationChannel, OutputConfig, KMSKeyId,
#'   QueriesConfig)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param FeatureTypes &#91;required&#93; A list of the types of analysis to perform. Add TABLES to the list to
#' return information about the tables that are detected in the input
#' document. Add FORMS to return detected form data. To perform both types
#' of analysis, add TABLES and FORMS to `FeatureTypes`. All lines and words
#' detected in the document are included in the response (including text
#' that isn't related to the value of `FeatureTypes`).
#' @param ClientRequestToken The idempotent token that you use to identify the start request. If you
#' use the same token with multiple
#' [`start_document_analysis`][textract_start_document_analysis] requests,
#' the same `JobId` is returned. Use `ClientRequestToken` to prevent the
#' same job from being accidentally started more than once. For more
#' information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html).
#' @param JobTag An identifier that you specify that's included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default,
#' Amazon Textract will save the results internally to be accessed by the
#' GetDocumentAnalysis operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#' @param QueriesConfig 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_document_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   FeatureTypes = list(
#'     "TABLES"|"FORMS"|"QUERIES"|"SIGNATURES"
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string",
#'   QueriesConfig = list(
#'     Queries = list(
#'       list(
#'         Text = "string",
#'         Alias = "string",
#'         Pages = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_document_analysis
#'
#' @aliases textract_start_document_analysis
textract_start_document_analysis <- function(DocumentLocation, FeatureTypes, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL, QueriesConfig = NULL) {
  op <- new_operation(
    name = "StartDocumentAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$start_document_analysis_input(DocumentLocation = DocumentLocation, FeatureTypes = FeatureTypes, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId, QueriesConfig = QueriesConfig)
  output <- .textract$start_document_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_document_analysis <- textract_start_document_analysis

#' Starts the asynchronous detection of text in a document
#'
#' @description
#' Starts the asynchronous detection of text in a document. Amazon Textract
#' can detect lines of text and the words that make up a line of text.
#' 
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' can analyze text in documents that are in JPEG, PNG, TIFF, and PDF
#' format. The documents are stored in an Amazon S3 bucket. Use
#' DocumentLocation to specify the bucket name and file name of the
#' document.
#' 
#' `StartTextDetection` returns a job identifier (`JobId`) that you use to
#' get the results of the operation. When text detection is finished,
#' Amazon Textract publishes a completion status to the Amazon Simple
#' Notification Service (Amazon SNS) topic that you specify in
#' `NotificationChannel`. To get the results of the text detection
#' operation, first check that the status value published to the Amazon SNS
#' topic is `SUCCEEDED`. If so, call
#' [`get_document_text_detection`][textract_get_document_text_detection],
#' and pass the job identifier (`JobId`) from the initial call to
#' [`start_document_text_detection`][textract_start_document_text_detection].
#' 
#' For more information, see [Document Text
#' Detection](https://docs.aws.amazon.com/textract/latest/dg/how-it-works-detecting.html).
#'
#' @usage
#' textract_start_document_text_detection(DocumentLocation,
#'   ClientRequestToken, JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param ClientRequestToken The idempotent token that's used to identify the start request. If you
#' use the same token with multiple
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' requests, the same `JobId` is returned. Use `ClientRequestToken` to
#' prevent the same job from being accidentally started more than once. For
#' more information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html).
#' @param JobTag An identifier that you specify that's included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default
#' Amazon Textract will save the results internally to be accessed with the
#' GetDocumentTextDetection operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_document_text_detection(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_document_text_detection
#'
#' @aliases textract_start_document_text_detection
textract_start_document_text_detection <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartDocumentTextDetection",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$start_document_text_detection_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_document_text_detection_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_document_text_detection <- textract_start_document_text_detection

#' Starts the asynchronous analysis of invoices or receipts for data like
#' contact information, items purchased, and vendor names
#'
#' @description
#' Starts the asynchronous analysis of invoices or receipts for data like
#' contact information, items purchased, and vendor names.
#' 
#' [`start_expense_analysis`][textract_start_expense_analysis] can analyze
#' text in documents that are in JPEG, PNG, and PDF format. The documents
#' must be stored in an Amazon S3 bucket. Use the DocumentLocation
#' parameter to specify the name of your S3 bucket and the name of the
#' document in that bucket.
#' 
#' [`start_expense_analysis`][textract_start_expense_analysis] returns a
#' job identifier (`JobId`) that you will provide to
#' [`get_expense_analysis`][textract_get_expense_analysis] to retrieve the
#' results of the operation. When the analysis of the input
#' invoices/receipts is finished, Amazon Textract publishes a completion
#' status to the Amazon Simple Notification Service (Amazon SNS) topic that
#' you provide to the `NotificationChannel`. To obtain the results of the
#' invoice and receipt analysis operation, ensure that the status value
#' published to the Amazon SNS topic is `SUCCEEDED`. If so, call
#' [`get_expense_analysis`][textract_get_expense_analysis], and pass the
#' job identifier (`JobId`) that was returned by your call to
#' [`start_expense_analysis`][textract_start_expense_analysis].
#' 
#' For more information, see [Analyzing Invoices and
#' Receipts](https://docs.aws.amazon.com/textract/latest/dg/).
#'
#' @usage
#' textract_start_expense_analysis(DocumentLocation, ClientRequestToken,
#'   JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; The location of the document to be processed.
#' @param ClientRequestToken The idempotent token that's used to identify the start request. If you
#' use the same token with multiple
#' [`start_document_text_detection`][textract_start_document_text_detection]
#' requests, the same `JobId` is returned. Use `ClientRequestToken` to
#' prevent the same job from being accidentally started more than once. For
#' more information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/api-async.html)
#' @param JobTag An identifier you specify that's included in the completion notification
#' published to the Amazon SNS topic. For example, you can use `JobTag` to
#' identify the type of document that the completion notification
#' corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel The Amazon SNS topic ARN that you want Amazon Textract to publish the
#' completion status of the operation to.
#' @param OutputConfig Sets if the output will go to a customer defined bucket. By default,
#' Amazon Textract will save the results internally to be accessed by the
#' [`get_expense_analysis`][textract_get_expense_analysis] operation.
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side,using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_expense_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_expense_analysis
#'
#' @aliases textract_start_expense_analysis
textract_start_expense_analysis <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartExpenseAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$start_expense_analysis_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_expense_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_expense_analysis <- textract_start_expense_analysis

#' Starts the classification and analysis of an input document
#'
#' @description
#' Starts the classification and analysis of an input document.
#' [`start_lending_analysis`][textract_start_lending_analysis] initiates
#' the classification and analysis of a packet of lending documents.
#' [`start_lending_analysis`][textract_start_lending_analysis] operates on
#' a document file located in an Amazon S3 bucket.
#' 
#' [`start_lending_analysis`][textract_start_lending_analysis] can analyze
#' text in documents that are in one of the following formats: JPEG, PNG,
#' TIFF, PDF. Use `DocumentLocation` to specify the bucket name and the
#' file name of the document.
#' 
#' [`start_lending_analysis`][textract_start_lending_analysis] returns a
#' job identifier (`JobId`) that you use to get the results of the
#' operation. When the text analysis is finished, Amazon Textract publishes
#' a completion status to the Amazon Simple Notification Service (Amazon
#' SNS) topic that you specify in `NotificationChannel`. To get the results
#' of the text analysis operation, first check that the status value
#' published to the Amazon SNS topic is SUCCEEDED. If the status is
#' SUCCEEDED you can call either
#' [`get_lending_analysis`][textract_get_lending_analysis] or
#' [`get_lending_analysis_summary`][textract_get_lending_analysis_summary]
#' and provide the `JobId` to obtain the results of the analysis.
#' 
#' If using `OutputConfig` to specify an Amazon S3 bucket, the output will
#' be contained within the specified prefix in a directory labeled with the
#' job-id. In the directory there are 3 sub-directories:
#' 
#' -   detailedResponse (contains the GetLendingAnalysis response)
#' 
#' -   summaryResponse (for the GetLendingAnalysisSummary response)
#' 
#' -   splitDocuments (documents split across logical boundaries)
#'
#' @usage
#' textract_start_lending_analysis(DocumentLocation, ClientRequestToken,
#'   JobTag, NotificationChannel, OutputConfig, KMSKeyId)
#'
#' @param DocumentLocation &#91;required&#93; 
#' @param ClientRequestToken The idempotent token that you use to identify the start request. If you
#' use the same token with multiple
#' [`start_lending_analysis`][textract_start_lending_analysis] requests,
#' the same `JobId` is returned. Use `ClientRequestToken` to prevent the
#' same job from being accidentally started more than once. For more
#' information, see [Calling Amazon Textract Asynchronous
#' Operations](https://docs.aws.amazon.com/textract/latest/dg/).
#' @param JobTag An identifier that you specify to be included in the completion
#' notification published to the Amazon SNS topic. For example, you can use
#' `JobTag` to identify the type of document that the completion
#' notification corresponds to (such as a tax form or a receipt).
#' @param NotificationChannel 
#' @param OutputConfig 
#' @param KMSKeyId The KMS key used to encrypt the inference results. This can be in either
#' Key ID or Key Alias format. When a KMS key is provided, the KMS key will
#' be used for server-side encryption of the objects in the customer
#' bucket. When this parameter is not enabled, the result will be encrypted
#' server side, using SSE-S3.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_lending_analysis(
#'   DocumentLocation = list(
#'     S3Object = list(
#'       Bucket = "string",
#'       Name = "string",
#'       Version = "string"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   JobTag = "string",
#'   NotificationChannel = list(
#'     SNSTopicArn = "string",
#'     RoleArn = "string"
#'   ),
#'   OutputConfig = list(
#'     S3Bucket = "string",
#'     S3Prefix = "string"
#'   ),
#'   KMSKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname textract_start_lending_analysis
#'
#' @aliases textract_start_lending_analysis
textract_start_lending_analysis <- function(DocumentLocation, ClientRequestToken = NULL, JobTag = NULL, NotificationChannel = NULL, OutputConfig = NULL, KMSKeyId = NULL) {
  op <- new_operation(
    name = "StartLendingAnalysis",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .textract$start_lending_analysis_input(DocumentLocation = DocumentLocation, ClientRequestToken = ClientRequestToken, JobTag = JobTag, NotificationChannel = NotificationChannel, OutputConfig = OutputConfig, KMSKeyId = KMSKeyId)
  output <- .textract$start_lending_analysis_output()
  config <- get_config()
  svc <- .textract$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.textract$operations$start_lending_analysis <- textract_start_lending_analysis

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include braket_service.R
NULL

#' Cancels an Amazon Braket hybrid job
#'
#' @description
#' Cancels an Amazon Braket hybrid job.
#'
#' @usage
#' braket_cancel_job(jobArn)
#'
#' @param jobArn &#91;required&#93; The ARN of the Amazon Braket hybrid job to cancel.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string",
#'   cancellationStatus = "CANCELLING"|"CANCELLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job(
#'   jobArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_cancel_job
#'
#' @aliases braket_cancel_job
braket_cancel_job <- function(jobArn) {
  op <- new_operation(
    name = "CancelJob",
    http_method = "PUT",
    http_path = "/job/{jobArn}/cancel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$cancel_job_input(jobArn = jobArn)
  output <- .braket$cancel_job_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$cancel_job <- braket_cancel_job

#' Cancels the specified task
#'
#' @description
#' Cancels the specified task.
#'
#' @usage
#' braket_cancel_quantum_task(quantumTaskArn, clientToken)
#'
#' @param quantumTaskArn &#91;required&#93; The ARN of the quantum task to cancel.
#' @param clientToken &#91;required&#93; The client token associated with the cancellation request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   quantumTaskArn = "string",
#'   cancellationStatus = "CANCELLING"|"CANCELLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_quantum_task(
#'   quantumTaskArn = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_cancel_quantum_task
#'
#' @aliases braket_cancel_quantum_task
braket_cancel_quantum_task <- function(quantumTaskArn, clientToken) {
  op <- new_operation(
    name = "CancelQuantumTask",
    http_method = "PUT",
    http_path = "/quantum-task/{quantumTaskArn}/cancel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$cancel_quantum_task_input(quantumTaskArn = quantumTaskArn, clientToken = clientToken)
  output <- .braket$cancel_quantum_task_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$cancel_quantum_task <- braket_cancel_quantum_task

#' Creates an Amazon Braket hybrid job
#'
#' @description
#' Creates an Amazon Braket hybrid job.
#'
#' @usage
#' braket_create_job(clientToken, algorithmSpecification, inputDataConfig,
#'   outputDataConfig, checkpointConfig, jobName, roleArn, stoppingCondition,
#'   instanceConfig, hyperParameters, deviceConfig, tags, associations)
#'
#' @param clientToken &#91;required&#93; The client token associated with this request that guarantees that the
#' request is idempotent.
#' @param algorithmSpecification &#91;required&#93; Definition of the Amazon Braket job to be created. Specifies the
#' container image the job uses and information about the Python scripts
#' used for entry and training.
#' @param inputDataConfig A list of parameters that specify the name and type of input data and
#' where it is located.
#' @param outputDataConfig &#91;required&#93; The path to the S3 location where you want to store hybrid job artifacts
#' and the encryption key used to store them.
#' @param checkpointConfig Information about the output locations for hybrid job checkpoint data.
#' @param jobName &#91;required&#93; The name of the Amazon Braket hybrid job.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of an IAM role that Amazon Braket can
#' assume to perform tasks on behalf of a user. It can access user
#' resources, run an Amazon Braket job container on behalf of user, and
#' output results and hybrid job details to the users' s3 buckets.
#' @param stoppingCondition The user-defined criteria that specifies when a hybrid job stops
#' running.
#' @param instanceConfig &#91;required&#93; Configuration of the resource instances to use while running the hybrid
#' job on Amazon Braket.
#' @param hyperParameters Algorithm-specific parameters used by an Amazon Braket hybrid job that
#' influence the quality of the training job. The values are set with a map
#' of JSON key:value pairs, where the key is the name of the hyperparameter
#' and the value is the value of the hyperparameter.
#' 
#' Do not include any security-sensitive information including account
#' access IDs, secrets, or tokens in any hyperparameter fields. As part of
#' the shared responsibility model, you are responsible for any potential
#' exposure, unauthorized access, or compromise of your sensitive data if
#' caused by security-sensitive information included in the request
#' hyperparameter variable or plain text fields.
#' @param deviceConfig &#91;required&#93; The quantum processing unit (QPU) or simulator used to create an Amazon
#' Braket hybrid job.
#' @param tags Tags to be added to the hybrid job you're creating.
#' @param associations The list of Amazon Braket resources associated with the hybrid job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_job(
#'   clientToken = "string",
#'   algorithmSpecification = list(
#'     scriptModeConfig = list(
#'       entryPoint = "string",
#'       s3Uri = "string",
#'       compressionType = "NONE"|"GZIP"
#'     ),
#'     containerImage = list(
#'       uri = "string"
#'     )
#'   ),
#'   inputDataConfig = list(
#'     list(
#'       channelName = "string",
#'       contentType = "string",
#'       dataSource = list(
#'         s3DataSource = list(
#'           s3Uri = "string"
#'         )
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     kmsKeyId = "string",
#'     s3Path = "string"
#'   ),
#'   checkpointConfig = list(
#'     localPath = "string",
#'     s3Uri = "string"
#'   ),
#'   jobName = "string",
#'   roleArn = "string",
#'   stoppingCondition = list(
#'     maxRuntimeInSeconds = 123
#'   ),
#'   instanceConfig = list(
#'     instanceType = "ml.m4.xlarge"|"ml.m4.2xlarge"|"ml.m4.4xlarge"|"ml.m4.10xlarge"|"ml.m4.16xlarge"|"ml.g4dn.xlarge"|"ml.g4dn.2xlarge"|"ml.g4dn.4xlarge"|"ml.g4dn.8xlarge"|"ml.g4dn.12xlarge"|"ml.g4dn.16xlarge"|"ml.m5.large"|"ml.m5.xlarge"|"ml.m5.2xlarge"|"ml.m5.4xlarge"|"ml.m5.12xlarge"|"ml.m5.24xlarge"|"ml.c4.xlarge"|"ml.c4.2xlarge"|"ml.c4.4xlarge"|"ml.c4.8xlarge"|"ml.p2.xlarge"|"ml.p2.8xlarge"|"ml.p2.16xlarge"|"ml.p3.2xlarge"|"ml.p3.8xlarge"|"ml.p3.16xlarge"|"ml.p3dn.24xlarge"|"ml.p4d.24xlarge"|"ml.c5.xlarge"|"ml.c5.2xlarge"|"ml.c5.4xlarge"|"ml.c5.9xlarge"|"ml.c5.18xlarge"|"ml.c5n.xlarge"|"ml.c5n.2xlarge"|"ml.c5n.4xlarge"|"ml.c5n.9xlarge"|"ml.c5n.18xlarge",
#'     volumeSizeInGb = 123,
#'     instanceCount = 123
#'   ),
#'   hyperParameters = list(
#'     "string"
#'   ),
#'   deviceConfig = list(
#'     device = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   associations = list(
#'     list(
#'       arn = "string",
#'       type = "RESERVATION_TIME_WINDOW_ARN"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_create_job
#'
#' @aliases braket_create_job
braket_create_job <- function(clientToken, algorithmSpecification, inputDataConfig = NULL, outputDataConfig, checkpointConfig = NULL, jobName, roleArn, stoppingCondition = NULL, instanceConfig, hyperParameters = NULL, deviceConfig, tags = NULL, associations = NULL) {
  op <- new_operation(
    name = "CreateJob",
    http_method = "POST",
    http_path = "/job",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$create_job_input(clientToken = clientToken, algorithmSpecification = algorithmSpecification, inputDataConfig = inputDataConfig, outputDataConfig = outputDataConfig, checkpointConfig = checkpointConfig, jobName = jobName, roleArn = roleArn, stoppingCondition = stoppingCondition, instanceConfig = instanceConfig, hyperParameters = hyperParameters, deviceConfig = deviceConfig, tags = tags, associations = associations)
  output <- .braket$create_job_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$create_job <- braket_create_job

#' Creates a quantum task
#'
#' @description
#' Creates a quantum task.
#'
#' @usage
#' braket_create_quantum_task(clientToken, deviceArn, deviceParameters,
#'   shots, outputS3Bucket, outputS3KeyPrefix, action, tags, jobToken,
#'   associations, experimentalCapabilities)
#'
#' @param clientToken &#91;required&#93; The client token associated with the request.
#' @param deviceArn &#91;required&#93; The ARN of the device to run the quantum task on.
#' @param deviceParameters The parameters for the device to run the quantum task on.
#' @param shots &#91;required&#93; The number of shots to use for the quantum task.
#' @param outputS3Bucket &#91;required&#93; The S3 bucket to store quantum task result files in.
#' @param outputS3KeyPrefix &#91;required&#93; The key prefix for the location in the S3 bucket to store quantum task
#' results in.
#' @param action &#91;required&#93; The action associated with the quantum task.
#' @param tags Tags to be added to the quantum task you're creating.
#' @param jobToken The token for an Amazon Braket hybrid job that associates it with the
#' quantum task.
#' @param associations The list of Amazon Braket resources associated with the quantum task.
#' @param experimentalCapabilities Enable experimental capabilities for the quantum task.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   quantumTaskArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_quantum_task(
#'   clientToken = "string",
#'   deviceArn = "string",
#'   deviceParameters = "string",
#'   shots = 123,
#'   outputS3Bucket = "string",
#'   outputS3KeyPrefix = "string",
#'   action = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   jobToken = "string",
#'   associations = list(
#'     list(
#'       arn = "string",
#'       type = "RESERVATION_TIME_WINDOW_ARN"
#'     )
#'   ),
#'   experimentalCapabilities = list(
#'     enabled = "ALL"|"NONE"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_create_quantum_task
#'
#' @aliases braket_create_quantum_task
braket_create_quantum_task <- function(clientToken, deviceArn, deviceParameters = NULL, shots, outputS3Bucket, outputS3KeyPrefix, action, tags = NULL, jobToken = NULL, associations = NULL, experimentalCapabilities = NULL) {
  op <- new_operation(
    name = "CreateQuantumTask",
    http_method = "POST",
    http_path = "/quantum-task",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$create_quantum_task_input(clientToken = clientToken, deviceArn = deviceArn, deviceParameters = deviceParameters, shots = shots, outputS3Bucket = outputS3Bucket, outputS3KeyPrefix = outputS3KeyPrefix, action = action, tags = tags, jobToken = jobToken, associations = associations, experimentalCapabilities = experimentalCapabilities)
  output <- .braket$create_quantum_task_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$create_quantum_task <- braket_create_quantum_task

#' Creates a spending limit for a specified quantum device
#'
#' @description
#' Creates a spending limit for a specified quantum device. Spending limits
#' help you control costs by setting maximum amounts that can be spent on
#' quantum computing tasks within a specified time period. Simulators do
#' not support spending limits.
#'
#' @usage
#' braket_create_spending_limit(clientToken, deviceArn, spendingLimit,
#'   timePeriod, tags)
#'
#' @param clientToken &#91;required&#93; A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Braket ignores the request, but does not return an
#' error.
#' @param deviceArn &#91;required&#93; The Amazon Resource Name (ARN) of the quantum device to apply the
#' spending limit to.
#' @param spendingLimit &#91;required&#93; The maximum amount that can be spent on the specified device, in USD.
#' @param timePeriod The time period during which the spending limit is active, including
#' start and end dates.
#' @param tags The tags to apply to the spending limit. Each tag consists of a key and
#' an optional value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   spendingLimitArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_spending_limit(
#'   clientToken = "string",
#'   deviceArn = "string",
#'   spendingLimit = "string",
#'   timePeriod = list(
#'     startAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_create_spending_limit
#'
#' @aliases braket_create_spending_limit
braket_create_spending_limit <- function(clientToken, deviceArn, spendingLimit, timePeriod = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateSpendingLimit",
    http_method = "POST",
    http_path = "/spending-limit",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$create_spending_limit_input(clientToken = clientToken, deviceArn = deviceArn, spendingLimit = spendingLimit, timePeriod = timePeriod, tags = tags)
  output <- .braket$create_spending_limit_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$create_spending_limit <- braket_create_spending_limit

#' Deletes an existing spending limit
#'
#' @description
#' Deletes an existing spending limit. This operation permanently removes
#' the spending limit and cannot be undone. After deletion, the associated
#' device becomes unrestricted for spending.
#'
#' @usage
#' braket_delete_spending_limit(spendingLimitArn)
#'
#' @param spendingLimitArn &#91;required&#93; The Amazon Resource Name (ARN) of the spending limit to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_spending_limit(
#'   spendingLimitArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_delete_spending_limit
#'
#' @aliases braket_delete_spending_limit
braket_delete_spending_limit <- function(spendingLimitArn) {
  op <- new_operation(
    name = "DeleteSpendingLimit",
    http_method = "DELETE",
    http_path = "/spending-limit/{spendingLimitArn}/delete",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$delete_spending_limit_input(spendingLimitArn = spendingLimitArn)
  output <- .braket$delete_spending_limit_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$delete_spending_limit <- braket_delete_spending_limit

#' Retrieves the devices available in Amazon Braket
#'
#' @description
#' Retrieves the devices available in Amazon Braket.
#' 
#' For backwards compatibility with older versions of BraketSchemas,
#' OpenQASM information is omitted from GetDevice API calls. To get this
#' information the user-agent needs to present a recent version of the
#' BraketSchemas (1.8.0 or later). The Braket SDK automatically reports
#' this for you. If you do not see OpenQASM results in the GetDevice
#' response when using a Braket SDK, you may need to set AWS_EXECUTION_ENV
#' environment variable to configure user-agent. See the code examples
#' provided below for how to do this for the AWS CLI, Boto3, and the Go,
#' Java, and JavaScript/TypeScript SDKs.
#'
#' @usage
#' braket_get_device(deviceArn)
#'
#' @param deviceArn &#91;required&#93; The ARN of the device to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   deviceArn = "string",
#'   deviceName = "string",
#'   providerName = "string",
#'   deviceType = "QPU"|"SIMULATOR",
#'   deviceStatus = "ONLINE"|"OFFLINE"|"RETIRED",
#'   deviceCapabilities = "string",
#'   deviceQueueInfo = list(
#'     list(
#'       queue = "QUANTUM_TASKS_QUEUE"|"JOBS_QUEUE",
#'       queueSize = "string",
#'       queuePriority = "Normal"|"Priority"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_device(
#'   deviceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_get_device
#'
#' @aliases braket_get_device
braket_get_device <- function(deviceArn) {
  op <- new_operation(
    name = "GetDevice",
    http_method = "GET",
    http_path = "/device/{deviceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$get_device_input(deviceArn = deviceArn)
  output <- .braket$get_device_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$get_device <- braket_get_device

#' Retrieves the specified Amazon Braket hybrid job
#'
#' @description
#' Retrieves the specified Amazon Braket hybrid job.
#'
#' @usage
#' braket_get_job(jobArn, additionalAttributeNames)
#'
#' @param jobArn &#91;required&#93; The ARN of the hybrid job to retrieve.
#' @param additionalAttributeNames A list of attributes to return additional information for. Only the
#' QueueInfo additional attribute name is currently supported.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "QUEUED"|"RUNNING"|"COMPLETED"|"FAILED"|"CANCELLING"|"CANCELLED",
#'   jobArn = "string",
#'   roleArn = "string",
#'   failureReason = "string",
#'   jobName = "string",
#'   hyperParameters = list(
#'     "string"
#'   ),
#'   inputDataConfig = list(
#'     list(
#'       channelName = "string",
#'       contentType = "string",
#'       dataSource = list(
#'         s3DataSource = list(
#'           s3Uri = "string"
#'         )
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     kmsKeyId = "string",
#'     s3Path = "string"
#'   ),
#'   stoppingCondition = list(
#'     maxRuntimeInSeconds = 123
#'   ),
#'   checkpointConfig = list(
#'     localPath = "string",
#'     s3Uri = "string"
#'   ),
#'   algorithmSpecification = list(
#'     scriptModeConfig = list(
#'       entryPoint = "string",
#'       s3Uri = "string",
#'       compressionType = "NONE"|"GZIP"
#'     ),
#'     containerImage = list(
#'       uri = "string"
#'     )
#'   ),
#'   instanceConfig = list(
#'     instanceType = "ml.m4.xlarge"|"ml.m4.2xlarge"|"ml.m4.4xlarge"|"ml.m4.10xlarge"|"ml.m4.16xlarge"|"ml.g4dn.xlarge"|"ml.g4dn.2xlarge"|"ml.g4dn.4xlarge"|"ml.g4dn.8xlarge"|"ml.g4dn.12xlarge"|"ml.g4dn.16xlarge"|"ml.m5.large"|"ml.m5.xlarge"|"ml.m5.2xlarge"|"ml.m5.4xlarge"|"ml.m5.12xlarge"|"ml.m5.24xlarge"|"ml.c4.xlarge"|"ml.c4.2xlarge"|"ml.c4.4xlarge"|"ml.c4.8xlarge"|"ml.p2.xlarge"|"ml.p2.8xlarge"|"ml.p2.16xlarge"|"ml.p3.2xlarge"|"ml.p3.8xlarge"|"ml.p3.16xlarge"|"ml.p3dn.24xlarge"|"ml.p4d.24xlarge"|"ml.c5.xlarge"|"ml.c5.2xlarge"|"ml.c5.4xlarge"|"ml.c5.9xlarge"|"ml.c5.18xlarge"|"ml.c5n.xlarge"|"ml.c5n.2xlarge"|"ml.c5n.4xlarge"|"ml.c5n.9xlarge"|"ml.c5n.18xlarge",
#'     volumeSizeInGb = 123,
#'     instanceCount = 123
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   billableDuration = 123,
#'   deviceConfig = list(
#'     device = "string"
#'   ),
#'   events = list(
#'     list(
#'       eventType = "WAITING_FOR_PRIORITY"|"QUEUED_FOR_EXECUTION"|"STARTING_INSTANCE"|"DOWNLOADING_DATA"|"RUNNING"|"DEPRIORITIZED_DUE_TO_INACTIVITY"|"UPLOADING_RESULTS"|"COMPLETED"|"FAILED"|"MAX_RUNTIME_EXCEEDED"|"CANCELLED",
#'       timeOfEvent = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       message = "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   queueInfo = list(
#'     queue = "QUANTUM_TASKS_QUEUE"|"JOBS_QUEUE",
#'     position = "string",
#'     message = "string"
#'   ),
#'   associations = list(
#'     list(
#'       arn = "string",
#'       type = "RESERVATION_TIME_WINDOW_ARN"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job(
#'   jobArn = "string",
#'   additionalAttributeNames = list(
#'     "QueueInfo"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_get_job
#'
#' @aliases braket_get_job
braket_get_job <- function(jobArn, additionalAttributeNames = NULL) {
  op <- new_operation(
    name = "GetJob",
    http_method = "GET",
    http_path = "/job/{jobArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$get_job_input(jobArn = jobArn, additionalAttributeNames = additionalAttributeNames)
  output <- .braket$get_job_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$get_job <- braket_get_job

#' Retrieves the specified quantum task
#'
#' @description
#' Retrieves the specified quantum task.
#'
#' @usage
#' braket_get_quantum_task(quantumTaskArn, additionalAttributeNames)
#'
#' @param quantumTaskArn &#91;required&#93; The ARN of the quantum task to retrieve.
#' @param additionalAttributeNames A list of attributes to return additional information for. Only the
#' QueueInfo additional attribute name is currently supported.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   quantumTaskArn = "string",
#'   status = "CREATED"|"QUEUED"|"RUNNING"|"COMPLETED"|"FAILED"|"CANCELLING"|"CANCELLED",
#'   failureReason = "string",
#'   deviceArn = "string",
#'   deviceParameters = "string",
#'   shots = 123,
#'   outputS3Bucket = "string",
#'   outputS3Directory = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   jobArn = "string",
#'   queueInfo = list(
#'     queue = "QUANTUM_TASKS_QUEUE"|"JOBS_QUEUE",
#'     position = "string",
#'     queuePriority = "Normal"|"Priority",
#'     message = "string"
#'   ),
#'   associations = list(
#'     list(
#'       arn = "string",
#'       type = "RESERVATION_TIME_WINDOW_ARN"
#'     )
#'   ),
#'   numSuccessfulShots = 123,
#'   actionMetadata = list(
#'     actionType = "string",
#'     programCount = 123,
#'     executableCount = 123
#'   ),
#'   experimentalCapabilities = list(
#'     enabled = "ALL"|"NONE"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_quantum_task(
#'   quantumTaskArn = "string",
#'   additionalAttributeNames = list(
#'     "QueueInfo"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_get_quantum_task
#'
#' @aliases braket_get_quantum_task
braket_get_quantum_task <- function(quantumTaskArn, additionalAttributeNames = NULL) {
  op <- new_operation(
    name = "GetQuantumTask",
    http_method = "GET",
    http_path = "/quantum-task/{quantumTaskArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$get_quantum_task_input(quantumTaskArn = quantumTaskArn, additionalAttributeNames = additionalAttributeNames)
  output <- .braket$get_quantum_task_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$get_quantum_task <- braket_get_quantum_task

#' Shows the tags associated with this resource
#'
#' @description
#' Shows the tags associated with this resource.
#'
#' @usage
#' braket_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; Specify the `resourceArn` for the resource whose tags to display.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_list_tags_for_resource
#'
#' @aliases braket_list_tags_for_resource
braket_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .braket$list_tags_for_resource_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$list_tags_for_resource <- braket_list_tags_for_resource

#' Searches for devices using the specified filters
#'
#' @description
#' Searches for devices using the specified filters.
#'
#' @usage
#' braket_search_devices(nextToken, maxResults, filters)
#'
#' @param nextToken A token used for pagination of results returned in the response. Use the
#' token returned from the previous request to continue search where the
#' previous request ended.
#' @param maxResults The maximum number of results to return in the response.
#' @param filters &#91;required&#93; Array of SearchDevicesFilter objects to use when searching for devices.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   devices = list(
#'     list(
#'       deviceArn = "string",
#'       deviceName = "string",
#'       providerName = "string",
#'       deviceType = "QPU"|"SIMULATOR",
#'       deviceStatus = "ONLINE"|"OFFLINE"|"RETIRED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_devices(
#'   nextToken = "string",
#'   maxResults = 123,
#'   filters = list(
#'     list(
#'       name = "string",
#'       values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_search_devices
#'
#' @aliases braket_search_devices
braket_search_devices <- function(nextToken = NULL, maxResults = NULL, filters) {
  op <- new_operation(
    name = "SearchDevices",
    http_method = "POST",
    http_path = "/devices",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "devices"),
    stream_api = FALSE
  )
  input <- .braket$search_devices_input(nextToken = nextToken, maxResults = maxResults, filters = filters)
  output <- .braket$search_devices_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$search_devices <- braket_search_devices

#' Searches for Amazon Braket hybrid jobs that match the specified filter
#' values
#'
#' @description
#' Searches for Amazon Braket hybrid jobs that match the specified filter
#' values.
#'
#' @usage
#' braket_search_jobs(nextToken, maxResults, filters)
#'
#' @param nextToken A token used for pagination of results returned in the response. Use the
#' token returned from the previous request to continue search where the
#' previous request ended.
#' @param maxResults The maximum number of results to return in the response.
#' @param filters &#91;required&#93; Array of SearchJobsFilter objects to use when searching for hybrid jobs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobs = list(
#'     list(
#'       status = "QUEUED"|"RUNNING"|"COMPLETED"|"FAILED"|"CANCELLING"|"CANCELLED",
#'       jobArn = "string",
#'       jobName = "string",
#'       device = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       startedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_jobs(
#'   nextToken = "string",
#'   maxResults = 123,
#'   filters = list(
#'     list(
#'       name = "string",
#'       values = list(
#'         "string"
#'       ),
#'       operator = "LT"|"LTE"|"EQUAL"|"GT"|"GTE"|"BETWEEN"|"CONTAINS"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_search_jobs
#'
#' @aliases braket_search_jobs
braket_search_jobs <- function(nextToken = NULL, maxResults = NULL, filters) {
  op <- new_operation(
    name = "SearchJobs",
    http_method = "POST",
    http_path = "/jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "jobs"),
    stream_api = FALSE
  )
  input <- .braket$search_jobs_input(nextToken = nextToken, maxResults = maxResults, filters = filters)
  output <- .braket$search_jobs_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$search_jobs <- braket_search_jobs

#' Searches for tasks that match the specified filter values
#'
#' @description
#' Searches for tasks that match the specified filter values.
#'
#' @usage
#' braket_search_quantum_tasks(nextToken, maxResults, filters)
#'
#' @param nextToken A token used for pagination of results returned in the response. Use the
#' token returned from the previous request to continue search where the
#' previous request ended.
#' @param maxResults Maximum number of results to return in the response.
#' @param filters &#91;required&#93; Array of `SearchQuantumTasksFilter` objects to use when searching for
#' quantum tasks.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   quantumTasks = list(
#'     list(
#'       quantumTaskArn = "string",
#'       status = "CREATED"|"QUEUED"|"RUNNING"|"COMPLETED"|"FAILED"|"CANCELLING"|"CANCELLED",
#'       deviceArn = "string",
#'       shots = 123,
#'       outputS3Bucket = "string",
#'       outputS3Directory = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_quantum_tasks(
#'   nextToken = "string",
#'   maxResults = 123,
#'   filters = list(
#'     list(
#'       name = "string",
#'       values = list(
#'         "string"
#'       ),
#'       operator = "LT"|"LTE"|"EQUAL"|"GT"|"GTE"|"BETWEEN"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_search_quantum_tasks
#'
#' @aliases braket_search_quantum_tasks
braket_search_quantum_tasks <- function(nextToken = NULL, maxResults = NULL, filters) {
  op <- new_operation(
    name = "SearchQuantumTasks",
    http_method = "POST",
    http_path = "/quantum-tasks",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "quantumTasks"),
    stream_api = FALSE
  )
  input <- .braket$search_quantum_tasks_input(nextToken = nextToken, maxResults = maxResults, filters = filters)
  output <- .braket$search_quantum_tasks_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$search_quantum_tasks <- braket_search_quantum_tasks

#' Searches and lists spending limits based on specified filters
#'
#' @description
#' Searches and lists spending limits based on specified filters. This
#' operation supports pagination and allows filtering by various criteria
#' to find specific spending limits. We recommend using pagination to
#' ensure that the operation returns quickly and successfully.
#'
#' @usage
#' braket_search_spending_limits(nextToken, maxResults, filters)
#'
#' @param nextToken The token to retrieve the next page of results. This value is returned
#' from a previous call to SearchSpendingLimits when there are more results
#' available.
#' @param maxResults The maximum number of results to return in a single call. Minimum value
#' of 1, maximum value of 100. Default is 20.
#' @param filters The filters to apply when searching for spending limits. Use filters to
#' narrow down the results based on specific criteria.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   spendingLimits = list(
#'     list(
#'       spendingLimitArn = "string",
#'       deviceArn = "string",
#'       timePeriod = list(
#'         startAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         endAt = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       spendingLimit = "string",
#'       queuedSpend = "string",
#'       totalSpend = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_spending_limits(
#'   nextToken = "string",
#'   maxResults = 123,
#'   filters = list(
#'     list(
#'       name = "string",
#'       values = list(
#'         "string"
#'       ),
#'       operator = "EQUAL"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_search_spending_limits
#'
#' @aliases braket_search_spending_limits
braket_search_spending_limits <- function(nextToken = NULL, maxResults = NULL, filters = NULL) {
  op <- new_operation(
    name = "SearchSpendingLimits",
    http_method = "POST",
    http_path = "/spending-limits",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "spendingLimits"),
    stream_api = FALSE
  )
  input <- .braket$search_spending_limits_input(nextToken = nextToken, maxResults = maxResults, filters = filters)
  output <- .braket$search_spending_limits_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$search_spending_limits <- braket_search_spending_limits

#' Add a tag to the specified resource
#'
#' @description
#' Add a tag to the specified resource.
#'
#' @usage
#' braket_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; Specify the `resourceArn` of the resource to which a tag will be added.
#' @param tags &#91;required&#93; Specify the tags to add to the resource. Tags can be specified as a
#' key-value map.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_tag_resource
#'
#' @aliases braket_tag_resource
braket_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .braket$tag_resource_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$tag_resource <- braket_tag_resource

#' Remove tags from a resource
#'
#' @description
#' Remove tags from a resource.
#'
#' @usage
#' braket_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; Specify the `resourceArn` for the resource from which to remove the
#' tags.
#' @param tagKeys &#91;required&#93; Specify the keys for the tags to remove from the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_untag_resource
#'
#' @aliases braket_untag_resource
braket_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .braket$untag_resource_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$untag_resource <- braket_untag_resource

#' Updates an existing spending limit
#'
#' @description
#' Updates an existing spending limit. You can modify the spending amount
#' or time period. Changes take effect immediately.
#'
#' @usage
#' braket_update_spending_limit(spendingLimitArn, clientToken,
#'   spendingLimit, timePeriod)
#'
#' @param spendingLimitArn &#91;required&#93; The Amazon Resource Name (ARN) of the spending limit to update.
#' @param clientToken &#91;required&#93; A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Braket ignores the request, but does not return an
#' error.
#' @param spendingLimit The new maximum amount that can be spent on the specified device, in
#' USD.
#' @param timePeriod The new time period during which the spending limit is active, including
#' start and end dates.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_spending_limit(
#'   spendingLimitArn = "string",
#'   clientToken = "string",
#'   spendingLimit = "string",
#'   timePeriod = list(
#'     startAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname braket_update_spending_limit
#'
#' @aliases braket_update_spending_limit
braket_update_spending_limit <- function(spendingLimitArn, clientToken, spendingLimit = NULL, timePeriod = NULL) {
  op <- new_operation(
    name = "UpdateSpendingLimit",
    http_method = "PATCH",
    http_path = "/spending-limit/{spendingLimitArn}/update",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .braket$update_spending_limit_input(spendingLimitArn = spendingLimitArn, clientToken = clientToken, spendingLimit = spendingLimit, timePeriod = timePeriod)
  output <- .braket$update_spending_limit_output()
  config <- get_config()
  svc <- .braket$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.braket$operations$update_spending_limit <- braket_update_spending_limit

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include omics_service.R
NULL

#' Stops a multipart upload
#'
#' @description
#' Stops a multipart upload.
#'
#' @usage
#' omics_abort_multipart_read_set_upload(sequenceStoreId, uploadId)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store involved in the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the multipart upload.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$abort_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   uploadId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_abort_multipart_read_set_upload
#'
#' @aliases omics_abort_multipart_read_set_upload
omics_abort_multipart_read_set_upload <- function(sequenceStoreId, uploadId) {
  op <- new_operation(
    name = "AbortMultipartReadSetUpload",
    http_method = "DELETE",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/abort",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$abort_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId)
  output <- .omics$abort_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$abort_multipart_read_set_upload <- omics_abort_multipart_read_set_upload

#' Accept a resource share request
#'
#' @description
#' Accept a resource share request.
#'
#' @usage
#' omics_accept_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID of the resource share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$accept_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_accept_share
#'
#' @aliases omics_accept_share
omics_accept_share <- function(shareId) {
  op <- new_operation(
    name = "AcceptShare",
    http_method = "POST",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$accept_share_input(shareId = shareId)
  output <- .omics$accept_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$accept_share <- omics_accept_share

#' Deletes one or more read sets
#'
#' @description
#' Deletes one or more read sets.
#'
#' @usage
#' omics_batch_delete_read_set(ids, sequenceStoreId)
#'
#' @param ids &#91;required&#93; The read sets' IDs.
#' @param sequenceStoreId &#91;required&#93; The read sets' sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       id = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_read_set(
#'   ids = list(
#'     "string"
#'   ),
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_batch_delete_read_set
#'
#' @aliases omics_batch_delete_read_set
omics_batch_delete_read_set <- function(ids, sequenceStoreId) {
  op <- new_operation(
    name = "BatchDeleteReadSet",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/readset/batch/delete",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$batch_delete_read_set_input(ids = ids, sequenceStoreId = sequenceStoreId)
  output <- .omics$batch_delete_read_set_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$batch_delete_read_set <- omics_batch_delete_read_set

#' Cancels an annotation import job
#'
#' @description
#' Cancels an annotation import job.
#'
#' @usage
#' omics_cancel_annotation_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_annotation_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_annotation_import_job
#'
#' @aliases omics_cancel_annotation_import_job
omics_cancel_annotation_import_job <- function(jobId) {
  op <- new_operation(
    name = "CancelAnnotationImportJob",
    http_method = "DELETE",
    http_path = "/import/annotation/{jobId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$cancel_annotation_import_job_input(jobId = jobId)
  output <- .omics$cancel_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_annotation_import_job <- omics_cancel_annotation_import_job

#' Cancels a run
#'
#' @description
#' Cancels a run.
#'
#' @usage
#' omics_cancel_run(id)
#'
#' @param id &#91;required&#93; The run's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_run(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_run
#'
#' @aliases omics_cancel_run
omics_cancel_run <- function(id) {
  op <- new_operation(
    name = "CancelRun",
    http_method = "POST",
    http_path = "/run/{id}/cancel",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$cancel_run_input(id = id)
  output <- .omics$cancel_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_run <- omics_cancel_run

#' Cancels a variant import job
#'
#' @description
#' Cancels a variant import job.
#'
#' @usage
#' omics_cancel_variant_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_variant_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_variant_import_job
#'
#' @aliases omics_cancel_variant_import_job
omics_cancel_variant_import_job <- function(jobId) {
  op <- new_operation(
    name = "CancelVariantImportJob",
    http_method = "DELETE",
    http_path = "/import/variant/{jobId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$cancel_variant_import_job_input(jobId = jobId)
  output <- .omics$cancel_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_variant_import_job <- omics_cancel_variant_import_job

#' Concludes a multipart upload once you have uploaded all the components
#'
#' @description
#' Concludes a multipart upload once you have uploaded all the components.
#'
#' @usage
#' omics_complete_multipart_read_set_upload(sequenceStoreId, uploadId,
#'   parts)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store involved in the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the multipart upload.
#' @param parts &#91;required&#93; The individual uploads or parts of a multipart upload.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   readSetId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$complete_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   parts = list(
#'     list(
#'       partNumber = 123,
#'       partSource = "SOURCE1"|"SOURCE2",
#'       checksum = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_complete_multipart_read_set_upload
#'
#' @aliases omics_complete_multipart_read_set_upload
omics_complete_multipart_read_set_upload <- function(sequenceStoreId, uploadId, parts) {
  op <- new_operation(
    name = "CompleteMultipartReadSetUpload",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/complete",
    host_prefix = "storage-",
    paginator = list()
  )
  input <- .omics$complete_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, parts = parts)
  output <- .omics$complete_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$complete_multipart_read_set_upload <- omics_complete_multipart_read_set_upload

#' Creates an annotation store
#'
#' @description
#' Creates an annotation store.
#'
#' @usage
#' omics_create_annotation_store(reference, name, description, tags,
#'   versionName, sseConfig, storeFormat, storeOptions)
#'
#' @param reference The genome reference for the store's annotations.
#' @param name A name for the store.
#' @param description A description for the store.
#' @param tags Tags for the store.
#' @param versionName The name given to an annotation store version to distinguish it from
#' other versions.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param storeFormat &#91;required&#93; The annotation file format of the store.
#' @param storeOptions File parsing options for the annotation store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   versionName = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_annotation_store(
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   versionName = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_annotation_store
#'
#' @aliases omics_create_annotation_store
omics_create_annotation_store <- function(reference = NULL, name = NULL, description = NULL, tags = NULL, versionName = NULL, sseConfig = NULL, storeFormat, storeOptions = NULL) {
  op <- new_operation(
    name = "CreateAnnotationStore",
    http_method = "POST",
    http_path = "/annotationStore",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$create_annotation_store_input(reference = reference, name = name, description = description, tags = tags, versionName = versionName, sseConfig = sseConfig, storeFormat = storeFormat, storeOptions = storeOptions)
  output <- .omics$create_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_annotation_store <- omics_create_annotation_store

#' Creates a new version of an annotation store
#'
#' @description
#' Creates a new version of an annotation store.
#'
#' @usage
#' omics_create_annotation_store_version(name, versionName, description,
#'   versionOptions, tags)
#'
#' @param name &#91;required&#93; The name of an annotation store version from which versions are being
#' created.
#' @param versionName &#91;required&#93; The name given to an annotation store version to distinguish it from
#' other versions.
#' @param description The description of an annotation store version.
#' @param versionOptions The options for an annotation store version.
#' @param tags Any tags added to annotation store version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   versionName = "string",
#'   storeId = "string",
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   name = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_annotation_store_version(
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_annotation_store_version
#'
#' @aliases omics_create_annotation_store_version
omics_create_annotation_store_version <- function(name, versionName, description = NULL, versionOptions = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateAnnotationStoreVersion",
    http_method = "POST",
    http_path = "/annotationStore/{name}/version",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$create_annotation_store_version_input(name = name, versionName = versionName, description = description, versionOptions = versionOptions, tags = tags)
  output <- .omics$create_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_annotation_store_version <- omics_create_annotation_store_version

#' Begins a multipart read set upload
#'
#' @description
#' Begins a multipart read set upload.
#'
#' @usage
#' omics_create_multipart_read_set_upload(sequenceStoreId, clientToken,
#'   sourceFileType, subjectId, sampleId, generatedFrom, referenceArn, name,
#'   description, tags)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store that is the destination of the
#' multipart uploads.
#' @param clientToken An idempotency token that can be used to avoid triggering multiple
#' multipart uploads.
#' @param sourceFileType &#91;required&#93; The type of file being uploaded.
#' @param subjectId &#91;required&#93; The source's subject ID.
#' @param sampleId &#91;required&#93; The source's sample ID.
#' @param generatedFrom Where the source originated.
#' @param referenceArn The ARN of the reference.
#' @param name &#91;required&#93; The name of the read set.
#' @param description The description of the read set.
#' @param tags Any tags to add to the read set.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   subjectId = "string",
#'   sampleId = "string",
#'   generatedFrom = "string",
#'   referenceArn = "string",
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   clientToken = "string",
#'   sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   subjectId = "string",
#'   sampleId = "string",
#'   generatedFrom = "string",
#'   referenceArn = "string",
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_multipart_read_set_upload
#'
#' @aliases omics_create_multipart_read_set_upload
omics_create_multipart_read_set_upload <- function(sequenceStoreId, clientToken = NULL, sourceFileType, subjectId, sampleId, generatedFrom = NULL, referenceArn = NULL, name, description = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateMultipartReadSetUpload",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$create_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, clientToken = clientToken, sourceFileType = sourceFileType, subjectId = subjectId, sampleId = sampleId, generatedFrom = generatedFrom, referenceArn = referenceArn, name = name, description = description, tags = tags)
  output <- .omics$create_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_multipart_read_set_upload <- omics_create_multipart_read_set_upload

#' Creates a reference store
#'
#' @description
#' Creates a reference store.
#'
#' @usage
#' omics_create_reference_store(name, description, sseConfig, tags,
#'   clientToken)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param tags Tags for the store.
#' @param clientToken To ensure that requests don't run multiple times, specify a unique token
#' for each request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_reference_store(
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_reference_store
#'
#' @aliases omics_create_reference_store
omics_create_reference_store <- function(name, description = NULL, sseConfig = NULL, tags = NULL, clientToken = NULL) {
  op <- new_operation(
    name = "CreateReferenceStore",
    http_method = "POST",
    http_path = "/referencestore",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$create_reference_store_input(name = name, description = description, sseConfig = sseConfig, tags = tags, clientToken = clientToken)
  output <- .omics$create_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_reference_store <- omics_create_reference_store

#' You can optionally create a run group to limit the compute resources for
#' the runs that you add to the group
#'
#' @description
#' You can optionally create a run group to limit the compute resources for
#' the runs that you add to the group.
#'
#' @usage
#' omics_create_run_group(name, maxCpus, maxRuns, maxDuration, tags,
#'   requestId, maxGpus)
#'
#' @param name A name for the group.
#' @param maxCpus The maximum number of CPUs that can run concurrently across all active
#' runs in the run group.
#' @param maxRuns The maximum number of runs that can be running at the same time.
#' @param maxDuration The maximum time for each run (in minutes). If a run exceeds the maximum
#' run time, the run fails automatically.
#' @param tags Tags for the group.
#' @param requestId &#91;required&#93; To ensure that requests don't run multiple times, specify a unique ID
#' for each request.
#' @param maxGpus The maximum number of GPUs that can run concurrently across all active
#' runs in the run group.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_run_group(
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   maxGpus = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_run_group
#'
#' @aliases omics_create_run_group
omics_create_run_group <- function(name = NULL, maxCpus = NULL, maxRuns = NULL, maxDuration = NULL, tags = NULL, requestId, maxGpus = NULL) {
  op <- new_operation(
    name = "CreateRunGroup",
    http_method = "POST",
    http_path = "/runGroup",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$create_run_group_input(name = name, maxCpus = maxCpus, maxRuns = maxRuns, maxDuration = maxDuration, tags = tags, requestId = requestId, maxGpus = maxGpus)
  output <- .omics$create_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_run_group <- omics_create_run_group

#' Creates a sequence store
#'
#' @description
#' Creates a sequence store.
#'
#' @usage
#' omics_create_sequence_store(name, description, sseConfig, tags,
#'   clientToken, fallbackLocation, eTagAlgorithmFamily)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param tags Tags for the store.
#' @param clientToken To ensure that requests don't run multiple times, specify a unique token
#' for each request.
#' @param fallbackLocation An S3 location that is used to store files that have failed a direct
#' upload.
#' @param eTagAlgorithmFamily The ETag algorithm family to use for ingested read sets.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   fallbackLocation = "string",
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_sequence_store(
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientToken = "string",
#'   fallbackLocation = "string",
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_sequence_store
#'
#' @aliases omics_create_sequence_store
omics_create_sequence_store <- function(name, description = NULL, sseConfig = NULL, tags = NULL, clientToken = NULL, fallbackLocation = NULL, eTagAlgorithmFamily = NULL) {
  op <- new_operation(
    name = "CreateSequenceStore",
    http_method = "POST",
    http_path = "/sequencestore",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$create_sequence_store_input(name = name, description = description, sseConfig = sseConfig, tags = tags, clientToken = clientToken, fallbackLocation = fallbackLocation, eTagAlgorithmFamily = eTagAlgorithmFamily)
  output <- .omics$create_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_sequence_store <- omics_create_sequence_store

#' Creates a cross-account shared resource
#'
#' @description
#' Creates a cross-account shared resource. The resource owner makes an
#' offer to share the resource with the principal subscriber (an AWS user
#' with a different account than the resource owner).
#' 
#' The following resources support cross-account sharing:
#' 
#' -   HealthOmics variant stores
#' 
#' -   HealthOmics annotation stores
#' 
#' -   Private workflows
#'
#' @usage
#' omics_create_share(resourceArn, principalSubscriber, shareName)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to be shared.
#' @param principalSubscriber &#91;required&#93; The principal subscriber is the account being offered shared access to
#' the resource.
#' @param shareName A name that the owner defines for the share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   shareId = "string",
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'   shareName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_share(
#'   resourceArn = "string",
#'   principalSubscriber = "string",
#'   shareName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_share
#'
#' @aliases omics_create_share
omics_create_share <- function(resourceArn, principalSubscriber, shareName = NULL) {
  op <- new_operation(
    name = "CreateShare",
    http_method = "POST",
    http_path = "/share",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$create_share_input(resourceArn = resourceArn, principalSubscriber = principalSubscriber, shareName = shareName)
  output <- .omics$create_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_share <- omics_create_share

#' Creates a variant store
#'
#' @description
#' Creates a variant store.
#'
#' @usage
#' omics_create_variant_store(reference, name, description, tags,
#'   sseConfig)
#'
#' @param reference &#91;required&#93; The genome reference for the store's variants.
#' @param name A name for the store.
#' @param description A description for the store.
#' @param tags Tags for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_variant_store(
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_variant_store
#'
#' @aliases omics_create_variant_store
omics_create_variant_store <- function(reference, name = NULL, description = NULL, tags = NULL, sseConfig = NULL) {
  op <- new_operation(
    name = "CreateVariantStore",
    http_method = "POST",
    http_path = "/variantStore",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$create_variant_store_input(reference = reference, name = name, description = description, tags = tags, sseConfig = sseConfig)
  output <- .omics$create_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_variant_store <- omics_create_variant_store

#' Creates a workflow
#'
#' @description
#' Creates a workflow.
#'
#' @usage
#' omics_create_workflow(name, description, engine, definitionZip,
#'   definitionUri, main, parameterTemplate, storageCapacity, tags,
#'   requestId, accelerators)
#'
#' @param name A name for the workflow.
#' @param description A description for the workflow.
#' @param engine An engine for the workflow.
#' @param definitionZip A ZIP archive for the workflow.
#' @param definitionUri The URI of a definition for the workflow.
#' @param main The path of the main definition file for the workflow.
#' @param parameterTemplate A parameter template for the workflow.
#' @param storageCapacity The default storage capacity for the workflow runs, in gibibytes.
#' @param tags Tags for the workflow.
#' @param requestId &#91;required&#93; To ensure that requests don't run multiple times, specify a unique ID
#' for each request.
#' @param accelerators The computational accelerator specified to run the workflow.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_workflow(
#'   name = "string",
#'   description = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL",
#'   definitionZip = raw,
#'   definitionUri = "string",
#'   main = "string",
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   storageCapacity = 123,
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   accelerators = "GPU"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_workflow
#'
#' @aliases omics_create_workflow
omics_create_workflow <- function(name = NULL, description = NULL, engine = NULL, definitionZip = NULL, definitionUri = NULL, main = NULL, parameterTemplate = NULL, storageCapacity = NULL, tags = NULL, requestId, accelerators = NULL) {
  op <- new_operation(
    name = "CreateWorkflow",
    http_method = "POST",
    http_path = "/workflow",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$create_workflow_input(name = name, description = description, engine = engine, definitionZip = definitionZip, definitionUri = definitionUri, main = main, parameterTemplate = parameterTemplate, storageCapacity = storageCapacity, tags = tags, requestId = requestId, accelerators = accelerators)
  output <- .omics$create_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_workflow <- omics_create_workflow

#' Deletes an annotation store
#'
#' @description
#' Deletes an annotation store.
#'
#' @usage
#' omics_delete_annotation_store(name, force)
#'
#' @param name &#91;required&#93; The store's name.
#' @param force Whether to force deletion.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_annotation_store(
#'   name = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_annotation_store
#'
#' @aliases omics_delete_annotation_store
omics_delete_annotation_store <- function(name, force = NULL) {
  op <- new_operation(
    name = "DeleteAnnotationStore",
    http_method = "DELETE",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$delete_annotation_store_input(name = name, force = force)
  output <- .omics$delete_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_annotation_store <- omics_delete_annotation_store

#' Deletes one or multiple versions of an annotation store
#'
#' @description
#' Deletes one or multiple versions of an annotation store.
#'
#' @usage
#' omics_delete_annotation_store_versions(name, versions, force)
#'
#' @param name &#91;required&#93; The name of the annotation store from which versions are being deleted.
#' @param versions &#91;required&#93; The versions of an annotation store to be deleted.
#' @param force Forces the deletion of an annotation store version when imports are
#' in-progress..
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       versionName = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_annotation_store_versions(
#'   name = "string",
#'   versions = list(
#'     "string"
#'   ),
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_annotation_store_versions
#'
#' @aliases omics_delete_annotation_store_versions
omics_delete_annotation_store_versions <- function(name, versions, force = NULL) {
  op <- new_operation(
    name = "DeleteAnnotationStoreVersions",
    http_method = "POST",
    http_path = "/annotationStore/{name}/versions/delete",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$delete_annotation_store_versions_input(name = name, versions = versions, force = force)
  output <- .omics$delete_annotation_store_versions_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_annotation_store_versions <- omics_delete_annotation_store_versions

#' Deletes a genome reference
#'
#' @description
#' Deletes a genome reference.
#'
#' @usage
#' omics_delete_reference(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's store ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_reference(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_reference
#'
#' @aliases omics_delete_reference
omics_delete_reference <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "DeleteReference",
    http_method = "DELETE",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$delete_reference_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$delete_reference_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_reference <- omics_delete_reference

#' Deletes a genome reference store
#'
#' @description
#' Deletes a genome reference store.
#'
#' @usage
#' omics_delete_reference_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_reference_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_reference_store
#'
#' @aliases omics_delete_reference_store
omics_delete_reference_store <- function(id) {
  op <- new_operation(
    name = "DeleteReferenceStore",
    http_method = "DELETE",
    http_path = "/referencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$delete_reference_store_input(id = id)
  output <- .omics$delete_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_reference_store <- omics_delete_reference_store

#' Deletes a workflow run
#'
#' @description
#' Deletes a workflow run.
#'
#' @usage
#' omics_delete_run(id)
#'
#' @param id &#91;required&#93; The run's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_run(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_run
#'
#' @aliases omics_delete_run
omics_delete_run <- function(id) {
  op <- new_operation(
    name = "DeleteRun",
    http_method = "DELETE",
    http_path = "/run/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$delete_run_input(id = id)
  output <- .omics$delete_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_run <- omics_delete_run

#' Deletes a workflow run group
#'
#' @description
#' Deletes a workflow run group.
#'
#' @usage
#' omics_delete_run_group(id)
#'
#' @param id &#91;required&#93; The run group's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_run_group(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_run_group
#'
#' @aliases omics_delete_run_group
omics_delete_run_group <- function(id) {
  op <- new_operation(
    name = "DeleteRunGroup",
    http_method = "DELETE",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$delete_run_group_input(id = id)
  output <- .omics$delete_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_run_group <- omics_delete_run_group

#' Deletes a sequence store
#'
#' @description
#' Deletes a sequence store.
#'
#' @usage
#' omics_delete_sequence_store(id)
#'
#' @param id &#91;required&#93; The sequence store's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_sequence_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_sequence_store
#'
#' @aliases omics_delete_sequence_store
omics_delete_sequence_store <- function(id) {
  op <- new_operation(
    name = "DeleteSequenceStore",
    http_method = "DELETE",
    http_path = "/sequencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$delete_sequence_store_input(id = id)
  output <- .omics$delete_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_sequence_store <- omics_delete_sequence_store

#' Deletes a resource share
#'
#' @description
#' Deletes a resource share. If you are the resource owner, the subscriber
#' will no longer have access to the shared resource. If you are the
#' subscriber, this operation deletes your access to the share.
#'
#' @usage
#' omics_delete_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID for the resource share to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_share
#'
#' @aliases omics_delete_share
omics_delete_share <- function(shareId) {
  op <- new_operation(
    name = "DeleteShare",
    http_method = "DELETE",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$delete_share_input(shareId = shareId)
  output <- .omics$delete_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_share <- omics_delete_share

#' Deletes a variant store
#'
#' @description
#' Deletes a variant store.
#'
#' @usage
#' omics_delete_variant_store(name, force)
#'
#' @param name &#91;required&#93; The store's name.
#' @param force Whether to force deletion.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_variant_store(
#'   name = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_variant_store
#'
#' @aliases omics_delete_variant_store
omics_delete_variant_store <- function(name, force = NULL) {
  op <- new_operation(
    name = "DeleteVariantStore",
    http_method = "DELETE",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$delete_variant_store_input(name = name, force = force)
  output <- .omics$delete_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_variant_store <- omics_delete_variant_store

#' Deletes a workflow
#'
#' @description
#' Deletes a workflow.
#'
#' @usage
#' omics_delete_workflow(id)
#'
#' @param id &#91;required&#93; The workflow's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_workflow(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_workflow
#'
#' @aliases omics_delete_workflow
omics_delete_workflow <- function(id) {
  op <- new_operation(
    name = "DeleteWorkflow",
    http_method = "DELETE",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$delete_workflow_input(id = id)
  output <- .omics$delete_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_workflow <- omics_delete_workflow

#' Gets information about an annotation import job
#'
#' @description
#' Gets information about an annotation import job.
#'
#' @usage
#' omics_get_annotation_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   destinationName = "string",
#'   versionName = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   items = list(
#'     list(
#'       source = "string",
#'       jobStatus = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   formatOptions = list(
#'     tsvOptions = list(
#'       readOptions = list(
#'         sep = "string",
#'         encoding = "string",
#'         quote = "string",
#'         quoteAll = TRUE|FALSE,
#'         escape = "string",
#'         escapeQuotes = TRUE|FALSE,
#'         comment = "string",
#'         header = TRUE|FALSE,
#'         lineSep = "string"
#'       )
#'     ),
#'     vcfOptions = list(
#'       ignoreQualField = TRUE|FALSE,
#'       ignoreFilterField = TRUE|FALSE
#'     )
#'   ),
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_import_job
#'
#' @aliases omics_get_annotation_import_job
omics_get_annotation_import_job <- function(jobId) {
  op <- new_operation(
    name = "GetAnnotationImportJob",
    http_method = "GET",
    http_path = "/import/annotation/{jobId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_annotation_import_job_input(jobId = jobId)
  output <- .omics$get_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_import_job <- omics_get_annotation_import_job

#' Gets information about an annotation store
#'
#' @description
#' Gets information about an annotation store.
#'
#' @usage
#' omics_get_annotation_store(name)
#'
#' @param name &#91;required&#93; The store's name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   storeArn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   statusMessage = "string",
#'   storeSizeBytes = 123,
#'   numVersions = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_store(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_store
#'
#' @aliases omics_get_annotation_store
omics_get_annotation_store <- function(name) {
  op <- new_operation(
    name = "GetAnnotationStore",
    http_method = "GET",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_annotation_store_input(name = name)
  output <- .omics$get_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_store <- omics_get_annotation_store

#' Retrieves the metadata for an annotation store version
#'
#' @description
#' Retrieves the metadata for an annotation store version.
#'
#' @usage
#' omics_get_annotation_store_version(name, versionName)
#'
#' @param name &#91;required&#93; The name given to an annotation store version to distinguish it from
#' others.
#' @param versionName &#91;required&#93; The name given to an annotation store version to distinguish it from
#' others.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   storeId = "string",
#'   id = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   versionArn = "string",
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   statusMessage = "string",
#'   versionSizeBytes = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_store_version(
#'   name = "string",
#'   versionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_store_version
#'
#' @aliases omics_get_annotation_store_version
omics_get_annotation_store_version <- function(name, versionName) {
  op <- new_operation(
    name = "GetAnnotationStoreVersion",
    http_method = "GET",
    http_path = "/annotationStore/{name}/version/{versionName}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_annotation_store_version_input(name = name, versionName = versionName)
  output <- .omics$get_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_store_version <- omics_get_annotation_store_version

#' Gets a file from a read set
#'
#' @description
#' Gets a file from a read set.
#'
#' @usage
#' omics_get_read_set(id, sequenceStoreId, file, partNumber)
#'
#' @param id &#91;required&#93; The read set's ID.
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param file The file to retrieve.
#' @param partNumber &#91;required&#93; The part number to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   payload = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   file = "SOURCE1"|"SOURCE2"|"INDEX",
#'   partNumber = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set
#'
#' @aliases omics_get_read_set
omics_get_read_set <- function(id, sequenceStoreId, file = NULL, partNumber) {
  op <- new_operation(
    name = "GetReadSet",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/readset/{id}",
    host_prefix = "storage-",
    paginator = list()
  )
  input <- .omics$get_read_set_input(id = id, sequenceStoreId = sequenceStoreId, file = file, partNumber = partNumber)
  output <- .omics$get_read_set_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set <- omics_get_read_set

#' Gets information about a read set activation job
#'
#' @description
#' Gets information about a read set activation job.
#'
#' @usage
#' omics_get_read_set_activation_job(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       readSetId = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_activation_job(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_activation_job
#'
#' @aliases omics_get_read_set_activation_job
omics_get_read_set_activation_job <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetActivationJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/activationjob/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_read_set_activation_job_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_activation_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_activation_job <- omics_get_read_set_activation_job

#' Gets information about a read set export job
#'
#' @description
#' Gets information about a read set export job.
#'
#' @usage
#' omics_get_read_set_export_job(sequenceStoreId, id)
#'
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#' @param id &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   readSets = list(
#'     list(
#'       id = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_export_job(
#'   sequenceStoreId = "string",
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_export_job
#'
#' @aliases omics_get_read_set_export_job
omics_get_read_set_export_job <- function(sequenceStoreId, id) {
  op <- new_operation(
    name = "GetReadSetExportJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/exportjob/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_read_set_export_job_input(sequenceStoreId = sequenceStoreId, id = id)
  output <- .omics$get_read_set_export_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_export_job <- omics_get_read_set_export_job

#' Gets information about a read set import job
#'
#' @description
#' Gets information about a read set import job.
#'
#' @usage
#' omics_get_read_set_import_job(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       sourceFiles = list(
#'         source1 = "string",
#'         source2 = "string"
#'       ),
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_import_job(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_import_job
#'
#' @aliases omics_get_read_set_import_job
omics_get_read_set_import_job <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetImportJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/importjob/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_read_set_import_job_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_import_job <- omics_get_read_set_import_job

#' Gets details about a read set
#'
#' @description
#' Gets details about a read set.
#'
#' @usage
#' omics_get_read_set_metadata(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The read set's ID.
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   sequenceStoreId = "string",
#'   subjectId = "string",
#'   sampleId = "string",
#'   status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'   name = "string",
#'   description = "string",
#'   fileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sequenceInformation = list(
#'     totalReadCount = 123,
#'     totalBaseCount = 123,
#'     generatedFrom = "string",
#'     alignment = "string"
#'   ),
#'   referenceArn = "string",
#'   files = list(
#'     source1 = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     source2 = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     index = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   statusMessage = "string",
#'   creationType = "IMPORT"|"UPLOAD",
#'   etag = list(
#'     algorithm = "FASTQ_MD5up"|"BAM_MD5up"|"CRAM_MD5up"|"FASTQ_SHA256up"|"BAM_SHA256up"|"CRAM_SHA256up"|"FASTQ_SHA512up"|"BAM_SHA512up"|"CRAM_SHA512up",
#'     source1 = "string",
#'     source2 = "string"
#'   ),
#'   creationJobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_metadata(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_metadata
#'
#' @aliases omics_get_read_set_metadata
omics_get_read_set_metadata <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetMetadata",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/readset/{id}/metadata",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_read_set_metadata_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_metadata_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_metadata <- omics_get_read_set_metadata

#' Gets a reference file
#'
#' @description
#' Gets a reference file.
#'
#' @usage
#' omics_get_reference(id, referenceStoreId, range, partNumber, file)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's store ID.
#' @param range The range to retrieve.
#' @param partNumber &#91;required&#93; The part number to retrieve.
#' @param file The file to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   payload = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference(
#'   id = "string",
#'   referenceStoreId = "string",
#'   range = "string",
#'   partNumber = 123,
#'   file = "SOURCE"|"INDEX"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference
#'
#' @aliases omics_get_reference
omics_get_reference <- function(id, referenceStoreId, range = NULL, partNumber, file = NULL) {
  op <- new_operation(
    name = "GetReference",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}",
    host_prefix = "storage-",
    paginator = list()
  )
  input <- .omics$get_reference_input(id = id, referenceStoreId = referenceStoreId, range = range, partNumber = partNumber, file = file)
  output <- .omics$get_reference_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference <- omics_get_reference

#' Gets information about a reference import job
#'
#' @description
#' Gets information about a reference import job.
#'
#' @usage
#' omics_get_reference_import_job(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       sourceFile = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       referenceId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_import_job(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_import_job
#'
#' @aliases omics_get_reference_import_job
omics_get_reference_import_job <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "GetReferenceImportJob",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/importjob/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_reference_import_job_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$get_reference_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_import_job <- omics_get_reference_import_job

#' Gets information about a genome reference's metadata
#'
#' @description
#' Gets information about a genome reference's metadata.
#'
#' @usage
#' omics_get_reference_metadata(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's reference store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   referenceStoreId = "string",
#'   md5 = "string",
#'   status = "ACTIVE"|"DELETING"|"DELETED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   files = list(
#'     source = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     index = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   creationType = "IMPORT",
#'   creationJobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_metadata(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_metadata
#'
#' @aliases omics_get_reference_metadata
omics_get_reference_metadata <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "GetReferenceMetadata",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}/metadata",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_reference_metadata_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$get_reference_metadata_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_metadata <- omics_get_reference_metadata

#' Gets information about a reference store
#'
#' @description
#' Gets information about a reference store.
#'
#' @usage
#' omics_get_reference_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_store
#'
#' @aliases omics_get_reference_store
omics_get_reference_store <- function(id) {
  op <- new_operation(
    name = "GetReferenceStore",
    http_method = "GET",
    http_path = "/referencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_reference_store_input(id = id)
  output <- .omics$get_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_store <- omics_get_reference_store

#' Gets information about a workflow run
#'
#' @description
#' Gets information about a workflow run.
#' 
#' If a workflow is shared with you, you cannot export information about
#' the run.
#'
#' @usage
#' omics_get_run(id, export)
#'
#' @param id &#91;required&#93; The run's ID.
#' @param export The run's export format.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'   workflowId = "string",
#'   workflowType = "PRIVATE"|"READY2RUN",
#'   runId = "string",
#'   roleArn = "string",
#'   name = "string",
#'   runGroupId = "string",
#'   priority = 123,
#'   definition = "string",
#'   digest = "string",
#'   parameters = list(),
#'   storageCapacity = 123,
#'   outputUri = "string",
#'   logLevel = "OFF"|"FATAL"|"ERROR"|"ALL",
#'   resourceDigests = list(
#'     "string"
#'   ),
#'   startedBy = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   stopTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   accelerators = "GPU",
#'   retentionMode = "RETAIN"|"REMOVE",
#'   failureReason = "string",
#'   logLocation = list(
#'     engineLogStream = "string",
#'     runLogStream = "string"
#'   ),
#'   uuid = "string",
#'   runOutputUri = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   workflowOwnerId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run(
#'   id = "string",
#'   export = list(
#'     "DEFINITION"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run
#'
#' @aliases omics_get_run
omics_get_run <- function(id, export = NULL) {
  op <- new_operation(
    name = "GetRun",
    http_method = "GET",
    http_path = "/run/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$get_run_input(id = id, export = export)
  output <- .omics$get_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run <- omics_get_run

#' Gets information about a workflow run group
#'
#' @description
#' Gets information about a workflow run group.
#'
#' @usage
#' omics_get_run_group(id)
#'
#' @param id &#91;required&#93; The group's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   maxGpus = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run_group(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run_group
#'
#' @aliases omics_get_run_group
omics_get_run_group <- function(id) {
  op <- new_operation(
    name = "GetRunGroup",
    http_method = "GET",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$get_run_group_input(id = id)
  output <- .omics$get_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run_group <- omics_get_run_group

#' Gets information about a workflow run task
#'
#' @description
#' Gets information about a workflow run task.
#'
#' @usage
#' omics_get_run_task(id, taskId)
#'
#' @param id &#91;required&#93; The workflow run ID.
#' @param taskId &#91;required&#93; The task's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   taskId = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'   name = "string",
#'   cpus = 123,
#'   memory = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   stopTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   logStream = "string",
#'   gpus = 123,
#'   instanceType = "string",
#'   failureReason = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run_task(
#'   id = "string",
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run_task
#'
#' @aliases omics_get_run_task
omics_get_run_task <- function(id, taskId) {
  op <- new_operation(
    name = "GetRunTask",
    http_method = "GET",
    http_path = "/run/{id}/task/{taskId}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$get_run_task_input(id = id, taskId = taskId)
  output <- .omics$get_run_task_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run_task <- omics_get_run_task

#' Gets information about a sequence store
#'
#' @description
#' Gets information about a sequence store.
#'
#' @usage
#' omics_get_sequence_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   fallbackLocation = "string",
#'   s3Access = list(
#'     s3Uri = "string",
#'     s3AccessPointArn = "string"
#'   ),
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_sequence_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_sequence_store
#'
#' @aliases omics_get_sequence_store
omics_get_sequence_store <- function(id) {
  op <- new_operation(
    name = "GetSequenceStore",
    http_method = "GET",
    http_path = "/sequencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$get_sequence_store_input(id = id)
  output <- .omics$get_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_sequence_store <- omics_get_sequence_store

#' Retrieves the metadata for the specified resource share
#'
#' @description
#' Retrieves the metadata for the specified resource share.
#'
#' @usage
#' omics_get_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID of the share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   share = list(
#'     shareId = "string",
#'     resourceArn = "string",
#'     resourceId = "string",
#'     principalSubscriber = "string",
#'     ownerId = "string",
#'     status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'     statusMessage = "string",
#'     shareName = "string",
#'     creationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updateTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_share
#'
#' @aliases omics_get_share
omics_get_share <- function(shareId) {
  op <- new_operation(
    name = "GetShare",
    http_method = "GET",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_share_input(shareId = shareId)
  output <- .omics$get_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_share <- omics_get_share

#' Gets information about a variant import job
#'
#' @description
#' Gets information about a variant import job.
#'
#' @usage
#' omics_get_variant_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   destinationName = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   items = list(
#'     list(
#'       source = "string",
#'       jobStatus = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       statusMessage = "string"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_variant_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_variant_import_job
#'
#' @aliases omics_get_variant_import_job
omics_get_variant_import_job <- function(jobId) {
  op <- new_operation(
    name = "GetVariantImportJob",
    http_method = "GET",
    http_path = "/import/variant/{jobId}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_variant_import_job_input(jobId = jobId)
  output <- .omics$get_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_variant_import_job <- omics_get_variant_import_job

#' Gets information about a variant store
#'
#' @description
#' Gets information about a variant store.
#'
#' @usage
#' omics_get_variant_store(name)
#'
#' @param name &#91;required&#93; The store's name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   storeArn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   statusMessage = "string",
#'   storeSizeBytes = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_variant_store(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_variant_store
#'
#' @aliases omics_get_variant_store
omics_get_variant_store <- function(name) {
  op <- new_operation(
    name = "GetVariantStore",
    http_method = "GET",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$get_variant_store_input(name = name)
  output <- .omics$get_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_variant_store <- omics_get_variant_store

#' Gets information about a workflow
#'
#' @description
#' Gets information about a workflow.
#' 
#' If a workflow is shared with you, you cannot export the workflow.
#'
#' @usage
#' omics_get_workflow(id, type, export, workflowOwnerId)
#'
#' @param id &#91;required&#93; The workflow's ID.
#' @param type The workflow's type.
#' @param export The export format for the workflow.
#' @param workflowOwnerId The ID of the workflow owner.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   type = "PRIVATE"|"READY2RUN",
#'   name = "string",
#'   description = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL",
#'   definition = "string",
#'   main = "string",
#'   digest = "string",
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   storageCapacity = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   metadata = list(
#'     "string"
#'   ),
#'   accelerators = "GPU"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow(
#'   id = "string",
#'   type = "PRIVATE"|"READY2RUN",
#'   export = list(
#'     "DEFINITION"
#'   ),
#'   workflowOwnerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_workflow
#'
#' @aliases omics_get_workflow
omics_get_workflow <- function(id, type = NULL, export = NULL, workflowOwnerId = NULL) {
  op <- new_operation(
    name = "GetWorkflow",
    http_method = "GET",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$get_workflow_input(id = id, type = type, export = export, workflowOwnerId = workflowOwnerId)
  output <- .omics$get_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_workflow <- omics_get_workflow

#' Retrieves a list of annotation import jobs
#'
#' @description
#' Retrieves a list of annotation import jobs.
#'
#' @usage
#' omics_list_annotation_import_jobs(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param ids IDs of annotation import jobs to retrieve.
#' @param nextToken Specifies the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationImportJobs = list(
#'     list(
#'       id = "string",
#'       destinationName = "string",
#'       versionName = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       runLeftNormalization = TRUE|FALSE,
#'       annotationFields = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_import_jobs(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'     storeName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_import_jobs
#'
#' @aliases omics_list_annotation_import_jobs
omics_list_annotation_import_jobs <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationImportJobs",
    http_method = "POST",
    http_path = "/import/annotations",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationImportJobs")
  )
  input <- .omics$list_annotation_import_jobs_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_import_jobs <- omics_list_annotation_import_jobs

#' Lists the versions of an annotation store
#'
#' @description
#' Lists the versions of an annotation store.
#'
#' @usage
#' omics_list_annotation_store_versions(name, maxResults, nextToken,
#'   filter)
#'
#' @param name &#91;required&#93; The name of an annotation store.
#' @param maxResults The maximum number of annotation store versions to return in one page of
#' results.
#' @param nextToken Specifies the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list of annotation store versions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationStoreVersions = list(
#'     list(
#'       storeId = "string",
#'       id = "string",
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       versionArn = "string",
#'       name = "string",
#'       versionName = "string",
#'       description = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       versionSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_store_versions(
#'   name = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_store_versions
#'
#' @aliases omics_list_annotation_store_versions
omics_list_annotation_store_versions <- function(name, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationStoreVersions",
    http_method = "POST",
    http_path = "/annotationStore/{name}/versions",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationStoreVersions")
  )
  input <- .omics$list_annotation_store_versions_input(name = name, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_store_versions_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_store_versions <- omics_list_annotation_store_versions

#' Retrieves a list of annotation stores
#'
#' @description
#' Retrieves a list of annotation stores.
#'
#' @usage
#' omics_list_annotation_stores(ids, maxResults, nextToken, filter)
#'
#' @param ids IDs of stores to list.
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationStores = list(
#'     list(
#'       id = "string",
#'       reference = list(
#'         referenceArn = "string"
#'       ),
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       storeArn = "string",
#'       name = "string",
#'       storeFormat = "GFF"|"TSV"|"VCF",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       storeSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_stores(
#'   ids = list(
#'     "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_stores
#'
#' @aliases omics_list_annotation_stores
omics_list_annotation_stores <- function(ids = NULL, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationStores",
    http_method = "POST",
    http_path = "/annotationStores",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationStores")
  )
  input <- .omics$list_annotation_stores_input(ids = ids, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_stores <- omics_list_annotation_stores

#' Lists multipart read set uploads and for in progress uploads
#'
#' @description
#' Lists multipart read set uploads and for in progress uploads. Once the
#' upload is completed, a read set is created and the upload will no longer
#' be returned in the response.
#'
#' @usage
#' omics_list_multipart_read_set_uploads(sequenceStoreId, maxResults,
#'   nextToken)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart uploads.
#' @param maxResults The maximum number of multipart uploads returned in a page.
#' @param nextToken Next token returned in the response of a previous
#' ListMultipartReadSetUploads call. Used to get the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   uploads = list(
#'     list(
#'       sequenceStoreId = "string",
#'       uploadId = "string",
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_multipart_read_set_uploads(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_multipart_read_set_uploads
#'
#' @aliases omics_list_multipart_read_set_uploads
omics_list_multipart_read_set_uploads <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListMultipartReadSetUploads",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/uploads",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "uploads")
  )
  input <- .omics$list_multipart_read_set_uploads_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken)
  output <- .omics$list_multipart_read_set_uploads_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_multipart_read_set_uploads <- omics_list_multipart_read_set_uploads

#' Retrieves a list of read set activation jobs
#'
#' @description
#' Retrieves a list of read set activation jobs.
#'
#' @usage
#' omics_list_read_set_activation_jobs(sequenceStoreId, maxResults,
#'   nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param maxResults The maximum number of read set activation jobs to return in one page of
#' results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   activationJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_activation_jobs(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_activation_jobs
#'
#' @aliases omics_list_read_set_activation_jobs
omics_list_read_set_activation_jobs <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetActivationJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/activationjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "activationJobs")
  )
  input <- .omics$list_read_set_activation_jobs_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_activation_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_activation_jobs <- omics_list_read_set_activation_jobs

#' Retrieves a list of read set export jobs
#'
#' @description
#' Retrieves a list of read set export jobs.
#'
#' @usage
#' omics_list_read_set_export_jobs(sequenceStoreId, maxResults, nextToken,
#'   filter)
#'
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   exportJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       destination = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_export_jobs(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_export_jobs
#'
#' @aliases omics_list_read_set_export_jobs
omics_list_read_set_export_jobs <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetExportJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/exportjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "exportJobs")
  )
  input <- .omics$list_read_set_export_jobs_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_export_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_export_jobs <- omics_list_read_set_export_jobs

#' Retrieves a list of read set import jobs
#'
#' @description
#' Retrieves a list of read set import jobs.
#'
#' @usage
#' omics_list_read_set_import_jobs(maxResults, nextToken, sequenceStoreId,
#'   filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   importJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_import_jobs(
#'   maxResults = 123,
#'   nextToken = "string",
#'   sequenceStoreId = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_import_jobs
#'
#' @aliases omics_list_read_set_import_jobs
omics_list_read_set_import_jobs <- function(maxResults = NULL, nextToken = NULL, sequenceStoreId, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetImportJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/importjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "importJobs")
  )
  input <- .omics$list_read_set_import_jobs_input(maxResults = maxResults, nextToken = nextToken, sequenceStoreId = sequenceStoreId, filter = filter)
  output <- .omics$list_read_set_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_import_jobs <- omics_list_read_set_import_jobs

#' This operation will list all parts in a requested multipart upload for a
#' sequence store
#'
#' @description
#' This operation will list all parts in a requested multipart upload for a
#' sequence store.
#'
#' @usage
#' omics_list_read_set_upload_parts(sequenceStoreId, uploadId, partSource,
#'   maxResults, nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart uploads.
#' @param uploadId &#91;required&#93; The ID for the initiated multipart upload.
#' @param partSource &#91;required&#93; The source file for the upload part.
#' @param maxResults The maximum number of read set upload parts returned in a page.
#' @param nextToken Next token returned in the response of a previous
#' ListReadSetUploadPartsRequest call. Used to get the next page of
#' results.
#' @param filter Attributes used to filter for a specific subset of read set part
#' uploads.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   parts = list(
#'     list(
#'       partNumber = 123,
#'       partSize = 123,
#'       partSource = "SOURCE1"|"SOURCE2",
#'       checksum = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_upload_parts(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   partSource = "SOURCE1"|"SOURCE2",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_upload_parts
#'
#' @aliases omics_list_read_set_upload_parts
omics_list_read_set_upload_parts <- function(sequenceStoreId, uploadId, partSource, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetUploadParts",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/parts",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "parts")
  )
  input <- .omics$list_read_set_upload_parts_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, partSource = partSource, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_upload_parts_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_upload_parts <- omics_list_read_set_upload_parts

#' Retrieves a list of read sets
#'
#' @description
#' Retrieves a list of read sets.
#'
#' @usage
#' omics_list_read_sets(sequenceStoreId, maxResults, nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param maxResults The maximum number of read sets to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   readSets = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       sequenceStoreId = "string",
#'       subjectId = "string",
#'       sampleId = "string",
#'       status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'       name = "string",
#'       description = "string",
#'       referenceArn = "string",
#'       fileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       sequenceInformation = list(
#'         totalReadCount = 123,
#'         totalBaseCount = 123,
#'         generatedFrom = "string",
#'         alignment = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       creationType = "IMPORT"|"UPLOAD",
#'       etag = list(
#'         algorithm = "FASTQ_MD5up"|"BAM_MD5up"|"CRAM_MD5up"|"FASTQ_SHA256up"|"BAM_SHA256up"|"CRAM_SHA256up"|"FASTQ_SHA512up"|"BAM_SHA512up"|"CRAM_SHA512up",
#'         source1 = "string",
#'         source2 = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_sets(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'     referenceArn = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     sampleId = "string",
#'     subjectId = "string",
#'     generatedFrom = "string",
#'     creationType = "IMPORT"|"UPLOAD"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_sets
#'
#' @aliases omics_list_read_sets
omics_list_read_sets <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSets",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/readsets",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "readSets")
  )
  input <- .omics$list_read_sets_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_sets_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_sets <- omics_list_read_sets

#' Retrieves a list of reference import jobs
#'
#' @description
#' Retrieves a list of reference import jobs.
#'
#' @usage
#' omics_list_reference_import_jobs(maxResults, nextToken,
#'   referenceStoreId, filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   importJobs = list(
#'     list(
#'       id = "string",
#'       referenceStoreId = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_reference_import_jobs(
#'   maxResults = 123,
#'   nextToken = "string",
#'   referenceStoreId = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_reference_import_jobs
#'
#' @aliases omics_list_reference_import_jobs
omics_list_reference_import_jobs <- function(maxResults = NULL, nextToken = NULL, referenceStoreId, filter = NULL) {
  op <- new_operation(
    name = "ListReferenceImportJobs",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/importjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "importJobs")
  )
  input <- .omics$list_reference_import_jobs_input(maxResults = maxResults, nextToken = nextToken, referenceStoreId = referenceStoreId, filter = filter)
  output <- .omics$list_reference_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_reference_import_jobs <- omics_list_reference_import_jobs

#' Retrieves a list of reference stores
#'
#' @description
#' Retrieves a list of reference stores.
#'
#' @usage
#' omics_list_reference_stores(maxResults, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   referenceStores = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_reference_stores(
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_reference_stores
#'
#' @aliases omics_list_reference_stores
omics_list_reference_stores <- function(maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReferenceStores",
    http_method = "POST",
    http_path = "/referencestores",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "referenceStores")
  )
  input <- .omics$list_reference_stores_input(maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_reference_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_reference_stores <- omics_list_reference_stores

#' Retrieves a list of references
#'
#' @description
#' Retrieves a list of references.
#'
#' @usage
#' omics_list_references(referenceStoreId, maxResults, nextToken, filter)
#'
#' @param referenceStoreId &#91;required&#93; The references' reference store ID.
#' @param maxResults The maximum number of references to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   references = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       referenceStoreId = "string",
#'       md5 = "string",
#'       status = "ACTIVE"|"DELETING"|"DELETED",
#'       name = "string",
#'       description = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_references(
#'   referenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     md5 = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_references
#'
#' @aliases omics_list_references
omics_list_references <- function(referenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReferences",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/references",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "references")
  )
  input <- .omics$list_references_input(referenceStoreId = referenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_references_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_references <- omics_list_references

#' Retrieves a list of run groups
#'
#' @description
#' Retrieves a list of run groups.
#'
#' @usage
#' omics_list_run_groups(name, startingToken, maxResults)
#'
#' @param name The run groups' name.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of run groups to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       maxCpus = 123,
#'       maxRuns = 123,
#'       maxDuration = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       maxGpus = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_run_groups(
#'   name = "string",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_run_groups
#'
#' @aliases omics_list_run_groups
omics_list_run_groups <- function(name = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListRunGroups",
    http_method = "GET",
    http_path = "/runGroup",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items")
  )
  input <- .omics$list_run_groups_input(name = name, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_run_groups_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_run_groups <- omics_list_run_groups

#' Retrieves a list of tasks for a run
#'
#' @description
#' Retrieves a list of tasks for a run.
#'
#' @usage
#' omics_list_run_tasks(id, status, startingToken, maxResults)
#'
#' @param id &#91;required&#93; The run's ID.
#' @param status Filter the list by status.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of run tasks to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       taskId = "string",
#'       status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'       name = "string",
#'       cpus = 123,
#'       memory = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stopTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       gpus = 123,
#'       instanceType = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_run_tasks(
#'   id = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_run_tasks
#'
#' @aliases omics_list_run_tasks
omics_list_run_tasks <- function(id, status = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListRunTasks",
    http_method = "GET",
    http_path = "/run/{id}/task",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items")
  )
  input <- .omics$list_run_tasks_input(id = id, status = status, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_run_tasks_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_run_tasks <- omics_list_run_tasks

#' Retrieves a list of runs
#'
#' @description
#' Retrieves a list of runs.
#'
#' @usage
#' omics_list_runs(name, runGroupId, startingToken, maxResults, status)
#'
#' @param name Filter the list by run name.
#' @param runGroupId Filter the list by run group ID.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of runs to return in one page of results.
#' @param status The status of a run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'       workflowId = "string",
#'       name = "string",
#'       priority = 123,
#'       storageCapacity = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stopTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       storageType = "STATIC"|"DYNAMIC"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_runs(
#'   name = "string",
#'   runGroupId = "string",
#'   startingToken = "string",
#'   maxResults = 123,
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_runs
#'
#' @aliases omics_list_runs
omics_list_runs <- function(name = NULL, runGroupId = NULL, startingToken = NULL, maxResults = NULL, status = NULL) {
  op <- new_operation(
    name = "ListRuns",
    http_method = "GET",
    http_path = "/run",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items")
  )
  input <- .omics$list_runs_input(name = name, runGroupId = runGroupId, startingToken = startingToken, maxResults = maxResults, status = status)
  output <- .omics$list_runs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_runs <- omics_list_runs

#' Retrieves a list of sequence stores
#'
#' @description
#' Retrieves a list of sequence stores.
#'
#' @usage
#' omics_list_sequence_stores(maxResults, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   sequenceStores = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       fallbackLocation = "string",
#'       eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_sequence_stores(
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_sequence_stores
#'
#' @aliases omics_list_sequence_stores
omics_list_sequence_stores <- function(maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListSequenceStores",
    http_method = "POST",
    http_path = "/sequencestores",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "sequenceStores")
  )
  input <- .omics$list_sequence_stores_input(maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_sequence_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_sequence_stores <- omics_list_sequence_stores

#' Retrieves the resource shares associated with an account
#'
#' @description
#' Retrieves the resource shares associated with an account. Use the filter
#' parameter to retrieve a specific subset of the shares.
#'
#' @usage
#' omics_list_shares(resourceOwner, filter, nextToken, maxResults)
#'
#' @param resourceOwner &#91;required&#93; The account that owns the resource shares.
#' @param filter Attributes that you use to filter for a specific subset of resource
#' shares.
#' @param nextToken Next token returned in the response of a previous
#' ListReadSetUploadPartsRequest call. Used to get the next page of
#' results.
#' @param maxResults The maximum number of shares to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   shares = list(
#'     list(
#'       shareId = "string",
#'       resourceArn = "string",
#'       resourceId = "string",
#'       principalSubscriber = "string",
#'       ownerId = "string",
#'       status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'       statusMessage = "string",
#'       shareName = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_shares(
#'   resourceOwner = "SELF"|"OTHER",
#'   filter = list(
#'     resourceArns = list(
#'       "string"
#'     ),
#'     status = list(
#'       "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#'     ),
#'     type = list(
#'       "VARIANT_STORE"|"ANNOTATION_STORE"|"WORKFLOW"
#'     )
#'   ),
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_shares
#'
#' @aliases omics_list_shares
omics_list_shares <- function(resourceOwner, filter = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListShares",
    http_method = "POST",
    http_path = "/shares",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "shares")
  )
  input <- .omics$list_shares_input(resourceOwner = resourceOwner, filter = filter, nextToken = nextToken, maxResults = maxResults)
  output <- .omics$list_shares_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_shares <- omics_list_shares

#' Retrieves a list of tags for a resource
#'
#' @description
#' Retrieves a list of tags for a resource.
#'
#' @usage
#' omics_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_tags_for_resource
#'
#' @aliases omics_list_tags_for_resource
omics_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list()
  )
  input <- .omics$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .omics$list_tags_for_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_tags_for_resource <- omics_list_tags_for_resource

#' Retrieves a list of variant import jobs
#'
#' @description
#' Retrieves a list of variant import jobs.
#'
#' @usage
#' omics_list_variant_import_jobs(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of import jobs to return in one page of results.
#' @param ids A list of job IDs.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   variantImportJobs = list(
#'     list(
#'       id = "string",
#'       destinationName = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       runLeftNormalization = TRUE|FALSE,
#'       annotationFields = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_variant_import_jobs(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'     storeName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_variant_import_jobs
#'
#' @aliases omics_list_variant_import_jobs
omics_list_variant_import_jobs <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListVariantImportJobs",
    http_method = "POST",
    http_path = "/import/variants",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "variantImportJobs")
  )
  input <- .omics$list_variant_import_jobs_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_variant_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_variant_import_jobs <- omics_list_variant_import_jobs

#' Retrieves a list of variant stores
#'
#' @description
#' Retrieves a list of variant stores.
#'
#' @usage
#' omics_list_variant_stores(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param ids A list of store IDs.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   variantStores = list(
#'     list(
#'       id = "string",
#'       reference = list(
#'         referenceArn = "string"
#'       ),
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       storeArn = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       storeSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_variant_stores(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_variant_stores
#'
#' @aliases omics_list_variant_stores
omics_list_variant_stores <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListVariantStores",
    http_method = "POST",
    http_path = "/variantStores",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "variantStores")
  )
  input <- .omics$list_variant_stores_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_variant_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_variant_stores <- omics_list_variant_stores

#' Retrieves a list of workflows
#'
#' @description
#' Retrieves a list of workflows.
#'
#' @usage
#' omics_list_workflows(type, name, startingToken, maxResults)
#'
#' @param type Filter the list by workflow type.
#' @param name Filter the list by workflow name.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of workflows to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'       type = "PRIVATE"|"READY2RUN",
#'       digest = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       metadata = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_workflows(
#'   type = "PRIVATE"|"READY2RUN",
#'   name = "string",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_workflows
#'
#' @aliases omics_list_workflows
omics_list_workflows <- function(type = NULL, name = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListWorkflows",
    http_method = "GET",
    http_path = "/workflow",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items")
  )
  input <- .omics$list_workflows_input(type = type, name = name, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_workflows_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_workflows <- omics_list_workflows

#' Starts an annotation import job
#'
#' @description
#' Starts an annotation import job.
#'
#' @usage
#' omics_start_annotation_import_job(destinationName, roleArn, items,
#'   versionName, formatOptions, runLeftNormalization, annotationFields)
#'
#' @param destinationName &#91;required&#93; A destination annotation store for the job.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param items &#91;required&#93; Items to import.
#' @param versionName The name of the annotation store version.
#' @param formatOptions Formatting options for the annotation file.
#' @param runLeftNormalization The job's left normalization setting.
#' @param annotationFields The annotation schema generated by the parsed annotation data.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_annotation_import_job(
#'   destinationName = "string",
#'   roleArn = "string",
#'   items = list(
#'     list(
#'       source = "string"
#'     )
#'   ),
#'   versionName = "string",
#'   formatOptions = list(
#'     tsvOptions = list(
#'       readOptions = list(
#'         sep = "string",
#'         encoding = "string",
#'         quote = "string",
#'         quoteAll = TRUE|FALSE,
#'         escape = "string",
#'         escapeQuotes = TRUE|FALSE,
#'         comment = "string",
#'         header = TRUE|FALSE,
#'         lineSep = "string"
#'       )
#'     ),
#'     vcfOptions = list(
#'       ignoreQualField = TRUE|FALSE,
#'       ignoreFilterField = TRUE|FALSE
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_annotation_import_job
#'
#' @aliases omics_start_annotation_import_job
omics_start_annotation_import_job <- function(destinationName, roleArn, items, versionName = NULL, formatOptions = NULL, runLeftNormalization = NULL, annotationFields = NULL) {
  op <- new_operation(
    name = "StartAnnotationImportJob",
    http_method = "POST",
    http_path = "/import/annotation",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$start_annotation_import_job_input(destinationName = destinationName, roleArn = roleArn, items = items, versionName = versionName, formatOptions = formatOptions, runLeftNormalization = runLeftNormalization, annotationFields = annotationFields)
  output <- .omics$start_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_annotation_import_job <- omics_start_annotation_import_job

#' Activates an archived read set
#'
#' @description
#' Activates an archived read set. To reduce storage charges, Amazon Omics
#' archives unused read sets after 30 days.
#'
#' @usage
#' omics_start_read_set_activation_job(sequenceStoreId, clientToken,
#'   sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_activation_job(
#'   sequenceStoreId = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_activation_job
#'
#' @aliases omics_start_read_set_activation_job
omics_start_read_set_activation_job <- function(sequenceStoreId, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetActivationJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/activationjob",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$start_read_set_activation_job_input(sequenceStoreId = sequenceStoreId, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_activation_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_activation_job <- omics_start_read_set_activation_job

#' Exports a read set to Amazon S3
#'
#' @description
#' Exports a read set to Amazon S3.
#'
#' @usage
#' omics_start_read_set_export_job(sequenceStoreId, destination, roleArn,
#'   clientToken, sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param destination &#91;required&#93; A location for exported files in Amazon S3.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_export_job(
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_export_job
#'
#' @aliases omics_start_read_set_export_job
omics_start_read_set_export_job <- function(sequenceStoreId, destination, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetExportJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/exportjob",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$start_read_set_export_job_input(sequenceStoreId = sequenceStoreId, destination = destination, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_export_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_export_job <- omics_start_read_set_export_job

#' Starts a read set import job
#'
#' @description
#' Starts a read set import job.
#'
#' @usage
#' omics_start_read_set_import_job(sequenceStoreId, roleArn, clientToken,
#'   sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_import_job(
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       sourceFiles = list(
#'         source1 = "string",
#'         source2 = "string"
#'       ),
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_import_job
#'
#' @aliases omics_start_read_set_import_job
omics_start_read_set_import_job <- function(sequenceStoreId, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetImportJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/importjob",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$start_read_set_import_job_input(sequenceStoreId = sequenceStoreId, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_import_job <- omics_start_read_set_import_job

#' Starts a reference import job
#'
#' @description
#' Starts a reference import job.
#'
#' @usage
#' omics_start_reference_import_job(referenceStoreId, roleArn, clientToken,
#'   sources)
#'
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_reference_import_job(
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       sourceFile = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_reference_import_job
#'
#' @aliases omics_start_reference_import_job
omics_start_reference_import_job <- function(referenceStoreId, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReferenceImportJob",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/importjob",
    host_prefix = "control-storage-",
    paginator = list()
  )
  input <- .omics$start_reference_import_job_input(referenceStoreId = referenceStoreId, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_reference_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_reference_import_job <- omics_start_reference_import_job

#' Starts a workflow run
#'
#' @description
#' Starts a workflow run. To duplicate a run, specify the run's ID and a
#' role ARN. The remaining parameters are copied from the previous run.
#' 
#' StartRun will not support re-run for a workflow that is shared with you.
#' 
#' The total number of runs in your account is subject to a quota per
#' Region. To avoid needing to delete runs manually, you can set the
#' retention mode to `REMOVE`. Runs with this setting are deleted
#' automatically when the run quoata is exceeded.
#' 
#' By default, the run uses STATIC storage. For STATIC storage, set the
#' `storageCapacity` field. You can set the storage type to DYNAMIC. You do
#' not set `storageCapacity`, because HealthOmics dynamically scales the
#' storage up or down as required. For more information about static and
#' dynamic storage, see [Running
#' workflows](https://docs.aws.amazon.com/omics/latest/dev/) in the *AWS
#' HealthOmics User Guide*.
#'
#' @usage
#' omics_start_run(workflowId, workflowType, runId, roleArn, name,
#'   runGroupId, priority, parameters, storageCapacity, outputUri, logLevel,
#'   tags, requestId, retentionMode, storageType, workflowOwnerId)
#'
#' @param workflowId The run's workflow ID.
#' @param workflowType The run's workflow type.
#' @param runId The ID of a run to duplicate.
#' @param roleArn &#91;required&#93; A service role for the run.
#' @param name A name for the run.
#' @param runGroupId The run's group ID.
#' @param priority A priority for the run.
#' @param parameters Parameters for the run.
#' @param storageCapacity A storage capacity for the run in gibibytes. This field is not required
#' if the storage type is dynamic (the system ignores any value that you
#' enter).
#' @param outputUri An output URI for the run.
#' @param logLevel A log level for the run.
#' @param tags Tags for the run.
#' @param requestId &#91;required&#93; To ensure that requests don't run multiple times, specify a unique ID
#' for each request.
#' @param retentionMode The retention mode for the run.
#' @param storageType The run's storage type. By default, the run uses STATIC storage type,
#' which allocates a fixed amount of storage. If you set the storage type
#' to DYNAMIC, HealthOmics dynamically scales the storage up or down, based
#' on file system utilization.
#' @param workflowOwnerId The ID of the workflow owner.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'   tags = list(
#'     "string"
#'   ),
#'   uuid = "string",
#'   runOutputUri = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_run(
#'   workflowId = "string",
#'   workflowType = "PRIVATE"|"READY2RUN",
#'   runId = "string",
#'   roleArn = "string",
#'   name = "string",
#'   runGroupId = "string",
#'   priority = 123,
#'   parameters = list(),
#'   storageCapacity = 123,
#'   outputUri = "string",
#'   logLevel = "OFF"|"FATAL"|"ERROR"|"ALL",
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   retentionMode = "RETAIN"|"REMOVE",
#'   storageType = "STATIC"|"DYNAMIC",
#'   workflowOwnerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_run
#'
#' @aliases omics_start_run
omics_start_run <- function(workflowId = NULL, workflowType = NULL, runId = NULL, roleArn, name = NULL, runGroupId = NULL, priority = NULL, parameters = NULL, storageCapacity = NULL, outputUri = NULL, logLevel = NULL, tags = NULL, requestId, retentionMode = NULL, storageType = NULL, workflowOwnerId = NULL) {
  op <- new_operation(
    name = "StartRun",
    http_method = "POST",
    http_path = "/run",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$start_run_input(workflowId = workflowId, workflowType = workflowType, runId = runId, roleArn = roleArn, name = name, runGroupId = runGroupId, priority = priority, parameters = parameters, storageCapacity = storageCapacity, outputUri = outputUri, logLevel = logLevel, tags = tags, requestId = requestId, retentionMode = retentionMode, storageType = storageType, workflowOwnerId = workflowOwnerId)
  output <- .omics$start_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_run <- omics_start_run

#' Starts a variant import job
#'
#' @description
#' Starts a variant import job.
#'
#' @usage
#' omics_start_variant_import_job(destinationName, roleArn, items,
#'   runLeftNormalization, annotationFields)
#'
#' @param destinationName &#91;required&#93; The destination variant store for the job.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param items &#91;required&#93; Items to import.
#' @param runLeftNormalization The job's left normalization setting.
#' @param annotationFields The annotation schema generated by the parsed annotation data.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_variant_import_job(
#'   destinationName = "string",
#'   roleArn = "string",
#'   items = list(
#'     list(
#'       source = "string"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_variant_import_job
#'
#' @aliases omics_start_variant_import_job
omics_start_variant_import_job <- function(destinationName, roleArn, items, runLeftNormalization = NULL, annotationFields = NULL) {
  op <- new_operation(
    name = "StartVariantImportJob",
    http_method = "POST",
    http_path = "/import/variant",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$start_variant_import_job_input(destinationName = destinationName, roleArn = roleArn, items = items, runLeftNormalization = runLeftNormalization, annotationFields = annotationFields)
  output <- .omics$start_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_variant_import_job <- omics_start_variant_import_job

#' Tags a resource
#'
#' @description
#' Tags a resource.
#'
#' @usage
#' omics_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#' @param tags &#91;required&#93; Tags for the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_tag_resource
#'
#' @aliases omics_tag_resource
omics_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list()
  )
  input <- .omics$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .omics$tag_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$tag_resource <- omics_tag_resource

#' Removes tags from a resource
#'
#' @description
#' Removes tags from a resource.
#'
#' @usage
#' omics_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#' @param tagKeys &#91;required&#93; Keys of tags to remove.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_untag_resource
#'
#' @aliases omics_untag_resource
omics_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list()
  )
  input <- .omics$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .omics$untag_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$untag_resource <- omics_untag_resource

#' Updates an annotation store
#'
#' @description
#' Updates an annotation store.
#'
#' @usage
#' omics_update_annotation_store(name, description)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_annotation_store(
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_annotation_store
#'
#' @aliases omics_update_annotation_store
omics_update_annotation_store <- function(name, description = NULL) {
  op <- new_operation(
    name = "UpdateAnnotationStore",
    http_method = "POST",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$update_annotation_store_input(name = name, description = description)
  output <- .omics$update_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_annotation_store <- omics_update_annotation_store

#' Updates the description of an annotation store version
#'
#' @description
#' Updates the description of an annotation store version.
#'
#' @usage
#' omics_update_annotation_store_version(name, versionName, description)
#'
#' @param name &#91;required&#93; The name of an annotation store.
#' @param versionName &#91;required&#93; The name of an annotation store version.
#' @param description The description of an annotation store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   storeId = "string",
#'   id = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_annotation_store_version(
#'   name = "string",
#'   versionName = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_annotation_store_version
#'
#' @aliases omics_update_annotation_store_version
omics_update_annotation_store_version <- function(name, versionName, description = NULL) {
  op <- new_operation(
    name = "UpdateAnnotationStoreVersion",
    http_method = "POST",
    http_path = "/annotationStore/{name}/version/{versionName}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$update_annotation_store_version_input(name = name, versionName = versionName, description = description)
  output <- .omics$update_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_annotation_store_version <- omics_update_annotation_store_version

#' Updates a run group
#'
#' @description
#' Updates a run group.
#'
#' @usage
#' omics_update_run_group(id, name, maxCpus, maxRuns, maxDuration, maxGpus)
#'
#' @param id &#91;required&#93; The group's ID.
#' @param name A name for the group.
#' @param maxCpus The maximum number of CPUs to use.
#' @param maxRuns The maximum number of concurrent runs for the group.
#' @param maxDuration A maximum run time for the group in minutes.
#' @param maxGpus The maximum GPUs that can be used by a run group.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_run_group(
#'   id = "string",
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   maxGpus = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_run_group
#'
#' @aliases omics_update_run_group
omics_update_run_group <- function(id, name = NULL, maxCpus = NULL, maxRuns = NULL, maxDuration = NULL, maxGpus = NULL) {
  op <- new_operation(
    name = "UpdateRunGroup",
    http_method = "POST",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$update_run_group_input(id = id, name = name, maxCpus = maxCpus, maxRuns = maxRuns, maxDuration = maxDuration, maxGpus = maxGpus)
  output <- .omics$update_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_run_group <- omics_update_run_group

#' Updates a variant store
#'
#' @description
#' Updates a variant store.
#'
#' @usage
#' omics_update_variant_store(name, description)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_variant_store(
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_variant_store
#'
#' @aliases omics_update_variant_store
omics_update_variant_store <- function(name, description = NULL) {
  op <- new_operation(
    name = "UpdateVariantStore",
    http_method = "POST",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list()
  )
  input <- .omics$update_variant_store_input(name = name, description = description)
  output <- .omics$update_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_variant_store <- omics_update_variant_store

#' Updates a workflow
#'
#' @description
#' Updates a workflow.
#'
#' @usage
#' omics_update_workflow(id, name, description)
#'
#' @param id &#91;required&#93; The workflow's ID.
#' @param name A name for the workflow.
#' @param description A description for the workflow.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_workflow(
#'   id = "string",
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_workflow
#'
#' @aliases omics_update_workflow
omics_update_workflow <- function(id, name = NULL, description = NULL) {
  op <- new_operation(
    name = "UpdateWorkflow",
    http_method = "POST",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list()
  )
  input <- .omics$update_workflow_input(id = id, name = name, description = description)
  output <- .omics$update_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_workflow <- omics_update_workflow

#' This operation uploads a specific part of a read set
#'
#' @description
#' This operation uploads a specific part of a read set. If you upload a
#' new part using a previously used part number, the previously uploaded
#' part will be overwritten.
#'
#' @usage
#' omics_upload_read_set_part(sequenceStoreId, uploadId, partSource,
#'   partNumber, payload)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the initiated multipart upload.
#' @param partSource &#91;required&#93; The source file for an upload part.
#' @param partNumber &#91;required&#93; The number of the part being uploaded.
#' @param payload &#91;required&#93; The read set data to upload for a part.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   checksum = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$upload_read_set_part(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   partSource = "SOURCE1"|"SOURCE2",
#'   partNumber = 123,
#'   payload = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_upload_read_set_part
#'
#' @aliases omics_upload_read_set_part
omics_upload_read_set_part <- function(sequenceStoreId, uploadId, partSource, partNumber, payload) {
  op <- new_operation(
    name = "UploadReadSetPart",
    http_method = "PUT",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/part",
    host_prefix = "storage-",
    paginator = list()
  )
  input <- .omics$upload_read_set_part_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, partSource = partSource, partNumber = partNumber, payload = payload)
  output <- .omics$upload_read_set_part_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$upload_read_set_part <- omics_upload_read_set_part

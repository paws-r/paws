# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include omics_service.R
NULL

#' Stops a multipart read set upload into a sequence store and returns a
#' response with no body if the operation is successful
#'
#' @description
#' Stops a multipart read set upload into a sequence store and returns a
#' response with no body if the operation is successful. To confirm that a
#' multipart read set upload has been stopped, use the
#' [`list_multipart_read_set_uploads`][omics_list_multipart_read_set_uploads]
#' API operation to view all active multipart read set uploads.
#'
#' @usage
#' omics_abort_multipart_read_set_upload(sequenceStoreId, uploadId)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store involved in the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the multipart upload.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$abort_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   uploadId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_abort_multipart_read_set_upload
#'
#' @aliases omics_abort_multipart_read_set_upload
omics_abort_multipart_read_set_upload <- function(sequenceStoreId, uploadId) {
  op <- new_operation(
    name = "AbortMultipartReadSetUpload",
    http_method = "DELETE",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/abort",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$abort_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId)
  output <- .omics$abort_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$abort_multipart_read_set_upload <- omics_abort_multipart_read_set_upload

#' Accept a resource share request
#'
#' @description
#' Accept a resource share request.
#'
#' @usage
#' omics_accept_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID of the resource share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$accept_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_accept_share
#'
#' @aliases omics_accept_share
omics_accept_share <- function(shareId) {
  op <- new_operation(
    name = "AcceptShare",
    http_method = "POST",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$accept_share_input(shareId = shareId)
  output <- .omics$accept_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$accept_share <- omics_accept_share

#' Deletes one or more read sets
#'
#' @description
#' Deletes one or more read sets. If the operation is successful, it
#' returns a response with no body. If there is an error with deleting one
#' of the read sets, the operation returns an error list. If the operation
#' successfully deletes only a subset of files, it will return an error
#' list for the remaining files that fail to be deleted. There is a limit
#' of 100 read sets that can be deleted in each
#' [`batch_delete_read_set`][omics_batch_delete_read_set] API call.
#'
#' @usage
#' omics_batch_delete_read_set(ids, sequenceStoreId)
#'
#' @param ids &#91;required&#93; The read sets' IDs.
#' @param sequenceStoreId &#91;required&#93; The read sets' sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       id = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_read_set(
#'   ids = list(
#'     "string"
#'   ),
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_batch_delete_read_set
#'
#' @aliases omics_batch_delete_read_set
omics_batch_delete_read_set <- function(ids, sequenceStoreId) {
  op <- new_operation(
    name = "BatchDeleteReadSet",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/readset/batch/delete",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$batch_delete_read_set_input(ids = ids, sequenceStoreId = sequenceStoreId)
  output <- .omics$batch_delete_read_set_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$batch_delete_read_set <- omics_batch_delete_read_set

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Cancels an annotation import job.
#'
#' @usage
#' omics_cancel_annotation_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_annotation_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_annotation_import_job
#'
#' @aliases omics_cancel_annotation_import_job
omics_cancel_annotation_import_job <- function(jobId) {
  op <- new_operation(
    name = "CancelAnnotationImportJob",
    http_method = "DELETE",
    http_path = "/import/annotation/{jobId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$cancel_annotation_import_job_input(jobId = jobId)
  output <- .omics$cancel_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_annotation_import_job <- omics_cancel_annotation_import_job

#' Cancels a run using its ID and returns a response with no body if the
#' operation is successful
#'
#' @description
#' Cancels a run using its ID and returns a response with no body if the
#' operation is successful. To confirm that the run has been cancelled, use
#' the [`list_runs`][omics_list_runs] API operation to check that it is no
#' longer listed.
#'
#' @usage
#' omics_cancel_run(id)
#'
#' @param id &#91;required&#93; The run's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_run(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_run
#'
#' @aliases omics_cancel_run
omics_cancel_run <- function(id) {
  op <- new_operation(
    name = "CancelRun",
    http_method = "POST",
    http_path = "/run/{id}/cancel",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$cancel_run_input(id = id)
  output <- .omics$cancel_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_run <- omics_cancel_run

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Cancels a variant import job.
#'
#' @usage
#' omics_cancel_variant_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_variant_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_cancel_variant_import_job
#'
#' @aliases omics_cancel_variant_import_job
omics_cancel_variant_import_job <- function(jobId) {
  op <- new_operation(
    name = "CancelVariantImportJob",
    http_method = "DELETE",
    http_path = "/import/variant/{jobId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$cancel_variant_import_job_input(jobId = jobId)
  output <- .omics$cancel_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$cancel_variant_import_job <- omics_cancel_variant_import_job

#' Completes a multipart read set upload into a sequence store after you
#' have initiated the upload process with CreateMultipartReadSetUpload and
#' uploaded all read set parts using UploadReadSetPart
#'
#' @description
#' Completes a multipart read set upload into a sequence store after you
#' have initiated the upload process with
#' [`create_multipart_read_set_upload`][omics_create_multipart_read_set_upload]
#' and uploaded all read set parts using
#' [`upload_read_set_part`][omics_upload_read_set_part]. You must specify
#' the parts you uploaded using the parts parameter. If the operation is
#' successful, it returns the read set ID(s) of the uploaded read set(s).
#' 
#' For more information, see [Direct upload to a sequence
#' store](https://docs.aws.amazon.com/omics/latest/dev/synchronous-uploads.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_complete_multipart_read_set_upload(sequenceStoreId, uploadId,
#'   parts)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store involved in the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the multipart upload.
#' @param parts &#91;required&#93; The individual uploads or parts of a multipart upload.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   readSetId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$complete_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   parts = list(
#'     list(
#'       partNumber = 123,
#'       partSource = "SOURCE1"|"SOURCE2",
#'       checksum = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_complete_multipart_read_set_upload
#'
#' @aliases omics_complete_multipart_read_set_upload
omics_complete_multipart_read_set_upload <- function(sequenceStoreId, uploadId, parts) {
  op <- new_operation(
    name = "CompleteMultipartReadSetUpload",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/complete",
    host_prefix = "storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$complete_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, parts = parts)
  output <- .omics$complete_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$complete_multipart_read_set_upload <- omics_complete_multipart_read_set_upload

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Creates an annotation store.
#'
#' @usage
#' omics_create_annotation_store(reference, name, description, tags,
#'   versionName, sseConfig, storeFormat, storeOptions)
#'
#' @param reference The genome reference for the store's annotations.
#' @param name A name for the store.
#' @param description A description for the store.
#' @param tags Tags for the store.
#' @param versionName The name given to an annotation store version to distinguish it from
#' other versions.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param storeFormat &#91;required&#93; The annotation file format of the store.
#' @param storeOptions File parsing options for the annotation store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   versionName = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_annotation_store(
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   versionName = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_annotation_store
#'
#' @aliases omics_create_annotation_store
omics_create_annotation_store <- function(reference = NULL, name = NULL, description = NULL, tags = NULL, versionName = NULL, sseConfig = NULL, storeFormat, storeOptions = NULL) {
  op <- new_operation(
    name = "CreateAnnotationStore",
    http_method = "POST",
    http_path = "/annotationStore",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_annotation_store_input(reference = reference, name = name, description = description, tags = tags, versionName = versionName, sseConfig = sseConfig, storeFormat = storeFormat, storeOptions = storeOptions)
  output <- .omics$create_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_annotation_store <- omics_create_annotation_store

#' Creates a new version of an annotation store
#'
#' @description
#' Creates a new version of an annotation store.
#'
#' @usage
#' omics_create_annotation_store_version(name, versionName, description,
#'   versionOptions, tags)
#'
#' @param name &#91;required&#93; The name of an annotation store version from which versions are being
#' created.
#' @param versionName &#91;required&#93; The name given to an annotation store version to distinguish it from
#' other versions.
#' @param description The description of an annotation store version.
#' @param versionOptions The options for an annotation store version.
#' @param tags Any tags added to annotation store version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   versionName = "string",
#'   storeId = "string",
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   name = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_annotation_store_version(
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_annotation_store_version
#'
#' @aliases omics_create_annotation_store_version
omics_create_annotation_store_version <- function(name, versionName, description = NULL, versionOptions = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateAnnotationStoreVersion",
    http_method = "POST",
    http_path = "/annotationStore/{name}/version",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_annotation_store_version_input(name = name, versionName = versionName, description = description, versionOptions = versionOptions, tags = tags)
  output <- .omics$create_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_annotation_store_version <- omics_create_annotation_store_version

#' Initiates a multipart read set upload for uploading partitioned source
#' files into a sequence store
#'
#' @description
#' Initiates a multipart read set upload for uploading partitioned source
#' files into a sequence store. You can directly import source files from
#' an EC2 instance and other local compute, or from an S3 bucket. To
#' separate these source files into parts, use the `split` operation. Each
#' part cannot be larger than 100 MB. If the operation is successful, it
#' provides an `uploadId` which is required by the
#' [`upload_read_set_part`][omics_upload_read_set_part] API operation to
#' upload parts into a sequence store.
#' 
#' To continue uploading a multipart read set into your sequence store, you
#' must use the [`upload_read_set_part`][omics_upload_read_set_part] API
#' operation to upload each part individually following the steps below:
#' 
#' -   Specify the `uploadId` obtained from the previous call to
#'     [`create_multipart_read_set_upload`][omics_create_multipart_read_set_upload].
#' 
#' -   Upload parts for that `uploadId`.
#' 
#' When you have finished uploading parts, use the
#' [`complete_multipart_read_set_upload`][omics_complete_multipart_read_set_upload]
#' API to complete the multipart read set upload and to retrieve the final
#' read set IDs in the response.
#' 
#' To learn more about creating parts and the `split` operation, see
#' [Direct upload to a sequence
#' store](https://docs.aws.amazon.com/omics/latest/dev/synchronous-uploads.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_multipart_read_set_upload(sequenceStoreId, clientToken,
#'   sourceFileType, subjectId, sampleId, generatedFrom, referenceArn, name,
#'   description, tags)
#'
#' @param sequenceStoreId &#91;required&#93; The sequence store ID for the store that is the destination of the
#' multipart uploads.
#' @param clientToken An idempotency token that can be used to avoid triggering multiple
#' multipart uploads.
#' @param sourceFileType &#91;required&#93; The type of file being uploaded.
#' @param subjectId &#91;required&#93; The source's subject ID.
#' @param sampleId &#91;required&#93; The source's sample ID.
#' @param generatedFrom Where the source originated.
#' @param referenceArn The ARN of the reference.
#' @param name &#91;required&#93; The name of the read set.
#' @param description The description of the read set.
#' @param tags Any tags to add to the read set.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   subjectId = "string",
#'   sampleId = "string",
#'   generatedFrom = "string",
#'   referenceArn = "string",
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_multipart_read_set_upload(
#'   sequenceStoreId = "string",
#'   clientToken = "string",
#'   sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   subjectId = "string",
#'   sampleId = "string",
#'   generatedFrom = "string",
#'   referenceArn = "string",
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_multipart_read_set_upload
#'
#' @aliases omics_create_multipart_read_set_upload
omics_create_multipart_read_set_upload <- function(sequenceStoreId, clientToken = NULL, sourceFileType, subjectId, sampleId, generatedFrom = NULL, referenceArn = NULL, name, description = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateMultipartReadSetUpload",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_multipart_read_set_upload_input(sequenceStoreId = sequenceStoreId, clientToken = clientToken, sourceFileType = sourceFileType, subjectId = subjectId, sampleId = sampleId, generatedFrom = generatedFrom, referenceArn = referenceArn, name = name, description = description, tags = tags)
  output <- .omics$create_multipart_read_set_upload_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_multipart_read_set_upload <- omics_create_multipart_read_set_upload

#' Creates a reference store and returns metadata in JSON format
#'
#' @description
#' Creates a reference store and returns metadata in JSON format. Reference
#' stores are used to store reference genomes in FASTA format. A reference
#' store is created when the first reference genome is imported. To import
#' additional reference genomes from an Amazon S3 bucket, use the
#' [`start_reference_import_job`][omics_start_reference_import_job] API
#' operation.
#' 
#' For more information, see [Creating a HealthOmics reference
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-reference-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_reference_store(name, description, sseConfig, tags,
#'   clientToken)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param tags Tags for the store.
#' @param clientToken To ensure that requests don't run multiple times, specify a unique token
#' for each request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_reference_store(
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_reference_store
#'
#' @aliases omics_create_reference_store
omics_create_reference_store <- function(name, description = NULL, sseConfig = NULL, tags = NULL, clientToken = NULL) {
  op <- new_operation(
    name = "CreateReferenceStore",
    http_method = "POST",
    http_path = "/referencestore",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_reference_store_input(name = name, description = description, sseConfig = sseConfig, tags = tags, clientToken = clientToken)
  output <- .omics$create_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_reference_store <- omics_create_reference_store

#' Creates a run cache to store and reference task outputs from completed
#' private runs
#'
#' @description
#' Creates a run cache to store and reference task outputs from completed
#' private runs. Specify an Amazon S3 location where Amazon Web Services
#' HealthOmics saves the cached data. This data must be immediately
#' accessible and not in an archived state. You can save intermediate task
#' files to a run cache if they are declared as task outputs in the
#' workflow definition file.
#' 
#' For more information, see [Call
#' caching](https://docs.aws.amazon.com/omics/latest/dev/workflows-call-caching.html)
#' and [Creating a run
#' cache](https://docs.aws.amazon.com/omics/latest/dev/workflow-cache-create.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_run_cache(cacheBehavior, cacheS3Location, description,
#'   name, requestId, tags, cacheBucketOwnerId)
#'
#' @param cacheBehavior Default cache behavior for runs that use this cache. Supported values
#' are:
#' 
#' `CACHE_ON_FAILURE`: Caches task outputs from completed tasks for runs
#' that fail. This setting is useful if you're debugging a workflow that
#' fails after several tasks completed successfully. The subsequent run
#' uses the cache outputs for previously-completed tasks if the task
#' definition, inputs, and container in ECR are identical to the prior run.
#' 
#' `CACHE_ALWAYS`: Caches task outputs from completed tasks for all runs.
#' This setting is useful in development mode, but do not use it in a
#' production setting.
#' 
#' If you don't specify a value, the default behavior is CACHE_ON_FAILURE.
#' When you start a run that uses this cache, you can override the default
#' cache behavior.
#' 
#' For more information, see [Run cache
#' behavior](https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html#run-cache-behavior)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param cacheS3Location &#91;required&#93; Specify the S3 location for storing the cached task outputs. This data
#' must be immediately accessible (not in an archived state).
#' @param description Enter a description of the run cache.
#' @param name Enter a user-friendly name for the run cache.
#' @param requestId &#91;required&#93; A unique request token, to ensure idempotency. If you don't specify a
#' token, Amazon Web Services HealthOmics automatically generates a
#' universally unique identifier (UUID) for the request.
#' @param tags Specify one or more tags to associate with this run cache.
#' @param cacheBucketOwnerId The Amazon Web Services account ID of the expected owner of the S3
#' bucket for the run cache. If not provided, your account ID is set as the
#' owner of the bucket.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "ACTIVE"|"DELETED"|"FAILED",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_run_cache(
#'   cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'   cacheS3Location = "string",
#'   description = "string",
#'   name = "string",
#'   requestId = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   cacheBucketOwnerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_run_cache
#'
#' @aliases omics_create_run_cache
omics_create_run_cache <- function(cacheBehavior = NULL, cacheS3Location, description = NULL, name = NULL, requestId, tags = NULL, cacheBucketOwnerId = NULL) {
  op <- new_operation(
    name = "CreateRunCache",
    http_method = "POST",
    http_path = "/runCache",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_run_cache_input(cacheBehavior = cacheBehavior, cacheS3Location = cacheS3Location, description = description, name = name, requestId = requestId, tags = tags, cacheBucketOwnerId = cacheBucketOwnerId)
  output <- .omics$create_run_cache_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_run_cache <- omics_create_run_cache

#' Creates a run group to limit the compute resources for the runs that are
#' added to the group
#'
#' @description
#' Creates a run group to limit the compute resources for the runs that are
#' added to the group. Returns an ARN, ID, and tags for the run group.
#'
#' @usage
#' omics_create_run_group(name, maxCpus, maxRuns, maxDuration, tags,
#'   requestId, maxGpus)
#'
#' @param name A name for the group.
#' @param maxCpus The maximum number of CPUs that can run concurrently across all active
#' runs in the run group.
#' @param maxRuns The maximum number of runs that can be running at the same time.
#' @param maxDuration The maximum time for each run (in minutes). If a run exceeds the maximum
#' run time, the run fails automatically.
#' @param tags Tags for the group.
#' @param requestId &#91;required&#93; To ensure that requests don't run multiple times, specify a unique ID
#' for each request.
#' @param maxGpus The maximum number of GPUs that can run concurrently across all active
#' runs in the run group.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_run_group(
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   maxGpus = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_run_group
#'
#' @aliases omics_create_run_group
omics_create_run_group <- function(name = NULL, maxCpus = NULL, maxRuns = NULL, maxDuration = NULL, tags = NULL, requestId, maxGpus = NULL) {
  op <- new_operation(
    name = "CreateRunGroup",
    http_method = "POST",
    http_path = "/runGroup",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_run_group_input(name = name, maxCpus = maxCpus, maxRuns = maxRuns, maxDuration = maxDuration, tags = tags, requestId = requestId, maxGpus = maxGpus)
  output <- .omics$create_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_run_group <- omics_create_run_group

#' Creates a sequence store and returns its metadata
#'
#' @description
#' Creates a sequence store and returns its metadata. Sequence stores are
#' used to store sequence data files called read sets that are saved in
#' FASTQ, BAM, uBAM, or CRAM formats. For aligned formats (BAM and CRAM), a
#' sequence store can only use one reference genome. For unaligned formats
#' (FASTQ and uBAM), a reference genome is not required. You can create
#' multiple sequence stores per region per account.
#' 
#' The following are optional parameters you can specify for your sequence
#' store:
#' 
#' -   Use `s3AccessConfig` to configure your sequence store with S3 access
#'     logs (recommended).
#' 
#' -   Use `sseConfig` to define your own KMS key for encryption.
#' 
#' -   Use `eTagAlgorithmFamily` to define which algorithm to use for the
#'     HealthOmics eTag on objects.
#' 
#' -   Use `fallbackLocation` to define a backup location for storing files
#'     that have failed a direct upload.
#' 
#' -   Use `propagatedSetLevelTags` to configure tags that propagate to all
#'     objects in your store.
#' 
#' For more information, see [Creating a HealthOmics sequence
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-sequence-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_sequence_store(name, description, sseConfig, tags,
#'   clientToken, fallbackLocation, eTagAlgorithmFamily,
#'   propagatedSetLevelTags, s3AccessConfig)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#' @param tags Tags for the store. You can configure up to 50 tags.
#' @param clientToken An idempotency token used to dedupe retry requests so that duplicate
#' runs are not created.
#' @param fallbackLocation An S3 location that is used to store files that have failed a direct
#' upload. You can add or change the `fallbackLocation` after creating a
#' sequence store. This is not required if you are uploading files from a
#' different S3 bucket.
#' @param eTagAlgorithmFamily The ETag algorithm family to use for ingested read sets. The default
#' value is MD5up. For more information on ETags, see [ETags and data
#' provenance](https://docs.aws.amazon.com/omics/latest/dev/etags-and-provenance.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param propagatedSetLevelTags The tags keys to propagate to the S3 objects associated with read sets
#' in the sequence store. These tags can be used as input to add metadata
#' to your read sets.
#' @param s3AccessConfig S3 access configuration parameters. This specifies the parameters needed
#' to access logs stored in S3 buckets. The S3 bucket must be in the same
#' region and account as the sequence store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   fallbackLocation = "string",
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"FAILED",
#'   statusMessage = "string",
#'   propagatedSetLevelTags = list(
#'     "string"
#'   ),
#'   s3Access = list(
#'     s3Uri = "string",
#'     s3AccessPointArn = "string",
#'     accessLogLocation = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_sequence_store(
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientToken = "string",
#'   fallbackLocation = "string",
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up",
#'   propagatedSetLevelTags = list(
#'     "string"
#'   ),
#'   s3AccessConfig = list(
#'     accessLogLocation = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_sequence_store
#'
#' @aliases omics_create_sequence_store
omics_create_sequence_store <- function(name, description = NULL, sseConfig = NULL, tags = NULL, clientToken = NULL, fallbackLocation = NULL, eTagAlgorithmFamily = NULL, propagatedSetLevelTags = NULL, s3AccessConfig = NULL) {
  op <- new_operation(
    name = "CreateSequenceStore",
    http_method = "POST",
    http_path = "/sequencestore",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_sequence_store_input(name = name, description = description, sseConfig = sseConfig, tags = tags, clientToken = clientToken, fallbackLocation = fallbackLocation, eTagAlgorithmFamily = eTagAlgorithmFamily, propagatedSetLevelTags = propagatedSetLevelTags, s3AccessConfig = s3AccessConfig)
  output <- .omics$create_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_sequence_store <- omics_create_sequence_store

#' Creates a cross-account shared resource
#'
#' @description
#' Creates a cross-account shared resource. The resource owner makes an
#' offer to share the resource with the principal subscriber (an AWS user
#' with a different account than the resource owner).
#' 
#' The following resources support cross-account sharing:
#' 
#' -   HealthOmics variant stores
#' 
#' -   HealthOmics annotation stores
#' 
#' -   Private workflows
#'
#' @usage
#' omics_create_share(resourceArn, principalSubscriber, shareName)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to be shared.
#' @param principalSubscriber &#91;required&#93; The principal subscriber is the account being offered shared access to
#' the resource.
#' @param shareName A name that the owner defines for the share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   shareId = "string",
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'   shareName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_share(
#'   resourceArn = "string",
#'   principalSubscriber = "string",
#'   shareName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_share
#'
#' @aliases omics_create_share
omics_create_share <- function(resourceArn, principalSubscriber, shareName = NULL) {
  op <- new_operation(
    name = "CreateShare",
    http_method = "POST",
    http_path = "/share",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_share_input(resourceArn = resourceArn, principalSubscriber = principalSubscriber, shareName = shareName)
  output <- .omics$create_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_share <- omics_create_share

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Creates a variant store.
#'
#' @usage
#' omics_create_variant_store(reference, name, description, tags,
#'   sseConfig)
#'
#' @param reference &#91;required&#93; The genome reference for the store's variants.
#' @param name A name for the store.
#' @param description A description for the store.
#' @param tags Tags for the store.
#' @param sseConfig Server-side encryption (SSE) settings for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_variant_store(
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   name = "string",
#'   description = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_variant_store
#'
#' @aliases omics_create_variant_store
omics_create_variant_store <- function(reference, name = NULL, description = NULL, tags = NULL, sseConfig = NULL) {
  op <- new_operation(
    name = "CreateVariantStore",
    http_method = "POST",
    http_path = "/variantStore",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_variant_store_input(reference = reference, name = name, description = description, tags = tags, sseConfig = sseConfig)
  output <- .omics$create_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_variant_store <- omics_create_variant_store

#' Creates a private workflow
#'
#' @description
#' Creates a private workflow. Before you create a private workflow, you
#' must create and configure these required resources:
#' 
#' -   *Workflow definition file:* A workflow definition file written in
#'     WDL, Nextflow, or CWL. The workflow definition specifies the inputs
#'     and outputs for runs that use the workflow. It also includes
#'     specifications for the runs and run tasks for your workflow,
#'     including compute and memory requirements. The workflow definition
#'     file must be in `.zip` format. For more information, see [Workflow
#'     definition
#'     files](https://docs.aws.amazon.com/omics/latest/dev/workflow-definition-files.html)
#'     in Amazon Web Services HealthOmics.
#' 
#'     -   You can use Amazon Q CLI to build and validate your workflow
#'         definition files in WDL, Nextflow, and CWL. For more
#'         information, see [Example prompts for Amazon Q
#'         CLI](https://docs.aws.amazon.com/omics/latest/dev/getting-started.html#omics-q-prompts)
#'         and the [Amazon Web Services HealthOmics Agentic generative AI
#'         tutorial](https://github.com/aws-samples/aws-healthomics-tutorials/tree/main/generative-ai)
#'         on GitHub.
#' 
#' -   *(Optional) Parameter template file:* A parameter template file
#'     written in JSON. Create the file to define the run parameters, or
#'     Amazon Web Services HealthOmics generates the parameter template for
#'     you. For more information, see [Parameter template files for
#'     HealthOmics
#'     workflows](https://docs.aws.amazon.com/omics/latest/dev/parameter-templates.html).
#' 
#' -   *ECR container images:* Create container images for the workflow in
#'     a private ECR repository, or synchronize images from a supported
#'     upstream registry with your Amazon ECR private repository.
#' 
#' -   *(Optional) Sentieon licenses:* Request a Sentieon license to use
#'     the Sentieon software in private workflows.
#' 
#' For more information, see [Creating or updating a private workflow in
#' Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/creating-private-workflows.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_workflow(name, description, engine, definitionZip,
#'   definitionUri, main, parameterTemplate, storageCapacity, tags,
#'   requestId, accelerators, storageType, containerRegistryMap,
#'   containerRegistryMapUri, readmeMarkdown, parameterTemplatePath,
#'   readmePath, definitionRepository, workflowBucketOwnerId, readmeUri)
#'
#' @param name Name (optional but highly recommended) for the workflow to locate
#' relevant information in the CloudWatch logs and Amazon Web Services
#' HealthOmics console.
#' @param description A description for the workflow.
#' @param engine The workflow engine for the workflow. This is only required if you have
#' workflow definition files from more than one engine in your zip file.
#' Otherwise, the service can detect the engine automatically from your
#' workflow definition.
#' @param definitionZip A ZIP archive containing the main workflow definition file and
#' dependencies that it imports for the workflow. You can use a file with a
#' ://fileb prefix instead of the Base64 string. For more information, see
#' [Workflow definition
#' requirements](https://docs.aws.amazon.com/omics/latest/dev/workflow-defn-requirements.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param definitionUri The S3 URI of a definition for the workflow. The S3 bucket must be in
#' the same region as the workflow.
#' @param main The path of the main definition file for the workflow. This parameter is
#' not required if the ZIP archive contains only one workflow definition
#' file, or if the main definition file is named “main”. An example path
#' is: `workflow-definition/main-file.wdl`.
#' @param parameterTemplate A parameter template for the workflow. If this field is blank, Amazon
#' Web Services HealthOmics will automatically parse the parameter template
#' values from your workflow definition file. To override these service
#' generated default values, provide a parameter template. To view an
#' example of a parameter template, see [Parameter template
#' files](https://docs.aws.amazon.com/omics/latest/dev/parameter-templates.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param storageCapacity The default static storage capacity (in gibibytes) for runs that use
#' this workflow or workflow version. The `storageCapacity` can be
#' overwritten at run time. The storage capacity is not required for runs
#' with a `DYNAMIC` storage type.
#' @param tags Tags for the workflow. You can define up to 50 tags for the workflow.
#' For more information, see [Adding a
#' tag](https://docs.aws.amazon.com/omics/latest/dev/add-a-tag.html) in the
#' *Amazon Web Services HealthOmics User Guide*.
#' @param requestId &#91;required&#93; An idempotency token to ensure that duplicate workflows are not created
#' when Amazon Web Services HealthOmics submits retry requests.
#' @param accelerators The computational accelerator specified to run the workflow.
#' @param storageType The default storage type for runs that use this workflow. The
#' `storageType` can be overridden at run time. `DYNAMIC` storage
#' dynamically scales the storage up or down, based on file system
#' utilization. `STATIC` storage allocates a fixed amount of storage. For
#' more information about dynamic and static storage types, see [Run
#' storage
#' types](https://docs.aws.amazon.com/omics/latest/dev/workflows-run-types.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param containerRegistryMap (Optional) Use a container registry map to specify mappings between the
#' ECR private repository and one or more upstream registries. For more
#' information, see [Container
#' images](https://docs.aws.amazon.com/omics/latest/dev/workflows-ecr.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param containerRegistryMapUri (Optional) URI of the S3 location for the registry mapping file.
#' @param readmeMarkdown The markdown content for the workflow's README file. This provides
#' documentation and usage information for users of the workflow.
#' @param parameterTemplatePath The path to the workflow parameter template JSON file within the
#' repository. This file defines the input parameters for runs that use
#' this workflow. If not specified, the workflow will be created without a
#' parameter template.
#' @param readmePath The path to the workflow README markdown file within the repository.
#' This file provides documentation and usage information for the workflow.
#' If not specified, the `README.md` file from the root directory of the
#' repository will be used.
#' @param definitionRepository The repository information for the workflow definition. This allows you
#' to source your workflow definition directly from a code repository.
#' @param workflowBucketOwnerId The Amazon Web Services account ID of the expected owner of the S3
#' bucket that contains the workflow definition. If not specified, the
#' service skips the validation.
#' @param readmeUri The S3 URI of the README file for the workflow. This file provides
#' documentation and usage information for the workflow. Requirements
#' include:
#' 
#' -   The S3 URI must begin with `s3://USER-OWNED-BUCKET/`
#' 
#' -   The requester must have access to the S3 bucket and object.
#' 
#' -   The max README content length is 500 KiB.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   tags = list(
#'     "string"
#'   ),
#'   uuid = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_workflow(
#'   name = "string",
#'   description = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL"|"WDL_LENIENT",
#'   definitionZip = raw,
#'   definitionUri = "string",
#'   main = "string",
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   storageCapacity = 123,
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   accelerators = "GPU",
#'   storageType = "STATIC"|"DYNAMIC",
#'   containerRegistryMap = list(
#'     registryMappings = list(
#'       list(
#'         upstreamRegistryUrl = "string",
#'         ecrRepositoryPrefix = "string",
#'         upstreamRepositoryPrefix = "string",
#'         ecrAccountId = "string"
#'       )
#'     ),
#'     imageMappings = list(
#'       list(
#'         sourceImage = "string",
#'         destinationImage = "string"
#'       )
#'     )
#'   ),
#'   containerRegistryMapUri = "string",
#'   readmeMarkdown = "string",
#'   parameterTemplatePath = "string",
#'   readmePath = "string",
#'   definitionRepository = list(
#'     connectionArn = "string",
#'     fullRepositoryId = "string",
#'     sourceReference = list(
#'       type = "BRANCH"|"TAG"|"COMMIT",
#'       value = "string"
#'     ),
#'     excludeFilePatterns = list(
#'       "string"
#'     )
#'   ),
#'   workflowBucketOwnerId = "string",
#'   readmeUri = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_workflow
#'
#' @aliases omics_create_workflow
omics_create_workflow <- function(name = NULL, description = NULL, engine = NULL, definitionZip = NULL, definitionUri = NULL, main = NULL, parameterTemplate = NULL, storageCapacity = NULL, tags = NULL, requestId, accelerators = NULL, storageType = NULL, containerRegistryMap = NULL, containerRegistryMapUri = NULL, readmeMarkdown = NULL, parameterTemplatePath = NULL, readmePath = NULL, definitionRepository = NULL, workflowBucketOwnerId = NULL, readmeUri = NULL) {
  op <- new_operation(
    name = "CreateWorkflow",
    http_method = "POST",
    http_path = "/workflow",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_workflow_input(name = name, description = description, engine = engine, definitionZip = definitionZip, definitionUri = definitionUri, main = main, parameterTemplate = parameterTemplate, storageCapacity = storageCapacity, tags = tags, requestId = requestId, accelerators = accelerators, storageType = storageType, containerRegistryMap = containerRegistryMap, containerRegistryMapUri = containerRegistryMapUri, readmeMarkdown = readmeMarkdown, parameterTemplatePath = parameterTemplatePath, readmePath = readmePath, definitionRepository = definitionRepository, workflowBucketOwnerId = workflowBucketOwnerId, readmeUri = readmeUri)
  output <- .omics$create_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_workflow <- omics_create_workflow

#' Creates a new workflow version for the workflow that you specify with
#' the workflowId parameter
#'
#' @description
#' Creates a new workflow version for the workflow that you specify with
#' the `workflowId` parameter.
#' 
#' When you create a new version of a workflow, you need to specify the
#' configuration for the new version. It doesn't inherit any configuration
#' values from the workflow.
#' 
#' Provide a version name that is unique for this workflow. You cannot
#' change the name after HealthOmics creates the version.
#' 
#' Don't include any personally identifiable information (PII) in the
#' version name. Version names appear in the workflow version ARN.
#' 
#' For more information, see [Workflow versioning in Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_create_workflow_version(workflowId, versionName, definitionZip,
#'   definitionUri, accelerators, description, engine, main,
#'   parameterTemplate, requestId, storageType, storageCapacity, tags,
#'   workflowBucketOwnerId, containerRegistryMap, containerRegistryMapUri,
#'   readmeMarkdown, parameterTemplatePath, readmePath, definitionRepository,
#'   readmeUri)
#'
#' @param workflowId &#91;required&#93; The ID of the workflow where you are creating the new version. The
#' `workflowId` is not the UUID.
#' @param versionName &#91;required&#93; A name for the workflow version. Provide a version name that is unique
#' for this workflow. You cannot change the name after HealthOmics creates
#' the version.
#' 
#' The version name must start with a letter or number and it can include
#' upper-case and lower-case letters, numbers, hyphens, periods and
#' underscores. The maximum length is 64 characters. You can use a simple
#' naming scheme, such as version1, version2, version3. You can also match
#' your workflow versions with your own internal versioning conventions,
#' such as 2.7.0, 2.7.1, 2.7.2.
#' @param definitionZip A ZIP archive containing the main workflow definition file and
#' dependencies that it imports for this workflow version. You can use a
#' file with a ://fileb prefix instead of the Base64 string. For more
#' information, see Workflow definition requirements in the *Amazon Web
#' Services HealthOmics User Guide*.
#' @param definitionUri The S3 URI of a definition for this workflow version. The S3 bucket must
#' be in the same region as this workflow version.
#' @param accelerators The computational accelerator for this workflow version.
#' @param description A description for this workflow version.
#' @param engine The workflow engine for this workflow version. This is only required if
#' you have workflow definition files from more than one engine in your zip
#' file. Otherwise, the service can detect the engine automatically from
#' your workflow definition.
#' @param main The path of the main definition file for this workflow version. This
#' parameter is not required if the ZIP archive contains only one workflow
#' definition file, or if the main definition file is named “main”. An
#' example path is: `workflow-definition/main-file.wdl`.
#' @param parameterTemplate A parameter template for this workflow version. If this field is blank,
#' Amazon Web Services HealthOmics will automatically parse the parameter
#' template values from your workflow definition file. To override these
#' service generated default values, provide a parameter template. To view
#' an example of a parameter template, see [Parameter template
#' files](https://docs.aws.amazon.com/omics/latest/dev/parameter-templates.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param requestId &#91;required&#93; An idempotency token to ensure that duplicate workflows are not created
#' when Amazon Web Services HealthOmics submits retry requests.
#' @param storageType The default storage type for runs that use this workflow version. The
#' `storageType` can be overridden at run time. `DYNAMIC` storage
#' dynamically scales the storage up or down, based on file system
#' utilization. STATIC storage allocates a fixed amount of storage. For
#' more information about dynamic and static storage types, see [Run
#' storage
#' types](https://docs.aws.amazon.com/omics/latest/dev/workflows-run-types.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param storageCapacity The default static storage capacity (in gibibytes) for runs that use
#' this workflow version. The `storageCapacity` can be overwritten at run
#' time. The storage capacity is not required for runs with a `DYNAMIC`
#' storage type.
#' @param tags Tags for this workflow version. You can define up to 50 tags for the
#' workflow. For more information, see [Adding a
#' tag](https://docs.aws.amazon.com/omics/latest/dev/add-a-tag.html) in the
#' *Amazon Web Services HealthOmics User Guide*.
#' @param workflowBucketOwnerId Amazon Web Services Id of the owner of the S3 bucket that contains the
#' workflow definition. You need to specify this parameter if your account
#' is not the bucket owner.
#' @param containerRegistryMap (Optional) Use a container registry map to specify mappings between the
#' ECR private repository and one or more upstream registries. For more
#' information, see [Container
#' images](https://docs.aws.amazon.com/omics/latest/dev/workflows-ecr.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param containerRegistryMapUri (Optional) URI of the S3 location for the registry mapping file.
#' @param readmeMarkdown The markdown content for the workflow version's README file. This
#' provides documentation and usage information for users of this specific
#' workflow version.
#' @param parameterTemplatePath The path to the workflow version parameter template JSON file within the
#' repository. This file defines the input parameters for runs that use
#' this workflow version. If not specified, the workflow version will be
#' created without a parameter template.
#' @param readmePath The path to the workflow version README markdown file within the
#' repository. This file provides documentation and usage information for
#' the workflow. If not specified, the `README.md` file from the root
#' directory of the repository will be used.
#' @param definitionRepository The repository information for the workflow version definition. This
#' allows you to source your workflow version definition directly from a
#' code repository.
#' @param readmeUri The S3 URI of the README file for the workflow version. This file
#' provides documentation and usage information for the workflow version.
#' Requirements include:
#' 
#' -   The S3 URI must begin with `s3://USER-OWNED-BUCKET/`
#' 
#' -   The requester must have access to the S3 bucket and object.
#' 
#' -   The max README content length is 500 KiB.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   workflowId = "string",
#'   versionName = "string",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   tags = list(
#'     "string"
#'   ),
#'   uuid = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_workflow_version(
#'   workflowId = "string",
#'   versionName = "string",
#'   definitionZip = raw,
#'   definitionUri = "string",
#'   accelerators = "GPU",
#'   description = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL"|"WDL_LENIENT",
#'   main = "string",
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   requestId = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   storageCapacity = 123,
#'   tags = list(
#'     "string"
#'   ),
#'   workflowBucketOwnerId = "string",
#'   containerRegistryMap = list(
#'     registryMappings = list(
#'       list(
#'         upstreamRegistryUrl = "string",
#'         ecrRepositoryPrefix = "string",
#'         upstreamRepositoryPrefix = "string",
#'         ecrAccountId = "string"
#'       )
#'     ),
#'     imageMappings = list(
#'       list(
#'         sourceImage = "string",
#'         destinationImage = "string"
#'       )
#'     )
#'   ),
#'   containerRegistryMapUri = "string",
#'   readmeMarkdown = "string",
#'   parameterTemplatePath = "string",
#'   readmePath = "string",
#'   definitionRepository = list(
#'     connectionArn = "string",
#'     fullRepositoryId = "string",
#'     sourceReference = list(
#'       type = "BRANCH"|"TAG"|"COMMIT",
#'       value = "string"
#'     ),
#'     excludeFilePatterns = list(
#'       "string"
#'     )
#'   ),
#'   readmeUri = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_create_workflow_version
#'
#' @aliases omics_create_workflow_version
omics_create_workflow_version <- function(workflowId, versionName, definitionZip = NULL, definitionUri = NULL, accelerators = NULL, description = NULL, engine = NULL, main = NULL, parameterTemplate = NULL, requestId, storageType = NULL, storageCapacity = NULL, tags = NULL, workflowBucketOwnerId = NULL, containerRegistryMap = NULL, containerRegistryMapUri = NULL, readmeMarkdown = NULL, parameterTemplatePath = NULL, readmePath = NULL, definitionRepository = NULL, readmeUri = NULL) {
  op <- new_operation(
    name = "CreateWorkflowVersion",
    http_method = "POST",
    http_path = "/workflow/{workflowId}/version",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$create_workflow_version_input(workflowId = workflowId, versionName = versionName, definitionZip = definitionZip, definitionUri = definitionUri, accelerators = accelerators, description = description, engine = engine, main = main, parameterTemplate = parameterTemplate, requestId = requestId, storageType = storageType, storageCapacity = storageCapacity, tags = tags, workflowBucketOwnerId = workflowBucketOwnerId, containerRegistryMap = containerRegistryMap, containerRegistryMapUri = containerRegistryMapUri, readmeMarkdown = readmeMarkdown, parameterTemplatePath = parameterTemplatePath, readmePath = readmePath, definitionRepository = definitionRepository, readmeUri = readmeUri)
  output <- .omics$create_workflow_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$create_workflow_version <- omics_create_workflow_version

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Deletes an annotation store.
#'
#' @usage
#' omics_delete_annotation_store(name, force)
#'
#' @param name &#91;required&#93; The store's name.
#' @param force Whether to force deletion.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_annotation_store(
#'   name = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_annotation_store
#'
#' @aliases omics_delete_annotation_store
omics_delete_annotation_store <- function(name, force = NULL) {
  op <- new_operation(
    name = "DeleteAnnotationStore",
    http_method = "DELETE",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_annotation_store_input(name = name, force = force)
  output <- .omics$delete_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_annotation_store <- omics_delete_annotation_store

#' Deletes one or multiple versions of an annotation store
#'
#' @description
#' Deletes one or multiple versions of an annotation store.
#'
#' @usage
#' omics_delete_annotation_store_versions(name, versions, force)
#'
#' @param name &#91;required&#93; The name of the annotation store from which versions are being deleted.
#' @param versions &#91;required&#93; The versions of an annotation store to be deleted.
#' @param force Forces the deletion of an annotation store version when imports are
#' in-progress..
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       versionName = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_annotation_store_versions(
#'   name = "string",
#'   versions = list(
#'     "string"
#'   ),
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_annotation_store_versions
#'
#' @aliases omics_delete_annotation_store_versions
omics_delete_annotation_store_versions <- function(name, versions, force = NULL) {
  op <- new_operation(
    name = "DeleteAnnotationStoreVersions",
    http_method = "POST",
    http_path = "/annotationStore/{name}/versions/delete",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_annotation_store_versions_input(name = name, versions = versions, force = force)
  output <- .omics$delete_annotation_store_versions_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_annotation_store_versions <- omics_delete_annotation_store_versions

#' Deletes a reference genome and returns a response with no body if the
#' operation is successful
#'
#' @description
#' Deletes a reference genome and returns a response with no body if the
#' operation is successful. The read set associated with the reference
#' genome must first be deleted before deleting the reference genome. After
#' the reference genome is deleted, you can delete the reference store
#' using the [`delete_reference_store`][omics_delete_reference_store] API
#' operation.
#' 
#' For more information, see [Deleting HealthOmics reference and sequence
#' stores](https://docs.aws.amazon.com/omics/latest/dev/deleting-reference-and-sequence-stores.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_delete_reference(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's store ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_reference(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_reference
#'
#' @aliases omics_delete_reference
omics_delete_reference <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "DeleteReference",
    http_method = "DELETE",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_reference_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$delete_reference_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_reference <- omics_delete_reference

#' Deletes a reference store and returns a response with no body if the
#' operation is successful
#'
#' @description
#' Deletes a reference store and returns a response with no body if the
#' operation is successful. You can only delete a reference store when it
#' does not contain any reference genomes. To empty a reference store, use
#' [`delete_reference`][omics_delete_reference].
#' 
#' For more information about your workflow status, see [Deleting
#' HealthOmics reference and sequence
#' stores](https://docs.aws.amazon.com/omics/latest/dev/deleting-reference-and-sequence-stores.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_delete_reference_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_reference_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_reference_store
#'
#' @aliases omics_delete_reference_store
omics_delete_reference_store <- function(id) {
  op <- new_operation(
    name = "DeleteReferenceStore",
    http_method = "DELETE",
    http_path = "/referencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_reference_store_input(id = id)
  output <- .omics$delete_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_reference_store <- omics_delete_reference_store

#' Deletes a run and returns a response with no body if the operation is
#' successful
#'
#' @description
#' Deletes a run and returns a response with no body if the operation is
#' successful. You can only delete a run that has reached a `COMPLETED`,
#' `FAILED`, or `CANCELLED` stage. A completed run has delivered an output,
#' or was cancelled and resulted in no output. When you delete a run, only
#' the metadata associated with the run is deleted. The run outputs remain
#' in Amazon S3 and logs remain in CloudWatch.
#' 
#' To verify that the workflow is deleted:
#' 
#' -   Use [`list_runs`][omics_list_runs] to confirm the workflow no longer
#'     appears in the list.
#' 
#' -   Use [`get_run`][omics_get_run] to verify the workflow cannot be
#'     found.
#'
#' @usage
#' omics_delete_run(id)
#'
#' @param id &#91;required&#93; The run's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_run(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_run
#'
#' @aliases omics_delete_run
omics_delete_run <- function(id) {
  op <- new_operation(
    name = "DeleteRun",
    http_method = "DELETE",
    http_path = "/run/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_run_input(id = id)
  output <- .omics$delete_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_run <- omics_delete_run

#' Deletes a run cache and returns a response with no body if the operation
#' is successful
#'
#' @description
#' Deletes a run cache and returns a response with no body if the operation
#' is successful. This action removes the cache metadata stored in the
#' service account, but does not delete the data in Amazon S3. You can
#' access the cache data in Amazon S3, for inspection or to troubleshoot
#' issues. You can remove old cache data using standard S3 `Delete`
#' operations.
#' 
#' For more information, see [Deleting a run
#' cache](https://docs.aws.amazon.com/omics/latest/dev/workflow-cache-delete.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_delete_run_cache(id)
#'
#' @param id &#91;required&#93; Run cache identifier for the cache you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_run_cache(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_run_cache
#'
#' @aliases omics_delete_run_cache
omics_delete_run_cache <- function(id) {
  op <- new_operation(
    name = "DeleteRunCache",
    http_method = "DELETE",
    http_path = "/runCache/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_run_cache_input(id = id)
  output <- .omics$delete_run_cache_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_run_cache <- omics_delete_run_cache

#' Deletes a run group and returns a response with no body if the operation
#' is successful
#'
#' @description
#' Deletes a run group and returns a response with no body if the operation
#' is successful.
#' 
#' To verify that the run group is deleted:
#' 
#' -   Use [`list_run_groups`][omics_list_run_groups] to confirm the
#'     workflow no longer appears in the list.
#' 
#' -   Use [`get_run_group`][omics_get_run_group] to verify the workflow
#'     cannot be found.
#'
#' @usage
#' omics_delete_run_group(id)
#'
#' @param id &#91;required&#93; The run group's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_run_group(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_run_group
#'
#' @aliases omics_delete_run_group
omics_delete_run_group <- function(id) {
  op <- new_operation(
    name = "DeleteRunGroup",
    http_method = "DELETE",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_run_group_input(id = id)
  output <- .omics$delete_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_run_group <- omics_delete_run_group

#' Deletes an access policy for the specified store
#'
#' @description
#' Deletes an access policy for the specified store.
#'
#' @usage
#' omics_delete_s3_access_policy(s3AccessPointArn)
#'
#' @param s3AccessPointArn &#91;required&#93; The S3 access point ARN that has the access policy.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_s3_access_policy(
#'   s3AccessPointArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_s3_access_policy
#'
#' @aliases omics_delete_s3_access_policy
omics_delete_s3_access_policy <- function(s3AccessPointArn) {
  op <- new_operation(
    name = "DeleteS3AccessPolicy",
    http_method = "DELETE",
    http_path = "/s3accesspolicy/{s3AccessPointArn}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_s3_access_policy_input(s3AccessPointArn = s3AccessPointArn)
  output <- .omics$delete_s3_access_policy_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_s3_access_policy <- omics_delete_s3_access_policy

#' Deletes a sequence store and returns a response with no body if the
#' operation is successful
#'
#' @description
#' Deletes a sequence store and returns a response with no body if the
#' operation is successful. You can only delete a sequence store when it
#' does not contain any read sets.
#' 
#' Use the [`batch_delete_read_set`][omics_batch_delete_read_set] API
#' operation to ensure that all read sets in the sequence store are
#' deleted. When a sequence store is deleted, all tags associated with the
#' store are also deleted.
#' 
#' For more information, see [Deleting HealthOmics reference and sequence
#' stores](https://docs.aws.amazon.com/omics/latest/dev/deleting-reference-and-sequence-stores.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_delete_sequence_store(id)
#'
#' @param id &#91;required&#93; The sequence store's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_sequence_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_sequence_store
#'
#' @aliases omics_delete_sequence_store
omics_delete_sequence_store <- function(id) {
  op <- new_operation(
    name = "DeleteSequenceStore",
    http_method = "DELETE",
    http_path = "/sequencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_sequence_store_input(id = id)
  output <- .omics$delete_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_sequence_store <- omics_delete_sequence_store

#' Deletes a resource share
#'
#' @description
#' Deletes a resource share. If you are the resource owner, the subscriber
#' will no longer have access to the shared resource. If you are the
#' subscriber, this operation deletes your access to the share.
#'
#' @usage
#' omics_delete_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID for the resource share to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_share
#'
#' @aliases omics_delete_share
omics_delete_share <- function(shareId) {
  op <- new_operation(
    name = "DeleteShare",
    http_method = "DELETE",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_share_input(shareId = shareId)
  output <- .omics$delete_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_share <- omics_delete_share

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Deletes a variant store.
#'
#' @usage
#' omics_delete_variant_store(name, force)
#'
#' @param name &#91;required&#93; The store's name.
#' @param force Whether to force deletion.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_variant_store(
#'   name = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_variant_store
#'
#' @aliases omics_delete_variant_store
omics_delete_variant_store <- function(name, force = NULL) {
  op <- new_operation(
    name = "DeleteVariantStore",
    http_method = "DELETE",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_variant_store_input(name = name, force = force)
  output <- .omics$delete_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_variant_store <- omics_delete_variant_store

#' Deletes a workflow by specifying its ID
#'
#' @description
#' Deletes a workflow by specifying its ID. This operation returns a
#' response with no body if the deletion is successful.
#' 
#' To verify that the workflow is deleted:
#' 
#' -   Use [`list_workflows`][omics_list_workflows] to confirm the workflow
#'     no longer appears in the list.
#' 
#' -   Use [`get_workflow`][omics_get_workflow] to verify the workflow
#'     cannot be found.
#'
#' @usage
#' omics_delete_workflow(id)
#'
#' @param id &#91;required&#93; The workflow's ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_workflow(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_workflow
#'
#' @aliases omics_delete_workflow
omics_delete_workflow <- function(id) {
  op <- new_operation(
    name = "DeleteWorkflow",
    http_method = "DELETE",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_workflow_input(id = id)
  output <- .omics$delete_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_workflow <- omics_delete_workflow

#' Deletes a workflow version
#'
#' @description
#' Deletes a workflow version. Deleting a workflow version doesn't affect
#' any ongoing runs that are using the workflow version.
#' 
#' For more information, see [Workflow versioning in Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_delete_workflow_version(workflowId, versionName)
#'
#' @param workflowId &#91;required&#93; The workflow's ID.
#' @param versionName &#91;required&#93; The workflow version name.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_workflow_version(
#'   workflowId = "string",
#'   versionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_delete_workflow_version
#'
#' @aliases omics_delete_workflow_version
omics_delete_workflow_version <- function(workflowId, versionName) {
  op <- new_operation(
    name = "DeleteWorkflowVersion",
    http_method = "DELETE",
    http_path = "/workflow/{workflowId}/version/{versionName}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$delete_workflow_version_input(workflowId = workflowId, versionName = versionName)
  output <- .omics$delete_workflow_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$delete_workflow_version <- omics_delete_workflow_version

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Gets information about an annotation import job.
#'
#' @usage
#' omics_get_annotation_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   destinationName = "string",
#'   versionName = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   items = list(
#'     list(
#'       source = "string",
#'       jobStatus = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   formatOptions = list(
#'     tsvOptions = list(
#'       readOptions = list(
#'         sep = "string",
#'         encoding = "string",
#'         quote = "string",
#'         quoteAll = TRUE|FALSE,
#'         escape = "string",
#'         escapeQuotes = TRUE|FALSE,
#'         comment = "string",
#'         header = TRUE|FALSE,
#'         lineSep = "string"
#'       )
#'     ),
#'     vcfOptions = list(
#'       ignoreQualField = TRUE|FALSE,
#'       ignoreFilterField = TRUE|FALSE
#'     )
#'   ),
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_import_job
#'
#' @aliases omics_get_annotation_import_job
omics_get_annotation_import_job <- function(jobId) {
  op <- new_operation(
    name = "GetAnnotationImportJob",
    http_method = "GET",
    http_path = "/import/annotation/{jobId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_annotation_import_job_input(jobId = jobId)
  output <- .omics$get_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_import_job <- omics_get_annotation_import_job

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Gets information about an annotation store.
#'
#' @usage
#' omics_get_annotation_store(name)
#'
#' @param name &#91;required&#93; The store's name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   storeArn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF",
#'   statusMessage = "string",
#'   storeSizeBytes = 123,
#'   numVersions = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_store(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_store
#'
#' @aliases omics_get_annotation_store
omics_get_annotation_store <- function(name) {
  op <- new_operation(
    name = "GetAnnotationStore",
    http_method = "GET",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_annotation_store_input(name = name)
  output <- .omics$get_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_store <- omics_get_annotation_store

#' Retrieves the metadata for an annotation store version
#'
#' @description
#' Retrieves the metadata for an annotation store version.
#'
#' @usage
#' omics_get_annotation_store_version(name, versionName)
#'
#' @param name &#91;required&#93; The name given to an annotation store version to distinguish it from
#' others.
#' @param versionName &#91;required&#93; The name given to an annotation store version to distinguish it from
#' others.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   storeId = "string",
#'   id = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   versionArn = "string",
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   versionOptions = list(
#'     tsvVersionOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   statusMessage = "string",
#'   versionSizeBytes = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_annotation_store_version(
#'   name = "string",
#'   versionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_annotation_store_version
#'
#' @aliases omics_get_annotation_store_version
omics_get_annotation_store_version <- function(name, versionName) {
  op <- new_operation(
    name = "GetAnnotationStoreVersion",
    http_method = "GET",
    http_path = "/annotationStore/{name}/version/{versionName}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_annotation_store_version_input(name = name, versionName = versionName)
  output <- .omics$get_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_annotation_store_version <- omics_get_annotation_store_version

#' Retrieves detailed information from parts of a read set and returns the
#' read set in the same format that it was uploaded
#'
#' @description
#' Retrieves detailed information from parts of a read set and returns the
#' read set in the same format that it was uploaded. You must have read
#' sets uploaded to your sequence store in order to run this operation.
#'
#' @usage
#' omics_get_read_set(id, sequenceStoreId, file, partNumber)
#'
#' @param id &#91;required&#93; The read set's ID.
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param file The file to retrieve.
#' @param partNumber &#91;required&#93; The part number to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   payload = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   file = "SOURCE1"|"SOURCE2"|"INDEX",
#'   partNumber = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set
#'
#' @aliases omics_get_read_set
omics_get_read_set <- function(id, sequenceStoreId, file = NULL, partNumber) {
  op <- new_operation(
    name = "GetReadSet",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/readset/{id}",
    host_prefix = "storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_read_set_input(id = id, sequenceStoreId = sequenceStoreId, file = file, partNumber = partNumber)
  output <- .omics$get_read_set_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set <- omics_get_read_set

#' Returns detailed information about the status of a read set activation
#' job in JSON format
#'
#' @description
#' Returns detailed information about the status of a read set activation
#' job in JSON format.
#'
#' @usage
#' omics_get_read_set_activation_job(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       readSetId = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_activation_job(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_activation_job
#'
#' @aliases omics_get_read_set_activation_job
omics_get_read_set_activation_job <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetActivationJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/activationjob/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_read_set_activation_job_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_activation_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_activation_job <- omics_get_read_set_activation_job

#' Retrieves status information about a read set export job and returns the
#' data in JSON format
#'
#' @description
#' Retrieves status information about a read set export job and returns the
#' data in JSON format. Use this operation to actively monitor the progress
#' of an export job.
#'
#' @usage
#' omics_get_read_set_export_job(sequenceStoreId, id)
#'
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#' @param id &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   readSets = list(
#'     list(
#'       id = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_export_job(
#'   sequenceStoreId = "string",
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_export_job
#'
#' @aliases omics_get_read_set_export_job
omics_get_read_set_export_job <- function(sequenceStoreId, id) {
  op <- new_operation(
    name = "GetReadSetExportJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/exportjob/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_read_set_export_job_input(sequenceStoreId = sequenceStoreId, id = id)
  output <- .omics$get_read_set_export_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_export_job <- omics_get_read_set_export_job

#' Gets detailed and status information about a read set import job and
#' returns the data in JSON format
#'
#' @description
#' Gets detailed and status information about a read set import job and
#' returns the data in JSON format.
#'
#' @usage
#' omics_get_read_set_import_job(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param sequenceStoreId &#91;required&#93; The job's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       sourceFiles = list(
#'         source1 = "string",
#'         source2 = "string"
#'       ),
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_import_job(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_import_job
#'
#' @aliases omics_get_read_set_import_job
omics_get_read_set_import_job <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetImportJob",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/importjob/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_read_set_import_job_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_import_job <- omics_get_read_set_import_job

#' Retrieves the metadata for a read set from a sequence store in JSON
#' format
#'
#' @description
#' Retrieves the metadata for a read set from a sequence store in JSON
#' format. This operation does not return tags. To retrieve the list of
#' tags for a read set, use the
#' [`list_tags_for_resource`][omics_list_tags_for_resource] API operation.
#'
#' @usage
#' omics_get_read_set_metadata(id, sequenceStoreId)
#'
#' @param id &#91;required&#93; The read set's ID.
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   sequenceStoreId = "string",
#'   subjectId = "string",
#'   sampleId = "string",
#'   status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'   name = "string",
#'   description = "string",
#'   fileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sequenceInformation = list(
#'     totalReadCount = 123,
#'     totalBaseCount = 123,
#'     generatedFrom = "string",
#'     alignment = "string"
#'   ),
#'   referenceArn = "string",
#'   files = list(
#'     source1 = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     source2 = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     index = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   statusMessage = "string",
#'   creationType = "IMPORT"|"UPLOAD",
#'   etag = list(
#'     algorithm = "FASTQ_MD5up"|"BAM_MD5up"|"CRAM_MD5up"|"FASTQ_SHA256up"|"BAM_SHA256up"|"CRAM_SHA256up"|"FASTQ_SHA512up"|"BAM_SHA512up"|"CRAM_SHA512up",
#'     source1 = "string",
#'     source2 = "string"
#'   ),
#'   creationJobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_read_set_metadata(
#'   id = "string",
#'   sequenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_read_set_metadata
#'
#' @aliases omics_get_read_set_metadata
omics_get_read_set_metadata <- function(id, sequenceStoreId) {
  op <- new_operation(
    name = "GetReadSetMetadata",
    http_method = "GET",
    http_path = "/sequencestore/{sequenceStoreId}/readset/{id}/metadata",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_read_set_metadata_input(id = id, sequenceStoreId = sequenceStoreId)
  output <- .omics$get_read_set_metadata_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_read_set_metadata <- omics_get_read_set_metadata

#' Downloads parts of data from a reference genome and returns the
#' reference file in the same format that it was uploaded
#'
#' @description
#' Downloads parts of data from a reference genome and returns the
#' reference file in the same format that it was uploaded.
#' 
#' For more information, see [Creating a HealthOmics reference
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-reference-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_get_reference(id, referenceStoreId, range, partNumber, file)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's store ID.
#' @param range The range to retrieve.
#' @param partNumber &#91;required&#93; The part number to retrieve.
#' @param file The file to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   payload = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference(
#'   id = "string",
#'   referenceStoreId = "string",
#'   range = "string",
#'   partNumber = 123,
#'   file = "SOURCE"|"INDEX"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference
#'
#' @aliases omics_get_reference
omics_get_reference <- function(id, referenceStoreId, range = NULL, partNumber, file = NULL) {
  op <- new_operation(
    name = "GetReference",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}",
    host_prefix = "storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_reference_input(id = id, referenceStoreId = referenceStoreId, range = range, partNumber = partNumber, file = file)
  output <- .omics$get_reference_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference <- omics_get_reference

#' Monitors the status of a reference import job
#'
#' @description
#' Monitors the status of a reference import job. This operation can be
#' called after calling the
#' [`start_reference_import_job`][omics_start_reference_import_job]
#' operation.
#'
#' @usage
#' omics_get_reference_import_job(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The job's ID.
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sources = list(
#'     list(
#'       sourceFile = "string",
#'       status = "NOT_STARTED"|"IN_PROGRESS"|"FINISHED"|"FAILED",
#'       statusMessage = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       referenceId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_import_job(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_import_job
#'
#' @aliases omics_get_reference_import_job
omics_get_reference_import_job <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "GetReferenceImportJob",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/importjob/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_reference_import_job_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$get_reference_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_import_job <- omics_get_reference_import_job

#' Retrieves metadata for a reference genome
#'
#' @description
#' Retrieves metadata for a reference genome. This operation returns the
#' number of parts, part size, and MD5 of an entire file. This operation
#' does not return tags. To retrieve the list of tags for a read set, use
#' the [`list_tags_for_resource`][omics_list_tags_for_resource] API
#' operation.
#'
#' @usage
#' omics_get_reference_metadata(id, referenceStoreId)
#'
#' @param id &#91;required&#93; The reference's ID.
#' @param referenceStoreId &#91;required&#93; The reference's reference store ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   referenceStoreId = "string",
#'   md5 = "string",
#'   status = "ACTIVE"|"DELETING"|"DELETED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   files = list(
#'     source = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     ),
#'     index = list(
#'       totalParts = 123,
#'       partSize = 123,
#'       contentLength = 123,
#'       s3Access = list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   creationType = "IMPORT",
#'   creationJobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_metadata(
#'   id = "string",
#'   referenceStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_metadata
#'
#' @aliases omics_get_reference_metadata
omics_get_reference_metadata <- function(id, referenceStoreId) {
  op <- new_operation(
    name = "GetReferenceMetadata",
    http_method = "GET",
    http_path = "/referencestore/{referenceStoreId}/reference/{id}/metadata",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_reference_metadata_input(id = id, referenceStoreId = referenceStoreId)
  output <- .omics$get_reference_metadata_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_metadata <- omics_get_reference_metadata

#' Gets information about a reference store
#'
#' @description
#' Gets information about a reference store.
#'
#' @usage
#' omics_get_reference_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_reference_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_reference_store
#'
#' @aliases omics_get_reference_store
omics_get_reference_store <- function(id) {
  op <- new_operation(
    name = "GetReferenceStore",
    http_method = "GET",
    http_path = "/referencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_reference_store_input(id = id)
  output <- .omics$get_reference_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_reference_store <- omics_get_reference_store

#' Gets detailed information about a specific run using its ID
#'
#' @description
#' Gets detailed information about a specific run using its ID.
#' 
#' Amazon Web Services HealthOmics stores a configurable number of runs, as
#' determined by service limits, that are available to the console and API.
#' If [`get_run`][omics_get_run] does not return the requested run, you can
#' find all run logs in the CloudWatch logs. For more information about
#' viewing the run logs, see [CloudWatch
#' logs](https://docs.aws.amazon.com/omics/latest/dev/monitoring-cloudwatch-logs.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_get_run(id, export)
#'
#' @param id &#91;required&#93; The run's ID.
#' @param export The run's export format.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   cacheId = "string",
#'   cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'   engineVersion = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'   workflowId = "string",
#'   workflowType = "PRIVATE"|"READY2RUN",
#'   runId = "string",
#'   roleArn = "string",
#'   name = "string",
#'   runGroupId = "string",
#'   priority = 123,
#'   definition = "string",
#'   digest = "string",
#'   parameters = list(),
#'   storageCapacity = 123,
#'   outputUri = "string",
#'   logLevel = "OFF"|"FATAL"|"ERROR"|"ALL",
#'   resourceDigests = list(
#'     "string"
#'   ),
#'   startedBy = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   stopTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   accelerators = "GPU",
#'   retentionMode = "RETAIN"|"REMOVE",
#'   failureReason = "string",
#'   logLocation = list(
#'     engineLogStream = "string",
#'     runLogStream = "string"
#'   ),
#'   uuid = "string",
#'   runOutputUri = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   workflowOwnerId = "string",
#'   workflowVersionName = "string",
#'   workflowUuid = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run(
#'   id = "string",
#'   export = list(
#'     "DEFINITION"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run
#'
#' @aliases omics_get_run
omics_get_run <- function(id, export = NULL) {
  op <- new_operation(
    name = "GetRun",
    http_method = "GET",
    http_path = "/run/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_run_input(id = id, export = export)
  output <- .omics$get_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run <- omics_get_run

#' Retrieves detailed information about the specified run cache using its
#' ID
#'
#' @description
#' Retrieves detailed information about the specified run cache using its
#' ID.
#' 
#' For more information, see [Call caching for Amazon Web Services
#' HealthOmics
#' runs](https://docs.aws.amazon.com/omics/latest/dev/workflows-call-caching.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_get_run_cache(id)
#'
#' @param id &#91;required&#93; The identifier of the run cache to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'   cacheBucketOwnerId = "string",
#'   cacheS3Uri = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   id = "string",
#'   name = "string",
#'   status = "ACTIVE"|"DELETED"|"FAILED",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run_cache(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run_cache
#'
#' @aliases omics_get_run_cache
omics_get_run_cache <- function(id) {
  op <- new_operation(
    name = "GetRunCache",
    http_method = "GET",
    http_path = "/runCache/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_run_cache_input(id = id)
  output <- .omics$get_run_cache_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run_cache <- omics_get_run_cache

#' Gets information about a run group and returns its metadata
#'
#' @description
#' Gets information about a run group and returns its metadata.
#'
#' @usage
#' omics_get_run_group(id)
#'
#' @param id &#91;required&#93; The group's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   maxGpus = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run_group(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run_group
#'
#' @aliases omics_get_run_group
omics_get_run_group <- function(id) {
  op <- new_operation(
    name = "GetRunGroup",
    http_method = "GET",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_run_group_input(id = id)
  output <- .omics$get_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run_group <- omics_get_run_group

#' Gets detailed information about a run task using its ID
#'
#' @description
#' Gets detailed information about a run task using its ID.
#'
#' @usage
#' omics_get_run_task(id, taskId)
#'
#' @param id &#91;required&#93; The workflow run ID.
#' @param taskId &#91;required&#93; The task's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   taskId = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'   name = "string",
#'   cpus = 123,
#'   cacheHit = TRUE|FALSE,
#'   cacheS3Uri = "string",
#'   memory = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   stopTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   logStream = "string",
#'   gpus = 123,
#'   instanceType = "string",
#'   failureReason = "string",
#'   imageDetails = list(
#'     image = "string",
#'     imageDigest = "string",
#'     sourceImage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_run_task(
#'   id = "string",
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_run_task
#'
#' @aliases omics_get_run_task
omics_get_run_task <- function(id, taskId) {
  op <- new_operation(
    name = "GetRunTask",
    http_method = "GET",
    http_path = "/run/{id}/task/{taskId}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_run_task_input(id = id, taskId = taskId)
  output <- .omics$get_run_task_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_run_task <- omics_get_run_task

#' Retrieves details about an access policy on a given store
#'
#' @description
#' Retrieves details about an access policy on a given store.
#'
#' @usage
#' omics_get_s3_access_policy(s3AccessPointArn)
#'
#' @param s3AccessPointArn &#91;required&#93; The S3 access point ARN that has the access policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   s3AccessPointArn = "string",
#'   storeId = "string",
#'   storeType = "SEQUENCE_STORE"|"REFERENCE_STORE",
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   s3AccessPolicy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_s3_access_policy(
#'   s3AccessPointArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_s3_access_policy
#'
#' @aliases omics_get_s3_access_policy
omics_get_s3_access_policy <- function(s3AccessPointArn) {
  op <- new_operation(
    name = "GetS3AccessPolicy",
    http_method = "GET",
    http_path = "/s3accesspolicy/{s3AccessPointArn}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_s3_access_policy_input(s3AccessPointArn = s3AccessPointArn)
  output <- .omics$get_s3_access_policy_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_s3_access_policy <- omics_get_s3_access_policy

#' Retrieves metadata for a sequence store using its ID and returns it in
#' JSON format
#'
#' @description
#' Retrieves metadata for a sequence store using its ID and returns it in
#' JSON format.
#'
#' @usage
#' omics_get_sequence_store(id)
#'
#' @param id &#91;required&#93; The store's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   fallbackLocation = "string",
#'   s3Access = list(
#'     s3Uri = "string",
#'     s3AccessPointArn = "string",
#'     accessLogLocation = "string"
#'   ),
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"FAILED",
#'   statusMessage = "string",
#'   propagatedSetLevelTags = list(
#'     "string"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_sequence_store(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_sequence_store
#'
#' @aliases omics_get_sequence_store
omics_get_sequence_store <- function(id) {
  op <- new_operation(
    name = "GetSequenceStore",
    http_method = "GET",
    http_path = "/sequencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_sequence_store_input(id = id)
  output <- .omics$get_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_sequence_store <- omics_get_sequence_store

#' Retrieves the metadata for the specified resource share
#'
#' @description
#' Retrieves the metadata for the specified resource share.
#'
#' @usage
#' omics_get_share(shareId)
#'
#' @param shareId &#91;required&#93; The ID of the share.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   share = list(
#'     shareId = "string",
#'     resourceArn = "string",
#'     resourceId = "string",
#'     principalSubscriber = "string",
#'     ownerId = "string",
#'     status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'     statusMessage = "string",
#'     shareName = "string",
#'     creationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updateTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_share(
#'   shareId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_share
#'
#' @aliases omics_get_share
omics_get_share <- function(shareId) {
  op <- new_operation(
    name = "GetShare",
    http_method = "GET",
    http_path = "/share/{shareId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_share_input(shareId = shareId)
  output <- .omics$get_share_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_share <- omics_get_share

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Gets information about a variant import job.
#'
#' @usage
#' omics_get_variant_import_job(jobId)
#'
#' @param jobId &#91;required&#93; The job's ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   destinationName = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'   statusMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completionTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   items = list(
#'     list(
#'       source = "string",
#'       jobStatus = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       statusMessage = "string"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_variant_import_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_variant_import_job
#'
#' @aliases omics_get_variant_import_job
omics_get_variant_import_job <- function(jobId) {
  op <- new_operation(
    name = "GetVariantImportJob",
    http_method = "GET",
    http_path = "/import/variant/{jobId}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_variant_import_job_input(jobId = jobId)
  output <- .omics$get_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_variant_import_job <- omics_get_variant_import_job

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Gets information about a variant store.
#'
#' @usage
#' omics_get_variant_store(name)
#'
#' @param name &#91;required&#93; The store's name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   storeArn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   statusMessage = "string",
#'   storeSizeBytes = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_variant_store(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_variant_store
#'
#' @aliases omics_get_variant_store
omics_get_variant_store <- function(name) {
  op <- new_operation(
    name = "GetVariantStore",
    http_method = "GET",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_variant_store_input(name = name)
  output <- .omics$get_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_variant_store <- omics_get_variant_store

#' Gets all information about a workflow using its ID
#'
#' @description
#' Gets all information about a workflow using its ID.
#' 
#' If a workflow is shared with you, you cannot export the workflow.
#' 
#' For more information about your workflow status, see [Verify the
#' workflow
#' status](https://docs.aws.amazon.com/omics/latest/dev/using-get-workflow.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_get_workflow(id, type, export, workflowOwnerId)
#'
#' @param id &#91;required&#93; The workflow's ID.
#' @param type The workflow's type.
#' @param export The export format for the workflow.
#' @param workflowOwnerId The ID of the workflow owner.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   type = "PRIVATE"|"READY2RUN",
#'   name = "string",
#'   description = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL"|"WDL_LENIENT",
#'   definition = "string",
#'   main = "string",
#'   digest = "string",
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   storageCapacity = 123,
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusMessage = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   metadata = list(
#'     "string"
#'   ),
#'   accelerators = "GPU",
#'   storageType = "STATIC"|"DYNAMIC",
#'   uuid = "string",
#'   containerRegistryMap = list(
#'     registryMappings = list(
#'       list(
#'         upstreamRegistryUrl = "string",
#'         ecrRepositoryPrefix = "string",
#'         upstreamRepositoryPrefix = "string",
#'         ecrAccountId = "string"
#'       )
#'     ),
#'     imageMappings = list(
#'       list(
#'         sourceImage = "string",
#'         destinationImage = "string"
#'       )
#'     )
#'   ),
#'   readme = "string",
#'   definitionRepositoryDetails = list(
#'     connectionArn = "string",
#'     fullRepositoryId = "string",
#'     sourceReference = list(
#'       type = "BRANCH"|"TAG"|"COMMIT",
#'       value = "string"
#'     ),
#'     providerType = "string",
#'     providerEndpoint = "string"
#'   ),
#'   readmePath = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow(
#'   id = "string",
#'   type = "PRIVATE"|"READY2RUN",
#'   export = list(
#'     "DEFINITION"|"README"
#'   ),
#'   workflowOwnerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_workflow
#'
#' @aliases omics_get_workflow
omics_get_workflow <- function(id, type = NULL, export = NULL, workflowOwnerId = NULL) {
  op <- new_operation(
    name = "GetWorkflow",
    http_method = "GET",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_workflow_input(id = id, type = type, export = export, workflowOwnerId = workflowOwnerId)
  output <- .omics$get_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_workflow <- omics_get_workflow

#' Gets information about a workflow version
#'
#' @description
#' Gets information about a workflow version. For more information, see
#' [Workflow versioning in Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_get_workflow_version(workflowId, versionName, type, export,
#'   workflowOwnerId)
#'
#' @param workflowId &#91;required&#93; The workflow's ID. The `workflowId` is not the UUID.
#' @param versionName &#91;required&#93; The workflow version name.
#' @param type The workflow's type.
#' @param export The export format for the workflow.
#' @param workflowOwnerId The 12-digit account ID of the workflow owner. The workflow owner ID can
#' be retrieved using the [`get_share`][omics_get_share] API operation. If
#' you are the workflow owner, you do not need to include this ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   workflowId = "string",
#'   versionName = "string",
#'   accelerators = "GPU",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   definition = "string",
#'   digest = "string",
#'   engine = "WDL"|"NEXTFLOW"|"CWL"|"WDL_LENIENT",
#'   main = "string",
#'   metadata = list(
#'     "string"
#'   ),
#'   parameterTemplate = list(
#'     list(
#'       description = "string",
#'       optional = TRUE|FALSE
#'     )
#'   ),
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'   statusMessage = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   storageCapacity = 123,
#'   type = "PRIVATE"|"READY2RUN",
#'   tags = list(
#'     "string"
#'   ),
#'   uuid = "string",
#'   workflowBucketOwnerId = "string",
#'   containerRegistryMap = list(
#'     registryMappings = list(
#'       list(
#'         upstreamRegistryUrl = "string",
#'         ecrRepositoryPrefix = "string",
#'         upstreamRepositoryPrefix = "string",
#'         ecrAccountId = "string"
#'       )
#'     ),
#'     imageMappings = list(
#'       list(
#'         sourceImage = "string",
#'         destinationImage = "string"
#'       )
#'     )
#'   ),
#'   readme = "string",
#'   definitionRepositoryDetails = list(
#'     connectionArn = "string",
#'     fullRepositoryId = "string",
#'     sourceReference = list(
#'       type = "BRANCH"|"TAG"|"COMMIT",
#'       value = "string"
#'     ),
#'     providerType = "string",
#'     providerEndpoint = "string"
#'   ),
#'   readmePath = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow_version(
#'   workflowId = "string",
#'   versionName = "string",
#'   type = "PRIVATE"|"READY2RUN",
#'   export = list(
#'     "DEFINITION"|"README"
#'   ),
#'   workflowOwnerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_get_workflow_version
#'
#' @aliases omics_get_workflow_version
omics_get_workflow_version <- function(workflowId, versionName, type = NULL, export = NULL, workflowOwnerId = NULL) {
  op <- new_operation(
    name = "GetWorkflowVersion",
    http_method = "GET",
    http_path = "/workflow/{workflowId}/version/{versionName}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$get_workflow_version_input(workflowId = workflowId, versionName = versionName, type = type, export = export, workflowOwnerId = workflowOwnerId)
  output <- .omics$get_workflow_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$get_workflow_version <- omics_get_workflow_version

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Retrieves a list of annotation import jobs.
#'
#' @usage
#' omics_list_annotation_import_jobs(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param ids IDs of annotation import jobs to retrieve.
#' @param nextToken Specifies the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationImportJobs = list(
#'     list(
#'       id = "string",
#'       destinationName = "string",
#'       versionName = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       runLeftNormalization = TRUE|FALSE,
#'       annotationFields = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_import_jobs(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'     storeName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_import_jobs
#'
#' @aliases omics_list_annotation_import_jobs
omics_list_annotation_import_jobs <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationImportJobs",
    http_method = "POST",
    http_path = "/import/annotations",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationImportJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_annotation_import_jobs_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_import_jobs <- omics_list_annotation_import_jobs

#' Lists the versions of an annotation store
#'
#' @description
#' Lists the versions of an annotation store.
#'
#' @usage
#' omics_list_annotation_store_versions(name, maxResults, nextToken,
#'   filter)
#'
#' @param name &#91;required&#93; The name of an annotation store.
#' @param maxResults The maximum number of annotation store versions to return in one page of
#' results.
#' @param nextToken Specifies the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list of annotation store versions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationStoreVersions = list(
#'     list(
#'       storeId = "string",
#'       id = "string",
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       versionArn = "string",
#'       name = "string",
#'       versionName = "string",
#'       description = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       versionSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_store_versions(
#'   name = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_store_versions
#'
#' @aliases omics_list_annotation_store_versions
omics_list_annotation_store_versions <- function(name, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationStoreVersions",
    http_method = "POST",
    http_path = "/annotationStore/{name}/versions",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationStoreVersions"),
    stream_api = FALSE
  )
  input <- .omics$list_annotation_store_versions_input(name = name, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_store_versions_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_store_versions <- omics_list_annotation_store_versions

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Retrieves a list of annotation stores.
#'
#' @usage
#' omics_list_annotation_stores(ids, maxResults, nextToken, filter)
#'
#' @param ids IDs of stores to list.
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   annotationStores = list(
#'     list(
#'       id = "string",
#'       reference = list(
#'         referenceArn = "string"
#'       ),
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       storeArn = "string",
#'       name = "string",
#'       storeFormat = "GFF"|"TSV"|"VCF",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       storeSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_annotation_stores(
#'   ids = list(
#'     "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_annotation_stores
#'
#' @aliases omics_list_annotation_stores
omics_list_annotation_stores <- function(ids = NULL, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListAnnotationStores",
    http_method = "POST",
    http_path = "/annotationStores",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "annotationStores"),
    stream_api = FALSE
  )
  input <- .omics$list_annotation_stores_input(ids = ids, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_annotation_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_annotation_stores <- omics_list_annotation_stores

#' Lists in-progress multipart read set uploads for a sequence store and
#' returns it in a JSON formatted output
#'
#' @description
#' Lists in-progress multipart read set uploads for a sequence store and
#' returns it in a JSON formatted output. Multipart read set uploads are
#' initiated by the `CreateMultipartReadSetUploads` API operation. This
#' operation returns a response with no body when the upload is complete.
#'
#' @usage
#' omics_list_multipart_read_set_uploads(sequenceStoreId, maxResults,
#'   nextToken)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart uploads.
#' @param maxResults The maximum number of multipart uploads returned in a page.
#' @param nextToken Next token returned in the response of a previous
#' ListMultipartReadSetUploads call. Used to get the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   uploads = list(
#'     list(
#'       sequenceStoreId = "string",
#'       uploadId = "string",
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_multipart_read_set_uploads(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_multipart_read_set_uploads
#'
#' @aliases omics_list_multipart_read_set_uploads
omics_list_multipart_read_set_uploads <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListMultipartReadSetUploads",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/uploads",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "uploads"),
    stream_api = FALSE
  )
  input <- .omics$list_multipart_read_set_uploads_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken)
  output <- .omics$list_multipart_read_set_uploads_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_multipart_read_set_uploads <- omics_list_multipart_read_set_uploads

#' Retrieves a list of read set activation jobs and returns the metadata in
#' a JSON formatted output
#'
#' @description
#' Retrieves a list of read set activation jobs and returns the metadata in
#' a JSON formatted output. To extract metadata from a read set activation
#' job, use the
#' [`get_read_set_activation_job`][omics_get_read_set_activation_job] API
#' operation.
#'
#' @usage
#' omics_list_read_set_activation_jobs(sequenceStoreId, maxResults,
#'   nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param maxResults The maximum number of read set activation jobs to return in one page of
#' results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   activationJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_activation_jobs(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_activation_jobs
#'
#' @aliases omics_list_read_set_activation_jobs
omics_list_read_set_activation_jobs <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetActivationJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/activationjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "activationJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_read_set_activation_jobs_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_activation_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_activation_jobs <- omics_list_read_set_activation_jobs

#' Retrieves a list of read set export jobs in a JSON formatted response
#'
#' @description
#' Retrieves a list of read set export jobs in a JSON formatted response.
#' This API operation is used to check the status of a read set export job
#' initiated by the
#' [`start_read_set_export_job`][omics_start_read_set_export_job] API
#' operation.
#'
#' @usage
#' omics_list_read_set_export_jobs(sequenceStoreId, maxResults, nextToken,
#'   filter)
#'
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   exportJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       destination = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_export_jobs(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_export_jobs
#'
#' @aliases omics_list_read_set_export_jobs
omics_list_read_set_export_jobs <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetExportJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/exportjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "exportJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_read_set_export_jobs_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_export_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_export_jobs <- omics_list_read_set_export_jobs

#' Retrieves a list of read set import jobs and returns the data in JSON
#' format
#'
#' @description
#' Retrieves a list of read set import jobs and returns the data in JSON
#' format.
#'
#' @usage
#' omics_list_read_set_import_jobs(maxResults, nextToken, sequenceStoreId,
#'   filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   importJobs = list(
#'     list(
#'       id = "string",
#'       sequenceStoreId = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_import_jobs(
#'   maxResults = 123,
#'   nextToken = "string",
#'   sequenceStoreId = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_import_jobs
#'
#' @aliases omics_list_read_set_import_jobs
omics_list_read_set_import_jobs <- function(maxResults = NULL, nextToken = NULL, sequenceStoreId, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetImportJobs",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/importjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "importJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_read_set_import_jobs_input(maxResults = maxResults, nextToken = nextToken, sequenceStoreId = sequenceStoreId, filter = filter)
  output <- .omics$list_read_set_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_import_jobs <- omics_list_read_set_import_jobs

#' Lists all parts in a multipart read set upload for a sequence store and
#' returns the metadata in a JSON formatted output
#'
#' @description
#' Lists all parts in a multipart read set upload for a sequence store and
#' returns the metadata in a JSON formatted output.
#'
#' @usage
#' omics_list_read_set_upload_parts(sequenceStoreId, uploadId, partSource,
#'   maxResults, nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart uploads.
#' @param uploadId &#91;required&#93; The ID for the initiated multipart upload.
#' @param partSource &#91;required&#93; The source file for the upload part.
#' @param maxResults The maximum number of read set upload parts returned in a page.
#' @param nextToken Next token returned in the response of a previous
#' ListReadSetUploadPartsRequest call. Used to get the next page of
#' results.
#' @param filter Attributes used to filter for a specific subset of read set part
#' uploads.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   parts = list(
#'     list(
#'       partNumber = 123,
#'       partSize = 123,
#'       partSource = "SOURCE1"|"SOURCE2",
#'       checksum = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_set_upload_parts(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   partSource = "SOURCE1"|"SOURCE2",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_set_upload_parts
#'
#' @aliases omics_list_read_set_upload_parts
omics_list_read_set_upload_parts <- function(sequenceStoreId, uploadId, partSource, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSetUploadParts",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/parts",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "parts"),
    stream_api = FALSE
  )
  input <- .omics$list_read_set_upload_parts_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, partSource = partSource, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_set_upload_parts_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_set_upload_parts <- omics_list_read_set_upload_parts

#' Retrieves a list of read sets from a sequence store ID and returns the
#' metadata in JSON format
#'
#' @description
#' Retrieves a list of read sets from a sequence store ID and returns the
#' metadata in JSON format.
#'
#' @usage
#' omics_list_read_sets(sequenceStoreId, maxResults, nextToken, filter)
#'
#' @param sequenceStoreId &#91;required&#93; The jobs' sequence store ID.
#' @param maxResults The maximum number of read sets to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   readSets = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       sequenceStoreId = "string",
#'       subjectId = "string",
#'       sampleId = "string",
#'       status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'       name = "string",
#'       description = "string",
#'       referenceArn = "string",
#'       fileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       sequenceInformation = list(
#'         totalReadCount = 123,
#'         totalBaseCount = 123,
#'         generatedFrom = "string",
#'         alignment = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       creationType = "IMPORT"|"UPLOAD",
#'       etag = list(
#'         algorithm = "FASTQ_MD5up"|"BAM_MD5up"|"CRAM_MD5up"|"FASTQ_SHA256up"|"BAM_SHA256up"|"CRAM_SHA256up"|"FASTQ_SHA512up"|"BAM_SHA512up"|"CRAM_SHA512up",
#'         source1 = "string",
#'         source2 = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_read_sets(
#'   sequenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     status = "ARCHIVED"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"PROCESSING_UPLOAD"|"UPLOAD_FAILED",
#'     referenceArn = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     sampleId = "string",
#'     subjectId = "string",
#'     generatedFrom = "string",
#'     creationType = "IMPORT"|"UPLOAD"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_read_sets
#'
#' @aliases omics_list_read_sets
omics_list_read_sets <- function(sequenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReadSets",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/readsets",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "readSets"),
    stream_api = FALSE
  )
  input <- .omics$list_read_sets_input(sequenceStoreId = sequenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_read_sets_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_read_sets <- omics_list_read_sets

#' Retrieves the metadata of one or more reference import jobs for a
#' reference store
#'
#' @description
#' Retrieves the metadata of one or more reference import jobs for a
#' reference store.
#'
#' @usage
#' omics_list_reference_import_jobs(maxResults, nextToken,
#'   referenceStoreId, filter)
#'
#' @param maxResults The maximum number of jobs to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   importJobs = list(
#'     list(
#'       id = "string",
#'       referenceStoreId = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_reference_import_jobs(
#'   maxResults = 123,
#'   nextToken = "string",
#'   referenceStoreId = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_reference_import_jobs
#'
#' @aliases omics_list_reference_import_jobs
omics_list_reference_import_jobs <- function(maxResults = NULL, nextToken = NULL, referenceStoreId, filter = NULL) {
  op <- new_operation(
    name = "ListReferenceImportJobs",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/importjobs",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "importJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_reference_import_jobs_input(maxResults = maxResults, nextToken = nextToken, referenceStoreId = referenceStoreId, filter = filter)
  output <- .omics$list_reference_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_reference_import_jobs <- omics_list_reference_import_jobs

#' Retrieves a list of reference stores linked to your account and returns
#' their metadata in JSON format
#'
#' @description
#' Retrieves a list of reference stores linked to your account and returns
#' their metadata in JSON format.
#' 
#' For more information, see [Creating a reference
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-reference-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_list_reference_stores(maxResults, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   referenceStores = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_reference_stores(
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_reference_stores
#'
#' @aliases omics_list_reference_stores
omics_list_reference_stores <- function(maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReferenceStores",
    http_method = "POST",
    http_path = "/referencestores",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "referenceStores"),
    stream_api = FALSE
  )
  input <- .omics$list_reference_stores_input(maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_reference_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_reference_stores <- omics_list_reference_stores

#' Retrieves the metadata of one or more reference genomes in a reference
#' store
#'
#' @description
#' Retrieves the metadata of one or more reference genomes in a reference
#' store.
#' 
#' For more information, see [Creating a reference
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-reference-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_list_references(referenceStoreId, maxResults, nextToken, filter)
#'
#' @param referenceStoreId &#91;required&#93; The references' reference store ID.
#' @param maxResults The maximum number of references to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   references = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       referenceStoreId = "string",
#'       md5 = "string",
#'       status = "ACTIVE"|"DELETING"|"DELETED",
#'       name = "string",
#'       description = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_references(
#'   referenceStoreId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     md5 = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_references
#'
#' @aliases omics_list_references
omics_list_references <- function(referenceStoreId, maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListReferences",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/references",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "references"),
    stream_api = FALSE
  )
  input <- .omics$list_references_input(referenceStoreId = referenceStoreId, maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_references_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_references <- omics_list_references

#' Retrieves a list of your run caches and the metadata for each cache
#'
#' @description
#' Retrieves a list of your run caches and the metadata for each cache.
#'
#' @usage
#' omics_list_run_caches(maxResults, startingToken)
#'
#' @param maxResults The maximum number of results to return.
#' @param startingToken Optional pagination token returned from a prior call to the
#' [`list_run_caches`][omics_list_run_caches] API operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'       cacheS3Uri = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       id = "string",
#'       name = "string",
#'       status = "ACTIVE"|"DELETED"|"FAILED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_run_caches(
#'   maxResults = 123,
#'   startingToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_run_caches
#'
#' @aliases omics_list_run_caches
omics_list_run_caches <- function(maxResults = NULL, startingToken = NULL) {
  op <- new_operation(
    name = "ListRunCaches",
    http_method = "GET",
    http_path = "/runCache",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_run_caches_input(maxResults = maxResults, startingToken = startingToken)
  output <- .omics$list_run_caches_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_run_caches <- omics_list_run_caches

#' Retrieves a list of all run groups and returns the metadata for each run
#' group
#'
#' @description
#' Retrieves a list of all run groups and returns the metadata for each run
#' group.
#'
#' @usage
#' omics_list_run_groups(name, startingToken, maxResults)
#'
#' @param name The run groups' name.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of run groups to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       maxCpus = 123,
#'       maxRuns = 123,
#'       maxDuration = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       maxGpus = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_run_groups(
#'   name = "string",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_run_groups
#'
#' @aliases omics_list_run_groups
omics_list_run_groups <- function(name = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListRunGroups",
    http_method = "GET",
    http_path = "/runGroup",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_run_groups_input(name = name, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_run_groups_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_run_groups <- omics_list_run_groups

#' Returns a list of tasks and status information within their specified
#' run
#'
#' @description
#' Returns a list of tasks and status information within their specified
#' run. Use this operation to monitor runs and to identify which specific
#' tasks have failed.
#'
#' @usage
#' omics_list_run_tasks(id, status, startingToken, maxResults)
#'
#' @param id &#91;required&#93; The run's ID.
#' @param status Filter the list by status.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of run tasks to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       taskId = "string",
#'       status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'       name = "string",
#'       cpus = 123,
#'       cacheHit = TRUE|FALSE,
#'       cacheS3Uri = "string",
#'       memory = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stopTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       gpus = 123,
#'       instanceType = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_run_tasks(
#'   id = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"CANCELLED"|"FAILED",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_run_tasks
#'
#' @aliases omics_list_run_tasks
omics_list_run_tasks <- function(id, status = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListRunTasks",
    http_method = "GET",
    http_path = "/run/{id}/task",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_run_tasks_input(id = id, status = status, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_run_tasks_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_run_tasks <- omics_list_run_tasks

#' Retrieves a list of runs and returns each run's metadata and status
#'
#' @description
#' Retrieves a list of runs and returns each run's metadata and status.
#' 
#' Amazon Web Services HealthOmics stores a configurable number of runs, as
#' determined by service limits, that are available to the console and API.
#' If the [`list_runs`][omics_list_runs] response doesn't include specific
#' runs that you expected, you can find all run logs in the CloudWatch
#' logs. For more information about viewing the run logs, see [CloudWatch
#' logs](https://docs.aws.amazon.com/omics/latest/dev/monitoring-cloudwatch-logs.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_list_runs(name, runGroupId, startingToken, maxResults, status)
#'
#' @param name Filter the list by run name.
#' @param runGroupId Filter the list by run group ID.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of runs to return in one page of results.
#' @param status The status of a run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'       workflowId = "string",
#'       name = "string",
#'       priority = 123,
#'       storageCapacity = 123,
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stopTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       storageType = "STATIC"|"DYNAMIC",
#'       workflowVersionName = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_runs(
#'   name = "string",
#'   runGroupId = "string",
#'   startingToken = "string",
#'   maxResults = 123,
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_runs
#'
#' @aliases omics_list_runs
omics_list_runs <- function(name = NULL, runGroupId = NULL, startingToken = NULL, maxResults = NULL, status = NULL) {
  op <- new_operation(
    name = "ListRuns",
    http_method = "GET",
    http_path = "/run",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_runs_input(name = name, runGroupId = runGroupId, startingToken = startingToken, maxResults = maxResults, status = status)
  output <- .omics$list_runs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_runs <- omics_list_runs

#' Retrieves a list of sequence stores and returns each sequence store's
#' metadata
#'
#' @description
#' Retrieves a list of sequence stores and returns each sequence store's
#' metadata.
#' 
#' For more information, see [Creating a HealthOmics sequence
#' store](https://docs.aws.amazon.com/omics/latest/dev/create-sequence-store.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_list_sequence_stores(maxResults, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   sequenceStores = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       fallbackLocation = "string",
#'       eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up",
#'       status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"FAILED",
#'       statusMessage = "string",
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_sequence_stores(
#'   maxResults = 123,
#'   nextToken = "string",
#'   filter = list(
#'     name = "string",
#'     createdAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"FAILED",
#'     updatedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_sequence_stores
#'
#' @aliases omics_list_sequence_stores
omics_list_sequence_stores <- function(maxResults = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListSequenceStores",
    http_method = "POST",
    http_path = "/sequencestores",
    host_prefix = "control-storage-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "sequenceStores"),
    stream_api = FALSE
  )
  input <- .omics$list_sequence_stores_input(maxResults = maxResults, nextToken = nextToken, filter = filter)
  output <- .omics$list_sequence_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_sequence_stores <- omics_list_sequence_stores

#' Retrieves the resource shares associated with an account
#'
#' @description
#' Retrieves the resource shares associated with an account. Use the filter
#' parameter to retrieve a specific subset of the shares.
#'
#' @usage
#' omics_list_shares(resourceOwner, filter, nextToken, maxResults)
#'
#' @param resourceOwner &#91;required&#93; The account that owns the resource shares.
#' @param filter Attributes that you use to filter for a specific subset of resource
#' shares.
#' @param nextToken Next token returned in the response of a previous
#' ListReadSetUploadPartsRequest call. Used to get the next page of
#' results.
#' @param maxResults The maximum number of shares to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   shares = list(
#'     list(
#'       shareId = "string",
#'       resourceArn = "string",
#'       resourceId = "string",
#'       principalSubscriber = "string",
#'       ownerId = "string",
#'       status = "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED",
#'       statusMessage = "string",
#'       shareName = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_shares(
#'   resourceOwner = "SELF"|"OTHER",
#'   filter = list(
#'     resourceArns = list(
#'       "string"
#'     ),
#'     status = list(
#'       "PENDING"|"ACTIVATING"|"ACTIVE"|"DELETING"|"DELETED"|"FAILED"
#'     ),
#'     type = list(
#'       "VARIANT_STORE"|"ANNOTATION_STORE"|"WORKFLOW"
#'     )
#'   ),
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_shares
#'
#' @aliases omics_list_shares
omics_list_shares <- function(resourceOwner, filter = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListShares",
    http_method = "POST",
    http_path = "/shares",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "shares"),
    stream_api = FALSE
  )
  input <- .omics$list_shares_input(resourceOwner = resourceOwner, filter = filter, nextToken = nextToken, maxResults = maxResults)
  output <- .omics$list_shares_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_shares <- omics_list_shares

#' Retrieves a list of tags for a resource
#'
#' @description
#' Retrieves a list of tags for a resource.
#'
#' @usage
#' omics_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_tags_for_resource
#'
#' @aliases omics_list_tags_for_resource
omics_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .omics$list_tags_for_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_tags_for_resource <- omics_list_tags_for_resource

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Retrieves a list of variant import jobs.
#'
#' @usage
#' omics_list_variant_import_jobs(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of import jobs to return in one page of results.
#' @param ids A list of job IDs.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   variantImportJobs = list(
#'     list(
#'       id = "string",
#'       destinationName = "string",
#'       roleArn = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       runLeftNormalization = TRUE|FALSE,
#'       annotationFields = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_variant_import_jobs(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLED"|"COMPLETED"|"FAILED"|"COMPLETED_WITH_FAILURES",
#'     storeName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_variant_import_jobs
#'
#' @aliases omics_list_variant_import_jobs
omics_list_variant_import_jobs <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListVariantImportJobs",
    http_method = "POST",
    http_path = "/import/variants",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "variantImportJobs"),
    stream_api = FALSE
  )
  input <- .omics$list_variant_import_jobs_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_variant_import_jobs_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_variant_import_jobs <- omics_list_variant_import_jobs

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Retrieves a list of variant stores.
#'
#' @usage
#' omics_list_variant_stores(maxResults, ids, nextToken, filter)
#'
#' @param maxResults The maximum number of stores to return in one page of results.
#' @param ids A list of store IDs.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param filter A filter to apply to the list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   variantStores = list(
#'     list(
#'       id = "string",
#'       reference = list(
#'         referenceArn = "string"
#'       ),
#'       status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'       storeArn = "string",
#'       name = "string",
#'       description = "string",
#'       sseConfig = list(
#'         type = "KMS",
#'         keyArn = "string"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       statusMessage = "string",
#'       storeSizeBytes = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_variant_stores(
#'   maxResults = 123,
#'   ids = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   filter = list(
#'     status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_variant_stores
#'
#' @aliases omics_list_variant_stores
omics_list_variant_stores <- function(maxResults = NULL, ids = NULL, nextToken = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListVariantStores",
    http_method = "POST",
    http_path = "/variantStores",
    host_prefix = "analytics-",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "variantStores"),
    stream_api = FALSE
  )
  input <- .omics$list_variant_stores_input(maxResults = maxResults, ids = ids, nextToken = nextToken, filter = filter)
  output <- .omics$list_variant_stores_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_variant_stores <- omics_list_variant_stores

#' Lists the workflow versions for the specified workflow
#'
#' @description
#' Lists the workflow versions for the specified workflow. For more
#' information, see [Workflow versioning in Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_list_workflow_versions(workflowId, type, workflowOwnerId,
#'   startingToken, maxResults)
#'
#' @param workflowId &#91;required&#93; The workflow's ID. The `workflowId` is not the UUID.
#' @param type The workflow type.
#' @param workflowOwnerId The 12-digit account ID of the workflow owner. The workflow owner ID can
#' be retrieved using the [`get_share`][omics_get_share] API operation. If
#' you are the workflow owner, you do not need to include this ID.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of workflows to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       workflowId = "string",
#'       versionName = "string",
#'       description = "string",
#'       status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'       type = "PRIVATE"|"READY2RUN",
#'       digest = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       metadata = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_workflow_versions(
#'   workflowId = "string",
#'   type = "PRIVATE"|"READY2RUN",
#'   workflowOwnerId = "string",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_workflow_versions
#'
#' @aliases omics_list_workflow_versions
omics_list_workflow_versions <- function(workflowId, type = NULL, workflowOwnerId = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListWorkflowVersions",
    http_method = "GET",
    http_path = "/workflow/{workflowId}/version",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_workflow_versions_input(workflowId = workflowId, type = type, workflowOwnerId = workflowOwnerId, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_workflow_versions_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_workflow_versions <- omics_list_workflow_versions

#' Retrieves a list of existing workflows
#'
#' @description
#' Retrieves a list of existing workflows. You can filter for specific
#' workflows by their name and type. Using the type parameter, specify
#' `PRIVATE` to retrieve a list of private workflows or specify `READY2RUN`
#' for a list of all Ready2Run workflows. If you do not specify the type of
#' workflow, this operation returns a list of existing workflows.
#'
#' @usage
#' omics_list_workflows(type, name, startingToken, maxResults)
#'
#' @param type Filter the list by workflow type.
#' @param name Filter the list by workflow name.
#' @param startingToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param maxResults The maximum number of workflows to return in one page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       id = "string",
#'       name = "string",
#'       status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETED"|"FAILED"|"INACTIVE",
#'       type = "PRIVATE"|"READY2RUN",
#'       digest = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       metadata = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_workflows(
#'   type = "PRIVATE"|"READY2RUN",
#'   name = "string",
#'   startingToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_list_workflows
#'
#' @aliases omics_list_workflows
omics_list_workflows <- function(type = NULL, name = NULL, startingToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListWorkflows",
    http_method = "GET",
    http_path = "/workflow",
    host_prefix = "workflows-",
    paginator = list(input_token = "startingToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .omics$list_workflows_input(type = type, name = name, startingToken = startingToken, maxResults = maxResults)
  output <- .omics$list_workflows_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$list_workflows <- omics_list_workflows

#' Adds an access policy to the specified store
#'
#' @description
#' Adds an access policy to the specified store.
#'
#' @usage
#' omics_put_s3_access_policy(s3AccessPointArn, s3AccessPolicy)
#'
#' @param s3AccessPointArn &#91;required&#93; The S3 access point ARN where you want to put the access policy.
#' @param s3AccessPolicy &#91;required&#93; The resource policy that controls S3 access to the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   s3AccessPointArn = "string",
#'   storeId = "string",
#'   storeType = "SEQUENCE_STORE"|"REFERENCE_STORE"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_s3_access_policy(
#'   s3AccessPointArn = "string",
#'   s3AccessPolicy = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_put_s3_access_policy
#'
#' @aliases omics_put_s3_access_policy
omics_put_s3_access_policy <- function(s3AccessPointArn, s3AccessPolicy) {
  op <- new_operation(
    name = "PutS3AccessPolicy",
    http_method = "PUT",
    http_path = "/s3accesspolicy/{s3AccessPointArn}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$put_s3_access_policy_input(s3AccessPointArn = s3AccessPointArn, s3AccessPolicy = s3AccessPolicy)
  output <- .omics$put_s3_access_policy_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$put_s3_access_policy <- omics_put_s3_access_policy

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Starts an annotation import job.
#'
#' @usage
#' omics_start_annotation_import_job(destinationName, roleArn, items,
#'   versionName, formatOptions, runLeftNormalization, annotationFields)
#'
#' @param destinationName &#91;required&#93; A destination annotation store for the job.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param items &#91;required&#93; Items to import.
#' @param versionName The name of the annotation store version.
#' @param formatOptions Formatting options for the annotation file.
#' @param runLeftNormalization The job's left normalization setting.
#' @param annotationFields The annotation schema generated by the parsed annotation data.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_annotation_import_job(
#'   destinationName = "string",
#'   roleArn = "string",
#'   items = list(
#'     list(
#'       source = "string"
#'     )
#'   ),
#'   versionName = "string",
#'   formatOptions = list(
#'     tsvOptions = list(
#'       readOptions = list(
#'         sep = "string",
#'         encoding = "string",
#'         quote = "string",
#'         quoteAll = TRUE|FALSE,
#'         escape = "string",
#'         escapeQuotes = TRUE|FALSE,
#'         comment = "string",
#'         header = TRUE|FALSE,
#'         lineSep = "string"
#'       )
#'     ),
#'     vcfOptions = list(
#'       ignoreQualField = TRUE|FALSE,
#'       ignoreFilterField = TRUE|FALSE
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_annotation_import_job
#'
#' @aliases omics_start_annotation_import_job
omics_start_annotation_import_job <- function(destinationName, roleArn, items, versionName = NULL, formatOptions = NULL, runLeftNormalization = NULL, annotationFields = NULL) {
  op <- new_operation(
    name = "StartAnnotationImportJob",
    http_method = "POST",
    http_path = "/import/annotation",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_annotation_import_job_input(destinationName = destinationName, roleArn = roleArn, items = items, versionName = versionName, formatOptions = formatOptions, runLeftNormalization = runLeftNormalization, annotationFields = annotationFields)
  output <- .omics$start_annotation_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_annotation_import_job <- omics_start_annotation_import_job

#' Activates an archived read set and returns its metadata in a JSON
#' formatted output
#'
#' @description
#' Activates an archived read set and returns its metadata in a JSON
#' formatted output. AWS HealthOmics automatically archives unused read
#' sets after 30 days. To monitor the status of your read set activation
#' job, use the
#' [`get_read_set_activation_job`][omics_get_read_set_activation_job]
#' operation.
#' 
#' To learn more, see [Activating read
#' sets](https://docs.aws.amazon.com/omics/latest/dev/activating-read-sets.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_start_read_set_activation_job(sequenceStoreId, clientToken,
#'   sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_activation_job(
#'   sequenceStoreId = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_activation_job
#'
#' @aliases omics_start_read_set_activation_job
omics_start_read_set_activation_job <- function(sequenceStoreId, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetActivationJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/activationjob",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_read_set_activation_job_input(sequenceStoreId = sequenceStoreId, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_activation_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_activation_job <- omics_start_read_set_activation_job

#' Starts a read set export job
#'
#' @description
#' Starts a read set export job. When the export job is finished, the read
#' set is exported to an Amazon S3 bucket which can be retrieved using the
#' [`get_read_set_export_job`][omics_get_read_set_export_job] API
#' operation.
#' 
#' To monitor the status of the export job, use the
#' [`list_read_set_export_jobs`][omics_list_read_set_export_jobs] API
#' operation.
#'
#' @usage
#' omics_start_read_set_export_job(sequenceStoreId, destination, roleArn,
#'   clientToken, sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param destination &#91;required&#93; A location for exported files in Amazon S3.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_export_job(
#'   sequenceStoreId = "string",
#'   destination = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       readSetId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_export_job
#'
#' @aliases omics_start_read_set_export_job
omics_start_read_set_export_job <- function(sequenceStoreId, destination, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetExportJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/exportjob",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_read_set_export_job_input(sequenceStoreId = sequenceStoreId, destination = destination, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_export_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_export_job <- omics_start_read_set_export_job

#' Imports a read set from the sequence store
#'
#' @description
#' Imports a read set from the sequence store. Read set import jobs support
#' a maximum of 100 read sets of different types. Monitor the progress of
#' your read set import job by calling the
#' [`get_read_set_import_job`][omics_get_read_set_import_job] API
#' operation.
#'
#' @usage
#' omics_start_read_set_import_job(sequenceStoreId, roleArn, clientToken,
#'   sources)
#'
#' @param sequenceStoreId &#91;required&#93; The read set's sequence store ID.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_read_set_import_job(
#'   sequenceStoreId = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       sourceFiles = list(
#'         source1 = "string",
#'         source2 = "string"
#'       ),
#'       sourceFileType = "FASTQ"|"BAM"|"CRAM"|"UBAM",
#'       subjectId = "string",
#'       sampleId = "string",
#'       generatedFrom = "string",
#'       referenceArn = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_read_set_import_job
#'
#' @aliases omics_start_read_set_import_job
omics_start_read_set_import_job <- function(sequenceStoreId, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReadSetImportJob",
    http_method = "POST",
    http_path = "/sequencestore/{sequenceStoreId}/importjob",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_read_set_import_job_input(sequenceStoreId = sequenceStoreId, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_read_set_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_read_set_import_job <- omics_start_read_set_import_job

#' Imports a reference genome from Amazon S3 into a specified reference
#' store
#'
#' @description
#' Imports a reference genome from Amazon S3 into a specified reference
#' store. You can have multiple reference genomes in a reference store. You
#' can only import reference genomes one at a time into each reference
#' store. Monitor the status of your reference import job by using the
#' [`get_reference_import_job`][omics_get_reference_import_job] API
#' operation.
#'
#' @usage
#' omics_start_reference_import_job(referenceStoreId, roleArn, clientToken,
#'   sources)
#'
#' @param referenceStoreId &#91;required&#93; The job's reference store ID.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param clientToken To ensure that jobs don't run multiple times, specify a unique token for
#' each job.
#' @param sources &#91;required&#93; The job's source files.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELLING"|"CANCELLED"|"FAILED"|"COMPLETED"|"COMPLETED_WITH_FAILURES",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_reference_import_job(
#'   referenceStoreId = "string",
#'   roleArn = "string",
#'   clientToken = "string",
#'   sources = list(
#'     list(
#'       sourceFile = "string",
#'       name = "string",
#'       description = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_reference_import_job
#'
#' @aliases omics_start_reference_import_job
omics_start_reference_import_job <- function(referenceStoreId, roleArn, clientToken = NULL, sources) {
  op <- new_operation(
    name = "StartReferenceImportJob",
    http_method = "POST",
    http_path = "/referencestore/{referenceStoreId}/importjob",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_reference_import_job_input(referenceStoreId = referenceStoreId, roleArn = roleArn, clientToken = clientToken, sources = sources)
  output <- .omics$start_reference_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_reference_import_job <- omics_start_reference_import_job

#' Starts a new run and returns details about the run, or duplicates an
#' existing run
#'
#' @description
#' Starts a new run and returns details about the run, or duplicates an
#' existing run. A run is a single invocation of a workflow. If you provide
#' request IDs, Amazon Web Services HealthOmics identifies duplicate
#' requests and starts the run only once. Monitor the progress of the run
#' by calling the [`get_run`][omics_get_run] API operation.
#' 
#' To start a new run, the following inputs are required:
#' 
#' -   A service role ARN (`roleArn`).
#' 
#' -   The run's workflow ID (`workflowId`, not the `uuid` or `runId`).
#' 
#' -   An Amazon S3 location (`outputUri`) where the run outputs will be
#'     saved.
#' 
#' -   All required workflow parameters (`parameter`), which can include
#'     optional parameters from the parameter template. The run cannot
#'     include any parameters that are not defined in the parameter
#'     template. To see all possible parameters, use the
#'     [`get_run`][omics_get_run] API operation.
#' 
#' -   For runs with a `STATIC` (default) storage type, specify the
#'     required storage capacity (in gibibytes). A storage capacity value
#'     is not required for runs that use `DYNAMIC` storage.
#' 
#' [`start_run`][omics_start_run] can also duplicate an existing run using
#' the run's default values. You can modify these default values and/or add
#' other optional inputs. To duplicate a run, the following inputs are
#' required:
#' 
#' -   A service role ARN (`roleArn`).
#' 
#' -   The ID of the run to duplicate (`runId`).
#' 
#' -   An Amazon S3 location where the run outputs will be saved
#'     (`outputUri`).
#' 
#' To learn more about the optional parameters for
#' [`start_run`][omics_start_run], see [Starting a
#' run](https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' 
#' Use the `retentionMode` input to control how long the metadata for each
#' run is stored in CloudWatch. There are two retention modes:
#' 
#' -   Specify `REMOVE` to automatically remove the oldest runs when you
#'     reach the maximum service retention limit for runs. It is
#'     recommended that you use the `REMOVE` mode to initiate major run
#'     requests so that your runs do not fail when you reach the limit.
#' 
#' -   The `retentionMode` is set to the `RETAIN` mode by default, which
#'     allows you to manually remove runs after reaching the maximum
#'     service retention limit. Under this setting, you cannot create
#'     additional runs until you remove the excess runs.
#' 
#' To learn more about the retention modes, see [Run retention
#' mode](https://docs.aws.amazon.com/omics/latest/dev/run-retention.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' 
#' You can use Amazon Q CLI to analyze run logs and make performance
#' optimization recommendations. To get started, see the [Amazon Web
#' Services HealthOmics MCP
#' server](https://github.com/awslabs/mcp/tree/main/src/aws-healthomics-mcp-server)
#' on GitHub.
#'
#' @usage
#' omics_start_run(workflowId, workflowType, runId, roleArn, name, cacheId,
#'   cacheBehavior, runGroupId, priority, parameters, storageCapacity,
#'   outputUri, logLevel, tags, requestId, retentionMode, storageType,
#'   workflowOwnerId, workflowVersionName)
#'
#' @param workflowId The run's workflow ID. The `workflowId` is not the UUID.
#' @param workflowType The run's workflow type. The `workflowType` must be specified if you are
#' running a `READY2RUN` workflow. If you are running a `PRIVATE` workflow
#' (default), you do not need to include the workflow type.
#' @param runId The ID of a run to duplicate.
#' @param roleArn &#91;required&#93; A service role for the run. The `roleArn` requires access to Amazon Web
#' Services HealthOmics, S3, Cloudwatch logs, and EC2. An example `roleArn`
#' is
#' `arn:aws:iam::123456789012:role/omics-service-role-serviceRole-W8O1XMPL7QZ`.
#' In this example, the AWS account ID is `123456789012` and the role name
#' is `omics-service-role-serviceRole-W8O1XMPL7QZ`.
#' @param name A name for the run. This is recommended to view and organize runs in the
#' Amazon Web Services HealthOmics console and CloudWatch logs.
#' @param cacheId Identifier of the cache associated with this run. If you don't specify a
#' cache ID, no task outputs are cached for this run.
#' @param cacheBehavior The cache behavior for the run. You specify this value if you want to
#' override the default behavior for the cache. You had set the default
#' value when you created the cache. For more information, see [Run cache
#' behavior](https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html#run-cache-behavior)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param runGroupId The run's group ID. Use a run group to cap the compute resources (and
#' number of concurrent runs) for the runs that you add to the run group.
#' @param priority Use the run priority (highest: 1) to establish the order of runs in a
#' run group when you start a run. If multiple runs share the same
#' priority, the run that was initiated first will have the higher
#' priority. Runs that do not belong to a run group can be assigned a
#' priority. The priorities of these runs are ranked among other runs that
#' are not in a run group. For more information, see [Run
#' priority](https://docs.aws.amazon.com/omics/latest/dev/creating-run-groups.html#run-priority)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param parameters Parameters for the run. The run needs all required parameters and can
#' include optional parameters. The run cannot include any parameters that
#' are not defined in the parameter template. To retrieve parameters from
#' the run, use the GetRun API operation.
#' @param storageCapacity The `STATIC` storage capacity (in gibibytes, GiB) for this run. The
#' default run storage capacity is 1200 GiB. If your requested storage
#' capacity is unavailable, the system rounds up the value to the nearest
#' 1200 GiB multiple. If the requested storage capacity is still
#' unavailable, the system rounds up the value to the nearest 2400 GiB
#' multiple. This field is not required if the storage type is `DYNAMIC`
#' (the system ignores any value that you enter).
#' @param outputUri &#91;required&#93; An output S3 URI for the run. The S3 bucket must be in the same region
#' as the workflow. The role ARN must have permission to write to this S3
#' bucket.
#' @param logLevel A log level for the run.
#' @param tags Tags for the run. You can add up to 50 tags per run. For more
#' information, see [Adding a
#' tag](https://docs.aws.amazon.com/omics/latest/dev/add-a-tag.html) in the
#' *Amazon Web Services HealthOmics User Guide*.
#' @param requestId &#91;required&#93; An idempotency token used to dedupe retry requests so that duplicate
#' runs are not created.
#' @param retentionMode The retention mode for the run. The default value is `RETAIN`.
#' 
#' Amazon Web Services HealthOmics stores a fixed number of runs that are
#' available to the console and API. In the default mode (`RETAIN`), you
#' need to remove runs manually when the number of run exceeds the maximum.
#' If you set the retention mode to `REMOVE`, Amazon Web Services
#' HealthOmics automatically removes runs (that have mode set to `REMOVE`)
#' when the number of run exceeds the maximum. All run logs are available
#' in CloudWatch logs, if you need information about a run that is no
#' longer available to the API.
#' 
#' For more information about retention mode, see [Specifying run retention
#' mode](https://docs.aws.amazon.com/omics/latest/dev/starting-a-run.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param storageType The storage type for the run. If you set the storage type to `DYNAMIC`,
#' Amazon Web Services HealthOmics dynamically scales the storage up or
#' down, based on file system utilization. By default, the run uses
#' `STATIC` storage type, which allocates a fixed amount of storage. For
#' more information about `DYNAMIC` and `STATIC` storage, see [Run storage
#' types](https://docs.aws.amazon.com/omics/latest/dev/workflows-run-types.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#' @param workflowOwnerId The 12-digit account ID of the workflow owner that is used for running a
#' shared workflow. The workflow owner ID can be retrieved using the
#' [`get_share`][omics_get_share] API operation. If you are the workflow
#' owner, you do not need to include this ID.
#' @param workflowVersionName The name of the workflow version. Use workflow versions to track and
#' organize changes to the workflow. If your workflow has multiple
#' versions, the run uses the default version unless you specify a version
#' name. To learn more, see [Workflow
#' versioning](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   id = "string",
#'   status = "PENDING"|"STARTING"|"RUNNING"|"STOPPING"|"COMPLETED"|"DELETED"|"CANCELLED"|"FAILED",
#'   tags = list(
#'     "string"
#'   ),
#'   uuid = "string",
#'   runOutputUri = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_run(
#'   workflowId = "string",
#'   workflowType = "PRIVATE"|"READY2RUN",
#'   runId = "string",
#'   roleArn = "string",
#'   name = "string",
#'   cacheId = "string",
#'   cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'   runGroupId = "string",
#'   priority = 123,
#'   parameters = list(),
#'   storageCapacity = 123,
#'   outputUri = "string",
#'   logLevel = "OFF"|"FATAL"|"ERROR"|"ALL",
#'   tags = list(
#'     "string"
#'   ),
#'   requestId = "string",
#'   retentionMode = "RETAIN"|"REMOVE",
#'   storageType = "STATIC"|"DYNAMIC",
#'   workflowOwnerId = "string",
#'   workflowVersionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_run
#'
#' @aliases omics_start_run
omics_start_run <- function(workflowId = NULL, workflowType = NULL, runId = NULL, roleArn, name = NULL, cacheId = NULL, cacheBehavior = NULL, runGroupId = NULL, priority = NULL, parameters = NULL, storageCapacity = NULL, outputUri, logLevel = NULL, tags = NULL, requestId, retentionMode = NULL, storageType = NULL, workflowOwnerId = NULL, workflowVersionName = NULL) {
  op <- new_operation(
    name = "StartRun",
    http_method = "POST",
    http_path = "/run",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_run_input(workflowId = workflowId, workflowType = workflowType, runId = runId, roleArn = roleArn, name = name, cacheId = cacheId, cacheBehavior = cacheBehavior, runGroupId = runGroupId, priority = priority, parameters = parameters, storageCapacity = storageCapacity, outputUri = outputUri, logLevel = logLevel, tags = tags, requestId = requestId, retentionMode = retentionMode, storageType = storageType, workflowOwnerId = workflowOwnerId, workflowVersionName = workflowVersionName)
  output <- .omics$start_run_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_run <- omics_start_run

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Starts a variant import job.
#'
#' @usage
#' omics_start_variant_import_job(destinationName, roleArn, items,
#'   runLeftNormalization, annotationFields)
#'
#' @param destinationName &#91;required&#93; The destination variant store for the job.
#' @param roleArn &#91;required&#93; A service role for the job.
#' @param items &#91;required&#93; Items to import.
#' @param runLeftNormalization The job's left normalization setting.
#' @param annotationFields The annotation schema generated by the parsed annotation data.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_variant_import_job(
#'   destinationName = "string",
#'   roleArn = "string",
#'   items = list(
#'     list(
#'       source = "string"
#'     )
#'   ),
#'   runLeftNormalization = TRUE|FALSE,
#'   annotationFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_start_variant_import_job
#'
#' @aliases omics_start_variant_import_job
omics_start_variant_import_job <- function(destinationName, roleArn, items, runLeftNormalization = NULL, annotationFields = NULL) {
  op <- new_operation(
    name = "StartVariantImportJob",
    http_method = "POST",
    http_path = "/import/variant",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$start_variant_import_job_input(destinationName = destinationName, roleArn = roleArn, items = items, runLeftNormalization = runLeftNormalization, annotationFields = annotationFields)
  output <- .omics$start_variant_import_job_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$start_variant_import_job <- omics_start_variant_import_job

#' Tags a resource
#'
#' @description
#' Tags a resource.
#'
#' @usage
#' omics_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#' @param tags &#91;required&#93; Tags for the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_tag_resource
#'
#' @aliases omics_tag_resource
omics_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .omics$tag_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$tag_resource <- omics_tag_resource

#' Removes tags from a resource
#'
#' @description
#' Removes tags from a resource.
#'
#' @usage
#' omics_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The resource's ARN.
#' @param tagKeys &#91;required&#93; Keys of tags to remove.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_untag_resource
#'
#' @aliases omics_untag_resource
omics_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "tags-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .omics$untag_resource_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$untag_resource <- omics_untag_resource

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Updates an annotation store.
#'
#' @usage
#' omics_update_annotation_store(name, description)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   storeOptions = list(
#'     tsvStoreOptions = list(
#'       annotationType = "GENERIC"|"CHR_POS"|"CHR_POS_REF_ALT"|"CHR_START_END_ONE_BASE"|"CHR_START_END_REF_ALT_ONE_BASE"|"CHR_START_END_ZERO_BASE"|"CHR_START_END_REF_ALT_ZERO_BASE",
#'       formatToHeader = list(
#'         "string"
#'       ),
#'       schema = list(
#'         list(
#'           "LONG"|"INT"|"STRING"|"FLOAT"|"DOUBLE"|"BOOLEAN"
#'         )
#'       )
#'     )
#'   ),
#'   storeFormat = "GFF"|"TSV"|"VCF"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_annotation_store(
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_annotation_store
#'
#' @aliases omics_update_annotation_store
omics_update_annotation_store <- function(name, description = NULL) {
  op <- new_operation(
    name = "UpdateAnnotationStore",
    http_method = "POST",
    http_path = "/annotationStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_annotation_store_input(name = name, description = description)
  output <- .omics$update_annotation_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_annotation_store <- omics_update_annotation_store

#' Updates the description of an annotation store version
#'
#' @description
#' Updates the description of an annotation store version.
#'
#' @usage
#' omics_update_annotation_store_version(name, versionName, description)
#'
#' @param name &#91;required&#93; The name of an annotation store.
#' @param versionName &#91;required&#93; The name of an annotation store version.
#' @param description The description of an annotation store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   storeId = "string",
#'   id = "string",
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   versionName = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_annotation_store_version(
#'   name = "string",
#'   versionName = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_annotation_store_version
#'
#' @aliases omics_update_annotation_store_version
omics_update_annotation_store_version <- function(name, versionName, description = NULL) {
  op <- new_operation(
    name = "UpdateAnnotationStoreVersion",
    http_method = "POST",
    http_path = "/annotationStore/{name}/version/{versionName}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_annotation_store_version_input(name = name, versionName = versionName, description = description)
  output <- .omics$update_annotation_store_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_annotation_store_version <- omics_update_annotation_store_version

#' Updates a run cache using its ID and returns a response with no body if
#' the operation is successful
#'
#' @description
#' Updates a run cache using its ID and returns a response with no body if
#' the operation is successful. You can update the run cache description,
#' name, or the default run cache behavior with `CACHE_ON_FAILURE` or
#' `CACHE_ALWAYS`. To confirm that your run cache settings have been
#' properly updated, use the [`get_run_cache`][omics_get_run_cache] API
#' operation.
#' 
#' For more information, see [How call caching
#' works](https://docs.aws.amazon.com/omics/latest/dev/how-run-cache.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_update_run_cache(cacheBehavior, description, id, name)
#'
#' @param cacheBehavior Update the default run cache behavior.
#' @param description Update the run cache description.
#' @param id &#91;required&#93; The identifier of the run cache you want to update.
#' @param name Update the name of the run cache.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_run_cache(
#'   cacheBehavior = "CACHE_ON_FAILURE"|"CACHE_ALWAYS",
#'   description = "string",
#'   id = "string",
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_run_cache
#'
#' @aliases omics_update_run_cache
omics_update_run_cache <- function(cacheBehavior = NULL, description = NULL, id, name = NULL) {
  op <- new_operation(
    name = "UpdateRunCache",
    http_method = "POST",
    http_path = "/runCache/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_run_cache_input(cacheBehavior = cacheBehavior, description = description, id = id, name = name)
  output <- .omics$update_run_cache_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_run_cache <- omics_update_run_cache

#' Updates the settings of a run group and returns a response with no body
#' if the operation is successful
#'
#' @description
#' Updates the settings of a run group and returns a response with no body
#' if the operation is successful.
#' 
#' You can update the following settings with
#' [`update_run_group`][omics_update_run_group]:
#' 
#' -   Maximum number of CPUs
#' 
#' -   Run time (measured in minutes)
#' 
#' -   Number of GPUs
#' 
#' -   Number of concurrent runs
#' 
#' -   Group name
#' 
#' To confirm that the settings have been successfully updated, use the
#' [`list_run_groups`][omics_list_run_groups] or
#' [`get_run_group`][omics_get_run_group] API operations to verify that the
#' desired changes have been made.
#'
#' @usage
#' omics_update_run_group(id, name, maxCpus, maxRuns, maxDuration, maxGpus)
#'
#' @param id &#91;required&#93; The group's ID.
#' @param name A name for the group.
#' @param maxCpus The maximum number of CPUs to use.
#' @param maxRuns The maximum number of concurrent runs for the group.
#' @param maxDuration A maximum run time for the group in minutes.
#' @param maxGpus The maximum GPUs that can be used by a run group.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_run_group(
#'   id = "string",
#'   name = "string",
#'   maxCpus = 123,
#'   maxRuns = 123,
#'   maxDuration = 123,
#'   maxGpus = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_run_group
#'
#' @aliases omics_update_run_group
omics_update_run_group <- function(id, name = NULL, maxCpus = NULL, maxRuns = NULL, maxDuration = NULL, maxGpus = NULL) {
  op <- new_operation(
    name = "UpdateRunGroup",
    http_method = "POST",
    http_path = "/runGroup/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_run_group_input(id = id, name = name, maxCpus = maxCpus, maxRuns = maxRuns, maxDuration = maxDuration, maxGpus = maxGpus)
  output <- .omics$update_run_group_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_run_group <- omics_update_run_group

#' Update one or more parameters for the sequence store
#'
#' @description
#' Update one or more parameters for the sequence store.
#'
#' @usage
#' omics_update_sequence_store(id, name, description, clientToken,
#'   fallbackLocation, propagatedSetLevelTags, s3AccessConfig)
#'
#' @param id &#91;required&#93; The ID of the sequence store.
#' @param name A name for the sequence store.
#' @param description A description for the sequence store.
#' @param clientToken To ensure that requests don't run multiple times, specify a unique token
#' for each request.
#' @param fallbackLocation The S3 URI of a bucket and folder to store Read Sets that fail to
#' upload.
#' @param propagatedSetLevelTags The tags keys to propagate to the S3 objects associated with read sets
#' in the sequence store.
#' @param s3AccessConfig S3 access configuration parameters.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   arn = "string",
#'   name = "string",
#'   description = "string",
#'   sseConfig = list(
#'     type = "KMS",
#'     keyArn = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   propagatedSetLevelTags = list(
#'     "string"
#'   ),
#'   status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"FAILED",
#'   statusMessage = "string",
#'   fallbackLocation = "string",
#'   s3Access = list(
#'     s3Uri = "string",
#'     s3AccessPointArn = "string",
#'     accessLogLocation = "string"
#'   ),
#'   eTagAlgorithmFamily = "MD5up"|"SHA256up"|"SHA512up"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_sequence_store(
#'   id = "string",
#'   name = "string",
#'   description = "string",
#'   clientToken = "string",
#'   fallbackLocation = "string",
#'   propagatedSetLevelTags = list(
#'     "string"
#'   ),
#'   s3AccessConfig = list(
#'     accessLogLocation = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_sequence_store
#'
#' @aliases omics_update_sequence_store
omics_update_sequence_store <- function(id, name = NULL, description = NULL, clientToken = NULL, fallbackLocation = NULL, propagatedSetLevelTags = NULL, s3AccessConfig = NULL) {
  op <- new_operation(
    name = "UpdateSequenceStore",
    http_method = "PATCH",
    http_path = "/sequencestore/{id}",
    host_prefix = "control-storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_sequence_store_input(id = id, name = name, description = description, clientToken = clientToken, fallbackLocation = fallbackLocation, propagatedSetLevelTags = propagatedSetLevelTags, s3AccessConfig = s3AccessConfig)
  output <- .omics$update_sequence_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_sequence_store <- omics_update_sequence_store

#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025
#'
#' @description
#' Amazon Web Services HealthOmics variant stores and annotation stores
#' will no longer be open to new customers starting November 7, 2025. If
#' you would like to use variant stores or annotation stores, sign up prior
#' to that date. Existing customers can continue to use the service as
#' normal. For more information, see [Amazon Web Services HealthOmics
#' variant store and annotation store availability
#' change](https://docs.aws.amazon.com/omics/latest/dev/variant-store-availability-change.html).
#' 
#' Updates a variant store.
#'
#' @usage
#' omics_update_variant_store(name, description)
#'
#' @param name &#91;required&#93; A name for the store.
#' @param description A description for the store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   reference = list(
#'     referenceArn = "string"
#'   ),
#'   status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"FAILED",
#'   name = "string",
#'   description = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_variant_store(
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_variant_store
#'
#' @aliases omics_update_variant_store
omics_update_variant_store <- function(name, description = NULL) {
  op <- new_operation(
    name = "UpdateVariantStore",
    http_method = "POST",
    http_path = "/variantStore/{name}",
    host_prefix = "analytics-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_variant_store_input(name = name, description = description)
  output <- .omics$update_variant_store_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_variant_store <- omics_update_variant_store

#' Updates information about a workflow
#'
#' @description
#' Updates information about a workflow.
#' 
#' You can update the following workflow information:
#' 
#' -   Name
#' 
#' -   Description
#' 
#' -   Default storage type
#' 
#' -   Default storage capacity (with workflow ID)
#' 
#' This operation returns a response with no body if the operation is
#' successful. You can check the workflow updates by calling the
#' [`get_workflow`][omics_get_workflow] API operation.
#' 
#' For more information, see [Update a private
#' workflow](https://docs.aws.amazon.com/omics/latest/dev/update-private-workflow.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_update_workflow(id, name, description, storageType,
#'   storageCapacity, readmeMarkdown)
#'
#' @param id &#91;required&#93; The workflow's ID.
#' @param name A name for the workflow.
#' @param description A description for the workflow.
#' @param storageType The default storage type for runs that use this workflow. STATIC storage
#' allocates a fixed amount of storage. DYNAMIC storage dynamically scales
#' the storage up or down, based on file system utilization. For more
#' information about static and dynamic storage, see [Running
#' workflows](https://docs.aws.amazon.com/omics/latest/dev/) in the *Amazon
#' Web Services HealthOmics User Guide*.
#' @param storageCapacity The default static storage capacity (in gibibytes) for runs that use
#' this workflow or workflow version.
#' @param readmeMarkdown The markdown content for the workflow's README file. This provides
#' documentation and usage information for users of the workflow.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_workflow(
#'   id = "string",
#'   name = "string",
#'   description = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   storageCapacity = 123,
#'   readmeMarkdown = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_workflow
#'
#' @aliases omics_update_workflow
omics_update_workflow <- function(id, name = NULL, description = NULL, storageType = NULL, storageCapacity = NULL, readmeMarkdown = NULL) {
  op <- new_operation(
    name = "UpdateWorkflow",
    http_method = "POST",
    http_path = "/workflow/{id}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_workflow_input(id = id, name = name, description = description, storageType = storageType, storageCapacity = storageCapacity, readmeMarkdown = readmeMarkdown)
  output <- .omics$update_workflow_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_workflow <- omics_update_workflow

#' Updates information about the workflow version
#'
#' @description
#' Updates information about the workflow version. For more information,
#' see [Workflow versioning in Amazon Web Services
#' HealthOmics](https://docs.aws.amazon.com/omics/latest/dev/workflow-versions.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_update_workflow_version(workflowId, versionName, description,
#'   storageType, storageCapacity, readmeMarkdown)
#'
#' @param workflowId &#91;required&#93; The workflow's ID. The `workflowId` is not the UUID.
#' @param versionName &#91;required&#93; The name of the workflow version.
#' @param description Description of the workflow version.
#' @param storageType The default storage type for runs that use this workflow version. The
#' `storageType` can be overridden at run time. `DYNAMIC` storage
#' dynamically scales the storage up or down, based on file system
#' utilization. STATIC storage allocates a fixed amount of storage. For
#' more information about dynamic and static storage types, see [Run
#' storage
#' types](https://docs.aws.amazon.com/omics/latest/dev/workflows-run-types.html)
#' in the *in the Amazon Web Services HealthOmics User Guide* .
#' @param storageCapacity The default static storage capacity (in gibibytes) for runs that use
#' this workflow version. The `storageCapacity` can be overwritten at run
#' time. The storage capacity is not required for runs with a `DYNAMIC`
#' storage type.
#' @param readmeMarkdown The markdown content for the workflow version's README file. This
#' provides documentation and usage information for users of this specific
#' workflow version.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_workflow_version(
#'   workflowId = "string",
#'   versionName = "string",
#'   description = "string",
#'   storageType = "STATIC"|"DYNAMIC",
#'   storageCapacity = 123,
#'   readmeMarkdown = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_update_workflow_version
#'
#' @aliases omics_update_workflow_version
omics_update_workflow_version <- function(workflowId, versionName, description = NULL, storageType = NULL, storageCapacity = NULL, readmeMarkdown = NULL) {
  op <- new_operation(
    name = "UpdateWorkflowVersion",
    http_method = "POST",
    http_path = "/workflow/{workflowId}/version/{versionName}",
    host_prefix = "workflows-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$update_workflow_version_input(workflowId = workflowId, versionName = versionName, description = description, storageType = storageType, storageCapacity = storageCapacity, readmeMarkdown = readmeMarkdown)
  output <- .omics$update_workflow_version_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$update_workflow_version <- omics_update_workflow_version

#' Uploads a specific part of a read set into a sequence store
#'
#' @description
#' Uploads a specific part of a read set into a sequence store. When you a
#' upload a read set part with a part number that already exists, the new
#' part replaces the existing one. This operation returns a JSON formatted
#' response containing a string identifier that is used to confirm that
#' parts are being added to the intended upload.
#' 
#' For more information, see [Direct upload to a sequence
#' store](https://docs.aws.amazon.com/omics/latest/dev/synchronous-uploads.html)
#' in the *Amazon Web Services HealthOmics User Guide*.
#'
#' @usage
#' omics_upload_read_set_part(sequenceStoreId, uploadId, partSource,
#'   partNumber, payload)
#'
#' @param sequenceStoreId &#91;required&#93; The Sequence Store ID used for the multipart upload.
#' @param uploadId &#91;required&#93; The ID for the initiated multipart upload.
#' @param partSource &#91;required&#93; The source file for an upload part.
#' @param partNumber &#91;required&#93; The number of the part being uploaded.
#' @param payload &#91;required&#93; The read set data to upload for a part.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   checksum = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$upload_read_set_part(
#'   sequenceStoreId = "string",
#'   uploadId = "string",
#'   partSource = "SOURCE1"|"SOURCE2",
#'   partNumber = 123,
#'   payload = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname omics_upload_read_set_part
#'
#' @aliases omics_upload_read_set_part
omics_upload_read_set_part <- function(sequenceStoreId, uploadId, partSource, partNumber, payload) {
  op <- new_operation(
    name = "UploadReadSetPart",
    http_method = "PUT",
    http_path = "/sequencestore/{sequenceStoreId}/upload/{uploadId}/part",
    host_prefix = "storage-",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .omics$upload_read_set_part_input(sequenceStoreId = sequenceStoreId, uploadId = uploadId, partSource = partSource, partNumber = partNumber, payload = payload)
  output <- .omics$upload_read_set_part_output()
  config <- get_config()
  svc <- .omics$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.omics$operations$upload_read_set_part <- omics_upload_read_set_part

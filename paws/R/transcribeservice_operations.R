# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include transcribeservice_service.R
NULL

#' Creates a new Call Analytics category
#'
#' @description
#' Creates a new Call Analytics category.
#' 
#' All categories are automatically applied to your Call Analytics
#' transcriptions. Note that in order to apply categories to your
#' transcriptions, you must create them before submitting your
#' transcription request, as categories cannot be applied retroactively.
#' 
#' When creating a new category, you can use the `InputType` parameter to
#' label the category as a `POST_CALL` or a `REAL_TIME` category.
#' `POST_CALL` categories can only be applied to post-call transcriptions
#' and `REAL_TIME` categories can only be applied to real-time
#' transcriptions. If you do not include `InputType`, your category is
#' created as a `POST_CALL` category by default.
#' 
#' Call Analytics categories are composed of rules. For each category, you
#' must create between 1 and 20 rules. Rules can include these parameters:
#' , , , and .
#' 
#' To update an existing category, see .
#' 
#' To learn more about Call Analytics categories, see [Creating categories
#' for post-call
#' transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html)
#' and [Creating categories for real-time
#' transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html).
#'
#' @usage
#' transcribeservice_create_call_analytics_category(CategoryName, Rules,
#'   Tags, InputType)
#'
#' @param CategoryName &#91;required&#93; A unique name, chosen by you, for your Call Analytics category. It's
#' helpful to use a detailed naming system that will make sense to you in
#' the future. For example, it's better to use
#' `sentiment-positive-last30seconds` for a category over a generic name
#' like `test-category`.
#' 
#' Category names are case sensitive.
#' @param Rules &#91;required&#93; Rules define a Call Analytics category. When creating a new category,
#' you must create between 1 and 20 rules for that category. For each rule,
#' you specify a filter you want applied to the attributes of a call. For
#' example, you can choose a sentiment filter that detects if a customer's
#' sentiment was positive during the last 30 seconds of the call.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new call analytics category at the time you start this new job.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param InputType Choose whether you want to create a real-time or a post-call category
#' for your Call Analytics transcription.
#' 
#' Specifying `POST_CALL` assigns your category to post-call
#' transcriptions; categories with this input type cannot be applied to
#' streaming (real-time) transcriptions.
#' 
#' Specifying `REAL_TIME` assigns your category to streaming
#' transcriptions; categories with this input type cannot be applied to
#' post-call transcriptions.
#' 
#' If you do not include `InputType`, your category is created as a
#' post-call category by default.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CategoryProperties = list(
#'     CategoryName = "string",
#'     Rules = list(
#'       list(
#'         NonTalkTimeFilter = list(
#'           Threshold = 123,
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         InterruptionFilter = list(
#'           Threshold = 123,
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         TranscriptFilter = list(
#'           TranscriptFilterType = "EXACT",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE,
#'           Targets = list(
#'             "string"
#'           )
#'         ),
#'         SentimentFilter = list(
#'           Sentiments = list(
#'             "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'           ),
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     InputType = "REAL_TIME"|"POST_CALL"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_call_analytics_category(
#'   CategoryName = "string",
#'   Rules = list(
#'     list(
#'       NonTalkTimeFilter = list(
#'         Threshold = 123,
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         Negate = TRUE|FALSE
#'       ),
#'       InterruptionFilter = list(
#'         Threshold = 123,
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         Negate = TRUE|FALSE
#'       ),
#'       TranscriptFilter = list(
#'         TranscriptFilterType = "EXACT",
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         Negate = TRUE|FALSE,
#'         Targets = list(
#'           "string"
#'         )
#'       ),
#'       SentimentFilter = list(
#'         Sentiments = list(
#'           "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'         ),
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         Negate = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   InputType = "REAL_TIME"|"POST_CALL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_create_call_analytics_category
#'
#' @aliases transcribeservice_create_call_analytics_category
transcribeservice_create_call_analytics_category <- function(CategoryName, Rules, Tags = NULL, InputType = NULL) {
  op <- new_operation(
    name = "CreateCallAnalyticsCategory",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$create_call_analytics_category_input(CategoryName = CategoryName, Rules = Rules, Tags = Tags, InputType = InputType)
  output <- .transcribeservice$create_call_analytics_category_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$create_call_analytics_category <- transcribeservice_create_call_analytics_category

#' Creates a new custom language model
#'
#' @description
#' Creates a new custom language model.
#' 
#' When creating a new custom language model, you must specify:
#' 
#' -   If you want a Wideband (audio sample rates over 16,000 Hz) or
#'     Narrowband (audio sample rates under 16,000 Hz) base model
#' 
#' -   The location of your training and tuning files (this must be an
#'     Amazon S3 URI)
#' 
#' -   The language of your model
#' 
#' -   A unique name for your model
#'
#' @usage
#' transcribeservice_create_language_model(LanguageCode, BaseModelName,
#'   ModelName, InputDataConfig, Tags)
#'
#' @param LanguageCode &#91;required&#93; The language code that represents the language of your model. Each
#' custom language model must contain terms in only one language, and the
#' language you select for your custom language model must match the
#' language of your training and tuning data.
#' 
#' For a list of supported languages and their associated language codes,
#' refer to the [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#' table. Note that US English (`en-US`) is the only language supported
#' with Amazon Transcribe Medical.
#' 
#' A custom language model can only be used to transcribe files in the same
#' language as the model. For example, if you create a custom language
#' model using US English (`en-US`), you can only apply this model to files
#' that contain English audio.
#' @param BaseModelName &#91;required&#93; The Amazon Transcribe standard language model, or base model, used to
#' create your custom language model. Amazon Transcribe offers two options
#' for base models: Wideband and Narrowband.
#' 
#' If the audio you want to transcribe has a sample rate of 16,000 Hz or
#' greater, choose `WideBand`. To transcribe audio with a sample rate less
#' than 16,000 Hz, choose `NarrowBand`.
#' @param ModelName &#91;required&#93; A unique name, chosen by you, for your custom language model.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new custom
#' language model with the same name as an existing custom language model,
#' you get a `ConflictException` error.
#' @param InputDataConfig &#91;required&#93; Contains the Amazon S3 location of the training data you want to use to
#' create a new custom language model, and permissions to access this
#' location.
#' 
#' When using `InputDataConfig`, you must include these sub-parameters:
#' `S3Uri`, which is the Amazon S3 location of your training data, and
#' `DataAccessRoleArn`, which is the Amazon Resource Name (ARN) of the role
#' that has permission to access your specified Amazon S3 location. You can
#' optionally include `TuningDataS3Uri`, which is the Amazon S3 location of
#' your tuning data. If you specify different Amazon S3 locations for
#' training and tuning data, the ARN you use must have permissions to
#' access both locations.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new custom language model at the time you create this new model.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LanguageCode = "en-US"|"hi-IN"|"es-US"|"en-GB"|"en-AU"|"de-DE"|"ja-JP",
#'   BaseModelName = "NarrowBand"|"WideBand",
#'   ModelName = "string",
#'   InputDataConfig = list(
#'     S3Uri = "string",
#'     TuningDataS3Uri = "string",
#'     DataAccessRoleArn = "string"
#'   ),
#'   ModelStatus = "IN_PROGRESS"|"FAILED"|"COMPLETED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_language_model(
#'   LanguageCode = "en-US"|"hi-IN"|"es-US"|"en-GB"|"en-AU"|"de-DE"|"ja-JP",
#'   BaseModelName = "NarrowBand"|"WideBand",
#'   ModelName = "string",
#'   InputDataConfig = list(
#'     S3Uri = "string",
#'     TuningDataS3Uri = "string",
#'     DataAccessRoleArn = "string"
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_create_language_model
#'
#' @aliases transcribeservice_create_language_model
transcribeservice_create_language_model <- function(LanguageCode, BaseModelName, ModelName, InputDataConfig, Tags = NULL) {
  op <- new_operation(
    name = "CreateLanguageModel",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$create_language_model_input(LanguageCode = LanguageCode, BaseModelName = BaseModelName, ModelName = ModelName, InputDataConfig = InputDataConfig, Tags = Tags)
  output <- .transcribeservice$create_language_model_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$create_language_model <- transcribeservice_create_language_model

#' Creates a new custom medical vocabulary
#'
#' @description
#' Creates a new custom medical vocabulary.
#' 
#' Before creating a new custom medical vocabulary, you must first upload a
#' text file that contains your vocabulary table into an Amazon S3 bucket.
#' Note that this differs from , where you can include a list of terms
#' within your request using the `Phrases` flag;
#' [`create_medical_vocabulary`][transcribeservice_create_medical_vocabulary]
#' does not support the `Phrases` flag and only accepts vocabularies in
#' table format.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary request fails. Refer to [Character Sets for Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' 
#' For more information, see [Custom
#' vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html).
#'
#' @usage
#' transcribeservice_create_medical_vocabulary(VocabularyName,
#'   LanguageCode, VocabularyFileUri, Tags)
#'
#' @param VocabularyName &#91;required&#93; A unique name, chosen by you, for your new custom medical vocabulary.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new custom
#' medical vocabulary with the same name as an existing custom medical
#' vocabulary, you get a `ConflictException` error.
#' @param LanguageCode &#91;required&#93; The language code that represents the language of the entries in your
#' custom vocabulary. US English (`en-US`) is the only language supported
#' with Amazon Transcribe Medical.
#' @param VocabularyFileUri &#91;required&#93; The Amazon S3 location (URI) of the text file that contains your custom
#' medical vocabulary. The URI must be in the same Amazon Web Services
#' Region as the resource you're calling.
#' 
#' Here's an example URI path: `s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt`
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new custom medical vocabulary at the time you create this new custom
#' vocabulary.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyState = "PENDING"|"READY"|"FAILED",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureReason = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_medical_vocabulary(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyFileUri = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_create_medical_vocabulary
#'
#' @aliases transcribeservice_create_medical_vocabulary
transcribeservice_create_medical_vocabulary <- function(VocabularyName, LanguageCode, VocabularyFileUri, Tags = NULL) {
  op <- new_operation(
    name = "CreateMedicalVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$create_medical_vocabulary_input(VocabularyName = VocabularyName, LanguageCode = LanguageCode, VocabularyFileUri = VocabularyFileUri, Tags = Tags)
  output <- .transcribeservice$create_medical_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$create_medical_vocabulary <- transcribeservice_create_medical_vocabulary

#' Creates a new custom vocabulary
#'
#' @description
#' Creates a new custom vocabulary.
#' 
#' When creating a new custom vocabulary, you can either upload a text file
#' that contains your new entries, phrases, and terms into an Amazon S3
#' bucket and include the URI in your request. Or you can include a list of
#' terms directly in your request using the `Phrases` flag.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary request fails. Refer to [Character Sets for Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' 
#' For more information, see [Custom
#' vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/custom-vocabulary.html).
#'
#' @usage
#' transcribeservice_create_vocabulary(VocabularyName, LanguageCode,
#'   Phrases, VocabularyFileUri, Tags, DataAccessRoleArn)
#'
#' @param VocabularyName &#91;required&#93; A unique name, chosen by you, for your new custom vocabulary.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new custom
#' vocabulary with the same name as an existing custom vocabulary, you get
#' a `ConflictException` error.
#' @param LanguageCode &#91;required&#93; The language code that represents the language of the entries in your
#' custom vocabulary. Each custom vocabulary must contain terms in only one
#' language.
#' 
#' A custom vocabulary can only be used to transcribe files in the same
#' language as the custom vocabulary. For example, if you create a custom
#' vocabulary using US English (`en-US`), you can only apply this custom
#' vocabulary to files that contain English audio.
#' 
#' For a list of supported languages and their associated language codes,
#' refer to the [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#' table.
#' @param Phrases Use this parameter if you want to create your custom vocabulary by
#' including all desired terms, as comma-separated values, within your
#' request. The other option for creating your custom vocabulary is to save
#' your entries in a text file and upload them to an Amazon S3 bucket, then
#' specify the location of your file using the `VocabularyFileUri`
#' parameter.
#' 
#' Note that if you include `Phrases` in your request, you cannot use
#' `VocabularyFileUri`; you must choose one or the other.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary filter request fails. Refer to [Character Sets for
#' Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' @param VocabularyFileUri The Amazon S3 location of the text file that contains your custom
#' vocabulary. The URI must be located in the same Amazon Web Services
#' Region as the resource you're calling.
#' 
#' Here's an example URI path: `s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt`
#' 
#' Note that if you include `VocabularyFileUri` in your request, you cannot
#' use the `Phrases` flag; you must choose one or the other.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new custom vocabulary at the time you create this new custom vocabulary.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param DataAccessRoleArn The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files (in this
#' case, your custom vocabulary). If the role that you specify doesn’t have
#' the appropriate permissions to access the specified Amazon S3 location,
#' your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyState = "PENDING"|"READY"|"FAILED",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureReason = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_vocabulary(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   Phrases = list(
#'     "string"
#'   ),
#'   VocabularyFileUri = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   DataAccessRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_create_vocabulary
#'
#' @aliases transcribeservice_create_vocabulary
transcribeservice_create_vocabulary <- function(VocabularyName, LanguageCode, Phrases = NULL, VocabularyFileUri = NULL, Tags = NULL, DataAccessRoleArn = NULL) {
  op <- new_operation(
    name = "CreateVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$create_vocabulary_input(VocabularyName = VocabularyName, LanguageCode = LanguageCode, Phrases = Phrases, VocabularyFileUri = VocabularyFileUri, Tags = Tags, DataAccessRoleArn = DataAccessRoleArn)
  output <- .transcribeservice$create_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$create_vocabulary <- transcribeservice_create_vocabulary

#' Creates a new custom vocabulary filter
#'
#' @description
#' Creates a new custom vocabulary filter.
#' 
#' You can use custom vocabulary filters to mask, delete, or flag specific
#' words from your transcript. Custom vocabulary filters are commonly used
#' to mask profanity in transcripts.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary filter request fails. Refer to [Character Sets for
#' Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' 
#' For more information, see [Vocabulary
#' filtering](https://docs.aws.amazon.com/transcribe/latest/dg/vocabulary-filtering.html).
#'
#' @usage
#' transcribeservice_create_vocabulary_filter(VocabularyFilterName,
#'   LanguageCode, Words, VocabularyFilterFileUri, Tags, DataAccessRoleArn)
#'
#' @param VocabularyFilterName &#91;required&#93; A unique name, chosen by you, for your new custom vocabulary filter.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new custom
#' vocabulary filter with the same name as an existing custom vocabulary
#' filter, you get a `ConflictException` error.
#' @param LanguageCode &#91;required&#93; The language code that represents the language of the entries in your
#' vocabulary filter. Each custom vocabulary filter must contain terms in
#' only one language.
#' 
#' A custom vocabulary filter can only be used to transcribe files in the
#' same language as the filter. For example, if you create a custom
#' vocabulary filter using US English (`en-US`), you can only apply this
#' filter to files that contain English audio.
#' 
#' For a list of supported languages and their associated language codes,
#' refer to the [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#' table.
#' @param Words Use this parameter if you want to create your custom vocabulary filter
#' by including all desired terms, as comma-separated values, within your
#' request. The other option for creating your vocabulary filter is to save
#' your entries in a text file and upload them to an Amazon S3 bucket, then
#' specify the location of your file using the `VocabularyFilterFileUri`
#' parameter.
#' 
#' Note that if you include `Words` in your request, you cannot use
#' `VocabularyFilterFileUri`; you must choose one or the other.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary filter request fails. Refer to [Character Sets for
#' Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' @param VocabularyFilterFileUri The Amazon S3 location of the text file that contains your custom
#' vocabulary filter terms. The URI must be located in the same Amazon Web
#' Services Region as the resource you're calling.
#' 
#' Here's an example URI path:
#' `s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt`
#' 
#' Note that if you include `VocabularyFilterFileUri` in your request, you
#' cannot use `Words`; you must choose one or the other.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new custom vocabulary filter at the time you create this new vocabulary
#' filter.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param DataAccessRoleArn The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files (in this
#' case, your custom vocabulary filter). If the role that you specify
#' doesn’t have the appropriate permissions to access the specified Amazon
#' S3 location, your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyFilterName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_vocabulary_filter(
#'   VocabularyFilterName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   Words = list(
#'     "string"
#'   ),
#'   VocabularyFilterFileUri = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   DataAccessRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_create_vocabulary_filter
#'
#' @aliases transcribeservice_create_vocabulary_filter
transcribeservice_create_vocabulary_filter <- function(VocabularyFilterName, LanguageCode, Words = NULL, VocabularyFilterFileUri = NULL, Tags = NULL, DataAccessRoleArn = NULL) {
  op <- new_operation(
    name = "CreateVocabularyFilter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$create_vocabulary_filter_input(VocabularyFilterName = VocabularyFilterName, LanguageCode = LanguageCode, Words = Words, VocabularyFilterFileUri = VocabularyFilterFileUri, Tags = Tags, DataAccessRoleArn = DataAccessRoleArn)
  output <- .transcribeservice$create_vocabulary_filter_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$create_vocabulary_filter <- transcribeservice_create_vocabulary_filter

#' Deletes a Call Analytics category
#'
#' @description
#' Deletes a Call Analytics category. To use this operation, specify the
#' name of the category you want to delete using `CategoryName`. Category
#' names are case sensitive.
#'
#' @usage
#' transcribeservice_delete_call_analytics_category(CategoryName)
#'
#' @param CategoryName &#91;required&#93; The name of the Call Analytics category you want to delete. Category
#' names are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_call_analytics_category(
#'   CategoryName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_call_analytics_category
#'
#' @aliases transcribeservice_delete_call_analytics_category
transcribeservice_delete_call_analytics_category <- function(CategoryName) {
  op <- new_operation(
    name = "DeleteCallAnalyticsCategory",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_call_analytics_category_input(CategoryName = CategoryName)
  output <- .transcribeservice$delete_call_analytics_category_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_call_analytics_category <- transcribeservice_delete_call_analytics_category

#' Deletes a Call Analytics job
#'
#' @description
#' Deletes a Call Analytics job. To use this operation, specify the name of
#' the job you want to delete using `CallAnalyticsJobName`. Job names are
#' case sensitive.
#'
#' @usage
#' transcribeservice_delete_call_analytics_job(CallAnalyticsJobName)
#'
#' @param CallAnalyticsJobName &#91;required&#93; The name of the Call Analytics job you want to delete. Job names are
#' case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_call_analytics_job(
#'   CallAnalyticsJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_call_analytics_job
#'
#' @aliases transcribeservice_delete_call_analytics_job
transcribeservice_delete_call_analytics_job <- function(CallAnalyticsJobName) {
  op <- new_operation(
    name = "DeleteCallAnalyticsJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_call_analytics_job_input(CallAnalyticsJobName = CallAnalyticsJobName)
  output <- .transcribeservice$delete_call_analytics_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_call_analytics_job <- transcribeservice_delete_call_analytics_job

#' Deletes a custom language model
#'
#' @description
#' Deletes a custom language model. To use this operation, specify the name
#' of the language model you want to delete using `ModelName`. custom
#' language model names are case sensitive.
#'
#' @usage
#' transcribeservice_delete_language_model(ModelName)
#'
#' @param ModelName &#91;required&#93; The name of the custom language model you want to delete. Model names
#' are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_language_model(
#'   ModelName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_language_model
#'
#' @aliases transcribeservice_delete_language_model
transcribeservice_delete_language_model <- function(ModelName) {
  op <- new_operation(
    name = "DeleteLanguageModel",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_language_model_input(ModelName = ModelName)
  output <- .transcribeservice$delete_language_model_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_language_model <- transcribeservice_delete_language_model

#' Deletes a Medical Scribe job
#'
#' @description
#' Deletes a Medical Scribe job. To use this operation, specify the name of
#' the job you want to delete using `MedicalScribeJobName`. Job names are
#' case sensitive.
#'
#' @usage
#' transcribeservice_delete_medical_scribe_job(MedicalScribeJobName)
#'
#' @param MedicalScribeJobName &#91;required&#93; The name of the Medical Scribe job you want to delete. Job names are
#' case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_medical_scribe_job(
#'   MedicalScribeJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_medical_scribe_job
#'
#' @aliases transcribeservice_delete_medical_scribe_job
transcribeservice_delete_medical_scribe_job <- function(MedicalScribeJobName) {
  op <- new_operation(
    name = "DeleteMedicalScribeJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_medical_scribe_job_input(MedicalScribeJobName = MedicalScribeJobName)
  output <- .transcribeservice$delete_medical_scribe_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_medical_scribe_job <- transcribeservice_delete_medical_scribe_job

#' Deletes a medical transcription job
#'
#' @description
#' Deletes a medical transcription job. To use this operation, specify the
#' name of the job you want to delete using `MedicalTranscriptionJobName`.
#' Job names are case sensitive.
#'
#' @usage
#' transcribeservice_delete_medical_transcription_job(
#'   MedicalTranscriptionJobName)
#'
#' @param MedicalTranscriptionJobName &#91;required&#93; The name of the medical transcription job you want to delete. Job names
#' are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_medical_transcription_job(
#'   MedicalTranscriptionJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_medical_transcription_job
#'
#' @aliases transcribeservice_delete_medical_transcription_job
transcribeservice_delete_medical_transcription_job <- function(MedicalTranscriptionJobName) {
  op <- new_operation(
    name = "DeleteMedicalTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_medical_transcription_job_input(MedicalTranscriptionJobName = MedicalTranscriptionJobName)
  output <- .transcribeservice$delete_medical_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_medical_transcription_job <- transcribeservice_delete_medical_transcription_job

#' Deletes a custom medical vocabulary
#'
#' @description
#' Deletes a custom medical vocabulary. To use this operation, specify the
#' name of the custom vocabulary you want to delete using `VocabularyName`.
#' Custom vocabulary names are case sensitive.
#'
#' @usage
#' transcribeservice_delete_medical_vocabulary(VocabularyName)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom medical vocabulary you want to delete. Custom
#' medical vocabulary names are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_medical_vocabulary(
#'   VocabularyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_medical_vocabulary
#'
#' @aliases transcribeservice_delete_medical_vocabulary
transcribeservice_delete_medical_vocabulary <- function(VocabularyName) {
  op <- new_operation(
    name = "DeleteMedicalVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_medical_vocabulary_input(VocabularyName = VocabularyName)
  output <- .transcribeservice$delete_medical_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_medical_vocabulary <- transcribeservice_delete_medical_vocabulary

#' Deletes a transcription job
#'
#' @description
#' Deletes a transcription job. To use this operation, specify the name of
#' the job you want to delete using `TranscriptionJobName`. Job names are
#' case sensitive.
#'
#' @usage
#' transcribeservice_delete_transcription_job(TranscriptionJobName)
#'
#' @param TranscriptionJobName &#91;required&#93; The name of the transcription job you want to delete. Job names are case
#' sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_transcription_job(
#'   TranscriptionJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_transcription_job
#'
#' @aliases transcribeservice_delete_transcription_job
transcribeservice_delete_transcription_job <- function(TranscriptionJobName) {
  op <- new_operation(
    name = "DeleteTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_transcription_job_input(TranscriptionJobName = TranscriptionJobName)
  output <- .transcribeservice$delete_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_transcription_job <- transcribeservice_delete_transcription_job

#' Deletes a custom vocabulary
#'
#' @description
#' Deletes a custom vocabulary. To use this operation, specify the name of
#' the custom vocabulary you want to delete using `VocabularyName`. Custom
#' vocabulary names are case sensitive.
#'
#' @usage
#' transcribeservice_delete_vocabulary(VocabularyName)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom vocabulary you want to delete. Custom vocabulary
#' names are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_vocabulary(
#'   VocabularyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_vocabulary
#'
#' @aliases transcribeservice_delete_vocabulary
transcribeservice_delete_vocabulary <- function(VocabularyName) {
  op <- new_operation(
    name = "DeleteVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_vocabulary_input(VocabularyName = VocabularyName)
  output <- .transcribeservice$delete_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_vocabulary <- transcribeservice_delete_vocabulary

#' Deletes a custom vocabulary filter
#'
#' @description
#' Deletes a custom vocabulary filter. To use this operation, specify the
#' name of the custom vocabulary filter you want to delete using
#' `VocabularyFilterName`. Custom vocabulary filter names are case
#' sensitive.
#'
#' @usage
#' transcribeservice_delete_vocabulary_filter(VocabularyFilterName)
#'
#' @param VocabularyFilterName &#91;required&#93; The name of the custom vocabulary filter you want to delete. Custom
#' vocabulary filter names are case sensitive.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_vocabulary_filter(
#'   VocabularyFilterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_delete_vocabulary_filter
#'
#' @aliases transcribeservice_delete_vocabulary_filter
transcribeservice_delete_vocabulary_filter <- function(VocabularyFilterName) {
  op <- new_operation(
    name = "DeleteVocabularyFilter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$delete_vocabulary_filter_input(VocabularyFilterName = VocabularyFilterName)
  output <- .transcribeservice$delete_vocabulary_filter_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$delete_vocabulary_filter <- transcribeservice_delete_vocabulary_filter

#' Provides information about the specified custom language model
#'
#' @description
#' Provides information about the specified custom language model.
#' 
#' This operation also shows if the base language model that you used to
#' create your custom language model has been updated. If Amazon Transcribe
#' has updated the base model, you can create a new custom language model
#' using the updated base model.
#' 
#' If you tried to create a new custom language model and the request
#' wasn't successful, you can use
#' [`describe_language_model`][transcribeservice_describe_language_model]
#' to help identify the reason for this failure.
#'
#' @usage
#' transcribeservice_describe_language_model(ModelName)
#'
#' @param ModelName &#91;required&#93; The name of the custom language model you want information about. Model
#' names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LanguageModel = list(
#'     ModelName = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LanguageCode = "en-US"|"hi-IN"|"es-US"|"en-GB"|"en-AU"|"de-DE"|"ja-JP",
#'     BaseModelName = "NarrowBand"|"WideBand",
#'     ModelStatus = "IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     UpgradeAvailability = TRUE|FALSE,
#'     FailureReason = "string",
#'     InputDataConfig = list(
#'       S3Uri = "string",
#'       TuningDataS3Uri = "string",
#'       DataAccessRoleArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_language_model(
#'   ModelName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_describe_language_model
#'
#' @aliases transcribeservice_describe_language_model
transcribeservice_describe_language_model <- function(ModelName) {
  op <- new_operation(
    name = "DescribeLanguageModel",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$describe_language_model_input(ModelName = ModelName)
  output <- .transcribeservice$describe_language_model_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$describe_language_model <- transcribeservice_describe_language_model

#' Provides information about the specified Call Analytics category
#'
#' @description
#' Provides information about the specified Call Analytics category.
#' 
#' To get a list of your Call Analytics categories, use the operation.
#'
#' @usage
#' transcribeservice_get_call_analytics_category(CategoryName)
#'
#' @param CategoryName &#91;required&#93; The name of the Call Analytics category you want information about.
#' Category names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CategoryProperties = list(
#'     CategoryName = "string",
#'     Rules = list(
#'       list(
#'         NonTalkTimeFilter = list(
#'           Threshold = 123,
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         InterruptionFilter = list(
#'           Threshold = 123,
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         TranscriptFilter = list(
#'           TranscriptFilterType = "EXACT",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE,
#'           Targets = list(
#'             "string"
#'           )
#'         ),
#'         SentimentFilter = list(
#'           Sentiments = list(
#'             "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'           ),
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     InputType = "REAL_TIME"|"POST_CALL"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_call_analytics_category(
#'   CategoryName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_call_analytics_category
#'
#' @aliases transcribeservice_get_call_analytics_category
transcribeservice_get_call_analytics_category <- function(CategoryName) {
  op <- new_operation(
    name = "GetCallAnalyticsCategory",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_call_analytics_category_input(CategoryName = CategoryName)
  output <- .transcribeservice$get_call_analytics_category_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_call_analytics_category <- transcribeservice_get_call_analytics_category

#' Provides information about the specified Call Analytics job
#'
#' @description
#' Provides information about the specified Call Analytics job.
#' 
#' To view the job's status, refer to `CallAnalyticsJobStatus`. If the
#' status is `COMPLETED`, the job is finished. You can find your completed
#' transcript at the URI specified in `TranscriptFileUri`. If the status is
#' `FAILED`, `FailureReason` provides details on why your transcription job
#' failed.
#' 
#' If you enabled personally identifiable information (PII) redaction, the
#' redacted transcript appears at the location specified in
#' `RedactedTranscriptFileUri`.
#' 
#' If you chose to redact the audio in your media file, you can find your
#' redacted media file at the location specified in `RedactedMediaFileUri`.
#' 
#' To get a list of your Call Analytics jobs, use the operation.
#'
#' @usage
#' transcribeservice_get_call_analytics_job(CallAnalyticsJobName)
#'
#' @param CallAnalyticsJobName &#91;required&#93; The name of the Call Analytics job you want information about. Job names
#' are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CallAnalyticsJob = list(
#'     CallAnalyticsJobName = "string",
#'     CallAnalyticsJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     CallAnalyticsJobDetails = list(
#'       Skipped = list(
#'         list(
#'           Feature = "GENERATIVE_SUMMARIZATION",
#'           ReasonCode = "INSUFFICIENT_CONVERSATION_CONTENT"|"FAILED_SAFETY_GUIDELINES",
#'           Message = "string"
#'         )
#'       )
#'     ),
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string",
#'       RedactedTranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     DataAccessRoleArn = "string",
#'     IdentifiedLanguageScore = 123.0,
#'     Settings = list(
#'       VocabularyName = "string",
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag",
#'       LanguageModelName = "string",
#'       ContentRedaction = list(
#'         RedactionType = "PII",
#'         RedactionOutput = "redacted"|"redacted_and_unredacted",
#'         PiiEntityTypes = list(
#'           "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'         )
#'       ),
#'       LanguageOptions = list(
#'         "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'       ),
#'       LanguageIdSettings = list(
#'         list(
#'           VocabularyName = "string",
#'           VocabularyFilterName = "string",
#'           LanguageModelName = "string"
#'         )
#'       ),
#'       Summarization = list(
#'         GenerateAbstractiveSummary = TRUE|FALSE
#'       )
#'     ),
#'     ChannelDefinitions = list(
#'       list(
#'         ChannelId = 123,
#'         ParticipantRole = "AGENT"|"CUSTOMER"
#'       )
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_call_analytics_job(
#'   CallAnalyticsJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_call_analytics_job
#'
#' @aliases transcribeservice_get_call_analytics_job
transcribeservice_get_call_analytics_job <- function(CallAnalyticsJobName) {
  op <- new_operation(
    name = "GetCallAnalyticsJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_call_analytics_job_input(CallAnalyticsJobName = CallAnalyticsJobName)
  output <- .transcribeservice$get_call_analytics_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_call_analytics_job <- transcribeservice_get_call_analytics_job

#' Provides information about the specified Medical Scribe job
#'
#' @description
#' Provides information about the specified Medical Scribe job.
#' 
#' To view the status of the specified medical transcription job, check the
#' `MedicalScribeJobStatus` field. If the status is `COMPLETED`, the job is
#' finished. You can find the results at the location specified in
#' `MedicalScribeOutput`. If the status is `FAILED`, `FailureReason`
#' provides details on why your Medical Scribe job failed.
#' 
#' To get a list of your Medical Scribe jobs, use the operation.
#'
#' @usage
#' transcribeservice_get_medical_scribe_job(MedicalScribeJobName)
#'
#' @param MedicalScribeJobName &#91;required&#93; The name of the Medical Scribe job you want information about. Job names
#' are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   MedicalScribeJob = list(
#'     MedicalScribeJobName = "string",
#'     MedicalScribeJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "en-US",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     MedicalScribeOutput = list(
#'       TranscriptFileUri = "string",
#'       ClinicalDocumentUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       VocabularyName = "string",
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag",
#'       ClinicalNoteGenerationSettings = list(
#'         NoteTemplate = "HISTORY_AND_PHYSICAL"|"GIRPP"|"BIRP"|"SIRP"|"DAP"|"BEHAVIORAL_SOAP"|"PHYSICAL_SOAP"
#'       )
#'     ),
#'     DataAccessRoleArn = "string",
#'     ChannelDefinitions = list(
#'       list(
#'         ChannelId = 123,
#'         ParticipantRole = "PATIENT"|"CLINICIAN"
#'       )
#'     ),
#'     MedicalScribeContextProvided = TRUE|FALSE,
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_medical_scribe_job(
#'   MedicalScribeJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_medical_scribe_job
#'
#' @aliases transcribeservice_get_medical_scribe_job
transcribeservice_get_medical_scribe_job <- function(MedicalScribeJobName) {
  op <- new_operation(
    name = "GetMedicalScribeJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_medical_scribe_job_input(MedicalScribeJobName = MedicalScribeJobName)
  output <- .transcribeservice$get_medical_scribe_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_medical_scribe_job <- transcribeservice_get_medical_scribe_job

#' Provides information about the specified medical transcription job
#'
#' @description
#' Provides information about the specified medical transcription job.
#' 
#' To view the status of the specified medical transcription job, check the
#' `TranscriptionJobStatus` field. If the status is `COMPLETED`, the job is
#' finished. You can find the results at the location specified in
#' `TranscriptFileUri`. If the status is `FAILED`, `FailureReason` provides
#' details on why your transcription job failed.
#' 
#' To get a list of your medical transcription jobs, use the operation.
#'
#' @usage
#' transcribeservice_get_medical_transcription_job(
#'   MedicalTranscriptionJobName)
#'
#' @param MedicalTranscriptionJobName &#91;required&#93; The name of the medical transcription job you want information about.
#' Job names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   MedicalTranscriptionJob = list(
#'     MedicalTranscriptionJobName = "string",
#'     TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       ShowAlternatives = TRUE|FALSE,
#'       MaxAlternatives = 123,
#'       VocabularyName = "string"
#'     ),
#'     ContentIdentificationType = "PHI",
#'     Specialty = "PRIMARYCARE",
#'     Type = "CONVERSATION"|"DICTATION",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_medical_transcription_job(
#'   MedicalTranscriptionJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_medical_transcription_job
#'
#' @aliases transcribeservice_get_medical_transcription_job
transcribeservice_get_medical_transcription_job <- function(MedicalTranscriptionJobName) {
  op <- new_operation(
    name = "GetMedicalTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_medical_transcription_job_input(MedicalTranscriptionJobName = MedicalTranscriptionJobName)
  output <- .transcribeservice$get_medical_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_medical_transcription_job <- transcribeservice_get_medical_transcription_job

#' Provides information about the specified custom medical vocabulary
#'
#' @description
#' Provides information about the specified custom medical vocabulary.
#' 
#' To view the status of the specified custom medical vocabulary, check the
#' `VocabularyState` field. If the status is `READY`, your custom
#' vocabulary is available to use. If the status is `FAILED`,
#' `FailureReason` provides details on why your vocabulary failed.
#' 
#' To get a list of your custom medical vocabularies, use the operation.
#'
#' @usage
#' transcribeservice_get_medical_vocabulary(VocabularyName)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom medical vocabulary you want information about.
#' Custom medical vocabulary names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyState = "PENDING"|"READY"|"FAILED",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureReason = "string",
#'   DownloadUri = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_medical_vocabulary(
#'   VocabularyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_medical_vocabulary
#'
#' @aliases transcribeservice_get_medical_vocabulary
transcribeservice_get_medical_vocabulary <- function(VocabularyName) {
  op <- new_operation(
    name = "GetMedicalVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_medical_vocabulary_input(VocabularyName = VocabularyName)
  output <- .transcribeservice$get_medical_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_medical_vocabulary <- transcribeservice_get_medical_vocabulary

#' Provides information about the specified transcription job
#'
#' @description
#' Provides information about the specified transcription job.
#' 
#' To view the status of the specified transcription job, check the
#' `TranscriptionJobStatus` field. If the status is `COMPLETED`, the job is
#' finished. You can find the results at the location specified in
#' `TranscriptFileUri`. If the status is `FAILED`, `FailureReason` provides
#' details on why your transcription job failed.
#' 
#' If you enabled content redaction, the redacted transcript can be found
#' at the location specified in `RedactedTranscriptFileUri`.
#' 
#' To get a list of your transcription jobs, use the operation.
#'
#' @usage
#' transcribeservice_get_transcription_job(TranscriptionJobName)
#'
#' @param TranscriptionJobName &#91;required&#93; The name of the transcription job you want information about. Job names
#' are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TranscriptionJob = list(
#'     TranscriptionJobName = "string",
#'     TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string",
#'       RedactedTranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       VocabularyName = "string",
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       ShowAlternatives = TRUE|FALSE,
#'       MaxAlternatives = 123,
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag"
#'     ),
#'     ModelSettings = list(
#'       LanguageModelName = "string"
#'     ),
#'     JobExecutionSettings = list(
#'       AllowDeferredExecution = TRUE|FALSE,
#'       DataAccessRoleArn = "string"
#'     ),
#'     ContentRedaction = list(
#'       RedactionType = "PII",
#'       RedactionOutput = "redacted"|"redacted_and_unredacted",
#'       PiiEntityTypes = list(
#'         "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'       )
#'     ),
#'     IdentifyLanguage = TRUE|FALSE,
#'     IdentifyMultipleLanguages = TRUE|FALSE,
#'     LanguageOptions = list(
#'       "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'     ),
#'     IdentifiedLanguageScore = 123.0,
#'     LanguageCodes = list(
#'       list(
#'         LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'         DurationInSeconds = 123.0
#'       )
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     Subtitles = list(
#'       Formats = list(
#'         "vtt"|"srt"
#'       ),
#'       SubtitleFileUris = list(
#'         "string"
#'       ),
#'       OutputStartIndex = 123
#'     ),
#'     LanguageIdSettings = list(
#'       list(
#'         VocabularyName = "string",
#'         VocabularyFilterName = "string",
#'         LanguageModelName = "string"
#'       )
#'     ),
#'     ToxicityDetection = list(
#'       list(
#'         ToxicityCategories = list(
#'           "ALL"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_transcription_job(
#'   TranscriptionJobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_transcription_job
#'
#' @aliases transcribeservice_get_transcription_job
transcribeservice_get_transcription_job <- function(TranscriptionJobName) {
  op <- new_operation(
    name = "GetTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_transcription_job_input(TranscriptionJobName = TranscriptionJobName)
  output <- .transcribeservice$get_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_transcription_job <- transcribeservice_get_transcription_job

#' Provides information about the specified custom vocabulary
#'
#' @description
#' Provides information about the specified custom vocabulary.
#' 
#' To view the status of the specified custom vocabulary, check the
#' `VocabularyState` field. If the status is `READY`, your custom
#' vocabulary is available to use. If the status is `FAILED`,
#' `FailureReason` provides details on why your custom vocabulary failed.
#' 
#' To get a list of your custom vocabularies, use the operation.
#'
#' @usage
#' transcribeservice_get_vocabulary(VocabularyName)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom vocabulary you want information about. Custom
#' vocabulary names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyState = "PENDING"|"READY"|"FAILED",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureReason = "string",
#'   DownloadUri = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_vocabulary(
#'   VocabularyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_vocabulary
#'
#' @aliases transcribeservice_get_vocabulary
transcribeservice_get_vocabulary <- function(VocabularyName) {
  op <- new_operation(
    name = "GetVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_vocabulary_input(VocabularyName = VocabularyName)
  output <- .transcribeservice$get_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_vocabulary <- transcribeservice_get_vocabulary

#' Provides information about the specified custom vocabulary filter
#'
#' @description
#' Provides information about the specified custom vocabulary filter.
#' 
#' To get a list of your custom vocabulary filters, use the operation.
#'
#' @usage
#' transcribeservice_get_vocabulary_filter(VocabularyFilterName)
#'
#' @param VocabularyFilterName &#91;required&#93; The name of the custom vocabulary filter you want information about.
#' Custom vocabulary filter names are case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyFilterName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   DownloadUri = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_vocabulary_filter(
#'   VocabularyFilterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_get_vocabulary_filter
#'
#' @aliases transcribeservice_get_vocabulary_filter
transcribeservice_get_vocabulary_filter <- function(VocabularyFilterName) {
  op <- new_operation(
    name = "GetVocabularyFilter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$get_vocabulary_filter_input(VocabularyFilterName = VocabularyFilterName)
  output <- .transcribeservice$get_vocabulary_filter_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$get_vocabulary_filter <- transcribeservice_get_vocabulary_filter

#' Provides a list of Call Analytics categories, including all rules that
#' make up each category
#'
#' @description
#' Provides a list of Call Analytics categories, including all rules that
#' make up each category.
#' 
#' To get detailed information about a specific Call Analytics category,
#' use the operation.
#'
#' @usage
#' transcribeservice_list_call_analytics_categories(NextToken, MaxResults)
#'
#' @param NextToken If your
#' [`list_call_analytics_categories`][transcribeservice_list_call_analytics_categories]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of Call Analytics categories to return in each page
#' of results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Categories = list(
#'     list(
#'       CategoryName = "string",
#'       Rules = list(
#'         list(
#'           NonTalkTimeFilter = list(
#'             Threshold = 123,
#'             AbsoluteTimeRange = list(
#'               StartTime = 123,
#'               EndTime = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             RelativeTimeRange = list(
#'               StartPercentage = 123,
#'               EndPercentage = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             Negate = TRUE|FALSE
#'           ),
#'           InterruptionFilter = list(
#'             Threshold = 123,
#'             ParticipantRole = "AGENT"|"CUSTOMER",
#'             AbsoluteTimeRange = list(
#'               StartTime = 123,
#'               EndTime = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             RelativeTimeRange = list(
#'               StartPercentage = 123,
#'               EndPercentage = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             Negate = TRUE|FALSE
#'           ),
#'           TranscriptFilter = list(
#'             TranscriptFilterType = "EXACT",
#'             AbsoluteTimeRange = list(
#'               StartTime = 123,
#'               EndTime = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             RelativeTimeRange = list(
#'               StartPercentage = 123,
#'               EndPercentage = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             ParticipantRole = "AGENT"|"CUSTOMER",
#'             Negate = TRUE|FALSE,
#'             Targets = list(
#'               "string"
#'             )
#'           ),
#'           SentimentFilter = list(
#'             Sentiments = list(
#'               "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'             ),
#'             AbsoluteTimeRange = list(
#'               StartTime = 123,
#'               EndTime = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             RelativeTimeRange = list(
#'               StartPercentage = 123,
#'               EndPercentage = 123,
#'               First = 123,
#'               Last = 123
#'             ),
#'             ParticipantRole = "AGENT"|"CUSTOMER",
#'             Negate = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Tags = list(
#'         list(
#'           Key = "string",
#'           Value = "string"
#'         )
#'       ),
#'       InputType = "REAL_TIME"|"POST_CALL"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_call_analytics_categories(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_call_analytics_categories
#'
#' @aliases transcribeservice_list_call_analytics_categories
transcribeservice_list_call_analytics_categories <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListCallAnalyticsCategories",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_call_analytics_categories_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_call_analytics_categories_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_call_analytics_categories <- transcribeservice_list_call_analytics_categories

#' Provides a list of Call Analytics jobs that match the specified criteria
#'
#' @description
#' Provides a list of Call Analytics jobs that match the specified
#' criteria. If no criteria are specified, all Call Analytics jobs are
#' returned.
#' 
#' To get detailed information about a specific Call Analytics job, use the
#' operation.
#'
#' @usage
#' transcribeservice_list_call_analytics_jobs(Status, JobNameContains,
#'   NextToken, MaxResults)
#'
#' @param Status Returns only Call Analytics jobs with the specified status. Jobs are
#' ordered by creation date, with the newest job first. If you do not
#' include `Status`, all Call Analytics jobs are returned.
#' @param JobNameContains Returns only the Call Analytics jobs that contain the specified string.
#' The search is not case sensitive.
#' @param NextToken If your
#' [`list_call_analytics_jobs`][transcribeservice_list_call_analytics_jobs]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of Call Analytics jobs to return in each page of
#' results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   NextToken = "string",
#'   CallAnalyticsJobSummaries = list(
#'     list(
#'       CallAnalyticsJobName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       CallAnalyticsJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'       CallAnalyticsJobDetails = list(
#'         Skipped = list(
#'           list(
#'             Feature = "GENERATIVE_SUMMARIZATION",
#'             ReasonCode = "INSUFFICIENT_CONVERSATION_CONTENT"|"FAILED_SAFETY_GUIDELINES",
#'             Message = "string"
#'           )
#'         )
#'       ),
#'       FailureReason = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_call_analytics_jobs(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   JobNameContains = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_call_analytics_jobs
#'
#' @aliases transcribeservice_list_call_analytics_jobs
transcribeservice_list_call_analytics_jobs <- function(Status = NULL, JobNameContains = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListCallAnalyticsJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_call_analytics_jobs_input(Status = Status, JobNameContains = JobNameContains, NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_call_analytics_jobs_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_call_analytics_jobs <- transcribeservice_list_call_analytics_jobs

#' Provides a list of custom language models that match the specified
#' criteria
#'
#' @description
#' Provides a list of custom language models that match the specified
#' criteria. If no criteria are specified, all custom language models are
#' returned.
#' 
#' To get detailed information about a specific custom language model, use
#' the operation.
#'
#' @usage
#' transcribeservice_list_language_models(StatusEquals, NameContains,
#'   NextToken, MaxResults)
#'
#' @param StatusEquals Returns only custom language models with the specified status. Language
#' models are ordered by creation date, with the newest model first. If you
#' do not include `StatusEquals`, all custom language models are returned.
#' @param NameContains Returns only the custom language models that contain the specified
#' string. The search is not case sensitive.
#' @param NextToken If your [`list_language_models`][transcribeservice_list_language_models]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of custom language models to return in each page of
#' results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Models = list(
#'     list(
#'       ModelName = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LanguageCode = "en-US"|"hi-IN"|"es-US"|"en-GB"|"en-AU"|"de-DE"|"ja-JP",
#'       BaseModelName = "NarrowBand"|"WideBand",
#'       ModelStatus = "IN_PROGRESS"|"FAILED"|"COMPLETED",
#'       UpgradeAvailability = TRUE|FALSE,
#'       FailureReason = "string",
#'       InputDataConfig = list(
#'         S3Uri = "string",
#'         TuningDataS3Uri = "string",
#'         DataAccessRoleArn = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_language_models(
#'   StatusEquals = "IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   NameContains = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_language_models
#'
#' @aliases transcribeservice_list_language_models
transcribeservice_list_language_models <- function(StatusEquals = NULL, NameContains = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListLanguageModels",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_language_models_input(StatusEquals = StatusEquals, NameContains = NameContains, NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_language_models_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_language_models <- transcribeservice_list_language_models

#' Provides a list of Medical Scribe jobs that match the specified criteria
#'
#' @description
#' Provides a list of Medical Scribe jobs that match the specified
#' criteria. If no criteria are specified, all Medical Scribe jobs are
#' returned.
#' 
#' To get detailed information about a specific Medical Scribe job, use the
#' operation.
#'
#' @usage
#' transcribeservice_list_medical_scribe_jobs(Status, JobNameContains,
#'   NextToken, MaxResults)
#'
#' @param Status Returns only Medical Scribe jobs with the specified status. Jobs are
#' ordered by creation date, with the newest job first. If you do not
#' include `Status`, all Medical Scribe jobs are returned.
#' @param JobNameContains Returns only the Medical Scribe jobs that contain the specified string.
#' The search is not case sensitive.
#' @param NextToken If your
#' [`list_medical_scribe_jobs`][transcribeservice_list_medical_scribe_jobs]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of Medical Scribe jobs to return in each page of
#' results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   NextToken = "string",
#'   MedicalScribeJobSummaries = list(
#'     list(
#'       MedicalScribeJobName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LanguageCode = "en-US",
#'       MedicalScribeJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'       FailureReason = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_medical_scribe_jobs(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   JobNameContains = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_medical_scribe_jobs
#'
#' @aliases transcribeservice_list_medical_scribe_jobs
transcribeservice_list_medical_scribe_jobs <- function(Status = NULL, JobNameContains = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListMedicalScribeJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_medical_scribe_jobs_input(Status = Status, JobNameContains = JobNameContains, NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_medical_scribe_jobs_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_medical_scribe_jobs <- transcribeservice_list_medical_scribe_jobs

#' Provides a list of medical transcription jobs that match the specified
#' criteria
#'
#' @description
#' Provides a list of medical transcription jobs that match the specified
#' criteria. If no criteria are specified, all medical transcription jobs
#' are returned.
#' 
#' To get detailed information about a specific medical transcription job,
#' use the operation.
#'
#' @usage
#' transcribeservice_list_medical_transcription_jobs(Status,
#'   JobNameContains, NextToken, MaxResults)
#'
#' @param Status Returns only medical transcription jobs with the specified status. Jobs
#' are ordered by creation date, with the newest job first. If you do not
#' include `Status`, all medical transcription jobs are returned.
#' @param JobNameContains Returns only the medical transcription jobs that contain the specified
#' string. The search is not case sensitive.
#' @param NextToken If your
#' [`list_medical_transcription_jobs`][transcribeservice_list_medical_transcription_jobs]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of medical transcription jobs to return in each page
#' of results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   NextToken = "string",
#'   MedicalTranscriptionJobSummaries = list(
#'     list(
#'       MedicalTranscriptionJobName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'       FailureReason = "string",
#'       OutputLocationType = "CUSTOMER_BUCKET"|"SERVICE_BUCKET",
#'       Specialty = "PRIMARYCARE",
#'       ContentIdentificationType = "PHI",
#'       Type = "CONVERSATION"|"DICTATION"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_medical_transcription_jobs(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   JobNameContains = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_medical_transcription_jobs
#'
#' @aliases transcribeservice_list_medical_transcription_jobs
transcribeservice_list_medical_transcription_jobs <- function(Status = NULL, JobNameContains = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListMedicalTranscriptionJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_medical_transcription_jobs_input(Status = Status, JobNameContains = JobNameContains, NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_medical_transcription_jobs_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_medical_transcription_jobs <- transcribeservice_list_medical_transcription_jobs

#' Provides a list of custom medical vocabularies that match the specified
#' criteria
#'
#' @description
#' Provides a list of custom medical vocabularies that match the specified
#' criteria. If no criteria are specified, all custom medical vocabularies
#' are returned.
#' 
#' To get detailed information about a specific custom medical vocabulary,
#' use the operation.
#'
#' @usage
#' transcribeservice_list_medical_vocabularies(NextToken, MaxResults,
#'   StateEquals, NameContains)
#'
#' @param NextToken If your
#' [`list_medical_vocabularies`][transcribeservice_list_medical_vocabularies]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of custom medical vocabularies to return in each page
#' of results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#' @param StateEquals Returns only custom medical vocabularies with the specified state.
#' Custom vocabularies are ordered by creation date, with the newest
#' vocabulary first. If you do not include `StateEquals`, all custom
#' medical vocabularies are returned.
#' @param NameContains Returns only the custom medical vocabularies that contain the specified
#' string. The search is not case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "PENDING"|"READY"|"FAILED",
#'   NextToken = "string",
#'   Vocabularies = list(
#'     list(
#'       VocabularyName = "string",
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       VocabularyState = "PENDING"|"READY"|"FAILED"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_medical_vocabularies(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   StateEquals = "PENDING"|"READY"|"FAILED",
#'   NameContains = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_medical_vocabularies
#'
#' @aliases transcribeservice_list_medical_vocabularies
transcribeservice_list_medical_vocabularies <- function(NextToken = NULL, MaxResults = NULL, StateEquals = NULL, NameContains = NULL) {
  op <- new_operation(
    name = "ListMedicalVocabularies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_medical_vocabularies_input(NextToken = NextToken, MaxResults = MaxResults, StateEquals = StateEquals, NameContains = NameContains)
  output <- .transcribeservice$list_medical_vocabularies_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_medical_vocabularies <- transcribeservice_list_medical_vocabularies

#' Lists all tags associated with the specified transcription job,
#' vocabulary, model, or resource
#'
#' @description
#' Lists all tags associated with the specified transcription job,
#' vocabulary, model, or resource.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @usage
#' transcribeservice_list_tags_for_resource(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; Returns a list of all tags associated with the specified Amazon Resource
#' Name (ARN). ARNs have the format
#' `arn:partition:service:region:account-id:resource-type/resource-id`.
#' 
#' For example,
#' `arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name`.
#' 
#' Valid values for `resource-type` are: `transcription-job`,
#' `medical-transcription-job`, `vocabulary`, `medical-vocabulary`,
#' `vocabulary-filter`, and `language-model`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResourceArn = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_tags_for_resource
#'
#' @aliases transcribeservice_list_tags_for_resource
transcribeservice_list_tags_for_resource <- function(ResourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_tags_for_resource_input(ResourceArn = ResourceArn)
  output <- .transcribeservice$list_tags_for_resource_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_tags_for_resource <- transcribeservice_list_tags_for_resource

#' Provides a list of transcription jobs that match the specified criteria
#'
#' @description
#' Provides a list of transcription jobs that match the specified criteria.
#' If no criteria are specified, all transcription jobs are returned.
#' 
#' To get detailed information about a specific transcription job, use the
#' operation.
#'
#' @usage
#' transcribeservice_list_transcription_jobs(Status, JobNameContains,
#'   NextToken, MaxResults)
#'
#' @param Status Returns only transcription jobs with the specified status. Jobs are
#' ordered by creation date, with the newest job first. If you do not
#' include `Status`, all transcription jobs are returned.
#' @param JobNameContains Returns only the transcription jobs that contain the specified string.
#' The search is not case sensitive.
#' @param NextToken If your
#' [`list_transcription_jobs`][transcribeservice_list_transcription_jobs]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of transcription jobs to return in each page of
#' results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   NextToken = "string",
#'   TranscriptionJobSummaries = list(
#'     list(
#'       TranscriptionJobName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'       FailureReason = "string",
#'       OutputLocationType = "CUSTOMER_BUCKET"|"SERVICE_BUCKET",
#'       ContentRedaction = list(
#'         RedactionType = "PII",
#'         RedactionOutput = "redacted"|"redacted_and_unredacted",
#'         PiiEntityTypes = list(
#'           "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'         )
#'       ),
#'       ModelSettings = list(
#'         LanguageModelName = "string"
#'       ),
#'       IdentifyLanguage = TRUE|FALSE,
#'       IdentifyMultipleLanguages = TRUE|FALSE,
#'       IdentifiedLanguageScore = 123.0,
#'       LanguageCodes = list(
#'         list(
#'           LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'           DurationInSeconds = 123.0
#'         )
#'       ),
#'       ToxicityDetection = list(
#'         list(
#'           ToxicityCategories = list(
#'             "ALL"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_transcription_jobs(
#'   Status = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   JobNameContains = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_transcription_jobs
#'
#' @aliases transcribeservice_list_transcription_jobs
transcribeservice_list_transcription_jobs <- function(Status = NULL, JobNameContains = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListTranscriptionJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_transcription_jobs_input(Status = Status, JobNameContains = JobNameContains, NextToken = NextToken, MaxResults = MaxResults)
  output <- .transcribeservice$list_transcription_jobs_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_transcription_jobs <- transcribeservice_list_transcription_jobs

#' Provides a list of custom vocabularies that match the specified criteria
#'
#' @description
#' Provides a list of custom vocabularies that match the specified
#' criteria. If no criteria are specified, all custom vocabularies are
#' returned.
#' 
#' To get detailed information about a specific custom vocabulary, use the
#' operation.
#'
#' @usage
#' transcribeservice_list_vocabularies(NextToken, MaxResults, StateEquals,
#'   NameContains)
#'
#' @param NextToken If your [`list_vocabularies`][transcribeservice_list_vocabularies]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of custom vocabularies to return in each page of
#' results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#' @param StateEquals Returns only custom vocabularies with the specified state. Vocabularies
#' are ordered by creation date, with the newest vocabulary first. If you
#' do not include `StateEquals`, all custom medical vocabularies are
#' returned.
#' @param NameContains Returns only the custom vocabularies that contain the specified string.
#' The search is not case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "PENDING"|"READY"|"FAILED",
#'   NextToken = "string",
#'   Vocabularies = list(
#'     list(
#'       VocabularyName = "string",
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       VocabularyState = "PENDING"|"READY"|"FAILED"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_vocabularies(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   StateEquals = "PENDING"|"READY"|"FAILED",
#'   NameContains = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_vocabularies
#'
#' @aliases transcribeservice_list_vocabularies
transcribeservice_list_vocabularies <- function(NextToken = NULL, MaxResults = NULL, StateEquals = NULL, NameContains = NULL) {
  op <- new_operation(
    name = "ListVocabularies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_vocabularies_input(NextToken = NextToken, MaxResults = MaxResults, StateEquals = StateEquals, NameContains = NameContains)
  output <- .transcribeservice$list_vocabularies_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_vocabularies <- transcribeservice_list_vocabularies

#' Provides a list of custom vocabulary filters that match the specified
#' criteria
#'
#' @description
#' Provides a list of custom vocabulary filters that match the specified
#' criteria. If no criteria are specified, all custom vocabularies are
#' returned.
#' 
#' To get detailed information about a specific custom vocabulary filter,
#' use the operation.
#'
#' @usage
#' transcribeservice_list_vocabulary_filters(NextToken, MaxResults,
#'   NameContains)
#'
#' @param NextToken If your
#' [`list_vocabulary_filters`][transcribeservice_list_vocabulary_filters]
#' request returns more results than can be displayed, `NextToken` is
#' displayed in the response with an associated string. To get the next
#' page of results, copy this string and repeat your request, including
#' `NextToken` with the value of the copied string. Repeat as needed to
#' view all your results.
#' @param MaxResults The maximum number of custom vocabulary filters to return in each page
#' of results. If there are fewer results than the value that you specify,
#' only the actual results are returned. If you do not specify a value, a
#' default of 5 is used.
#' @param NameContains Returns only the custom vocabulary filters that contain the specified
#' string. The search is not case sensitive.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   VocabularyFilters = list(
#'     list(
#'       VocabularyFilterName = "string",
#'       LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_vocabulary_filters(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   NameContains = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_list_vocabulary_filters
#'
#' @aliases transcribeservice_list_vocabulary_filters
transcribeservice_list_vocabulary_filters <- function(NextToken = NULL, MaxResults = NULL, NameContains = NULL) {
  op <- new_operation(
    name = "ListVocabularyFilters",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .transcribeservice$list_vocabulary_filters_input(NextToken = NextToken, MaxResults = MaxResults, NameContains = NameContains)
  output <- .transcribeservice$list_vocabulary_filters_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$list_vocabulary_filters <- transcribeservice_list_vocabulary_filters

#' Transcribes the audio from a customer service call and applies any
#' additional Request Parameters you choose to include in your request
#'
#' @description
#' Transcribes the audio from a customer service call and applies any
#' additional Request Parameters you choose to include in your request.
#' 
#' In addition to many standard transcription features, Call Analytics
#' provides you with call characteristics, call summarization, speaker
#' sentiment, and optional redaction of your text transcript and your audio
#' file. You can also apply custom categories to flag specified conditions.
#' To learn more about these features and insights, refer to [Analyzing
#' call center audio with Call
#' Analytics](https://docs.aws.amazon.com/transcribe/latest/dg/call-analytics.html).
#' 
#' If you want to apply categories to your Call Analytics job, you must
#' create them before submitting your job request. Categories cannot be
#' retroactively applied to a job. To create a new category, use the
#' operation. To learn more about Call Analytics categories, see [Creating
#' categories for post-call
#' transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-batch.html)
#' and [Creating categories for real-time
#' transcriptions](https://docs.aws.amazon.com/transcribe/latest/dg/tca-categories-stream.html).
#' 
#' To make a
#' [`start_call_analytics_job`][transcribeservice_start_call_analytics_job]
#' request, you must first upload your media file into an Amazon S3 bucket;
#' you can then specify the Amazon S3 location of the file using the
#' `Media` parameter.
#' 
#' Job queuing is available for Call Analytics jobs. If you pass a
#' `DataAccessRoleArn` in your request and you exceed your Concurrent Job
#' Limit, your job will automatically be added to a queue to be processed
#' once your concurrent job count is below the limit.
#' 
#' You must include the following parameters in your
#' [`start_call_analytics_job`][transcribeservice_start_call_analytics_job]
#' request:
#' 
#' -   `region`: The Amazon Web Services Region where you are making your
#'     request. For a list of Amazon Web Services Regions supported with
#'     Amazon Transcribe, refer to [Amazon Transcribe endpoints and
#'     quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html).
#' 
#' -   `CallAnalyticsJobName`: A custom name that you create for your
#'     transcription job that's unique within your Amazon Web Services
#'     account.
#' 
#' -   `Media` (`MediaFileUri` or `RedactedMediaFileUri`): The Amazon S3
#'     location of your media file.
#' 
#' With Call Analytics, you can redact the audio contained in your media
#' file by including `RedactedMediaFileUri`, instead of `MediaFileUri`, to
#' specify the location of your input audio. If you choose to redact your
#' audio, you can find your redacted media at the location specified in the
#' `RedactedMediaFileUri` field of your response.
#'
#' @usage
#' transcribeservice_start_call_analytics_job(CallAnalyticsJobName, Media,
#'   OutputLocation, OutputEncryptionKMSKeyId, DataAccessRoleArn, Settings,
#'   Tags, ChannelDefinitions)
#'
#' @param CallAnalyticsJobName &#91;required&#93; A unique name, chosen by you, for your Call Analytics job.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new job
#' with the same name as an existing job, you get a `ConflictException`
#' error.
#' @param Media &#91;required&#93; Describes the Amazon S3 location of the media file you want to use in
#' your Call Analytics request.
#' @param OutputLocation The Amazon S3 location where you want your Call Analytics transcription
#' output stored. You can use any of the following formats to specify the
#' output location:
#' 
#' 1.  s3://DOC-EXAMPLE-BUCKET
#' 
#' 2.  s3://DOC-EXAMPLE-BUCKET/my-output-folder/
#' 
#' 3.  s3://DOC-EXAMPLE-BUCKET/my-output-folder/my-call-analytics-job.json
#' 
#' Unless you specify a file name (option 3), the name of your output file
#' has a default value that matches the name you specified for your
#' transcription job using the `CallAnalyticsJobName` parameter.
#' 
#' You can specify a KMS key to encrypt your output using the
#' `OutputEncryptionKMSKeyId` parameter. If you do not specify a KMS key,
#' Amazon Transcribe uses the default Amazon S3 key for server-side
#' encryption.
#' 
#' If you do not specify `OutputLocation`, your transcript is placed in a
#' service-managed Amazon S3 bucket and you are provided with a URI to
#' access your transcript.
#' @param OutputEncryptionKMSKeyId The Amazon Resource Name (ARN) of a KMS key that you want to use to
#' encrypt your Call Analytics output.
#' 
#' KMS key ARNs have the format
#' `arn:partition:kms:region:account:key/key-id`. For example:
#' `arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`.
#' For more information, see [KMS key
#' ARNs](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN).
#' 
#' If you do not specify an encryption key, your output is encrypted with
#' the default Amazon S3 key (SSE-S3).
#' 
#' Note that the role making the request and the role specified in the
#' `DataAccessRoleArn` request parameter (if present) must have permission
#' to use the specified KMS key.
#' @param DataAccessRoleArn The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files. If the role
#' that you specify doesn’t have the appropriate permissions to access the
#' specified Amazon S3 location, your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#' @param Settings Specify additional optional settings in your request, including content
#' redaction; allows you to apply custom language models, vocabulary
#' filters, and custom vocabularies to your Call Analytics job.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new call analytics job at the time you start this new job.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param ChannelDefinitions Makes it possible to specify which speaker is on which channel. For
#' example, if your agent is the first participant to speak, you would set
#' `ChannelId` to `0` (to indicate the first channel) and `ParticipantRole`
#' to `AGENT` (to indicate that it's the agent speaking).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CallAnalyticsJob = list(
#'     CallAnalyticsJobName = "string",
#'     CallAnalyticsJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     CallAnalyticsJobDetails = list(
#'       Skipped = list(
#'         list(
#'           Feature = "GENERATIVE_SUMMARIZATION",
#'           ReasonCode = "INSUFFICIENT_CONVERSATION_CONTENT"|"FAILED_SAFETY_GUIDELINES",
#'           Message = "string"
#'         )
#'       )
#'     ),
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string",
#'       RedactedTranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     DataAccessRoleArn = "string",
#'     IdentifiedLanguageScore = 123.0,
#'     Settings = list(
#'       VocabularyName = "string",
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag",
#'       LanguageModelName = "string",
#'       ContentRedaction = list(
#'         RedactionType = "PII",
#'         RedactionOutput = "redacted"|"redacted_and_unredacted",
#'         PiiEntityTypes = list(
#'           "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'         )
#'       ),
#'       LanguageOptions = list(
#'         "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'       ),
#'       LanguageIdSettings = list(
#'         list(
#'           VocabularyName = "string",
#'           VocabularyFilterName = "string",
#'           LanguageModelName = "string"
#'         )
#'       ),
#'       Summarization = list(
#'         GenerateAbstractiveSummary = TRUE|FALSE
#'       )
#'     ),
#'     ChannelDefinitions = list(
#'       list(
#'         ChannelId = 123,
#'         ParticipantRole = "AGENT"|"CUSTOMER"
#'       )
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_call_analytics_job(
#'   CallAnalyticsJobName = "string",
#'   Media = list(
#'     MediaFileUri = "string",
#'     RedactedMediaFileUri = "string"
#'   ),
#'   OutputLocation = "string",
#'   OutputEncryptionKMSKeyId = "string",
#'   DataAccessRoleArn = "string",
#'   Settings = list(
#'     VocabularyName = "string",
#'     VocabularyFilterName = "string",
#'     VocabularyFilterMethod = "remove"|"mask"|"tag",
#'     LanguageModelName = "string",
#'     ContentRedaction = list(
#'       RedactionType = "PII",
#'       RedactionOutput = "redacted"|"redacted_and_unredacted",
#'       PiiEntityTypes = list(
#'         "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'       )
#'     ),
#'     LanguageOptions = list(
#'       "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'     ),
#'     LanguageIdSettings = list(
#'       list(
#'         VocabularyName = "string",
#'         VocabularyFilterName = "string",
#'         LanguageModelName = "string"
#'       )
#'     ),
#'     Summarization = list(
#'       GenerateAbstractiveSummary = TRUE|FALSE
#'     )
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   ChannelDefinitions = list(
#'     list(
#'       ChannelId = 123,
#'       ParticipantRole = "AGENT"|"CUSTOMER"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_start_call_analytics_job
#'
#' @aliases transcribeservice_start_call_analytics_job
transcribeservice_start_call_analytics_job <- function(CallAnalyticsJobName, Media, OutputLocation = NULL, OutputEncryptionKMSKeyId = NULL, DataAccessRoleArn = NULL, Settings = NULL, Tags = NULL, ChannelDefinitions = NULL) {
  op <- new_operation(
    name = "StartCallAnalyticsJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$start_call_analytics_job_input(CallAnalyticsJobName = CallAnalyticsJobName, Media = Media, OutputLocation = OutputLocation, OutputEncryptionKMSKeyId = OutputEncryptionKMSKeyId, DataAccessRoleArn = DataAccessRoleArn, Settings = Settings, Tags = Tags, ChannelDefinitions = ChannelDefinitions)
  output <- .transcribeservice$start_call_analytics_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$start_call_analytics_job <- transcribeservice_start_call_analytics_job

#' Transcribes patient-clinician conversations and generates clinical notes
#'
#' @description
#' Transcribes patient-clinician conversations and generates clinical
#' notes.
#' 
#' Amazon Web Services HealthScribe automatically provides rich
#' conversation transcripts, identifies speaker roles, classifies
#' dialogues, extracts medical terms, and generates preliminary clinical
#' notes. To learn more about these features, refer to [Amazon Web Services
#' HealthScribe](https://docs.aws.amazon.com/transcribe/latest/dg/health-scribe.html).
#' 
#' To make a
#' [`start_medical_scribe_job`][transcribeservice_start_medical_scribe_job]
#' request, you must first upload your media file into an Amazon S3 bucket;
#' you can then specify the Amazon S3 location of the file using the
#' `Media` parameter.
#' 
#' You must include the following parameters in your
#' [`start_medical_transcription_job`][transcribeservice_start_medical_transcription_job]
#' request:
#' 
#' -   `DataAccessRoleArn`: The ARN of an IAM role with the these minimum
#'     permissions: read permission on input file Amazon S3 bucket
#'     specified in `Media`, write permission on the Amazon S3 bucket
#'     specified in `OutputBucketName`, and full permissions on the KMS key
#'     specified in `OutputEncryptionKMSKeyId` (if set). The role should
#'     also allow `transcribe.amazonaws.com` to assume it.
#' 
#' -   `Media` (`MediaFileUri`): The Amazon S3 location of your media file.
#' 
#' -   `MedicalScribeJobName`: A custom name you create for your
#'     MedicalScribe job that is unique within your Amazon Web Services
#'     account.
#' 
#' -   `OutputBucketName`: The Amazon S3 bucket where you want your output
#'     files stored.
#' 
#' -   `Settings`: A `MedicalScribeSettings` object that must set exactly
#'     one of `ShowSpeakerLabels` or `ChannelIdentification` to true. If
#'     `ShowSpeakerLabels` is true, `MaxSpeakerLabels` must also be set.
#' 
#' -   `ChannelDefinitions`: A `MedicalScribeChannelDefinitions` array
#'     should be set if and only if the `ChannelIdentification` value of
#'     `Settings` is set to true.
#'
#' @usage
#' transcribeservice_start_medical_scribe_job(MedicalScribeJobName, Media,
#'   OutputBucketName, OutputEncryptionKMSKeyId, KMSEncryptionContext,
#'   DataAccessRoleArn, Settings, ChannelDefinitions, Tags,
#'   MedicalScribeContext)
#'
#' @param MedicalScribeJobName &#91;required&#93; A unique name, chosen by you, for your Medical Scribe job.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new job
#' with the same name as an existing job, you get a `ConflictException`
#' error.
#' @param Media &#91;required&#93; 
#' @param OutputBucketName &#91;required&#93; The name of the Amazon S3 bucket where you want your Medical Scribe
#' output stored. Do not include the `S3://` prefix of the specified
#' bucket.
#' 
#' Note that the role specified in the `DataAccessRoleArn` request
#' parameter must have permission to use the specified location. You can
#' change Amazon S3 permissions using the Amazon Web Services Management
#' Console. See also [Permissions Required for IAM User
#' Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
#' @param OutputEncryptionKMSKeyId The Amazon Resource Name (ARN) of a KMS key that you want to use to
#' encrypt your Medical Scribe output.
#' 
#' KMS key ARNs have the format
#' `arn:partition:kms:region:account:key/key-id`. For example:
#' `arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`.
#' For more information, see [KMS key
#' ARNs](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN).
#' 
#' If you do not specify an encryption key, your output is encrypted with
#' the default Amazon S3 key (SSE-S3).
#' 
#' Note that the role making the request and the role specified in the
#' `DataAccessRoleArn` request parameter (if present) must have permission
#' to use the specified KMS key.
#' @param KMSEncryptionContext A map of plain text, non-secret key:value pairs, known as encryption
#' context pairs, that provide an added layer of security for your data.
#' For more information, see [KMS encryption
#' context](https://docs.aws.amazon.com/transcribe/latest/dg/#kms-context)
#' and [Asymmetric keys in
#' KMS](https://docs.aws.amazon.com/transcribe/latest/dg/).
#' @param DataAccessRoleArn &#91;required&#93; The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files, write to the
#' output bucket, and use your KMS key if supplied. If the role that you
#' specify doesn’t have the appropriate permissions your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#' @param Settings &#91;required&#93; Makes it possible to control how your Medical Scribe job is processed
#' using a `MedicalScribeSettings` object. Specify `ChannelIdentification`
#' if `ChannelDefinitions` are set. Enabled `ShowSpeakerLabels` if
#' `ChannelIdentification` and `ChannelDefinitions` are not set. One and
#' only one of `ChannelIdentification` and `ShowSpeakerLabels` must be set.
#' If `ShowSpeakerLabels` is set, `MaxSpeakerLabels` must also be set. Use
#' `Settings` to specify a vocabulary or vocabulary filter or both using
#' `VocabularyName`, `VocabularyFilterName`. `VocabularyFilterMethod` must
#' be specified if `VocabularyFilterName` is set.
#' @param ChannelDefinitions Makes it possible to specify which speaker is on which channel. For
#' example, if the clinician is the first participant to speak, you would
#' set `ChannelId` of the first `ChannelDefinition` in the list to `0` (to
#' indicate the first channel) and `ParticipantRole` to `CLINICIAN` (to
#' indicate that it's the clinician speaking). Then you would set the
#' `ChannelId` of the second `ChannelDefinition` in the list to `1` (to
#' indicate the second channel) and `ParticipantRole` to `PATIENT` (to
#' indicate that it's the patient speaking).
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to
#' the Medical Scribe job.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param MedicalScribeContext The `MedicalScribeContext` object that contains contextual information
#' which is used during clinical note generation to add relevant context to
#' the note.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   MedicalScribeJob = list(
#'     MedicalScribeJobName = "string",
#'     MedicalScribeJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "en-US",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     MedicalScribeOutput = list(
#'       TranscriptFileUri = "string",
#'       ClinicalDocumentUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       VocabularyName = "string",
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag",
#'       ClinicalNoteGenerationSettings = list(
#'         NoteTemplate = "HISTORY_AND_PHYSICAL"|"GIRPP"|"BIRP"|"SIRP"|"DAP"|"BEHAVIORAL_SOAP"|"PHYSICAL_SOAP"
#'       )
#'     ),
#'     DataAccessRoleArn = "string",
#'     ChannelDefinitions = list(
#'       list(
#'         ChannelId = 123,
#'         ParticipantRole = "PATIENT"|"CLINICIAN"
#'       )
#'     ),
#'     MedicalScribeContextProvided = TRUE|FALSE,
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_medical_scribe_job(
#'   MedicalScribeJobName = "string",
#'   Media = list(
#'     MediaFileUri = "string",
#'     RedactedMediaFileUri = "string"
#'   ),
#'   OutputBucketName = "string",
#'   OutputEncryptionKMSKeyId = "string",
#'   KMSEncryptionContext = list(
#'     "string"
#'   ),
#'   DataAccessRoleArn = "string",
#'   Settings = list(
#'     ShowSpeakerLabels = TRUE|FALSE,
#'     MaxSpeakerLabels = 123,
#'     ChannelIdentification = TRUE|FALSE,
#'     VocabularyName = "string",
#'     VocabularyFilterName = "string",
#'     VocabularyFilterMethod = "remove"|"mask"|"tag",
#'     ClinicalNoteGenerationSettings = list(
#'       NoteTemplate = "HISTORY_AND_PHYSICAL"|"GIRPP"|"BIRP"|"SIRP"|"DAP"|"BEHAVIORAL_SOAP"|"PHYSICAL_SOAP"
#'     )
#'   ),
#'   ChannelDefinitions = list(
#'     list(
#'       ChannelId = 123,
#'       ParticipantRole = "PATIENT"|"CLINICIAN"
#'     )
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   MedicalScribeContext = list(
#'     PatientContext = list(
#'       Pronouns = "HE_HIM"|"SHE_HER"|"THEY_THEM"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_start_medical_scribe_job
#'
#' @aliases transcribeservice_start_medical_scribe_job
transcribeservice_start_medical_scribe_job <- function(MedicalScribeJobName, Media, OutputBucketName, OutputEncryptionKMSKeyId = NULL, KMSEncryptionContext = NULL, DataAccessRoleArn, Settings, ChannelDefinitions = NULL, Tags = NULL, MedicalScribeContext = NULL) {
  op <- new_operation(
    name = "StartMedicalScribeJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$start_medical_scribe_job_input(MedicalScribeJobName = MedicalScribeJobName, Media = Media, OutputBucketName = OutputBucketName, OutputEncryptionKMSKeyId = OutputEncryptionKMSKeyId, KMSEncryptionContext = KMSEncryptionContext, DataAccessRoleArn = DataAccessRoleArn, Settings = Settings, ChannelDefinitions = ChannelDefinitions, Tags = Tags, MedicalScribeContext = MedicalScribeContext)
  output <- .transcribeservice$start_medical_scribe_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$start_medical_scribe_job <- transcribeservice_start_medical_scribe_job

#' Transcribes the audio from a medical dictation or conversation and
#' applies any additional Request Parameters you choose to include in your
#' request
#'
#' @description
#' Transcribes the audio from a medical dictation or conversation and
#' applies any additional Request Parameters you choose to include in your
#' request.
#' 
#' In addition to many standard transcription features, Amazon Transcribe
#' Medical provides you with a robust medical vocabulary and, optionally,
#' content identification, which adds flags to personal health information
#' (PHI). To learn more about these features, refer to [How Amazon
#' Transcribe Medical
#' works](https://docs.aws.amazon.com/transcribe/latest/dg/how-it-works-med.html).
#' 
#' To make a
#' [`start_medical_transcription_job`][transcribeservice_start_medical_transcription_job]
#' request, you must first upload your media file into an Amazon S3 bucket;
#' you can then specify the Amazon S3 location of the file using the
#' `Media` parameter.
#' 
#' You must include the following parameters in your
#' [`start_medical_transcription_job`][transcribeservice_start_medical_transcription_job]
#' request:
#' 
#' -   `region`: The Amazon Web Services Region where you are making your
#'     request. For a list of Amazon Web Services Regions supported with
#'     Amazon Transcribe, refer to [Amazon Transcribe endpoints and
#'     quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html).
#' 
#' -   `MedicalTranscriptionJobName`: A custom name you create for your
#'     transcription job that is unique within your Amazon Web Services
#'     account.
#' 
#' -   `Media` (`MediaFileUri`): The Amazon S3 location of your media file.
#' 
#' -   `LanguageCode`: This must be `en-US`.
#' 
#' -   `OutputBucketName`: The Amazon S3 bucket where you want your
#'     transcript stored. If you want your output stored in a sub-folder of
#'     this bucket, you must also include `OutputKey`.
#' 
#' -   `Specialty`: This must be `PRIMARYCARE`.
#' 
#' -   `Type`: Choose whether your audio is a conversation or a dictation.
#'
#' @usage
#' transcribeservice_start_medical_transcription_job(
#'   MedicalTranscriptionJobName, LanguageCode, MediaSampleRateHertz,
#'   MediaFormat, Media, OutputBucketName, OutputKey,
#'   OutputEncryptionKMSKeyId, KMSEncryptionContext, Settings,
#'   ContentIdentificationType, Specialty, Type, Tags)
#'
#' @param MedicalTranscriptionJobName &#91;required&#93; A unique name, chosen by you, for your medical transcription job. The
#' name that you specify is also used as the default name of your
#' transcription output file. If you want to specify a different name for
#' your transcription output, use the `OutputKey` parameter.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new job
#' with the same name as an existing job, you get a `ConflictException`
#' error.
#' @param LanguageCode &#91;required&#93; The language code that represents the language spoken in the input media
#' file. US English (`en-US`) is the only valid value for medical
#' transcription jobs. Any other value you enter for language code results
#' in a `BadRequestException` error.
#' @param MediaSampleRateHertz The sample rate, in hertz, of the audio track in your input media file.
#' 
#' If you do not specify the media sample rate, Amazon Transcribe Medical
#' determines it for you. If you specify the sample rate, it must match the
#' rate detected by Amazon Transcribe Medical; if there's a mismatch
#' between the value that you specify and the value detected, your job
#' fails. Therefore, in most cases, it's advised to omit
#' `MediaSampleRateHertz` and let Amazon Transcribe Medical determine the
#' sample rate.
#' @param MediaFormat Specify the format of your input media file.
#' @param Media &#91;required&#93; 
#' @param OutputBucketName &#91;required&#93; The name of the Amazon S3 bucket where you want your medical
#' transcription output stored. Do not include the `S3://` prefix of the
#' specified bucket.
#' 
#' If you want your output to go to a sub-folder of this bucket, specify it
#' using the `OutputKey` parameter; `OutputBucketName` only accepts the
#' name of a bucket.
#' 
#' For example, if you want your output stored in
#' `S3://DOC-EXAMPLE-BUCKET`, set `OutputBucketName` to
#' `DOC-EXAMPLE-BUCKET`. However, if you want your output stored in
#' `S3://DOC-EXAMPLE-BUCKET/test-files/`, set `OutputBucketName` to
#' `DOC-EXAMPLE-BUCKET` and `OutputKey` to `test-files/`.
#' 
#' Note that Amazon Transcribe must have permission to use the specified
#' location. You can change Amazon S3 permissions using the Amazon Web
#' Services Management Console. See also [Permissions Required for IAM User
#' Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
#' @param OutputKey Use in combination with `OutputBucketName` to specify the output
#' location of your transcript and, optionally, a unique name for your
#' output file. The default name for your transcription output is the same
#' as the name you specified for your medical transcription job
#' (`MedicalTranscriptionJobName`).
#' 
#' Here are some examples of how you can use `OutputKey`:
#' 
#' -   If you specify 'DOC-EXAMPLE-BUCKET' as the `OutputBucketName` and
#'     'my-transcript.json' as the `OutputKey`, your transcription output
#'     path is `s3://DOC-EXAMPLE-BUCKET/my-transcript.json`.
#' 
#' -   If you specify 'my-first-transcription' as the
#'     `MedicalTranscriptionJobName`, 'DOC-EXAMPLE-BUCKET' as the
#'     `OutputBucketName`, and 'my-transcript' as the `OutputKey`, your
#'     transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json`.
#' 
#' -   If you specify 'DOC-EXAMPLE-BUCKET' as the `OutputBucketName` and
#'     'test-files/my-transcript.json' as the `OutputKey`, your
#'     transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json`.
#' 
#' -   If you specify 'my-first-transcription' as the
#'     `MedicalTranscriptionJobName`, 'DOC-EXAMPLE-BUCKET' as the
#'     `OutputBucketName`, and 'test-files/my-transcript' as the
#'     `OutputKey`, your transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json`.
#' 
#' If you specify the name of an Amazon S3 bucket sub-folder that doesn't
#' exist, one is created for you.
#' @param OutputEncryptionKMSKeyId The Amazon Resource Name (ARN) of a KMS key that you want to use to
#' encrypt your medical transcription output.
#' 
#' KMS key ARNs have the format
#' `arn:partition:kms:region:account:key/key-id`. For example:
#' `arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`.
#' For more information, see [KMS key
#' ARNs](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN).
#' 
#' If you do not specify an encryption key, your output is encrypted with
#' the default Amazon S3 key (SSE-S3).
#' 
#' Note that the role making the request and the role specified in the
#' `DataAccessRoleArn` request parameter (if present) must have permission
#' to use the specified KMS key.
#' @param KMSEncryptionContext A map of plain text, non-secret key:value pairs, known as encryption
#' context pairs, that provide an added layer of security for your data.
#' For more information, see [KMS encryption
#' context](https://docs.aws.amazon.com/transcribe/latest/dg/#kms-context)
#' and [Asymmetric keys in
#' KMS](https://docs.aws.amazon.com/transcribe/latest/dg/).
#' @param Settings Specify additional optional settings in your request, including channel
#' identification, alternative transcriptions, and speaker partitioning.
#' You can use that to apply custom vocabularies to your transcription job.
#' @param ContentIdentificationType Labels all personal health information (PHI) identified in your
#' transcript. For more information, see [Identifying personal health
#' information (PHI) in a
#' transcription](https://docs.aws.amazon.com/transcribe/latest/dg/phi-id.html).
#' @param Specialty &#91;required&#93; Specify the predominant medical specialty represented in your media. For
#' batch transcriptions, `PRIMARYCARE` is the only valid value. If you
#' require additional specialties, refer to .
#' @param Type &#91;required&#93; Specify whether your input media contains only one person (`DICTATION`)
#' or contains a conversation between two people (`CONVERSATION`).
#' 
#' For example, `DICTATION` could be used for a medical professional
#' wanting to transcribe voice memos; `CONVERSATION` could be used for
#' transcribing the doctor-patient dialogue during the patient's office
#' visit.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new medical transcription job at the time you start this new job.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   MedicalTranscriptionJob = list(
#'     MedicalTranscriptionJobName = "string",
#'     TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       ShowAlternatives = TRUE|FALSE,
#'       MaxAlternatives = 123,
#'       VocabularyName = "string"
#'     ),
#'     ContentIdentificationType = "PHI",
#'     Specialty = "PRIMARYCARE",
#'     Type = "CONVERSATION"|"DICTATION",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_medical_transcription_job(
#'   MedicalTranscriptionJobName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   MediaSampleRateHertz = 123,
#'   MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'   Media = list(
#'     MediaFileUri = "string",
#'     RedactedMediaFileUri = "string"
#'   ),
#'   OutputBucketName = "string",
#'   OutputKey = "string",
#'   OutputEncryptionKMSKeyId = "string",
#'   KMSEncryptionContext = list(
#'     "string"
#'   ),
#'   Settings = list(
#'     ShowSpeakerLabels = TRUE|FALSE,
#'     MaxSpeakerLabels = 123,
#'     ChannelIdentification = TRUE|FALSE,
#'     ShowAlternatives = TRUE|FALSE,
#'     MaxAlternatives = 123,
#'     VocabularyName = "string"
#'   ),
#'   ContentIdentificationType = "PHI",
#'   Specialty = "PRIMARYCARE",
#'   Type = "CONVERSATION"|"DICTATION",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_start_medical_transcription_job
#'
#' @aliases transcribeservice_start_medical_transcription_job
transcribeservice_start_medical_transcription_job <- function(MedicalTranscriptionJobName, LanguageCode, MediaSampleRateHertz = NULL, MediaFormat = NULL, Media, OutputBucketName, OutputKey = NULL, OutputEncryptionKMSKeyId = NULL, KMSEncryptionContext = NULL, Settings = NULL, ContentIdentificationType = NULL, Specialty, Type, Tags = NULL) {
  op <- new_operation(
    name = "StartMedicalTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$start_medical_transcription_job_input(MedicalTranscriptionJobName = MedicalTranscriptionJobName, LanguageCode = LanguageCode, MediaSampleRateHertz = MediaSampleRateHertz, MediaFormat = MediaFormat, Media = Media, OutputBucketName = OutputBucketName, OutputKey = OutputKey, OutputEncryptionKMSKeyId = OutputEncryptionKMSKeyId, KMSEncryptionContext = KMSEncryptionContext, Settings = Settings, ContentIdentificationType = ContentIdentificationType, Specialty = Specialty, Type = Type, Tags = Tags)
  output <- .transcribeservice$start_medical_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$start_medical_transcription_job <- transcribeservice_start_medical_transcription_job

#' Transcribes the audio from a media file and applies any additional
#' Request Parameters you choose to include in your request
#'
#' @description
#' Transcribes the audio from a media file and applies any additional
#' Request Parameters you choose to include in your request.
#' 
#' To make a
#' [`start_transcription_job`][transcribeservice_start_transcription_job]
#' request, you must first upload your media file into an Amazon S3 bucket;
#' you can then specify the Amazon S3 location of the file using the
#' `Media` parameter.
#' 
#' You must include the following parameters in your
#' [`start_transcription_job`][transcribeservice_start_transcription_job]
#' request:
#' 
#' -   `region`: The Amazon Web Services Region where you are making your
#'     request. For a list of Amazon Web Services Regions supported with
#'     Amazon Transcribe, refer to [Amazon Transcribe endpoints and
#'     quotas](https://docs.aws.amazon.com/general/latest/gr/transcribe.html).
#' 
#' -   `TranscriptionJobName`: A custom name you create for your
#'     transcription job that is unique within your Amazon Web Services
#'     account.
#' 
#' -   `Media` (`MediaFileUri`): The Amazon S3 location of your media file.
#' 
#' -   One of `LanguageCode`, `IdentifyLanguage`, or
#'     `IdentifyMultipleLanguages`: If you know the language of your media
#'     file, specify it using the `LanguageCode` parameter; you can find
#'     all valid language codes in the [Supported
#'     languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#'     table. If you do not know the languages spoken in your media, use
#'     either `IdentifyLanguage` or `IdentifyMultipleLanguages` and let
#'     Amazon Transcribe identify the languages for you.
#'
#' @usage
#' transcribeservice_start_transcription_job(TranscriptionJobName,
#'   LanguageCode, MediaSampleRateHertz, MediaFormat, Media,
#'   OutputBucketName, OutputKey, OutputEncryptionKMSKeyId,
#'   KMSEncryptionContext, Settings, ModelSettings, JobExecutionSettings,
#'   ContentRedaction, IdentifyLanguage, IdentifyMultipleLanguages,
#'   LanguageOptions, Subtitles, Tags, LanguageIdSettings, ToxicityDetection)
#'
#' @param TranscriptionJobName &#91;required&#93; A unique name, chosen by you, for your transcription job. The name that
#' you specify is also used as the default name of your transcription
#' output file. If you want to specify a different name for your
#' transcription output, use the `OutputKey` parameter.
#' 
#' This name is case sensitive, cannot contain spaces, and must be unique
#' within an Amazon Web Services account. If you try to create a new job
#' with the same name as an existing job, you get a `ConflictException`
#' error.
#' @param LanguageCode The language code that represents the language spoken in the input media
#' file.
#' 
#' If you're unsure of the language spoken in your media file, consider
#' using `IdentifyLanguage` or `IdentifyMultipleLanguages` to enable
#' automatic language identification.
#' 
#' Note that you must include one of `LanguageCode`, `IdentifyLanguage`, or
#' `IdentifyMultipleLanguages` in your request. If you include more than
#' one of these parameters, your transcription job fails.
#' 
#' For a list of supported languages and their associated language codes,
#' refer to the [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#' table.
#' 
#' To transcribe speech in Modern Standard Arabic (`ar-SA`) in Amazon Web
#' Services GovCloud (US) (US-West, us-gov-west-1), Amazon Web Services
#' GovCloud (US) (US-East, us-gov-east-1), Canada (Calgary, ca-west-1) and
#' Africa (Cape Town, af-south-1), your media file must be encoded at a
#' sample rate of 16,000 Hz or higher.
#' @param MediaSampleRateHertz The sample rate, in hertz, of the audio track in your input media file.
#' 
#' If you do not specify the media sample rate, Amazon Transcribe
#' determines it for you. If you specify the sample rate, it must match the
#' rate detected by Amazon Transcribe. If there's a mismatch between the
#' value that you specify and the value detected, your job fails. In most
#' cases, you can omit `MediaSampleRateHertz` and let Amazon Transcribe
#' determine the sample rate.
#' @param MediaFormat Specify the format of your input media file.
#' @param Media &#91;required&#93; Describes the Amazon S3 location of the media file you want to use in
#' your request.
#' @param OutputBucketName The name of the Amazon S3 bucket where you want your transcription
#' output stored. Do not include the `S3://` prefix of the specified
#' bucket.
#' 
#' If you want your output to go to a sub-folder of this bucket, specify it
#' using the `OutputKey` parameter; `OutputBucketName` only accepts the
#' name of a bucket.
#' 
#' For example, if you want your output stored in
#' `S3://DOC-EXAMPLE-BUCKET`, set `OutputBucketName` to
#' `DOC-EXAMPLE-BUCKET`. However, if you want your output stored in
#' `S3://DOC-EXAMPLE-BUCKET/test-files/`, set `OutputBucketName` to
#' `DOC-EXAMPLE-BUCKET` and `OutputKey` to `test-files/`.
#' 
#' Note that Amazon Transcribe must have permission to use the specified
#' location. You can change Amazon S3 permissions using the Amazon Web
#' Services Management Console. See also [Permissions Required for IAM User
#' Roles](https://docs.aws.amazon.com/transcribe/latest/dg/security_iam_id-based-policy-examples.html#auth-role-iam-user).
#' 
#' If you do not specify `OutputBucketName`, your transcript is placed in a
#' service-managed Amazon S3 bucket and you are provided with a URI to
#' access your transcript.
#' @param OutputKey Use in combination with `OutputBucketName` to specify the output
#' location of your transcript and, optionally, a unique name for your
#' output file. The default name for your transcription output is the same
#' as the name you specified for your transcription job
#' (`TranscriptionJobName`).
#' 
#' Here are some examples of how you can use `OutputKey`:
#' 
#' -   If you specify 'DOC-EXAMPLE-BUCKET' as the `OutputBucketName` and
#'     'my-transcript.json' as the `OutputKey`, your transcription output
#'     path is `s3://DOC-EXAMPLE-BUCKET/my-transcript.json`.
#' 
#' -   If you specify 'my-first-transcription' as the
#'     `TranscriptionJobName`, 'DOC-EXAMPLE-BUCKET' as the
#'     `OutputBucketName`, and 'my-transcript' as the `OutputKey`, your
#'     transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/my-transcript/my-first-transcription.json`.
#' 
#' -   If you specify 'DOC-EXAMPLE-BUCKET' as the `OutputBucketName` and
#'     'test-files/my-transcript.json' as the `OutputKey`, your
#'     transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript.json`.
#' 
#' -   If you specify 'my-first-transcription' as the
#'     `TranscriptionJobName`, 'DOC-EXAMPLE-BUCKET' as the
#'     `OutputBucketName`, and 'test-files/my-transcript' as the
#'     `OutputKey`, your transcription output path is
#'     `s3://DOC-EXAMPLE-BUCKET/test-files/my-transcript/my-first-transcription.json`.
#' 
#' If you specify the name of an Amazon S3 bucket sub-folder that doesn't
#' exist, one is created for you.
#' @param OutputEncryptionKMSKeyId The Amazon Resource Name (ARN) of a KMS key that you want to use to
#' encrypt your transcription output.
#' 
#' KMS key ARNs have the format
#' `arn:partition:kms:region:account:key/key-id`. For example:
#' `arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab`.
#' For more information, see [KMS key
#' ARNs](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id-key-ARN).
#' 
#' If you do not specify an encryption key, your output is encrypted with
#' the default Amazon S3 key (SSE-S3).
#' 
#' Note that the role making the request and the role specified in the
#' `DataAccessRoleArn` request parameter (if present) must have permission
#' to use the specified KMS key.
#' @param KMSEncryptionContext A map of plain text, non-secret key:value pairs, known as encryption
#' context pairs, that provide an added layer of security for your data.
#' For more information, see [KMS encryption
#' context](https://docs.aws.amazon.com/transcribe/latest/dg/#kms-context)
#' and [Asymmetric keys in
#' KMS](https://docs.aws.amazon.com/transcribe/latest/dg/).
#' @param Settings Specify additional optional settings in your request, including channel
#' identification, alternative transcriptions, speaker partitioning. You
#' can use that to apply custom vocabularies and vocabulary filters.
#' 
#' If you want to include a custom vocabulary or a custom vocabulary filter
#' (or both) with your request but **do not** want to use automatic
#' language identification, use `Settings` with the `VocabularyName` or
#' `VocabularyFilterName` (or both) sub-parameter.
#' 
#' If you're using automatic language identification with your request and
#' want to include a custom language model, a custom vocabulary, or a
#' custom vocabulary filter, use instead the `` parameter with the
#' `LanguageModelName`, `VocabularyName` or `VocabularyFilterName`
#' sub-parameters.
#' @param ModelSettings Specify the custom language model you want to include with your
#' transcription job. If you include `ModelSettings` in your request, you
#' must include the `LanguageModelName` sub-parameter.
#' 
#' For more information, see [Custom language
#' models](https://docs.aws.amazon.com/transcribe/latest/dg/custom-language-models.html).
#' @param JobExecutionSettings Makes it possible to control how your transcription job is processed.
#' Currently, the only `JobExecutionSettings` modification you can choose
#' is enabling job queueing using the `AllowDeferredExecution`
#' sub-parameter.
#' 
#' If you include `JobExecutionSettings` in your request, you must also
#' include the sub-parameters: `AllowDeferredExecution` and
#' `DataAccessRoleArn`.
#' @param ContentRedaction Makes it possible to redact or flag specified personally identifiable
#' information (PII) in your transcript. If you use `ContentRedaction`, you
#' must also include the sub-parameters: `RedactionOutput` and
#' `RedactionType`. You can optionally include `PiiEntityTypes` to choose
#' which types of PII you want to redact. If you do not include
#' `PiiEntityTypes` in your request, all PII is redacted.
#' @param IdentifyLanguage Enables automatic language identification in your transcription job
#' request. Use this parameter if your media file contains only one
#' language. If your media contains multiple languages, use
#' `IdentifyMultipleLanguages` instead.
#' 
#' If you include `IdentifyLanguage`, you can optionally include a list of
#' language codes, using `LanguageOptions`, that you think may be present
#' in your media file. Including `LanguageOptions` restricts
#' `IdentifyLanguage` to only the language options that you specify, which
#' can improve transcription accuracy.
#' 
#' If you want to apply a custom language model, a custom vocabulary, or a
#' custom vocabulary filter to your automatic language identification
#' request, include `LanguageIdSettings` with the relevant sub-parameters
#' (`VocabularyName`, `LanguageModelName`, and `VocabularyFilterName`). If
#' you include `LanguageIdSettings`, also include `LanguageOptions`.
#' 
#' Note that you must include one of `LanguageCode`, `IdentifyLanguage`, or
#' `IdentifyMultipleLanguages` in your request. If you include more than
#' one of these parameters, your transcription job fails.
#' @param IdentifyMultipleLanguages Enables automatic multi-language identification in your transcription
#' job request. Use this parameter if your media file contains more than
#' one language. If your media contains only one language, use
#' `IdentifyLanguage` instead.
#' 
#' If you include `IdentifyMultipleLanguages`, you can optionally include a
#' list of language codes, using `LanguageOptions`, that you think may be
#' present in your media file. Including `LanguageOptions` restricts
#' `IdentifyLanguage` to only the language options that you specify, which
#' can improve transcription accuracy.
#' 
#' If you want to apply a custom vocabulary or a custom vocabulary filter
#' to your automatic language identification request, include
#' `LanguageIdSettings` with the relevant sub-parameters (`VocabularyName`
#' and `VocabularyFilterName`). If you include `LanguageIdSettings`, also
#' include `LanguageOptions`.
#' 
#' Note that you must include one of `LanguageCode`, `IdentifyLanguage`, or
#' `IdentifyMultipleLanguages` in your request. If you include more than
#' one of these parameters, your transcription job fails.
#' @param LanguageOptions You can specify two or more language codes that represent the languages
#' you think may be present in your media. Including more than five is not
#' recommended. If you're unsure what languages are present, do not include
#' this parameter.
#' 
#' If you include `LanguageOptions` in your request, you must also include
#' `IdentifyLanguage`.
#' 
#' For more information, refer to [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html).
#' 
#' To transcribe speech in Modern Standard Arabic (`ar-SA`)in Amazon Web
#' Services GovCloud (US) (US-West, us-gov-west-1), Amazon Web Services
#' GovCloud (US) (US-East, us-gov-east-1), in Canada (Calgary) ca-west-1
#' and Africa (Cape Town) af-south-1, your media file must be encoded at a
#' sample rate of 16,000 Hz or higher.
#' @param Subtitles Produces subtitle files for your input media. You can specify WebVTT
#' (*.vtt) and SubRip (*.srt) formats.
#' @param Tags Adds one or more custom tags, each in the form of a key:value pair, to a
#' new transcription job at the time you start this new job.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#' @param LanguageIdSettings If using automatic language identification in your request and you want
#' to apply a custom language model, a custom vocabulary, or a custom
#' vocabulary filter, include `LanguageIdSettings` with the relevant
#' sub-parameters (`VocabularyName`, `LanguageModelName`, and
#' `VocabularyFilterName`). Note that multi-language identification
#' (`IdentifyMultipleLanguages`) doesn't support custom language models.
#' 
#' `LanguageIdSettings` supports two to five language codes. Each language
#' code you include can have an associated custom language model, custom
#' vocabulary, and custom vocabulary filter. The language codes that you
#' specify must match the languages of the associated custom language
#' models, custom vocabularies, and custom vocabulary filters.
#' 
#' It's recommended that you include `LanguageOptions` when using
#' `LanguageIdSettings` to ensure that the correct language dialect is
#' identified. For example, if you specify a custom vocabulary that is in
#' `en-US` but Amazon Transcribe determines that the language spoken in
#' your media is `en-AU`, your custom vocabulary *is not* applied to your
#' transcription. If you include `LanguageOptions` and include `en-US` as
#' the only English language dialect, your custom vocabulary *is* applied
#' to your transcription.
#' 
#' If you want to include a custom language model with your request but
#' **do not** want to use automatic language identification, use instead
#' the `` parameter with the `LanguageModelName` sub-parameter. If you want
#' to include a custom vocabulary or a custom vocabulary filter (or both)
#' with your request but **do not** want to use automatic language
#' identification, use instead the `` parameter with the `VocabularyName`
#' or `VocabularyFilterName` (or both) sub-parameter.
#' @param ToxicityDetection Enables toxic speech detection in your transcript. If you include
#' `ToxicityDetection` in your request, you must also include
#' `ToxicityCategories`.
#' 
#' For information on the types of toxic speech Amazon Transcribe can
#' detect, see [Detecting toxic
#' speech](https://docs.aws.amazon.com/transcribe/latest/dg/).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TranscriptionJob = list(
#'     TranscriptionJobName = "string",
#'     TranscriptionJobStatus = "QUEUED"|"IN_PROGRESS"|"FAILED"|"COMPLETED",
#'     LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'     MediaSampleRateHertz = 123,
#'     MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'     Media = list(
#'       MediaFileUri = "string",
#'       RedactedMediaFileUri = "string"
#'     ),
#'     Transcript = list(
#'       TranscriptFileUri = "string",
#'       RedactedTranscriptFileUri = "string"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureReason = "string",
#'     Settings = list(
#'       VocabularyName = "string",
#'       ShowSpeakerLabels = TRUE|FALSE,
#'       MaxSpeakerLabels = 123,
#'       ChannelIdentification = TRUE|FALSE,
#'       ShowAlternatives = TRUE|FALSE,
#'       MaxAlternatives = 123,
#'       VocabularyFilterName = "string",
#'       VocabularyFilterMethod = "remove"|"mask"|"tag"
#'     ),
#'     ModelSettings = list(
#'       LanguageModelName = "string"
#'     ),
#'     JobExecutionSettings = list(
#'       AllowDeferredExecution = TRUE|FALSE,
#'       DataAccessRoleArn = "string"
#'     ),
#'     ContentRedaction = list(
#'       RedactionType = "PII",
#'       RedactionOutput = "redacted"|"redacted_and_unredacted",
#'       PiiEntityTypes = list(
#'         "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'       )
#'     ),
#'     IdentifyLanguage = TRUE|FALSE,
#'     IdentifyMultipleLanguages = TRUE|FALSE,
#'     LanguageOptions = list(
#'       "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'     ),
#'     IdentifiedLanguageScore = 123.0,
#'     LanguageCodes = list(
#'       list(
#'         LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'         DurationInSeconds = 123.0
#'       )
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     Subtitles = list(
#'       Formats = list(
#'         "vtt"|"srt"
#'       ),
#'       SubtitleFileUris = list(
#'         "string"
#'       ),
#'       OutputStartIndex = 123
#'     ),
#'     LanguageIdSettings = list(
#'       list(
#'         VocabularyName = "string",
#'         VocabularyFilterName = "string",
#'         LanguageModelName = "string"
#'       )
#'     ),
#'     ToxicityDetection = list(
#'       list(
#'         ToxicityCategories = list(
#'           "ALL"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_transcription_job(
#'   TranscriptionJobName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   MediaSampleRateHertz = 123,
#'   MediaFormat = "mp3"|"mp4"|"wav"|"flac"|"ogg"|"amr"|"webm"|"m4a",
#'   Media = list(
#'     MediaFileUri = "string",
#'     RedactedMediaFileUri = "string"
#'   ),
#'   OutputBucketName = "string",
#'   OutputKey = "string",
#'   OutputEncryptionKMSKeyId = "string",
#'   KMSEncryptionContext = list(
#'     "string"
#'   ),
#'   Settings = list(
#'     VocabularyName = "string",
#'     ShowSpeakerLabels = TRUE|FALSE,
#'     MaxSpeakerLabels = 123,
#'     ChannelIdentification = TRUE|FALSE,
#'     ShowAlternatives = TRUE|FALSE,
#'     MaxAlternatives = 123,
#'     VocabularyFilterName = "string",
#'     VocabularyFilterMethod = "remove"|"mask"|"tag"
#'   ),
#'   ModelSettings = list(
#'     LanguageModelName = "string"
#'   ),
#'   JobExecutionSettings = list(
#'     AllowDeferredExecution = TRUE|FALSE,
#'     DataAccessRoleArn = "string"
#'   ),
#'   ContentRedaction = list(
#'     RedactionType = "PII",
#'     RedactionOutput = "redacted"|"redacted_and_unredacted",
#'     PiiEntityTypes = list(
#'       "BANK_ACCOUNT_NUMBER"|"BANK_ROUTING"|"CREDIT_DEBIT_NUMBER"|"CREDIT_DEBIT_CVV"|"CREDIT_DEBIT_EXPIRY"|"PIN"|"EMAIL"|"ADDRESS"|"NAME"|"PHONE"|"SSN"|"ALL"
#'     )
#'   ),
#'   IdentifyLanguage = TRUE|FALSE,
#'   IdentifyMultipleLanguages = TRUE|FALSE,
#'   LanguageOptions = list(
#'     "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA"
#'   ),
#'   Subtitles = list(
#'     Formats = list(
#'       "vtt"|"srt"
#'     ),
#'     OutputStartIndex = 123
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   LanguageIdSettings = list(
#'     list(
#'       VocabularyName = "string",
#'       VocabularyFilterName = "string",
#'       LanguageModelName = "string"
#'     )
#'   ),
#'   ToxicityDetection = list(
#'     list(
#'       ToxicityCategories = list(
#'         "ALL"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_start_transcription_job
#'
#' @aliases transcribeservice_start_transcription_job
transcribeservice_start_transcription_job <- function(TranscriptionJobName, LanguageCode = NULL, MediaSampleRateHertz = NULL, MediaFormat = NULL, Media, OutputBucketName = NULL, OutputKey = NULL, OutputEncryptionKMSKeyId = NULL, KMSEncryptionContext = NULL, Settings = NULL, ModelSettings = NULL, JobExecutionSettings = NULL, ContentRedaction = NULL, IdentifyLanguage = NULL, IdentifyMultipleLanguages = NULL, LanguageOptions = NULL, Subtitles = NULL, Tags = NULL, LanguageIdSettings = NULL, ToxicityDetection = NULL) {
  op <- new_operation(
    name = "StartTranscriptionJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$start_transcription_job_input(TranscriptionJobName = TranscriptionJobName, LanguageCode = LanguageCode, MediaSampleRateHertz = MediaSampleRateHertz, MediaFormat = MediaFormat, Media = Media, OutputBucketName = OutputBucketName, OutputKey = OutputKey, OutputEncryptionKMSKeyId = OutputEncryptionKMSKeyId, KMSEncryptionContext = KMSEncryptionContext, Settings = Settings, ModelSettings = ModelSettings, JobExecutionSettings = JobExecutionSettings, ContentRedaction = ContentRedaction, IdentifyLanguage = IdentifyLanguage, IdentifyMultipleLanguages = IdentifyMultipleLanguages, LanguageOptions = LanguageOptions, Subtitles = Subtitles, Tags = Tags, LanguageIdSettings = LanguageIdSettings, ToxicityDetection = ToxicityDetection)
  output <- .transcribeservice$start_transcription_job_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$start_transcription_job <- transcribeservice_start_transcription_job

#' Adds one or more custom tags, each in the form of a key:value pair, to
#' the specified resource
#'
#' @description
#' Adds one or more custom tags, each in the form of a key:value pair, to
#' the specified resource.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @usage
#' transcribeservice_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource you want to tag. ARNs
#' have the format
#' `arn:partition:service:region:account-id:resource-type/resource-id`.
#' 
#' For example,
#' `arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name`.
#' 
#' Valid values for `resource-type` are: `transcription-job`,
#' `medical-transcription-job`, `vocabulary`, `medical-vocabulary`,
#' `vocabulary-filter`, and `language-model`.
#' @param Tags &#91;required&#93; Adds one or more custom tags, each in the form of a key:value pair, to
#' the specified resource.
#' 
#' To learn more about using tags with Amazon Transcribe, refer to [Tagging
#' resources](https://docs.aws.amazon.com/transcribe/latest/dg/tagging.html).
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_tag_resource
#'
#' @aliases transcribeservice_tag_resource
transcribeservice_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .transcribeservice$tag_resource_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$tag_resource <- transcribeservice_tag_resource

#' Removes the specified tags from the specified Amazon Transcribe resource
#'
#' @description
#' Removes the specified tags from the specified Amazon Transcribe
#' resource.
#' 
#' If you include [`untag_resource`][transcribeservice_untag_resource] in
#' your request, you must also include `ResourceArn` and `TagKeys`.
#'
#' @usage
#' transcribeservice_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the Amazon Transcribe resource you
#' want to remove tags from. ARNs have the format
#' `arn:partition:service:region:account-id:resource-type/resource-id`.
#' 
#' For example,
#' `arn:aws:transcribe:us-west-2:111122223333:transcription-job/transcription-job-name`.
#' 
#' Valid values for `resource-type` are: `transcription-job`,
#' `medical-transcription-job`, `vocabulary`, `medical-vocabulary`,
#' `vocabulary-filter`, and `language-model`.
#' @param TagKeys &#91;required&#93; Removes the specified tag keys from the specified Amazon Transcribe
#' resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_untag_resource
#'
#' @aliases transcribeservice_untag_resource
transcribeservice_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .transcribeservice$untag_resource_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$untag_resource <- transcribeservice_untag_resource

#' Updates the specified Call Analytics category with new rules
#'
#' @description
#' Updates the specified Call Analytics category with new rules. Note that
#' the
#' [`update_call_analytics_category`][transcribeservice_update_call_analytics_category]
#' operation overwrites all existing rules contained in the specified
#' category. You cannot append additional rules onto an existing category.
#' 
#' To create a new category, see .
#'
#' @usage
#' transcribeservice_update_call_analytics_category(CategoryName, Rules,
#'   InputType)
#'
#' @param CategoryName &#91;required&#93; The name of the Call Analytics category you want to update. Category
#' names are case sensitive.
#' @param Rules &#91;required&#93; The rules used for the updated Call Analytics category. The rules you
#' provide in this field replace the ones that are currently being used in
#' the specified category.
#' @param InputType Choose whether you want to update a real-time or a post-call category.
#' The input type you specify must match the input type specified when the
#' category was created. For example, if you created a category with the
#' `POST_CALL` input type, you must use `POST_CALL` as the input type when
#' updating this category.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CategoryProperties = list(
#'     CategoryName = "string",
#'     Rules = list(
#'       list(
#'         NonTalkTimeFilter = list(
#'           Threshold = 123,
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         InterruptionFilter = list(
#'           Threshold = 123,
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           Negate = TRUE|FALSE
#'         ),
#'         TranscriptFilter = list(
#'           TranscriptFilterType = "EXACT",
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE,
#'           Targets = list(
#'             "string"
#'           )
#'         ),
#'         SentimentFilter = list(
#'           Sentiments = list(
#'             "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'           ),
#'           AbsoluteTimeRange = list(
#'             StartTime = 123,
#'             EndTime = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           RelativeTimeRange = list(
#'             StartPercentage = 123,
#'             EndPercentage = 123,
#'             First = 123,
#'             Last = 123
#'           ),
#'           ParticipantRole = "AGENT"|"CUSTOMER",
#'           Negate = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     InputType = "REAL_TIME"|"POST_CALL"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_call_analytics_category(
#'   CategoryName = "string",
#'   Rules = list(
#'     list(
#'       NonTalkTimeFilter = list(
#'         Threshold = 123,
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         Negate = TRUE|FALSE
#'       ),
#'       InterruptionFilter = list(
#'         Threshold = 123,
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         Negate = TRUE|FALSE
#'       ),
#'       TranscriptFilter = list(
#'         TranscriptFilterType = "EXACT",
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         Negate = TRUE|FALSE,
#'         Targets = list(
#'           "string"
#'         )
#'       ),
#'       SentimentFilter = list(
#'         Sentiments = list(
#'           "POSITIVE"|"NEGATIVE"|"NEUTRAL"|"MIXED"
#'         ),
#'         AbsoluteTimeRange = list(
#'           StartTime = 123,
#'           EndTime = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         RelativeTimeRange = list(
#'           StartPercentage = 123,
#'           EndPercentage = 123,
#'           First = 123,
#'           Last = 123
#'         ),
#'         ParticipantRole = "AGENT"|"CUSTOMER",
#'         Negate = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   InputType = "REAL_TIME"|"POST_CALL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_update_call_analytics_category
#'
#' @aliases transcribeservice_update_call_analytics_category
transcribeservice_update_call_analytics_category <- function(CategoryName, Rules, InputType = NULL) {
  op <- new_operation(
    name = "UpdateCallAnalyticsCategory",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$update_call_analytics_category_input(CategoryName = CategoryName, Rules = Rules, InputType = InputType)
  output <- .transcribeservice$update_call_analytics_category_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$update_call_analytics_category <- transcribeservice_update_call_analytics_category

#' Updates an existing custom medical vocabulary with new values
#'
#' @description
#' Updates an existing custom medical vocabulary with new values. This
#' operation overwrites all existing information with your new values; you
#' cannot append new terms onto an existing custom vocabulary.
#'
#' @usage
#' transcribeservice_update_medical_vocabulary(VocabularyName,
#'   LanguageCode, VocabularyFileUri)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom medical vocabulary you want to update. Custom
#' medical vocabulary names are case sensitive.
#' @param LanguageCode &#91;required&#93; The language code that represents the language of the entries in the
#' custom vocabulary you want to update. US English (`en-US`) is the only
#' language supported with Amazon Transcribe Medical.
#' @param VocabularyFileUri &#91;required&#93; The Amazon S3 location of the text file that contains your custom
#' medical vocabulary. The URI must be located in the same Amazon Web
#' Services Region as the resource you're calling.
#' 
#' Here's an example URI path: `s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt`
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   VocabularyState = "PENDING"|"READY"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_medical_vocabulary(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   VocabularyFileUri = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_update_medical_vocabulary
#'
#' @aliases transcribeservice_update_medical_vocabulary
transcribeservice_update_medical_vocabulary <- function(VocabularyName, LanguageCode, VocabularyFileUri) {
  op <- new_operation(
    name = "UpdateMedicalVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$update_medical_vocabulary_input(VocabularyName = VocabularyName, LanguageCode = LanguageCode, VocabularyFileUri = VocabularyFileUri)
  output <- .transcribeservice$update_medical_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$update_medical_vocabulary <- transcribeservice_update_medical_vocabulary

#' Updates an existing custom vocabulary with new values
#'
#' @description
#' Updates an existing custom vocabulary with new values. This operation
#' overwrites all existing information with your new values; you cannot
#' append new terms onto an existing custom vocabulary.
#'
#' @usage
#' transcribeservice_update_vocabulary(VocabularyName, LanguageCode,
#'   Phrases, VocabularyFileUri, DataAccessRoleArn)
#'
#' @param VocabularyName &#91;required&#93; The name of the custom vocabulary you want to update. Custom vocabulary
#' names are case sensitive.
#' @param LanguageCode &#91;required&#93; The language code that represents the language of the entries in the
#' custom vocabulary you want to update. Each custom vocabulary must
#' contain terms in only one language.
#' 
#' A custom vocabulary can only be used to transcribe files in the same
#' language as the custom vocabulary. For example, if you create a custom
#' vocabulary using US English (`en-US`), you can only apply this custom
#' vocabulary to files that contain English audio.
#' 
#' For a list of supported languages and their associated language codes,
#' refer to the [Supported
#' languages](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html)
#' table.
#' @param Phrases Use this parameter if you want to update your custom vocabulary by
#' including all desired terms, as comma-separated values, within your
#' request. The other option for updating your custom vocabulary is to save
#' your entries in a text file and upload them to an Amazon S3 bucket, then
#' specify the location of your file using the `VocabularyFileUri`
#' parameter.
#' 
#' Note that if you include `Phrases` in your request, you cannot use
#' `VocabularyFileUri`; you must choose one or the other.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary filter request fails. Refer to [Character Sets for
#' Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' @param VocabularyFileUri The Amazon S3 location of the text file that contains your custom
#' vocabulary. The URI must be located in the same Amazon Web Services
#' Region as the resource you're calling.
#' 
#' Here's an example URI path: `s3://DOC-EXAMPLE-BUCKET/my-vocab-file.txt`
#' 
#' Note that if you include `VocabularyFileUri` in your request, you cannot
#' use the `Phrases` flag; you must choose one or the other.
#' @param DataAccessRoleArn The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files (in this
#' case, your custom vocabulary). If the role that you specify doesn’t have
#' the appropriate permissions to access the specified Amazon S3 location,
#' your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   VocabularyState = "PENDING"|"READY"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_vocabulary(
#'   VocabularyName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   Phrases = list(
#'     "string"
#'   ),
#'   VocabularyFileUri = "string",
#'   DataAccessRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_update_vocabulary
#'
#' @aliases transcribeservice_update_vocabulary
transcribeservice_update_vocabulary <- function(VocabularyName, LanguageCode, Phrases = NULL, VocabularyFileUri = NULL, DataAccessRoleArn = NULL) {
  op <- new_operation(
    name = "UpdateVocabulary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$update_vocabulary_input(VocabularyName = VocabularyName, LanguageCode = LanguageCode, Phrases = Phrases, VocabularyFileUri = VocabularyFileUri, DataAccessRoleArn = DataAccessRoleArn)
  output <- .transcribeservice$update_vocabulary_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$update_vocabulary <- transcribeservice_update_vocabulary

#' Updates an existing custom vocabulary filter with a new list of words
#'
#' @description
#' Updates an existing custom vocabulary filter with a new list of words.
#' The new list you provide overwrites all previous entries; you cannot
#' append new terms onto an existing custom vocabulary filter.
#'
#' @usage
#' transcribeservice_update_vocabulary_filter(VocabularyFilterName, Words,
#'   VocabularyFilterFileUri, DataAccessRoleArn)
#'
#' @param VocabularyFilterName &#91;required&#93; The name of the custom vocabulary filter you want to update. Custom
#' vocabulary filter names are case sensitive.
#' @param Words Use this parameter if you want to update your custom vocabulary filter
#' by including all desired terms, as comma-separated values, within your
#' request. The other option for updating your vocabulary filter is to save
#' your entries in a text file and upload them to an Amazon S3 bucket, then
#' specify the location of your file using the `VocabularyFilterFileUri`
#' parameter.
#' 
#' Note that if you include `Words` in your request, you cannot use
#' `VocabularyFilterFileUri`; you must choose one or the other.
#' 
#' Each language has a character set that contains all allowed characters
#' for that specific language. If you use unsupported characters, your
#' custom vocabulary filter request fails. Refer to [Character Sets for
#' Custom
#' Vocabularies](https://docs.aws.amazon.com/transcribe/latest/dg/charsets.html)
#' to get the character set for your language.
#' @param VocabularyFilterFileUri The Amazon S3 location of the text file that contains your custom
#' vocabulary filter terms. The URI must be located in the same Amazon Web
#' Services Region as the resource you're calling.
#' 
#' Here's an example URI path:
#' `s3://DOC-EXAMPLE-BUCKET/my-vocab-filter-file.txt`
#' 
#' Note that if you include `VocabularyFilterFileUri` in your request, you
#' cannot use `Words`; you must choose one or the other.
#' @param DataAccessRoleArn The Amazon Resource Name (ARN) of an IAM role that has permissions to
#' access the Amazon S3 bucket that contains your input files (in this
#' case, your custom vocabulary filter). If the role that you specify
#' doesn’t have the appropriate permissions to access the specified Amazon
#' S3 location, your request fails.
#' 
#' IAM role ARNs have the format
#' `arn:partition:iam::account:role/role-name-with-path`. For example:
#' `arn:aws:iam::111122223333:role/Admin`.
#' 
#' For more information, see [IAM
#' ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VocabularyFilterName = "string",
#'   LanguageCode = "af-ZA"|"ar-AE"|"ar-SA"|"da-DK"|"de-CH"|"de-DE"|"en-AB"|"en-AU"|"en-GB"|"en-IE"|"en-IN"|"en-US"|"en-WL"|"es-ES"|"es-US"|"fa-IR"|"fr-CA"|"fr-FR"|"he-IL"|"hi-IN"|"id-ID"|"it-IT"|"ja-JP"|"ko-KR"|"ms-MY"|"nl-NL"|"pt-BR"|"pt-PT"|"ru-RU"|"ta-IN"|"te-IN"|"tr-TR"|"zh-CN"|"zh-TW"|"th-TH"|"en-ZA"|"en-NZ"|"vi-VN"|"sv-SE"|"ab-GE"|"ast-ES"|"az-AZ"|"ba-RU"|"be-BY"|"bg-BG"|"bn-IN"|"bs-BA"|"ca-ES"|"ckb-IQ"|"ckb-IR"|"cs-CZ"|"cy-WL"|"el-GR"|"et-EE"|"et-ET"|"eu-ES"|"fi-FI"|"gl-ES"|"gu-IN"|"ha-NG"|"hr-HR"|"hu-HU"|"hy-AM"|"is-IS"|"ka-GE"|"kab-DZ"|"kk-KZ"|"kn-IN"|"ky-KG"|"lg-IN"|"lt-LT"|"lv-LV"|"mhr-RU"|"mi-NZ"|"mk-MK"|"ml-IN"|"mn-MN"|"mr-IN"|"mt-MT"|"no-NO"|"or-IN"|"pa-IN"|"pl-PL"|"ps-AF"|"ro-RO"|"rw-RW"|"si-LK"|"sk-SK"|"sl-SI"|"so-SO"|"sr-RS"|"su-ID"|"sw-BI"|"sw-KE"|"sw-RW"|"sw-TZ"|"sw-UG"|"tl-PH"|"tt-RU"|"ug-CN"|"uk-UA"|"uz-UZ"|"wo-SN"|"zh-HK"|"zu-ZA",
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_vocabulary_filter(
#'   VocabularyFilterName = "string",
#'   Words = list(
#'     "string"
#'   ),
#'   VocabularyFilterFileUri = "string",
#'   DataAccessRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname transcribeservice_update_vocabulary_filter
#'
#' @aliases transcribeservice_update_vocabulary_filter
transcribeservice_update_vocabulary_filter <- function(VocabularyFilterName, Words = NULL, VocabularyFilterFileUri = NULL, DataAccessRoleArn = NULL) {
  op <- new_operation(
    name = "UpdateVocabularyFilter",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .transcribeservice$update_vocabulary_filter_input(VocabularyFilterName = VocabularyFilterName, Words = Words, VocabularyFilterFileUri = VocabularyFilterFileUri, DataAccessRoleArn = DataAccessRoleArn)
  output <- .transcribeservice$update_vocabulary_filter_output()
  config <- get_config()
  svc <- .transcribeservice$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.transcribeservice$operations$update_vocabulary_filter <- transcribeservice_update_vocabulary_filter

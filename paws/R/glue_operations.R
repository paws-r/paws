# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include glue_service.R
NULL

#' Creates one or more partitions in a batch operation
#'
#' @description
#' Creates one or more partitions in a batch operation.
#'
#' @usage
#' glue_batch_create_partition(CatalogId, DatabaseName, TableName,
#'   PartitionInputList)
#'
#' @param CatalogId The ID of the catalog in which the partition is to be created.
#' Currently, this should be the Amazon Web Services account ID.
#' @param DatabaseName &#91;required&#93; The name of the metadata database in which the partition is to be
#' created.
#' @param TableName &#91;required&#93; The name of the metadata table in which the partition is to be created.
#' @param PartitionInputList &#91;required&#93; A list of `PartitionInput` structures that define the partitions to be
#' created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       PartitionValues = list(
#'         "string"
#'       ),
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_create_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionInputList = list(
#'     list(
#'       Values = list(
#'         "string"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_create_partition
#'
#' @aliases glue_batch_create_partition
glue_batch_create_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionInputList) {
  op <- new_operation(
    name = "BatchCreatePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_create_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionInputList = PartitionInputList)
  output <- .glue$batch_create_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_create_partition <- glue_batch_create_partition

#' Deletes a list of connection definitions from the Data Catalog
#'
#' @description
#' Deletes a list of connection definitions from the Data Catalog.
#'
#' @usage
#' glue_batch_delete_connection(CatalogId, ConnectionNameList)
#'
#' @param CatalogId The ID of the Data Catalog in which the connections reside. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param ConnectionNameList &#91;required&#93; A list of names of the connections to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Succeeded = list(
#'     "string"
#'   ),
#'   Errors = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_connection(
#'   CatalogId = "string",
#'   ConnectionNameList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_delete_connection
#'
#' @aliases glue_batch_delete_connection
glue_batch_delete_connection <- function(CatalogId = NULL, ConnectionNameList) {
  op <- new_operation(
    name = "BatchDeleteConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_delete_connection_input(CatalogId = CatalogId, ConnectionNameList = ConnectionNameList)
  output <- .glue$batch_delete_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_delete_connection <- glue_batch_delete_connection

#' Deletes one or more partitions in a batch operation
#'
#' @description
#' Deletes one or more partitions in a batch operation.
#'
#' @usage
#' glue_batch_delete_partition(CatalogId, DatabaseName, TableName,
#'   PartitionsToDelete)
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be deleted resides. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table that contains the partitions to be deleted.
#' @param PartitionsToDelete &#91;required&#93; A list of `PartitionInput` structures that define the partitions to be
#' deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       PartitionValues = list(
#'         "string"
#'       ),
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionsToDelete = list(
#'     list(
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_delete_partition
#'
#' @aliases glue_batch_delete_partition
glue_batch_delete_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionsToDelete) {
  op <- new_operation(
    name = "BatchDeletePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_delete_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionsToDelete = PartitionsToDelete)
  output <- .glue$batch_delete_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_delete_partition <- glue_batch_delete_partition

#' Deletes multiple tables at once
#'
#' @description
#' Deletes multiple tables at once.
#' 
#' After completing this operation, you no longer have access to the table
#' versions and partitions that belong to the deleted table. Glue deletes
#' these "orphaned" resources asynchronously in a timely manner, at the
#' discretion of the service.
#' 
#' To ensure the immediate deletion of all related resources, before
#' calling [`batch_delete_table`][glue_batch_delete_table], use
#' [`delete_table_version`][glue_delete_table_version] or
#' [`batch_delete_table_version`][glue_batch_delete_table_version], and
#' [`delete_partition`][glue_delete_partition] or
#' [`batch_delete_partition`][glue_batch_delete_partition], to delete any
#' resources that belong to the table.
#'
#' @usage
#' glue_batch_delete_table(CatalogId, DatabaseName, TablesToDelete,
#'   TransactionId)
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the tables to delete reside.
#' For Hive compatibility, this name is entirely lowercase.
#' @param TablesToDelete &#91;required&#93; A list of the table to delete.
#' @param TransactionId The transaction ID at which to delete the table contents.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       TableName = "string",
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TablesToDelete = list(
#'     "string"
#'   ),
#'   TransactionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_delete_table
#'
#' @aliases glue_batch_delete_table
glue_batch_delete_table <- function(CatalogId = NULL, DatabaseName, TablesToDelete, TransactionId = NULL) {
  op <- new_operation(
    name = "BatchDeleteTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_delete_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TablesToDelete = TablesToDelete, TransactionId = TransactionId)
  output <- .glue$batch_delete_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_delete_table <- glue_batch_delete_table

#' Deletes a specified batch of versions of a table
#'
#' @description
#' Deletes a specified batch of versions of a table.
#'
#' @usage
#' glue_batch_delete_table_version(CatalogId, DatabaseName, TableName,
#'   VersionIds)
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely
#' lowercase.
#' @param VersionIds &#91;required&#93; A list of the IDs of versions to be deleted. A `VersionId` is a string
#' representation of an integer. Each version is incremented by 1.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       TableName = "string",
#'       VersionId = "string",
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_delete_table_version
#'
#' @aliases glue_batch_delete_table_version
glue_batch_delete_table_version <- function(CatalogId = NULL, DatabaseName, TableName, VersionIds) {
  op <- new_operation(
    name = "BatchDeleteTableVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_delete_table_version_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, VersionIds = VersionIds)
  output <- .glue$batch_delete_table_version_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_delete_table_version <- glue_batch_delete_table_version

#' Retrieves information about a list of blueprints
#'
#' @description
#' Retrieves information about a list of blueprints.
#'
#' @usage
#' glue_batch_get_blueprints(Names, IncludeBlueprint, IncludeParameterSpec)
#'
#' @param Names &#91;required&#93; A list of blueprint names.
#' @param IncludeBlueprint Specifies whether or not to include the blueprint in the response.
#' @param IncludeParameterSpec Specifies whether or not to include the parameters, as a JSON string,
#' for the blueprint in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Blueprints = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ParameterSpec = "string",
#'       BlueprintLocation = "string",
#'       BlueprintServiceLocation = "string",
#'       Status = "CREATING"|"ACTIVE"|"UPDATING"|"FAILED",
#'       ErrorMessage = "string",
#'       LastActiveDefinition = list(
#'         Description = "string",
#'         LastModifiedOn = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ParameterSpec = "string",
#'         BlueprintLocation = "string",
#'         BlueprintServiceLocation = "string"
#'       )
#'     )
#'   ),
#'   MissingBlueprints = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_blueprints(
#'   Names = list(
#'     "string"
#'   ),
#'   IncludeBlueprint = TRUE|FALSE,
#'   IncludeParameterSpec = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_blueprints
#'
#' @aliases glue_batch_get_blueprints
glue_batch_get_blueprints <- function(Names, IncludeBlueprint = NULL, IncludeParameterSpec = NULL) {
  op <- new_operation(
    name = "BatchGetBlueprints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_blueprints_input(Names = Names, IncludeBlueprint = IncludeBlueprint, IncludeParameterSpec = IncludeParameterSpec)
  output <- .glue$batch_get_blueprints_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_blueprints <- glue_batch_get_blueprints

#' Returns a list of resource metadata for a given list of crawler names
#'
#' @description
#' Returns a list of resource metadata for a given list of crawler names.
#' After calling the [`list_crawlers`][glue_list_crawlers] operation, you
#' can call this operation to access the data to which you have been
#' granted permissions. This operation supports all IAM permissions,
#' including permission conditions that uses tags.
#'
#' @usage
#' glue_batch_get_crawlers(CrawlerNames)
#'
#' @param CrawlerNames &#91;required&#93; A list of crawler names, which might be the names returned from the
#' [`list_crawlers`][glue_list_crawlers] operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Crawlers = list(
#'     list(
#'       Name = "string",
#'       Role = "string",
#'       Targets = list(
#'         S3Targets = list(
#'           list(
#'             Path = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             SampleSize = 123,
#'             EventQueueArn = "string",
#'             DlqEventQueueArn = "string"
#'           )
#'         ),
#'         JdbcTargets = list(
#'           list(
#'             ConnectionName = "string",
#'             Path = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             EnableAdditionalMetadata = list(
#'               "COMMENTS"|"RAWTYPES"
#'             )
#'           )
#'         ),
#'         MongoDBTargets = list(
#'           list(
#'             ConnectionName = "string",
#'             Path = "string",
#'             ScanAll = TRUE|FALSE
#'           )
#'         ),
#'         DynamoDBTargets = list(
#'           list(
#'             Path = "string",
#'             scanAll = TRUE|FALSE,
#'             scanRate = 123.0
#'           )
#'         ),
#'         CatalogTargets = list(
#'           list(
#'             DatabaseName = "string",
#'             Tables = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             EventQueueArn = "string",
#'             DlqEventQueueArn = "string"
#'           )
#'         ),
#'         DeltaTargets = list(
#'           list(
#'             DeltaTables = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             WriteManifest = TRUE|FALSE,
#'             CreateNativeDeltaTable = TRUE|FALSE
#'           )
#'         ),
#'         IcebergTargets = list(
#'           list(
#'             Paths = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             MaximumTraversalDepth = 123
#'           )
#'         ),
#'         HudiTargets = list(
#'           list(
#'             Paths = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             MaximumTraversalDepth = 123
#'           )
#'         )
#'       ),
#'       DatabaseName = "string",
#'       Description = "string",
#'       Classifiers = list(
#'         "string"
#'       ),
#'       RecrawlPolicy = list(
#'         RecrawlBehavior = "CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"
#'       ),
#'       SchemaChangePolicy = list(
#'         UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'         DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'       ),
#'       LineageConfiguration = list(
#'         CrawlerLineageSettings = "ENABLE"|"DISABLE"
#'       ),
#'       State = "READY"|"RUNNING"|"STOPPING",
#'       TablePrefix = "string",
#'       Schedule = list(
#'         ScheduleExpression = "string",
#'         State = "SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"
#'       ),
#'       CrawlElapsedTime = 123,
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastCrawl = list(
#'         Status = "SUCCEEDED"|"CANCELLED"|"FAILED",
#'         ErrorMessage = "string",
#'         LogGroup = "string",
#'         LogStream = "string",
#'         MessagePrefix = "string",
#'         StartTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       Version = 123,
#'       Configuration = "string",
#'       CrawlerSecurityConfiguration = "string",
#'       LakeFormationConfiguration = list(
#'         UseLakeFormationCredentials = TRUE|FALSE,
#'         AccountId = "string"
#'       )
#'     )
#'   ),
#'   CrawlersNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_crawlers(
#'   CrawlerNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_crawlers
#'
#' @aliases glue_batch_get_crawlers
glue_batch_get_crawlers <- function(CrawlerNames) {
  op <- new_operation(
    name = "BatchGetCrawlers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_crawlers_input(CrawlerNames = CrawlerNames)
  output <- .glue$batch_get_crawlers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_crawlers <- glue_batch_get_crawlers

#' Retrieves the details for the custom patterns specified by a list of
#' names
#'
#' @description
#' Retrieves the details for the custom patterns specified by a list of
#' names.
#'
#' @usage
#' glue_batch_get_custom_entity_types(Names)
#'
#' @param Names &#91;required&#93; A list of names of the custom patterns that you want to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CustomEntityTypes = list(
#'     list(
#'       Name = "string",
#'       RegexString = "string",
#'       ContextWords = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   CustomEntityTypesNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_custom_entity_types(
#'   Names = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_custom_entity_types
#'
#' @aliases glue_batch_get_custom_entity_types
glue_batch_get_custom_entity_types <- function(Names) {
  op <- new_operation(
    name = "BatchGetCustomEntityTypes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_custom_entity_types_input(Names = Names)
  output <- .glue$batch_get_custom_entity_types_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_custom_entity_types <- glue_batch_get_custom_entity_types

#' Retrieves a list of data quality results for the specified result IDs
#'
#' @description
#' Retrieves a list of data quality results for the specified result IDs.
#'
#' @usage
#' glue_batch_get_data_quality_result(ResultIds)
#'
#' @param ResultIds &#91;required&#93; A list of unique result IDs for the data quality results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Results = list(
#'     list(
#'       ResultId = "string",
#'       ProfileId = "string",
#'       Score = 123.0,
#'       DataSource = list(
#'         GlueTable = list(
#'           DatabaseName = "string",
#'           TableName = "string",
#'           CatalogId = "string",
#'           ConnectionName = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       RulesetName = "string",
#'       EvaluationContext = "string",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       JobName = "string",
#'       JobRunId = "string",
#'       RulesetEvaluationRunId = "string",
#'       RuleResults = list(
#'         list(
#'           Name = "string",
#'           Description = "string",
#'           EvaluationMessage = "string",
#'           Result = "PASS"|"FAIL"|"ERROR",
#'           EvaluatedMetrics = list(
#'             123.0
#'           ),
#'           EvaluatedRule = "string"
#'         )
#'       ),
#'       AnalyzerResults = list(
#'         list(
#'           Name = "string",
#'           Description = "string",
#'           EvaluationMessage = "string",
#'           EvaluatedMetrics = list(
#'             123.0
#'           )
#'         )
#'       ),
#'       Observations = list(
#'         list(
#'           Description = "string",
#'           MetricBasedObservation = list(
#'             MetricName = "string",
#'             StatisticId = "string",
#'             MetricValues = list(
#'               ActualValue = 123.0,
#'               ExpectedValue = 123.0,
#'               LowerLimit = 123.0,
#'               UpperLimit = 123.0
#'             ),
#'             NewRules = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ResultsNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_data_quality_result(
#'   ResultIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_data_quality_result
#'
#' @aliases glue_batch_get_data_quality_result
glue_batch_get_data_quality_result <- function(ResultIds) {
  op <- new_operation(
    name = "BatchGetDataQualityResult",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_data_quality_result_input(ResultIds = ResultIds)
  output <- .glue$batch_get_data_quality_result_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_data_quality_result <- glue_batch_get_data_quality_result

#' Returns a list of resource metadata for a given list of development
#' endpoint names
#'
#' @description
#' Returns a list of resource metadata for a given list of development
#' endpoint names. After calling the
#' [`list_dev_endpoints`][glue_list_dev_endpoints] operation, you can call
#' this operation to access the data to which you have been granted
#' permissions. This operation supports all IAM permissions, including
#' permission conditions that uses tags.
#'
#' @usage
#' glue_batch_get_dev_endpoints(DevEndpointNames)
#'
#' @param DevEndpointNames &#91;required&#93; The list of `DevEndpoint` names, which might be the names returned from
#' the `ListDevEndpoint` operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DevEndpoints = list(
#'     list(
#'       EndpointName = "string",
#'       RoleArn = "string",
#'       SecurityGroupIds = list(
#'         "string"
#'       ),
#'       SubnetId = "string",
#'       YarnEndpointAddress = "string",
#'       PrivateAddress = "string",
#'       ZeppelinRemoteSparkInterpreterPort = 123,
#'       PublicAddress = "string",
#'       Status = "string",
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       GlueVersion = "string",
#'       NumberOfWorkers = 123,
#'       NumberOfNodes = 123,
#'       AvailabilityZone = "string",
#'       VpcId = "string",
#'       ExtraPythonLibsS3Path = "string",
#'       ExtraJarsS3Path = "string",
#'       FailureReason = "string",
#'       LastUpdateStatus = "string",
#'       CreatedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       PublicKey = "string",
#'       PublicKeys = list(
#'         "string"
#'       ),
#'       SecurityConfiguration = "string",
#'       Arguments = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   DevEndpointsNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_dev_endpoints(
#'   DevEndpointNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_dev_endpoints
#'
#' @aliases glue_batch_get_dev_endpoints
glue_batch_get_dev_endpoints <- function(DevEndpointNames) {
  op <- new_operation(
    name = "BatchGetDevEndpoints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_dev_endpoints_input(DevEndpointNames = DevEndpointNames)
  output <- .glue$batch_get_dev_endpoints_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_dev_endpoints <- glue_batch_get_dev_endpoints

#' Returns a list of resource metadata for a given list of job names
#'
#' @description
#' Returns a list of resource metadata for a given list of job names. After
#' calling the [`list_jobs`][glue_list_jobs] operation, you can call this
#' operation to access the data to which you have been granted permissions.
#' This operation supports all IAM permissions, including permission
#' conditions that uses tags.
#'
#' @usage
#' glue_batch_get_jobs(JobNames)
#'
#' @param JobNames &#91;required&#93; A list of job names, which might be the names returned from the
#' [`list_jobs`][glue_list_jobs] operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Jobs = list(
#'     list(
#'       Name = "string",
#'       JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'       JobRunQueuingEnabled = TRUE|FALSE,
#'       Description = "string",
#'       LogUri = "string",
#'       Role = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExecutionProperty = list(
#'         MaxConcurrentRuns = 123
#'       ),
#'       Command = list(
#'         Name = "string",
#'         ScriptLocation = "string",
#'         PythonVersion = "string",
#'         Runtime = "string"
#'       ),
#'       DefaultArguments = list(
#'         "string"
#'       ),
#'       NonOverridableArguments = list(
#'         "string"
#'       ),
#'       Connections = list(
#'         Connections = list(
#'           "string"
#'         )
#'       ),
#'       MaxRetries = 123,
#'       AllocatedCapacity = 123,
#'       Timeout = 123,
#'       MaxCapacity = 123.0,
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       NumberOfWorkers = 123,
#'       SecurityConfiguration = "string",
#'       NotificationProperty = list(
#'         NotifyDelayAfter = 123
#'       ),
#'       GlueVersion = "string",
#'       CodeGenConfigurationNodes = list(
#'         list(
#'           AthenaConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             ConnectionTable = "string",
#'             SchemaName = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           JDBCConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               FilterPredicate = "string",
#'               PartitionColumn = "string",
#'               LowerBound = 123,
#'               UpperBound = 123,
#'               NumPartitions = 123,
#'               JobBookmarkKeys = list(
#'                 "string"
#'               ),
#'               JobBookmarkKeysSortOrder = "string",
#'               DataTypeMapping = list(
#'                 "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE"
#'               )
#'             ),
#'             ConnectionTable = "string",
#'             Query = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           RedshiftSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             RedshiftTmpDir = "string",
#'             TmpDirIAMRole = "string"
#'           ),
#'           S3CatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             PartitionPredicate = "string",
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123
#'             )
#'           ),
#'           S3CsvSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "gzip"|"bzip2",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             Separator = "comma"|"ctrla"|"pipe"|"semicolon"|"tab",
#'             Escaper = "string",
#'             QuoteChar = "quote"|"quillemet"|"single_quote"|"disabled",
#'             Multiline = TRUE|FALSE,
#'             WithHeader = TRUE|FALSE,
#'             WriteHeader = TRUE|FALSE,
#'             SkipFirst = TRUE|FALSE,
#'             OptimizePerformance = TRUE|FALSE,
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3JsonSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "gzip"|"bzip2",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             JsonPath = "string",
#'             Multiline = TRUE|FALSE,
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3ParquetSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           RelationalCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           DynamoDBCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           JDBCConnectorTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             ConnectionTable = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkConnectorTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           RedshiftTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string",
#'             RedshiftTmpDir = "string",
#'             TmpDirIAMRole = "string",
#'             UpsertRedshiftOptions = list(
#'               TableLocation = "string",
#'               ConnectionName = "string",
#'               UpsertKeys = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           S3CatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3GlueParquetTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           S3DirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "string",
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           ApplyMapping = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Mapping = list(
#'               list(
#'                 ToKey = "string",
#'                 FromPath = list(
#'                   "string"
#'                 ),
#'                 FromType = "string",
#'                 ToType = "string",
#'                 Dropped = TRUE|FALSE,
#'                 Children = list()
#'               )
#'             )
#'           ),
#'           SelectFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           DropFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           RenameField = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             SourcePath = list(
#'               "string"
#'             ),
#'             TargetPath = list(
#'               "string"
#'             )
#'           ),
#'           Spigot = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Path = "string",
#'             Topk = 123,
#'             Prob = 123.0
#'           ),
#'           Join = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             JoinType = "equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti",
#'             Columns = list(
#'               list(
#'                 From = "string",
#'                 Keys = list(
#'                   list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SplitFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           SelectFromCollection = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Index = 123
#'           ),
#'           FillMissingValues = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ImputedPath = "string",
#'             FilledPath = "string"
#'           ),
#'           Filter = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             LogicalOperator = "AND"|"OR",
#'             Filters = list(
#'               list(
#'                 Operation = "EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL",
#'                 Negated = TRUE|FALSE,
#'                 Values = list(
#'                   list(
#'                     Type = "COLUMNEXTRACTED"|"CONSTANT",
#'                     Value = list(
#'                       "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CustomCode = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Code = "string",
#'             ClassName = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkSQL = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             SqlQuery = "string",
#'             SqlAliases = list(
#'               list(
#'                 From = "string",
#'                 Alias = "string"
#'               )
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           DirectKinesisSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             StreamingOptions = list(
#'               EndpointUrl = "string",
#'               StreamName = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'               MaxFetchTimeInMs = 123,
#'               MaxFetchRecordsPerShard = 123,
#'               MaxRecordPerRead = 123,
#'               AddIdleTimeBetweenReads = TRUE|FALSE,
#'               IdleTimeBetweenReadsInMs = 123,
#'               DescribeShardInterval = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxRetryIntervalMs = 123,
#'               AvoidEmptyBatches = TRUE|FALSE,
#'               StreamArn = "string",
#'               RoleArn = "string",
#'               RoleSessionName = "string",
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           DirectKafkaSource = list(
#'             Name = "string",
#'             StreamingOptions = list(
#'               BootstrapServers = "string",
#'               SecurityProtocol = "string",
#'               ConnectionName = "string",
#'               TopicName = "string",
#'               Assign = "string",
#'               SubscribePattern = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingOffsets = "string",
#'               EndingOffsets = "string",
#'               PollTimeoutMs = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxOffsetsPerTrigger = 123,
#'               MinPartitions = 123,
#'               IncludeHeaders = TRUE|FALSE,
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           CatalogKinesisSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             Table = "string",
#'             Database = "string",
#'             StreamingOptions = list(
#'               EndpointUrl = "string",
#'               StreamName = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'               MaxFetchTimeInMs = 123,
#'               MaxFetchRecordsPerShard = 123,
#'               MaxRecordPerRead = 123,
#'               AddIdleTimeBetweenReads = TRUE|FALSE,
#'               IdleTimeBetweenReadsInMs = 123,
#'               DescribeShardInterval = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxRetryIntervalMs = 123,
#'               AvoidEmptyBatches = TRUE|FALSE,
#'               StreamArn = "string",
#'               RoleArn = "string",
#'               RoleSessionName = "string",
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           CatalogKafkaSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             Table = "string",
#'             Database = "string",
#'             StreamingOptions = list(
#'               BootstrapServers = "string",
#'               SecurityProtocol = "string",
#'               ConnectionName = "string",
#'               TopicName = "string",
#'               Assign = "string",
#'               SubscribePattern = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingOffsets = "string",
#'               EndingOffsets = "string",
#'               PollTimeoutMs = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxOffsetsPerTrigger = 123,
#'               MinPartitions = 123,
#'               IncludeHeaders = TRUE|FALSE,
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           DropNullFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             NullCheckBoxList = list(
#'               IsEmpty = TRUE|FALSE,
#'               IsNullString = TRUE|FALSE,
#'               IsNegOne = TRUE|FALSE
#'             ),
#'             NullTextList = list(
#'               list(
#'                 Value = "string",
#'                 Datatype = list(
#'                   Id = "string",
#'                   Label = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           Merge = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Source = "string",
#'             PrimaryKeys = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           Union = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             UnionType = "ALL"|"DISTINCT"
#'           ),
#'           PIIDetection = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PiiType = "RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking",
#'             EntityTypesToDetect = list(
#'               "string"
#'             ),
#'             OutputColumnName = "string",
#'             SampleFraction = 123.0,
#'             ThresholdFraction = 123.0,
#'             MaskValue = "string"
#'           ),
#'           Aggregate = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Groups = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Aggs = list(
#'               list(
#'                 Column = list(
#'                   "string"
#'                 ),
#'                 AggFunc = "avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"
#'               )
#'             )
#'           ),
#'           DropDuplicates = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Columns = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           GovernedCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           GovernedCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             PartitionPredicate = "string",
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123
#'             )
#'           ),
#'           MicrosoftSQLServerCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MySQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           OracleSQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           PostgreSQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MicrosoftSQLServerCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MySQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           OracleSQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           PostgreSQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           DynamicTransform = list(
#'             Name = "string",
#'             TransformName = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Parameters = list(
#'               list(
#'                 Name = "string",
#'                 Type = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'                 ValidationRule = "string",
#'                 ValidationMessage = "string",
#'                 Value = list(
#'                   "string"
#'                 ),
#'                 ListType = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'                 IsOptional = TRUE|FALSE
#'               )
#'             ),
#'             FunctionName = "string",
#'             Path = "string",
#'             Version = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           EvaluateDataQuality = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Ruleset = "string",
#'             Output = "PrimaryInput"|"EvaluationResults",
#'             PublishingOptions = list(
#'               EvaluationContext = "string",
#'               ResultsS3Prefix = "string",
#'               CloudWatchMetricsEnabled = TRUE|FALSE,
#'               ResultsPublishingEnabled = TRUE|FALSE
#'             ),
#'             StopJobOnFailureOptions = list(
#'               StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'             )
#'           ),
#'           S3CatalogHudiSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogHudiSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3HudiSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3HudiCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3HudiDirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Path = "string",
#'             Compression = "gzip"|"lzo"|"uncompressed"|"snappy",
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           DirectJDBCSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             ConnectionName = "string",
#'             ConnectionType = "sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift",
#'             RedshiftTmpDir = "string"
#'           ),
#'           S3CatalogDeltaSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogDeltaSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3DeltaSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3DeltaCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3DeltaDirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "uncompressed"|"snappy",
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           AmazonRedshiftSource = list(
#'             Name = "string",
#'             Data = list(
#'               AccessType = "string",
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Table = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogDatabase = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogTable = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogRedshiftSchema = "string",
#'               CatalogRedshiftTable = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdvancedOptions = list(
#'                 list(
#'                   Key = "string",
#'                   Value = "string"
#'                 )
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               TablePrefix = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               CrawlerConnection = "string",
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           AmazonRedshiftTarget = list(
#'             Name = "string",
#'             Data = list(
#'               AccessType = "string",
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Table = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogDatabase = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogTable = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogRedshiftSchema = "string",
#'               CatalogRedshiftTable = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdvancedOptions = list(
#'                 list(
#'                   Key = "string",
#'                   Value = "string"
#'                 )
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               TablePrefix = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               CrawlerConnection = "string",
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           ),
#'           EvaluateDataQualityMultiFrame = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             AdditionalDataSources = list(
#'               "string"
#'             ),
#'             Ruleset = "string",
#'             PublishingOptions = list(
#'               EvaluationContext = "string",
#'               ResultsS3Prefix = "string",
#'               CloudWatchMetricsEnabled = TRUE|FALSE,
#'               ResultsPublishingEnabled = TRUE|FALSE
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             StopJobOnFailureOptions = list(
#'               StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'             )
#'           ),
#'           Recipe = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             RecipeReference = list(
#'               RecipeArn = "string",
#'               RecipeVersion = "string"
#'             ),
#'             RecipeSteps = list(
#'               list(
#'                 Action = list(
#'                   Operation = "string",
#'                   Parameters = list(
#'                     "string"
#'                   )
#'                 ),
#'                 ConditionExpressions = list(
#'                   list(
#'                     Condition = "string",
#'                     Value = "string",
#'                     TargetColumn = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SnowflakeSource = list(
#'             Name = "string",
#'             Data = list(
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = "string",
#'               Table = "string",
#'               Database = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdditionalOptions = list(
#'                 "string"
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               AutoPushdown = TRUE|FALSE,
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SnowflakeTarget = list(
#'             Name = "string",
#'             Data = list(
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = "string",
#'               Table = "string",
#'               Database = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdditionalOptions = list(
#'                 "string"
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               AutoPushdown = TRUE|FALSE,
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           ),
#'           ConnectorDataSource = list(
#'             Name = "string",
#'             ConnectionType = "string",
#'             Data = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           ConnectorDataTarget = list(
#'             Name = "string",
#'             ConnectionType = "string",
#'             Data = list(
#'               "string"
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           )
#'         )
#'       ),
#'       ExecutionClass = "FLEX"|"STANDARD",
#'       SourceControlDetails = list(
#'         Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'         Repository = "string",
#'         Owner = "string",
#'         Branch = "string",
#'         Folder = "string",
#'         LastCommitId = "string",
#'         AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'         AuthToken = "string"
#'       ),
#'       MaintenanceWindow = "string",
#'       ProfileName = "string"
#'     )
#'   ),
#'   JobsNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_jobs(
#'   JobNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_jobs
#'
#' @aliases glue_batch_get_jobs
glue_batch_get_jobs <- function(JobNames) {
  op <- new_operation(
    name = "BatchGetJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_jobs_input(JobNames = JobNames)
  output <- .glue$batch_get_jobs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_jobs <- glue_batch_get_jobs

#' Retrieves partitions in a batch request
#'
#' @description
#' Retrieves partitions in a batch request.
#'
#' @usage
#' glue_batch_get_partition(CatalogId, DatabaseName, TableName,
#'   PartitionsToGet)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param PartitionsToGet &#91;required&#93; A list of partition values identifying the partitions to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Partitions = list(
#'     list(
#'       Values = list(
#'         "string"
#'       ),
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CatalogId = "string"
#'     )
#'   ),
#'   UnprocessedKeys = list(
#'     list(
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionsToGet = list(
#'     list(
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_partition
#'
#' @aliases glue_batch_get_partition
glue_batch_get_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionsToGet) {
  op <- new_operation(
    name = "BatchGetPartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionsToGet = PartitionsToGet)
  output <- .glue$batch_get_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_partition <- glue_batch_get_partition

#' Returns the configuration for the specified table optimizers
#'
#' @description
#' Returns the configuration for the specified table optimizers.
#'
#' @usage
#' glue_batch_get_table_optimizer(Entries)
#'
#' @param Entries &#91;required&#93; A list of `BatchGetTableOptimizerEntry` objects specifying the table
#' optimizers to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableOptimizers = list(
#'     list(
#'       catalogId = "string",
#'       databaseName = "string",
#'       tableName = "string",
#'       tableOptimizer = list(
#'         type = "compaction"|"retention"|"orphan_file_deletion",
#'         configuration = list(
#'           roleArn = "string",
#'           enabled = TRUE|FALSE,
#'           vpcConfiguration = list(
#'             glueConnectionName = "string"
#'           ),
#'           retentionConfiguration = list(
#'             icebergConfiguration = list(
#'               snapshotRetentionPeriodInDays = 123,
#'               numberOfSnapshotsToRetain = 123,
#'               cleanExpiredFiles = TRUE|FALSE
#'             )
#'           ),
#'           orphanFileDeletionConfiguration = list(
#'             icebergConfiguration = list(
#'               orphanFileRetentionPeriodInDays = 123,
#'               location = "string"
#'             )
#'           )
#'         ),
#'         lastRun = list(
#'           eventType = "starting"|"completed"|"failed"|"in_progress",
#'           startTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           endTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           metrics = list(
#'             NumberOfBytesCompacted = "string",
#'             NumberOfFilesCompacted = "string",
#'             NumberOfDpus = "string",
#'             JobDurationInHour = "string"
#'           ),
#'           error = "string",
#'           compactionMetrics = list(
#'             IcebergMetrics = list(
#'               NumberOfBytesCompacted = 123,
#'               NumberOfFilesCompacted = 123,
#'               NumberOfDpus = 123,
#'               JobDurationInHour = 123.0
#'             )
#'           ),
#'           retentionMetrics = list(
#'             IcebergMetrics = list(
#'               NumberOfDataFilesDeleted = 123,
#'               NumberOfManifestFilesDeleted = 123,
#'               NumberOfManifestListsDeleted = 123,
#'               NumberOfDpus = 123,
#'               JobDurationInHour = 123.0
#'             )
#'           ),
#'           orphanFileDeletionMetrics = list(
#'             IcebergMetrics = list(
#'               NumberOfOrphanFilesDeleted = 123,
#'               NumberOfDpus = 123,
#'               JobDurationInHour = 123.0
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Failures = list(
#'     list(
#'       error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       ),
#'       catalogId = "string",
#'       databaseName = "string",
#'       tableName = "string",
#'       type = "compaction"|"retention"|"orphan_file_deletion"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_table_optimizer(
#'   Entries = list(
#'     list(
#'       catalogId = "string",
#'       databaseName = "string",
#'       tableName = "string",
#'       type = "compaction"|"retention"|"orphan_file_deletion"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_table_optimizer
#'
#' @aliases glue_batch_get_table_optimizer
glue_batch_get_table_optimizer <- function(Entries) {
  op <- new_operation(
    name = "BatchGetTableOptimizer",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_table_optimizer_input(Entries = Entries)
  output <- .glue$batch_get_table_optimizer_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_table_optimizer <- glue_batch_get_table_optimizer

#' Returns a list of resource metadata for a given list of trigger names
#'
#' @description
#' Returns a list of resource metadata for a given list of trigger names.
#' After calling the [`list_triggers`][glue_list_triggers] operation, you
#' can call this operation to access the data to which you have been
#' granted permissions. This operation supports all IAM permissions,
#' including permission conditions that uses tags.
#'
#' @usage
#' glue_batch_get_triggers(TriggerNames)
#'
#' @param TriggerNames &#91;required&#93; A list of trigger names, which may be the names returned from the
#' [`list_triggers`][glue_list_triggers] operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Triggers = list(
#'     list(
#'       Name = "string",
#'       WorkflowName = "string",
#'       Id = "string",
#'       Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'       State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'       Description = "string",
#'       Schedule = "string",
#'       Actions = list(
#'         list(
#'           JobName = "string",
#'           Arguments = list(
#'             "string"
#'           ),
#'           Timeout = 123,
#'           SecurityConfiguration = "string",
#'           NotificationProperty = list(
#'             NotifyDelayAfter = 123
#'           ),
#'           CrawlerName = "string"
#'         )
#'       ),
#'       Predicate = list(
#'         Logical = "AND"|"ANY",
#'         Conditions = list(
#'           list(
#'             LogicalOperator = "EQUALS",
#'             JobName = "string",
#'             State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'             CrawlerName = "string",
#'             CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'           )
#'         )
#'       ),
#'       EventBatchingCondition = list(
#'         BatchSize = 123,
#'         BatchWindow = 123
#'       )
#'     )
#'   ),
#'   TriggersNotFound = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_triggers(
#'   TriggerNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_triggers
#'
#' @aliases glue_batch_get_triggers
glue_batch_get_triggers <- function(TriggerNames) {
  op <- new_operation(
    name = "BatchGetTriggers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_triggers_input(TriggerNames = TriggerNames)
  output <- .glue$batch_get_triggers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_triggers <- glue_batch_get_triggers

#' Returns a list of resource metadata for a given list of workflow names
#'
#' @description
#' Returns a list of resource metadata for a given list of workflow names.
#' After calling the [`list_workflows`][glue_list_workflows] operation, you
#' can call this operation to access the data to which you have been
#' granted permissions. This operation supports all IAM permissions,
#' including permission conditions that uses tags.
#'
#' @usage
#' glue_batch_get_workflows(Names, IncludeGraph)
#'
#' @param Names &#91;required&#93; A list of workflow names, which may be the names returned from the
#' [`list_workflows`][glue_list_workflows] operation.
#' @param IncludeGraph Specifies whether to include a graph when returning the workflow
#' resource metadata.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Workflows = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       DefaultRunProperties = list(
#'         "string"
#'       ),
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastRun = list(
#'         Name = "string",
#'         WorkflowRunId = "string",
#'         PreviousRunId = "string",
#'         WorkflowRunProperties = list(
#'           "string"
#'         ),
#'         StartedOn = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         CompletedOn = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Status = "RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR",
#'         ErrorMessage = "string",
#'         Statistics = list(
#'           TotalActions = 123,
#'           TimeoutActions = 123,
#'           FailedActions = 123,
#'           StoppedActions = 123,
#'           SucceededActions = 123,
#'           RunningActions = 123,
#'           ErroredActions = 123,
#'           WaitingActions = 123
#'         ),
#'         Graph = list(
#'           Nodes = list(
#'             list(
#'               Type = "CRAWLER"|"JOB"|"TRIGGER",
#'               Name = "string",
#'               UniqueId = "string",
#'               TriggerDetails = list(
#'                 Trigger = list(
#'                   Name = "string",
#'                   WorkflowName = "string",
#'                   Id = "string",
#'                   Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'                   State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'                   Description = "string",
#'                   Schedule = "string",
#'                   Actions = list(
#'                     list(
#'                       JobName = "string",
#'                       Arguments = list(
#'                         "string"
#'                       ),
#'                       Timeout = 123,
#'                       SecurityConfiguration = "string",
#'                       NotificationProperty = list(
#'                         NotifyDelayAfter = 123
#'                       ),
#'                       CrawlerName = "string"
#'                     )
#'                   ),
#'                   Predicate = list(
#'                     Logical = "AND"|"ANY",
#'                     Conditions = list(
#'                       list(
#'                         LogicalOperator = "EQUALS",
#'                         JobName = "string",
#'                         State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                         CrawlerName = "string",
#'                         CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                       )
#'                     )
#'                   ),
#'                   EventBatchingCondition = list(
#'                     BatchSize = 123,
#'                     BatchWindow = 123
#'                   )
#'                 )
#'               ),
#'               JobDetails = list(
#'                 JobRuns = list(
#'                   list(
#'                     Id = "string",
#'                     Attempt = 123,
#'                     PreviousRunId = "string",
#'                     TriggerName = "string",
#'                     JobName = "string",
#'                     JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                     JobRunQueuingEnabled = TRUE|FALSE,
#'                     StartedOn = as.POSIXct(
#'                       "2015-01-01"
#'                     ),
#'                     LastModifiedOn = as.POSIXct(
#'                       "2015-01-01"
#'                     ),
#'                     CompletedOn = as.POSIXct(
#'                       "2015-01-01"
#'                     ),
#'                     JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                     Arguments = list(
#'                       "string"
#'                     ),
#'                     ErrorMessage = "string",
#'                     PredecessorRuns = list(
#'                       list(
#'                         JobName = "string",
#'                         RunId = "string"
#'                       )
#'                     ),
#'                     AllocatedCapacity = 123,
#'                     ExecutionTime = 123,
#'                     Timeout = 123,
#'                     MaxCapacity = 123.0,
#'                     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                     NumberOfWorkers = 123,
#'                     SecurityConfiguration = "string",
#'                     LogGroupName = "string",
#'                     NotificationProperty = list(
#'                       NotifyDelayAfter = 123
#'                     ),
#'                     GlueVersion = "string",
#'                     DPUSeconds = 123.0,
#'                     ExecutionClass = "FLEX"|"STANDARD",
#'                     MaintenanceWindow = "string",
#'                     ProfileName = "string",
#'                     StateDetail = "string"
#'                   )
#'                 )
#'               ),
#'               CrawlerDetails = list(
#'                 Crawls = list(
#'                   list(
#'                     State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                     StartedOn = as.POSIXct(
#'                       "2015-01-01"
#'                     ),
#'                     CompletedOn = as.POSIXct(
#'                       "2015-01-01"
#'                     ),
#'                     ErrorMessage = "string",
#'                     LogGroup = "string",
#'                     LogStream = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           Edges = list(
#'             list(
#'               SourceId = "string",
#'               DestinationId = "string"
#'             )
#'           )
#'         ),
#'         StartingEventBatchCondition = list(
#'           BatchSize = 123,
#'           BatchWindow = 123
#'         )
#'       ),
#'       Graph = list(
#'         Nodes = list(
#'           list(
#'             Type = "CRAWLER"|"JOB"|"TRIGGER",
#'             Name = "string",
#'             UniqueId = "string",
#'             TriggerDetails = list(
#'               Trigger = list(
#'                 Name = "string",
#'                 WorkflowName = "string",
#'                 Id = "string",
#'                 Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'                 State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'                 Description = "string",
#'                 Schedule = "string",
#'                 Actions = list(
#'                   list(
#'                     JobName = "string",
#'                     Arguments = list(
#'                       "string"
#'                     ),
#'                     Timeout = 123,
#'                     SecurityConfiguration = "string",
#'                     NotificationProperty = list(
#'                       NotifyDelayAfter = 123
#'                     ),
#'                     CrawlerName = "string"
#'                   )
#'                 ),
#'                 Predicate = list(
#'                   Logical = "AND"|"ANY",
#'                   Conditions = list(
#'                     list(
#'                       LogicalOperator = "EQUALS",
#'                       JobName = "string",
#'                       State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                       CrawlerName = "string",
#'                       CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                     )
#'                   )
#'                 ),
#'                 EventBatchingCondition = list(
#'                   BatchSize = 123,
#'                   BatchWindow = 123
#'                 )
#'               )
#'             ),
#'             JobDetails = list(
#'               JobRuns = list(
#'                 list(
#'                   Id = "string",
#'                   Attempt = 123,
#'                   PreviousRunId = "string",
#'                   TriggerName = "string",
#'                   JobName = "string",
#'                   JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                   JobRunQueuingEnabled = TRUE|FALSE,
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   LastModifiedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                   Arguments = list(
#'                     "string"
#'                   ),
#'                   ErrorMessage = "string",
#'                   PredecessorRuns = list(
#'                     list(
#'                       JobName = "string",
#'                       RunId = "string"
#'                     )
#'                   ),
#'                   AllocatedCapacity = 123,
#'                   ExecutionTime = 123,
#'                   Timeout = 123,
#'                   MaxCapacity = 123.0,
#'                   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                   NumberOfWorkers = 123,
#'                   SecurityConfiguration = "string",
#'                   LogGroupName = "string",
#'                   NotificationProperty = list(
#'                     NotifyDelayAfter = 123
#'                   ),
#'                   GlueVersion = "string",
#'                   DPUSeconds = 123.0,
#'                   ExecutionClass = "FLEX"|"STANDARD",
#'                   MaintenanceWindow = "string",
#'                   ProfileName = "string",
#'                   StateDetail = "string"
#'                 )
#'               )
#'             ),
#'             CrawlerDetails = list(
#'               Crawls = list(
#'                 list(
#'                   State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   ErrorMessage = "string",
#'                   LogGroup = "string",
#'                   LogStream = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         Edges = list(
#'           list(
#'             SourceId = "string",
#'             DestinationId = "string"
#'           )
#'         )
#'       ),
#'       MaxConcurrentRuns = 123,
#'       BlueprintDetails = list(
#'         BlueprintName = "string",
#'         RunId = "string"
#'       )
#'     )
#'   ),
#'   MissingWorkflows = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_workflows(
#'   Names = list(
#'     "string"
#'   ),
#'   IncludeGraph = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_get_workflows
#'
#' @aliases glue_batch_get_workflows
glue_batch_get_workflows <- function(Names, IncludeGraph = NULL) {
  op <- new_operation(
    name = "BatchGetWorkflows",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_get_workflows_input(Names = Names, IncludeGraph = IncludeGraph)
  output <- .glue$batch_get_workflows_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_get_workflows <- glue_batch_get_workflows

#' Annotate datapoints over time for a specific data quality statistic
#'
#' @description
#' Annotate datapoints over time for a specific data quality statistic.
#'
#' @usage
#' glue_batch_put_data_quality_statistic_annotation(InclusionAnnotations,
#'   ClientToken)
#'
#' @param InclusionAnnotations &#91;required&#93; A list of `DatapointInclusionAnnotation`'s.
#' @param ClientToken Client Token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FailedInclusionAnnotations = list(
#'     list(
#'       ProfileId = "string",
#'       StatisticId = "string",
#'       FailureReason = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_put_data_quality_statistic_annotation(
#'   InclusionAnnotations = list(
#'     list(
#'       ProfileId = "string",
#'       StatisticId = "string",
#'       InclusionAnnotation = "INCLUDE"|"EXCLUDE"
#'     )
#'   ),
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_put_data_quality_statistic_annotation
#'
#' @aliases glue_batch_put_data_quality_statistic_annotation
glue_batch_put_data_quality_statistic_annotation <- function(InclusionAnnotations, ClientToken = NULL) {
  op <- new_operation(
    name = "BatchPutDataQualityStatisticAnnotation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_put_data_quality_statistic_annotation_input(InclusionAnnotations = InclusionAnnotations, ClientToken = ClientToken)
  output <- .glue$batch_put_data_quality_statistic_annotation_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_put_data_quality_statistic_annotation <- glue_batch_put_data_quality_statistic_annotation

#' Stops one or more job runs for a specified job definition
#'
#' @description
#' Stops one or more job runs for a specified job definition.
#'
#' @usage
#' glue_batch_stop_job_run(JobName, JobRunIds)
#'
#' @param JobName &#91;required&#93; The name of the job definition for which to stop job runs.
#' @param JobRunIds &#91;required&#93; A list of the `JobRunIds` that should be stopped for that job
#' definition.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SuccessfulSubmissions = list(
#'     list(
#'       JobName = "string",
#'       JobRunId = "string"
#'     )
#'   ),
#'   Errors = list(
#'     list(
#'       JobName = "string",
#'       JobRunId = "string",
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_stop_job_run(
#'   JobName = "string",
#'   JobRunIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_stop_job_run
#'
#' @aliases glue_batch_stop_job_run
glue_batch_stop_job_run <- function(JobName, JobRunIds) {
  op <- new_operation(
    name = "BatchStopJobRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_stop_job_run_input(JobName = JobName, JobRunIds = JobRunIds)
  output <- .glue$batch_stop_job_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_stop_job_run <- glue_batch_stop_job_run

#' Updates one or more partitions in a batch operation
#'
#' @description
#' Updates one or more partitions in a batch operation.
#'
#' @usage
#' glue_batch_update_partition(CatalogId, DatabaseName, TableName, Entries)
#'
#' @param CatalogId The ID of the catalog in which the partition is to be updated.
#' Currently, this should be the Amazon Web Services account ID.
#' @param DatabaseName &#91;required&#93; The name of the metadata database in which the partition is to be
#' updated.
#' @param TableName &#91;required&#93; The name of the metadata table in which the partition is to be updated.
#' @param Entries &#91;required&#93; A list of up to 100 `BatchUpdatePartitionRequestEntry` objects to
#' update.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       PartitionValueList = list(
#'         "string"
#'       ),
#'       ErrorDetail = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_update_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Entries = list(
#'     list(
#'       PartitionValueList = list(
#'         "string"
#'       ),
#'       PartitionInput = list(
#'         Values = list(
#'           "string"
#'         ),
#'         LastAccessTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         StorageDescriptor = list(
#'           Columns = list(
#'             list(
#'               Name = "string",
#'               Type = "string",
#'               Comment = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           Location = "string",
#'           AdditionalLocations = list(
#'             "string"
#'           ),
#'           InputFormat = "string",
#'           OutputFormat = "string",
#'           Compressed = TRUE|FALSE,
#'           NumberOfBuckets = 123,
#'           SerdeInfo = list(
#'             Name = "string",
#'             SerializationLibrary = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           ),
#'           BucketColumns = list(
#'             "string"
#'           ),
#'           SortColumns = list(
#'             list(
#'               Column = "string",
#'               SortOrder = 123
#'             )
#'           ),
#'           Parameters = list(
#'             "string"
#'           ),
#'           SkewedInfo = list(
#'             SkewedColumnNames = list(
#'               "string"
#'             ),
#'             SkewedColumnValues = list(
#'               "string"
#'             ),
#'             SkewedColumnValueLocationMaps = list(
#'               "string"
#'             )
#'           ),
#'           StoredAsSubDirectories = TRUE|FALSE,
#'           SchemaReference = list(
#'             SchemaId = list(
#'               SchemaArn = "string",
#'               SchemaName = "string",
#'               RegistryName = "string"
#'             ),
#'             SchemaVersionId = "string",
#'             SchemaVersionNumber = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         LastAnalyzedTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_batch_update_partition
#'
#' @aliases glue_batch_update_partition
glue_batch_update_partition <- function(CatalogId = NULL, DatabaseName, TableName, Entries) {
  op <- new_operation(
    name = "BatchUpdatePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$batch_update_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Entries = Entries)
  output <- .glue$batch_update_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$batch_update_partition <- glue_batch_update_partition

#' Cancels the specified recommendation run that was being used to generate
#' rules
#'
#' @description
#' Cancels the specified recommendation run that was being used to generate
#' rules.
#'
#' @usage
#' glue_cancel_data_quality_rule_recommendation_run(RunId)
#'
#' @param RunId &#91;required&#93; The unique run identifier associated with this run.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_data_quality_rule_recommendation_run(
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_cancel_data_quality_rule_recommendation_run
#'
#' @aliases glue_cancel_data_quality_rule_recommendation_run
glue_cancel_data_quality_rule_recommendation_run <- function(RunId) {
  op <- new_operation(
    name = "CancelDataQualityRuleRecommendationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$cancel_data_quality_rule_recommendation_run_input(RunId = RunId)
  output <- .glue$cancel_data_quality_rule_recommendation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$cancel_data_quality_rule_recommendation_run <- glue_cancel_data_quality_rule_recommendation_run

#' Cancels a run where a ruleset is being evaluated against a data source
#'
#' @description
#' Cancels a run where a ruleset is being evaluated against a data source.
#'
#' @usage
#' glue_cancel_data_quality_ruleset_evaluation_run(RunId)
#'
#' @param RunId &#91;required&#93; The unique run identifier associated with this run.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_data_quality_ruleset_evaluation_run(
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_cancel_data_quality_ruleset_evaluation_run
#'
#' @aliases glue_cancel_data_quality_ruleset_evaluation_run
glue_cancel_data_quality_ruleset_evaluation_run <- function(RunId) {
  op <- new_operation(
    name = "CancelDataQualityRulesetEvaluationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$cancel_data_quality_ruleset_evaluation_run_input(RunId = RunId)
  output <- .glue$cancel_data_quality_ruleset_evaluation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$cancel_data_quality_ruleset_evaluation_run <- glue_cancel_data_quality_ruleset_evaluation_run

#' Cancels (stops) a task run
#'
#' @description
#' Cancels (stops) a task run. Machine learning task runs are asynchronous
#' tasks that Glue runs on your behalf as part of various machine learning
#' workflows. You can cancel a machine learning task run at any time by
#' calling [`cancel_ml_task_run`][glue_cancel_ml_task_run] with a task
#' run's parent transform's `TransformID` and the task run's `TaskRunId`.
#'
#' @usage
#' glue_cancel_ml_task_run(TransformId, TaskRunId)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param TaskRunId &#91;required&#93; A unique identifier for the task run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string",
#'   TaskRunId = "string",
#'   Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_ml_task_run(
#'   TransformId = "string",
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_cancel_ml_task_run
#'
#' @aliases glue_cancel_ml_task_run
glue_cancel_ml_task_run <- function(TransformId, TaskRunId) {
  op <- new_operation(
    name = "CancelMLTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$cancel_ml_task_run_input(TransformId = TransformId, TaskRunId = TaskRunId)
  output <- .glue$cancel_ml_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$cancel_ml_task_run <- glue_cancel_ml_task_run

#' Cancels the statement
#'
#' @description
#' Cancels the statement.
#'
#' @usage
#' glue_cancel_statement(SessionId, Id, RequestOrigin)
#'
#' @param SessionId &#91;required&#93; The Session ID of the statement to be cancelled.
#' @param Id &#91;required&#93; The ID of the statement to be cancelled.
#' @param RequestOrigin The origin of the request to cancel the statement.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_statement(
#'   SessionId = "string",
#'   Id = 123,
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_cancel_statement
#'
#' @aliases glue_cancel_statement
glue_cancel_statement <- function(SessionId, Id, RequestOrigin = NULL) {
  op <- new_operation(
    name = "CancelStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$cancel_statement_input(SessionId = SessionId, Id = Id, RequestOrigin = RequestOrigin)
  output <- .glue$cancel_statement_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$cancel_statement <- glue_cancel_statement

#' Validates the supplied schema
#'
#' @description
#' Validates the supplied schema. This call has no side effects, it simply
#' validates using the supplied schema using `DataFormat` as the format.
#' Since it does not take a schema set name, no compatibility checks are
#' performed.
#'
#' @usage
#' glue_check_schema_version_validity(DataFormat, SchemaDefinition)
#'
#' @param DataFormat &#91;required&#93; The data format of the schema definition. Currently `AVRO`, `JSON` and
#' `PROTOBUF` are supported.
#' @param SchemaDefinition &#91;required&#93; The definition of the schema that has to be validated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Valid = TRUE|FALSE,
#'   Error = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$check_schema_version_validity(
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   SchemaDefinition = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_check_schema_version_validity
#'
#' @aliases glue_check_schema_version_validity
glue_check_schema_version_validity <- function(DataFormat, SchemaDefinition) {
  op <- new_operation(
    name = "CheckSchemaVersionValidity",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$check_schema_version_validity_input(DataFormat = DataFormat, SchemaDefinition = SchemaDefinition)
  output <- .glue$check_schema_version_validity_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$check_schema_version_validity <- glue_check_schema_version_validity

#' Registers a blueprint with Glue
#'
#' @description
#' Registers a blueprint with Glue.
#'
#' @usage
#' glue_create_blueprint(Name, Description, BlueprintLocation, Tags)
#'
#' @param Name &#91;required&#93; The name of the blueprint.
#' @param Description A description of the blueprint.
#' @param BlueprintLocation &#91;required&#93; Specifies a path in Amazon S3 where the blueprint is published.
#' @param Tags The tags to be applied to this blueprint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_blueprint(
#'   Name = "string",
#'   Description = "string",
#'   BlueprintLocation = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_blueprint
#'
#' @aliases glue_create_blueprint
glue_create_blueprint <- function(Name, Description = NULL, BlueprintLocation, Tags = NULL) {
  op <- new_operation(
    name = "CreateBlueprint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_blueprint_input(Name = Name, Description = Description, BlueprintLocation = BlueprintLocation, Tags = Tags)
  output <- .glue$create_blueprint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_blueprint <- glue_create_blueprint

#' Creates a new catalog in the Glue Data Catalog
#'
#' @description
#' Creates a new catalog in the Glue Data Catalog.
#'
#' @usage
#' glue_create_catalog(Name, CatalogInput, Tags)
#'
#' @param Name &#91;required&#93; The name of the catalog to create.
#' @param CatalogInput &#91;required&#93; A `CatalogInput` object that defines the metadata for the catalog.
#' @param Tags A map array of key-value pairs, not more than 50 pairs. Each key is a
#' UTF-8 string, not less than 1 or more than 128 bytes long. Each value is
#' a UTF-8 string, not more than 256 bytes long. The tags you assign to the
#' catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_catalog(
#'   Name = "string",
#'   CatalogInput = list(
#'     Description = "string",
#'     FederatedCatalog = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     TargetRedshiftCatalog = list(
#'       CatalogArn = "string"
#'     ),
#'     CatalogProperties = list(
#'       DataLakeAccessProperties = list(
#'         DataLakeAccess = TRUE|FALSE,
#'         DataTransferRole = "string",
#'         KmsKey = "string",
#'         CatalogType = "string"
#'       ),
#'       CustomProperties = list(
#'         "string"
#'       )
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     CreateDatabaseDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_catalog
#'
#' @aliases glue_create_catalog
glue_create_catalog <- function(Name, CatalogInput, Tags = NULL) {
  op <- new_operation(
    name = "CreateCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_catalog_input(Name = Name, CatalogInput = CatalogInput, Tags = Tags)
  output <- .glue$create_catalog_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_catalog <- glue_create_catalog

#' Creates a classifier in the user's account
#'
#' @description
#' Creates a classifier in the user's account. This can be a
#' `GrokClassifier`, an `XMLClassifier`, a `JsonClassifier`, or a
#' `CsvClassifier`, depending on which field of the request is present.
#'
#' @usage
#' glue_create_classifier(GrokClassifier, XMLClassifier, JsonClassifier,
#'   CsvClassifier)
#'
#' @param GrokClassifier A `GrokClassifier` object specifying the classifier to create.
#' @param XMLClassifier An `XMLClassifier` object specifying the classifier to create.
#' @param JsonClassifier A `JsonClassifier` object specifying the classifier to create.
#' @param CsvClassifier A `CsvClassifier` object specifying the classifier to create.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_classifier(
#'   GrokClassifier = list(
#'     Classification = "string",
#'     Name = "string",
#'     GrokPattern = "string",
#'     CustomPatterns = "string"
#'   ),
#'   XMLClassifier = list(
#'     Classification = "string",
#'     Name = "string",
#'     RowTag = "string"
#'   ),
#'   JsonClassifier = list(
#'     Name = "string",
#'     JsonPath = "string"
#'   ),
#'   CsvClassifier = list(
#'     Name = "string",
#'     Delimiter = "string",
#'     QuoteSymbol = "string",
#'     ContainsHeader = "UNKNOWN"|"PRESENT"|"ABSENT",
#'     Header = list(
#'       "string"
#'     ),
#'     DisableValueTrimming = TRUE|FALSE,
#'     AllowSingleColumn = TRUE|FALSE,
#'     CustomDatatypeConfigured = TRUE|FALSE,
#'     CustomDatatypes = list(
#'       "string"
#'     ),
#'     Serde = "OpenCSVSerDe"|"LazySimpleSerDe"|"None"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_classifier
#'
#' @aliases glue_create_classifier
glue_create_classifier <- function(GrokClassifier = NULL, XMLClassifier = NULL, JsonClassifier = NULL, CsvClassifier = NULL) {
  op <- new_operation(
    name = "CreateClassifier",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_classifier_input(GrokClassifier = GrokClassifier, XMLClassifier = XMLClassifier, JsonClassifier = JsonClassifier, CsvClassifier = CsvClassifier)
  output <- .glue$create_classifier_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_classifier <- glue_create_classifier

#' Creates settings for a column statistics task
#'
#' @description
#' Creates settings for a column statistics task.
#'
#' @usage
#' glue_create_column_statistics_task_settings(DatabaseName, TableName,
#'   Role, Schedule, ColumnNameList, SampleSize, CatalogID,
#'   SecurityConfiguration, Tags)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to generate column statistics.
#' @param Role &#91;required&#93; The role used for running the column statistics.
#' @param Schedule A schedule for running the column statistics, specified in CRON syntax.
#' @param ColumnNameList A list of column names for which to run statistics.
#' @param SampleSize The percentage of data to sample.
#' @param CatalogID The ID of the Data Catalog in which the database resides.
#' @param SecurityConfiguration Name of the security configuration that is used to encrypt CloudWatch
#' logs.
#' @param Tags A map of tags.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_column_statistics_task_settings(
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Role = "string",
#'   Schedule = "string",
#'   ColumnNameList = list(
#'     "string"
#'   ),
#'   SampleSize = 123.0,
#'   CatalogID = "string",
#'   SecurityConfiguration = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_column_statistics_task_settings
#'
#' @aliases glue_create_column_statistics_task_settings
glue_create_column_statistics_task_settings <- function(DatabaseName, TableName, Role, Schedule = NULL, ColumnNameList = NULL, SampleSize = NULL, CatalogID = NULL, SecurityConfiguration = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateColumnStatisticsTaskSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_column_statistics_task_settings_input(DatabaseName = DatabaseName, TableName = TableName, Role = Role, Schedule = Schedule, ColumnNameList = ColumnNameList, SampleSize = SampleSize, CatalogID = CatalogID, SecurityConfiguration = SecurityConfiguration, Tags = Tags)
  output <- .glue$create_column_statistics_task_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_column_statistics_task_settings <- glue_create_column_statistics_task_settings

#' Creates a connection definition in the Data Catalog
#'
#' @description
#' Creates a connection definition in the Data Catalog.
#' 
#' Connections used for creating federated resources require the IAM
#' `glue:PassConnection` permission.
#'
#' @usage
#' glue_create_connection(CatalogId, ConnectionInput, Tags)
#'
#' @param CatalogId The ID of the Data Catalog in which to create the connection. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param ConnectionInput &#91;required&#93; A `ConnectionInput` object defining the connection to create.
#' @param Tags The tags you assign to the connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreateConnectionStatus = "READY"|"IN_PROGRESS"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_connection(
#'   CatalogId = "string",
#'   ConnectionInput = list(
#'     Name = "string",
#'     Description = "string",
#'     ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     AthenaProperties = list(
#'       "string"
#'     ),
#'     PythonProperties = list(
#'       "string"
#'     ),
#'     PhysicalConnectionRequirements = list(
#'       SubnetId = "string",
#'       SecurityGroupIdList = list(
#'         "string"
#'       ),
#'       AvailabilityZone = "string"
#'     ),
#'     AuthenticationConfiguration = list(
#'       AuthenticationType = "BASIC"|"OAUTH2"|"CUSTOM"|"IAM",
#'       OAuth2Properties = list(
#'         OAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'         OAuth2ClientApplication = list(
#'           UserManagedClientApplicationClientId = "string",
#'           AWSManagedClientApplicationReference = "string"
#'         ),
#'         TokenUrl = "string",
#'         TokenUrlParametersMap = list(
#'           "string"
#'         ),
#'         AuthorizationCodeProperties = list(
#'           AuthorizationCode = "string",
#'           RedirectUri = "string"
#'         ),
#'         OAuth2Credentials = list(
#'           UserManagedClientApplicationClientSecret = "string",
#'           AccessToken = "string",
#'           RefreshToken = "string",
#'           JwtToken = "string"
#'         )
#'       ),
#'       SecretArn = "string",
#'       KmsKeyArn = "string",
#'       BasicAuthenticationCredentials = list(
#'         Username = "string",
#'         Password = "string"
#'       ),
#'       CustomAuthenticationCredentials = list(
#'         "string"
#'       )
#'     ),
#'     ValidateCredentials = TRUE|FALSE,
#'     ValidateForComputeEnvironments = list(
#'       "SPARK"|"ATHENA"|"PYTHON"
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_connection
#'
#' @aliases glue_create_connection
glue_create_connection <- function(CatalogId = NULL, ConnectionInput, Tags = NULL) {
  op <- new_operation(
    name = "CreateConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_connection_input(CatalogId = CatalogId, ConnectionInput = ConnectionInput, Tags = Tags)
  output <- .glue$create_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_connection <- glue_create_connection

#' Creates a new crawler with specified targets, role, configuration, and
#' optional schedule
#'
#' @description
#' Creates a new crawler with specified targets, role, configuration, and
#' optional schedule. At least one crawl target must be specified, in the
#' `s3Targets` field, the `jdbcTargets` field, or the `DynamoDBTargets`
#' field.
#'
#' @usage
#' glue_create_crawler(Name, Role, DatabaseName, Description, Targets,
#'   Schedule, Classifiers, TablePrefix, SchemaChangePolicy, RecrawlPolicy,
#'   LineageConfiguration, LakeFormationConfiguration, Configuration,
#'   CrawlerSecurityConfiguration, Tags)
#'
#' @param Name &#91;required&#93; Name of the new crawler.
#' @param Role &#91;required&#93; The IAM role or Amazon Resource Name (ARN) of an IAM role used by the
#' new crawler to access customer resources.
#' @param DatabaseName The Glue database where results are written, such as:
#' `arn:aws:daylight:us-east-1::database/sometable/*`.
#' @param Description A description of the new crawler.
#' @param Targets &#91;required&#93; A list of collection of targets to crawl.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based
#' Schedules for Jobs and
#' Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html).
#' For example, to run something every day at 12:15 UTC, you would specify:
#' `cron(15 12 * * ? *)`.
#' @param Classifiers A list of custom classifiers that the user has registered. By default,
#' all built-in classifiers are included in a crawl, but these custom
#' classifiers always override the default classifiers for a given
#' classification.
#' @param TablePrefix The table prefix used for catalog tables that are created.
#' @param SchemaChangePolicy The policy for the crawler's update and deletion behavior.
#' @param RecrawlPolicy A policy that specifies whether to crawl the entire dataset again, or to
#' crawl only folders that were added since the last crawler run.
#' @param LineageConfiguration Specifies data lineage configuration settings for the crawler.
#' @param LakeFormationConfiguration Specifies Lake Formation configuration settings for the crawler.
#' @param Configuration Crawler configuration information. This versioned JSON string allows
#' users to specify aspects of a crawler's behavior. For more information,
#' see [Setting crawler configuration
#' options](https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
#' @param CrawlerSecurityConfiguration The name of the `SecurityConfiguration` structure to be used by this
#' crawler.
#' @param Tags The tags to use with this crawler request. You may use tags to limit
#' access to the crawler. For more information about tags in Glue, see
#' [Amazon Web Services Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in
#' the developer guide.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_crawler(
#'   Name = "string",
#'   Role = "string",
#'   DatabaseName = "string",
#'   Description = "string",
#'   Targets = list(
#'     S3Targets = list(
#'       list(
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         SampleSize = 123,
#'         EventQueueArn = "string",
#'         DlqEventQueueArn = "string"
#'       )
#'     ),
#'     JdbcTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         EnableAdditionalMetadata = list(
#'           "COMMENTS"|"RAWTYPES"
#'         )
#'       )
#'     ),
#'     MongoDBTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         ScanAll = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDBTargets = list(
#'       list(
#'         Path = "string",
#'         scanAll = TRUE|FALSE,
#'         scanRate = 123.0
#'       )
#'     ),
#'     CatalogTargets = list(
#'       list(
#'         DatabaseName = "string",
#'         Tables = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         EventQueueArn = "string",
#'         DlqEventQueueArn = "string"
#'       )
#'     ),
#'     DeltaTargets = list(
#'       list(
#'         DeltaTables = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         WriteManifest = TRUE|FALSE,
#'         CreateNativeDeltaTable = TRUE|FALSE
#'       )
#'     ),
#'     IcebergTargets = list(
#'       list(
#'         Paths = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         MaximumTraversalDepth = 123
#'       )
#'     ),
#'     HudiTargets = list(
#'       list(
#'         Paths = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         MaximumTraversalDepth = 123
#'       )
#'     )
#'   ),
#'   Schedule = "string",
#'   Classifiers = list(
#'     "string"
#'   ),
#'   TablePrefix = "string",
#'   SchemaChangePolicy = list(
#'     UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'     DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'   ),
#'   RecrawlPolicy = list(
#'     RecrawlBehavior = "CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"
#'   ),
#'   LineageConfiguration = list(
#'     CrawlerLineageSettings = "ENABLE"|"DISABLE"
#'   ),
#'   LakeFormationConfiguration = list(
#'     UseLakeFormationCredentials = TRUE|FALSE,
#'     AccountId = "string"
#'   ),
#'   Configuration = "string",
#'   CrawlerSecurityConfiguration = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_crawler
#'
#' @aliases glue_create_crawler
glue_create_crawler <- function(Name, Role, DatabaseName = NULL, Description = NULL, Targets, Schedule = NULL, Classifiers = NULL, TablePrefix = NULL, SchemaChangePolicy = NULL, RecrawlPolicy = NULL, LineageConfiguration = NULL, LakeFormationConfiguration = NULL, Configuration = NULL, CrawlerSecurityConfiguration = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_crawler_input(Name = Name, Role = Role, DatabaseName = DatabaseName, Description = Description, Targets = Targets, Schedule = Schedule, Classifiers = Classifiers, TablePrefix = TablePrefix, SchemaChangePolicy = SchemaChangePolicy, RecrawlPolicy = RecrawlPolicy, LineageConfiguration = LineageConfiguration, LakeFormationConfiguration = LakeFormationConfiguration, Configuration = Configuration, CrawlerSecurityConfiguration = CrawlerSecurityConfiguration, Tags = Tags)
  output <- .glue$create_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_crawler <- glue_create_crawler

#' Creates a custom pattern that is used to detect sensitive data across
#' the columns and rows of your structured data
#'
#' @description
#' Creates a custom pattern that is used to detect sensitive data across
#' the columns and rows of your structured data.
#' 
#' Each custom pattern you create specifies a regular expression and an
#' optional list of context words. If no context words are passed only a
#' regular expression is checked.
#'
#' @usage
#' glue_create_custom_entity_type(Name, RegexString, ContextWords, Tags)
#'
#' @param Name &#91;required&#93; A name for the custom pattern that allows it to be retrieved or deleted
#' later. This name must be unique per Amazon Web Services account.
#' @param RegexString &#91;required&#93; A regular expression string that is used for detecting sensitive data in
#' a custom pattern.
#' @param ContextWords A list of context words. If none of these context words are found within
#' the vicinity of the regular expression the data will not be detected as
#' sensitive data.
#' 
#' If no context words are passed only a regular expression is checked.
#' @param Tags A list of tags applied to the custom entity type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_custom_entity_type(
#'   Name = "string",
#'   RegexString = "string",
#'   ContextWords = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_custom_entity_type
#'
#' @aliases glue_create_custom_entity_type
glue_create_custom_entity_type <- function(Name, RegexString, ContextWords = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateCustomEntityType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_custom_entity_type_input(Name = Name, RegexString = RegexString, ContextWords = ContextWords, Tags = Tags)
  output <- .glue$create_custom_entity_type_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_custom_entity_type <- glue_create_custom_entity_type

#' Creates a data quality ruleset with DQDL rules applied to a specified
#' Glue table
#'
#' @description
#' Creates a data quality ruleset with DQDL rules applied to a specified
#' Glue table.
#' 
#' You create the ruleset using the Data Quality Definition Language
#' (DQDL). For more information, see the Glue developer guide.
#'
#' @usage
#' glue_create_data_quality_ruleset(Name, Description, Ruleset, Tags,
#'   TargetTable, DataQualitySecurityConfiguration, ClientToken)
#'
#' @param Name &#91;required&#93; A unique name for the data quality ruleset.
#' @param Description A description of the data quality ruleset.
#' @param Ruleset &#91;required&#93; A Data Quality Definition Language (DQDL) ruleset. For more information,
#' see the Glue developer guide.
#' @param Tags A list of tags applied to the data quality ruleset.
#' @param TargetTable A target table associated with the data quality ruleset.
#' @param DataQualitySecurityConfiguration The name of the security configuration created with the data quality
#' encryption option.
#' @param ClientToken Used for idempotency and is recommended to be set to a random ID (such
#' as a UUID) to avoid creating or starting multiple instances of the same
#' resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_quality_ruleset(
#'   Name = "string",
#'   Description = "string",
#'   Ruleset = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   TargetTable = list(
#'     TableName = "string",
#'     DatabaseName = "string",
#'     CatalogId = "string"
#'   ),
#'   DataQualitySecurityConfiguration = "string",
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_data_quality_ruleset
#'
#' @aliases glue_create_data_quality_ruleset
glue_create_data_quality_ruleset <- function(Name, Description = NULL, Ruleset, Tags = NULL, TargetTable = NULL, DataQualitySecurityConfiguration = NULL, ClientToken = NULL) {
  op <- new_operation(
    name = "CreateDataQualityRuleset",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_data_quality_ruleset_input(Name = Name, Description = Description, Ruleset = Ruleset, Tags = Tags, TargetTable = TargetTable, DataQualitySecurityConfiguration = DataQualitySecurityConfiguration, ClientToken = ClientToken)
  output <- .glue$create_data_quality_ruleset_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_data_quality_ruleset <- glue_create_data_quality_ruleset

#' Creates a new database in a Data Catalog
#'
#' @description
#' Creates a new database in a Data Catalog.
#'
#' @usage
#' glue_create_database(CatalogId, DatabaseInput, Tags)
#'
#' @param CatalogId The ID of the Data Catalog in which to create the database. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseInput &#91;required&#93; The metadata for the database.
#' @param Tags The tags you assign to the database.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_database(
#'   CatalogId = "string",
#'   DatabaseInput = list(
#'     Name = "string",
#'     Description = "string",
#'     LocationUri = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     TargetDatabase = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Region = "string"
#'     ),
#'     FederatedDatabase = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_database
#'
#' @aliases glue_create_database
glue_create_database <- function(CatalogId = NULL, DatabaseInput, Tags = NULL) {
  op <- new_operation(
    name = "CreateDatabase",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_database_input(CatalogId = CatalogId, DatabaseInput = DatabaseInput, Tags = Tags)
  output <- .glue$create_database_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_database <- glue_create_database

#' Creates a new development endpoint
#'
#' @description
#' Creates a new development endpoint.
#'
#' @usage
#' glue_create_dev_endpoint(EndpointName, RoleArn, SecurityGroupIds,
#'   SubnetId, PublicKey, PublicKeys, NumberOfNodes, WorkerType, GlueVersion,
#'   NumberOfWorkers, ExtraPythonLibsS3Path, ExtraJarsS3Path,
#'   SecurityConfiguration, Tags, Arguments)
#'
#' @param EndpointName &#91;required&#93; The name to be assigned to the new `DevEndpoint`.
#' @param RoleArn &#91;required&#93; The IAM role for the `DevEndpoint`.
#' @param SecurityGroupIds Security group IDs for the security groups to be used by the new
#' `DevEndpoint`.
#' @param SubnetId The subnet ID for the new `DevEndpoint` to use.
#' @param PublicKey The public key to be used by this `DevEndpoint` for authentication. This
#' attribute is provided for backward compatibility because the recommended
#' attribute to use is public keys.
#' @param PublicKeys A list of public keys to be used by the development endpoints for
#' authentication. The use of this attribute is preferred over a single
#' public key because the public keys allow you to have a different private
#' key per client.
#' 
#' If you previously created an endpoint with a public key, you must remove
#' that key to be able to set a list of public keys. Call the
#' [`update_dev_endpoint`][glue_update_dev_endpoint] API with the public
#' key content in the `deletePublicKeys` attribute, and the list of new
#' keys in the `addPublicKeys` attribute.
#' @param NumberOfNodes The number of Glue Data Processing Units (DPUs) to allocate to this
#' `DevEndpoint`.
#' @param WorkerType The type of predefined worker that is allocated to the development
#' endpoint. Accepts a value of Standard, G.1X, or G.2X.
#' 
#' -   For the `Standard` worker type, each worker provides 4 vCPU, 16 GB
#'     of memory and a 50GB disk, and 2 executors per worker.
#' 
#' -   For the `G.1X` worker type, each worker maps to 1 DPU (4 vCPU, 16 GB
#'     of memory, 64 GB disk), and provides 1 executor per worker. We
#'     recommend this worker type for memory-intensive jobs.
#' 
#' -   For the `G.2X` worker type, each worker maps to 2 DPU (8 vCPU, 32 GB
#'     of memory, 128 GB disk), and provides 1 executor per worker. We
#'     recommend this worker type for memory-intensive jobs.
#' 
#' Known issue: when a development endpoint is created with the `G.2X`
#' `WorkerType` configuration, the Spark drivers for the development
#' endpoint will run on 4 vCPU, 16 GB of memory, and a 64 GB disk.
#' @param GlueVersion Glue version determines the versions of Apache Spark and Python that
#' Glue supports. The Python version indicates the version supported for
#' running your ETL scripts on development endpoints.
#' 
#' For more information about the available Glue versions and corresponding
#' Spark and Python versions, see [Glue
#' version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the
#' developer guide.
#' 
#' Development endpoints that are created without specifying a Glue version
#' default to Glue 0.9.
#' 
#' You can specify a version of Python support for development endpoints by
#' using the `Arguments` parameter in the
#' [`create_dev_endpoint`][glue_create_dev_endpoint] or
#' [`update_dev_endpoint`][glue_update_dev_endpoint] APIs. If no arguments
#' are provided, the version defaults to Python 2.
#' @param NumberOfWorkers The number of workers of a defined `workerType` that are allocated to
#' the development endpoint.
#' 
#' The maximum number of workers you can define are 299 for `G.1X`, and 149
#' for `G.2X`.
#' @param ExtraPythonLibsS3Path The paths to one or more Python libraries in an Amazon S3 bucket that
#' should be loaded in your `DevEndpoint`. Multiple values must be complete
#' paths separated by a comma.
#' 
#' You can only use pure Python libraries with a `DevEndpoint`. Libraries
#' that rely on C extensions, such as the
#' [pandas](http://pandas.pydata.org/) Python data analysis library, are
#' not yet supported.
#' @param ExtraJarsS3Path The path to one or more Java `.jar` files in an S3 bucket that should be
#' loaded in your `DevEndpoint`.
#' @param SecurityConfiguration The name of the `SecurityConfiguration` structure to be used with this
#' `DevEndpoint`.
#' @param Tags The tags to use with this DevEndpoint. You may use tags to limit access
#' to the DevEndpoint. For more information about tags in Glue, see [Amazon
#' Web Services Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in
#' the developer guide.
#' @param Arguments A map of arguments used to configure the `DevEndpoint`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   EndpointName = "string",
#'   Status = "string",
#'   SecurityGroupIds = list(
#'     "string"
#'   ),
#'   SubnetId = "string",
#'   RoleArn = "string",
#'   YarnEndpointAddress = "string",
#'   ZeppelinRemoteSparkInterpreterPort = 123,
#'   NumberOfNodes = 123,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   GlueVersion = "string",
#'   NumberOfWorkers = 123,
#'   AvailabilityZone = "string",
#'   VpcId = "string",
#'   ExtraPythonLibsS3Path = "string",
#'   ExtraJarsS3Path = "string",
#'   FailureReason = "string",
#'   SecurityConfiguration = "string",
#'   CreatedTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Arguments = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_dev_endpoint(
#'   EndpointName = "string",
#'   RoleArn = "string",
#'   SecurityGroupIds = list(
#'     "string"
#'   ),
#'   SubnetId = "string",
#'   PublicKey = "string",
#'   PublicKeys = list(
#'     "string"
#'   ),
#'   NumberOfNodes = 123,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   GlueVersion = "string",
#'   NumberOfWorkers = 123,
#'   ExtraPythonLibsS3Path = "string",
#'   ExtraJarsS3Path = "string",
#'   SecurityConfiguration = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Arguments = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_dev_endpoint
#'
#' @aliases glue_create_dev_endpoint
glue_create_dev_endpoint <- function(EndpointName, RoleArn, SecurityGroupIds = NULL, SubnetId = NULL, PublicKey = NULL, PublicKeys = NULL, NumberOfNodes = NULL, WorkerType = NULL, GlueVersion = NULL, NumberOfWorkers = NULL, ExtraPythonLibsS3Path = NULL, ExtraJarsS3Path = NULL, SecurityConfiguration = NULL, Tags = NULL, Arguments = NULL) {
  op <- new_operation(
    name = "CreateDevEndpoint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_dev_endpoint_input(EndpointName = EndpointName, RoleArn = RoleArn, SecurityGroupIds = SecurityGroupIds, SubnetId = SubnetId, PublicKey = PublicKey, PublicKeys = PublicKeys, NumberOfNodes = NumberOfNodes, WorkerType = WorkerType, GlueVersion = GlueVersion, NumberOfWorkers = NumberOfWorkers, ExtraPythonLibsS3Path = ExtraPythonLibsS3Path, ExtraJarsS3Path = ExtraJarsS3Path, SecurityConfiguration = SecurityConfiguration, Tags = Tags, Arguments = Arguments)
  output <- .glue$create_dev_endpoint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_dev_endpoint <- glue_create_dev_endpoint

#' Creates a Zero-ETL integration in the caller's account between two
#' resources with Amazon Resource Names (ARNs): the SourceArn and TargetArn
#'
#' @description
#' Creates a Zero-ETL integration in the caller's account between two
#' resources with Amazon Resource Names (ARNs): the `SourceArn` and
#' `TargetArn`.
#'
#' @usage
#' glue_create_integration(IntegrationName, SourceArn, TargetArn,
#'   Description, DataFilter, KmsKeyId, AdditionalEncryptionContext, Tags)
#'
#' @param IntegrationName &#91;required&#93; A unique name for an integration in Glue.
#' @param SourceArn &#91;required&#93; The ARN of the source resource for the integration.
#' @param TargetArn &#91;required&#93; The ARN of the target resource for the integration.
#' @param Description A description of the integration.
#' @param DataFilter Selects source tables for the integration using Maxwell filter syntax.
#' @param KmsKeyId The ARN of a KMS key used for encrypting the channel.
#' @param AdditionalEncryptionContext An optional set of non-secret key–value pairs that contains additional
#' contextual information for encryption. This can only be provided if
#' `KMSKeyId` is provided.
#' @param Tags Metadata assigned to the resource consisting of a list of key-value
#' pairs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SourceArn = "string",
#'   TargetArn = "string",
#'   IntegrationName = "string",
#'   Description = "string",
#'   IntegrationArn = "string",
#'   KmsKeyId = "string",
#'   AdditionalEncryptionContext = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   Status = "CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION",
#'   CreateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Errors = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   ),
#'   DataFilter = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_integration(
#'   IntegrationName = "string",
#'   SourceArn = "string",
#'   TargetArn = "string",
#'   Description = "string",
#'   DataFilter = "string",
#'   KmsKeyId = "string",
#'   AdditionalEncryptionContext = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_integration
#'
#' @aliases glue_create_integration
glue_create_integration <- function(IntegrationName, SourceArn, TargetArn, Description = NULL, DataFilter = NULL, KmsKeyId = NULL, AdditionalEncryptionContext = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateIntegration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_integration_input(IntegrationName = IntegrationName, SourceArn = SourceArn, TargetArn = TargetArn, Description = Description, DataFilter = DataFilter, KmsKeyId = KmsKeyId, AdditionalEncryptionContext = AdditionalEncryptionContext, Tags = Tags)
  output <- .glue$create_integration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_integration <- glue_create_integration

#' This API can be used for setting up the ResourceProperty of the Glue
#' connection (for the source) or Glue database ARN (for the target)
#'
#' @description
#' This API can be used for setting up the `ResourceProperty` of the Glue
#' connection (for the source) or Glue database ARN (for the target). These
#' properties can include the role to access the connection or database. To
#' set both source and target properties the same API needs to be invoked
#' with the Glue connection ARN as `ResourceArn` with
#' `SourceProcessingProperties` and the Glue database ARN as `ResourceArn`
#' with `TargetProcessingProperties` respectively.
#'
#' @usage
#' glue_create_integration_resource_property(ResourceArn,
#'   SourceProcessingProperties, TargetProcessingProperties)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param SourceProcessingProperties The resource properties associated with the integration source.
#' @param TargetProcessingProperties The resource properties associated with the integration target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResourceArn = "string",
#'   SourceProcessingProperties = list(
#'     RoleArn = "string"
#'   ),
#'   TargetProcessingProperties = list(
#'     RoleArn = "string",
#'     KmsArn = "string",
#'     ConnectionName = "string",
#'     EventBusArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_integration_resource_property(
#'   ResourceArn = "string",
#'   SourceProcessingProperties = list(
#'     RoleArn = "string"
#'   ),
#'   TargetProcessingProperties = list(
#'     RoleArn = "string",
#'     KmsArn = "string",
#'     ConnectionName = "string",
#'     EventBusArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_integration_resource_property
#'
#' @aliases glue_create_integration_resource_property
glue_create_integration_resource_property <- function(ResourceArn, SourceProcessingProperties = NULL, TargetProcessingProperties = NULL) {
  op <- new_operation(
    name = "CreateIntegrationResourceProperty",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_integration_resource_property_input(ResourceArn = ResourceArn, SourceProcessingProperties = SourceProcessingProperties, TargetProcessingProperties = TargetProcessingProperties)
  output <- .glue$create_integration_resource_property_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_integration_resource_property <- glue_create_integration_resource_property

#' This API is used to provide optional override properties for the the
#' tables that need to be replicated
#'
#' @description
#' This API is used to provide optional override properties for the the
#' tables that need to be replicated. These properties can include
#' properties for filtering and partitioning for the source and target
#' tables. To set both source and target properties the same API need to be
#' invoked with the Glue connection ARN as `ResourceArn` with
#' `SourceTableConfig`, and the Glue database ARN as `ResourceArn` with
#' `TargetTableConfig` respectively.
#'
#' @usage
#' glue_create_integration_table_properties(ResourceArn, TableName,
#'   SourceTableConfig, TargetTableConfig)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param TableName &#91;required&#93; The name of the table to be replicated.
#' @param SourceTableConfig A structure for the source table configuration.
#' @param TargetTableConfig A structure for the target table configuration.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_integration_table_properties(
#'   ResourceArn = "string",
#'   TableName = "string",
#'   SourceTableConfig = list(
#'     Fields = list(
#'       "string"
#'     ),
#'     FilterPredicate = "string",
#'     PrimaryKey = list(
#'       "string"
#'     ),
#'     RecordUpdateField = "string"
#'   ),
#'   TargetTableConfig = list(
#'     UnnestSpec = "TOPLEVEL"|"FULL"|"NOUNNEST",
#'     PartitionSpec = list(
#'       list(
#'         FieldName = "string",
#'         FunctionSpec = "string"
#'       )
#'     ),
#'     TargetTableName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_integration_table_properties
#'
#' @aliases glue_create_integration_table_properties
glue_create_integration_table_properties <- function(ResourceArn, TableName, SourceTableConfig = NULL, TargetTableConfig = NULL) {
  op <- new_operation(
    name = "CreateIntegrationTableProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_integration_table_properties_input(ResourceArn = ResourceArn, TableName = TableName, SourceTableConfig = SourceTableConfig, TargetTableConfig = TargetTableConfig)
  output <- .glue$create_integration_table_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_integration_table_properties <- glue_create_integration_table_properties

#' Creates a new job definition
#'
#' @description
#' Creates a new job definition.
#'
#' @usage
#' glue_create_job(Name, JobMode, JobRunQueuingEnabled, Description,
#'   LogUri, Role, ExecutionProperty, Command, DefaultArguments,
#'   NonOverridableArguments, Connections, MaxRetries, AllocatedCapacity,
#'   Timeout, MaxCapacity, SecurityConfiguration, Tags, NotificationProperty,
#'   GlueVersion, NumberOfWorkers, WorkerType, CodeGenConfigurationNodes,
#'   ExecutionClass, SourceControlDetails, MaintenanceWindow)
#'
#' @param Name &#91;required&#93; The name you assign to this job definition. It must be unique in your
#' account.
#' @param JobMode A mode that describes how a job was created. Valid values are:
#' 
#' -   `SCRIPT` - The job was created using the Glue Studio script editor.
#' 
#' -   `VISUAL` - The job was created using the Glue Studio visual editor.
#' 
#' -   `NOTEBOOK` - The job was created using an interactive sessions
#'     notebook.
#' 
#' When the `JobMode` field is missing or null, `SCRIPT` is assigned as the
#' default value.
#' @param JobRunQueuingEnabled Specifies whether job run queuing is enabled for the job runs for this
#' job.
#' 
#' A value of true means job run queuing is enabled for the job runs. If
#' false or not populated, the job runs will not be considered for
#' queueing.
#' 
#' If this field does not match the value set in the job run, then the
#' value from the job run field will be used.
#' @param Description Description of the job being defined.
#' @param LogUri This field is reserved for future use.
#' @param Role &#91;required&#93; The name or Amazon Resource Name (ARN) of the IAM role associated with
#' this job.
#' @param ExecutionProperty An `ExecutionProperty` specifying the maximum number of concurrent runs
#' allowed for this job.
#' @param Command &#91;required&#93; The `JobCommand` that runs this job.
#' @param DefaultArguments The default arguments for every run of this job, specified as name-value
#' pairs.
#' 
#' You can specify arguments here that your own job-execution script
#' consumes, as well as arguments that Glue itself consumes.
#' 
#' Job arguments may be logged. Do not pass plaintext secrets as arguments.
#' Retrieve secrets from a Glue Connection, Secrets Manager or other secret
#' management mechanism if you intend to keep them within the Job.
#' 
#' For information about how to specify and consume your own Job arguments,
#' see the [Calling Glue APIs in
#' Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html)
#' topic in the developer guide.
#' 
#' For information about the arguments you can provide to this field when
#' configuring Spark jobs, see the [Special Parameters Used by
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html)
#' topic in the developer guide.
#' 
#' For information about the arguments you can provide to this field when
#' configuring Ray jobs, see [Using job parameters in Ray
#' jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html)
#' in the developer guide.
#' @param NonOverridableArguments Arguments for this job that are not overridden when providing job
#' arguments in a job run, specified as name-value pairs.
#' @param Connections The connections used for this job.
#' @param MaxRetries The maximum number of times to retry this job if it fails.
#' @param AllocatedCapacity This parameter is deprecated. Use `MaxCapacity` instead.
#' 
#' The number of Glue data processing units (DPUs) to allocate to this Job.
#' You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a
#' relative measure of processing power that consists of 4 vCPUs of compute
#' capacity and 16 GB of memory. For more information, see the [Glue
#' pricing page](https://aws.amazon.com/glue/pricing/).
#' @param Timeout The job timeout in minutes. This is the maximum time that a job run can
#' consume resources before it is terminated and enters `TIMEOUT` status.
#' The default is 2,880 minutes (48 hours) for batch jobs.
#' 
#' Streaming jobs must have timeout values less than 7 days or 10080
#' minutes. When the value is left blank, the job will be restarted after 7
#' days based if you have not setup a maintenance window. If you have setup
#' maintenance window, it will be restarted during the maintenance window
#' after 7 days.
#' @param MaxCapacity For Glue version 1.0 or earlier jobs, using the standard worker type,
#' the number of Glue data processing units (DPUs) that can be allocated
#' when this job runs. A DPU is a relative measure of processing power that
#' consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
#' information, see the [Glue pricing
#' page](https://aws.amazon.com/glue/pricing/).
#' 
#' For Glue version 2.0+ jobs, you cannot specify a `Maximum capacity`.
#' Instead, you should specify a `Worker type` and the `Number of workers`.
#' 
#' Do not set `MaxCapacity` if using `WorkerType` and `NumberOfWorkers`.
#' 
#' The value that can be allocated for `MaxCapacity` depends on whether you
#' are running a Python shell job, an Apache Spark ETL job, or an Apache
#' Spark streaming ETL job:
#' 
#' -   When you specify a Python shell job
#'     (`JobCommand.Name`="pythonshell"), you can allocate either 0.0625 or
#'     1 DPU. The default is 0.0625 DPU.
#' 
#' -   When you specify an Apache Spark ETL job
#'     (`JobCommand.Name`="glueetl") or Apache Spark streaming ETL job
#'     (`JobCommand.Name`="gluestreaming"), you can allocate from 2 to 100
#'     DPUs. The default is 10 DPUs. This job type cannot have a fractional
#'     DPU allocation.
#' @param SecurityConfiguration The name of the `SecurityConfiguration` structure to be used with this
#' job.
#' @param Tags The tags to use with this job. You may use tags to limit access to the
#' job. For more information about tags in Glue, see [Amazon Web Services
#' Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in
#' the developer guide.
#' @param NotificationProperty Specifies configuration properties of a job notification.
#' @param GlueVersion In Spark jobs, `GlueVersion` determines the versions of Apache Spark and
#' Python that Glue available in a job. The Python version indicates the
#' version supported for jobs of type Spark.
#' 
#' Ray jobs should set `GlueVersion` to `4.0` or greater. However, the
#' versions of Ray, Python and additional libraries available in your Ray
#' job are determined by the `Runtime` parameter of the Job command.
#' 
#' For more information about the available Glue versions and corresponding
#' Spark and Python versions, see [Glue
#' version](https://docs.aws.amazon.com/glue/latest/dg/add-job.html) in the
#' developer guide.
#' 
#' Jobs that are created without specifying a Glue version default to Glue
#' 0.9.
#' @param NumberOfWorkers The number of workers of a defined `workerType` that are allocated when
#' a job runs.
#' @param WorkerType The type of predefined worker that is allocated when a job runs. Accepts
#' a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the
#' value Z.2X for Ray jobs.
#' 
#' -   For the `G.1X` worker type, each worker maps to 1 DPU (4 vCPUs, 16
#'     GB of memory) with 94GB disk, and provides 1 executor per worker. We
#'     recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.2X` worker type, each worker maps to 2 DPU (8 vCPUs, 32
#'     GB of memory) with 138GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.4X` worker type, each worker maps to 4 DPU (16 vCPUs, 64
#'     GB of memory) with 256GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs in the following Amazon Web Services Regions: US East
#'     (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific
#'     (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada
#'     (Central), Europe (Frankfurt), Europe (Ireland), and Europe
#'     (Stockholm).
#' 
#' -   For the `G.8X` worker type, each worker maps to 8 DPU (32 vCPUs, 128
#'     GB of memory) with 512GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs, in the same Amazon Web Services Regions as supported for
#'     the `G.4X` worker type.
#' 
#' -   For the `G.025X` worker type, each worker maps to 0.25 DPU (2 vCPUs,
#'     4 GB of memory) with 84GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for low volume streaming jobs. This
#'     worker type is only available for Glue version 3.0 or later
#'     streaming jobs.
#' 
#' -   For the `Z.2X` worker type, each worker maps to 2 M-DPU (8vCPUs, 64
#'     GB of memory) with 128 GB disk, and provides up to 8 Ray workers
#'     based on the autoscaler.
#' @param CodeGenConfigurationNodes The representation of a directed acyclic graph on which both the Glue
#' Studio visual component and Glue Studio code generation is based.
#' @param ExecutionClass Indicates whether the job is run with a standard or flexible execution
#' class. The standard execution-class is ideal for time-sensitive
#' workloads that require fast job startup and dedicated resources.
#' 
#' The flexible execution class is appropriate for time-insensitive jobs
#' whose start and completion times may vary.
#' 
#' Only jobs with Glue version 3.0 and above and command type `glueetl`
#' will be allowed to set `ExecutionClass` to `FLEX`. The flexible
#' execution class is available for Spark jobs.
#' @param SourceControlDetails The details for a source control configuration for a job, allowing
#' synchronization of job artifacts to or from a remote repository.
#' @param MaintenanceWindow This field specifies a day of the week and hour for a maintenance window
#' for streaming jobs. Glue periodically performs maintenance activities.
#' During these maintenance windows, Glue will need to restart your
#' streaming jobs.
#' 
#' Glue will restart the job within 3 hours of the specified maintenance
#' window. For instance, if you set up the maintenance window for Monday at
#' 10:00AM GMT, your jobs will be restarted between 10:00AM GMT to 1:00PM
#' GMT.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_job(
#'   Name = "string",
#'   JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'   JobRunQueuingEnabled = TRUE|FALSE,
#'   Description = "string",
#'   LogUri = "string",
#'   Role = "string",
#'   ExecutionProperty = list(
#'     MaxConcurrentRuns = 123
#'   ),
#'   Command = list(
#'     Name = "string",
#'     ScriptLocation = "string",
#'     PythonVersion = "string",
#'     Runtime = "string"
#'   ),
#'   DefaultArguments = list(
#'     "string"
#'   ),
#'   NonOverridableArguments = list(
#'     "string"
#'   ),
#'   Connections = list(
#'     Connections = list(
#'       "string"
#'     )
#'   ),
#'   MaxRetries = 123,
#'   AllocatedCapacity = 123,
#'   Timeout = 123,
#'   MaxCapacity = 123.0,
#'   SecurityConfiguration = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   NotificationProperty = list(
#'     NotifyDelayAfter = 123
#'   ),
#'   GlueVersion = "string",
#'   NumberOfWorkers = 123,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   CodeGenConfigurationNodes = list(
#'     list(
#'       AthenaConnectorSource = list(
#'         Name = "string",
#'         ConnectionName = "string",
#'         ConnectorName = "string",
#'         ConnectionType = "string",
#'         ConnectionTable = "string",
#'         SchemaName = "string",
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       JDBCConnectorSource = list(
#'         Name = "string",
#'         ConnectionName = "string",
#'         ConnectorName = "string",
#'         ConnectionType = "string",
#'         AdditionalOptions = list(
#'           FilterPredicate = "string",
#'           PartitionColumn = "string",
#'           LowerBound = 123,
#'           UpperBound = 123,
#'           NumPartitions = 123,
#'           JobBookmarkKeys = list(
#'             "string"
#'           ),
#'           JobBookmarkKeysSortOrder = "string",
#'           DataTypeMapping = list(
#'             "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE"
#'           )
#'         ),
#'         ConnectionTable = "string",
#'         Query = "string",
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SparkConnectorSource = list(
#'         Name = "string",
#'         ConnectionName = "string",
#'         ConnectorName = "string",
#'         ConnectionType = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       CatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       RedshiftSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         RedshiftTmpDir = "string",
#'         TmpDirIAMRole = "string"
#'       ),
#'       S3CatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         PartitionPredicate = "string",
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123
#'         )
#'       ),
#'       S3CsvSource = list(
#'         Name = "string",
#'         Paths = list(
#'           "string"
#'         ),
#'         CompressionType = "gzip"|"bzip2",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         GroupSize = "string",
#'         GroupFiles = "string",
#'         Recurse = TRUE|FALSE,
#'         MaxBand = 123,
#'         MaxFilesInBand = 123,
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123,
#'           EnableSamplePath = TRUE|FALSE,
#'           SamplePath = "string"
#'         ),
#'         Separator = "comma"|"ctrla"|"pipe"|"semicolon"|"tab",
#'         Escaper = "string",
#'         QuoteChar = "quote"|"quillemet"|"single_quote"|"disabled",
#'         Multiline = TRUE|FALSE,
#'         WithHeader = TRUE|FALSE,
#'         WriteHeader = TRUE|FALSE,
#'         SkipFirst = TRUE|FALSE,
#'         OptimizePerformance = TRUE|FALSE,
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3JsonSource = list(
#'         Name = "string",
#'         Paths = list(
#'           "string"
#'         ),
#'         CompressionType = "gzip"|"bzip2",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         GroupSize = "string",
#'         GroupFiles = "string",
#'         Recurse = TRUE|FALSE,
#'         MaxBand = 123,
#'         MaxFilesInBand = 123,
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123,
#'           EnableSamplePath = TRUE|FALSE,
#'           SamplePath = "string"
#'         ),
#'         JsonPath = "string",
#'         Multiline = TRUE|FALSE,
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3ParquetSource = list(
#'         Name = "string",
#'         Paths = list(
#'           "string"
#'         ),
#'         CompressionType = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         GroupSize = "string",
#'         GroupFiles = "string",
#'         Recurse = TRUE|FALSE,
#'         MaxBand = 123,
#'         MaxFilesInBand = 123,
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123,
#'           EnableSamplePath = TRUE|FALSE,
#'           SamplePath = "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       RelationalCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       DynamoDBCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       JDBCConnectorTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         ConnectionTable = "string",
#'         ConnectorName = "string",
#'         ConnectionType = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SparkConnectorTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         ConnectorName = "string",
#'         ConnectionType = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       CatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       RedshiftTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Database = "string",
#'         Table = "string",
#'         RedshiftTmpDir = "string",
#'         TmpDirIAMRole = "string",
#'         UpsertRedshiftOptions = list(
#'           TableLocation = "string",
#'           ConnectionName = "string",
#'           UpsertKeys = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       S3CatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Table = "string",
#'         Database = "string",
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'         )
#'       ),
#'       S3GlueParquetTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Path = "string",
#'         Compression = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'           Table = "string",
#'           Database = "string"
#'         )
#'       ),
#'       S3DirectTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Path = "string",
#'         Compression = "string",
#'         Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'           Table = "string",
#'           Database = "string"
#'         )
#'       ),
#'       ApplyMapping = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Mapping = list(
#'           list(
#'             ToKey = "string",
#'             FromPath = list(
#'               "string"
#'             ),
#'             FromType = "string",
#'             ToType = "string",
#'             Dropped = TRUE|FALSE,
#'             Children = list()
#'           )
#'         )
#'       ),
#'       SelectFields = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Paths = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       DropFields = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Paths = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       RenameField = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         SourcePath = list(
#'           "string"
#'         ),
#'         TargetPath = list(
#'           "string"
#'         )
#'       ),
#'       Spigot = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Path = "string",
#'         Topk = 123,
#'         Prob = 123.0
#'       ),
#'       Join = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         JoinType = "equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti",
#'         Columns = list(
#'           list(
#'             From = "string",
#'             Keys = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SplitFields = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Paths = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       SelectFromCollection = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Index = 123
#'       ),
#'       FillMissingValues = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         ImputedPath = "string",
#'         FilledPath = "string"
#'       ),
#'       Filter = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         LogicalOperator = "AND"|"OR",
#'         Filters = list(
#'           list(
#'             Operation = "EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL",
#'             Negated = TRUE|FALSE,
#'             Values = list(
#'               list(
#'                 Type = "COLUMNEXTRACTED"|"CONSTANT",
#'                 Value = list(
#'                   "string"
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       CustomCode = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Code = "string",
#'         ClassName = "string",
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SparkSQL = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         SqlQuery = "string",
#'         SqlAliases = list(
#'           list(
#'             From = "string",
#'             Alias = "string"
#'           )
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       DirectKinesisSource = list(
#'         Name = "string",
#'         WindowSize = 123,
#'         DetectSchema = TRUE|FALSE,
#'         StreamingOptions = list(
#'           EndpointUrl = "string",
#'           StreamName = "string",
#'           Classification = "string",
#'           Delimiter = "string",
#'           StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'           MaxFetchTimeInMs = 123,
#'           MaxFetchRecordsPerShard = 123,
#'           MaxRecordPerRead = 123,
#'           AddIdleTimeBetweenReads = TRUE|FALSE,
#'           IdleTimeBetweenReadsInMs = 123,
#'           DescribeShardInterval = 123,
#'           NumRetries = 123,
#'           RetryIntervalMs = 123,
#'           MaxRetryIntervalMs = 123,
#'           AvoidEmptyBatches = TRUE|FALSE,
#'           StreamArn = "string",
#'           RoleArn = "string",
#'           RoleSessionName = "string",
#'           AddRecordTimestamp = "string",
#'           EmitConsumerLagMetrics = "string",
#'           StartingTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         DataPreviewOptions = list(
#'           PollingTime = 123,
#'           RecordPollingLimit = 123
#'         )
#'       ),
#'       DirectKafkaSource = list(
#'         Name = "string",
#'         StreamingOptions = list(
#'           BootstrapServers = "string",
#'           SecurityProtocol = "string",
#'           ConnectionName = "string",
#'           TopicName = "string",
#'           Assign = "string",
#'           SubscribePattern = "string",
#'           Classification = "string",
#'           Delimiter = "string",
#'           StartingOffsets = "string",
#'           EndingOffsets = "string",
#'           PollTimeoutMs = 123,
#'           NumRetries = 123,
#'           RetryIntervalMs = 123,
#'           MaxOffsetsPerTrigger = 123,
#'           MinPartitions = 123,
#'           IncludeHeaders = TRUE|FALSE,
#'           AddRecordTimestamp = "string",
#'           EmitConsumerLagMetrics = "string",
#'           StartingTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         WindowSize = 123,
#'         DetectSchema = TRUE|FALSE,
#'         DataPreviewOptions = list(
#'           PollingTime = 123,
#'           RecordPollingLimit = 123
#'         )
#'       ),
#'       CatalogKinesisSource = list(
#'         Name = "string",
#'         WindowSize = 123,
#'         DetectSchema = TRUE|FALSE,
#'         Table = "string",
#'         Database = "string",
#'         StreamingOptions = list(
#'           EndpointUrl = "string",
#'           StreamName = "string",
#'           Classification = "string",
#'           Delimiter = "string",
#'           StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'           MaxFetchTimeInMs = 123,
#'           MaxFetchRecordsPerShard = 123,
#'           MaxRecordPerRead = 123,
#'           AddIdleTimeBetweenReads = TRUE|FALSE,
#'           IdleTimeBetweenReadsInMs = 123,
#'           DescribeShardInterval = 123,
#'           NumRetries = 123,
#'           RetryIntervalMs = 123,
#'           MaxRetryIntervalMs = 123,
#'           AvoidEmptyBatches = TRUE|FALSE,
#'           StreamArn = "string",
#'           RoleArn = "string",
#'           RoleSessionName = "string",
#'           AddRecordTimestamp = "string",
#'           EmitConsumerLagMetrics = "string",
#'           StartingTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         DataPreviewOptions = list(
#'           PollingTime = 123,
#'           RecordPollingLimit = 123
#'         )
#'       ),
#'       CatalogKafkaSource = list(
#'         Name = "string",
#'         WindowSize = 123,
#'         DetectSchema = TRUE|FALSE,
#'         Table = "string",
#'         Database = "string",
#'         StreamingOptions = list(
#'           BootstrapServers = "string",
#'           SecurityProtocol = "string",
#'           ConnectionName = "string",
#'           TopicName = "string",
#'           Assign = "string",
#'           SubscribePattern = "string",
#'           Classification = "string",
#'           Delimiter = "string",
#'           StartingOffsets = "string",
#'           EndingOffsets = "string",
#'           PollTimeoutMs = 123,
#'           NumRetries = 123,
#'           RetryIntervalMs = 123,
#'           MaxOffsetsPerTrigger = 123,
#'           MinPartitions = 123,
#'           IncludeHeaders = TRUE|FALSE,
#'           AddRecordTimestamp = "string",
#'           EmitConsumerLagMetrics = "string",
#'           StartingTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         DataPreviewOptions = list(
#'           PollingTime = 123,
#'           RecordPollingLimit = 123
#'         )
#'       ),
#'       DropNullFields = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         NullCheckBoxList = list(
#'           IsEmpty = TRUE|FALSE,
#'           IsNullString = TRUE|FALSE,
#'           IsNegOne = TRUE|FALSE
#'         ),
#'         NullTextList = list(
#'           list(
#'             Value = "string",
#'             Datatype = list(
#'               Id = "string",
#'               Label = "string"
#'             )
#'           )
#'         )
#'       ),
#'       Merge = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Source = "string",
#'         PrimaryKeys = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Union = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         UnionType = "ALL"|"DISTINCT"
#'       ),
#'       PIIDetection = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PiiType = "RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking",
#'         EntityTypesToDetect = list(
#'           "string"
#'         ),
#'         OutputColumnName = "string",
#'         SampleFraction = 123.0,
#'         ThresholdFraction = 123.0,
#'         MaskValue = "string"
#'       ),
#'       Aggregate = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Groups = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Aggs = list(
#'           list(
#'             Column = list(
#'               "string"
#'             ),
#'             AggFunc = "avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"
#'           )
#'         )
#'       ),
#'       DropDuplicates = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Columns = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       GovernedCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Table = "string",
#'         Database = "string",
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'         )
#'       ),
#'       GovernedCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         PartitionPredicate = "string",
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123
#'         )
#'       ),
#'       MicrosoftSQLServerCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       MySQLCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       OracleSQLCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       PostgreSQLCatalogSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       MicrosoftSQLServerCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       MySQLCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       OracleSQLCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       PostgreSQLCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Database = "string",
#'         Table = "string"
#'       ),
#'       DynamicTransform = list(
#'         Name = "string",
#'         TransformName = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Parameters = list(
#'           list(
#'             Name = "string",
#'             Type = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'             ValidationRule = "string",
#'             ValidationMessage = "string",
#'             Value = list(
#'               "string"
#'             ),
#'             ListType = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'             IsOptional = TRUE|FALSE
#'           )
#'         ),
#'         FunctionName = "string",
#'         Path = "string",
#'         Version = "string",
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       EvaluateDataQuality = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Ruleset = "string",
#'         Output = "PrimaryInput"|"EvaluationResults",
#'         PublishingOptions = list(
#'           EvaluationContext = "string",
#'           ResultsS3Prefix = "string",
#'           CloudWatchMetricsEnabled = TRUE|FALSE,
#'           ResultsPublishingEnabled = TRUE|FALSE
#'         ),
#'         StopJobOnFailureOptions = list(
#'           StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'         )
#'       ),
#'       S3CatalogHudiSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         AdditionalHudiOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       CatalogHudiSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         AdditionalHudiOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3HudiSource = list(
#'         Name = "string",
#'         Paths = list(
#'           "string"
#'         ),
#'         AdditionalHudiOptions = list(
#'           "string"
#'         ),
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123,
#'           EnableSamplePath = TRUE|FALSE,
#'           SamplePath = "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3HudiCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Table = "string",
#'         Database = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'         )
#'       ),
#'       S3HudiDirectTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         Path = "string",
#'         Compression = "gzip"|"lzo"|"uncompressed"|"snappy",
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'           Table = "string",
#'           Database = "string"
#'         )
#'       ),
#'       DirectJDBCSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         ConnectionName = "string",
#'         ConnectionType = "sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift",
#'         RedshiftTmpDir = "string"
#'       ),
#'       S3CatalogDeltaSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         AdditionalDeltaOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       CatalogDeltaSource = list(
#'         Name = "string",
#'         Database = "string",
#'         Table = "string",
#'         AdditionalDeltaOptions = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3DeltaSource = list(
#'         Name = "string",
#'         Paths = list(
#'           "string"
#'         ),
#'         AdditionalDeltaOptions = list(
#'           "string"
#'         ),
#'         AdditionalOptions = list(
#'           BoundedSize = 123,
#'           BoundedFiles = 123,
#'           EnableSamplePath = TRUE|FALSE,
#'           SamplePath = "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       S3DeltaCatalogTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Table = "string",
#'         Database = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'         )
#'       ),
#'       S3DeltaDirectTarget = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             "string"
#'           )
#'         ),
#'         Path = "string",
#'         Compression = "uncompressed"|"snappy",
#'         Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         SchemaChangePolicy = list(
#'           EnableUpdateCatalog = TRUE|FALSE,
#'           UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'           Table = "string",
#'           Database = "string"
#'         )
#'       ),
#'       AmazonRedshiftSource = list(
#'         Name = "string",
#'         Data = list(
#'           AccessType = "string",
#'           SourceType = "string",
#'           Connection = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Schema = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Table = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogDatabase = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogTable = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogRedshiftSchema = "string",
#'           CatalogRedshiftTable = "string",
#'           TempDir = "string",
#'           IamRole = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           AdvancedOptions = list(
#'             list(
#'               Key = "string",
#'               Value = "string"
#'             )
#'           ),
#'           SampleQuery = "string",
#'           PreAction = "string",
#'           PostAction = "string",
#'           Action = "string",
#'           TablePrefix = "string",
#'           Upsert = TRUE|FALSE,
#'           MergeAction = "string",
#'           MergeWhenMatched = "string",
#'           MergeWhenNotMatched = "string",
#'           MergeClause = "string",
#'           CrawlerConnection = "string",
#'           TableSchema = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           ),
#'           StagingTable = "string",
#'           SelectedColumns = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           )
#'         )
#'       ),
#'       AmazonRedshiftTarget = list(
#'         Name = "string",
#'         Data = list(
#'           AccessType = "string",
#'           SourceType = "string",
#'           Connection = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Schema = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Table = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogDatabase = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogTable = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           CatalogRedshiftSchema = "string",
#'           CatalogRedshiftTable = "string",
#'           TempDir = "string",
#'           IamRole = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           AdvancedOptions = list(
#'             list(
#'               Key = "string",
#'               Value = "string"
#'             )
#'           ),
#'           SampleQuery = "string",
#'           PreAction = "string",
#'           PostAction = "string",
#'           Action = "string",
#'           TablePrefix = "string",
#'           Upsert = TRUE|FALSE,
#'           MergeAction = "string",
#'           MergeWhenMatched = "string",
#'           MergeWhenNotMatched = "string",
#'           MergeClause = "string",
#'           CrawlerConnection = "string",
#'           TableSchema = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           ),
#'           StagingTable = "string",
#'           SelectedColumns = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           )
#'         ),
#'         Inputs = list(
#'           "string"
#'         )
#'       ),
#'       EvaluateDataQualityMultiFrame = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         AdditionalDataSources = list(
#'           "string"
#'         ),
#'         Ruleset = "string",
#'         PublishingOptions = list(
#'           EvaluationContext = "string",
#'           ResultsS3Prefix = "string",
#'           CloudWatchMetricsEnabled = TRUE|FALSE,
#'           ResultsPublishingEnabled = TRUE|FALSE
#'         ),
#'         AdditionalOptions = list(
#'           "string"
#'         ),
#'         StopJobOnFailureOptions = list(
#'           StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'         )
#'       ),
#'       Recipe = list(
#'         Name = "string",
#'         Inputs = list(
#'           "string"
#'         ),
#'         RecipeReference = list(
#'           RecipeArn = "string",
#'           RecipeVersion = "string"
#'         ),
#'         RecipeSteps = list(
#'           list(
#'             Action = list(
#'               Operation = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             ),
#'             ConditionExpressions = list(
#'               list(
#'                 Condition = "string",
#'                 Value = "string",
#'                 TargetColumn = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SnowflakeSource = list(
#'         Name = "string",
#'         Data = list(
#'           SourceType = "string",
#'           Connection = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Schema = "string",
#'           Table = "string",
#'           Database = "string",
#'           TempDir = "string",
#'           IamRole = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SampleQuery = "string",
#'           PreAction = "string",
#'           PostAction = "string",
#'           Action = "string",
#'           Upsert = TRUE|FALSE,
#'           MergeAction = "string",
#'           MergeWhenMatched = "string",
#'           MergeWhenNotMatched = "string",
#'           MergeClause = "string",
#'           StagingTable = "string",
#'           SelectedColumns = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           ),
#'           AutoPushdown = TRUE|FALSE,
#'           TableSchema = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           )
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       SnowflakeTarget = list(
#'         Name = "string",
#'         Data = list(
#'           SourceType = "string",
#'           Connection = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           Schema = "string",
#'           Table = "string",
#'           Database = "string",
#'           TempDir = "string",
#'           IamRole = list(
#'             Value = "string",
#'             Label = "string",
#'             Description = "string"
#'           ),
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SampleQuery = "string",
#'           PreAction = "string",
#'           PostAction = "string",
#'           Action = "string",
#'           Upsert = TRUE|FALSE,
#'           MergeAction = "string",
#'           MergeWhenMatched = "string",
#'           MergeWhenNotMatched = "string",
#'           MergeClause = "string",
#'           StagingTable = "string",
#'           SelectedColumns = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           ),
#'           AutoPushdown = TRUE|FALSE,
#'           TableSchema = list(
#'             list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             )
#'           )
#'         ),
#'         Inputs = list(
#'           "string"
#'         )
#'       ),
#'       ConnectorDataSource = list(
#'         Name = "string",
#'         ConnectionType = "string",
#'         Data = list(
#'           "string"
#'         ),
#'         OutputSchemas = list(
#'           list(
#'             Columns = list(
#'               list(
#'                 Name = "string",
#'                 Type = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       ConnectorDataTarget = list(
#'         Name = "string",
#'         ConnectionType = "string",
#'         Data = list(
#'           "string"
#'         ),
#'         Inputs = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ExecutionClass = "FLEX"|"STANDARD",
#'   SourceControlDetails = list(
#'     Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'     Repository = "string",
#'     Owner = "string",
#'     Branch = "string",
#'     Folder = "string",
#'     LastCommitId = "string",
#'     AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'     AuthToken = "string"
#'   ),
#'   MaintenanceWindow = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_job
#'
#' @aliases glue_create_job
glue_create_job <- function(Name, JobMode = NULL, JobRunQueuingEnabled = NULL, Description = NULL, LogUri = NULL, Role, ExecutionProperty = NULL, Command, DefaultArguments = NULL, NonOverridableArguments = NULL, Connections = NULL, MaxRetries = NULL, AllocatedCapacity = NULL, Timeout = NULL, MaxCapacity = NULL, SecurityConfiguration = NULL, Tags = NULL, NotificationProperty = NULL, GlueVersion = NULL, NumberOfWorkers = NULL, WorkerType = NULL, CodeGenConfigurationNodes = NULL, ExecutionClass = NULL, SourceControlDetails = NULL, MaintenanceWindow = NULL) {
  op <- new_operation(
    name = "CreateJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_job_input(Name = Name, JobMode = JobMode, JobRunQueuingEnabled = JobRunQueuingEnabled, Description = Description, LogUri = LogUri, Role = Role, ExecutionProperty = ExecutionProperty, Command = Command, DefaultArguments = DefaultArguments, NonOverridableArguments = NonOverridableArguments, Connections = Connections, MaxRetries = MaxRetries, AllocatedCapacity = AllocatedCapacity, Timeout = Timeout, MaxCapacity = MaxCapacity, SecurityConfiguration = SecurityConfiguration, Tags = Tags, NotificationProperty = NotificationProperty, GlueVersion = GlueVersion, NumberOfWorkers = NumberOfWorkers, WorkerType = WorkerType, CodeGenConfigurationNodes = CodeGenConfigurationNodes, ExecutionClass = ExecutionClass, SourceControlDetails = SourceControlDetails, MaintenanceWindow = MaintenanceWindow)
  output <- .glue$create_job_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_job <- glue_create_job

#' Creates an Glue machine learning transform
#'
#' @description
#' Creates an Glue machine learning transform. This operation creates the
#' transform and all the necessary parameters to train it.
#' 
#' Call this operation as the first step in the process of using a machine
#' learning transform (such as the `FindMatches` transform) for
#' deduplicating data. You can provide an optional `Description`, in
#' addition to the parameters that you want to use for your algorithm.
#' 
#' You must also specify certain parameters for the tasks that Glue runs on
#' your behalf as part of learning from your data and creating a
#' high-quality machine learning transform. These parameters include
#' `Role`, and optionally, `AllocatedCapacity`, `Timeout`, and
#' `MaxRetries`. For more information, see
#' [Jobs](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html).
#'
#' @usage
#' glue_create_ml_transform(Name, Description, InputRecordTables,
#'   Parameters, Role, GlueVersion, MaxCapacity, WorkerType, NumberOfWorkers,
#'   Timeout, MaxRetries, Tags, TransformEncryption)
#'
#' @param Name &#91;required&#93; The unique name that you give the transform when you create it.
#' @param Description A description of the machine learning transform that is being defined.
#' The default is an empty string.
#' @param InputRecordTables &#91;required&#93; A list of Glue table definitions used by the transform.
#' @param Parameters &#91;required&#93; The algorithmic parameters that are specific to the transform type used.
#' Conditionally dependent on the transform type.
#' @param Role &#91;required&#93; The name or Amazon Resource Name (ARN) of the IAM role with the required
#' permissions. The required permissions include both Glue service role
#' permissions to Glue resources, and Amazon S3 permissions required by the
#' transform.
#' 
#' -   This role needs Glue service role permissions to allow access to
#'     resources in Glue. See [Attach a Policy to IAM Users That Access
#'     Glue](https://docs.aws.amazon.com/glue/latest/dg/attach-policy-iam-user.html).
#' 
#' -   This role needs permission to your Amazon Simple Storage Service
#'     (Amazon S3) sources, targets, temporary directory, scripts, and any
#'     libraries used by the task run for this transform.
#' @param GlueVersion This value determines which version of Glue this machine learning
#' transform is compatible with. Glue 1.0 is recommended for most
#' customers. If the value is not set, the Glue compatibility defaults to
#' Glue 0.9. For more information, see [Glue
#' Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions)
#' in the developer guide.
#' @param MaxCapacity The number of Glue data processing units (DPUs) that are allocated to
#' task runs for this transform. You can allocate from 2 to 100 DPUs; the
#' default is 10. A DPU is a relative measure of processing power that
#' consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
#' information, see the [Glue pricing
#' page](https://aws.amazon.com/glue/pricing/).
#' 
#' `MaxCapacity` is a mutually exclusive option with `NumberOfWorkers` and
#' `WorkerType`.
#' 
#' -   If either `NumberOfWorkers` or `WorkerType` is set, then
#'     `MaxCapacity` cannot be set.
#' 
#' -   If `MaxCapacity` is set then neither `NumberOfWorkers` or
#'     `WorkerType` can be set.
#' 
#' -   If `WorkerType` is set, then `NumberOfWorkers` is required (and vice
#'     versa).
#' 
#' -   `MaxCapacity` and `NumberOfWorkers` must both be at least 1.
#' 
#' When the `WorkerType` field is set to a value other than `Standard`, the
#' `MaxCapacity` field is set automatically and becomes read-only.
#' 
#' When the `WorkerType` field is set to a value other than `Standard`, the
#' `MaxCapacity` field is set automatically and becomes read-only.
#' @param WorkerType The type of predefined worker that is allocated when this task runs.
#' Accepts a value of Standard, G.1X, or G.2X.
#' 
#' -   For the `Standard` worker type, each worker provides 4 vCPU, 16 GB
#'     of memory and a 50GB disk, and 2 executors per worker.
#' 
#' -   For the `G.1X` worker type, each worker provides 4 vCPU, 16 GB of
#'     memory and a 64GB disk, and 1 executor per worker.
#' 
#' -   For the `G.2X` worker type, each worker provides 8 vCPU, 32 GB of
#'     memory and a 128GB disk, and 1 executor per worker.
#' 
#' `MaxCapacity` is a mutually exclusive option with `NumberOfWorkers` and
#' `WorkerType`.
#' 
#' -   If either `NumberOfWorkers` or `WorkerType` is set, then
#'     `MaxCapacity` cannot be set.
#' 
#' -   If `MaxCapacity` is set then neither `NumberOfWorkers` or
#'     `WorkerType` can be set.
#' 
#' -   If `WorkerType` is set, then `NumberOfWorkers` is required (and vice
#'     versa).
#' 
#' -   `MaxCapacity` and `NumberOfWorkers` must both be at least 1.
#' @param NumberOfWorkers The number of workers of a defined `workerType` that are allocated when
#' this task runs.
#' 
#' If `WorkerType` is set, then `NumberOfWorkers` is required (and vice
#' versa).
#' @param Timeout The timeout of the task run for this transform in minutes. This is the
#' maximum time that a task run for this transform can consume resources
#' before it is terminated and enters `TIMEOUT` status. The default is
#' 2,880 minutes (48 hours).
#' @param MaxRetries The maximum number of times to retry a task for this transform after a
#' task run fails.
#' @param Tags The tags to use with this machine learning transform. You may use tags
#' to limit access to the machine learning transform. For more information
#' about tags in Glue, see [Amazon Web Services Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in
#' the developer guide.
#' @param TransformEncryption The encryption-at-rest settings of the transform that apply to accessing
#' user data. Machine learning transforms can access user data encrypted in
#' Amazon S3 using KMS.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_ml_transform(
#'   Name = "string",
#'   Description = "string",
#'   InputRecordTables = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Parameters = list(
#'     TransformType = "FIND_MATCHES",
#'     FindMatchesParameters = list(
#'       PrimaryKeyColumnName = "string",
#'       PrecisionRecallTradeoff = 123.0,
#'       AccuracyCostTradeoff = 123.0,
#'       EnforceProvidedLabels = TRUE|FALSE
#'     )
#'   ),
#'   Role = "string",
#'   GlueVersion = "string",
#'   MaxCapacity = 123.0,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   MaxRetries = 123,
#'   Tags = list(
#'     "string"
#'   ),
#'   TransformEncryption = list(
#'     MlUserDataEncryption = list(
#'       MlUserDataEncryptionMode = "DISABLED"|"SSE-KMS",
#'       KmsKeyId = "string"
#'     ),
#'     TaskRunSecurityConfigurationName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_ml_transform
#'
#' @aliases glue_create_ml_transform
glue_create_ml_transform <- function(Name, Description = NULL, InputRecordTables, Parameters, Role, GlueVersion = NULL, MaxCapacity = NULL, WorkerType = NULL, NumberOfWorkers = NULL, Timeout = NULL, MaxRetries = NULL, Tags = NULL, TransformEncryption = NULL) {
  op <- new_operation(
    name = "CreateMLTransform",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_ml_transform_input(Name = Name, Description = Description, InputRecordTables = InputRecordTables, Parameters = Parameters, Role = Role, GlueVersion = GlueVersion, MaxCapacity = MaxCapacity, WorkerType = WorkerType, NumberOfWorkers = NumberOfWorkers, Timeout = Timeout, MaxRetries = MaxRetries, Tags = Tags, TransformEncryption = TransformEncryption)
  output <- .glue$create_ml_transform_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_ml_transform <- glue_create_ml_transform

#' Creates a new partition
#'
#' @description
#' Creates a new partition.
#'
#' @usage
#' glue_create_partition(CatalogId, DatabaseName, TableName,
#'   PartitionInput)
#'
#' @param CatalogId The Amazon Web Services account ID of the catalog in which the partition
#' is to be created.
#' @param DatabaseName &#91;required&#93; The name of the metadata database in which the partition is to be
#' created.
#' @param TableName &#91;required&#93; The name of the metadata table in which the partition is to be created.
#' @param PartitionInput &#91;required&#93; A `PartitionInput` structure defining the partition to be created.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionInput = list(
#'     Values = list(
#'       "string"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_partition
#'
#' @aliases glue_create_partition
glue_create_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionInput) {
  op <- new_operation(
    name = "CreatePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionInput = PartitionInput)
  output <- .glue$create_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_partition <- glue_create_partition

#' Creates a specified partition index in an existing table
#'
#' @description
#' Creates a specified partition index in an existing table.
#'
#' @usage
#' glue_create_partition_index(CatalogId, DatabaseName, TableName,
#'   PartitionIndex)
#'
#' @param CatalogId The catalog ID where the table resides.
#' @param DatabaseName &#91;required&#93; Specifies the name of a database in which you want to create a partition
#' index.
#' @param TableName &#91;required&#93; Specifies the name of a table in which you want to create a partition
#' index.
#' @param PartitionIndex &#91;required&#93; Specifies a `PartitionIndex` structure to create a partition index in an
#' existing table.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_partition_index(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionIndex = list(
#'     Keys = list(
#'       "string"
#'     ),
#'     IndexName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_partition_index
#'
#' @aliases glue_create_partition_index
glue_create_partition_index <- function(CatalogId = NULL, DatabaseName, TableName, PartitionIndex) {
  op <- new_operation(
    name = "CreatePartitionIndex",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_partition_index_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionIndex = PartitionIndex)
  output <- .glue$create_partition_index_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_partition_index <- glue_create_partition_index

#' Creates a new registry which may be used to hold a collection of schemas
#'
#' @description
#' Creates a new registry which may be used to hold a collection of
#' schemas.
#'
#' @usage
#' glue_create_registry(RegistryName, Description, Tags)
#'
#' @param RegistryName &#91;required&#93; Name of the registry to be created of max length of 255, and may only
#' contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.
#' No whitespace.
#' @param Description A description of the registry. If description is not provided, there
#' will not be any default value for this.
#' @param Tags Amazon Web Services tags that contain a key value pair and may be
#' searched by console, command line, or API.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryArn = "string",
#'   RegistryName = "string",
#'   Description = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_registry(
#'   RegistryName = "string",
#'   Description = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_registry
#'
#' @aliases glue_create_registry
glue_create_registry <- function(RegistryName, Description = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateRegistry",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_registry_input(RegistryName = RegistryName, Description = Description, Tags = Tags)
  output <- .glue$create_registry_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_registry <- glue_create_registry

#' Creates a new schema set and registers the schema definition
#'
#' @description
#' Creates a new schema set and registers the schema definition. Returns an
#' error if the schema set already exists without actually registering the
#' version.
#' 
#' When the schema set is created, a version checkpoint will be set to the
#' first version. Compatibility mode "DISABLED" restricts any additional
#' schema versions from being added after the first schema version. For all
#' other compatibility modes, validation of compatibility settings will be
#' applied only from the second version onwards when the
#' [`register_schema_version`][glue_register_schema_version] API is used.
#' 
#' When this API is called without a `RegistryId`, this will create an
#' entry for a "default-registry" in the registry database tables, if it is
#' not already present.
#'
#' @usage
#' glue_create_schema(RegistryId, SchemaName, DataFormat, Compatibility,
#'   Description, Tags, SchemaDefinition)
#'
#' @param RegistryId This is a wrapper shape to contain the registry identity fields. If this
#' is not provided, the default registry will be used. The ARN format for
#' the same will be:
#' `arn:aws:glue:us-east-2:<customer id>:registry/default-registry:random-5-letter-id`.
#' @param SchemaName &#91;required&#93; Name of the schema to be created of max length of 255, and may only
#' contain letters, numbers, hyphen, underscore, dollar sign, or hash mark.
#' No whitespace.
#' @param DataFormat &#91;required&#93; The data format of the schema definition. Currently `AVRO`, `JSON` and
#' `PROTOBUF` are supported.
#' @param Compatibility The compatibility mode of the schema. The possible values are:
#' 
#' -   *NONE*: No compatibility mode applies. You can use this choice in
#'     development scenarios or if you do not know the compatibility mode
#'     that you want to apply to schemas. Any new version added will be
#'     accepted without undergoing a compatibility check.
#' 
#' -   *DISABLED*: This compatibility choice prevents versioning for a
#'     particular schema. You can use this choice to prevent future
#'     versioning of a schema.
#' 
#' -   *BACKWARD*: This compatibility choice is recommended as it allows
#'     data receivers to read both the current and one previous schema
#'     version. This means that for instance, a new schema version cannot
#'     drop data fields or change the type of these fields, so they can't
#'     be read by readers using the previous version.
#' 
#' -   *BACKWARD_ALL*: This compatibility choice allows data receivers to
#'     read both the current and all previous schema versions. You can use
#'     this choice when you need to delete fields or add optional fields,
#'     and check compatibility against all previous schema versions.
#' 
#' -   *FORWARD*: This compatibility choice allows data receivers to read
#'     both the current and one next schema version, but not necessarily
#'     later versions. You can use this choice when you need to add fields
#'     or delete optional fields, but only check compatibility against the
#'     last schema version.
#' 
#' -   *FORWARD_ALL*: This compatibility choice allows data receivers to
#'     read written by producers of any new registered schema. You can use
#'     this choice when you need to add fields or delete optional fields,
#'     and check compatibility against all previous schema versions.
#' 
#' -   *FULL*: This compatibility choice allows data receivers to read data
#'     written by producers using the previous or next version of the
#'     schema, but not necessarily earlier or later versions. You can use
#'     this choice when you need to add or remove optional fields, but only
#'     check compatibility against the last schema version.
#' 
#' -   *FULL_ALL*: This compatibility choice allows data receivers to read
#'     data written by producers using all previous schema versions. You
#'     can use this choice when you need to add or remove optional fields,
#'     and check compatibility against all previous schema versions.
#' @param Description An optional description of the schema. If description is not provided,
#' there will not be any automatic default value for this.
#' @param Tags Amazon Web Services tags that contain a key value pair and may be
#' searched by console, command line, or API. If specified, follows the
#' Amazon Web Services tags-on-create pattern.
#' @param SchemaDefinition The schema definition using the `DataFormat` setting for `SchemaName`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryName = "string",
#'   RegistryArn = "string",
#'   SchemaName = "string",
#'   SchemaArn = "string",
#'   Description = "string",
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   Compatibility = "NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL",
#'   SchemaCheckpoint = 123,
#'   LatestSchemaVersion = 123,
#'   NextSchemaVersion = 123,
#'   SchemaStatus = "AVAILABLE"|"PENDING"|"DELETING",
#'   Tags = list(
#'     "string"
#'   ),
#'   SchemaVersionId = "string",
#'   SchemaVersionStatus = "AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_schema(
#'   RegistryId = list(
#'     RegistryName = "string",
#'     RegistryArn = "string"
#'   ),
#'   SchemaName = "string",
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   Compatibility = "NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL",
#'   Description = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   SchemaDefinition = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_schema
#'
#' @aliases glue_create_schema
glue_create_schema <- function(RegistryId = NULL, SchemaName, DataFormat, Compatibility = NULL, Description = NULL, Tags = NULL, SchemaDefinition = NULL) {
  op <- new_operation(
    name = "CreateSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_schema_input(RegistryId = RegistryId, SchemaName = SchemaName, DataFormat = DataFormat, Compatibility = Compatibility, Description = Description, Tags = Tags, SchemaDefinition = SchemaDefinition)
  output <- .glue$create_schema_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_schema <- glue_create_schema

#' Transforms a directed acyclic graph (DAG) into code
#'
#' @description
#' Transforms a directed acyclic graph (DAG) into code.
#'
#' @usage
#' glue_create_script(DagNodes, DagEdges, Language)
#'
#' @param DagNodes A list of the nodes in the DAG.
#' @param DagEdges A list of the edges in the DAG.
#' @param Language The programming language of the resulting code from the DAG.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PythonScript = "string",
#'   ScalaCode = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_script(
#'   DagNodes = list(
#'     list(
#'       Id = "string",
#'       NodeType = "string",
#'       Args = list(
#'         list(
#'           Name = "string",
#'           Value = "string",
#'           Param = TRUE|FALSE
#'         )
#'       ),
#'       LineNumber = 123
#'     )
#'   ),
#'   DagEdges = list(
#'     list(
#'       Source = "string",
#'       Target = "string",
#'       TargetParameter = "string"
#'     )
#'   ),
#'   Language = "PYTHON"|"SCALA"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_script
#'
#' @aliases glue_create_script
glue_create_script <- function(DagNodes = NULL, DagEdges = NULL, Language = NULL) {
  op <- new_operation(
    name = "CreateScript",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_script_input(DagNodes = DagNodes, DagEdges = DagEdges, Language = Language)
  output <- .glue$create_script_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_script <- glue_create_script

#' Creates a new security configuration
#'
#' @description
#' Creates a new security configuration. A security configuration is a set
#' of security properties that can be used by Glue. You can use a security
#' configuration to encrypt data at rest. For information about using
#' security configurations in Glue, see [Encrypting Data Written by
#' Crawlers, Jobs, and Development
#' Endpoints](https://docs.aws.amazon.com/glue/latest/dg/encryption-security-configuration.html).
#'
#' @usage
#' glue_create_security_configuration(Name, EncryptionConfiguration)
#'
#' @param Name &#91;required&#93; The name for the new security configuration.
#' @param EncryptionConfiguration &#91;required&#93; The encryption configuration for the new security configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   CreatedTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_security_configuration(
#'   Name = "string",
#'   EncryptionConfiguration = list(
#'     S3Encryption = list(
#'       list(
#'         S3EncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-S3",
#'         KmsKeyArn = "string"
#'       )
#'     ),
#'     CloudWatchEncryption = list(
#'       CloudWatchEncryptionMode = "DISABLED"|"SSE-KMS",
#'       KmsKeyArn = "string"
#'     ),
#'     JobBookmarksEncryption = list(
#'       JobBookmarksEncryptionMode = "DISABLED"|"CSE-KMS",
#'       KmsKeyArn = "string"
#'     ),
#'     DataQualityEncryption = list(
#'       DataQualityEncryptionMode = "DISABLED"|"SSE-KMS",
#'       KmsKeyArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_security_configuration
#'
#' @aliases glue_create_security_configuration
glue_create_security_configuration <- function(Name, EncryptionConfiguration) {
  op <- new_operation(
    name = "CreateSecurityConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_security_configuration_input(Name = Name, EncryptionConfiguration = EncryptionConfiguration)
  output <- .glue$create_security_configuration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_security_configuration <- glue_create_security_configuration

#' Creates a new session
#'
#' @description
#' Creates a new session.
#'
#' @usage
#' glue_create_session(Id, Description, Role, Command, Timeout,
#'   IdleTimeout, DefaultArguments, Connections, MaxCapacity,
#'   NumberOfWorkers, WorkerType, SecurityConfiguration, GlueVersion, Tags,
#'   RequestOrigin)
#'
#' @param Id &#91;required&#93; The ID of the session request.
#' @param Description The description of the session.
#' @param Role &#91;required&#93; The IAM Role ARN
#' @param Command &#91;required&#93; The `SessionCommand` that runs the job.
#' @param Timeout The number of minutes before session times out. Default for Spark ETL
#' jobs is 48 hours (2880 minutes), the maximum session lifetime for this
#' job type. Consult the documentation for other job types.
#' @param IdleTimeout The number of minutes when idle before session times out. Default for
#' Spark ETL jobs is value of Timeout. Consult the documentation for other
#' job types.
#' @param DefaultArguments A map array of key-value pairs. Max is 75 pairs.
#' @param Connections The number of connections to use for the session.
#' @param MaxCapacity The number of Glue data processing units (DPUs) that can be allocated
#' when the job runs. A DPU is a relative measure of processing power that
#' consists of 4 vCPUs of compute capacity and 16 GB memory.
#' @param NumberOfWorkers The number of workers of a defined `WorkerType` to use for the session.
#' @param WorkerType The type of predefined worker that is allocated when a job runs. Accepts
#' a value of G.1X, G.2X, G.4X, or G.8X for Spark jobs. Accepts the value
#' Z.2X for Ray notebooks.
#' 
#' -   For the `G.1X` worker type, each worker maps to 1 DPU (4 vCPUs, 16
#'     GB of memory) with 94GB disk, and provides 1 executor per worker. We
#'     recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.2X` worker type, each worker maps to 2 DPU (8 vCPUs, 32
#'     GB of memory) with 138GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.4X` worker type, each worker maps to 4 DPU (16 vCPUs, 64
#'     GB of memory) with 256GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs in the following Amazon Web Services Regions: US East
#'     (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific
#'     (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada
#'     (Central), Europe (Frankfurt), Europe (Ireland), and Europe
#'     (Stockholm).
#' 
#' -   For the `G.8X` worker type, each worker maps to 8 DPU (32 vCPUs, 128
#'     GB of memory) with 512GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs, in the same Amazon Web Services Regions as supported for
#'     the `G.4X` worker type.
#' 
#' -   For the `Z.2X` worker type, each worker maps to 2 M-DPU (8vCPUs, 64
#'     GB of memory) with 128 GB disk, and provides up to 8 Ray workers
#'     based on the autoscaler.
#' @param SecurityConfiguration The name of the SecurityConfiguration structure to be used with the
#' session
#' @param GlueVersion The Glue version determines the versions of Apache Spark and Python that
#' Glue supports. The GlueVersion must be greater than 2.0.
#' @param Tags The map of key value pairs (tags) belonging to the session.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Session = list(
#'     Id = "string",
#'     CreatedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Status = "PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED",
#'     ErrorMessage = "string",
#'     Description = "string",
#'     Role = "string",
#'     Command = list(
#'       Name = "string",
#'       PythonVersion = "string"
#'     ),
#'     DefaultArguments = list(
#'       "string"
#'     ),
#'     Connections = list(
#'       Connections = list(
#'         "string"
#'       )
#'     ),
#'     Progress = 123.0,
#'     MaxCapacity = 123.0,
#'     SecurityConfiguration = "string",
#'     GlueVersion = "string",
#'     NumberOfWorkers = 123,
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     CompletedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExecutionTime = 123.0,
#'     DPUSeconds = 123.0,
#'     IdleTimeout = 123,
#'     ProfileName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_session(
#'   Id = "string",
#'   Description = "string",
#'   Role = "string",
#'   Command = list(
#'     Name = "string",
#'     PythonVersion = "string"
#'   ),
#'   Timeout = 123,
#'   IdleTimeout = 123,
#'   DefaultArguments = list(
#'     "string"
#'   ),
#'   Connections = list(
#'     Connections = list(
#'       "string"
#'     )
#'   ),
#'   MaxCapacity = 123.0,
#'   NumberOfWorkers = 123,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   SecurityConfiguration = "string",
#'   GlueVersion = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_session
#'
#' @aliases glue_create_session
glue_create_session <- function(Id, Description = NULL, Role, Command, Timeout = NULL, IdleTimeout = NULL, DefaultArguments = NULL, Connections = NULL, MaxCapacity = NULL, NumberOfWorkers = NULL, WorkerType = NULL, SecurityConfiguration = NULL, GlueVersion = NULL, Tags = NULL, RequestOrigin = NULL) {
  op <- new_operation(
    name = "CreateSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_session_input(Id = Id, Description = Description, Role = Role, Command = Command, Timeout = Timeout, IdleTimeout = IdleTimeout, DefaultArguments = DefaultArguments, Connections = Connections, MaxCapacity = MaxCapacity, NumberOfWorkers = NumberOfWorkers, WorkerType = WorkerType, SecurityConfiguration = SecurityConfiguration, GlueVersion = GlueVersion, Tags = Tags, RequestOrigin = RequestOrigin)
  output <- .glue$create_session_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_session <- glue_create_session

#' Creates a new table definition in the Data Catalog
#'
#' @description
#' Creates a new table definition in the Data Catalog.
#'
#' @usage
#' glue_create_table(CatalogId, DatabaseName, TableInput, PartitionIndexes,
#'   TransactionId, OpenTableFormatInput)
#'
#' @param CatalogId The ID of the Data Catalog in which to create the `Table`. If none is
#' supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The catalog database in which to create the new table. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableInput &#91;required&#93; The `TableInput` object that defines the metadata table to create in the
#' catalog.
#' @param PartitionIndexes A list of partition indexes, `PartitionIndex` structures, to create in
#' the table.
#' @param TransactionId The ID of the transaction.
#' @param OpenTableFormatInput Specifies an `OpenTableFormatInput` structure when creating an open
#' format table.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableInput = list(
#'     Name = "string",
#'     Description = "string",
#'     Owner = "string",
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     TargetTable = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Name = "string",
#'       Region = "string"
#'     ),
#'     ViewDefinition = list(
#'       IsProtected = TRUE|FALSE,
#'       Definer = "string",
#'       Representations = list(
#'         list(
#'           Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'           DialectVersion = "string",
#'           ViewOriginalText = "string",
#'           ValidationConnection = "string",
#'           ViewExpandedText = "string"
#'         )
#'       ),
#'       SubObjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   PartitionIndexes = list(
#'     list(
#'       Keys = list(
#'         "string"
#'       ),
#'       IndexName = "string"
#'     )
#'   ),
#'   TransactionId = "string",
#'   OpenTableFormatInput = list(
#'     IcebergInput = list(
#'       MetadataOperation = "CREATE",
#'       Version = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_table
#'
#' @aliases glue_create_table
glue_create_table <- function(CatalogId = NULL, DatabaseName, TableInput, PartitionIndexes = NULL, TransactionId = NULL, OpenTableFormatInput = NULL) {
  op <- new_operation(
    name = "CreateTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableInput = TableInput, PartitionIndexes = PartitionIndexes, TransactionId = TransactionId, OpenTableFormatInput = OpenTableFormatInput)
  output <- .glue$create_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_table <- glue_create_table

#' Creates a new table optimizer for a specific function
#'
#' @description
#' Creates a new table optimizer for a specific function.
#'
#' @usage
#' glue_create_table_optimizer(CatalogId, DatabaseName, TableName, Type,
#'   TableOptimizerConfiguration)
#'
#' @param CatalogId &#91;required&#93; The Catalog ID of the table.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param Type &#91;required&#93; The type of table optimizer.
#' @param TableOptimizerConfiguration &#91;required&#93; A `TableOptimizerConfiguration` object representing the configuration of
#' a table optimizer.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_table_optimizer(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Type = "compaction"|"retention"|"orphan_file_deletion",
#'   TableOptimizerConfiguration = list(
#'     roleArn = "string",
#'     enabled = TRUE|FALSE,
#'     vpcConfiguration = list(
#'       glueConnectionName = "string"
#'     ),
#'     retentionConfiguration = list(
#'       icebergConfiguration = list(
#'         snapshotRetentionPeriodInDays = 123,
#'         numberOfSnapshotsToRetain = 123,
#'         cleanExpiredFiles = TRUE|FALSE
#'       )
#'     ),
#'     orphanFileDeletionConfiguration = list(
#'       icebergConfiguration = list(
#'         orphanFileRetentionPeriodInDays = 123,
#'         location = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_table_optimizer
#'
#' @aliases glue_create_table_optimizer
glue_create_table_optimizer <- function(CatalogId, DatabaseName, TableName, Type, TableOptimizerConfiguration) {
  op <- new_operation(
    name = "CreateTableOptimizer",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_table_optimizer_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Type = Type, TableOptimizerConfiguration = TableOptimizerConfiguration)
  output <- .glue$create_table_optimizer_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_table_optimizer <- glue_create_table_optimizer

#' Creates a new trigger
#'
#' @description
#' Creates a new trigger.
#' 
#' Job arguments may be logged. Do not pass plaintext secrets as arguments.
#' Retrieve secrets from a Glue Connection, Amazon Web Services Secrets
#' Manager or other secret management mechanism if you intend to keep them
#' within the Job.
#'
#' @usage
#' glue_create_trigger(Name, WorkflowName, Type, Schedule, Predicate,
#'   Actions, Description, StartOnCreation, Tags, EventBatchingCondition)
#'
#' @param Name &#91;required&#93; The name of the trigger.
#' @param WorkflowName The name of the workflow associated with the trigger.
#' @param Type &#91;required&#93; The type of the new trigger.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based
#' Schedules for Jobs and
#' Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html).
#' For example, to run something every day at 12:15 UTC, you would specify:
#' `cron(15 12 * * ? *)`.
#' 
#' This field is required when the trigger type is SCHEDULED.
#' @param Predicate A predicate to specify when the new trigger should fire.
#' 
#' This field is required when the trigger type is `CONDITIONAL`.
#' @param Actions &#91;required&#93; The actions initiated by this trigger when it fires.
#' @param Description A description of the new trigger.
#' @param StartOnCreation Set to `true` to start `SCHEDULED` and `CONDITIONAL` triggers when
#' created. True is not supported for `ON_DEMAND` triggers.
#' @param Tags The tags to use with this trigger. You may use tags to limit access to
#' the trigger. For more information about tags in Glue, see [Amazon Web
#' Services Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html) in
#' the developer guide.
#' @param EventBatchingCondition Batch condition that must be met (specified number of events received or
#' batch time window expired) before EventBridge event trigger fires.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_trigger(
#'   Name = "string",
#'   WorkflowName = "string",
#'   Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'   Schedule = "string",
#'   Predicate = list(
#'     Logical = "AND"|"ANY",
#'     Conditions = list(
#'       list(
#'         LogicalOperator = "EQUALS",
#'         JobName = "string",
#'         State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'         CrawlerName = "string",
#'         CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'       )
#'     )
#'   ),
#'   Actions = list(
#'     list(
#'       JobName = "string",
#'       Arguments = list(
#'         "string"
#'       ),
#'       Timeout = 123,
#'       SecurityConfiguration = "string",
#'       NotificationProperty = list(
#'         NotifyDelayAfter = 123
#'       ),
#'       CrawlerName = "string"
#'     )
#'   ),
#'   Description = "string",
#'   StartOnCreation = TRUE|FALSE,
#'   Tags = list(
#'     "string"
#'   ),
#'   EventBatchingCondition = list(
#'     BatchSize = 123,
#'     BatchWindow = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_trigger
#'
#' @aliases glue_create_trigger
glue_create_trigger <- function(Name, WorkflowName = NULL, Type, Schedule = NULL, Predicate = NULL, Actions, Description = NULL, StartOnCreation = NULL, Tags = NULL, EventBatchingCondition = NULL) {
  op <- new_operation(
    name = "CreateTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_trigger_input(Name = Name, WorkflowName = WorkflowName, Type = Type, Schedule = Schedule, Predicate = Predicate, Actions = Actions, Description = Description, StartOnCreation = StartOnCreation, Tags = Tags, EventBatchingCondition = EventBatchingCondition)
  output <- .glue$create_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_trigger <- glue_create_trigger

#' Creates an Glue usage profile
#'
#' @description
#' Creates an Glue usage profile.
#'
#' @usage
#' glue_create_usage_profile(Name, Description, Configuration, Tags)
#'
#' @param Name &#91;required&#93; The name of the usage profile.
#' @param Description A description of the usage profile.
#' @param Configuration &#91;required&#93; A `ProfileConfiguration` object specifying the job and session values
#' for the profile.
#' @param Tags A list of tags applied to the usage profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_usage_profile(
#'   Name = "string",
#'   Description = "string",
#'   Configuration = list(
#'     SessionConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     ),
#'     JobConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_usage_profile
#'
#' @aliases glue_create_usage_profile
glue_create_usage_profile <- function(Name, Description = NULL, Configuration, Tags = NULL) {
  op <- new_operation(
    name = "CreateUsageProfile",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_usage_profile_input(Name = Name, Description = Description, Configuration = Configuration, Tags = Tags)
  output <- .glue$create_usage_profile_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_usage_profile <- glue_create_usage_profile

#' Creates a new function definition in the Data Catalog
#'
#' @description
#' Creates a new function definition in the Data Catalog.
#'
#' @usage
#' glue_create_user_defined_function(CatalogId, DatabaseName,
#'   FunctionInput)
#'
#' @param CatalogId The ID of the Data Catalog in which to create the function. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which to create the function.
#' @param FunctionInput &#91;required&#93; A `FunctionInput` object that defines the function to create in the Data
#' Catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionInput = list(
#'     FunctionName = "string",
#'     ClassName = "string",
#'     OwnerName = "string",
#'     OwnerType = "USER"|"ROLE"|"GROUP",
#'     ResourceUris = list(
#'       list(
#'         ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'         Uri = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_user_defined_function
#'
#' @aliases glue_create_user_defined_function
glue_create_user_defined_function <- function(CatalogId = NULL, DatabaseName, FunctionInput) {
  op <- new_operation(
    name = "CreateUserDefinedFunction",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_user_defined_function_input(CatalogId = CatalogId, DatabaseName = DatabaseName, FunctionInput = FunctionInput)
  output <- .glue$create_user_defined_function_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_user_defined_function <- glue_create_user_defined_function

#' Creates a new workflow
#'
#' @description
#' Creates a new workflow.
#'
#' @usage
#' glue_create_workflow(Name, Description, DefaultRunProperties, Tags,
#'   MaxConcurrentRuns)
#'
#' @param Name &#91;required&#93; The name to be assigned to the workflow. It should be unique within your
#' account.
#' @param Description A description of the workflow.
#' @param DefaultRunProperties A collection of properties to be used as part of each execution of the
#' workflow.
#' 
#' Run properties may be logged. Do not pass plaintext secrets as
#' properties. Retrieve secrets from a Glue Connection, Amazon Web Services
#' Secrets Manager or other secret management mechanism if you intend to
#' use them within the workflow run.
#' @param Tags The tags to be used with this workflow.
#' @param MaxConcurrentRuns You can use this parameter to prevent unwanted multiple updates to data,
#' to control costs, or in some cases, to prevent exceeding the maximum
#' number of concurrent runs of any of the component jobs. If you leave
#' this parameter blank, there is no limit to the number of concurrent
#' workflow runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_workflow(
#'   Name = "string",
#'   Description = "string",
#'   DefaultRunProperties = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   ),
#'   MaxConcurrentRuns = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_create_workflow
#'
#' @aliases glue_create_workflow
glue_create_workflow <- function(Name, Description = NULL, DefaultRunProperties = NULL, Tags = NULL, MaxConcurrentRuns = NULL) {
  op <- new_operation(
    name = "CreateWorkflow",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$create_workflow_input(Name = Name, Description = Description, DefaultRunProperties = DefaultRunProperties, Tags = Tags, MaxConcurrentRuns = MaxConcurrentRuns)
  output <- .glue$create_workflow_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$create_workflow <- glue_create_workflow

#' Deletes an existing blueprint
#'
#' @description
#' Deletes an existing blueprint.
#'
#' @usage
#' glue_delete_blueprint(Name)
#'
#' @param Name &#91;required&#93; The name of the blueprint to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_blueprint(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_blueprint
#'
#' @aliases glue_delete_blueprint
glue_delete_blueprint <- function(Name) {
  op <- new_operation(
    name = "DeleteBlueprint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_blueprint_input(Name = Name)
  output <- .glue$delete_blueprint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_blueprint <- glue_delete_blueprint

#' Removes the specified catalog from the Glue Data Catalog
#'
#' @description
#' Removes the specified catalog from the Glue Data Catalog.
#' 
#' After completing this operation, you no longer have access to the
#' databases, tables (and all table versions and partitions that might
#' belong to the tables) and the user-defined functions in the deleted
#' catalog. Glue deletes these "orphaned" resources asynchronously in a
#' timely manner, at the discretion of the service.
#' 
#' To ensure the immediate deletion of all related resources before calling
#' the [`delete_catalog`][glue_delete_catalog] operation, use
#' [`delete_table_version`][glue_delete_table_version] (or
#' [`batch_delete_table_version`][glue_batch_delete_table_version]),
#' [`delete_partition`][glue_delete_partition] (or
#' [`batch_delete_partition`][glue_batch_delete_partition]),
#' [`delete_table`][glue_delete_table] (or
#' [`batch_delete_table`][glue_batch_delete_table]),
#' [`delete_user_defined_function`][glue_delete_user_defined_function] and
#' [`delete_database`][glue_delete_database] to delete any resources that
#' belong to the catalog.
#'
#' @usage
#' glue_delete_catalog(CatalogId)
#'
#' @param CatalogId &#91;required&#93; The ID of the catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_catalog(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_catalog
#'
#' @aliases glue_delete_catalog
glue_delete_catalog <- function(CatalogId) {
  op <- new_operation(
    name = "DeleteCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_catalog_input(CatalogId = CatalogId)
  output <- .glue$delete_catalog_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_catalog <- glue_delete_catalog

#' Removes a classifier from the Data Catalog
#'
#' @description
#' Removes a classifier from the Data Catalog.
#'
#' @usage
#' glue_delete_classifier(Name)
#'
#' @param Name &#91;required&#93; Name of the classifier to remove.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_classifier(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_classifier
#'
#' @aliases glue_delete_classifier
glue_delete_classifier <- function(Name) {
  op <- new_operation(
    name = "DeleteClassifier",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_classifier_input(Name = Name)
  output <- .glue$delete_classifier_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_classifier <- glue_delete_classifier

#' Delete the partition column statistics of a column
#'
#' @description
#' Delete the partition column statistics of a column.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`delete_partition`][glue_delete_partition].
#'
#' @usage
#' glue_delete_column_statistics_for_partition(CatalogId, DatabaseName,
#'   TableName, PartitionValues, ColumnName)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param PartitionValues &#91;required&#93; A list of partition values identifying the partition.
#' @param ColumnName &#91;required&#93; Name of the column.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_column_statistics_for_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   ),
#'   ColumnName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_column_statistics_for_partition
#'
#' @aliases glue_delete_column_statistics_for_partition
glue_delete_column_statistics_for_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValues, ColumnName) {
  op <- new_operation(
    name = "DeleteColumnStatisticsForPartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_column_statistics_for_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues, ColumnName = ColumnName)
  output <- .glue$delete_column_statistics_for_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_column_statistics_for_partition <- glue_delete_column_statistics_for_partition

#' Retrieves table statistics of columns
#'
#' @description
#' Retrieves table statistics of columns.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`delete_table`][glue_delete_table].
#'
#' @usage
#' glue_delete_column_statistics_for_table(CatalogId, DatabaseName,
#'   TableName, ColumnName)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param ColumnName &#91;required&#93; The name of the column.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_column_statistics_for_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   ColumnName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_column_statistics_for_table
#'
#' @aliases glue_delete_column_statistics_for_table
glue_delete_column_statistics_for_table <- function(CatalogId = NULL, DatabaseName, TableName, ColumnName) {
  op <- new_operation(
    name = "DeleteColumnStatisticsForTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_column_statistics_for_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, ColumnName = ColumnName)
  output <- .glue$delete_column_statistics_for_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_column_statistics_for_table <- glue_delete_column_statistics_for_table

#' Deletes settings for a column statistics task
#'
#' @description
#' Deletes settings for a column statistics task.
#'
#' @usage
#' glue_delete_column_statistics_task_settings(DatabaseName, TableName)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to delete column statistics.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_column_statistics_task_settings(
#'   DatabaseName = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_column_statistics_task_settings
#'
#' @aliases glue_delete_column_statistics_task_settings
glue_delete_column_statistics_task_settings <- function(DatabaseName, TableName) {
  op <- new_operation(
    name = "DeleteColumnStatisticsTaskSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_column_statistics_task_settings_input(DatabaseName = DatabaseName, TableName = TableName)
  output <- .glue$delete_column_statistics_task_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_column_statistics_task_settings <- glue_delete_column_statistics_task_settings

#' Deletes a connection from the Data Catalog
#'
#' @description
#' Deletes a connection from the Data Catalog.
#'
#' @usage
#' glue_delete_connection(CatalogId, ConnectionName)
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param ConnectionName &#91;required&#93; The name of the connection to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_connection(
#'   CatalogId = "string",
#'   ConnectionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_connection
#'
#' @aliases glue_delete_connection
glue_delete_connection <- function(CatalogId = NULL, ConnectionName) {
  op <- new_operation(
    name = "DeleteConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_connection_input(CatalogId = CatalogId, ConnectionName = ConnectionName)
  output <- .glue$delete_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_connection <- glue_delete_connection

#' Removes a specified crawler from the Glue Data Catalog, unless the
#' crawler state is RUNNING
#'
#' @description
#' Removes a specified crawler from the Glue Data Catalog, unless the
#' crawler state is `RUNNING`.
#'
#' @usage
#' glue_delete_crawler(Name)
#'
#' @param Name &#91;required&#93; The name of the crawler to remove.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_crawler
#'
#' @aliases glue_delete_crawler
glue_delete_crawler <- function(Name) {
  op <- new_operation(
    name = "DeleteCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_crawler_input(Name = Name)
  output <- .glue$delete_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_crawler <- glue_delete_crawler

#' Deletes a custom pattern by specifying its name
#'
#' @description
#' Deletes a custom pattern by specifying its name.
#'
#' @usage
#' glue_delete_custom_entity_type(Name)
#'
#' @param Name &#91;required&#93; The name of the custom pattern that you want to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_custom_entity_type(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_custom_entity_type
#'
#' @aliases glue_delete_custom_entity_type
glue_delete_custom_entity_type <- function(Name) {
  op <- new_operation(
    name = "DeleteCustomEntityType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_custom_entity_type_input(Name = Name)
  output <- .glue$delete_custom_entity_type_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_custom_entity_type <- glue_delete_custom_entity_type

#' Deletes a data quality ruleset
#'
#' @description
#' Deletes a data quality ruleset.
#'
#' @usage
#' glue_delete_data_quality_ruleset(Name)
#'
#' @param Name &#91;required&#93; A name for the data quality ruleset.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_quality_ruleset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_data_quality_ruleset
#'
#' @aliases glue_delete_data_quality_ruleset
glue_delete_data_quality_ruleset <- function(Name) {
  op <- new_operation(
    name = "DeleteDataQualityRuleset",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_data_quality_ruleset_input(Name = Name)
  output <- .glue$delete_data_quality_ruleset_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_data_quality_ruleset <- glue_delete_data_quality_ruleset

#' Removes a specified database from a Data Catalog
#'
#' @description
#' Removes a specified database from a Data Catalog.
#' 
#' After completing this operation, you no longer have access to the tables
#' (and all table versions and partitions that might belong to the tables)
#' and the user-defined functions in the deleted database. Glue deletes
#' these "orphaned" resources asynchronously in a timely manner, at the
#' discretion of the service.
#' 
#' To ensure the immediate deletion of all related resources, before
#' calling [`delete_database`][glue_delete_database], use
#' [`delete_table_version`][glue_delete_table_version] or
#' [`batch_delete_table_version`][glue_batch_delete_table_version],
#' [`delete_partition`][glue_delete_partition] or
#' [`batch_delete_partition`][glue_batch_delete_partition],
#' [`delete_user_defined_function`][glue_delete_user_defined_function], and
#' [`delete_table`][glue_delete_table] or
#' [`batch_delete_table`][glue_batch_delete_table], to delete any resources
#' that belong to the database.
#'
#' @usage
#' glue_delete_database(CatalogId, Name)
#'
#' @param CatalogId The ID of the Data Catalog in which the database resides. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param Name &#91;required&#93; The name of the database to delete. For Hive compatibility, this must be
#' all lowercase.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_database(
#'   CatalogId = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_database
#'
#' @aliases glue_delete_database
glue_delete_database <- function(CatalogId = NULL, Name) {
  op <- new_operation(
    name = "DeleteDatabase",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_database_input(CatalogId = CatalogId, Name = Name)
  output <- .glue$delete_database_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_database <- glue_delete_database

#' Deletes a specified development endpoint
#'
#' @description
#' Deletes a specified development endpoint.
#'
#' @usage
#' glue_delete_dev_endpoint(EndpointName)
#'
#' @param EndpointName &#91;required&#93; The name of the `DevEndpoint`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_dev_endpoint(
#'   EndpointName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_dev_endpoint
#'
#' @aliases glue_delete_dev_endpoint
glue_delete_dev_endpoint <- function(EndpointName) {
  op <- new_operation(
    name = "DeleteDevEndpoint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_dev_endpoint_input(EndpointName = EndpointName)
  output <- .glue$delete_dev_endpoint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_dev_endpoint <- glue_delete_dev_endpoint

#' Deletes the specified Zero-ETL integration
#'
#' @description
#' Deletes the specified Zero-ETL integration.
#'
#' @usage
#' glue_delete_integration(IntegrationIdentifier)
#'
#' @param IntegrationIdentifier &#91;required&#93; The Amazon Resource Name (ARN) for the integration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SourceArn = "string",
#'   TargetArn = "string",
#'   IntegrationName = "string",
#'   Description = "string",
#'   IntegrationArn = "string",
#'   KmsKeyId = "string",
#'   AdditionalEncryptionContext = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   Status = "CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION",
#'   CreateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Errors = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   ),
#'   DataFilter = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_integration(
#'   IntegrationIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_integration
#'
#' @aliases glue_delete_integration
glue_delete_integration <- function(IntegrationIdentifier) {
  op <- new_operation(
    name = "DeleteIntegration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_integration_input(IntegrationIdentifier = IntegrationIdentifier)
  output <- .glue$delete_integration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_integration <- glue_delete_integration

#' Deletes the table properties that have been created for the tables that
#' need to be replicated
#'
#' @description
#' Deletes the table properties that have been created for the tables that
#' need to be replicated.
#'
#' @usage
#' glue_delete_integration_table_properties(ResourceArn, TableName)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param TableName &#91;required&#93; The name of the table to be replicated.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_integration_table_properties(
#'   ResourceArn = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_integration_table_properties
#'
#' @aliases glue_delete_integration_table_properties
glue_delete_integration_table_properties <- function(ResourceArn, TableName) {
  op <- new_operation(
    name = "DeleteIntegrationTableProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_integration_table_properties_input(ResourceArn = ResourceArn, TableName = TableName)
  output <- .glue$delete_integration_table_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_integration_table_properties <- glue_delete_integration_table_properties

#' Deletes a specified job definition
#'
#' @description
#' Deletes a specified job definition. If the job definition is not found,
#' no exception is thrown.
#'
#' @usage
#' glue_delete_job(JobName)
#'
#' @param JobName &#91;required&#93; The name of the job definition to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   JobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_job
#'
#' @aliases glue_delete_job
glue_delete_job <- function(JobName) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_job_input(JobName = JobName)
  output <- .glue$delete_job_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_job <- glue_delete_job

#' Deletes an Glue machine learning transform
#'
#' @description
#' Deletes an Glue machine learning transform. Machine learning transforms
#' are a special type of transform that use machine learning to learn the
#' details of the transformation to be performed by learning from examples
#' provided by humans. These transformations are then saved by Glue. If you
#' no longer need a transform, you can delete it by calling
#' `DeleteMLTransforms`. However, any Glue jobs that still reference the
#' deleted transform will no longer succeed.
#'
#' @usage
#' glue_delete_ml_transform(TransformId)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the transform to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_ml_transform(
#'   TransformId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_ml_transform
#'
#' @aliases glue_delete_ml_transform
glue_delete_ml_transform <- function(TransformId) {
  op <- new_operation(
    name = "DeleteMLTransform",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_ml_transform_input(TransformId = TransformId)
  output <- .glue$delete_ml_transform_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_ml_transform <- glue_delete_ml_transform

#' Deletes a specified partition
#'
#' @description
#' Deletes a specified partition.
#'
#' @usage
#' glue_delete_partition(CatalogId, DatabaseName, TableName,
#'   PartitionValues)
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be deleted resides. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table that contains the partition to be deleted.
#' @param PartitionValues &#91;required&#93; The values that define the partition.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_partition
#'
#' @aliases glue_delete_partition
glue_delete_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValues) {
  op <- new_operation(
    name = "DeletePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues)
  output <- .glue$delete_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_partition <- glue_delete_partition

#' Deletes a specified partition index from an existing table
#'
#' @description
#' Deletes a specified partition index from an existing table.
#'
#' @usage
#' glue_delete_partition_index(CatalogId, DatabaseName, TableName,
#'   IndexName)
#'
#' @param CatalogId The catalog ID where the table resides.
#' @param DatabaseName &#91;required&#93; Specifies the name of a database from which you want to delete a
#' partition index.
#' @param TableName &#91;required&#93; Specifies the name of a table from which you want to delete a partition
#' index.
#' @param IndexName &#91;required&#93; The name of the partition index to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_partition_index(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   IndexName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_partition_index
#'
#' @aliases glue_delete_partition_index
glue_delete_partition_index <- function(CatalogId = NULL, DatabaseName, TableName, IndexName) {
  op <- new_operation(
    name = "DeletePartitionIndex",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_partition_index_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, IndexName = IndexName)
  output <- .glue$delete_partition_index_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_partition_index <- glue_delete_partition_index

#' Delete the entire registry including schema and all of its versions
#'
#' @description
#' Delete the entire registry including schema and all of its versions. To
#' get the status of the delete operation, you can call the
#' [`get_registry`][glue_get_registry] API after the asynchronous call.
#' Deleting a registry will deactivate all online operations for the
#' registry such as the [`update_registry`][glue_update_registry],
#' [`create_schema`][glue_create_schema],
#' [`update_schema`][glue_update_schema], and
#' [`register_schema_version`][glue_register_schema_version] APIs.
#'
#' @usage
#' glue_delete_registry(RegistryId)
#'
#' @param RegistryId &#91;required&#93; This is a wrapper structure that may contain the registry name and
#' Amazon Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryName = "string",
#'   RegistryArn = "string",
#'   Status = "AVAILABLE"|"DELETING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_registry(
#'   RegistryId = list(
#'     RegistryName = "string",
#'     RegistryArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_registry
#'
#' @aliases glue_delete_registry
glue_delete_registry <- function(RegistryId) {
  op <- new_operation(
    name = "DeleteRegistry",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_registry_input(RegistryId = RegistryId)
  output <- .glue$delete_registry_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_registry <- glue_delete_registry

#' Deletes a specified policy
#'
#' @description
#' Deletes a specified policy.
#'
#' @usage
#' glue_delete_resource_policy(PolicyHashCondition, ResourceArn)
#'
#' @param PolicyHashCondition The hash value returned when this policy was set.
#' @param ResourceArn The ARN of the Glue resource for the resource policy to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_resource_policy(
#'   PolicyHashCondition = "string",
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_resource_policy
#'
#' @aliases glue_delete_resource_policy
glue_delete_resource_policy <- function(PolicyHashCondition = NULL, ResourceArn = NULL) {
  op <- new_operation(
    name = "DeleteResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_resource_policy_input(PolicyHashCondition = PolicyHashCondition, ResourceArn = ResourceArn)
  output <- .glue$delete_resource_policy_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_resource_policy <- glue_delete_resource_policy

#' Deletes the entire schema set, including the schema set and all of its
#' versions
#'
#' @description
#' Deletes the entire schema set, including the schema set and all of its
#' versions. To get the status of the delete operation, you can call
#' [`get_schema`][glue_get_schema] API after the asynchronous call.
#' Deleting a registry will deactivate all online operations for the
#' schema, such as the
#' [`get_schema_by_definition`][glue_get_schema_by_definition], and
#' [`register_schema_version`][glue_register_schema_version] APIs.
#'
#' @usage
#' glue_delete_schema(SchemaId)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure that may contain the schema name and Amazon
#' Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaArn = "string",
#'   SchemaName = "string",
#'   Status = "AVAILABLE"|"PENDING"|"DELETING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_schema(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_schema
#'
#' @aliases glue_delete_schema
glue_delete_schema <- function(SchemaId) {
  op <- new_operation(
    name = "DeleteSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_schema_input(SchemaId = SchemaId)
  output <- .glue$delete_schema_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_schema <- glue_delete_schema

#' Remove versions from the specified schema
#'
#' @description
#' Remove versions from the specified schema. A version number or range may
#' be supplied. If the compatibility mode forbids deleting of a version
#' that is necessary, such as BACKWARDS_FULL, an error is returned. Calling
#' the `GetSchemaVersions` API after this call will list the status of the
#' deleted versions.
#' 
#' When the range of version numbers contain check pointed version, the API
#' will return a 409 conflict and will not proceed with the deletion. You
#' have to remove the checkpoint first using the `DeleteSchemaCheckpoint`
#' API before using this API.
#' 
#' You cannot use the
#' [`delete_schema_versions`][glue_delete_schema_versions] API to delete
#' the first schema version in the schema set. The first schema version can
#' only be deleted by the [`delete_schema`][glue_delete_schema] API. This
#' operation will also delete the attached `SchemaVersionMetadata` under
#' the schema versions. Hard deletes will be enforced on the database.
#' 
#' If the compatibility mode forbids deleting of a version that is
#' necessary, such as BACKWARDS_FULL, an error is returned.
#'
#' @usage
#' glue_delete_schema_versions(SchemaId, Versions)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure that may contain the schema name and Amazon
#' Resource Name (ARN).
#' @param Versions &#91;required&#93; A version range may be supplied which may be of the format:
#' 
#' -   a single version number, 5
#' 
#' -   a range, 5-8 : deletes versions 5, 6, 7, 8
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaVersionErrors = list(
#'     list(
#'       VersionNumber = 123,
#'       ErrorDetails = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_schema_versions(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   Versions = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_schema_versions
#'
#' @aliases glue_delete_schema_versions
glue_delete_schema_versions <- function(SchemaId, Versions) {
  op <- new_operation(
    name = "DeleteSchemaVersions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_schema_versions_input(SchemaId = SchemaId, Versions = Versions)
  output <- .glue$delete_schema_versions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_schema_versions <- glue_delete_schema_versions

#' Deletes a specified security configuration
#'
#' @description
#' Deletes a specified security configuration.
#'
#' @usage
#' glue_delete_security_configuration(Name)
#'
#' @param Name &#91;required&#93; The name of the security configuration to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_security_configuration(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_security_configuration
#'
#' @aliases glue_delete_security_configuration
glue_delete_security_configuration <- function(Name) {
  op <- new_operation(
    name = "DeleteSecurityConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_security_configuration_input(Name = Name)
  output <- .glue$delete_security_configuration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_security_configuration <- glue_delete_security_configuration

#' Deletes the session
#'
#' @description
#' Deletes the session.
#'
#' @usage
#' glue_delete_session(Id, RequestOrigin)
#'
#' @param Id &#91;required&#93; The ID of the session to be deleted.
#' @param RequestOrigin The name of the origin of the delete session request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_session(
#'   Id = "string",
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_session
#'
#' @aliases glue_delete_session
glue_delete_session <- function(Id, RequestOrigin = NULL) {
  op <- new_operation(
    name = "DeleteSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_session_input(Id = Id, RequestOrigin = RequestOrigin)
  output <- .glue$delete_session_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_session <- glue_delete_session

#' Removes a table definition from the Data Catalog
#'
#' @description
#' Removes a table definition from the Data Catalog.
#' 
#' After completing this operation, you no longer have access to the table
#' versions and partitions that belong to the deleted table. Glue deletes
#' these "orphaned" resources asynchronously in a timely manner, at the
#' discretion of the service.
#' 
#' To ensure the immediate deletion of all related resources, before
#' calling [`delete_table`][glue_delete_table], use
#' [`delete_table_version`][glue_delete_table_version] or
#' [`batch_delete_table_version`][glue_batch_delete_table_version], and
#' [`delete_partition`][glue_delete_partition] or
#' [`batch_delete_partition`][glue_batch_delete_partition], to delete any
#' resources that belong to the table.
#'
#' @usage
#' glue_delete_table(CatalogId, DatabaseName, Name, TransactionId)
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param Name &#91;required&#93; The name of the table to be deleted. For Hive compatibility, this name
#' is entirely lowercase.
#' @param TransactionId The transaction ID at which to delete the table contents.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Name = "string",
#'   TransactionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_table
#'
#' @aliases glue_delete_table
glue_delete_table <- function(CatalogId = NULL, DatabaseName, Name, TransactionId = NULL) {
  op <- new_operation(
    name = "DeleteTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, Name = Name, TransactionId = TransactionId)
  output <- .glue$delete_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_table <- glue_delete_table

#' Deletes an optimizer and all associated metadata for a table
#'
#' @description
#' Deletes an optimizer and all associated metadata for a table. The
#' optimization will no longer be performed on the table.
#'
#' @usage
#' glue_delete_table_optimizer(CatalogId, DatabaseName, TableName, Type)
#'
#' @param CatalogId &#91;required&#93; The Catalog ID of the table.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param Type &#91;required&#93; The type of table optimizer.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_table_optimizer(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Type = "compaction"|"retention"|"orphan_file_deletion"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_table_optimizer
#'
#' @aliases glue_delete_table_optimizer
glue_delete_table_optimizer <- function(CatalogId, DatabaseName, TableName, Type) {
  op <- new_operation(
    name = "DeleteTableOptimizer",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_table_optimizer_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Type = Type)
  output <- .glue$delete_table_optimizer_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_table_optimizer <- glue_delete_table_optimizer

#' Deletes a specified version of a table
#'
#' @description
#' Deletes a specified version of a table.
#'
#' @usage
#' glue_delete_table_version(CatalogId, DatabaseName, TableName, VersionId)
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely
#' lowercase.
#' @param VersionId &#91;required&#93; The ID of the table version to be deleted. A `VersionID` is a string
#' representation of an integer. Each version is incremented by 1.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_table_version
#'
#' @aliases glue_delete_table_version
glue_delete_table_version <- function(CatalogId = NULL, DatabaseName, TableName, VersionId) {
  op <- new_operation(
    name = "DeleteTableVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_table_version_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, VersionId = VersionId)
  output <- .glue$delete_table_version_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_table_version <- glue_delete_table_version

#' Deletes a specified trigger
#'
#' @description
#' Deletes a specified trigger. If the trigger is not found, no exception
#' is thrown.
#'
#' @usage
#' glue_delete_trigger(Name)
#'
#' @param Name &#91;required&#93; The name of the trigger to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_trigger
#'
#' @aliases glue_delete_trigger
glue_delete_trigger <- function(Name) {
  op <- new_operation(
    name = "DeleteTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_trigger_input(Name = Name)
  output <- .glue$delete_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_trigger <- glue_delete_trigger

#' Deletes the Glue specified usage profile
#'
#' @description
#' Deletes the Glue specified usage profile.
#'
#' @usage
#' glue_delete_usage_profile(Name)
#'
#' @param Name &#91;required&#93; The name of the usage profile to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_usage_profile(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_usage_profile
#'
#' @aliases glue_delete_usage_profile
glue_delete_usage_profile <- function(Name) {
  op <- new_operation(
    name = "DeleteUsageProfile",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_usage_profile_input(Name = Name)
  output <- .glue$delete_usage_profile_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_usage_profile <- glue_delete_usage_profile

#' Deletes an existing function definition from the Data Catalog
#'
#' @description
#' Deletes an existing function definition from the Data Catalog.
#'
#' @usage
#' glue_delete_user_defined_function(CatalogId, DatabaseName, FunctionName)
#'
#' @param CatalogId The ID of the Data Catalog where the function to be deleted is located.
#' If none is supplied, the Amazon Web Services account ID is used by
#' default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function is located.
#' @param FunctionName &#91;required&#93; The name of the function definition to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_user_defined_function
#'
#' @aliases glue_delete_user_defined_function
glue_delete_user_defined_function <- function(CatalogId = NULL, DatabaseName, FunctionName) {
  op <- new_operation(
    name = "DeleteUserDefinedFunction",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_user_defined_function_input(CatalogId = CatalogId, DatabaseName = DatabaseName, FunctionName = FunctionName)
  output <- .glue$delete_user_defined_function_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_user_defined_function <- glue_delete_user_defined_function

#' Deletes a workflow
#'
#' @description
#' Deletes a workflow.
#'
#' @usage
#' glue_delete_workflow(Name)
#'
#' @param Name &#91;required&#93; Name of the workflow to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_workflow(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_delete_workflow
#'
#' @aliases glue_delete_workflow
glue_delete_workflow <- function(Name) {
  op <- new_operation(
    name = "DeleteWorkflow",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$delete_workflow_input(Name = Name)
  output <- .glue$delete_workflow_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$delete_workflow <- glue_delete_workflow

#' The DescribeConnectionType API provides full details of the supported
#' options for a given connection type in Glue
#'
#' @description
#' The [`describe_connection_type`][glue_describe_connection_type] API
#' provides full details of the supported options for a given connection
#' type in Glue.
#'
#' @usage
#' glue_describe_connection_type(ConnectionType)
#'
#' @param ConnectionType &#91;required&#93; The name of the connection type to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ConnectionType = "string",
#'   Description = "string",
#'   Capabilities = list(
#'     SupportedAuthenticationTypes = list(
#'       "BASIC"|"OAUTH2"|"CUSTOM"|"IAM"
#'     ),
#'     SupportedDataOperations = list(
#'       "READ"|"WRITE"
#'     ),
#'     SupportedComputeEnvironments = list(
#'       "SPARK"|"ATHENA"|"PYTHON"
#'     )
#'   ),
#'   ConnectionProperties = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   ),
#'   ConnectionOptions = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   ),
#'   AuthenticationConfiguration = list(
#'     AuthenticationType = list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     ),
#'     SecretArn = list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     ),
#'     OAuth2Properties = list(
#'       list(
#'         Name = "string",
#'         Description = "string",
#'         Required = TRUE|FALSE,
#'         DefaultValue = "string",
#'         PropertyTypes = list(
#'           "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'         ),
#'         AllowedValues = list(
#'           list(
#'             Description = "string",
#'             Value = "string"
#'           )
#'         ),
#'         DataOperationScopes = list(
#'           "READ"|"WRITE"
#'         )
#'       )
#'     ),
#'     BasicAuthenticationProperties = list(
#'       list(
#'         Name = "string",
#'         Description = "string",
#'         Required = TRUE|FALSE,
#'         DefaultValue = "string",
#'         PropertyTypes = list(
#'           "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'         ),
#'         AllowedValues = list(
#'           list(
#'             Description = "string",
#'             Value = "string"
#'           )
#'         ),
#'         DataOperationScopes = list(
#'           "READ"|"WRITE"
#'         )
#'       )
#'     ),
#'     CustomAuthenticationProperties = list(
#'       list(
#'         Name = "string",
#'         Description = "string",
#'         Required = TRUE|FALSE,
#'         DefaultValue = "string",
#'         PropertyTypes = list(
#'           "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'         ),
#'         AllowedValues = list(
#'           list(
#'             Description = "string",
#'             Value = "string"
#'           )
#'         ),
#'         DataOperationScopes = list(
#'           "READ"|"WRITE"
#'         )
#'       )
#'     )
#'   ),
#'   ComputeEnvironmentConfigurations = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       ComputeEnvironment = "SPARK"|"ATHENA"|"PYTHON",
#'       SupportedAuthenticationTypes = list(
#'         "BASIC"|"OAUTH2"|"CUSTOM"|"IAM"
#'       ),
#'       ConnectionOptions = list(
#'         list(
#'           Name = "string",
#'           Description = "string",
#'           Required = TRUE|FALSE,
#'           DefaultValue = "string",
#'           PropertyTypes = list(
#'             "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'           ),
#'           AllowedValues = list(
#'             list(
#'               Description = "string",
#'               Value = "string"
#'             )
#'           ),
#'           DataOperationScopes = list(
#'             "READ"|"WRITE"
#'           )
#'         )
#'       ),
#'       ConnectionPropertyNameOverrides = list(
#'         "string"
#'       ),
#'       ConnectionOptionNameOverrides = list(
#'         "string"
#'       ),
#'       ConnectionPropertiesRequiredOverrides = list(
#'         "string"
#'       ),
#'       PhysicalConnectionPropertiesRequired = TRUE|FALSE
#'     )
#'   ),
#'   PhysicalConnectionRequirements = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   ),
#'   AthenaConnectionProperties = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   ),
#'   PythonConnectionProperties = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   ),
#'   SparkConnectionProperties = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Required = TRUE|FALSE,
#'       DefaultValue = "string",
#'       PropertyTypes = list(
#'         "USER_INPUT"|"SECRET"|"READ_ONLY"|"UNUSED"|"SECRET_OR_USER_INPUT"
#'       ),
#'       AllowedValues = list(
#'         list(
#'           Description = "string",
#'           Value = "string"
#'         )
#'       ),
#'       DataOperationScopes = list(
#'         "READ"|"WRITE"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_connection_type(
#'   ConnectionType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_describe_connection_type
#'
#' @aliases glue_describe_connection_type
glue_describe_connection_type <- function(ConnectionType) {
  op <- new_operation(
    name = "DescribeConnectionType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$describe_connection_type_input(ConnectionType = ConnectionType)
  output <- .glue$describe_connection_type_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$describe_connection_type <- glue_describe_connection_type

#' Provides details regarding the entity used with the connection type,
#' with a description of the data model for each field in the selected
#' entity
#'
#' @description
#' Provides details regarding the entity used with the connection type,
#' with a description of the data model for each field in the selected
#' entity.
#' 
#' The response includes all the fields which make up the entity.
#'
#' @usage
#' glue_describe_entity(ConnectionName, CatalogId, EntityName, NextToken,
#'   DataStoreApiVersion)
#'
#' @param ConnectionName &#91;required&#93; The name of the connection that contains the connection type
#' credentials.
#' @param CatalogId The catalog ID of the catalog that contains the connection. This can be
#' null, By default, the Amazon Web Services Account ID is the catalog ID.
#' @param EntityName &#91;required&#93; The name of the entity that you want to describe from the connection
#' type.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param DataStoreApiVersion The version of the API used for the data store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Fields = list(
#'     list(
#'       FieldName = "string",
#'       Label = "string",
#'       Description = "string",
#'       FieldType = "INT"|"SMALLINT"|"BIGINT"|"FLOAT"|"LONG"|"DATE"|"BOOLEAN"|"MAP"|"ARRAY"|"STRING"|"TIMESTAMP"|"DECIMAL"|"BYTE"|"SHORT"|"DOUBLE"|"STRUCT",
#'       IsPrimaryKey = TRUE|FALSE,
#'       IsNullable = TRUE|FALSE,
#'       IsRetrievable = TRUE|FALSE,
#'       IsFilterable = TRUE|FALSE,
#'       IsPartitionable = TRUE|FALSE,
#'       IsCreateable = TRUE|FALSE,
#'       IsUpdateable = TRUE|FALSE,
#'       IsUpsertable = TRUE|FALSE,
#'       IsDefaultOnCreate = TRUE|FALSE,
#'       SupportedValues = list(
#'         "string"
#'       ),
#'       SupportedFilterOperators = list(
#'         "LESS_THAN"|"GREATER_THAN"|"BETWEEN"|"EQUAL_TO"|"NOT_EQUAL_TO"|"GREATER_THAN_OR_EQUAL_TO"|"LESS_THAN_OR_EQUAL_TO"|"CONTAINS"|"ORDER_BY"
#'       ),
#'       ParentField = "string",
#'       NativeDataType = "string",
#'       CustomProperties = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_entity(
#'   ConnectionName = "string",
#'   CatalogId = "string",
#'   EntityName = "string",
#'   NextToken = "string",
#'   DataStoreApiVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_describe_entity
#'
#' @aliases glue_describe_entity
glue_describe_entity <- function(ConnectionName, CatalogId = NULL, EntityName, NextToken = NULL, DataStoreApiVersion = NULL) {
  op <- new_operation(
    name = "DescribeEntity",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", result_key = "Fields"),
    stream_api = FALSE
  )
  input <- .glue$describe_entity_input(ConnectionName = ConnectionName, CatalogId = CatalogId, EntityName = EntityName, NextToken = NextToken, DataStoreApiVersion = DataStoreApiVersion)
  output <- .glue$describe_entity_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$describe_entity <- glue_describe_entity

#' Returns a list of inbound integrations for the specified integration
#'
#' @description
#' Returns a list of inbound integrations for the specified integration.
#'
#' @usage
#' glue_describe_inbound_integrations(IntegrationArn, Marker, MaxRecords,
#'   TargetArn)
#'
#' @param IntegrationArn The Amazon Resource Name (ARN) of the integration.
#' @param Marker A token to specify where to start paginating. This is the marker from a
#' previously truncated response.
#' @param MaxRecords The total number of items to return in the output.
#' @param TargetArn The Amazon Resource Name (ARN) of the target resource in the
#' integration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   InboundIntegrations = list(
#'     list(
#'       SourceArn = "string",
#'       TargetArn = "string",
#'       IntegrationArn = "string",
#'       Status = "CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Errors = list(
#'         list(
#'           ErrorCode = "string",
#'           ErrorMessage = "string"
#'         )
#'       )
#'     )
#'   ),
#'   Marker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_inbound_integrations(
#'   IntegrationArn = "string",
#'   Marker = "string",
#'   MaxRecords = 123,
#'   TargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_describe_inbound_integrations
#'
#' @aliases glue_describe_inbound_integrations
glue_describe_inbound_integrations <- function(IntegrationArn = NULL, Marker = NULL, MaxRecords = NULL, TargetArn = NULL) {
  op <- new_operation(
    name = "DescribeInboundIntegrations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$describe_inbound_integrations_input(IntegrationArn = IntegrationArn, Marker = Marker, MaxRecords = MaxRecords, TargetArn = TargetArn)
  output <- .glue$describe_inbound_integrations_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$describe_inbound_integrations <- glue_describe_inbound_integrations

#' The API is used to retrieve a list of integrations
#'
#' @description
#' The API is used to retrieve a list of integrations.
#'
#' @usage
#' glue_describe_integrations(IntegrationIdentifier, Marker, MaxRecords,
#'   Filters)
#'
#' @param IntegrationIdentifier The Amazon Resource Name (ARN) for the integration.
#' @param Marker A value that indicates the starting point for the next set of response
#' records in a subsequent request.
#' @param MaxRecords The total number of items to return in the output.
#' @param Filters A list of key and values, to filter down the results. Supported keys are
#' "Status", "IntegrationName", and "SourceArn". IntegrationName is limited
#' to only one value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Integrations = list(
#'     list(
#'       SourceArn = "string",
#'       TargetArn = "string",
#'       Description = "string",
#'       IntegrationName = "string",
#'       IntegrationArn = "string",
#'       KmsKeyId = "string",
#'       AdditionalEncryptionContext = list(
#'         "string"
#'       ),
#'       Tags = list(
#'         list(
#'           key = "string",
#'           value = "string"
#'         )
#'       ),
#'       Status = "CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Errors = list(
#'         list(
#'           ErrorCode = "string",
#'           ErrorMessage = "string"
#'         )
#'       ),
#'       DataFilter = "string"
#'     )
#'   ),
#'   Marker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_integrations(
#'   IntegrationIdentifier = "string",
#'   Marker = "string",
#'   MaxRecords = 123,
#'   Filters = list(
#'     list(
#'       Name = "string",
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_describe_integrations
#'
#' @aliases glue_describe_integrations
glue_describe_integrations <- function(IntegrationIdentifier = NULL, Marker = NULL, MaxRecords = NULL, Filters = NULL) {
  op <- new_operation(
    name = "DescribeIntegrations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$describe_integrations_input(IntegrationIdentifier = IntegrationIdentifier, Marker = Marker, MaxRecords = MaxRecords, Filters = Filters)
  output <- .glue$describe_integrations_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$describe_integrations <- glue_describe_integrations

#' Retrieves the details of a blueprint
#'
#' @description
#' Retrieves the details of a blueprint.
#'
#' @usage
#' glue_get_blueprint(Name, IncludeBlueprint, IncludeParameterSpec)
#'
#' @param Name &#91;required&#93; The name of the blueprint.
#' @param IncludeBlueprint Specifies whether or not to include the blueprint in the response.
#' @param IncludeParameterSpec Specifies whether or not to include the parameter specification.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Blueprint = list(
#'     Name = "string",
#'     Description = "string",
#'     CreatedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ParameterSpec = "string",
#'     BlueprintLocation = "string",
#'     BlueprintServiceLocation = "string",
#'     Status = "CREATING"|"ACTIVE"|"UPDATING"|"FAILED",
#'     ErrorMessage = "string",
#'     LastActiveDefinition = list(
#'       Description = "string",
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ParameterSpec = "string",
#'       BlueprintLocation = "string",
#'       BlueprintServiceLocation = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_blueprint(
#'   Name = "string",
#'   IncludeBlueprint = TRUE|FALSE,
#'   IncludeParameterSpec = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_blueprint
#'
#' @aliases glue_get_blueprint
glue_get_blueprint <- function(Name, IncludeBlueprint = NULL, IncludeParameterSpec = NULL) {
  op <- new_operation(
    name = "GetBlueprint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_blueprint_input(Name = Name, IncludeBlueprint = IncludeBlueprint, IncludeParameterSpec = IncludeParameterSpec)
  output <- .glue$get_blueprint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_blueprint <- glue_get_blueprint

#' Retrieves the details of a blueprint run
#'
#' @description
#' Retrieves the details of a blueprint run.
#'
#' @usage
#' glue_get_blueprint_run(BlueprintName, RunId)
#'
#' @param BlueprintName &#91;required&#93; The name of the blueprint.
#' @param RunId &#91;required&#93; The run ID for the blueprint run you want to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BlueprintRun = list(
#'     BlueprintName = "string",
#'     RunId = "string",
#'     WorkflowName = "string",
#'     State = "RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK",
#'     StartedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ErrorMessage = "string",
#'     RollbackErrorMessage = "string",
#'     Parameters = "string",
#'     RoleArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_blueprint_run(
#'   BlueprintName = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_blueprint_run
#'
#' @aliases glue_get_blueprint_run
glue_get_blueprint_run <- function(BlueprintName, RunId) {
  op <- new_operation(
    name = "GetBlueprintRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_blueprint_run_input(BlueprintName = BlueprintName, RunId = RunId)
  output <- .glue$get_blueprint_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_blueprint_run <- glue_get_blueprint_run

#' Retrieves the details of blueprint runs for a specified blueprint
#'
#' @description
#' Retrieves the details of blueprint runs for a specified blueprint.
#'
#' @usage
#' glue_get_blueprint_runs(BlueprintName, NextToken, MaxResults)
#'
#' @param BlueprintName &#91;required&#93; The name of the blueprint.
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BlueprintRuns = list(
#'     list(
#'       BlueprintName = "string",
#'       RunId = "string",
#'       WorkflowName = "string",
#'       State = "RUNNING"|"SUCCEEDED"|"FAILED"|"ROLLING_BACK",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ErrorMessage = "string",
#'       RollbackErrorMessage = "string",
#'       Parameters = "string",
#'       RoleArn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_blueprint_runs(
#'   BlueprintName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_blueprint_runs
#'
#' @aliases glue_get_blueprint_runs
glue_get_blueprint_runs <- function(BlueprintName, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetBlueprintRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$get_blueprint_runs_input(BlueprintName = BlueprintName, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_blueprint_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_blueprint_runs <- glue_get_blueprint_runs

#' The name of the Catalog to retrieve
#'
#' @description
#' The name of the Catalog to retrieve. This should be all lowercase.
#'
#' @usage
#' glue_get_catalog(CatalogId)
#'
#' @param CatalogId &#91;required&#93; The ID of the parent catalog in which the catalog resides. If none is
#' provided, the Amazon Web Services Account Number is used by default.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Catalog = list(
#'     CatalogId = "string",
#'     Name = "string",
#'     ResourceArn = "string",
#'     Description = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     TargetRedshiftCatalog = list(
#'       CatalogArn = "string"
#'     ),
#'     FederatedCatalog = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     ),
#'     CatalogProperties = list(
#'       DataLakeAccessProperties = list(
#'         DataLakeAccess = TRUE|FALSE,
#'         DataTransferRole = "string",
#'         KmsKey = "string",
#'         ManagedWorkgroupName = "string",
#'         ManagedWorkgroupStatus = "string",
#'         RedshiftDatabaseName = "string",
#'         StatusMessage = "string",
#'         CatalogType = "string"
#'       ),
#'       CustomProperties = list(
#'         "string"
#'       )
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     CreateDatabaseDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_catalog(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_catalog
#'
#' @aliases glue_get_catalog
glue_get_catalog <- function(CatalogId) {
  op <- new_operation(
    name = "GetCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_catalog_input(CatalogId = CatalogId)
  output <- .glue$get_catalog_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_catalog <- glue_get_catalog

#' Retrieves the status of a migration operation
#'
#' @description
#' Retrieves the status of a migration operation.
#'
#' @usage
#' glue_get_catalog_import_status(CatalogId)
#'
#' @param CatalogId The ID of the catalog to migrate. Currently, this should be the Amazon
#' Web Services account ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ImportStatus = list(
#'     ImportCompleted = TRUE|FALSE,
#'     ImportTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ImportedBy = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_catalog_import_status(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_catalog_import_status
#'
#' @aliases glue_get_catalog_import_status
glue_get_catalog_import_status <- function(CatalogId = NULL) {
  op <- new_operation(
    name = "GetCatalogImportStatus",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_catalog_import_status_input(CatalogId = CatalogId)
  output <- .glue$get_catalog_import_status_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_catalog_import_status <- glue_get_catalog_import_status

#' Retrieves all catalogs defined in a catalog in the Glue Data Catalog
#'
#' @description
#' Retrieves all catalogs defined in a catalog in the Glue Data Catalog.
#' For a Redshift-federated catalog use case, this operation returns the
#' list of catalogs mapped to Redshift databases in the Redshift namespace
#' catalog.
#'
#' @usage
#' glue_get_catalogs(ParentCatalogId, NextToken, MaxResults, Recursive,
#'   IncludeRoot)
#'
#' @param ParentCatalogId The ID of the parent catalog in which the catalog resides. If none is
#' provided, the Amazon Web Services Account Number is used by default.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of catalogs to return in one response.
#' @param Recursive Whether to list all catalogs across the catalog hierarchy, starting from
#' the `ParentCatalogId`. Defaults to `false` . When `true`, all catalog
#' objects in the `ParentCatalogID` hierarchy are enumerated in the
#' response.
#' @param IncludeRoot Whether to list the default catalog in the account and region in the
#' response. Defaults to `false`. When `true` and
#' `ParentCatalogId = NULL | Amazon Web Services Account ID`, all catalogs
#' and the default catalog are enumerated in the response.
#' 
#' When the `ParentCatalogId` is not equal to null, and this attribute is
#' passed as `false` or `true`, an `InvalidInputException` is thrown.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CatalogList = list(
#'     list(
#'       CatalogId = "string",
#'       Name = "string",
#'       ResourceArn = "string",
#'       Description = "string",
#'       Parameters = list(
#'         "string"
#'       ),
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       TargetRedshiftCatalog = list(
#'         CatalogArn = "string"
#'       ),
#'       FederatedCatalog = list(
#'         Identifier = "string",
#'         ConnectionName = "string"
#'       ),
#'       CatalogProperties = list(
#'         DataLakeAccessProperties = list(
#'           DataLakeAccess = TRUE|FALSE,
#'           DataTransferRole = "string",
#'           KmsKey = "string",
#'           ManagedWorkgroupName = "string",
#'           ManagedWorkgroupStatus = "string",
#'           RedshiftDatabaseName = "string",
#'           StatusMessage = "string",
#'           CatalogType = "string"
#'         ),
#'         CustomProperties = list(
#'           "string"
#'         )
#'       ),
#'       CreateTableDefaultPermissions = list(
#'         list(
#'           Principal = list(
#'             DataLakePrincipalIdentifier = "string"
#'           ),
#'           Permissions = list(
#'             "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'           )
#'         )
#'       ),
#'       CreateDatabaseDefaultPermissions = list(
#'         list(
#'           Principal = list(
#'             DataLakePrincipalIdentifier = "string"
#'           ),
#'           Permissions = list(
#'             "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_catalogs(
#'   ParentCatalogId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Recursive = TRUE|FALSE,
#'   IncludeRoot = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_catalogs
#'
#' @aliases glue_get_catalogs
glue_get_catalogs <- function(ParentCatalogId = NULL, NextToken = NULL, MaxResults = NULL, Recursive = NULL, IncludeRoot = NULL) {
  op <- new_operation(
    name = "GetCatalogs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_catalogs_input(ParentCatalogId = ParentCatalogId, NextToken = NextToken, MaxResults = MaxResults, Recursive = Recursive, IncludeRoot = IncludeRoot)
  output <- .glue$get_catalogs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_catalogs <- glue_get_catalogs

#' Retrieve a classifier by name
#'
#' @description
#' Retrieve a classifier by name.
#'
#' @usage
#' glue_get_classifier(Name)
#'
#' @param Name &#91;required&#93; Name of the classifier to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Classifier = list(
#'     GrokClassifier = list(
#'       Name = "string",
#'       Classification = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Version = 123,
#'       GrokPattern = "string",
#'       CustomPatterns = "string"
#'     ),
#'     XMLClassifier = list(
#'       Name = "string",
#'       Classification = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Version = 123,
#'       RowTag = "string"
#'     ),
#'     JsonClassifier = list(
#'       Name = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Version = 123,
#'       JsonPath = "string"
#'     ),
#'     CsvClassifier = list(
#'       Name = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Version = 123,
#'       Delimiter = "string",
#'       QuoteSymbol = "string",
#'       ContainsHeader = "UNKNOWN"|"PRESENT"|"ABSENT",
#'       Header = list(
#'         "string"
#'       ),
#'       DisableValueTrimming = TRUE|FALSE,
#'       AllowSingleColumn = TRUE|FALSE,
#'       CustomDatatypeConfigured = TRUE|FALSE,
#'       CustomDatatypes = list(
#'         "string"
#'       ),
#'       Serde = "OpenCSVSerDe"|"LazySimpleSerDe"|"None"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_classifier(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_classifier
#'
#' @aliases glue_get_classifier
glue_get_classifier <- function(Name) {
  op <- new_operation(
    name = "GetClassifier",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_classifier_input(Name = Name)
  output <- .glue$get_classifier_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_classifier <- glue_get_classifier

#' Lists all classifier objects in the Data Catalog
#'
#' @description
#' Lists all classifier objects in the Data Catalog.
#'
#' @usage
#' glue_get_classifiers(MaxResults, NextToken)
#'
#' @param MaxResults The size of the list to return (optional).
#' @param NextToken An optional continuation token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Classifiers = list(
#'     list(
#'       GrokClassifier = list(
#'         Name = "string",
#'         Classification = "string",
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastUpdated = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Version = 123,
#'         GrokPattern = "string",
#'         CustomPatterns = "string"
#'       ),
#'       XMLClassifier = list(
#'         Name = "string",
#'         Classification = "string",
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastUpdated = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Version = 123,
#'         RowTag = "string"
#'       ),
#'       JsonClassifier = list(
#'         Name = "string",
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastUpdated = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Version = 123,
#'         JsonPath = "string"
#'       ),
#'       CsvClassifier = list(
#'         Name = "string",
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastUpdated = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Version = 123,
#'         Delimiter = "string",
#'         QuoteSymbol = "string",
#'         ContainsHeader = "UNKNOWN"|"PRESENT"|"ABSENT",
#'         Header = list(
#'           "string"
#'         ),
#'         DisableValueTrimming = TRUE|FALSE,
#'         AllowSingleColumn = TRUE|FALSE,
#'         CustomDatatypeConfigured = TRUE|FALSE,
#'         CustomDatatypes = list(
#'           "string"
#'         ),
#'         Serde = "OpenCSVSerDe"|"LazySimpleSerDe"|"None"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_classifiers(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_classifiers
#'
#' @aliases glue_get_classifiers
glue_get_classifiers <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetClassifiers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "Classifiers", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_classifiers_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_classifiers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_classifiers <- glue_get_classifiers

#' Retrieves partition statistics of columns
#'
#' @description
#' Retrieves partition statistics of columns.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`get_partition`][glue_get_partition].
#'
#' @usage
#' glue_get_column_statistics_for_partition(CatalogId, DatabaseName,
#'   TableName, PartitionValues, ColumnNames)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param PartitionValues &#91;required&#93; A list of partition values identifying the partition.
#' @param ColumnNames &#91;required&#93; A list of the column names.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsList = list(
#'     list(
#'       ColumnName = "string",
#'       ColumnType = "string",
#'       AnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StatisticsData = list(
#'         Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'         BooleanColumnStatisticsData = list(
#'           NumberOfTrues = 123,
#'           NumberOfFalses = 123,
#'           NumberOfNulls = 123
#'         ),
#'         DateColumnStatisticsData = list(
#'           MinimumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           MaximumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DecimalColumnStatisticsData = list(
#'           MinimumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           MaximumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DoubleColumnStatisticsData = list(
#'           MinimumValue = 123.0,
#'           MaximumValue = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         LongColumnStatisticsData = list(
#'           MinimumValue = 123,
#'           MaximumValue = 123,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         StringColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         BinaryColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123
#'         )
#'       )
#'     )
#'   ),
#'   Errors = list(
#'     list(
#'       ColumnName = "string",
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_column_statistics_for_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   ),
#'   ColumnNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_column_statistics_for_partition
#'
#' @aliases glue_get_column_statistics_for_partition
glue_get_column_statistics_for_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValues, ColumnNames) {
  op <- new_operation(
    name = "GetColumnStatisticsForPartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_column_statistics_for_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues, ColumnNames = ColumnNames)
  output <- .glue$get_column_statistics_for_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_column_statistics_for_partition <- glue_get_column_statistics_for_partition

#' Retrieves table statistics of columns
#'
#' @description
#' Retrieves table statistics of columns.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`get_table`][glue_get_table].
#'
#' @usage
#' glue_get_column_statistics_for_table(CatalogId, DatabaseName, TableName,
#'   ColumnNames)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param ColumnNames &#91;required&#93; A list of the column names.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsList = list(
#'     list(
#'       ColumnName = "string",
#'       ColumnType = "string",
#'       AnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StatisticsData = list(
#'         Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'         BooleanColumnStatisticsData = list(
#'           NumberOfTrues = 123,
#'           NumberOfFalses = 123,
#'           NumberOfNulls = 123
#'         ),
#'         DateColumnStatisticsData = list(
#'           MinimumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           MaximumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DecimalColumnStatisticsData = list(
#'           MinimumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           MaximumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DoubleColumnStatisticsData = list(
#'           MinimumValue = 123.0,
#'           MaximumValue = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         LongColumnStatisticsData = list(
#'           MinimumValue = 123,
#'           MaximumValue = 123,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         StringColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         BinaryColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123
#'         )
#'       )
#'     )
#'   ),
#'   Errors = list(
#'     list(
#'       ColumnName = "string",
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_column_statistics_for_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   ColumnNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_column_statistics_for_table
#'
#' @aliases glue_get_column_statistics_for_table
glue_get_column_statistics_for_table <- function(CatalogId = NULL, DatabaseName, TableName, ColumnNames) {
  op <- new_operation(
    name = "GetColumnStatisticsForTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_column_statistics_for_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, ColumnNames = ColumnNames)
  output <- .glue$get_column_statistics_for_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_column_statistics_for_table <- glue_get_column_statistics_for_table

#' Get the associated metadata/information for a task run, given a task run
#' ID
#'
#' @description
#' Get the associated metadata/information for a task run, given a task run
#' ID.
#'
#' @usage
#' glue_get_column_statistics_task_run(ColumnStatisticsTaskRunId)
#'
#' @param ColumnStatisticsTaskRunId &#91;required&#93; The identifier for the particular column statistics task run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsTaskRun = list(
#'     CustomerId = "string",
#'     ColumnStatisticsTaskRunId = "string",
#'     DatabaseName = "string",
#'     TableName = "string",
#'     ColumnNameList = list(
#'       "string"
#'     ),
#'     CatalogID = "string",
#'     Role = "string",
#'     SampleSize = 123.0,
#'     SecurityConfiguration = "string",
#'     NumberOfWorkers = 123,
#'     WorkerType = "string",
#'     ComputationType = "FULL"|"INCREMENTAL",
#'     Status = "STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdated = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ErrorMessage = "string",
#'     DPUSeconds = 123.0
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_column_statistics_task_run(
#'   ColumnStatisticsTaskRunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_column_statistics_task_run
#'
#' @aliases glue_get_column_statistics_task_run
glue_get_column_statistics_task_run <- function(ColumnStatisticsTaskRunId) {
  op <- new_operation(
    name = "GetColumnStatisticsTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_column_statistics_task_run_input(ColumnStatisticsTaskRunId = ColumnStatisticsTaskRunId)
  output <- .glue$get_column_statistics_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_column_statistics_task_run <- glue_get_column_statistics_task_run

#' Retrieves information about all runs associated with the specified table
#'
#' @description
#' Retrieves information about all runs associated with the specified
#' table.
#'
#' @usage
#' glue_get_column_statistics_task_runs(DatabaseName, TableName,
#'   MaxResults, NextToken)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param MaxResults The maximum size of the response.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsTaskRuns = list(
#'     list(
#'       CustomerId = "string",
#'       ColumnStatisticsTaskRunId = "string",
#'       DatabaseName = "string",
#'       TableName = "string",
#'       ColumnNameList = list(
#'         "string"
#'       ),
#'       CatalogID = "string",
#'       Role = "string",
#'       SampleSize = 123.0,
#'       SecurityConfiguration = "string",
#'       NumberOfWorkers = 123,
#'       WorkerType = "string",
#'       ComputationType = "FULL"|"INCREMENTAL",
#'       Status = "STARTING"|"RUNNING"|"SUCCEEDED"|"FAILED"|"STOPPED",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ErrorMessage = "string",
#'       DPUSeconds = 123.0
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_column_statistics_task_runs(
#'   DatabaseName = "string",
#'   TableName = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_column_statistics_task_runs
#'
#' @aliases glue_get_column_statistics_task_runs
glue_get_column_statistics_task_runs <- function(DatabaseName, TableName, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetColumnStatisticsTaskRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$get_column_statistics_task_runs_input(DatabaseName = DatabaseName, TableName = TableName, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_column_statistics_task_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_column_statistics_task_runs <- glue_get_column_statistics_task_runs

#' Gets settings for a column statistics task
#'
#' @description
#' Gets settings for a column statistics task.
#'
#' @usage
#' glue_get_column_statistics_task_settings(DatabaseName, TableName)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to retrieve column statistics.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsTaskSettings = list(
#'     DatabaseName = "string",
#'     TableName = "string",
#'     Schedule = list(
#'       ScheduleExpression = "string",
#'       State = "SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"
#'     ),
#'     ColumnNameList = list(
#'       "string"
#'     ),
#'     CatalogID = "string",
#'     Role = "string",
#'     SampleSize = 123.0,
#'     SecurityConfiguration = "string",
#'     ScheduleType = "CRON"|"AUTO",
#'     SettingSource = "CATALOG"|"TABLE",
#'     LastExecutionAttempt = list(
#'       Status = "FAILED"|"STARTED",
#'       ColumnStatisticsTaskRunId = "string",
#'       ExecutionTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ErrorMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_column_statistics_task_settings(
#'   DatabaseName = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_column_statistics_task_settings
#'
#' @aliases glue_get_column_statistics_task_settings
glue_get_column_statistics_task_settings <- function(DatabaseName, TableName) {
  op <- new_operation(
    name = "GetColumnStatisticsTaskSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_column_statistics_task_settings_input(DatabaseName = DatabaseName, TableName = TableName)
  output <- .glue$get_column_statistics_task_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_column_statistics_task_settings <- glue_get_column_statistics_task_settings

#' Retrieves a connection definition from the Data Catalog
#'
#' @description
#' Retrieves a connection definition from the Data Catalog.
#'
#' @usage
#' glue_get_connection(CatalogId, Name, HidePassword,
#'   ApplyOverrideForComputeEnvironment)
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param Name &#91;required&#93; The name of the connection definition to retrieve.
#' @param HidePassword Allows you to retrieve the connection metadata without returning the
#' password. For instance, the Glue console uses this flag to retrieve the
#' connection, and does not display the password. Set this parameter when
#' the caller might not have permission to use the KMS key to decrypt the
#' password, but it does have permission to access the rest of the
#' connection properties.
#' @param ApplyOverrideForComputeEnvironment For connections that may be used in multiple services, specifies
#' returning properties for the specified compute environment.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Connection = list(
#'     Name = "string",
#'     Description = "string",
#'     ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     AthenaProperties = list(
#'       "string"
#'     ),
#'     PythonProperties = list(
#'       "string"
#'     ),
#'     PhysicalConnectionRequirements = list(
#'       SubnetId = "string",
#'       SecurityGroupIdList = list(
#'         "string"
#'       ),
#'       AvailabilityZone = "string"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdatedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdatedBy = "string",
#'     Status = "READY"|"IN_PROGRESS"|"FAILED",
#'     StatusReason = "string",
#'     LastConnectionValidationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AuthenticationConfiguration = list(
#'       AuthenticationType = "BASIC"|"OAUTH2"|"CUSTOM"|"IAM",
#'       SecretArn = "string",
#'       OAuth2Properties = list(
#'         OAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'         OAuth2ClientApplication = list(
#'           UserManagedClientApplicationClientId = "string",
#'           AWSManagedClientApplicationReference = "string"
#'         ),
#'         TokenUrl = "string",
#'         TokenUrlParametersMap = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ConnectionSchemaVersion = 123,
#'     CompatibleComputeEnvironments = list(
#'       "SPARK"|"ATHENA"|"PYTHON"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_connection(
#'   CatalogId = "string",
#'   Name = "string",
#'   HidePassword = TRUE|FALSE,
#'   ApplyOverrideForComputeEnvironment = "SPARK"|"ATHENA"|"PYTHON"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_connection
#'
#' @aliases glue_get_connection
glue_get_connection <- function(CatalogId = NULL, Name, HidePassword = NULL, ApplyOverrideForComputeEnvironment = NULL) {
  op <- new_operation(
    name = "GetConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_connection_input(CatalogId = CatalogId, Name = Name, HidePassword = HidePassword, ApplyOverrideForComputeEnvironment = ApplyOverrideForComputeEnvironment)
  output <- .glue$get_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_connection <- glue_get_connection

#' Retrieves a list of connection definitions from the Data Catalog
#'
#' @description
#' Retrieves a list of connection definitions from the Data Catalog.
#'
#' @usage
#' glue_get_connections(CatalogId, Filter, HidePassword, NextToken,
#'   MaxResults)
#'
#' @param CatalogId The ID of the Data Catalog in which the connections reside. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param Filter A filter that controls which connections are returned.
#' @param HidePassword Allows you to retrieve the connection metadata without returning the
#' password. For instance, the Glue console uses this flag to retrieve the
#' connection, and does not display the password. Set this parameter when
#' the caller might not have permission to use the KMS key to decrypt the
#' password, but it does have permission to access the rest of the
#' connection properties.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of connections to return in one response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ConnectionList = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'       MatchCriteria = list(
#'         "string"
#'       ),
#'       ConnectionProperties = list(
#'         "string"
#'       ),
#'       SparkProperties = list(
#'         "string"
#'       ),
#'       AthenaProperties = list(
#'         "string"
#'       ),
#'       PythonProperties = list(
#'         "string"
#'       ),
#'       PhysicalConnectionRequirements = list(
#'         SubnetId = "string",
#'         SecurityGroupIdList = list(
#'           "string"
#'         ),
#'         AvailabilityZone = "string"
#'       ),
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdatedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdatedBy = "string",
#'       Status = "READY"|"IN_PROGRESS"|"FAILED",
#'       StatusReason = "string",
#'       LastConnectionValidationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AuthenticationConfiguration = list(
#'         AuthenticationType = "BASIC"|"OAUTH2"|"CUSTOM"|"IAM",
#'         SecretArn = "string",
#'         OAuth2Properties = list(
#'           OAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'           OAuth2ClientApplication = list(
#'             UserManagedClientApplicationClientId = "string",
#'             AWSManagedClientApplicationReference = "string"
#'           ),
#'           TokenUrl = "string",
#'           TokenUrlParametersMap = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ConnectionSchemaVersion = 123,
#'       CompatibleComputeEnvironments = list(
#'         "SPARK"|"ATHENA"|"PYTHON"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_connections(
#'   CatalogId = "string",
#'   Filter = list(
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'     ConnectionSchemaVersion = 123
#'   ),
#'   HidePassword = TRUE|FALSE,
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_connections
#'
#' @aliases glue_get_connections
glue_get_connections <- function(CatalogId = NULL, Filter = NULL, HidePassword = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetConnections",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "ConnectionList", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_connections_input(CatalogId = CatalogId, Filter = Filter, HidePassword = HidePassword, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_connections_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_connections <- glue_get_connections

#' Retrieves metadata for a specified crawler
#'
#' @description
#' Retrieves metadata for a specified crawler.
#'
#' @usage
#' glue_get_crawler(Name)
#'
#' @param Name &#91;required&#93; The name of the crawler to retrieve metadata for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Crawler = list(
#'     Name = "string",
#'     Role = "string",
#'     Targets = list(
#'       S3Targets = list(
#'         list(
#'           Path = "string",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           SampleSize = 123,
#'           EventQueueArn = "string",
#'           DlqEventQueueArn = "string"
#'         )
#'       ),
#'       JdbcTargets = list(
#'         list(
#'           ConnectionName = "string",
#'           Path = "string",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           EnableAdditionalMetadata = list(
#'             "COMMENTS"|"RAWTYPES"
#'           )
#'         )
#'       ),
#'       MongoDBTargets = list(
#'         list(
#'           ConnectionName = "string",
#'           Path = "string",
#'           ScanAll = TRUE|FALSE
#'         )
#'       ),
#'       DynamoDBTargets = list(
#'         list(
#'           Path = "string",
#'           scanAll = TRUE|FALSE,
#'           scanRate = 123.0
#'         )
#'       ),
#'       CatalogTargets = list(
#'         list(
#'           DatabaseName = "string",
#'           Tables = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           EventQueueArn = "string",
#'           DlqEventQueueArn = "string"
#'         )
#'       ),
#'       DeltaTargets = list(
#'         list(
#'           DeltaTables = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           WriteManifest = TRUE|FALSE,
#'           CreateNativeDeltaTable = TRUE|FALSE
#'         )
#'       ),
#'       IcebergTargets = list(
#'         list(
#'           Paths = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           MaximumTraversalDepth = 123
#'         )
#'       ),
#'       HudiTargets = list(
#'         list(
#'           Paths = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           MaximumTraversalDepth = 123
#'         )
#'       )
#'     ),
#'     DatabaseName = "string",
#'     Description = "string",
#'     Classifiers = list(
#'       "string"
#'     ),
#'     RecrawlPolicy = list(
#'       RecrawlBehavior = "CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"
#'     ),
#'     SchemaChangePolicy = list(
#'       UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'       DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'     ),
#'     LineageConfiguration = list(
#'       CrawlerLineageSettings = "ENABLE"|"DISABLE"
#'     ),
#'     State = "READY"|"RUNNING"|"STOPPING",
#'     TablePrefix = "string",
#'     Schedule = list(
#'       ScheduleExpression = "string",
#'       State = "SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"
#'     ),
#'     CrawlElapsedTime = 123,
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastUpdated = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastCrawl = list(
#'       Status = "SUCCEEDED"|"CANCELLED"|"FAILED",
#'       ErrorMessage = "string",
#'       LogGroup = "string",
#'       LogStream = "string",
#'       MessagePrefix = "string",
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     Version = 123,
#'     Configuration = "string",
#'     CrawlerSecurityConfiguration = "string",
#'     LakeFormationConfiguration = list(
#'       UseLakeFormationCredentials = TRUE|FALSE,
#'       AccountId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_crawler
#'
#' @aliases glue_get_crawler
glue_get_crawler <- function(Name) {
  op <- new_operation(
    name = "GetCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_crawler_input(Name = Name)
  output <- .glue$get_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_crawler <- glue_get_crawler

#' Retrieves metrics about specified crawlers
#'
#' @description
#' Retrieves metrics about specified crawlers.
#'
#' @usage
#' glue_get_crawler_metrics(CrawlerNameList, MaxResults, NextToken)
#'
#' @param CrawlerNameList A list of the names of crawlers about which to retrieve metrics.
#' @param MaxResults The maximum size of a list to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CrawlerMetricsList = list(
#'     list(
#'       CrawlerName = "string",
#'       TimeLeftSeconds = 123.0,
#'       StillEstimating = TRUE|FALSE,
#'       LastRuntimeSeconds = 123.0,
#'       MedianRuntimeSeconds = 123.0,
#'       TablesCreated = 123,
#'       TablesUpdated = 123,
#'       TablesDeleted = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_crawler_metrics(
#'   CrawlerNameList = list(
#'     "string"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_crawler_metrics
#'
#' @aliases glue_get_crawler_metrics
glue_get_crawler_metrics <- function(CrawlerNameList = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetCrawlerMetrics",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "CrawlerMetricsList", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_crawler_metrics_input(CrawlerNameList = CrawlerNameList, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_crawler_metrics_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_crawler_metrics <- glue_get_crawler_metrics

#' Retrieves metadata for all crawlers defined in the customer account
#'
#' @description
#' Retrieves metadata for all crawlers defined in the customer account.
#'
#' @usage
#' glue_get_crawlers(MaxResults, NextToken)
#'
#' @param MaxResults The number of crawlers to return on each call.
#' @param NextToken A continuation token, if this is a continuation request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Crawlers = list(
#'     list(
#'       Name = "string",
#'       Role = "string",
#'       Targets = list(
#'         S3Targets = list(
#'           list(
#'             Path = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             SampleSize = 123,
#'             EventQueueArn = "string",
#'             DlqEventQueueArn = "string"
#'           )
#'         ),
#'         JdbcTargets = list(
#'           list(
#'             ConnectionName = "string",
#'             Path = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             EnableAdditionalMetadata = list(
#'               "COMMENTS"|"RAWTYPES"
#'             )
#'           )
#'         ),
#'         MongoDBTargets = list(
#'           list(
#'             ConnectionName = "string",
#'             Path = "string",
#'             ScanAll = TRUE|FALSE
#'           )
#'         ),
#'         DynamoDBTargets = list(
#'           list(
#'             Path = "string",
#'             scanAll = TRUE|FALSE,
#'             scanRate = 123.0
#'           )
#'         ),
#'         CatalogTargets = list(
#'           list(
#'             DatabaseName = "string",
#'             Tables = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             EventQueueArn = "string",
#'             DlqEventQueueArn = "string"
#'           )
#'         ),
#'         DeltaTargets = list(
#'           list(
#'             DeltaTables = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             WriteManifest = TRUE|FALSE,
#'             CreateNativeDeltaTable = TRUE|FALSE
#'           )
#'         ),
#'         IcebergTargets = list(
#'           list(
#'             Paths = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             MaximumTraversalDepth = 123
#'           )
#'         ),
#'         HudiTargets = list(
#'           list(
#'             Paths = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             MaximumTraversalDepth = 123
#'           )
#'         )
#'       ),
#'       DatabaseName = "string",
#'       Description = "string",
#'       Classifiers = list(
#'         "string"
#'       ),
#'       RecrawlPolicy = list(
#'         RecrawlBehavior = "CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"
#'       ),
#'       SchemaChangePolicy = list(
#'         UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'         DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'       ),
#'       LineageConfiguration = list(
#'         CrawlerLineageSettings = "ENABLE"|"DISABLE"
#'       ),
#'       State = "READY"|"RUNNING"|"STOPPING",
#'       TablePrefix = "string",
#'       Schedule = list(
#'         ScheduleExpression = "string",
#'         State = "SCHEDULED"|"NOT_SCHEDULED"|"TRANSITIONING"
#'       ),
#'       CrawlElapsedTime = 123,
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastUpdated = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastCrawl = list(
#'         Status = "SUCCEEDED"|"CANCELLED"|"FAILED",
#'         ErrorMessage = "string",
#'         LogGroup = "string",
#'         LogStream = "string",
#'         MessagePrefix = "string",
#'         StartTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       Version = 123,
#'       Configuration = "string",
#'       CrawlerSecurityConfiguration = "string",
#'       LakeFormationConfiguration = list(
#'         UseLakeFormationCredentials = TRUE|FALSE,
#'         AccountId = "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_crawlers(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_crawlers
#'
#' @aliases glue_get_crawlers
glue_get_crawlers <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetCrawlers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "Crawlers", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_crawlers_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_crawlers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_crawlers <- glue_get_crawlers

#' Retrieves the details of a custom pattern by specifying its name
#'
#' @description
#' Retrieves the details of a custom pattern by specifying its name.
#'
#' @usage
#' glue_get_custom_entity_type(Name)
#'
#' @param Name &#91;required&#93; The name of the custom pattern that you want to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   RegexString = "string",
#'   ContextWords = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_custom_entity_type(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_custom_entity_type
#'
#' @aliases glue_get_custom_entity_type
glue_get_custom_entity_type <- function(Name) {
  op <- new_operation(
    name = "GetCustomEntityType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_custom_entity_type_input(Name = Name)
  output <- .glue$get_custom_entity_type_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_custom_entity_type <- glue_get_custom_entity_type

#' Retrieves the security configuration for a specified catalog
#'
#' @description
#' Retrieves the security configuration for a specified catalog.
#'
#' @usage
#' glue_get_data_catalog_encryption_settings(CatalogId)
#'
#' @param CatalogId The ID of the Data Catalog to retrieve the security configuration for.
#' If none is provided, the Amazon Web Services account ID is used by
#' default.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DataCatalogEncryptionSettings = list(
#'     EncryptionAtRest = list(
#'       CatalogEncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE",
#'       SseAwsKmsKeyId = "string",
#'       CatalogEncryptionServiceRole = "string"
#'     ),
#'     ConnectionPasswordEncryption = list(
#'       ReturnConnectionPasswordEncrypted = TRUE|FALSE,
#'       AwsKmsKeyId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_catalog_encryption_settings(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_catalog_encryption_settings
#'
#' @aliases glue_get_data_catalog_encryption_settings
glue_get_data_catalog_encryption_settings <- function(CatalogId = NULL) {
  op <- new_operation(
    name = "GetDataCatalogEncryptionSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_catalog_encryption_settings_input(CatalogId = CatalogId)
  output <- .glue$get_data_catalog_encryption_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_catalog_encryption_settings <- glue_get_data_catalog_encryption_settings

#' Retrieve the training status of the model along with more information
#' (CompletedOn, StartedOn, FailureReason)
#'
#' @description
#' Retrieve the training status of the model along with more information
#' (CompletedOn, StartedOn, FailureReason).
#'
#' @usage
#' glue_get_data_quality_model(StatisticId, ProfileId)
#'
#' @param StatisticId The Statistic ID.
#' @param ProfileId &#91;required&#93; The Profile ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "RUNNING"|"SUCCEEDED"|"FAILED",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureReason = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_model(
#'   StatisticId = "string",
#'   ProfileId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_model
#'
#' @aliases glue_get_data_quality_model
glue_get_data_quality_model <- function(StatisticId = NULL, ProfileId) {
  op <- new_operation(
    name = "GetDataQualityModel",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_model_input(StatisticId = StatisticId, ProfileId = ProfileId)
  output <- .glue$get_data_quality_model_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_model <- glue_get_data_quality_model

#' Retrieve a statistic's predictions for a given Profile ID
#'
#' @description
#' Retrieve a statistic's predictions for a given Profile ID.
#'
#' @usage
#' glue_get_data_quality_model_result(StatisticId, ProfileId)
#'
#' @param StatisticId &#91;required&#93; The Statistic ID.
#' @param ProfileId &#91;required&#93; The Profile ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Model = list(
#'     list(
#'       LowerBound = 123.0,
#'       UpperBound = 123.0,
#'       PredictedValue = 123.0,
#'       ActualValue = 123.0,
#'       Date = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       InclusionAnnotation = "INCLUDE"|"EXCLUDE"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_model_result(
#'   StatisticId = "string",
#'   ProfileId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_model_result
#'
#' @aliases glue_get_data_quality_model_result
glue_get_data_quality_model_result <- function(StatisticId, ProfileId) {
  op <- new_operation(
    name = "GetDataQualityModelResult",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_model_result_input(StatisticId = StatisticId, ProfileId = ProfileId)
  output <- .glue$get_data_quality_model_result_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_model_result <- glue_get_data_quality_model_result

#' Retrieves the result of a data quality rule evaluation
#'
#' @description
#' Retrieves the result of a data quality rule evaluation.
#'
#' @usage
#' glue_get_data_quality_result(ResultId)
#'
#' @param ResultId &#91;required&#93; A unique result ID for the data quality result.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResultId = "string",
#'   ProfileId = "string",
#'   Score = 123.0,
#'   DataSource = list(
#'     GlueTable = list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   RulesetName = "string",
#'   EvaluationContext = "string",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   JobName = "string",
#'   JobRunId = "string",
#'   RulesetEvaluationRunId = "string",
#'   RuleResults = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       EvaluationMessage = "string",
#'       Result = "PASS"|"FAIL"|"ERROR",
#'       EvaluatedMetrics = list(
#'         123.0
#'       ),
#'       EvaluatedRule = "string"
#'     )
#'   ),
#'   AnalyzerResults = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       EvaluationMessage = "string",
#'       EvaluatedMetrics = list(
#'         123.0
#'       )
#'     )
#'   ),
#'   Observations = list(
#'     list(
#'       Description = "string",
#'       MetricBasedObservation = list(
#'         MetricName = "string",
#'         StatisticId = "string",
#'         MetricValues = list(
#'           ActualValue = 123.0,
#'           ExpectedValue = 123.0,
#'           LowerLimit = 123.0,
#'           UpperLimit = 123.0
#'         ),
#'         NewRules = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_result(
#'   ResultId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_result
#'
#' @aliases glue_get_data_quality_result
glue_get_data_quality_result <- function(ResultId) {
  op <- new_operation(
    name = "GetDataQualityResult",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_result_input(ResultId = ResultId)
  output <- .glue$get_data_quality_result_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_result <- glue_get_data_quality_result

#' Gets the specified recommendation run that was used to generate rules
#'
#' @description
#' Gets the specified recommendation run that was used to generate rules.
#'
#' @usage
#' glue_get_data_quality_rule_recommendation_run(RunId)
#'
#' @param RunId &#91;required&#93; The unique run identifier associated with this run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string",
#'   DataSource = list(
#'     GlueTable = list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Role = "string",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'   ErrorString = "string",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ExecutionTime = 123,
#'   RecommendedRuleset = "string",
#'   CreatedRulesetName = "string",
#'   DataQualitySecurityConfiguration = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_rule_recommendation_run(
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_rule_recommendation_run
#'
#' @aliases glue_get_data_quality_rule_recommendation_run
glue_get_data_quality_rule_recommendation_run <- function(RunId) {
  op <- new_operation(
    name = "GetDataQualityRuleRecommendationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_rule_recommendation_run_input(RunId = RunId)
  output <- .glue$get_data_quality_rule_recommendation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_rule_recommendation_run <- glue_get_data_quality_rule_recommendation_run

#' Returns an existing ruleset by identifier or name
#'
#' @description
#' Returns an existing ruleset by identifier or name.
#'
#' @usage
#' glue_get_data_quality_ruleset(Name)
#'
#' @param Name &#91;required&#93; The name of the ruleset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Description = "string",
#'   Ruleset = "string",
#'   TargetTable = list(
#'     TableName = "string",
#'     DatabaseName = "string",
#'     CatalogId = "string"
#'   ),
#'   CreatedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   RecommendationRunId = "string",
#'   DataQualitySecurityConfiguration = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_ruleset(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_ruleset
#'
#' @aliases glue_get_data_quality_ruleset
glue_get_data_quality_ruleset <- function(Name) {
  op <- new_operation(
    name = "GetDataQualityRuleset",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_ruleset_input(Name = Name)
  output <- .glue$get_data_quality_ruleset_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_ruleset <- glue_get_data_quality_ruleset

#' Retrieves a specific run where a ruleset is evaluated against a data
#' source
#'
#' @description
#' Retrieves a specific run where a ruleset is evaluated against a data
#' source.
#'
#' @usage
#' glue_get_data_quality_ruleset_evaluation_run(RunId)
#'
#' @param RunId &#91;required&#93; The unique run identifier associated with this run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string",
#'   DataSource = list(
#'     GlueTable = list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Role = "string",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   AdditionalRunOptions = list(
#'     CloudWatchMetricsEnabled = TRUE|FALSE,
#'     ResultsS3Prefix = "string",
#'     CompositeRuleEvaluationMethod = "COLUMN"|"ROW"
#'   ),
#'   Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'   ErrorString = "string",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ExecutionTime = 123,
#'   RulesetNames = list(
#'     "string"
#'   ),
#'   ResultIds = list(
#'     "string"
#'   ),
#'   AdditionalDataSources = list(
#'     list(
#'       GlueTable = list(
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CatalogId = "string",
#'         ConnectionName = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_quality_ruleset_evaluation_run(
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_data_quality_ruleset_evaluation_run
#'
#' @aliases glue_get_data_quality_ruleset_evaluation_run
glue_get_data_quality_ruleset_evaluation_run <- function(RunId) {
  op <- new_operation(
    name = "GetDataQualityRulesetEvaluationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_data_quality_ruleset_evaluation_run_input(RunId = RunId)
  output <- .glue$get_data_quality_ruleset_evaluation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_data_quality_ruleset_evaluation_run <- glue_get_data_quality_ruleset_evaluation_run

#' Retrieves the definition of a specified database
#'
#' @description
#' Retrieves the definition of a specified database.
#'
#' @usage
#' glue_get_database(CatalogId, Name)
#'
#' @param CatalogId The ID of the Data Catalog in which the database resides. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param Name &#91;required&#93; The name of the database to retrieve. For Hive compatibility, this
#' should be all lowercase.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Database = list(
#'     Name = "string",
#'     Description = "string",
#'     LocationUri = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     TargetDatabase = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Region = "string"
#'     ),
#'     CatalogId = "string",
#'     FederatedDatabase = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_database(
#'   CatalogId = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_database
#'
#' @aliases glue_get_database
glue_get_database <- function(CatalogId = NULL, Name) {
  op <- new_operation(
    name = "GetDatabase",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_database_input(CatalogId = CatalogId, Name = Name)
  output <- .glue$get_database_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_database <- glue_get_database

#' Retrieves all databases defined in a given Data Catalog
#'
#' @description
#' Retrieves all databases defined in a given Data Catalog.
#'
#' @usage
#' glue_get_databases(CatalogId, NextToken, MaxResults, ResourceShareType,
#'   AttributesToGet)
#'
#' @param CatalogId The ID of the Data Catalog from which to retrieve `Databases`. If none
#' is provided, the Amazon Web Services account ID is used by default.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of databases to return in one response.
#' @param ResourceShareType Allows you to specify that you want to list the databases shared with
#' your account. The allowable values are `FEDERATED`, `FOREIGN` or `ALL`.
#' 
#' -   If set to `FEDERATED`, will list the federated databases
#'     (referencing an external entity) shared with your account.
#' 
#' -   If set to `FOREIGN`, will list the databases shared with your
#'     account.
#' 
#' -   If set to `ALL`, will list the databases shared with your account,
#'     as well as the databases in yor local account.
#' @param AttributesToGet Specifies the database fields returned by the
#' [`get_databases`][glue_get_databases] call. This parameter doesn’t
#' accept an empty list. The request must include the `NAME`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DatabaseList = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       LocationUri = "string",
#'       Parameters = list(
#'         "string"
#'       ),
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CreateTableDefaultPermissions = list(
#'         list(
#'           Principal = list(
#'             DataLakePrincipalIdentifier = "string"
#'           ),
#'           Permissions = list(
#'             "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'           )
#'         )
#'       ),
#'       TargetDatabase = list(
#'         CatalogId = "string",
#'         DatabaseName = "string",
#'         Region = "string"
#'       ),
#'       CatalogId = "string",
#'       FederatedDatabase = list(
#'         Identifier = "string",
#'         ConnectionName = "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_databases(
#'   CatalogId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   ResourceShareType = "FOREIGN"|"ALL"|"FEDERATED",
#'   AttributesToGet = list(
#'     "NAME"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_databases
#'
#' @aliases glue_get_databases
glue_get_databases <- function(CatalogId = NULL, NextToken = NULL, MaxResults = NULL, ResourceShareType = NULL, AttributesToGet = NULL) {
  op <- new_operation(
    name = "GetDatabases",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "DatabaseList", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_databases_input(CatalogId = CatalogId, NextToken = NextToken, MaxResults = MaxResults, ResourceShareType = ResourceShareType, AttributesToGet = AttributesToGet)
  output <- .glue$get_databases_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_databases <- glue_get_databases

#' Transforms a Python script into a directed acyclic graph (DAG)
#'
#' @description
#' Transforms a Python script into a directed acyclic graph (DAG).
#'
#' @usage
#' glue_get_dataflow_graph(PythonScript)
#'
#' @param PythonScript The Python script to transform.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DagNodes = list(
#'     list(
#'       Id = "string",
#'       NodeType = "string",
#'       Args = list(
#'         list(
#'           Name = "string",
#'           Value = "string",
#'           Param = TRUE|FALSE
#'         )
#'       ),
#'       LineNumber = 123
#'     )
#'   ),
#'   DagEdges = list(
#'     list(
#'       Source = "string",
#'       Target = "string",
#'       TargetParameter = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_dataflow_graph(
#'   PythonScript = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_dataflow_graph
#'
#' @aliases glue_get_dataflow_graph
glue_get_dataflow_graph <- function(PythonScript = NULL) {
  op <- new_operation(
    name = "GetDataflowGraph",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_dataflow_graph_input(PythonScript = PythonScript)
  output <- .glue$get_dataflow_graph_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_dataflow_graph <- glue_get_dataflow_graph

#' Retrieves information about a specified development endpoint
#'
#' @description
#' Retrieves information about a specified development endpoint.
#' 
#' When you create a development endpoint in a virtual private cloud (VPC),
#' Glue returns only a private IP address, and the public IP address field
#' is not populated. When you create a non-VPC development endpoint, Glue
#' returns only a public IP address.
#'
#' @usage
#' glue_get_dev_endpoint(EndpointName)
#'
#' @param EndpointName &#91;required&#93; Name of the `DevEndpoint` to retrieve information for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DevEndpoint = list(
#'     EndpointName = "string",
#'     RoleArn = "string",
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     SubnetId = "string",
#'     YarnEndpointAddress = "string",
#'     PrivateAddress = "string",
#'     ZeppelinRemoteSparkInterpreterPort = 123,
#'     PublicAddress = "string",
#'     Status = "string",
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     GlueVersion = "string",
#'     NumberOfWorkers = 123,
#'     NumberOfNodes = 123,
#'     AvailabilityZone = "string",
#'     VpcId = "string",
#'     ExtraPythonLibsS3Path = "string",
#'     ExtraJarsS3Path = "string",
#'     FailureReason = "string",
#'     LastUpdateStatus = "string",
#'     CreatedTimestamp = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedTimestamp = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     PublicKey = "string",
#'     PublicKeys = list(
#'       "string"
#'     ),
#'     SecurityConfiguration = "string",
#'     Arguments = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_dev_endpoint(
#'   EndpointName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_dev_endpoint
#'
#' @aliases glue_get_dev_endpoint
glue_get_dev_endpoint <- function(EndpointName) {
  op <- new_operation(
    name = "GetDevEndpoint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_dev_endpoint_input(EndpointName = EndpointName)
  output <- .glue$get_dev_endpoint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_dev_endpoint <- glue_get_dev_endpoint

#' Retrieves all the development endpoints in this Amazon Web Services
#' account
#'
#' @description
#' Retrieves all the development endpoints in this Amazon Web Services
#' account.
#' 
#' When you create a development endpoint in a virtual private cloud (VPC),
#' Glue returns only a private IP address and the public IP address field
#' is not populated. When you create a non-VPC development endpoint, Glue
#' returns only a public IP address.
#'
#' @usage
#' glue_get_dev_endpoints(MaxResults, NextToken)
#'
#' @param MaxResults The maximum size of information to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DevEndpoints = list(
#'     list(
#'       EndpointName = "string",
#'       RoleArn = "string",
#'       SecurityGroupIds = list(
#'         "string"
#'       ),
#'       SubnetId = "string",
#'       YarnEndpointAddress = "string",
#'       PrivateAddress = "string",
#'       ZeppelinRemoteSparkInterpreterPort = 123,
#'       PublicAddress = "string",
#'       Status = "string",
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       GlueVersion = "string",
#'       NumberOfWorkers = 123,
#'       NumberOfNodes = 123,
#'       AvailabilityZone = "string",
#'       VpcId = "string",
#'       ExtraPythonLibsS3Path = "string",
#'       ExtraJarsS3Path = "string",
#'       FailureReason = "string",
#'       LastUpdateStatus = "string",
#'       CreatedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       PublicKey = "string",
#'       PublicKeys = list(
#'         "string"
#'       ),
#'       SecurityConfiguration = "string",
#'       Arguments = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_dev_endpoints(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_dev_endpoints
#'
#' @aliases glue_get_dev_endpoints
glue_get_dev_endpoints <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetDevEndpoints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "DevEndpoints", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_dev_endpoints_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_dev_endpoints_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_dev_endpoints <- glue_get_dev_endpoints

#' This API is used to query preview data from a given connection type or
#' from a native Amazon S3 based Glue Data Catalog
#'
#' @description
#' This API is used to query preview data from a given connection type or
#' from a native Amazon S3 based Glue Data Catalog.
#' 
#' Returns records as an array of JSON blobs. Each record is formatted
#' using Jackson JsonNode based on the field type defined by the
#' [`describe_entity`][glue_describe_entity] API.
#' 
#' Spark connectors generate schemas according to the same data type
#' mapping as in the [`describe_entity`][glue_describe_entity] API. Spark
#' connectors convert data to the appropriate data types matching the
#' schema when returning rows.
#'
#' @usage
#' glue_get_entity_records(ConnectionName, CatalogId, EntityName,
#'   NextToken, DataStoreApiVersion, ConnectionOptions, FilterPredicate,
#'   Limit, OrderBy, SelectedFields)
#'
#' @param ConnectionName The name of the connection that contains the connection type
#' credentials.
#' @param CatalogId The catalog ID of the catalog that contains the connection. This can be
#' null, By default, the Amazon Web Services Account ID is the catalog ID.
#' @param EntityName &#91;required&#93; Name of the entity that we want to query the preview data from the given
#' connection type.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param DataStoreApiVersion The API version of the SaaS connector.
#' @param ConnectionOptions Connector options that are required to query the data.
#' @param FilterPredicate A filter predicate that you can apply in the query request.
#' @param Limit &#91;required&#93; Limits the number of records fetched with the request.
#' @param OrderBy A parameter that orders the response preview data.
#' @param SelectedFields List of fields that we want to fetch as part of preview data.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Records = list(
#'     list()
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_entity_records(
#'   ConnectionName = "string",
#'   CatalogId = "string",
#'   EntityName = "string",
#'   NextToken = "string",
#'   DataStoreApiVersion = "string",
#'   ConnectionOptions = list(
#'     "string"
#'   ),
#'   FilterPredicate = "string",
#'   Limit = 123,
#'   OrderBy = "string",
#'   SelectedFields = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_entity_records
#'
#' @aliases glue_get_entity_records
glue_get_entity_records <- function(ConnectionName = NULL, CatalogId = NULL, EntityName, NextToken = NULL, DataStoreApiVersion = NULL, ConnectionOptions = NULL, FilterPredicate = NULL, Limit, OrderBy = NULL, SelectedFields = NULL) {
  op <- new_operation(
    name = "GetEntityRecords",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_entity_records_input(ConnectionName = ConnectionName, CatalogId = CatalogId, EntityName = EntityName, NextToken = NextToken, DataStoreApiVersion = DataStoreApiVersion, ConnectionOptions = ConnectionOptions, FilterPredicate = FilterPredicate, Limit = Limit, OrderBy = OrderBy, SelectedFields = SelectedFields)
  output <- .glue$get_entity_records_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_entity_records <- glue_get_entity_records

#' This API is used for fetching the ResourceProperty of the Glue
#' connection (for the source) or Glue database ARN (for the target)
#'
#' @description
#' This API is used for fetching the `ResourceProperty` of the Glue
#' connection (for the source) or Glue database ARN (for the target)
#'
#' @usage
#' glue_get_integration_resource_property(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResourceArn = "string",
#'   SourceProcessingProperties = list(
#'     RoleArn = "string"
#'   ),
#'   TargetProcessingProperties = list(
#'     RoleArn = "string",
#'     KmsArn = "string",
#'     ConnectionName = "string",
#'     EventBusArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_integration_resource_property(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_integration_resource_property
#'
#' @aliases glue_get_integration_resource_property
glue_get_integration_resource_property <- function(ResourceArn) {
  op <- new_operation(
    name = "GetIntegrationResourceProperty",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_integration_resource_property_input(ResourceArn = ResourceArn)
  output <- .glue$get_integration_resource_property_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_integration_resource_property <- glue_get_integration_resource_property

#' This API is used to retrieve optional override properties for the tables
#' that need to be replicated
#'
#' @description
#' This API is used to retrieve optional override properties for the tables
#' that need to be replicated. These properties can include properties for
#' filtering and partition for source and target tables.
#'
#' @usage
#' glue_get_integration_table_properties(ResourceArn, TableName)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param TableName &#91;required&#93; The name of the table to be replicated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResourceArn = "string",
#'   TableName = "string",
#'   SourceTableConfig = list(
#'     Fields = list(
#'       "string"
#'     ),
#'     FilterPredicate = "string",
#'     PrimaryKey = list(
#'       "string"
#'     ),
#'     RecordUpdateField = "string"
#'   ),
#'   TargetTableConfig = list(
#'     UnnestSpec = "TOPLEVEL"|"FULL"|"NOUNNEST",
#'     PartitionSpec = list(
#'       list(
#'         FieldName = "string",
#'         FunctionSpec = "string"
#'       )
#'     ),
#'     TargetTableName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_integration_table_properties(
#'   ResourceArn = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_integration_table_properties
#'
#' @aliases glue_get_integration_table_properties
glue_get_integration_table_properties <- function(ResourceArn, TableName) {
  op <- new_operation(
    name = "GetIntegrationTableProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_integration_table_properties_input(ResourceArn = ResourceArn, TableName = TableName)
  output <- .glue$get_integration_table_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_integration_table_properties <- glue_get_integration_table_properties

#' Retrieves an existing job definition
#'
#' @description
#' Retrieves an existing job definition.
#'
#' @usage
#' glue_get_job(JobName)
#'
#' @param JobName &#91;required&#93; The name of the job definition to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Job = list(
#'     Name = "string",
#'     JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'     JobRunQueuingEnabled = TRUE|FALSE,
#'     Description = "string",
#'     LogUri = "string",
#'     Role = "string",
#'     CreatedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExecutionProperty = list(
#'       MaxConcurrentRuns = 123
#'     ),
#'     Command = list(
#'       Name = "string",
#'       ScriptLocation = "string",
#'       PythonVersion = "string",
#'       Runtime = "string"
#'     ),
#'     DefaultArguments = list(
#'       "string"
#'     ),
#'     NonOverridableArguments = list(
#'       "string"
#'     ),
#'     Connections = list(
#'       Connections = list(
#'         "string"
#'       )
#'     ),
#'     MaxRetries = 123,
#'     AllocatedCapacity = 123,
#'     Timeout = 123,
#'     MaxCapacity = 123.0,
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     NumberOfWorkers = 123,
#'     SecurityConfiguration = "string",
#'     NotificationProperty = list(
#'       NotifyDelayAfter = 123
#'     ),
#'     GlueVersion = "string",
#'     CodeGenConfigurationNodes = list(
#'       list(
#'         AthenaConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           ConnectionTable = "string",
#'           SchemaName = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         JDBCConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             FilterPredicate = "string",
#'             PartitionColumn = "string",
#'             LowerBound = 123,
#'             UpperBound = 123,
#'             NumPartitions = 123,
#'             JobBookmarkKeys = list(
#'               "string"
#'             ),
#'             JobBookmarkKeysSortOrder = "string",
#'             DataTypeMapping = list(
#'               "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE"
#'             )
#'           ),
#'           ConnectionTable = "string",
#'           Query = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         RedshiftSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           RedshiftTmpDir = "string",
#'           TmpDirIAMRole = "string"
#'         ),
#'         S3CatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           PartitionPredicate = "string",
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123
#'           )
#'         ),
#'         S3CsvSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "gzip"|"bzip2",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           Separator = "comma"|"ctrla"|"pipe"|"semicolon"|"tab",
#'           Escaper = "string",
#'           QuoteChar = "quote"|"quillemet"|"single_quote"|"disabled",
#'           Multiline = TRUE|FALSE,
#'           WithHeader = TRUE|FALSE,
#'           WriteHeader = TRUE|FALSE,
#'           SkipFirst = TRUE|FALSE,
#'           OptimizePerformance = TRUE|FALSE,
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3JsonSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "gzip"|"bzip2",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           JsonPath = "string",
#'           Multiline = TRUE|FALSE,
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3ParquetSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         RelationalCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         DynamoDBCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         JDBCConnectorTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           ConnectionTable = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkConnectorTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         RedshiftTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string",
#'           RedshiftTmpDir = "string",
#'           TmpDirIAMRole = "string",
#'           UpsertRedshiftOptions = list(
#'             TableLocation = "string",
#'             ConnectionName = "string",
#'             UpsertKeys = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         S3CatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3GlueParquetTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         S3DirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "string",
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         ApplyMapping = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Mapping = list(
#'             list(
#'               ToKey = "string",
#'               FromPath = list(
#'                 "string"
#'               ),
#'               FromType = "string",
#'               ToType = "string",
#'               Dropped = TRUE|FALSE,
#'               Children = list()
#'             )
#'           )
#'         ),
#'         SelectFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         DropFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         RenameField = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           SourcePath = list(
#'             "string"
#'           ),
#'           TargetPath = list(
#'             "string"
#'           )
#'         ),
#'         Spigot = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Path = "string",
#'           Topk = 123,
#'           Prob = 123.0
#'         ),
#'         Join = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           JoinType = "equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti",
#'           Columns = list(
#'             list(
#'               From = "string",
#'               Keys = list(
#'                 list(
#'                   "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SplitFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         SelectFromCollection = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Index = 123
#'         ),
#'         FillMissingValues = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ImputedPath = "string",
#'           FilledPath = "string"
#'         ),
#'         Filter = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           LogicalOperator = "AND"|"OR",
#'           Filters = list(
#'             list(
#'               Operation = "EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL",
#'               Negated = TRUE|FALSE,
#'               Values = list(
#'                 list(
#'                   Type = "COLUMNEXTRACTED"|"CONSTANT",
#'                   Value = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CustomCode = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Code = "string",
#'           ClassName = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkSQL = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           SqlQuery = "string",
#'           SqlAliases = list(
#'             list(
#'               From = "string",
#'               Alias = "string"
#'             )
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         DirectKinesisSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           StreamingOptions = list(
#'             EndpointUrl = "string",
#'             StreamName = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'             MaxFetchTimeInMs = 123,
#'             MaxFetchRecordsPerShard = 123,
#'             MaxRecordPerRead = 123,
#'             AddIdleTimeBetweenReads = TRUE|FALSE,
#'             IdleTimeBetweenReadsInMs = 123,
#'             DescribeShardInterval = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxRetryIntervalMs = 123,
#'             AvoidEmptyBatches = TRUE|FALSE,
#'             StreamArn = "string",
#'             RoleArn = "string",
#'             RoleSessionName = "string",
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         DirectKafkaSource = list(
#'           Name = "string",
#'           StreamingOptions = list(
#'             BootstrapServers = "string",
#'             SecurityProtocol = "string",
#'             ConnectionName = "string",
#'             TopicName = "string",
#'             Assign = "string",
#'             SubscribePattern = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingOffsets = "string",
#'             EndingOffsets = "string",
#'             PollTimeoutMs = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxOffsetsPerTrigger = 123,
#'             MinPartitions = 123,
#'             IncludeHeaders = TRUE|FALSE,
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         CatalogKinesisSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           Table = "string",
#'           Database = "string",
#'           StreamingOptions = list(
#'             EndpointUrl = "string",
#'             StreamName = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'             MaxFetchTimeInMs = 123,
#'             MaxFetchRecordsPerShard = 123,
#'             MaxRecordPerRead = 123,
#'             AddIdleTimeBetweenReads = TRUE|FALSE,
#'             IdleTimeBetweenReadsInMs = 123,
#'             DescribeShardInterval = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxRetryIntervalMs = 123,
#'             AvoidEmptyBatches = TRUE|FALSE,
#'             StreamArn = "string",
#'             RoleArn = "string",
#'             RoleSessionName = "string",
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         CatalogKafkaSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           Table = "string",
#'           Database = "string",
#'           StreamingOptions = list(
#'             BootstrapServers = "string",
#'             SecurityProtocol = "string",
#'             ConnectionName = "string",
#'             TopicName = "string",
#'             Assign = "string",
#'             SubscribePattern = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingOffsets = "string",
#'             EndingOffsets = "string",
#'             PollTimeoutMs = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxOffsetsPerTrigger = 123,
#'             MinPartitions = 123,
#'             IncludeHeaders = TRUE|FALSE,
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         DropNullFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           NullCheckBoxList = list(
#'             IsEmpty = TRUE|FALSE,
#'             IsNullString = TRUE|FALSE,
#'             IsNegOne = TRUE|FALSE
#'           ),
#'           NullTextList = list(
#'             list(
#'               Value = "string",
#'               Datatype = list(
#'                 Id = "string",
#'                 Label = "string"
#'               )
#'             )
#'           )
#'         ),
#'         Merge = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Source = "string",
#'           PrimaryKeys = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Union = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           UnionType = "ALL"|"DISTINCT"
#'         ),
#'         PIIDetection = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PiiType = "RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking",
#'           EntityTypesToDetect = list(
#'             "string"
#'           ),
#'           OutputColumnName = "string",
#'           SampleFraction = 123.0,
#'           ThresholdFraction = 123.0,
#'           MaskValue = "string"
#'         ),
#'         Aggregate = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Groups = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Aggs = list(
#'             list(
#'               Column = list(
#'                 "string"
#'               ),
#'               AggFunc = "avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"
#'             )
#'           )
#'         ),
#'         DropDuplicates = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Columns = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         GovernedCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         GovernedCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           PartitionPredicate = "string",
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123
#'           )
#'         ),
#'         MicrosoftSQLServerCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MySQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         OracleSQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         PostgreSQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MicrosoftSQLServerCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MySQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         OracleSQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         PostgreSQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         DynamicTransform = list(
#'           Name = "string",
#'           TransformName = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Parameters = list(
#'             list(
#'               Name = "string",
#'               Type = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'               ValidationRule = "string",
#'               ValidationMessage = "string",
#'               Value = list(
#'                 "string"
#'               ),
#'               ListType = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'               IsOptional = TRUE|FALSE
#'             )
#'           ),
#'           FunctionName = "string",
#'           Path = "string",
#'           Version = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         EvaluateDataQuality = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Ruleset = "string",
#'           Output = "PrimaryInput"|"EvaluationResults",
#'           PublishingOptions = list(
#'             EvaluationContext = "string",
#'             ResultsS3Prefix = "string",
#'             CloudWatchMetricsEnabled = TRUE|FALSE,
#'             ResultsPublishingEnabled = TRUE|FALSE
#'           ),
#'           StopJobOnFailureOptions = list(
#'             StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'           )
#'         ),
#'         S3CatalogHudiSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogHudiSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3HudiSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3HudiCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3HudiDirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Path = "string",
#'           Compression = "gzip"|"lzo"|"uncompressed"|"snappy",
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         DirectJDBCSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           ConnectionName = "string",
#'           ConnectionType = "sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift",
#'           RedshiftTmpDir = "string"
#'         ),
#'         S3CatalogDeltaSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogDeltaSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3DeltaSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3DeltaCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3DeltaDirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "uncompressed"|"snappy",
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         AmazonRedshiftSource = list(
#'           Name = "string",
#'           Data = list(
#'             AccessType = "string",
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Table = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogDatabase = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogTable = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogRedshiftSchema = "string",
#'             CatalogRedshiftTable = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdvancedOptions = list(
#'               list(
#'                 Key = "string",
#'                 Value = "string"
#'               )
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             TablePrefix = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             CrawlerConnection = "string",
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           )
#'         ),
#'         AmazonRedshiftTarget = list(
#'           Name = "string",
#'           Data = list(
#'             AccessType = "string",
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Table = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogDatabase = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogTable = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogRedshiftSchema = "string",
#'             CatalogRedshiftTable = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdvancedOptions = list(
#'               list(
#'                 Key = "string",
#'                 Value = "string"
#'               )
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             TablePrefix = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             CrawlerConnection = "string",
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         ),
#'         EvaluateDataQualityMultiFrame = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           AdditionalDataSources = list(
#'             "string"
#'           ),
#'           Ruleset = "string",
#'           PublishingOptions = list(
#'             EvaluationContext = "string",
#'             ResultsS3Prefix = "string",
#'             CloudWatchMetricsEnabled = TRUE|FALSE,
#'             ResultsPublishingEnabled = TRUE|FALSE
#'           ),
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           StopJobOnFailureOptions = list(
#'             StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'           )
#'         ),
#'         Recipe = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           RecipeReference = list(
#'             RecipeArn = "string",
#'             RecipeVersion = "string"
#'           ),
#'           RecipeSteps = list(
#'             list(
#'               Action = list(
#'                 Operation = "string",
#'                 Parameters = list(
#'                   "string"
#'                 )
#'               ),
#'               ConditionExpressions = list(
#'                 list(
#'                   Condition = "string",
#'                   Value = "string",
#'                   TargetColumn = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SnowflakeSource = list(
#'           Name = "string",
#'           Data = list(
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = "string",
#'             Table = "string",
#'             Database = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             AutoPushdown = TRUE|FALSE,
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SnowflakeTarget = list(
#'           Name = "string",
#'           Data = list(
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = "string",
#'             Table = "string",
#'             Database = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             AutoPushdown = TRUE|FALSE,
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         ),
#'         ConnectorDataSource = list(
#'           Name = "string",
#'           ConnectionType = "string",
#'           Data = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         ConnectorDataTarget = list(
#'           Name = "string",
#'           ConnectionType = "string",
#'           Data = list(
#'             "string"
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ExecutionClass = "FLEX"|"STANDARD",
#'     SourceControlDetails = list(
#'       Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'       Repository = "string",
#'       Owner = "string",
#'       Branch = "string",
#'       Folder = "string",
#'       LastCommitId = "string",
#'       AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'       AuthToken = "string"
#'     ),
#'     MaintenanceWindow = "string",
#'     ProfileName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job(
#'   JobName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_job
#'
#' @aliases glue_get_job
glue_get_job <- function(JobName) {
  op <- new_operation(
    name = "GetJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_job_input(JobName = JobName)
  output <- .glue$get_job_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_job <- glue_get_job

#' Returns information on a job bookmark entry
#'
#' @description
#' Returns information on a job bookmark entry.
#' 
#' For more information about enabling and using job bookmarks, see:
#' 
#' -   [Tracking processed data using job
#'     bookmarks](https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html)
#' 
#' -   [Job parameters used by
#'     Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html)
#' 
#' -   [Job
#'     structure](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html#aws-glue-api-jobs-job-Job)
#'
#' @usage
#' glue_get_job_bookmark(JobName, RunId)
#'
#' @param JobName &#91;required&#93; The name of the job in question.
#' @param RunId The unique run identifier associated with this job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobBookmarkEntry = list(
#'     JobName = "string",
#'     Version = 123,
#'     Run = 123,
#'     Attempt = 123,
#'     PreviousRunId = "string",
#'     RunId = "string",
#'     JobBookmark = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_bookmark(
#'   JobName = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_job_bookmark
#'
#' @aliases glue_get_job_bookmark
glue_get_job_bookmark <- function(JobName, RunId = NULL) {
  op <- new_operation(
    name = "GetJobBookmark",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_job_bookmark_input(JobName = JobName, RunId = RunId)
  output <- .glue$get_job_bookmark_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_job_bookmark <- glue_get_job_bookmark

#' Retrieves the metadata for a given job run
#'
#' @description
#' Retrieves the metadata for a given job run. Job run history is
#' accessible for 365 days for your workflow and job run.
#'
#' @usage
#' glue_get_job_run(JobName, RunId, PredecessorsIncluded)
#'
#' @param JobName &#91;required&#93; Name of the job definition being run.
#' @param RunId &#91;required&#93; The ID of the job run.
#' @param PredecessorsIncluded True if a list of predecessor runs should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobRun = list(
#'     Id = "string",
#'     Attempt = 123,
#'     PreviousRunId = "string",
#'     TriggerName = "string",
#'     JobName = "string",
#'     JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'     JobRunQueuingEnabled = TRUE|FALSE,
#'     StartedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'     Arguments = list(
#'       "string"
#'     ),
#'     ErrorMessage = "string",
#'     PredecessorRuns = list(
#'       list(
#'         JobName = "string",
#'         RunId = "string"
#'       )
#'     ),
#'     AllocatedCapacity = 123,
#'     ExecutionTime = 123,
#'     Timeout = 123,
#'     MaxCapacity = 123.0,
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     NumberOfWorkers = 123,
#'     SecurityConfiguration = "string",
#'     LogGroupName = "string",
#'     NotificationProperty = list(
#'       NotifyDelayAfter = 123
#'     ),
#'     GlueVersion = "string",
#'     DPUSeconds = 123.0,
#'     ExecutionClass = "FLEX"|"STANDARD",
#'     MaintenanceWindow = "string",
#'     ProfileName = "string",
#'     StateDetail = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_run(
#'   JobName = "string",
#'   RunId = "string",
#'   PredecessorsIncluded = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_job_run
#'
#' @aliases glue_get_job_run
glue_get_job_run <- function(JobName, RunId, PredecessorsIncluded = NULL) {
  op <- new_operation(
    name = "GetJobRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_job_run_input(JobName = JobName, RunId = RunId, PredecessorsIncluded = PredecessorsIncluded)
  output <- .glue$get_job_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_job_run <- glue_get_job_run

#' Retrieves metadata for all runs of a given job definition
#'
#' @description
#' Retrieves metadata for all runs of a given job definition.
#' 
#' [`get_job_runs`][glue_get_job_runs] returns the job runs in
#' chronological order, with the newest jobs returned first.
#'
#' @usage
#' glue_get_job_runs(JobName, NextToken, MaxResults)
#'
#' @param JobName &#91;required&#93; The name of the job definition for which to retrieve all job runs.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum size of the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobRuns = list(
#'     list(
#'       Id = "string",
#'       Attempt = 123,
#'       PreviousRunId = "string",
#'       TriggerName = "string",
#'       JobName = "string",
#'       JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'       JobRunQueuingEnabled = TRUE|FALSE,
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'       Arguments = list(
#'         "string"
#'       ),
#'       ErrorMessage = "string",
#'       PredecessorRuns = list(
#'         list(
#'           JobName = "string",
#'           RunId = "string"
#'         )
#'       ),
#'       AllocatedCapacity = 123,
#'       ExecutionTime = 123,
#'       Timeout = 123,
#'       MaxCapacity = 123.0,
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       NumberOfWorkers = 123,
#'       SecurityConfiguration = "string",
#'       LogGroupName = "string",
#'       NotificationProperty = list(
#'         NotifyDelayAfter = 123
#'       ),
#'       GlueVersion = "string",
#'       DPUSeconds = 123.0,
#'       ExecutionClass = "FLEX"|"STANDARD",
#'       MaintenanceWindow = "string",
#'       ProfileName = "string",
#'       StateDetail = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_runs(
#'   JobName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_job_runs
#'
#' @aliases glue_get_job_runs
glue_get_job_runs <- function(JobName, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetJobRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "JobRuns", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_job_runs_input(JobName = JobName, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_job_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_job_runs <- glue_get_job_runs

#' Retrieves all current job definitions
#'
#' @description
#' Retrieves all current job definitions.
#'
#' @usage
#' glue_get_jobs(NextToken, MaxResults)
#'
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum size of the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Jobs = list(
#'     list(
#'       Name = "string",
#'       JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'       JobRunQueuingEnabled = TRUE|FALSE,
#'       Description = "string",
#'       LogUri = "string",
#'       Role = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExecutionProperty = list(
#'         MaxConcurrentRuns = 123
#'       ),
#'       Command = list(
#'         Name = "string",
#'         ScriptLocation = "string",
#'         PythonVersion = "string",
#'         Runtime = "string"
#'       ),
#'       DefaultArguments = list(
#'         "string"
#'       ),
#'       NonOverridableArguments = list(
#'         "string"
#'       ),
#'       Connections = list(
#'         Connections = list(
#'           "string"
#'         )
#'       ),
#'       MaxRetries = 123,
#'       AllocatedCapacity = 123,
#'       Timeout = 123,
#'       MaxCapacity = 123.0,
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       NumberOfWorkers = 123,
#'       SecurityConfiguration = "string",
#'       NotificationProperty = list(
#'         NotifyDelayAfter = 123
#'       ),
#'       GlueVersion = "string",
#'       CodeGenConfigurationNodes = list(
#'         list(
#'           AthenaConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             ConnectionTable = "string",
#'             SchemaName = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           JDBCConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               FilterPredicate = "string",
#'               PartitionColumn = "string",
#'               LowerBound = 123,
#'               UpperBound = 123,
#'               NumPartitions = 123,
#'               JobBookmarkKeys = list(
#'                 "string"
#'               ),
#'               JobBookmarkKeysSortOrder = "string",
#'               DataTypeMapping = list(
#'                 "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE"
#'               )
#'             ),
#'             ConnectionTable = "string",
#'             Query = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkConnectorSource = list(
#'             Name = "string",
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           RedshiftSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             RedshiftTmpDir = "string",
#'             TmpDirIAMRole = "string"
#'           ),
#'           S3CatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             PartitionPredicate = "string",
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123
#'             )
#'           ),
#'           S3CsvSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "gzip"|"bzip2",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             Separator = "comma"|"ctrla"|"pipe"|"semicolon"|"tab",
#'             Escaper = "string",
#'             QuoteChar = "quote"|"quillemet"|"single_quote"|"disabled",
#'             Multiline = TRUE|FALSE,
#'             WithHeader = TRUE|FALSE,
#'             WriteHeader = TRUE|FALSE,
#'             SkipFirst = TRUE|FALSE,
#'             OptimizePerformance = TRUE|FALSE,
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3JsonSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "gzip"|"bzip2",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             JsonPath = "string",
#'             Multiline = TRUE|FALSE,
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3ParquetSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             CompressionType = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'             Exclusions = list(
#'               "string"
#'             ),
#'             GroupSize = "string",
#'             GroupFiles = "string",
#'             Recurse = TRUE|FALSE,
#'             MaxBand = 123,
#'             MaxFilesInBand = 123,
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           RelationalCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           DynamoDBCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           JDBCConnectorTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             ConnectionTable = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkConnectorTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ConnectionName = "string",
#'             ConnectorName = "string",
#'             ConnectionType = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           RedshiftTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string",
#'             RedshiftTmpDir = "string",
#'             TmpDirIAMRole = "string",
#'             UpsertRedshiftOptions = list(
#'               TableLocation = "string",
#'               ConnectionName = "string",
#'               UpsertKeys = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           S3CatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3GlueParquetTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           S3DirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "string",
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           ApplyMapping = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Mapping = list(
#'               list(
#'                 ToKey = "string",
#'                 FromPath = list(
#'                   "string"
#'                 ),
#'                 FromType = "string",
#'                 ToType = "string",
#'                 Dropped = TRUE|FALSE,
#'                 Children = list()
#'               )
#'             )
#'           ),
#'           SelectFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           DropFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           RenameField = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             SourcePath = list(
#'               "string"
#'             ),
#'             TargetPath = list(
#'               "string"
#'             )
#'           ),
#'           Spigot = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Path = "string",
#'             Topk = 123,
#'             Prob = 123.0
#'           ),
#'           Join = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             JoinType = "equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti",
#'             Columns = list(
#'               list(
#'                 From = "string",
#'                 Keys = list(
#'                   list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SplitFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Paths = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           SelectFromCollection = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Index = 123
#'           ),
#'           FillMissingValues = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             ImputedPath = "string",
#'             FilledPath = "string"
#'           ),
#'           Filter = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             LogicalOperator = "AND"|"OR",
#'             Filters = list(
#'               list(
#'                 Operation = "EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL",
#'                 Negated = TRUE|FALSE,
#'                 Values = list(
#'                   list(
#'                     Type = "COLUMNEXTRACTED"|"CONSTANT",
#'                     Value = list(
#'                       "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CustomCode = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Code = "string",
#'             ClassName = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SparkSQL = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             SqlQuery = "string",
#'             SqlAliases = list(
#'               list(
#'                 From = "string",
#'                 Alias = "string"
#'               )
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           DirectKinesisSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             StreamingOptions = list(
#'               EndpointUrl = "string",
#'               StreamName = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'               MaxFetchTimeInMs = 123,
#'               MaxFetchRecordsPerShard = 123,
#'               MaxRecordPerRead = 123,
#'               AddIdleTimeBetweenReads = TRUE|FALSE,
#'               IdleTimeBetweenReadsInMs = 123,
#'               DescribeShardInterval = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxRetryIntervalMs = 123,
#'               AvoidEmptyBatches = TRUE|FALSE,
#'               StreamArn = "string",
#'               RoleArn = "string",
#'               RoleSessionName = "string",
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           DirectKafkaSource = list(
#'             Name = "string",
#'             StreamingOptions = list(
#'               BootstrapServers = "string",
#'               SecurityProtocol = "string",
#'               ConnectionName = "string",
#'               TopicName = "string",
#'               Assign = "string",
#'               SubscribePattern = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingOffsets = "string",
#'               EndingOffsets = "string",
#'               PollTimeoutMs = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxOffsetsPerTrigger = 123,
#'               MinPartitions = 123,
#'               IncludeHeaders = TRUE|FALSE,
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           CatalogKinesisSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             Table = "string",
#'             Database = "string",
#'             StreamingOptions = list(
#'               EndpointUrl = "string",
#'               StreamName = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'               MaxFetchTimeInMs = 123,
#'               MaxFetchRecordsPerShard = 123,
#'               MaxRecordPerRead = 123,
#'               AddIdleTimeBetweenReads = TRUE|FALSE,
#'               IdleTimeBetweenReadsInMs = 123,
#'               DescribeShardInterval = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxRetryIntervalMs = 123,
#'               AvoidEmptyBatches = TRUE|FALSE,
#'               StreamArn = "string",
#'               RoleArn = "string",
#'               RoleSessionName = "string",
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           CatalogKafkaSource = list(
#'             Name = "string",
#'             WindowSize = 123,
#'             DetectSchema = TRUE|FALSE,
#'             Table = "string",
#'             Database = "string",
#'             StreamingOptions = list(
#'               BootstrapServers = "string",
#'               SecurityProtocol = "string",
#'               ConnectionName = "string",
#'               TopicName = "string",
#'               Assign = "string",
#'               SubscribePattern = "string",
#'               Classification = "string",
#'               Delimiter = "string",
#'               StartingOffsets = "string",
#'               EndingOffsets = "string",
#'               PollTimeoutMs = 123,
#'               NumRetries = 123,
#'               RetryIntervalMs = 123,
#'               MaxOffsetsPerTrigger = 123,
#'               MinPartitions = 123,
#'               IncludeHeaders = TRUE|FALSE,
#'               AddRecordTimestamp = "string",
#'               EmitConsumerLagMetrics = "string",
#'               StartingTimestamp = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             ),
#'             DataPreviewOptions = list(
#'               PollingTime = 123,
#'               RecordPollingLimit = 123
#'             )
#'           ),
#'           DropNullFields = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             NullCheckBoxList = list(
#'               IsEmpty = TRUE|FALSE,
#'               IsNullString = TRUE|FALSE,
#'               IsNegOne = TRUE|FALSE
#'             ),
#'             NullTextList = list(
#'               list(
#'                 Value = "string",
#'                 Datatype = list(
#'                   Id = "string",
#'                   Label = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           Merge = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Source = "string",
#'             PrimaryKeys = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           Union = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             UnionType = "ALL"|"DISTINCT"
#'           ),
#'           PIIDetection = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PiiType = "RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking",
#'             EntityTypesToDetect = list(
#'               "string"
#'             ),
#'             OutputColumnName = "string",
#'             SampleFraction = 123.0,
#'             ThresholdFraction = 123.0,
#'             MaskValue = "string"
#'           ),
#'           Aggregate = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Groups = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Aggs = list(
#'               list(
#'                 Column = list(
#'                   "string"
#'                 ),
#'                 AggFunc = "avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"
#'               )
#'             )
#'           ),
#'           DropDuplicates = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Columns = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           GovernedCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           GovernedCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             PartitionPredicate = "string",
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123
#'             )
#'           ),
#'           MicrosoftSQLServerCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MySQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           OracleSQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           PostgreSQLCatalogSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MicrosoftSQLServerCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           MySQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           OracleSQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           PostgreSQLCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Database = "string",
#'             Table = "string"
#'           ),
#'           DynamicTransform = list(
#'             Name = "string",
#'             TransformName = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Parameters = list(
#'               list(
#'                 Name = "string",
#'                 Type = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'                 ValidationRule = "string",
#'                 ValidationMessage = "string",
#'                 Value = list(
#'                   "string"
#'                 ),
#'                 ListType = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'                 IsOptional = TRUE|FALSE
#'               )
#'             ),
#'             FunctionName = "string",
#'             Path = "string",
#'             Version = "string",
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           EvaluateDataQuality = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Ruleset = "string",
#'             Output = "PrimaryInput"|"EvaluationResults",
#'             PublishingOptions = list(
#'               EvaluationContext = "string",
#'               ResultsS3Prefix = "string",
#'               CloudWatchMetricsEnabled = TRUE|FALSE,
#'               ResultsPublishingEnabled = TRUE|FALSE
#'             ),
#'             StopJobOnFailureOptions = list(
#'               StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'             )
#'           ),
#'           S3CatalogHudiSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogHudiSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3HudiSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             AdditionalHudiOptions = list(
#'               "string"
#'             ),
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3HudiCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3HudiDirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             Path = "string",
#'             Compression = "gzip"|"lzo"|"uncompressed"|"snappy",
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           DirectJDBCSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             ConnectionName = "string",
#'             ConnectionType = "sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift",
#'             RedshiftTmpDir = "string"
#'           ),
#'           S3CatalogDeltaSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           CatalogDeltaSource = list(
#'             Name = "string",
#'             Database = "string",
#'             Table = "string",
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3DeltaSource = list(
#'             Name = "string",
#'             Paths = list(
#'               "string"
#'             ),
#'             AdditionalDeltaOptions = list(
#'               "string"
#'             ),
#'             AdditionalOptions = list(
#'               BoundedSize = 123,
#'               BoundedFiles = 123,
#'               EnableSamplePath = TRUE|FALSE,
#'               SamplePath = "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           S3DeltaCatalogTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Table = "string",
#'             Database = "string",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'             )
#'           ),
#'           S3DeltaDirectTarget = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             PartitionKeys = list(
#'               list(
#'                 "string"
#'               )
#'             ),
#'             Path = "string",
#'             Compression = "uncompressed"|"snappy",
#'             Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SchemaChangePolicy = list(
#'               EnableUpdateCatalog = TRUE|FALSE,
#'               UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'               Table = "string",
#'               Database = "string"
#'             )
#'           ),
#'           AmazonRedshiftSource = list(
#'             Name = "string",
#'             Data = list(
#'               AccessType = "string",
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Table = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogDatabase = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogTable = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogRedshiftSchema = "string",
#'               CatalogRedshiftTable = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdvancedOptions = list(
#'                 list(
#'                   Key = "string",
#'                   Value = "string"
#'                 )
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               TablePrefix = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               CrawlerConnection = "string",
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           AmazonRedshiftTarget = list(
#'             Name = "string",
#'             Data = list(
#'               AccessType = "string",
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Table = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogDatabase = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogTable = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               CatalogRedshiftSchema = "string",
#'               CatalogRedshiftTable = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdvancedOptions = list(
#'                 list(
#'                   Key = "string",
#'                   Value = "string"
#'                 )
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               TablePrefix = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               CrawlerConnection = "string",
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           ),
#'           EvaluateDataQualityMultiFrame = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             AdditionalDataSources = list(
#'               "string"
#'             ),
#'             Ruleset = "string",
#'             PublishingOptions = list(
#'               EvaluationContext = "string",
#'               ResultsS3Prefix = "string",
#'               CloudWatchMetricsEnabled = TRUE|FALSE,
#'               ResultsPublishingEnabled = TRUE|FALSE
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             StopJobOnFailureOptions = list(
#'               StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'             )
#'           ),
#'           Recipe = list(
#'             Name = "string",
#'             Inputs = list(
#'               "string"
#'             ),
#'             RecipeReference = list(
#'               RecipeArn = "string",
#'               RecipeVersion = "string"
#'             ),
#'             RecipeSteps = list(
#'               list(
#'                 Action = list(
#'                   Operation = "string",
#'                   Parameters = list(
#'                     "string"
#'                   )
#'                 ),
#'                 ConditionExpressions = list(
#'                   list(
#'                     Condition = "string",
#'                     Value = "string",
#'                     TargetColumn = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SnowflakeSource = list(
#'             Name = "string",
#'             Data = list(
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = "string",
#'               Table = "string",
#'               Database = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdditionalOptions = list(
#'                 "string"
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               AutoPushdown = TRUE|FALSE,
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           SnowflakeTarget = list(
#'             Name = "string",
#'             Data = list(
#'               SourceType = "string",
#'               Connection = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               Schema = "string",
#'               Table = "string",
#'               Database = "string",
#'               TempDir = "string",
#'               IamRole = list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               ),
#'               AdditionalOptions = list(
#'                 "string"
#'               ),
#'               SampleQuery = "string",
#'               PreAction = "string",
#'               PostAction = "string",
#'               Action = "string",
#'               Upsert = TRUE|FALSE,
#'               MergeAction = "string",
#'               MergeWhenMatched = "string",
#'               MergeWhenNotMatched = "string",
#'               MergeClause = "string",
#'               StagingTable = "string",
#'               SelectedColumns = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               ),
#'               AutoPushdown = TRUE|FALSE,
#'               TableSchema = list(
#'                 list(
#'                   Value = "string",
#'                   Label = "string",
#'                   Description = "string"
#'                 )
#'               )
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           ),
#'           ConnectorDataSource = list(
#'             Name = "string",
#'             ConnectionType = "string",
#'             Data = list(
#'               "string"
#'             ),
#'             OutputSchemas = list(
#'               list(
#'                 Columns = list(
#'                   list(
#'                     Name = "string",
#'                     Type = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           ConnectorDataTarget = list(
#'             Name = "string",
#'             ConnectionType = "string",
#'             Data = list(
#'               "string"
#'             ),
#'             Inputs = list(
#'               "string"
#'             )
#'           )
#'         )
#'       ),
#'       ExecutionClass = "FLEX"|"STANDARD",
#'       SourceControlDetails = list(
#'         Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'         Repository = "string",
#'         Owner = "string",
#'         Branch = "string",
#'         Folder = "string",
#'         LastCommitId = "string",
#'         AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'         AuthToken = "string"
#'       ),
#'       MaintenanceWindow = "string",
#'       ProfileName = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_jobs(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_jobs
#'
#' @aliases glue_get_jobs
glue_get_jobs <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "Jobs", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_jobs_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_jobs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_jobs <- glue_get_jobs

#' Gets details for a specific task run on a machine learning transform
#'
#' @description
#' Gets details for a specific task run on a machine learning transform.
#' Machine learning task runs are asynchronous tasks that Glue runs on your
#' behalf as part of various machine learning workflows. You can check the
#' stats of any task run by calling
#' [`get_ml_task_run`][glue_get_ml_task_run] with the `TaskRunID` and its
#' parent transform's `TransformID`.
#'
#' @usage
#' glue_get_ml_task_run(TransformId, TaskRunId)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param TaskRunId &#91;required&#93; The unique identifier of the task run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string",
#'   TaskRunId = "string",
#'   Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'   LogGroupName = "string",
#'   Properties = list(
#'     TaskType = "EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES",
#'     ImportLabelsTaskRunProperties = list(
#'       InputS3Path = "string",
#'       Replace = TRUE|FALSE
#'     ),
#'     ExportLabelsTaskRunProperties = list(
#'       OutputS3Path = "string"
#'     ),
#'     LabelingSetGenerationTaskRunProperties = list(
#'       OutputS3Path = "string"
#'     ),
#'     FindMatchesTaskRunProperties = list(
#'       JobId = "string",
#'       JobName = "string",
#'       JobRunId = "string"
#'     )
#'   ),
#'   ErrorString = "string",
#'   StartedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CompletedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ExecutionTime = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_ml_task_run(
#'   TransformId = "string",
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_ml_task_run
#'
#' @aliases glue_get_ml_task_run
glue_get_ml_task_run <- function(TransformId, TaskRunId) {
  op <- new_operation(
    name = "GetMLTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_ml_task_run_input(TransformId = TransformId, TaskRunId = TaskRunId)
  output <- .glue$get_ml_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_ml_task_run <- glue_get_ml_task_run

#' Gets a list of runs for a machine learning transform
#'
#' @description
#' Gets a list of runs for a machine learning transform. Machine learning
#' task runs are asynchronous tasks that Glue runs on your behalf as part
#' of various machine learning workflows. You can get a sortable,
#' filterable list of machine learning task runs by calling
#' [`get_ml_task_runs`][glue_get_ml_task_runs] with their parent
#' transform's `TransformID` and other optional parameters as documented in
#' this section.
#' 
#' This operation returns a list of historic runs and must be paginated.
#'
#' @usage
#' glue_get_ml_task_runs(TransformId, NextToken, MaxResults, Filter, Sort)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param NextToken A token for pagination of the results. The default is empty.
#' @param MaxResults The maximum number of results to return.
#' @param Filter The filter criteria, in the `TaskRunFilterCriteria` structure, for the
#' task run.
#' @param Sort The sorting criteria, in the `TaskRunSortCriteria` structure, for the
#' task run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TaskRuns = list(
#'     list(
#'       TransformId = "string",
#'       TaskRunId = "string",
#'       Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'       LogGroupName = "string",
#'       Properties = list(
#'         TaskType = "EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES",
#'         ImportLabelsTaskRunProperties = list(
#'           InputS3Path = "string",
#'           Replace = TRUE|FALSE
#'         ),
#'         ExportLabelsTaskRunProperties = list(
#'           OutputS3Path = "string"
#'         ),
#'         LabelingSetGenerationTaskRunProperties = list(
#'           OutputS3Path = "string"
#'         ),
#'         FindMatchesTaskRunProperties = list(
#'           JobId = "string",
#'           JobName = "string",
#'           JobRunId = "string"
#'         )
#'       ),
#'       ErrorString = "string",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExecutionTime = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_ml_task_runs(
#'   TransformId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Filter = list(
#'     TaskRunType = "EVALUATION"|"LABELING_SET_GENERATION"|"IMPORT_LABELS"|"EXPORT_LABELS"|"FIND_MATCHES",
#'     Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'     StartedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StartedAfter = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   Sort = list(
#'     Column = "TASK_RUN_TYPE"|"STATUS"|"STARTED",
#'     SortDirection = "DESCENDING"|"ASCENDING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_ml_task_runs
#'
#' @aliases glue_get_ml_task_runs
glue_get_ml_task_runs <- function(TransformId, NextToken = NULL, MaxResults = NULL, Filter = NULL, Sort = NULL) {
  op <- new_operation(
    name = "GetMLTaskRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$get_ml_task_runs_input(TransformId = TransformId, NextToken = NextToken, MaxResults = MaxResults, Filter = Filter, Sort = Sort)
  output <- .glue$get_ml_task_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_ml_task_runs <- glue_get_ml_task_runs

#' Gets an Glue machine learning transform artifact and all its
#' corresponding metadata
#'
#' @description
#' Gets an Glue machine learning transform artifact and all its
#' corresponding metadata. Machine learning transforms are a special type
#' of transform that use machine learning to learn the details of the
#' transformation to be performed by learning from examples provided by
#' humans. These transformations are then saved by Glue. You can retrieve
#' their metadata by calling [`get_ml_transform`][glue_get_ml_transform].
#'
#' @usage
#' glue_get_ml_transform(TransformId)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the transform, generated at the time that the
#' transform was created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string",
#'   Name = "string",
#'   Description = "string",
#'   Status = "NOT_READY"|"READY"|"DELETING",
#'   CreatedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   InputRecordTables = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Parameters = list(
#'     TransformType = "FIND_MATCHES",
#'     FindMatchesParameters = list(
#'       PrimaryKeyColumnName = "string",
#'       PrecisionRecallTradeoff = 123.0,
#'       AccuracyCostTradeoff = 123.0,
#'       EnforceProvidedLabels = TRUE|FALSE
#'     )
#'   ),
#'   EvaluationMetrics = list(
#'     TransformType = "FIND_MATCHES",
#'     FindMatchesMetrics = list(
#'       AreaUnderPRCurve = 123.0,
#'       Precision = 123.0,
#'       Recall = 123.0,
#'       F1 = 123.0,
#'       ConfusionMatrix = list(
#'         NumTruePositives = 123,
#'         NumFalsePositives = 123,
#'         NumTrueNegatives = 123,
#'         NumFalseNegatives = 123
#'       ),
#'       ColumnImportances = list(
#'         list(
#'           ColumnName = "string",
#'           Importance = 123.0
#'         )
#'       )
#'     )
#'   ),
#'   LabelCount = 123,
#'   Schema = list(
#'     list(
#'       Name = "string",
#'       DataType = "string"
#'     )
#'   ),
#'   Role = "string",
#'   GlueVersion = "string",
#'   MaxCapacity = 123.0,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   MaxRetries = 123,
#'   TransformEncryption = list(
#'     MlUserDataEncryption = list(
#'       MlUserDataEncryptionMode = "DISABLED"|"SSE-KMS",
#'       KmsKeyId = "string"
#'     ),
#'     TaskRunSecurityConfigurationName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_ml_transform(
#'   TransformId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_ml_transform
#'
#' @aliases glue_get_ml_transform
glue_get_ml_transform <- function(TransformId) {
  op <- new_operation(
    name = "GetMLTransform",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_ml_transform_input(TransformId = TransformId)
  output <- .glue$get_ml_transform_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_ml_transform <- glue_get_ml_transform

#' Gets a sortable, filterable list of existing Glue machine learning
#' transforms
#'
#' @description
#' Gets a sortable, filterable list of existing Glue machine learning
#' transforms. Machine learning transforms are a special type of transform
#' that use machine learning to learn the details of the transformation to
#' be performed by learning from examples provided by humans. These
#' transformations are then saved by Glue, and you can retrieve their
#' metadata by calling [`get_ml_transforms`][glue_get_ml_transforms].
#'
#' @usage
#' glue_get_ml_transforms(NextToken, MaxResults, Filter, Sort)
#'
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#' @param Filter The filter transformation criteria.
#' @param Sort The sorting criteria.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Transforms = list(
#'     list(
#'       TransformId = "string",
#'       Name = "string",
#'       Description = "string",
#'       Status = "NOT_READY"|"READY"|"DELETING",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       InputRecordTables = list(
#'         list(
#'           DatabaseName = "string",
#'           TableName = "string",
#'           CatalogId = "string",
#'           ConnectionName = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Parameters = list(
#'         TransformType = "FIND_MATCHES",
#'         FindMatchesParameters = list(
#'           PrimaryKeyColumnName = "string",
#'           PrecisionRecallTradeoff = 123.0,
#'           AccuracyCostTradeoff = 123.0,
#'           EnforceProvidedLabels = TRUE|FALSE
#'         )
#'       ),
#'       EvaluationMetrics = list(
#'         TransformType = "FIND_MATCHES",
#'         FindMatchesMetrics = list(
#'           AreaUnderPRCurve = 123.0,
#'           Precision = 123.0,
#'           Recall = 123.0,
#'           F1 = 123.0,
#'           ConfusionMatrix = list(
#'             NumTruePositives = 123,
#'             NumFalsePositives = 123,
#'             NumTrueNegatives = 123,
#'             NumFalseNegatives = 123
#'           ),
#'           ColumnImportances = list(
#'             list(
#'               ColumnName = "string",
#'               Importance = 123.0
#'             )
#'           )
#'         )
#'       ),
#'       LabelCount = 123,
#'       Schema = list(
#'         list(
#'           Name = "string",
#'           DataType = "string"
#'         )
#'       ),
#'       Role = "string",
#'       GlueVersion = "string",
#'       MaxCapacity = 123.0,
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       NumberOfWorkers = 123,
#'       Timeout = 123,
#'       MaxRetries = 123,
#'       TransformEncryption = list(
#'         MlUserDataEncryption = list(
#'           MlUserDataEncryptionMode = "DISABLED"|"SSE-KMS",
#'           KmsKeyId = "string"
#'         ),
#'         TaskRunSecurityConfigurationName = "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_ml_transforms(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Filter = list(
#'     Name = "string",
#'     TransformType = "FIND_MATCHES",
#'     Status = "NOT_READY"|"READY"|"DELETING",
#'     GlueVersion = "string",
#'     CreatedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreatedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Schema = list(
#'       list(
#'         Name = "string",
#'         DataType = "string"
#'       )
#'     )
#'   ),
#'   Sort = list(
#'     Column = "NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED",
#'     SortDirection = "DESCENDING"|"ASCENDING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_ml_transforms
#'
#' @aliases glue_get_ml_transforms
glue_get_ml_transforms <- function(NextToken = NULL, MaxResults = NULL, Filter = NULL, Sort = NULL) {
  op <- new_operation(
    name = "GetMLTransforms",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$get_ml_transforms_input(NextToken = NextToken, MaxResults = MaxResults, Filter = Filter, Sort = Sort)
  output <- .glue$get_ml_transforms_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_ml_transforms <- glue_get_ml_transforms

#' Creates mappings
#'
#' @description
#' Creates mappings.
#'
#' @usage
#' glue_get_mapping(Source, Sinks, Location)
#'
#' @param Source &#91;required&#93; Specifies the source table.
#' @param Sinks A list of target tables.
#' @param Location Parameters for the mapping.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Mapping = list(
#'     list(
#'       SourceTable = "string",
#'       SourcePath = "string",
#'       SourceType = "string",
#'       TargetTable = "string",
#'       TargetPath = "string",
#'       TargetType = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_mapping(
#'   Source = list(
#'     DatabaseName = "string",
#'     TableName = "string"
#'   ),
#'   Sinks = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string"
#'     )
#'   ),
#'   Location = list(
#'     Jdbc = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     S3 = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDB = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_mapping
#'
#' @aliases glue_get_mapping
glue_get_mapping <- function(Source, Sinks = NULL, Location = NULL) {
  op <- new_operation(
    name = "GetMapping",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_mapping_input(Source = Source, Sinks = Sinks, Location = Location)
  output <- .glue$get_mapping_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_mapping <- glue_get_mapping

#' Retrieves information about a specified partition
#'
#' @description
#' Retrieves information about a specified partition.
#'
#' @usage
#' glue_get_partition(CatalogId, DatabaseName, TableName, PartitionValues)
#'
#' @param CatalogId The ID of the Data Catalog where the partition in question resides. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partition resides.
#' @param TableName &#91;required&#93; The name of the partition's table.
#' @param PartitionValues &#91;required&#93; The values that define the partition.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Partition = list(
#'     Values = list(
#'       "string"
#'     ),
#'     DatabaseName = "string",
#'     TableName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CatalogId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_partition
#'
#' @aliases glue_get_partition
glue_get_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValues) {
  op <- new_operation(
    name = "GetPartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues)
  output <- .glue$get_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_partition <- glue_get_partition

#' Retrieves the partition indexes associated with a table
#'
#' @description
#' Retrieves the partition indexes associated with a table.
#'
#' @usage
#' glue_get_partition_indexes(CatalogId, DatabaseName, TableName,
#'   NextToken)
#'
#' @param CatalogId The catalog ID where the table resides.
#' @param DatabaseName &#91;required&#93; Specifies the name of a database from which you want to retrieve
#' partition indexes.
#' @param TableName &#91;required&#93; Specifies the name of a table for which you want to retrieve the
#' partition indexes.
#' @param NextToken A continuation token, included if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PartitionIndexDescriptorList = list(
#'     list(
#'       IndexName = "string",
#'       Keys = list(
#'         list(
#'           Name = "string",
#'           Type = "string"
#'         )
#'       ),
#'       IndexStatus = "CREATING"|"ACTIVE"|"DELETING"|"FAILED",
#'       BackfillErrors = list(
#'         list(
#'           Code = "ENCRYPTED_PARTITION_ERROR"|"INTERNAL_ERROR"|"INVALID_PARTITION_TYPE_DATA_ERROR"|"MISSING_PARTITION_VALUE_ERROR"|"UNSUPPORTED_PARTITION_CHARACTER_ERROR",
#'           Partitions = list(
#'             list(
#'               Values = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_partition_indexes(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_partition_indexes
#'
#' @aliases glue_get_partition_indexes
glue_get_partition_indexes <- function(CatalogId = NULL, DatabaseName, TableName, NextToken = NULL) {
  op <- new_operation(
    name = "GetPartitionIndexes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", result_key = "PartitionIndexDescriptorList"),
    stream_api = FALSE
  )
  input <- .glue$get_partition_indexes_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, NextToken = NextToken)
  output <- .glue$get_partition_indexes_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_partition_indexes <- glue_get_partition_indexes

#' Retrieves information about the partitions in a table
#'
#' @description
#' Retrieves information about the partitions in a table.
#'
#' @usage
#' glue_get_partitions(CatalogId, DatabaseName, TableName, Expression,
#'   NextToken, Segment, MaxResults, ExcludeColumnSchema, TransactionId,
#'   QueryAsOfTime)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param Expression An expression that filters the partitions to be returned.
#' 
#' The expression uses SQL syntax similar to the SQL `WHERE` filter clause.
#' The SQL statement parser
#' [JSQLParser](https://jsqlparser.sourceforge.net/home.php) parses the
#' expression.
#' 
#' *Operators*: The following are the operators that you can use in the
#' `Expression` API call:
#' 
#' **=**
#' 
#' Checks whether the values of the two operands are equal; if yes, then
#' the condition becomes true.
#' 
#' Example: Assume 'variable a' holds 10 and 'variable b' holds 20.
#' 
#' (a = b) is not true.
#' 
#' **\< \>**
#' 
#' Checks whether the values of two operands are equal; if the values are
#' not equal, then the condition becomes true.
#' 
#' Example: (a \< \> b) is true.
#' 
#' **\>**
#' 
#' Checks whether the value of the left operand is greater than the value
#' of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \> b) is not true.
#' 
#' **\<**
#' 
#' Checks whether the value of the left operand is less than the value of
#' the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \< b) is true.
#' 
#' **\>=**
#' 
#' Checks whether the value of the left operand is greater than or equal to
#' the value of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \>= b) is not true.
#' 
#' **\<=**
#' 
#' Checks whether the value of the left operand is less than or equal to
#' the value of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \<= b) is true.
#' 
#' **AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL**
#' 
#' Logical operators.
#' 
#' *Supported Partition Key Types*: The following are the supported
#' partition keys.
#' 
#' -   `string`
#' 
#' -   `date`
#' 
#' -   `timestamp`
#' 
#' -   `int`
#' 
#' -   `bigint`
#' 
#' -   `long`
#' 
#' -   `tinyint`
#' 
#' -   `smallint`
#' 
#' -   `decimal`
#' 
#' If an type is encountered that is not valid, an exception is thrown.
#' 
#' The following list shows the valid operators on each type. When you
#' define a crawler, the `partitionKey` type is created as a `STRING`, to
#' be compatible with the catalog partitions.
#' 
#' *Sample API Call*:
#' @param NextToken A continuation token, if this is not the first call to retrieve these
#' partitions.
#' @param Segment The segment of the table's partitions to scan in this request.
#' @param MaxResults The maximum number of partitions to return in a single response.
#' @param ExcludeColumnSchema When true, specifies not returning the partition column schema. Useful
#' when you are interested only in other partition attributes such as
#' partition values or location. This approach avoids the problem of a
#' large response by not returning duplicate data.
#' @param TransactionId The transaction ID at which to read the partition contents.
#' @param QueryAsOfTime The time as of when to read the partition contents. If not set, the most
#' recent transaction commit time will be used. Cannot be specified along
#' with `TransactionId`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Partitions = list(
#'     list(
#'       Values = list(
#'         "string"
#'       ),
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CatalogId = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_partitions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Expression = "string",
#'   NextToken = "string",
#'   Segment = list(
#'     SegmentNumber = 123,
#'     TotalSegments = 123
#'   ),
#'   MaxResults = 123,
#'   ExcludeColumnSchema = TRUE|FALSE,
#'   TransactionId = "string",
#'   QueryAsOfTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_partitions
#'
#' @aliases glue_get_partitions
glue_get_partitions <- function(CatalogId = NULL, DatabaseName, TableName, Expression = NULL, NextToken = NULL, Segment = NULL, MaxResults = NULL, ExcludeColumnSchema = NULL, TransactionId = NULL, QueryAsOfTime = NULL) {
  op <- new_operation(
    name = "GetPartitions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "Partitions", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_partitions_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Expression = Expression, NextToken = NextToken, Segment = Segment, MaxResults = MaxResults, ExcludeColumnSchema = ExcludeColumnSchema, TransactionId = TransactionId, QueryAsOfTime = QueryAsOfTime)
  output <- .glue$get_partitions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_partitions <- glue_get_partitions

#' Gets code to perform a specified mapping
#'
#' @description
#' Gets code to perform a specified mapping.
#'
#' @usage
#' glue_get_plan(Mapping, Source, Sinks, Location, Language,
#'   AdditionalPlanOptionsMap)
#'
#' @param Mapping &#91;required&#93; The list of mappings from a source table to target tables.
#' @param Source &#91;required&#93; The source table.
#' @param Sinks The target tables.
#' @param Location The parameters for the mapping.
#' @param Language The programming language of the code to perform the mapping.
#' @param AdditionalPlanOptionsMap A map to hold additional optional key-value parameters.
#' 
#' Currently, these key-value pairs are supported:
#' 
#' -   `inferSchema`  —  Specifies whether to set `inferSchema` to true or
#'     false for the default script generated by an Glue job. For example,
#'     to set `inferSchema` to true, pass the following key value pair:
#' 
#'     `--additional-plan-options-map '{"inferSchema":"true"}'`
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PythonScript = "string",
#'   ScalaCode = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_plan(
#'   Mapping = list(
#'     list(
#'       SourceTable = "string",
#'       SourcePath = "string",
#'       SourceType = "string",
#'       TargetTable = "string",
#'       TargetPath = "string",
#'       TargetType = "string"
#'     )
#'   ),
#'   Source = list(
#'     DatabaseName = "string",
#'     TableName = "string"
#'   ),
#'   Sinks = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string"
#'     )
#'   ),
#'   Location = list(
#'     Jdbc = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     S3 = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDB = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   Language = "PYTHON"|"SCALA",
#'   AdditionalPlanOptionsMap = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_plan
#'
#' @aliases glue_get_plan
glue_get_plan <- function(Mapping, Source, Sinks = NULL, Location = NULL, Language = NULL, AdditionalPlanOptionsMap = NULL) {
  op <- new_operation(
    name = "GetPlan",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_plan_input(Mapping = Mapping, Source = Source, Sinks = Sinks, Location = Location, Language = Language, AdditionalPlanOptionsMap = AdditionalPlanOptionsMap)
  output <- .glue$get_plan_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_plan <- glue_get_plan

#' Describes the specified registry in detail
#'
#' @description
#' Describes the specified registry in detail.
#'
#' @usage
#' glue_get_registry(RegistryId)
#'
#' @param RegistryId &#91;required&#93; This is a wrapper structure that may contain the registry name and
#' Amazon Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryName = "string",
#'   RegistryArn = "string",
#'   Description = "string",
#'   Status = "AVAILABLE"|"DELETING",
#'   CreatedTime = "string",
#'   UpdatedTime = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_registry(
#'   RegistryId = list(
#'     RegistryName = "string",
#'     RegistryArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_registry
#'
#' @aliases glue_get_registry
glue_get_registry <- function(RegistryId) {
  op <- new_operation(
    name = "GetRegistry",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_registry_input(RegistryId = RegistryId)
  output <- .glue$get_registry_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_registry <- glue_get_registry

#' Retrieves the resource policies set on individual resources by Resource
#' Access Manager during cross-account permission grants
#'
#' @description
#' Retrieves the resource policies set on individual resources by Resource
#' Access Manager during cross-account permission grants. Also retrieves
#' the Data Catalog resource policy.
#' 
#' If you enabled metadata encryption in Data Catalog settings, and you do
#' not have permission on the KMS key, the operation can't return the Data
#' Catalog resource policy.
#'
#' @usage
#' glue_get_resource_policies(NextToken, MaxResults)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GetResourcePoliciesResponseList = list(
#'     list(
#'       PolicyInJson = "string",
#'       PolicyHash = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_resource_policies(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_resource_policies
#'
#' @aliases glue_get_resource_policies
glue_get_resource_policies <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetResourcePolicies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "GetResourcePoliciesResponseList"),
    stream_api = FALSE
  )
  input <- .glue$get_resource_policies_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_resource_policies_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_resource_policies <- glue_get_resource_policies

#' Retrieves a specified resource policy
#'
#' @description
#' Retrieves a specified resource policy.
#'
#' @usage
#' glue_get_resource_policy(ResourceArn)
#'
#' @param ResourceArn The ARN of the Glue resource for which to retrieve the resource policy.
#' If not supplied, the Data Catalog resource policy is returned. Use
#' [`get_resource_policies`][glue_get_resource_policies] to view all
#' existing resource policies. For more information see [Specifying Glue
#' Resource
#' ARNs](https://docs.aws.amazon.com/glue/latest/dg/glue-specifying-resource-arns.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PolicyInJson = "string",
#'   PolicyHash = "string",
#'   CreateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   UpdateTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_resource_policy(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_resource_policy
#'
#' @aliases glue_get_resource_policy
glue_get_resource_policy <- function(ResourceArn = NULL) {
  op <- new_operation(
    name = "GetResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_resource_policy_input(ResourceArn = ResourceArn)
  output <- .glue$get_resource_policy_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_resource_policy <- glue_get_resource_policy

#' Describes the specified schema in detail
#'
#' @description
#' Describes the specified schema in detail.
#'
#' @usage
#' glue_get_schema(SchemaId)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     Either `SchemaArn` or `SchemaName` and `RegistryName` has to be
#'     provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. Either `SchemaArn` or
#'     `SchemaName` and `RegistryName` has to be provided.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryName = "string",
#'   RegistryArn = "string",
#'   SchemaName = "string",
#'   SchemaArn = "string",
#'   Description = "string",
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   Compatibility = "NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL",
#'   SchemaCheckpoint = 123,
#'   LatestSchemaVersion = 123,
#'   NextSchemaVersion = 123,
#'   SchemaStatus = "AVAILABLE"|"PENDING"|"DELETING",
#'   CreatedTime = "string",
#'   UpdatedTime = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_schema(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_schema
#'
#' @aliases glue_get_schema
glue_get_schema <- function(SchemaId) {
  op <- new_operation(
    name = "GetSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_schema_input(SchemaId = SchemaId)
  output <- .glue$get_schema_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_schema <- glue_get_schema

#' Retrieves a schema by the SchemaDefinition
#'
#' @description
#' Retrieves a schema by the `SchemaDefinition`. The schema definition is
#' sent to the Schema Registry, canonicalized, and hashed. If the hash is
#' matched within the scope of the `SchemaName` or ARN (or the default
#' registry, if none is supplied), that schema’s metadata is returned.
#' Otherwise, a 404 or NotFound error is returned. Schema versions in
#' `Deleted` statuses will not be included in the results.
#'
#' @usage
#' glue_get_schema_by_definition(SchemaId, SchemaDefinition)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     One of `SchemaArn` or `SchemaName` has to be provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. One of `SchemaArn` or
#'     `SchemaName` has to be provided.
#' @param SchemaDefinition &#91;required&#93; The definition of the schema for which schema details are required.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaVersionId = "string",
#'   SchemaArn = "string",
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   Status = "AVAILABLE"|"PENDING"|"FAILURE"|"DELETING",
#'   CreatedTime = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_schema_by_definition(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaDefinition = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_schema_by_definition
#'
#' @aliases glue_get_schema_by_definition
glue_get_schema_by_definition <- function(SchemaId, SchemaDefinition) {
  op <- new_operation(
    name = "GetSchemaByDefinition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_schema_by_definition_input(SchemaId = SchemaId, SchemaDefinition = SchemaDefinition)
  output <- .glue$get_schema_by_definition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_schema_by_definition <- glue_get_schema_by_definition

#' Get the specified schema by its unique ID assigned when a version of the
#' schema is created or registered
#'
#' @description
#' Get the specified schema by its unique ID assigned when a version of the
#' schema is created or registered. Schema versions in Deleted status will
#' not be included in the results.
#'
#' @usage
#' glue_get_schema_version(SchemaId, SchemaVersionId, SchemaVersionNumber)
#'
#' @param SchemaId This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     Either `SchemaArn` or `SchemaName` and `RegistryName` has to be
#'     provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. Either `SchemaArn` or
#'     `SchemaName` and `RegistryName` has to be provided.
#' @param SchemaVersionId The `SchemaVersionId` of the schema version. This field is required for
#' fetching by schema ID. Either this or the `SchemaId` wrapper has to be
#' provided.
#' @param SchemaVersionNumber The version number of the schema.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaVersionId = "string",
#'   SchemaDefinition = "string",
#'   DataFormat = "AVRO"|"JSON"|"PROTOBUF",
#'   SchemaArn = "string",
#'   VersionNumber = 123,
#'   Status = "AVAILABLE"|"PENDING"|"FAILURE"|"DELETING",
#'   CreatedTime = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_schema_version(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaVersionId = "string",
#'   SchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_schema_version
#'
#' @aliases glue_get_schema_version
glue_get_schema_version <- function(SchemaId = NULL, SchemaVersionId = NULL, SchemaVersionNumber = NULL) {
  op <- new_operation(
    name = "GetSchemaVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_schema_version_input(SchemaId = SchemaId, SchemaVersionId = SchemaVersionId, SchemaVersionNumber = SchemaVersionNumber)
  output <- .glue$get_schema_version_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_schema_version <- glue_get_schema_version

#' Fetches the schema version difference in the specified difference type
#' between two stored schema versions in the Schema Registry
#'
#' @description
#' Fetches the schema version difference in the specified difference type
#' between two stored schema versions in the Schema Registry.
#' 
#' This API allows you to compare two schema versions between two schema
#' definitions under the same schema.
#'
#' @usage
#' glue_get_schema_versions_diff(SchemaId, FirstSchemaVersionNumber,
#'   SecondSchemaVersionNumber, SchemaDiffType)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     One of `SchemaArn` or `SchemaName` has to be provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. One of `SchemaArn` or
#'     `SchemaName` has to be provided.
#' @param FirstSchemaVersionNumber &#91;required&#93; The first of the two schema versions to be compared.
#' @param SecondSchemaVersionNumber &#91;required&#93; The second of the two schema versions to be compared.
#' @param SchemaDiffType &#91;required&#93; Refers to `SYNTAX_DIFF`, which is the currently supported diff type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Diff = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_schema_versions_diff(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   FirstSchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   SecondSchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   SchemaDiffType = "SYNTAX_DIFF"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_schema_versions_diff
#'
#' @aliases glue_get_schema_versions_diff
glue_get_schema_versions_diff <- function(SchemaId, FirstSchemaVersionNumber, SecondSchemaVersionNumber, SchemaDiffType) {
  op <- new_operation(
    name = "GetSchemaVersionsDiff",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_schema_versions_diff_input(SchemaId = SchemaId, FirstSchemaVersionNumber = FirstSchemaVersionNumber, SecondSchemaVersionNumber = SecondSchemaVersionNumber, SchemaDiffType = SchemaDiffType)
  output <- .glue$get_schema_versions_diff_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_schema_versions_diff <- glue_get_schema_versions_diff

#' Retrieves a specified security configuration
#'
#' @description
#' Retrieves a specified security configuration.
#'
#' @usage
#' glue_get_security_configuration(Name)
#'
#' @param Name &#91;required&#93; The name of the security configuration to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SecurityConfiguration = list(
#'     Name = "string",
#'     CreatedTimeStamp = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EncryptionConfiguration = list(
#'       S3Encryption = list(
#'         list(
#'           S3EncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-S3",
#'           KmsKeyArn = "string"
#'         )
#'       ),
#'       CloudWatchEncryption = list(
#'         CloudWatchEncryptionMode = "DISABLED"|"SSE-KMS",
#'         KmsKeyArn = "string"
#'       ),
#'       JobBookmarksEncryption = list(
#'         JobBookmarksEncryptionMode = "DISABLED"|"CSE-KMS",
#'         KmsKeyArn = "string"
#'       ),
#'       DataQualityEncryption = list(
#'         DataQualityEncryptionMode = "DISABLED"|"SSE-KMS",
#'         KmsKeyArn = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_security_configuration(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_security_configuration
#'
#' @aliases glue_get_security_configuration
glue_get_security_configuration <- function(Name) {
  op <- new_operation(
    name = "GetSecurityConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_security_configuration_input(Name = Name)
  output <- .glue$get_security_configuration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_security_configuration <- glue_get_security_configuration

#' Retrieves a list of all security configurations
#'
#' @description
#' Retrieves a list of all security configurations.
#'
#' @usage
#' glue_get_security_configurations(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SecurityConfigurations = list(
#'     list(
#'       Name = "string",
#'       CreatedTimeStamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EncryptionConfiguration = list(
#'         S3Encryption = list(
#'           list(
#'             S3EncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-S3",
#'             KmsKeyArn = "string"
#'           )
#'         ),
#'         CloudWatchEncryption = list(
#'           CloudWatchEncryptionMode = "DISABLED"|"SSE-KMS",
#'           KmsKeyArn = "string"
#'         ),
#'         JobBookmarksEncryption = list(
#'           JobBookmarksEncryptionMode = "DISABLED"|"CSE-KMS",
#'           KmsKeyArn = "string"
#'         ),
#'         DataQualityEncryption = list(
#'           DataQualityEncryptionMode = "DISABLED"|"SSE-KMS",
#'           KmsKeyArn = "string"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_security_configurations(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_security_configurations
#'
#' @aliases glue_get_security_configurations
glue_get_security_configurations <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "GetSecurityConfigurations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "SecurityConfigurations"),
    stream_api = FALSE
  )
  input <- .glue$get_security_configurations_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$get_security_configurations_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_security_configurations <- glue_get_security_configurations

#' Retrieves the session
#'
#' @description
#' Retrieves the session.
#'
#' @usage
#' glue_get_session(Id, RequestOrigin)
#'
#' @param Id &#91;required&#93; The ID of the session.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Session = list(
#'     Id = "string",
#'     CreatedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Status = "PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED",
#'     ErrorMessage = "string",
#'     Description = "string",
#'     Role = "string",
#'     Command = list(
#'       Name = "string",
#'       PythonVersion = "string"
#'     ),
#'     DefaultArguments = list(
#'       "string"
#'     ),
#'     Connections = list(
#'       Connections = list(
#'         "string"
#'       )
#'     ),
#'     Progress = 123.0,
#'     MaxCapacity = 123.0,
#'     SecurityConfiguration = "string",
#'     GlueVersion = "string",
#'     NumberOfWorkers = 123,
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     CompletedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExecutionTime = 123.0,
#'     DPUSeconds = 123.0,
#'     IdleTimeout = 123,
#'     ProfileName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session(
#'   Id = "string",
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_session
#'
#' @aliases glue_get_session
glue_get_session <- function(Id, RequestOrigin = NULL) {
  op <- new_operation(
    name = "GetSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_session_input(Id = Id, RequestOrigin = RequestOrigin)
  output <- .glue$get_session_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_session <- glue_get_session

#' Retrieves the statement
#'
#' @description
#' Retrieves the statement.
#'
#' @usage
#' glue_get_statement(SessionId, Id, RequestOrigin)
#'
#' @param SessionId &#91;required&#93; The Session ID of the statement.
#' @param Id &#91;required&#93; The Id of the statement.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Statement = list(
#'     Id = 123,
#'     Code = "string",
#'     State = "WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR",
#'     Output = list(
#'       Data = list(
#'         TextPlain = "string"
#'       ),
#'       ExecutionCount = 123,
#'       Status = "WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR",
#'       ErrorName = "string",
#'       ErrorValue = "string",
#'       Traceback = list(
#'         "string"
#'       )
#'     ),
#'     Progress = 123.0,
#'     StartedOn = 123,
#'     CompletedOn = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_statement(
#'   SessionId = "string",
#'   Id = 123,
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_statement
#'
#' @aliases glue_get_statement
glue_get_statement <- function(SessionId, Id, RequestOrigin = NULL) {
  op <- new_operation(
    name = "GetStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_statement_input(SessionId = SessionId, Id = Id, RequestOrigin = RequestOrigin)
  output <- .glue$get_statement_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_statement <- glue_get_statement

#' Retrieves the Table definition in a Data Catalog for a specified table
#'
#' @description
#' Retrieves the `Table` definition in a Data Catalog for a specified
#' table.
#'
#' @usage
#' glue_get_table(CatalogId, DatabaseName, Name, TransactionId,
#'   QueryAsOfTime, IncludeStatusDetails)
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides. For
#' Hive compatibility, this name is entirely lowercase.
#' @param Name &#91;required&#93; The name of the table for which to retrieve the definition. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TransactionId The transaction ID at which to read the table contents.
#' @param QueryAsOfTime The time as of when to read the table contents. If not set, the most
#' recent transaction commit time will be used. Cannot be specified along
#' with `TransactionId`.
#' @param IncludeStatusDetails Specifies whether to include status details related to a request to
#' create or update an Glue Data Catalog view.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Table = list(
#'     Name = "string",
#'     DatabaseName = "string",
#'     Description = "string",
#'     Owner = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreatedBy = "string",
#'     IsRegisteredWithLakeFormation = TRUE|FALSE,
#'     TargetTable = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Name = "string",
#'       Region = "string"
#'     ),
#'     CatalogId = "string",
#'     VersionId = "string",
#'     FederatedTable = list(
#'       Identifier = "string",
#'       DatabaseIdentifier = "string",
#'       ConnectionName = "string"
#'     ),
#'     ViewDefinition = list(
#'       IsProtected = TRUE|FALSE,
#'       Definer = "string",
#'       SubObjects = list(
#'         "string"
#'       ),
#'       Representations = list(
#'         list(
#'           Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'           DialectVersion = "string",
#'           ViewOriginalText = "string",
#'           ViewExpandedText = "string",
#'           ValidationConnection = "string",
#'           IsStale = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     IsMultiDialectView = TRUE|FALSE,
#'     Status = list(
#'       RequestedBy = "string",
#'       UpdatedBy = "string",
#'       RequestTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Action = "UPDATE"|"CREATE",
#'       State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       ),
#'       Details = list(
#'         RequestedChange = list(),
#'         ViewValidations = list(
#'           list(
#'             Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'             DialectVersion = "string",
#'             ViewValidationText = "string",
#'             UpdateTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'             Error = list(
#'               ErrorCode = "string",
#'               ErrorMessage = "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Name = "string",
#'   TransactionId = "string",
#'   QueryAsOfTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   IncludeStatusDetails = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_table
#'
#' @aliases glue_get_table
glue_get_table <- function(CatalogId = NULL, DatabaseName, Name, TransactionId = NULL, QueryAsOfTime = NULL, IncludeStatusDetails = NULL) {
  op <- new_operation(
    name = "GetTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, Name = Name, TransactionId = TransactionId, QueryAsOfTime = QueryAsOfTime, IncludeStatusDetails = IncludeStatusDetails)
  output <- .glue$get_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_table <- glue_get_table

#' Returns the configuration of all optimizers associated with a specified
#' table
#'
#' @description
#' Returns the configuration of all optimizers associated with a specified
#' table.
#'
#' @usage
#' glue_get_table_optimizer(CatalogId, DatabaseName, TableName, Type)
#'
#' @param CatalogId &#91;required&#93; The Catalog ID of the table.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param Type &#91;required&#93; The type of table optimizer.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   TableOptimizer = list(
#'     type = "compaction"|"retention"|"orphan_file_deletion",
#'     configuration = list(
#'       roleArn = "string",
#'       enabled = TRUE|FALSE,
#'       vpcConfiguration = list(
#'         glueConnectionName = "string"
#'       ),
#'       retentionConfiguration = list(
#'         icebergConfiguration = list(
#'           snapshotRetentionPeriodInDays = 123,
#'           numberOfSnapshotsToRetain = 123,
#'           cleanExpiredFiles = TRUE|FALSE
#'         )
#'       ),
#'       orphanFileDeletionConfiguration = list(
#'         icebergConfiguration = list(
#'           orphanFileRetentionPeriodInDays = 123,
#'           location = "string"
#'         )
#'       )
#'     ),
#'     lastRun = list(
#'       eventType = "starting"|"completed"|"failed"|"in_progress",
#'       startTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       metrics = list(
#'         NumberOfBytesCompacted = "string",
#'         NumberOfFilesCompacted = "string",
#'         NumberOfDpus = "string",
#'         JobDurationInHour = "string"
#'       ),
#'       error = "string",
#'       compactionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfBytesCompacted = 123,
#'           NumberOfFilesCompacted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       ),
#'       retentionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfDataFilesDeleted = 123,
#'           NumberOfManifestFilesDeleted = 123,
#'           NumberOfManifestListsDeleted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       ),
#'       orphanFileDeletionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfOrphanFilesDeleted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_table_optimizer(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Type = "compaction"|"retention"|"orphan_file_deletion"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_table_optimizer
#'
#' @aliases glue_get_table_optimizer
glue_get_table_optimizer <- function(CatalogId, DatabaseName, TableName, Type) {
  op <- new_operation(
    name = "GetTableOptimizer",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_table_optimizer_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Type = Type)
  output <- .glue$get_table_optimizer_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_table_optimizer <- glue_get_table_optimizer

#' Retrieves a specified version of a table
#'
#' @description
#' Retrieves a specified version of a table.
#'
#' @usage
#' glue_get_table_version(CatalogId, DatabaseName, TableName, VersionId)
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely
#' lowercase.
#' @param VersionId The ID value of the table version to be retrieved. A `VersionID` is a
#' string representation of an integer. Each version is incremented by 1.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableVersion = list(
#'     Table = list(
#'       Name = "string",
#'       DatabaseName = "string",
#'       Description = "string",
#'       Owner = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Retention = 123,
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       PartitionKeys = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ViewOriginalText = "string",
#'       ViewExpandedText = "string",
#'       TableType = "string",
#'       Parameters = list(
#'         "string"
#'       ),
#'       CreatedBy = "string",
#'       IsRegisteredWithLakeFormation = TRUE|FALSE,
#'       TargetTable = list(
#'         CatalogId = "string",
#'         DatabaseName = "string",
#'         Name = "string",
#'         Region = "string"
#'       ),
#'       CatalogId = "string",
#'       VersionId = "string",
#'       FederatedTable = list(
#'         Identifier = "string",
#'         DatabaseIdentifier = "string",
#'         ConnectionName = "string"
#'       ),
#'       ViewDefinition = list(
#'         IsProtected = TRUE|FALSE,
#'         Definer = "string",
#'         SubObjects = list(
#'           "string"
#'         ),
#'         Representations = list(
#'           list(
#'             Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'             DialectVersion = "string",
#'             ViewOriginalText = "string",
#'             ViewExpandedText = "string",
#'             ValidationConnection = "string",
#'             IsStale = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       IsMultiDialectView = TRUE|FALSE,
#'       Status = list(
#'         RequestedBy = "string",
#'         UpdatedBy = "string",
#'         RequestTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         UpdateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Action = "UPDATE"|"CREATE",
#'         State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'         Error = list(
#'           ErrorCode = "string",
#'           ErrorMessage = "string"
#'         ),
#'         Details = list(
#'           RequestedChange = list(),
#'           ViewValidations = list(
#'             list(
#'               Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'               DialectVersion = "string",
#'               ViewValidationText = "string",
#'               UpdateTime = as.POSIXct(
#'                 "2015-01-01"
#'               ),
#'               State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'               Error = list(
#'                 ErrorCode = "string",
#'                 ErrorMessage = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     VersionId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_table_version
#'
#' @aliases glue_get_table_version
glue_get_table_version <- function(CatalogId = NULL, DatabaseName, TableName, VersionId = NULL) {
  op <- new_operation(
    name = "GetTableVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_table_version_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, VersionId = VersionId)
  output <- .glue$get_table_version_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_table_version <- glue_get_table_version

#' Retrieves a list of strings that identify available versions of a
#' specified table
#'
#' @description
#' Retrieves a list of strings that identify available versions of a
#' specified table.
#'
#' @usage
#' glue_get_table_versions(CatalogId, DatabaseName, TableName, NextToken,
#'   MaxResults)
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely
#' lowercase.
#' @param NextToken A continuation token, if this is not the first call.
#' @param MaxResults The maximum number of table versions to return in one response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableVersions = list(
#'     list(
#'       Table = list(
#'         Name = "string",
#'         DatabaseName = "string",
#'         Description = "string",
#'         Owner = "string",
#'         CreateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         UpdateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastAccessTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastAnalyzedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Retention = 123,
#'         StorageDescriptor = list(
#'           Columns = list(
#'             list(
#'               Name = "string",
#'               Type = "string",
#'               Comment = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           Location = "string",
#'           AdditionalLocations = list(
#'             "string"
#'           ),
#'           InputFormat = "string",
#'           OutputFormat = "string",
#'           Compressed = TRUE|FALSE,
#'           NumberOfBuckets = 123,
#'           SerdeInfo = list(
#'             Name = "string",
#'             SerializationLibrary = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           ),
#'           BucketColumns = list(
#'             "string"
#'           ),
#'           SortColumns = list(
#'             list(
#'               Column = "string",
#'               SortOrder = 123
#'             )
#'           ),
#'           Parameters = list(
#'             "string"
#'           ),
#'           SkewedInfo = list(
#'             SkewedColumnNames = list(
#'               "string"
#'             ),
#'             SkewedColumnValues = list(
#'               "string"
#'             ),
#'             SkewedColumnValueLocationMaps = list(
#'               "string"
#'             )
#'           ),
#'           StoredAsSubDirectories = TRUE|FALSE,
#'           SchemaReference = list(
#'             SchemaId = list(
#'               SchemaArn = "string",
#'               SchemaName = "string",
#'               RegistryName = "string"
#'             ),
#'             SchemaVersionId = "string",
#'             SchemaVersionNumber = 123
#'           )
#'         ),
#'         PartitionKeys = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         ViewOriginalText = "string",
#'         ViewExpandedText = "string",
#'         TableType = "string",
#'         Parameters = list(
#'           "string"
#'         ),
#'         CreatedBy = "string",
#'         IsRegisteredWithLakeFormation = TRUE|FALSE,
#'         TargetTable = list(
#'           CatalogId = "string",
#'           DatabaseName = "string",
#'           Name = "string",
#'           Region = "string"
#'         ),
#'         CatalogId = "string",
#'         VersionId = "string",
#'         FederatedTable = list(
#'           Identifier = "string",
#'           DatabaseIdentifier = "string",
#'           ConnectionName = "string"
#'         ),
#'         ViewDefinition = list(
#'           IsProtected = TRUE|FALSE,
#'           Definer = "string",
#'           SubObjects = list(
#'             "string"
#'           ),
#'           Representations = list(
#'             list(
#'               Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'               DialectVersion = "string",
#'               ViewOriginalText = "string",
#'               ViewExpandedText = "string",
#'               ValidationConnection = "string",
#'               IsStale = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         IsMultiDialectView = TRUE|FALSE,
#'         Status = list(
#'           RequestedBy = "string",
#'           UpdatedBy = "string",
#'           RequestTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           UpdateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           Action = "UPDATE"|"CREATE",
#'           State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'           Error = list(
#'             ErrorCode = "string",
#'             ErrorMessage = "string"
#'           ),
#'           Details = list(
#'             RequestedChange = list(),
#'             ViewValidations = list(
#'               list(
#'                 Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'                 DialectVersion = "string",
#'                 ViewValidationText = "string",
#'                 UpdateTime = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'                 Error = list(
#'                   ErrorCode = "string",
#'                   ErrorMessage = "string"
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       VersionId = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_table_versions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_table_versions
#'
#' @aliases glue_get_table_versions
glue_get_table_versions <- function(CatalogId = NULL, DatabaseName, TableName, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetTableVersions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "TableVersions", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_table_versions_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_table_versions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_table_versions <- glue_get_table_versions

#' Retrieves the definitions of some or all of the tables in a given
#' Database
#'
#' @description
#' Retrieves the definitions of some or all of the tables in a given
#' `Database`.
#'
#' @usage
#' glue_get_tables(CatalogId, DatabaseName, Expression, NextToken,
#'   MaxResults, TransactionId, QueryAsOfTime, IncludeStatusDetails,
#'   AttributesToGet)
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog whose tables to list. For Hive
#' compatibility, this name is entirely lowercase.
#' @param Expression A regular expression pattern. If present, only those tables whose names
#' match the pattern are returned.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param MaxResults The maximum number of tables to return in a single response.
#' @param TransactionId The transaction ID at which to read the table contents.
#' @param QueryAsOfTime The time as of when to read the table contents. If not set, the most
#' recent transaction commit time will be used. Cannot be specified along
#' with `TransactionId`.
#' @param IncludeStatusDetails Specifies whether to include status details related to a request to
#' create or update an Glue Data Catalog view.
#' @param AttributesToGet Specifies the table fields returned by the
#' [`get_tables`][glue_get_tables] call. This parameter doesn’t accept an
#' empty list. The request must include `NAME`.
#' 
#' The following are the valid combinations of values:
#' 
#' -   `NAME` - Names of all tables in the database.
#' 
#' -   `NAME`, `TABLE_TYPE` - Names of all tables and the table types.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableList = list(
#'     list(
#'       Name = "string",
#'       DatabaseName = "string",
#'       Description = "string",
#'       Owner = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Retention = 123,
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       PartitionKeys = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ViewOriginalText = "string",
#'       ViewExpandedText = "string",
#'       TableType = "string",
#'       Parameters = list(
#'         "string"
#'       ),
#'       CreatedBy = "string",
#'       IsRegisteredWithLakeFormation = TRUE|FALSE,
#'       TargetTable = list(
#'         CatalogId = "string",
#'         DatabaseName = "string",
#'         Name = "string",
#'         Region = "string"
#'       ),
#'       CatalogId = "string",
#'       VersionId = "string",
#'       FederatedTable = list(
#'         Identifier = "string",
#'         DatabaseIdentifier = "string",
#'         ConnectionName = "string"
#'       ),
#'       ViewDefinition = list(
#'         IsProtected = TRUE|FALSE,
#'         Definer = "string",
#'         SubObjects = list(
#'           "string"
#'         ),
#'         Representations = list(
#'           list(
#'             Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'             DialectVersion = "string",
#'             ViewOriginalText = "string",
#'             ViewExpandedText = "string",
#'             ValidationConnection = "string",
#'             IsStale = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       IsMultiDialectView = TRUE|FALSE,
#'       Status = list(
#'         RequestedBy = "string",
#'         UpdatedBy = "string",
#'         RequestTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         UpdateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Action = "UPDATE"|"CREATE",
#'         State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'         Error = list(
#'           ErrorCode = "string",
#'           ErrorMessage = "string"
#'         ),
#'         Details = list(
#'           RequestedChange = list(),
#'           ViewValidations = list(
#'             list(
#'               Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'               DialectVersion = "string",
#'               ViewValidationText = "string",
#'               UpdateTime = as.POSIXct(
#'                 "2015-01-01"
#'               ),
#'               State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'               Error = list(
#'                 ErrorCode = "string",
#'                 ErrorMessage = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_tables(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Expression = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   TransactionId = "string",
#'   QueryAsOfTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   IncludeStatusDetails = TRUE|FALSE,
#'   AttributesToGet = list(
#'     "NAME"|"TABLE_TYPE"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_tables
#'
#' @aliases glue_get_tables
glue_get_tables <- function(CatalogId = NULL, DatabaseName, Expression = NULL, NextToken = NULL, MaxResults = NULL, TransactionId = NULL, QueryAsOfTime = NULL, IncludeStatusDetails = NULL, AttributesToGet = NULL) {
  op <- new_operation(
    name = "GetTables",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "TableList", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_tables_input(CatalogId = CatalogId, DatabaseName = DatabaseName, Expression = Expression, NextToken = NextToken, MaxResults = MaxResults, TransactionId = TransactionId, QueryAsOfTime = QueryAsOfTime, IncludeStatusDetails = IncludeStatusDetails, AttributesToGet = AttributesToGet)
  output <- .glue$get_tables_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_tables <- glue_get_tables

#' Retrieves a list of tags associated with a resource
#'
#' @description
#' Retrieves a list of tags associated with a resource.
#'
#' @usage
#' glue_get_tags(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource for which to retrieve
#' tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_tags(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_tags
#'
#' @aliases glue_get_tags
glue_get_tags <- function(ResourceArn) {
  op <- new_operation(
    name = "GetTags",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_tags_input(ResourceArn = ResourceArn)
  output <- .glue$get_tags_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_tags <- glue_get_tags

#' Retrieves the definition of a trigger
#'
#' @description
#' Retrieves the definition of a trigger.
#'
#' @usage
#' glue_get_trigger(Name)
#'
#' @param Name &#91;required&#93; The name of the trigger to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Trigger = list(
#'     Name = "string",
#'     WorkflowName = "string",
#'     Id = "string",
#'     Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'     State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'     Description = "string",
#'     Schedule = "string",
#'     Actions = list(
#'       list(
#'         JobName = "string",
#'         Arguments = list(
#'           "string"
#'         ),
#'         Timeout = 123,
#'         SecurityConfiguration = "string",
#'         NotificationProperty = list(
#'           NotifyDelayAfter = 123
#'         ),
#'         CrawlerName = "string"
#'       )
#'     ),
#'     Predicate = list(
#'       Logical = "AND"|"ANY",
#'       Conditions = list(
#'         list(
#'           LogicalOperator = "EQUALS",
#'           JobName = "string",
#'           State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'           CrawlerName = "string",
#'           CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'         )
#'       )
#'     ),
#'     EventBatchingCondition = list(
#'       BatchSize = 123,
#'       BatchWindow = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_trigger
#'
#' @aliases glue_get_trigger
glue_get_trigger <- function(Name) {
  op <- new_operation(
    name = "GetTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_trigger_input(Name = Name)
  output <- .glue$get_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_trigger <- glue_get_trigger

#' Gets all the triggers associated with a job
#'
#' @description
#' Gets all the triggers associated with a job.
#'
#' @usage
#' glue_get_triggers(NextToken, DependentJobName, MaxResults)
#'
#' @param NextToken A continuation token, if this is a continuation call.
#' @param DependentJobName The name of the job to retrieve triggers for. The trigger that can start
#' this job is returned, and if there is no such trigger, all triggers are
#' returned.
#' @param MaxResults The maximum size of the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Triggers = list(
#'     list(
#'       Name = "string",
#'       WorkflowName = "string",
#'       Id = "string",
#'       Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'       State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'       Description = "string",
#'       Schedule = "string",
#'       Actions = list(
#'         list(
#'           JobName = "string",
#'           Arguments = list(
#'             "string"
#'           ),
#'           Timeout = 123,
#'           SecurityConfiguration = "string",
#'           NotificationProperty = list(
#'             NotifyDelayAfter = 123
#'           ),
#'           CrawlerName = "string"
#'         )
#'       ),
#'       Predicate = list(
#'         Logical = "AND"|"ANY",
#'         Conditions = list(
#'           list(
#'             LogicalOperator = "EQUALS",
#'             JobName = "string",
#'             State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'             CrawlerName = "string",
#'             CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'           )
#'         )
#'       ),
#'       EventBatchingCondition = list(
#'         BatchSize = 123,
#'         BatchWindow = 123
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_triggers(
#'   NextToken = "string",
#'   DependentJobName = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_triggers
#'
#' @aliases glue_get_triggers
glue_get_triggers <- function(NextToken = NULL, DependentJobName = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetTriggers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "Triggers", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_triggers_input(NextToken = NextToken, DependentJobName = DependentJobName, MaxResults = MaxResults)
  output <- .glue$get_triggers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_triggers <- glue_get_triggers

#' Retrieves partition metadata from the Data Catalog that contains
#' unfiltered metadata
#'
#' @description
#' Retrieves partition metadata from the Data Catalog that contains
#' unfiltered metadata.
#' 
#' For IAM authorization, the public IAM action associated with this API is
#' `glue:GetPartition`.
#'
#' @usage
#' glue_get_unfiltered_partition_metadata(Region, CatalogId, DatabaseName,
#'   TableName, PartitionValues, AuditContext, SupportedPermissionTypes,
#'   QuerySessionContext)
#'
#' @param Region Specified only if the base tables belong to a different Amazon Web
#' Services Region.
#' @param CatalogId &#91;required&#93; The catalog ID where the partition resides.
#' @param DatabaseName &#91;required&#93; (Required) Specifies the name of a database that contains the partition.
#' @param TableName &#91;required&#93; (Required) Specifies the name of a table that contains the partition.
#' @param PartitionValues &#91;required&#93; (Required) A list of partition key values.
#' @param AuditContext A structure containing Lake Formation audit context information.
#' @param SupportedPermissionTypes &#91;required&#93; (Required) A list of supported permission types.
#' @param QuerySessionContext A structure used as a protocol between query engines and Lake Formation
#' or Glue. Contains both a Lake Formation generated authorization
#' identifier and information from the request's authorization context.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Partition = list(
#'     Values = list(
#'       "string"
#'     ),
#'     DatabaseName = "string",
#'     TableName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CatalogId = "string"
#'   ),
#'   AuthorizedColumns = list(
#'     "string"
#'   ),
#'   IsRegisteredWithLakeFormation = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_unfiltered_partition_metadata(
#'   Region = "string",
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   ),
#'   AuditContext = list(
#'     AdditionalAuditContext = "string",
#'     RequestedColumns = list(
#'       "string"
#'     ),
#'     AllColumnsRequested = TRUE|FALSE
#'   ),
#'   SupportedPermissionTypes = list(
#'     "COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION"
#'   ),
#'   QuerySessionContext = list(
#'     QueryId = "string",
#'     QueryStartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ClusterId = "string",
#'     QueryAuthorizationId = "string",
#'     AdditionalContext = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_unfiltered_partition_metadata
#'
#' @aliases glue_get_unfiltered_partition_metadata
glue_get_unfiltered_partition_metadata <- function(Region = NULL, CatalogId, DatabaseName, TableName, PartitionValues, AuditContext = NULL, SupportedPermissionTypes, QuerySessionContext = NULL) {
  op <- new_operation(
    name = "GetUnfilteredPartitionMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_unfiltered_partition_metadata_input(Region = Region, CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues, AuditContext = AuditContext, SupportedPermissionTypes = SupportedPermissionTypes, QuerySessionContext = QuerySessionContext)
  output <- .glue$get_unfiltered_partition_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_unfiltered_partition_metadata <- glue_get_unfiltered_partition_metadata

#' Retrieves partition metadata from the Data Catalog that contains
#' unfiltered metadata
#'
#' @description
#' Retrieves partition metadata from the Data Catalog that contains
#' unfiltered metadata.
#' 
#' For IAM authorization, the public IAM action associated with this API is
#' `glue:GetPartitions`.
#'
#' @usage
#' glue_get_unfiltered_partitions_metadata(Region, CatalogId, DatabaseName,
#'   TableName, Expression, AuditContext, SupportedPermissionTypes,
#'   NextToken, Segment, MaxResults, QuerySessionContext)
#'
#' @param Region Specified only if the base tables belong to a different Amazon Web
#' Services Region.
#' @param CatalogId &#91;required&#93; The ID of the Data Catalog where the partitions in question reside. If
#' none is provided, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the table that contains the partition.
#' @param Expression An expression that filters the partitions to be returned.
#' 
#' The expression uses SQL syntax similar to the SQL `WHERE` filter clause.
#' The SQL statement parser
#' [JSQLParser](https://jsqlparser.sourceforge.net/home.php) parses the
#' expression.
#' 
#' *Operators*: The following are the operators that you can use in the
#' `Expression` API call:
#' 
#' **=**
#' 
#' Checks whether the values of the two operands are equal; if yes, then
#' the condition becomes true.
#' 
#' Example: Assume 'variable a' holds 10 and 'variable b' holds 20.
#' 
#' (a = b) is not true.
#' 
#' **\< \>**
#' 
#' Checks whether the values of two operands are equal; if the values are
#' not equal, then the condition becomes true.
#' 
#' Example: (a \< \> b) is true.
#' 
#' **\>**
#' 
#' Checks whether the value of the left operand is greater than the value
#' of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \> b) is not true.
#' 
#' **\<**
#' 
#' Checks whether the value of the left operand is less than the value of
#' the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \< b) is true.
#' 
#' **\>=**
#' 
#' Checks whether the value of the left operand is greater than or equal to
#' the value of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \>= b) is not true.
#' 
#' **\<=**
#' 
#' Checks whether the value of the left operand is less than or equal to
#' the value of the right operand; if yes, then the condition becomes true.
#' 
#' Example: (a \<= b) is true.
#' 
#' **AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL**
#' 
#' Logical operators.
#' 
#' *Supported Partition Key Types*: The following are the supported
#' partition keys.
#' 
#' -   `string`
#' 
#' -   `date`
#' 
#' -   `timestamp`
#' 
#' -   `int`
#' 
#' -   `bigint`
#' 
#' -   `long`
#' 
#' -   `tinyint`
#' 
#' -   `smallint`
#' 
#' -   `decimal`
#' 
#' If an type is encountered that is not valid, an exception is thrown.
#' @param AuditContext A structure containing Lake Formation audit context information.
#' @param SupportedPermissionTypes &#91;required&#93; A list of supported permission types.
#' @param NextToken A continuation token, if this is not the first call to retrieve these
#' partitions.
#' @param Segment The segment of the table's partitions to scan in this request.
#' @param MaxResults The maximum number of partitions to return in a single response.
#' @param QuerySessionContext A structure used as a protocol between query engines and Lake Formation
#' or Glue. Contains both a Lake Formation generated authorization
#' identifier and information from the request's authorization context.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UnfilteredPartitions = list(
#'     list(
#'       Partition = list(
#'         Values = list(
#'           "string"
#'         ),
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastAccessTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         StorageDescriptor = list(
#'           Columns = list(
#'             list(
#'               Name = "string",
#'               Type = "string",
#'               Comment = "string",
#'               Parameters = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           Location = "string",
#'           AdditionalLocations = list(
#'             "string"
#'           ),
#'           InputFormat = "string",
#'           OutputFormat = "string",
#'           Compressed = TRUE|FALSE,
#'           NumberOfBuckets = 123,
#'           SerdeInfo = list(
#'             Name = "string",
#'             SerializationLibrary = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           ),
#'           BucketColumns = list(
#'             "string"
#'           ),
#'           SortColumns = list(
#'             list(
#'               Column = "string",
#'               SortOrder = 123
#'             )
#'           ),
#'           Parameters = list(
#'             "string"
#'           ),
#'           SkewedInfo = list(
#'             SkewedColumnNames = list(
#'               "string"
#'             ),
#'             SkewedColumnValues = list(
#'               "string"
#'             ),
#'             SkewedColumnValueLocationMaps = list(
#'               "string"
#'             )
#'           ),
#'           StoredAsSubDirectories = TRUE|FALSE,
#'           SchemaReference = list(
#'             SchemaId = list(
#'               SchemaArn = "string",
#'               SchemaName = "string",
#'               RegistryName = "string"
#'             ),
#'             SchemaVersionId = "string",
#'             SchemaVersionNumber = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         LastAnalyzedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         CatalogId = "string"
#'       ),
#'       AuthorizedColumns = list(
#'         "string"
#'       ),
#'       IsRegisteredWithLakeFormation = TRUE|FALSE
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_unfiltered_partitions_metadata(
#'   Region = "string",
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Expression = "string",
#'   AuditContext = list(
#'     AdditionalAuditContext = "string",
#'     RequestedColumns = list(
#'       "string"
#'     ),
#'     AllColumnsRequested = TRUE|FALSE
#'   ),
#'   SupportedPermissionTypes = list(
#'     "COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION"
#'   ),
#'   NextToken = "string",
#'   Segment = list(
#'     SegmentNumber = 123,
#'     TotalSegments = 123
#'   ),
#'   MaxResults = 123,
#'   QuerySessionContext = list(
#'     QueryId = "string",
#'     QueryStartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ClusterId = "string",
#'     QueryAuthorizationId = "string",
#'     AdditionalContext = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_unfiltered_partitions_metadata
#'
#' @aliases glue_get_unfiltered_partitions_metadata
glue_get_unfiltered_partitions_metadata <- function(Region = NULL, CatalogId, DatabaseName, TableName, Expression = NULL, AuditContext = NULL, SupportedPermissionTypes, NextToken = NULL, Segment = NULL, MaxResults = NULL, QuerySessionContext = NULL) {
  op <- new_operation(
    name = "GetUnfilteredPartitionsMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$get_unfiltered_partitions_metadata_input(Region = Region, CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Expression = Expression, AuditContext = AuditContext, SupportedPermissionTypes = SupportedPermissionTypes, NextToken = NextToken, Segment = Segment, MaxResults = MaxResults, QuerySessionContext = QuerySessionContext)
  output <- .glue$get_unfiltered_partitions_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_unfiltered_partitions_metadata <- glue_get_unfiltered_partitions_metadata

#' Allows a third-party analytical engine to retrieve unfiltered table
#' metadata from the Data Catalog
#'
#' @description
#' Allows a third-party analytical engine to retrieve unfiltered table
#' metadata from the Data Catalog.
#' 
#' For IAM authorization, the public IAM action associated with this API is
#' `glue:GetTable`.
#'
#' @usage
#' glue_get_unfiltered_table_metadata(Region, CatalogId, DatabaseName,
#'   Name, AuditContext, SupportedPermissionTypes, ParentResourceArn,
#'   RootResourceArn, SupportedDialect, Permissions, QuerySessionContext)
#'
#' @param Region Specified only if the base tables belong to a different Amazon Web
#' Services Region.
#' @param CatalogId &#91;required&#93; The catalog ID where the table resides.
#' @param DatabaseName &#91;required&#93; (Required) Specifies the name of a database that contains the table.
#' @param Name &#91;required&#93; (Required) Specifies the name of a table for which you are requesting
#' metadata.
#' @param AuditContext A structure containing Lake Formation audit context information.
#' @param SupportedPermissionTypes &#91;required&#93; Indicates the level of filtering a third-party analytical engine is
#' capable of enforcing when calling the
#' [`get_unfiltered_table_metadata`][glue_get_unfiltered_table_metadata]
#' API operation. Accepted values are:
#' 
#' -   `COLUMN_PERMISSION` - Column permissions ensure that users can
#'     access only specific columns in the table. If there are particular
#'     columns contain sensitive data, data lake administrators can define
#'     column filters that exclude access to specific columns.
#' 
#' -   `CELL_FILTER_PERMISSION` - Cell-level filtering combines column
#'     filtering (include or exclude columns) and row filter expressions to
#'     restrict access to individual elements in the table.
#' 
#' -   `NESTED_PERMISSION` - Nested permissions combines cell-level
#'     filtering and nested column filtering to restrict access to columns
#'     and/or nested columns in specific rows based on row filter
#'     expressions.
#' 
#' -   `NESTED_CELL_PERMISSION` - Nested cell permissions combines nested
#'     permission with nested cell-level filtering. This allows different
#'     subsets of nested columns to be restricted based on an array of row
#'     filter expressions.
#' 
#' Note: Each of these permission types follows a hierarchical order where
#' each subsequent permission type includes all permission of the previous
#' type.
#' 
#' Important: If you provide a supported permission type that doesn't match
#' the user's level of permissions on the table, then Lake Formation raises
#' an exception. For example, if the third-party engine calling the
#' [`get_unfiltered_table_metadata`][glue_get_unfiltered_table_metadata]
#' operation can enforce only column-level filtering, and the user has
#' nested cell filtering applied on the table, Lake Formation throws an
#' exception, and will not return unfiltered table metadata and data access
#' credentials.
#' @param ParentResourceArn The resource ARN of the view.
#' @param RootResourceArn The resource ARN of the root view in a chain of nested views.
#' @param SupportedDialect A structure specifying the dialect and dialect version used by the query
#' engine.
#' @param Permissions The Lake Formation data permissions of the caller on the table. Used to
#' authorize the call when no view context is found.
#' @param QuerySessionContext A structure used as a protocol between query engines and Lake Formation
#' or Glue. Contains both a Lake Formation generated authorization
#' identifier and information from the request's authorization context.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Table = list(
#'     Name = "string",
#'     DatabaseName = "string",
#'     Description = "string",
#'     Owner = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreatedBy = "string",
#'     IsRegisteredWithLakeFormation = TRUE|FALSE,
#'     TargetTable = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Name = "string",
#'       Region = "string"
#'     ),
#'     CatalogId = "string",
#'     VersionId = "string",
#'     FederatedTable = list(
#'       Identifier = "string",
#'       DatabaseIdentifier = "string",
#'       ConnectionName = "string"
#'     ),
#'     ViewDefinition = list(
#'       IsProtected = TRUE|FALSE,
#'       Definer = "string",
#'       SubObjects = list(
#'         "string"
#'       ),
#'       Representations = list(
#'         list(
#'           Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'           DialectVersion = "string",
#'           ViewOriginalText = "string",
#'           ViewExpandedText = "string",
#'           ValidationConnection = "string",
#'           IsStale = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     IsMultiDialectView = TRUE|FALSE,
#'     Status = list(
#'       RequestedBy = "string",
#'       UpdatedBy = "string",
#'       RequestTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Action = "UPDATE"|"CREATE",
#'       State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       ),
#'       Details = list(
#'         RequestedChange = list(),
#'         ViewValidations = list(
#'           list(
#'             Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'             DialectVersion = "string",
#'             ViewValidationText = "string",
#'             UpdateTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'             Error = list(
#'               ErrorCode = "string",
#'               ErrorMessage = "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   AuthorizedColumns = list(
#'     "string"
#'   ),
#'   IsRegisteredWithLakeFormation = TRUE|FALSE,
#'   CellFilters = list(
#'     list(
#'       ColumnName = "string",
#'       RowFilterExpression = "string"
#'     )
#'   ),
#'   QueryAuthorizationId = "string",
#'   IsMultiDialectView = TRUE|FALSE,
#'   ResourceArn = "string",
#'   IsProtected = TRUE|FALSE,
#'   Permissions = list(
#'     "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'   ),
#'   RowFilter = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_unfiltered_table_metadata(
#'   Region = "string",
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Name = "string",
#'   AuditContext = list(
#'     AdditionalAuditContext = "string",
#'     RequestedColumns = list(
#'       "string"
#'     ),
#'     AllColumnsRequested = TRUE|FALSE
#'   ),
#'   SupportedPermissionTypes = list(
#'     "COLUMN_PERMISSION"|"CELL_FILTER_PERMISSION"|"NESTED_PERMISSION"|"NESTED_CELL_PERMISSION"
#'   ),
#'   ParentResourceArn = "string",
#'   RootResourceArn = "string",
#'   SupportedDialect = list(
#'     Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'     DialectVersion = "string"
#'   ),
#'   Permissions = list(
#'     "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'   ),
#'   QuerySessionContext = list(
#'     QueryId = "string",
#'     QueryStartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ClusterId = "string",
#'     QueryAuthorizationId = "string",
#'     AdditionalContext = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_unfiltered_table_metadata
#'
#' @aliases glue_get_unfiltered_table_metadata
glue_get_unfiltered_table_metadata <- function(Region = NULL, CatalogId, DatabaseName, Name, AuditContext = NULL, SupportedPermissionTypes, ParentResourceArn = NULL, RootResourceArn = NULL, SupportedDialect = NULL, Permissions = NULL, QuerySessionContext = NULL) {
  op <- new_operation(
    name = "GetUnfilteredTableMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_unfiltered_table_metadata_input(Region = Region, CatalogId = CatalogId, DatabaseName = DatabaseName, Name = Name, AuditContext = AuditContext, SupportedPermissionTypes = SupportedPermissionTypes, ParentResourceArn = ParentResourceArn, RootResourceArn = RootResourceArn, SupportedDialect = SupportedDialect, Permissions = Permissions, QuerySessionContext = QuerySessionContext)
  output <- .glue$get_unfiltered_table_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_unfiltered_table_metadata <- glue_get_unfiltered_table_metadata

#' Retrieves information about the specified Glue usage profile
#'
#' @description
#' Retrieves information about the specified Glue usage profile.
#'
#' @usage
#' glue_get_usage_profile(Name)
#'
#' @param Name &#91;required&#93; The name of the usage profile to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Description = "string",
#'   Configuration = list(
#'     SessionConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     ),
#'     JobConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     )
#'   ),
#'   CreatedOn = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastModifiedOn = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_usage_profile(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_usage_profile
#'
#' @aliases glue_get_usage_profile
glue_get_usage_profile <- function(Name) {
  op <- new_operation(
    name = "GetUsageProfile",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_usage_profile_input(Name = Name)
  output <- .glue$get_usage_profile_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_usage_profile <- glue_get_usage_profile

#' Retrieves a specified function definition from the Data Catalog
#'
#' @description
#' Retrieves a specified function definition from the Data Catalog.
#'
#' @usage
#' glue_get_user_defined_function(CatalogId, DatabaseName, FunctionName)
#'
#' @param CatalogId The ID of the Data Catalog where the function to be retrieved is
#' located. If none is provided, the Amazon Web Services account ID is used
#' by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function is located.
#' @param FunctionName &#91;required&#93; The name of the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UserDefinedFunction = list(
#'     FunctionName = "string",
#'     DatabaseName = "string",
#'     ClassName = "string",
#'     OwnerName = "string",
#'     OwnerType = "USER"|"ROLE"|"GROUP",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ResourceUris = list(
#'       list(
#'         ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'         Uri = "string"
#'       )
#'     ),
#'     CatalogId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_user_defined_function
#'
#' @aliases glue_get_user_defined_function
glue_get_user_defined_function <- function(CatalogId = NULL, DatabaseName, FunctionName) {
  op <- new_operation(
    name = "GetUserDefinedFunction",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_user_defined_function_input(CatalogId = CatalogId, DatabaseName = DatabaseName, FunctionName = FunctionName)
  output <- .glue$get_user_defined_function_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_user_defined_function <- glue_get_user_defined_function

#' Retrieves multiple function definitions from the Data Catalog
#'
#' @description
#' Retrieves multiple function definitions from the Data Catalog.
#'
#' @usage
#' glue_get_user_defined_functions(CatalogId, DatabaseName, Pattern,
#'   NextToken, MaxResults)
#'
#' @param CatalogId The ID of the Data Catalog where the functions to be retrieved are
#' located. If none is provided, the Amazon Web Services account ID is used
#' by default.
#' @param DatabaseName The name of the catalog database where the functions are located. If
#' none is provided, functions from all the databases across the catalog
#' will be returned.
#' @param Pattern &#91;required&#93; An optional function-name pattern string that filters the function
#' definitions returned.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of functions to return in one response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UserDefinedFunctions = list(
#'     list(
#'       FunctionName = "string",
#'       DatabaseName = "string",
#'       ClassName = "string",
#'       OwnerName = "string",
#'       OwnerType = "USER"|"ROLE"|"GROUP",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ResourceUris = list(
#'         list(
#'           ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'           Uri = "string"
#'         )
#'       ),
#'       CatalogId = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_user_defined_functions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Pattern = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_user_defined_functions
#'
#' @aliases glue_get_user_defined_functions
glue_get_user_defined_functions <- function(CatalogId = NULL, DatabaseName = NULL, Pattern, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetUserDefinedFunctions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(result_key = "UserDefinedFunctions", output_token = "NextToken", input_token = "NextToken", limit_key = "MaxResults"),
    stream_api = FALSE
  )
  input <- .glue$get_user_defined_functions_input(CatalogId = CatalogId, DatabaseName = DatabaseName, Pattern = Pattern, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_user_defined_functions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_user_defined_functions <- glue_get_user_defined_functions

#' Retrieves resource metadata for a workflow
#'
#' @description
#' Retrieves resource metadata for a workflow.
#'
#' @usage
#' glue_get_workflow(Name, IncludeGraph)
#'
#' @param Name &#91;required&#93; The name of the workflow to retrieve.
#' @param IncludeGraph Specifies whether to include a graph when returning the workflow
#' resource metadata.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Workflow = list(
#'     Name = "string",
#'     Description = "string",
#'     DefaultRunProperties = list(
#'       "string"
#'     ),
#'     CreatedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastRun = list(
#'       Name = "string",
#'       WorkflowRunId = "string",
#'       PreviousRunId = "string",
#'       WorkflowRunProperties = list(
#'         "string"
#'       ),
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Status = "RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR",
#'       ErrorMessage = "string",
#'       Statistics = list(
#'         TotalActions = 123,
#'         TimeoutActions = 123,
#'         FailedActions = 123,
#'         StoppedActions = 123,
#'         SucceededActions = 123,
#'         RunningActions = 123,
#'         ErroredActions = 123,
#'         WaitingActions = 123
#'       ),
#'       Graph = list(
#'         Nodes = list(
#'           list(
#'             Type = "CRAWLER"|"JOB"|"TRIGGER",
#'             Name = "string",
#'             UniqueId = "string",
#'             TriggerDetails = list(
#'               Trigger = list(
#'                 Name = "string",
#'                 WorkflowName = "string",
#'                 Id = "string",
#'                 Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'                 State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'                 Description = "string",
#'                 Schedule = "string",
#'                 Actions = list(
#'                   list(
#'                     JobName = "string",
#'                     Arguments = list(
#'                       "string"
#'                     ),
#'                     Timeout = 123,
#'                     SecurityConfiguration = "string",
#'                     NotificationProperty = list(
#'                       NotifyDelayAfter = 123
#'                     ),
#'                     CrawlerName = "string"
#'                   )
#'                 ),
#'                 Predicate = list(
#'                   Logical = "AND"|"ANY",
#'                   Conditions = list(
#'                     list(
#'                       LogicalOperator = "EQUALS",
#'                       JobName = "string",
#'                       State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                       CrawlerName = "string",
#'                       CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                     )
#'                   )
#'                 ),
#'                 EventBatchingCondition = list(
#'                   BatchSize = 123,
#'                   BatchWindow = 123
#'                 )
#'               )
#'             ),
#'             JobDetails = list(
#'               JobRuns = list(
#'                 list(
#'                   Id = "string",
#'                   Attempt = 123,
#'                   PreviousRunId = "string",
#'                   TriggerName = "string",
#'                   JobName = "string",
#'                   JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                   JobRunQueuingEnabled = TRUE|FALSE,
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   LastModifiedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                   Arguments = list(
#'                     "string"
#'                   ),
#'                   ErrorMessage = "string",
#'                   PredecessorRuns = list(
#'                     list(
#'                       JobName = "string",
#'                       RunId = "string"
#'                     )
#'                   ),
#'                   AllocatedCapacity = 123,
#'                   ExecutionTime = 123,
#'                   Timeout = 123,
#'                   MaxCapacity = 123.0,
#'                   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                   NumberOfWorkers = 123,
#'                   SecurityConfiguration = "string",
#'                   LogGroupName = "string",
#'                   NotificationProperty = list(
#'                     NotifyDelayAfter = 123
#'                   ),
#'                   GlueVersion = "string",
#'                   DPUSeconds = 123.0,
#'                   ExecutionClass = "FLEX"|"STANDARD",
#'                   MaintenanceWindow = "string",
#'                   ProfileName = "string",
#'                   StateDetail = "string"
#'                 )
#'               )
#'             ),
#'             CrawlerDetails = list(
#'               Crawls = list(
#'                 list(
#'                   State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   ErrorMessage = "string",
#'                   LogGroup = "string",
#'                   LogStream = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         Edges = list(
#'           list(
#'             SourceId = "string",
#'             DestinationId = "string"
#'           )
#'         )
#'       ),
#'       StartingEventBatchCondition = list(
#'         BatchSize = 123,
#'         BatchWindow = 123
#'       )
#'     ),
#'     Graph = list(
#'       Nodes = list(
#'         list(
#'           Type = "CRAWLER"|"JOB"|"TRIGGER",
#'           Name = "string",
#'           UniqueId = "string",
#'           TriggerDetails = list(
#'             Trigger = list(
#'               Name = "string",
#'               WorkflowName = "string",
#'               Id = "string",
#'               Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'               State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'               Description = "string",
#'               Schedule = "string",
#'               Actions = list(
#'                 list(
#'                   JobName = "string",
#'                   Arguments = list(
#'                     "string"
#'                   ),
#'                   Timeout = 123,
#'                   SecurityConfiguration = "string",
#'                   NotificationProperty = list(
#'                     NotifyDelayAfter = 123
#'                   ),
#'                   CrawlerName = "string"
#'                 )
#'               ),
#'               Predicate = list(
#'                 Logical = "AND"|"ANY",
#'                 Conditions = list(
#'                   list(
#'                     LogicalOperator = "EQUALS",
#'                     JobName = "string",
#'                     State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                     CrawlerName = "string",
#'                     CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                   )
#'                 )
#'               ),
#'               EventBatchingCondition = list(
#'                 BatchSize = 123,
#'                 BatchWindow = 123
#'               )
#'             )
#'           ),
#'           JobDetails = list(
#'             JobRuns = list(
#'               list(
#'                 Id = "string",
#'                 Attempt = 123,
#'                 PreviousRunId = "string",
#'                 TriggerName = "string",
#'                 JobName = "string",
#'                 JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                 JobRunQueuingEnabled = TRUE|FALSE,
#'                 StartedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 LastModifiedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 CompletedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                 Arguments = list(
#'                   "string"
#'                 ),
#'                 ErrorMessage = "string",
#'                 PredecessorRuns = list(
#'                   list(
#'                     JobName = "string",
#'                     RunId = "string"
#'                   )
#'                 ),
#'                 AllocatedCapacity = 123,
#'                 ExecutionTime = 123,
#'                 Timeout = 123,
#'                 MaxCapacity = 123.0,
#'                 WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                 NumberOfWorkers = 123,
#'                 SecurityConfiguration = "string",
#'                 LogGroupName = "string",
#'                 NotificationProperty = list(
#'                   NotifyDelayAfter = 123
#'                 ),
#'                 GlueVersion = "string",
#'                 DPUSeconds = 123.0,
#'                 ExecutionClass = "FLEX"|"STANDARD",
#'                 MaintenanceWindow = "string",
#'                 ProfileName = "string",
#'                 StateDetail = "string"
#'               )
#'             )
#'           ),
#'           CrawlerDetails = list(
#'             Crawls = list(
#'               list(
#'                 State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                 StartedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 CompletedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 ErrorMessage = "string",
#'                 LogGroup = "string",
#'                 LogStream = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Edges = list(
#'         list(
#'           SourceId = "string",
#'           DestinationId = "string"
#'         )
#'       )
#'     ),
#'     MaxConcurrentRuns = 123,
#'     BlueprintDetails = list(
#'       BlueprintName = "string",
#'       RunId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow(
#'   Name = "string",
#'   IncludeGraph = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_workflow
#'
#' @aliases glue_get_workflow
glue_get_workflow <- function(Name, IncludeGraph = NULL) {
  op <- new_operation(
    name = "GetWorkflow",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_workflow_input(Name = Name, IncludeGraph = IncludeGraph)
  output <- .glue$get_workflow_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_workflow <- glue_get_workflow

#' Retrieves the metadata for a given workflow run
#'
#' @description
#' Retrieves the metadata for a given workflow run. Job run history is
#' accessible for 90 days for your workflow and job run.
#'
#' @usage
#' glue_get_workflow_run(Name, RunId, IncludeGraph)
#'
#' @param Name &#91;required&#93; Name of the workflow being run.
#' @param RunId &#91;required&#93; The ID of the workflow run.
#' @param IncludeGraph Specifies whether to include the workflow graph in response or not.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Run = list(
#'     Name = "string",
#'     WorkflowRunId = "string",
#'     PreviousRunId = "string",
#'     WorkflowRunProperties = list(
#'       "string"
#'     ),
#'     StartedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Status = "RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR",
#'     ErrorMessage = "string",
#'     Statistics = list(
#'       TotalActions = 123,
#'       TimeoutActions = 123,
#'       FailedActions = 123,
#'       StoppedActions = 123,
#'       SucceededActions = 123,
#'       RunningActions = 123,
#'       ErroredActions = 123,
#'       WaitingActions = 123
#'     ),
#'     Graph = list(
#'       Nodes = list(
#'         list(
#'           Type = "CRAWLER"|"JOB"|"TRIGGER",
#'           Name = "string",
#'           UniqueId = "string",
#'           TriggerDetails = list(
#'             Trigger = list(
#'               Name = "string",
#'               WorkflowName = "string",
#'               Id = "string",
#'               Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'               State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'               Description = "string",
#'               Schedule = "string",
#'               Actions = list(
#'                 list(
#'                   JobName = "string",
#'                   Arguments = list(
#'                     "string"
#'                   ),
#'                   Timeout = 123,
#'                   SecurityConfiguration = "string",
#'                   NotificationProperty = list(
#'                     NotifyDelayAfter = 123
#'                   ),
#'                   CrawlerName = "string"
#'                 )
#'               ),
#'               Predicate = list(
#'                 Logical = "AND"|"ANY",
#'                 Conditions = list(
#'                   list(
#'                     LogicalOperator = "EQUALS",
#'                     JobName = "string",
#'                     State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                     CrawlerName = "string",
#'                     CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                   )
#'                 )
#'               ),
#'               EventBatchingCondition = list(
#'                 BatchSize = 123,
#'                 BatchWindow = 123
#'               )
#'             )
#'           ),
#'           JobDetails = list(
#'             JobRuns = list(
#'               list(
#'                 Id = "string",
#'                 Attempt = 123,
#'                 PreviousRunId = "string",
#'                 TriggerName = "string",
#'                 JobName = "string",
#'                 JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                 JobRunQueuingEnabled = TRUE|FALSE,
#'                 StartedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 LastModifiedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 CompletedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                 Arguments = list(
#'                   "string"
#'                 ),
#'                 ErrorMessage = "string",
#'                 PredecessorRuns = list(
#'                   list(
#'                     JobName = "string",
#'                     RunId = "string"
#'                   )
#'                 ),
#'                 AllocatedCapacity = 123,
#'                 ExecutionTime = 123,
#'                 Timeout = 123,
#'                 MaxCapacity = 123.0,
#'                 WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                 NumberOfWorkers = 123,
#'                 SecurityConfiguration = "string",
#'                 LogGroupName = "string",
#'                 NotificationProperty = list(
#'                   NotifyDelayAfter = 123
#'                 ),
#'                 GlueVersion = "string",
#'                 DPUSeconds = 123.0,
#'                 ExecutionClass = "FLEX"|"STANDARD",
#'                 MaintenanceWindow = "string",
#'                 ProfileName = "string",
#'                 StateDetail = "string"
#'               )
#'             )
#'           ),
#'           CrawlerDetails = list(
#'             Crawls = list(
#'               list(
#'                 State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                 StartedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 CompletedOn = as.POSIXct(
#'                   "2015-01-01"
#'                 ),
#'                 ErrorMessage = "string",
#'                 LogGroup = "string",
#'                 LogStream = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       Edges = list(
#'         list(
#'           SourceId = "string",
#'           DestinationId = "string"
#'         )
#'       )
#'     ),
#'     StartingEventBatchCondition = list(
#'       BatchSize = 123,
#'       BatchWindow = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow_run(
#'   Name = "string",
#'   RunId = "string",
#'   IncludeGraph = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_workflow_run
#'
#' @aliases glue_get_workflow_run
glue_get_workflow_run <- function(Name, RunId, IncludeGraph = NULL) {
  op <- new_operation(
    name = "GetWorkflowRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_workflow_run_input(Name = Name, RunId = RunId, IncludeGraph = IncludeGraph)
  output <- .glue$get_workflow_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_workflow_run <- glue_get_workflow_run

#' Retrieves the workflow run properties which were set during the run
#'
#' @description
#' Retrieves the workflow run properties which were set during the run.
#'
#' @usage
#' glue_get_workflow_run_properties(Name, RunId)
#'
#' @param Name &#91;required&#93; Name of the workflow which was run.
#' @param RunId &#91;required&#93; The ID of the workflow run whose run properties should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunProperties = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow_run_properties(
#'   Name = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_workflow_run_properties
#'
#' @aliases glue_get_workflow_run_properties
glue_get_workflow_run_properties <- function(Name, RunId) {
  op <- new_operation(
    name = "GetWorkflowRunProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$get_workflow_run_properties_input(Name = Name, RunId = RunId)
  output <- .glue$get_workflow_run_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_workflow_run_properties <- glue_get_workflow_run_properties

#' Retrieves metadata for all runs of a given workflow
#'
#' @description
#' Retrieves metadata for all runs of a given workflow.
#'
#' @usage
#' glue_get_workflow_runs(Name, IncludeGraph, NextToken, MaxResults)
#'
#' @param Name &#91;required&#93; Name of the workflow whose metadata of runs should be returned.
#' @param IncludeGraph Specifies whether to include the workflow graph in response or not.
#' @param NextToken The maximum size of the response.
#' @param MaxResults The maximum number of workflow runs to be included in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Runs = list(
#'     list(
#'       Name = "string",
#'       WorkflowRunId = "string",
#'       PreviousRunId = "string",
#'       WorkflowRunProperties = list(
#'         "string"
#'       ),
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Status = "RUNNING"|"COMPLETED"|"STOPPING"|"STOPPED"|"ERROR",
#'       ErrorMessage = "string",
#'       Statistics = list(
#'         TotalActions = 123,
#'         TimeoutActions = 123,
#'         FailedActions = 123,
#'         StoppedActions = 123,
#'         SucceededActions = 123,
#'         RunningActions = 123,
#'         ErroredActions = 123,
#'         WaitingActions = 123
#'       ),
#'       Graph = list(
#'         Nodes = list(
#'           list(
#'             Type = "CRAWLER"|"JOB"|"TRIGGER",
#'             Name = "string",
#'             UniqueId = "string",
#'             TriggerDetails = list(
#'               Trigger = list(
#'                 Name = "string",
#'                 WorkflowName = "string",
#'                 Id = "string",
#'                 Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'                 State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'                 Description = "string",
#'                 Schedule = "string",
#'                 Actions = list(
#'                   list(
#'                     JobName = "string",
#'                     Arguments = list(
#'                       "string"
#'                     ),
#'                     Timeout = 123,
#'                     SecurityConfiguration = "string",
#'                     NotificationProperty = list(
#'                       NotifyDelayAfter = 123
#'                     ),
#'                     CrawlerName = "string"
#'                   )
#'                 ),
#'                 Predicate = list(
#'                   Logical = "AND"|"ANY",
#'                   Conditions = list(
#'                     list(
#'                       LogicalOperator = "EQUALS",
#'                       JobName = "string",
#'                       State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                       CrawlerName = "string",
#'                       CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'                     )
#'                   )
#'                 ),
#'                 EventBatchingCondition = list(
#'                   BatchSize = 123,
#'                   BatchWindow = 123
#'                 )
#'               )
#'             ),
#'             JobDetails = list(
#'               JobRuns = list(
#'                 list(
#'                   Id = "string",
#'                   Attempt = 123,
#'                   PreviousRunId = "string",
#'                   TriggerName = "string",
#'                   JobName = "string",
#'                   JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'                   JobRunQueuingEnabled = TRUE|FALSE,
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   LastModifiedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   JobRunState = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'                   Arguments = list(
#'                     "string"
#'                   ),
#'                   ErrorMessage = "string",
#'                   PredecessorRuns = list(
#'                     list(
#'                       JobName = "string",
#'                       RunId = "string"
#'                     )
#'                   ),
#'                   AllocatedCapacity = 123,
#'                   ExecutionTime = 123,
#'                   Timeout = 123,
#'                   MaxCapacity = 123.0,
#'                   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'                   NumberOfWorkers = 123,
#'                   SecurityConfiguration = "string",
#'                   LogGroupName = "string",
#'                   NotificationProperty = list(
#'                     NotifyDelayAfter = 123
#'                   ),
#'                   GlueVersion = "string",
#'                   DPUSeconds = 123.0,
#'                   ExecutionClass = "FLEX"|"STANDARD",
#'                   MaintenanceWindow = "string",
#'                   ProfileName = "string",
#'                   StateDetail = "string"
#'                 )
#'               )
#'             ),
#'             CrawlerDetails = list(
#'               Crawls = list(
#'                 list(
#'                   State = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR",
#'                   StartedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   CompletedOn = as.POSIXct(
#'                     "2015-01-01"
#'                   ),
#'                   ErrorMessage = "string",
#'                   LogGroup = "string",
#'                   LogStream = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         Edges = list(
#'           list(
#'             SourceId = "string",
#'             DestinationId = "string"
#'           )
#'         )
#'       ),
#'       StartingEventBatchCondition = list(
#'         BatchSize = 123,
#'         BatchWindow = 123
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_workflow_runs(
#'   Name = "string",
#'   IncludeGraph = TRUE|FALSE,
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_get_workflow_runs
#'
#' @aliases glue_get_workflow_runs
glue_get_workflow_runs <- function(Name, IncludeGraph = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetWorkflowRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Runs"),
    stream_api = FALSE
  )
  input <- .glue$get_workflow_runs_input(Name = Name, IncludeGraph = IncludeGraph, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$get_workflow_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$get_workflow_runs <- glue_get_workflow_runs

#' Imports an existing Amazon Athena Data Catalog to Glue
#'
#' @description
#' Imports an existing Amazon Athena Data Catalog to Glue.
#'
#' @usage
#' glue_import_catalog_to_glue(CatalogId)
#'
#' @param CatalogId The ID of the catalog to import. Currently, this should be the Amazon
#' Web Services account ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$import_catalog_to_glue(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_import_catalog_to_glue
#'
#' @aliases glue_import_catalog_to_glue
glue_import_catalog_to_glue <- function(CatalogId = NULL) {
  op <- new_operation(
    name = "ImportCatalogToGlue",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$import_catalog_to_glue_input(CatalogId = CatalogId)
  output <- .glue$import_catalog_to_glue_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$import_catalog_to_glue <- glue_import_catalog_to_glue

#' Lists all the blueprint names in an account
#'
#' @description
#' Lists all the blueprint names in an account.
#'
#' @usage
#' glue_list_blueprints(NextToken, MaxResults, Tags)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#' @param Tags Filters the list by an Amazon Web Services resource tag.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Blueprints = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_blueprints(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_blueprints
#'
#' @aliases glue_list_blueprints
glue_list_blueprints <- function(NextToken = NULL, MaxResults = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListBlueprints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Blueprints"),
    stream_api = FALSE
  )
  input <- .glue$list_blueprints_input(NextToken = NextToken, MaxResults = MaxResults, Tags = Tags)
  output <- .glue$list_blueprints_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_blueprints <- glue_list_blueprints

#' List all task runs for a particular account
#'
#' @description
#' List all task runs for a particular account.
#'
#' @usage
#' glue_list_column_statistics_task_runs(MaxResults, NextToken)
#'
#' @param MaxResults The maximum size of the response.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsTaskRunIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_column_statistics_task_runs(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_column_statistics_task_runs
#'
#' @aliases glue_list_column_statistics_task_runs
glue_list_column_statistics_task_runs <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListColumnStatisticsTaskRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_column_statistics_task_runs_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_column_statistics_task_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_column_statistics_task_runs <- glue_list_column_statistics_task_runs

#' The ListConnectionTypes API provides a discovery mechanism to learn
#' available connection types in Glue
#'
#' @description
#' The [`list_connection_types`][glue_list_connection_types] API provides a
#' discovery mechanism to learn available connection types in Glue. The
#' response contains a list of connection types with high-level details of
#' what is supported for each connection type. The connection types listed
#' are the set of supported options for the `ConnectionType` value in the
#' [`create_connection`][glue_create_connection] API.
#'
#' @usage
#' glue_list_connection_types(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ConnectionTypes = list(
#'     list(
#'       ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'       Description = "string",
#'       Capabilities = list(
#'         SupportedAuthenticationTypes = list(
#'           "BASIC"|"OAUTH2"|"CUSTOM"|"IAM"
#'         ),
#'         SupportedDataOperations = list(
#'           "READ"|"WRITE"
#'         ),
#'         SupportedComputeEnvironments = list(
#'           "SPARK"|"ATHENA"|"PYTHON"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_connection_types(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_connection_types
#'
#' @aliases glue_list_connection_types
glue_list_connection_types <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListConnectionTypes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "ConnectionTypes"),
    stream_api = FALSE
  )
  input <- .glue$list_connection_types_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_connection_types_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_connection_types <- glue_list_connection_types

#' Retrieves the names of all crawler resources in this Amazon Web Services
#' account, or the resources with the specified tag
#'
#' @description
#' Retrieves the names of all crawler resources in this Amazon Web Services
#' account, or the resources with the specified tag. This operation allows
#' you to see which resources are available in your account, and their
#' names.
#' 
#' This operation takes the optional `Tags` field, which you can use as a
#' filter on the response so that tagged resources can be retrieved as a
#' group. If you choose to use tags filtering, only resources with the tag
#' are retrieved.
#'
#' @usage
#' glue_list_crawlers(MaxResults, NextToken, Tags)
#'
#' @param MaxResults The maximum size of a list to return.
#' @param NextToken A continuation token, if this is a continuation request.
#' @param Tags Specifies to return only these tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CrawlerNames = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_crawlers(
#'   MaxResults = 123,
#'   NextToken = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_crawlers
#'
#' @aliases glue_list_crawlers
glue_list_crawlers <- function(MaxResults = NULL, NextToken = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListCrawlers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_crawlers_input(MaxResults = MaxResults, NextToken = NextToken, Tags = Tags)
  output <- .glue$list_crawlers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_crawlers <- glue_list_crawlers

#' Returns all the crawls of a specified crawler
#'
#' @description
#' Returns all the crawls of a specified crawler. Returns only the crawls
#' that have occurred since the launch date of the crawler history feature,
#' and only retains up to 12 months of crawls. Older crawls will not be
#' returned.
#' 
#' You may use this API to:
#' 
#' -   Retrive all the crawls of a specified crawler.
#' 
#' -   Retrieve all the crawls of a specified crawler within a limited
#'     count.
#' 
#' -   Retrieve all the crawls of a specified crawler in a specific time
#'     range.
#' 
#' -   Retrieve all the crawls of a specified crawler with a particular
#'     state, crawl ID, or DPU hour value.
#'
#' @usage
#' glue_list_crawls(CrawlerName, MaxResults, Filters, NextToken)
#'
#' @param CrawlerName &#91;required&#93; The name of the crawler whose runs you want to retrieve.
#' @param MaxResults The maximum number of results to return. The default is 20, and maximum
#' is 100.
#' @param Filters Filters the crawls by the criteria you specify in a list of
#' `CrawlsFilter` objects.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Crawls = list(
#'     list(
#'       CrawlId = "string",
#'       State = "RUNNING"|"COMPLETED"|"FAILED"|"STOPPED",
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Summary = "string",
#'       ErrorMessage = "string",
#'       LogGroup = "string",
#'       LogStream = "string",
#'       MessagePrefix = "string",
#'       DPUHour = 123.0
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_crawls(
#'   CrawlerName = "string",
#'   MaxResults = 123,
#'   Filters = list(
#'     list(
#'       FieldName = "CRAWL_ID"|"STATE"|"START_TIME"|"END_TIME"|"DPU_HOUR",
#'       FilterOperator = "GT"|"GE"|"LT"|"LE"|"EQ"|"NE",
#'       FieldValue = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_crawls
#'
#' @aliases glue_list_crawls
glue_list_crawls <- function(CrawlerName, MaxResults = NULL, Filters = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListCrawls",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$list_crawls_input(CrawlerName = CrawlerName, MaxResults = MaxResults, Filters = Filters, NextToken = NextToken)
  output <- .glue$list_crawls_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_crawls <- glue_list_crawls

#' Lists all the custom patterns that have been created
#'
#' @description
#' Lists all the custom patterns that have been created.
#'
#' @usage
#' glue_list_custom_entity_types(NextToken, MaxResults, Tags)
#'
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#' @param Tags A list of key-value pair tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CustomEntityTypes = list(
#'     list(
#'       Name = "string",
#'       RegexString = "string",
#'       ContextWords = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_custom_entity_types(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_custom_entity_types
#'
#' @aliases glue_list_custom_entity_types
glue_list_custom_entity_types <- function(NextToken = NULL, MaxResults = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListCustomEntityTypes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_custom_entity_types_input(NextToken = NextToken, MaxResults = MaxResults, Tags = Tags)
  output <- .glue$list_custom_entity_types_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_custom_entity_types <- glue_list_custom_entity_types

#' Returns all data quality execution results for your account
#'
#' @description
#' Returns all data quality execution results for your account.
#'
#' @usage
#' glue_list_data_quality_results(Filter, NextToken, MaxResults)
#'
#' @param Filter The filter criteria.
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Results = list(
#'     list(
#'       ResultId = "string",
#'       DataSource = list(
#'         GlueTable = list(
#'           DatabaseName = "string",
#'           TableName = "string",
#'           CatalogId = "string",
#'           ConnectionName = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       JobName = "string",
#'       JobRunId = "string",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_results(
#'   Filter = list(
#'     DataSource = list(
#'       GlueTable = list(
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CatalogId = "string",
#'         ConnectionName = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     JobName = "string",
#'     JobRunId = "string",
#'     StartedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StartedBefore = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_results
#'
#' @aliases glue_list_data_quality_results
glue_list_data_quality_results <- function(Filter = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListDataQualityResults",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_results_input(Filter = Filter, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$list_data_quality_results_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_results <- glue_list_data_quality_results

#' Lists the recommendation runs meeting the filter criteria
#'
#' @description
#' Lists the recommendation runs meeting the filter criteria.
#'
#' @usage
#' glue_list_data_quality_rule_recommendation_runs(Filter, NextToken,
#'   MaxResults)
#'
#' @param Filter The filter criteria.
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Runs = list(
#'     list(
#'       RunId = "string",
#'       Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       DataSource = list(
#'         GlueTable = list(
#'           DatabaseName = "string",
#'           TableName = "string",
#'           CatalogId = "string",
#'           ConnectionName = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_rule_recommendation_runs(
#'   Filter = list(
#'     DataSource = list(
#'       GlueTable = list(
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CatalogId = "string",
#'         ConnectionName = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     StartedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StartedAfter = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_rule_recommendation_runs
#'
#' @aliases glue_list_data_quality_rule_recommendation_runs
glue_list_data_quality_rule_recommendation_runs <- function(Filter = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListDataQualityRuleRecommendationRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_rule_recommendation_runs_input(Filter = Filter, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$list_data_quality_rule_recommendation_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_rule_recommendation_runs <- glue_list_data_quality_rule_recommendation_runs

#' Lists all the runs meeting the filter criteria, where a ruleset is
#' evaluated against a data source
#'
#' @description
#' Lists all the runs meeting the filter criteria, where a ruleset is
#' evaluated against a data source.
#'
#' @usage
#' glue_list_data_quality_ruleset_evaluation_runs(Filter, NextToken,
#'   MaxResults)
#'
#' @param Filter The filter criteria.
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Runs = list(
#'     list(
#'       RunId = "string",
#'       Status = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT",
#'       StartedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       DataSource = list(
#'         GlueTable = list(
#'           DatabaseName = "string",
#'           TableName = "string",
#'           CatalogId = "string",
#'           ConnectionName = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_ruleset_evaluation_runs(
#'   Filter = list(
#'     DataSource = list(
#'       GlueTable = list(
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CatalogId = "string",
#'         ConnectionName = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     StartedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StartedAfter = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_ruleset_evaluation_runs
#'
#' @aliases glue_list_data_quality_ruleset_evaluation_runs
glue_list_data_quality_ruleset_evaluation_runs <- function(Filter = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListDataQualityRulesetEvaluationRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_ruleset_evaluation_runs_input(Filter = Filter, NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$list_data_quality_ruleset_evaluation_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_ruleset_evaluation_runs <- glue_list_data_quality_ruleset_evaluation_runs

#' Returns a paginated list of rulesets for the specified list of Glue
#' tables
#'
#' @description
#' Returns a paginated list of rulesets for the specified list of Glue
#' tables.
#'
#' @usage
#' glue_list_data_quality_rulesets(NextToken, MaxResults, Filter, Tags)
#'
#' @param NextToken A paginated token to offset the results.
#' @param MaxResults The maximum number of results to return.
#' @param Filter The filter criteria.
#' @param Tags A list of key-value pair tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Rulesets = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       TargetTable = list(
#'         TableName = "string",
#'         DatabaseName = "string",
#'         CatalogId = "string"
#'       ),
#'       RecommendationRunId = "string",
#'       RuleCount = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_rulesets(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Filter = list(
#'     Name = "string",
#'     Description = "string",
#'     CreatedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreatedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     TargetTable = list(
#'       TableName = "string",
#'       DatabaseName = "string",
#'       CatalogId = "string"
#'     )
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_rulesets
#'
#' @aliases glue_list_data_quality_rulesets
glue_list_data_quality_rulesets <- function(NextToken = NULL, MaxResults = NULL, Filter = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListDataQualityRulesets",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_rulesets_input(NextToken = NextToken, MaxResults = MaxResults, Filter = Filter, Tags = Tags)
  output <- .glue$list_data_quality_rulesets_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_rulesets <- glue_list_data_quality_rulesets

#' Retrieve annotations for a data quality statistic
#'
#' @description
#' Retrieve annotations for a data quality statistic.
#'
#' @usage
#' glue_list_data_quality_statistic_annotations(StatisticId, ProfileId,
#'   TimestampFilter, MaxResults, NextToken)
#'
#' @param StatisticId The Statistic ID.
#' @param ProfileId The Profile ID.
#' @param TimestampFilter A timestamp filter.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken A pagination token to retrieve the next set of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Annotations = list(
#'     list(
#'       ProfileId = "string",
#'       StatisticId = "string",
#'       StatisticRecordedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       InclusionAnnotation = list(
#'         Value = "INCLUDE"|"EXCLUDE",
#'         LastModifiedOn = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_statistic_annotations(
#'   StatisticId = "string",
#'   ProfileId = "string",
#'   TimestampFilter = list(
#'     RecordedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RecordedAfter = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_statistic_annotations
#'
#' @aliases glue_list_data_quality_statistic_annotations
glue_list_data_quality_statistic_annotations <- function(StatisticId = NULL, ProfileId = NULL, TimestampFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListDataQualityStatisticAnnotations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_statistic_annotations_input(StatisticId = StatisticId, ProfileId = ProfileId, TimestampFilter = TimestampFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_data_quality_statistic_annotations_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_statistic_annotations <- glue_list_data_quality_statistic_annotations

#' Retrieves a list of data quality statistics
#'
#' @description
#' Retrieves a list of data quality statistics.
#'
#' @usage
#' glue_list_data_quality_statistics(StatisticId, ProfileId,
#'   TimestampFilter, MaxResults, NextToken)
#'
#' @param StatisticId The Statistic ID.
#' @param ProfileId The Profile ID.
#' @param TimestampFilter A timestamp filter.
#' @param MaxResults The maximum number of results to return in this request.
#' @param NextToken A pagination token to request the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Statistics = list(
#'     list(
#'       StatisticId = "string",
#'       ProfileId = "string",
#'       RunIdentifier = list(
#'         RunId = "string",
#'         JobRunId = "string"
#'       ),
#'       StatisticName = "string",
#'       DoubleValue = 123.0,
#'       EvaluationLevel = "Dataset"|"Column"|"Multicolumn",
#'       ColumnsReferenced = list(
#'         "string"
#'       ),
#'       ReferencedDatasets = list(
#'         "string"
#'       ),
#'       StatisticProperties = list(
#'         "string"
#'       ),
#'       RecordedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       InclusionAnnotation = list(
#'         Value = "INCLUDE"|"EXCLUDE",
#'         LastModifiedOn = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_quality_statistics(
#'   StatisticId = "string",
#'   ProfileId = "string",
#'   TimestampFilter = list(
#'     RecordedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RecordedAfter = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_data_quality_statistics
#'
#' @aliases glue_list_data_quality_statistics
glue_list_data_quality_statistics <- function(StatisticId = NULL, ProfileId = NULL, TimestampFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListDataQualityStatistics",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$list_data_quality_statistics_input(StatisticId = StatisticId, ProfileId = ProfileId, TimestampFilter = TimestampFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_data_quality_statistics_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_data_quality_statistics <- glue_list_data_quality_statistics

#' Retrieves the names of all DevEndpoint resources in this Amazon Web
#' Services account, or the resources with the specified tag
#'
#' @description
#' Retrieves the names of all `DevEndpoint` resources in this Amazon Web
#' Services account, or the resources with the specified tag. This
#' operation allows you to see which resources are available in your
#' account, and their names.
#' 
#' This operation takes the optional `Tags` field, which you can use as a
#' filter on the response so that tagged resources can be retrieved as a
#' group. If you choose to use tags filtering, only resources with the tag
#' are retrieved.
#'
#' @usage
#' glue_list_dev_endpoints(NextToken, MaxResults, Tags)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#' @param Tags Specifies to return only these tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DevEndpointNames = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_dev_endpoints(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_dev_endpoints
#'
#' @aliases glue_list_dev_endpoints
glue_list_dev_endpoints <- function(NextToken = NULL, MaxResults = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListDevEndpoints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_dev_endpoints_input(NextToken = NextToken, MaxResults = MaxResults, Tags = Tags)
  output <- .glue$list_dev_endpoints_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_dev_endpoints <- glue_list_dev_endpoints

#' Returns the available entities supported by the connection type
#'
#' @description
#' Returns the available entities supported by the connection type.
#'
#' @usage
#' glue_list_entities(ConnectionName, CatalogId, ParentEntityName,
#'   NextToken, DataStoreApiVersion)
#'
#' @param ConnectionName A name for the connection that has required credentials to query any
#' connection type.
#' @param CatalogId The catalog ID of the catalog that contains the connection. This can be
#' null, By default, the Amazon Web Services Account ID is the catalog ID.
#' @param ParentEntityName Name of the parent entity for which you want to list the children. This
#' parameter takes a fully-qualified path of the entity in order to list
#' the child entities.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param DataStoreApiVersion The API version of the SaaS connector.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Entities = list(
#'     list(
#'       EntityName = "string",
#'       Label = "string",
#'       IsParentEntity = TRUE|FALSE,
#'       Description = "string",
#'       Category = "string",
#'       CustomProperties = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_entities(
#'   ConnectionName = "string",
#'   CatalogId = "string",
#'   ParentEntityName = "string",
#'   NextToken = "string",
#'   DataStoreApiVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_entities
#'
#' @aliases glue_list_entities
glue_list_entities <- function(ConnectionName = NULL, CatalogId = NULL, ParentEntityName = NULL, NextToken = NULL, DataStoreApiVersion = NULL) {
  op <- new_operation(
    name = "ListEntities",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", result_key = "Entities"),
    stream_api = FALSE
  )
  input <- .glue$list_entities_input(ConnectionName = ConnectionName, CatalogId = CatalogId, ParentEntityName = ParentEntityName, NextToken = NextToken, DataStoreApiVersion = DataStoreApiVersion)
  output <- .glue$list_entities_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_entities <- glue_list_entities

#' Retrieves the names of all job resources in this Amazon Web Services
#' account, or the resources with the specified tag
#'
#' @description
#' Retrieves the names of all job resources in this Amazon Web Services
#' account, or the resources with the specified tag. This operation allows
#' you to see which resources are available in your account, and their
#' names.
#' 
#' This operation takes the optional `Tags` field, which you can use as a
#' filter on the response so that tagged resources can be retrieved as a
#' group. If you choose to use tags filtering, only resources with the tag
#' are retrieved.
#'
#' @usage
#' glue_list_jobs(NextToken, MaxResults, Tags)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#' @param Tags Specifies to return only these tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobNames = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_jobs(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_jobs
#'
#' @aliases glue_list_jobs
glue_list_jobs <- function(NextToken = NULL, MaxResults = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListJobs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "JobNames"),
    stream_api = FALSE
  )
  input <- .glue$list_jobs_input(NextToken = NextToken, MaxResults = MaxResults, Tags = Tags)
  output <- .glue$list_jobs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_jobs <- glue_list_jobs

#' Retrieves a sortable, filterable list of existing Glue machine learning
#' transforms in this Amazon Web Services account, or the resources with
#' the specified tag
#'
#' @description
#' Retrieves a sortable, filterable list of existing Glue machine learning
#' transforms in this Amazon Web Services account, or the resources with
#' the specified tag. This operation takes the optional `Tags` field, which
#' you can use as a filter of the responses so that tagged resources can be
#' retrieved as a group. If you choose to use tag filtering, only resources
#' with the tags are retrieved.
#'
#' @usage
#' glue_list_ml_transforms(NextToken, MaxResults, Filter, Sort, Tags)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#' @param Filter A `TransformFilterCriteria` used to filter the machine learning
#' transforms.
#' @param Sort A `TransformSortCriteria` used to sort the machine learning transforms.
#' @param Tags Specifies to return only these tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_ml_transforms(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Filter = list(
#'     Name = "string",
#'     TransformType = "FIND_MATCHES",
#'     Status = "NOT_READY"|"READY"|"DELETING",
#'     GlueVersion = "string",
#'     CreatedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreatedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedBefore = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedAfter = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Schema = list(
#'       list(
#'         Name = "string",
#'         DataType = "string"
#'       )
#'     )
#'   ),
#'   Sort = list(
#'     Column = "NAME"|"TRANSFORM_TYPE"|"STATUS"|"CREATED"|"LAST_MODIFIED",
#'     SortDirection = "DESCENDING"|"ASCENDING"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_ml_transforms
#'
#' @aliases glue_list_ml_transforms
glue_list_ml_transforms <- function(NextToken = NULL, MaxResults = NULL, Filter = NULL, Sort = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListMLTransforms",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_ml_transforms_input(NextToken = NextToken, MaxResults = MaxResults, Filter = Filter, Sort = Sort, Tags = Tags)
  output <- .glue$list_ml_transforms_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_ml_transforms <- glue_list_ml_transforms

#' Returns a list of registries that you have created, with minimal
#' registry information
#'
#' @description
#' Returns a list of registries that you have created, with minimal
#' registry information. Registries in the `Deleting` status will not be
#' included in the results. Empty results will be returned if there are no
#' registries available.
#'
#' @usage
#' glue_list_registries(MaxResults, NextToken)
#'
#' @param MaxResults Maximum number of results required per page. If the value is not
#' supplied, this will be defaulted to 25 per page.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Registries = list(
#'     list(
#'       RegistryName = "string",
#'       RegistryArn = "string",
#'       Description = "string",
#'       Status = "AVAILABLE"|"DELETING",
#'       CreatedTime = "string",
#'       UpdatedTime = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_registries(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_registries
#'
#' @aliases glue_list_registries
glue_list_registries <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListRegistries",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Registries"),
    stream_api = FALSE
  )
  input <- .glue$list_registries_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_registries_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_registries <- glue_list_registries

#' Returns a list of schema versions that you have created, with minimal
#' information
#'
#' @description
#' Returns a list of schema versions that you have created, with minimal
#' information. Schema versions in Deleted status will not be included in
#' the results. Empty results will be returned if there are no schema
#' versions available.
#'
#' @usage
#' glue_list_schema_versions(SchemaId, MaxResults, NextToken)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     Either `SchemaArn` or `SchemaName` and `RegistryName` has to be
#'     provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. Either `SchemaArn` or
#'     `SchemaName` and `RegistryName` has to be provided.
#' @param MaxResults Maximum number of results required per page. If the value is not
#' supplied, this will be defaulted to 25 per page.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Schemas = list(
#'     list(
#'       SchemaArn = "string",
#'       SchemaVersionId = "string",
#'       VersionNumber = 123,
#'       Status = "AVAILABLE"|"PENDING"|"FAILURE"|"DELETING",
#'       CreatedTime = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_schema_versions(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_schema_versions
#'
#' @aliases glue_list_schema_versions
glue_list_schema_versions <- function(SchemaId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListSchemaVersions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Schemas"),
    stream_api = FALSE
  )
  input <- .glue$list_schema_versions_input(SchemaId = SchemaId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_schema_versions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_schema_versions <- glue_list_schema_versions

#' Returns a list of schemas with minimal details
#'
#' @description
#' Returns a list of schemas with minimal details. Schemas in Deleting
#' status will not be included in the results. Empty results will be
#' returned if there are no schemas available.
#' 
#' When the `RegistryId` is not provided, all the schemas across registries
#' will be part of the API response.
#'
#' @usage
#' glue_list_schemas(RegistryId, MaxResults, NextToken)
#'
#' @param RegistryId A wrapper structure that may contain the registry name and Amazon
#' Resource Name (ARN).
#' @param MaxResults Maximum number of results required per page. If the value is not
#' supplied, this will be defaulted to 25 per page.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Schemas = list(
#'     list(
#'       RegistryName = "string",
#'       SchemaName = "string",
#'       SchemaArn = "string",
#'       Description = "string",
#'       SchemaStatus = "AVAILABLE"|"PENDING"|"DELETING",
#'       CreatedTime = "string",
#'       UpdatedTime = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_schemas(
#'   RegistryId = list(
#'     RegistryName = "string",
#'     RegistryArn = "string"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_schemas
#'
#' @aliases glue_list_schemas
glue_list_schemas <- function(RegistryId = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListSchemas",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Schemas"),
    stream_api = FALSE
  )
  input <- .glue$list_schemas_input(RegistryId = RegistryId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_schemas_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_schemas <- glue_list_schemas

#' Retrieve a list of sessions
#'
#' @description
#' Retrieve a list of sessions.
#'
#' @usage
#' glue_list_sessions(NextToken, MaxResults, Tags, RequestOrigin)
#'
#' @param NextToken The token for the next set of results, or null if there are no more
#' result.
#' @param MaxResults The maximum number of results.
#' @param Tags Tags belonging to the session.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Ids = list(
#'     "string"
#'   ),
#'   Sessions = list(
#'     list(
#'       Id = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Status = "PROVISIONING"|"READY"|"FAILED"|"TIMEOUT"|"STOPPING"|"STOPPED",
#'       ErrorMessage = "string",
#'       Description = "string",
#'       Role = "string",
#'       Command = list(
#'         Name = "string",
#'         PythonVersion = "string"
#'       ),
#'       DefaultArguments = list(
#'         "string"
#'       ),
#'       Connections = list(
#'         Connections = list(
#'           "string"
#'         )
#'       ),
#'       Progress = 123.0,
#'       MaxCapacity = 123.0,
#'       SecurityConfiguration = "string",
#'       GlueVersion = "string",
#'       NumberOfWorkers = 123,
#'       WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'       CompletedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExecutionTime = 123.0,
#'       DPUSeconds = 123.0,
#'       IdleTimeout = 123,
#'       ProfileName = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_sessions(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   ),
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_sessions
#'
#' @aliases glue_list_sessions
glue_list_sessions <- function(NextToken = NULL, MaxResults = NULL, Tags = NULL, RequestOrigin = NULL) {
  op <- new_operation(
    name = "ListSessions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$list_sessions_input(NextToken = NextToken, MaxResults = MaxResults, Tags = Tags, RequestOrigin = RequestOrigin)
  output <- .glue$list_sessions_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_sessions <- glue_list_sessions

#' Lists statements for the session
#'
#' @description
#' Lists statements for the session.
#'
#' @usage
#' glue_list_statements(SessionId, RequestOrigin, NextToken)
#'
#' @param SessionId &#91;required&#93; The Session ID of the statements.
#' @param RequestOrigin The origin of the request to list statements.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Statements = list(
#'     list(
#'       Id = 123,
#'       Code = "string",
#'       State = "WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR",
#'       Output = list(
#'         Data = list(
#'           TextPlain = "string"
#'         ),
#'         ExecutionCount = 123,
#'         Status = "WAITING"|"RUNNING"|"AVAILABLE"|"CANCELLING"|"CANCELLED"|"ERROR",
#'         ErrorName = "string",
#'         ErrorValue = "string",
#'         Traceback = list(
#'           "string"
#'         )
#'       ),
#'       Progress = 123.0,
#'       StartedOn = 123,
#'       CompletedOn = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_statements(
#'   SessionId = "string",
#'   RequestOrigin = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_statements
#'
#' @aliases glue_list_statements
glue_list_statements <- function(SessionId, RequestOrigin = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListStatements",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$list_statements_input(SessionId = SessionId, RequestOrigin = RequestOrigin, NextToken = NextToken)
  output <- .glue$list_statements_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_statements <- glue_list_statements

#' Lists the history of previous optimizer runs for a specific table
#'
#' @description
#' Lists the history of previous optimizer runs for a specific table.
#'
#' @usage
#' glue_list_table_optimizer_runs(CatalogId, DatabaseName, TableName, Type,
#'   MaxResults, NextToken)
#'
#' @param CatalogId &#91;required&#93; The Catalog ID of the table.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param Type &#91;required&#93; The type of table optimizer.
#' @param MaxResults The maximum number of optimizer runs to return on each call.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   NextToken = "string",
#'   TableOptimizerRuns = list(
#'     list(
#'       eventType = "starting"|"completed"|"failed"|"in_progress",
#'       startTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       metrics = list(
#'         NumberOfBytesCompacted = "string",
#'         NumberOfFilesCompacted = "string",
#'         NumberOfDpus = "string",
#'         JobDurationInHour = "string"
#'       ),
#'       error = "string",
#'       compactionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfBytesCompacted = 123,
#'           NumberOfFilesCompacted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       ),
#'       retentionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfDataFilesDeleted = 123,
#'           NumberOfManifestFilesDeleted = 123,
#'           NumberOfManifestListsDeleted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       ),
#'       orphanFileDeletionMetrics = list(
#'         IcebergMetrics = list(
#'           NumberOfOrphanFilesDeleted = 123,
#'           NumberOfDpus = 123,
#'           JobDurationInHour = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_table_optimizer_runs(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Type = "compaction"|"retention"|"orphan_file_deletion",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_table_optimizer_runs
#'
#' @aliases glue_list_table_optimizer_runs
glue_list_table_optimizer_runs <- function(CatalogId, DatabaseName, TableName, Type, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListTableOptimizerRuns",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "TableOptimizerRuns"),
    stream_api = FALSE
  )
  input <- .glue$list_table_optimizer_runs_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Type = Type, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$list_table_optimizer_runs_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_table_optimizer_runs <- glue_list_table_optimizer_runs

#' Retrieves the names of all trigger resources in this Amazon Web Services
#' account, or the resources with the specified tag
#'
#' @description
#' Retrieves the names of all trigger resources in this Amazon Web Services
#' account, or the resources with the specified tag. This operation allows
#' you to see which resources are available in your account, and their
#' names.
#' 
#' This operation takes the optional `Tags` field, which you can use as a
#' filter on the response so that tagged resources can be retrieved as a
#' group. If you choose to use tags filtering, only resources with the tag
#' are retrieved.
#'
#' @usage
#' glue_list_triggers(NextToken, DependentJobName, MaxResults, Tags)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param DependentJobName The name of the job for which to retrieve triggers. The trigger that can
#' start this job is returned. If there is no such trigger, all triggers
#' are returned.
#' @param MaxResults The maximum size of a list to return.
#' @param Tags Specifies to return only these tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TriggerNames = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_triggers(
#'   NextToken = "string",
#'   DependentJobName = "string",
#'   MaxResults = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_triggers
#'
#' @aliases glue_list_triggers
glue_list_triggers <- function(NextToken = NULL, DependentJobName = NULL, MaxResults = NULL, Tags = NULL) {
  op <- new_operation(
    name = "ListTriggers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "TriggerNames"),
    stream_api = FALSE
  )
  input <- .glue$list_triggers_input(NextToken = NextToken, DependentJobName = DependentJobName, MaxResults = MaxResults, Tags = Tags)
  output <- .glue$list_triggers_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_triggers <- glue_list_triggers

#' List all the Glue usage profiles
#'
#' @description
#' List all the Glue usage profiles.
#'
#' @usage
#' glue_list_usage_profiles(NextToken, MaxResults)
#'
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param MaxResults The maximum number of usage profiles to return in a single response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Profiles = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       CreatedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastModifiedOn = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_usage_profiles(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_usage_profiles
#'
#' @aliases glue_list_usage_profiles
glue_list_usage_profiles <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListUsageProfiles",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Profiles"),
    stream_api = FALSE
  )
  input <- .glue$list_usage_profiles_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$list_usage_profiles_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_usage_profiles <- glue_list_usage_profiles

#' Lists names of workflows created in the account
#'
#' @description
#' Lists names of workflows created in the account.
#'
#' @usage
#' glue_list_workflows(NextToken, MaxResults)
#'
#' @param NextToken A continuation token, if this is a continuation request.
#' @param MaxResults The maximum size of a list to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Workflows = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_workflows(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_list_workflows
#'
#' @aliases glue_list_workflows
glue_list_workflows <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListWorkflows",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Workflows"),
    stream_api = FALSE
  )
  input <- .glue$list_workflows_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .glue$list_workflows_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$list_workflows <- glue_list_workflows

#' Modifies a Zero-ETL integration in the caller's account
#'
#' @description
#' Modifies a Zero-ETL integration in the caller's account.
#'
#' @usage
#' glue_modify_integration(IntegrationIdentifier, Description, DataFilter,
#'   IntegrationName)
#'
#' @param IntegrationIdentifier &#91;required&#93; The Amazon Resource Name (ARN) for the integration.
#' @param Description A description of the integration.
#' @param DataFilter Selects source tables for the integration using Maxwell filter syntax.
#' @param IntegrationName A unique name for an integration in Glue.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SourceArn = "string",
#'   TargetArn = "string",
#'   IntegrationName = "string",
#'   Description = "string",
#'   IntegrationArn = "string",
#'   KmsKeyId = "string",
#'   AdditionalEncryptionContext = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   Status = "CREATING"|"ACTIVE"|"MODIFYING"|"FAILED"|"DELETING"|"SYNCING"|"NEEDS_ATTENTION",
#'   CreateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Errors = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   ),
#'   DataFilter = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$modify_integration(
#'   IntegrationIdentifier = "string",
#'   Description = "string",
#'   DataFilter = "string",
#'   IntegrationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_modify_integration
#'
#' @aliases glue_modify_integration
glue_modify_integration <- function(IntegrationIdentifier, Description = NULL, DataFilter = NULL, IntegrationName = NULL) {
  op <- new_operation(
    name = "ModifyIntegration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$modify_integration_input(IntegrationIdentifier = IntegrationIdentifier, Description = Description, DataFilter = DataFilter, IntegrationName = IntegrationName)
  output <- .glue$modify_integration_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$modify_integration <- glue_modify_integration

#' Sets the security configuration for a specified catalog
#'
#' @description
#' Sets the security configuration for a specified catalog. After the
#' configuration has been set, the specified encryption is applied to every
#' catalog write thereafter.
#'
#' @usage
#' glue_put_data_catalog_encryption_settings(CatalogId,
#'   DataCatalogEncryptionSettings)
#'
#' @param CatalogId The ID of the Data Catalog to set the security configuration for. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DataCatalogEncryptionSettings &#91;required&#93; The security configuration to set.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_data_catalog_encryption_settings(
#'   CatalogId = "string",
#'   DataCatalogEncryptionSettings = list(
#'     EncryptionAtRest = list(
#'       CatalogEncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-KMS-WITH-SERVICE-ROLE",
#'       SseAwsKmsKeyId = "string",
#'       CatalogEncryptionServiceRole = "string"
#'     ),
#'     ConnectionPasswordEncryption = list(
#'       ReturnConnectionPasswordEncrypted = TRUE|FALSE,
#'       AwsKmsKeyId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_put_data_catalog_encryption_settings
#'
#' @aliases glue_put_data_catalog_encryption_settings
glue_put_data_catalog_encryption_settings <- function(CatalogId = NULL, DataCatalogEncryptionSettings) {
  op <- new_operation(
    name = "PutDataCatalogEncryptionSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$put_data_catalog_encryption_settings_input(CatalogId = CatalogId, DataCatalogEncryptionSettings = DataCatalogEncryptionSettings)
  output <- .glue$put_data_catalog_encryption_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$put_data_catalog_encryption_settings <- glue_put_data_catalog_encryption_settings

#' Annotate all datapoints for a Profile
#'
#' @description
#' Annotate all datapoints for a Profile.
#'
#' @usage
#' glue_put_data_quality_profile_annotation(ProfileId, InclusionAnnotation)
#'
#' @param ProfileId &#91;required&#93; The ID of the data quality monitoring profile to annotate.
#' @param InclusionAnnotation &#91;required&#93; The inclusion annotation value to apply to the profile.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_data_quality_profile_annotation(
#'   ProfileId = "string",
#'   InclusionAnnotation = "INCLUDE"|"EXCLUDE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_put_data_quality_profile_annotation
#'
#' @aliases glue_put_data_quality_profile_annotation
glue_put_data_quality_profile_annotation <- function(ProfileId, InclusionAnnotation) {
  op <- new_operation(
    name = "PutDataQualityProfileAnnotation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$put_data_quality_profile_annotation_input(ProfileId = ProfileId, InclusionAnnotation = InclusionAnnotation)
  output <- .glue$put_data_quality_profile_annotation_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$put_data_quality_profile_annotation <- glue_put_data_quality_profile_annotation

#' Sets the Data Catalog resource policy for access control
#'
#' @description
#' Sets the Data Catalog resource policy for access control.
#'
#' @usage
#' glue_put_resource_policy(PolicyInJson, ResourceArn, PolicyHashCondition,
#'   PolicyExistsCondition, EnableHybrid)
#'
#' @param PolicyInJson &#91;required&#93; Contains the policy document to set, in JSON format.
#' @param ResourceArn Do not use. For internal use only.
#' @param PolicyHashCondition The hash value returned when the previous policy was set using
#' [`put_resource_policy`][glue_put_resource_policy]. Its purpose is to
#' prevent concurrent modifications of a policy. Do not use this parameter
#' if no previous policy has been set.
#' @param PolicyExistsCondition A value of `MUST_EXIST` is used to update a policy. A value of
#' `NOT_EXIST` is used to create a new policy. If a value of `NONE` or a
#' null value is used, the call does not depend on the existence of a
#' policy.
#' @param EnableHybrid If `'TRUE'`, indicates that you are using both methods to grant
#' cross-account access to Data Catalog resources:
#' 
#' -   By directly updating the resource policy with `PutResourePolicy`
#' 
#' -   By using the **Grant permissions** command on the Amazon Web
#'     Services Management Console.
#' 
#' Must be set to `'TRUE'` if you have already used the Management Console
#' to grant cross-account access, otherwise the call fails. Default is
#' 'FALSE'.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PolicyHash = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_resource_policy(
#'   PolicyInJson = "string",
#'   ResourceArn = "string",
#'   PolicyHashCondition = "string",
#'   PolicyExistsCondition = "MUST_EXIST"|"NOT_EXIST"|"NONE",
#'   EnableHybrid = "TRUE"|"FALSE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_put_resource_policy
#'
#' @aliases glue_put_resource_policy
glue_put_resource_policy <- function(PolicyInJson, ResourceArn = NULL, PolicyHashCondition = NULL, PolicyExistsCondition = NULL, EnableHybrid = NULL) {
  op <- new_operation(
    name = "PutResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$put_resource_policy_input(PolicyInJson = PolicyInJson, ResourceArn = ResourceArn, PolicyHashCondition = PolicyHashCondition, PolicyExistsCondition = PolicyExistsCondition, EnableHybrid = EnableHybrid)
  output <- .glue$put_resource_policy_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$put_resource_policy <- glue_put_resource_policy

#' Puts the metadata key value pair for a specified schema version ID
#'
#' @description
#' Puts the metadata key value pair for a specified schema version ID. A
#' maximum of 10 key value pairs will be allowed per schema version. They
#' can be added over one or more calls.
#'
#' @usage
#' glue_put_schema_version_metadata(SchemaId, SchemaVersionNumber,
#'   SchemaVersionId, MetadataKeyValue)
#'
#' @param SchemaId The unique ID for the schema.
#' @param SchemaVersionNumber The version number of the schema.
#' @param SchemaVersionId The unique version ID of the schema version.
#' @param MetadataKeyValue &#91;required&#93; The metadata key's corresponding value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaArn = "string",
#'   SchemaName = "string",
#'   RegistryName = "string",
#'   LatestVersion = TRUE|FALSE,
#'   VersionNumber = 123,
#'   SchemaVersionId = "string",
#'   MetadataKey = "string",
#'   MetadataValue = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_schema_version_metadata(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   SchemaVersionId = "string",
#'   MetadataKeyValue = list(
#'     MetadataKey = "string",
#'     MetadataValue = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_put_schema_version_metadata
#'
#' @aliases glue_put_schema_version_metadata
glue_put_schema_version_metadata <- function(SchemaId = NULL, SchemaVersionNumber = NULL, SchemaVersionId = NULL, MetadataKeyValue) {
  op <- new_operation(
    name = "PutSchemaVersionMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$put_schema_version_metadata_input(SchemaId = SchemaId, SchemaVersionNumber = SchemaVersionNumber, SchemaVersionId = SchemaVersionId, MetadataKeyValue = MetadataKeyValue)
  output <- .glue$put_schema_version_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$put_schema_version_metadata <- glue_put_schema_version_metadata

#' Puts the specified workflow run properties for the given workflow run
#'
#' @description
#' Puts the specified workflow run properties for the given workflow run.
#' If a property already exists for the specified run, then it overrides
#' the value otherwise adds the property to existing properties.
#'
#' @usage
#' glue_put_workflow_run_properties(Name, RunId, RunProperties)
#'
#' @param Name &#91;required&#93; Name of the workflow which was run.
#' @param RunId &#91;required&#93; The ID of the workflow run for which the run properties should be
#' updated.
#' @param RunProperties &#91;required&#93; The properties to put for the specified run.
#' 
#' Run properties may be logged. Do not pass plaintext secrets as
#' properties. Retrieve secrets from a Glue Connection, Amazon Web Services
#' Secrets Manager or other secret management mechanism if you intend to
#' use them within the workflow run.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_workflow_run_properties(
#'   Name = "string",
#'   RunId = "string",
#'   RunProperties = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_put_workflow_run_properties
#'
#' @aliases glue_put_workflow_run_properties
glue_put_workflow_run_properties <- function(Name, RunId, RunProperties) {
  op <- new_operation(
    name = "PutWorkflowRunProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$put_workflow_run_properties_input(Name = Name, RunId = RunId, RunProperties = RunProperties)
  output <- .glue$put_workflow_run_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$put_workflow_run_properties <- glue_put_workflow_run_properties

#' Queries for the schema version metadata information
#'
#' @description
#' Queries for the schema version metadata information.
#'
#' @usage
#' glue_query_schema_version_metadata(SchemaId, SchemaVersionNumber,
#'   SchemaVersionId, MetadataList, MaxResults, NextToken)
#'
#' @param SchemaId A wrapper structure that may contain the schema name and Amazon Resource
#' Name (ARN).
#' @param SchemaVersionNumber The version number of the schema.
#' @param SchemaVersionId The unique version ID of the schema version.
#' @param MetadataList Search key-value pairs for metadata, if they are not provided all the
#' metadata information will be fetched.
#' @param MaxResults Maximum number of results required per page. If the value is not
#' supplied, this will be defaulted to 25 per page.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   MetadataInfoMap = list(
#'     list(
#'       MetadataValue = "string",
#'       CreatedTime = "string",
#'       OtherMetadataValueList = list(
#'         list(
#'           MetadataValue = "string",
#'           CreatedTime = "string"
#'         )
#'       )
#'     )
#'   ),
#'   SchemaVersionId = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$query_schema_version_metadata(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   SchemaVersionId = "string",
#'   MetadataList = list(
#'     list(
#'       MetadataKey = "string",
#'       MetadataValue = "string"
#'     )
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_query_schema_version_metadata
#'
#' @aliases glue_query_schema_version_metadata
glue_query_schema_version_metadata <- function(SchemaId = NULL, SchemaVersionNumber = NULL, SchemaVersionId = NULL, MetadataList = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "QuerySchemaVersionMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$query_schema_version_metadata_input(SchemaId = SchemaId, SchemaVersionNumber = SchemaVersionNumber, SchemaVersionId = SchemaVersionId, MetadataList = MetadataList, MaxResults = MaxResults, NextToken = NextToken)
  output <- .glue$query_schema_version_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$query_schema_version_metadata <- glue_query_schema_version_metadata

#' Adds a new version to the existing schema
#'
#' @description
#' Adds a new version to the existing schema. Returns an error if new
#' version of schema does not meet the compatibility requirements of the
#' schema set. This API will not create a new schema set and will return a
#' 404 error if the schema set is not already present in the Schema
#' Registry.
#' 
#' If this is the first schema definition to be registered in the Schema
#' Registry, this API will store the schema version and return immediately.
#' Otherwise, this call has the potential to run longer than other
#' operations due to compatibility modes. You can call the
#' [`get_schema_version`][glue_get_schema_version] API with the
#' `SchemaVersionId` to check compatibility modes.
#' 
#' If the same schema definition is already stored in Schema Registry as a
#' version, the schema ID of the existing schema is returned to the caller.
#'
#' @usage
#' glue_register_schema_version(SchemaId, SchemaDefinition)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     Either `SchemaArn` or `SchemaName` and `RegistryName` has to be
#'     provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. Either `SchemaArn` or
#'     `SchemaName` and `RegistryName` has to be provided.
#' @param SchemaDefinition &#91;required&#93; The schema definition using the `DataFormat` setting for the
#' `SchemaName`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaVersionId = "string",
#'   VersionNumber = 123,
#'   Status = "AVAILABLE"|"PENDING"|"FAILURE"|"DELETING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$register_schema_version(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaDefinition = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_register_schema_version
#'
#' @aliases glue_register_schema_version
glue_register_schema_version <- function(SchemaId, SchemaDefinition) {
  op <- new_operation(
    name = "RegisterSchemaVersion",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$register_schema_version_input(SchemaId = SchemaId, SchemaDefinition = SchemaDefinition)
  output <- .glue$register_schema_version_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$register_schema_version <- glue_register_schema_version

#' Removes a key value pair from the schema version metadata for the
#' specified schema version ID
#'
#' @description
#' Removes a key value pair from the schema version metadata for the
#' specified schema version ID.
#'
#' @usage
#' glue_remove_schema_version_metadata(SchemaId, SchemaVersionNumber,
#'   SchemaVersionId, MetadataKeyValue)
#'
#' @param SchemaId A wrapper structure that may contain the schema name and Amazon Resource
#' Name (ARN).
#' @param SchemaVersionNumber The version number of the schema.
#' @param SchemaVersionId The unique version ID of the schema version.
#' @param MetadataKeyValue &#91;required&#93; The value of the metadata key.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaArn = "string",
#'   SchemaName = "string",
#'   RegistryName = "string",
#'   LatestVersion = TRUE|FALSE,
#'   VersionNumber = 123,
#'   SchemaVersionId = "string",
#'   MetadataKey = "string",
#'   MetadataValue = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$remove_schema_version_metadata(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   SchemaVersionId = "string",
#'   MetadataKeyValue = list(
#'     MetadataKey = "string",
#'     MetadataValue = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_remove_schema_version_metadata
#'
#' @aliases glue_remove_schema_version_metadata
glue_remove_schema_version_metadata <- function(SchemaId = NULL, SchemaVersionNumber = NULL, SchemaVersionId = NULL, MetadataKeyValue) {
  op <- new_operation(
    name = "RemoveSchemaVersionMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$remove_schema_version_metadata_input(SchemaId = SchemaId, SchemaVersionNumber = SchemaVersionNumber, SchemaVersionId = SchemaVersionId, MetadataKeyValue = MetadataKeyValue)
  output <- .glue$remove_schema_version_metadata_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$remove_schema_version_metadata <- glue_remove_schema_version_metadata

#' Resets a bookmark entry
#'
#' @description
#' Resets a bookmark entry.
#' 
#' For more information about enabling and using job bookmarks, see:
#' 
#' -   [Tracking processed data using job
#'     bookmarks](https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html)
#' 
#' -   [Job parameters used by
#'     Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html)
#' 
#' -   [Job
#'     structure](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html#aws-glue-api-jobs-job-Job)
#'
#' @usage
#' glue_reset_job_bookmark(JobName, RunId)
#'
#' @param JobName &#91;required&#93; The name of the job in question.
#' @param RunId The unique run identifier associated with this job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobBookmarkEntry = list(
#'     JobName = "string",
#'     Version = 123,
#'     Run = 123,
#'     Attempt = 123,
#'     PreviousRunId = "string",
#'     RunId = "string",
#'     JobBookmark = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reset_job_bookmark(
#'   JobName = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_reset_job_bookmark
#'
#' @aliases glue_reset_job_bookmark
glue_reset_job_bookmark <- function(JobName, RunId = NULL) {
  op <- new_operation(
    name = "ResetJobBookmark",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$reset_job_bookmark_input(JobName = JobName, RunId = RunId)
  output <- .glue$reset_job_bookmark_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$reset_job_bookmark <- glue_reset_job_bookmark

#' Restarts selected nodes of a previous partially completed workflow run
#' and resumes the workflow run
#'
#' @description
#' Restarts selected nodes of a previous partially completed workflow run
#' and resumes the workflow run. The selected nodes and all nodes that are
#' downstream from the selected nodes are run.
#'
#' @usage
#' glue_resume_workflow_run(Name, RunId, NodeIds)
#'
#' @param Name &#91;required&#93; The name of the workflow to resume.
#' @param RunId &#91;required&#93; The ID of the workflow run to resume.
#' @param NodeIds &#91;required&#93; A list of the node IDs for the nodes you want to restart. The nodes that
#' are to be restarted must have a run attempt in the original run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string",
#'   NodeIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$resume_workflow_run(
#'   Name = "string",
#'   RunId = "string",
#'   NodeIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_resume_workflow_run
#'
#' @aliases glue_resume_workflow_run
glue_resume_workflow_run <- function(Name, RunId, NodeIds) {
  op <- new_operation(
    name = "ResumeWorkflowRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$resume_workflow_run_input(Name = Name, RunId = RunId, NodeIds = NodeIds)
  output <- .glue$resume_workflow_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$resume_workflow_run <- glue_resume_workflow_run

#' Executes the statement
#'
#' @description
#' Executes the statement.
#'
#' @usage
#' glue_run_statement(SessionId, Code, RequestOrigin)
#'
#' @param SessionId &#91;required&#93; The Session Id of the statement to be run.
#' @param Code &#91;required&#93; The statement code to be run.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Id = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$run_statement(
#'   SessionId = "string",
#'   Code = "string",
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_run_statement
#'
#' @aliases glue_run_statement
glue_run_statement <- function(SessionId, Code, RequestOrigin = NULL) {
  op <- new_operation(
    name = "RunStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$run_statement_input(SessionId = SessionId, Code = Code, RequestOrigin = RequestOrigin)
  output <- .glue$run_statement_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$run_statement <- glue_run_statement

#' Searches a set of tables based on properties in the table metadata as
#' well as on the parent database
#'
#' @description
#' Searches a set of tables based on properties in the table metadata as
#' well as on the parent database. You can search against text or filter
#' conditions.
#' 
#' You can only get tables that you have access to based on the security
#' policies defined in Lake Formation. You need at least a read-only access
#' to the table for it to be returned. If you do not have access to all the
#' columns in the table, these columns will not be searched against when
#' returning the list of tables back to you. If you have access to the
#' columns but not the data in the columns, those columns and the
#' associated metadata for those columns will be included in the search.
#'
#' @usage
#' glue_search_tables(CatalogId, NextToken, Filters, SearchText,
#'   SortCriteria, MaxResults, ResourceShareType, IncludeStatusDetails)
#'
#' @param CatalogId A unique identifier, consisting of ` account_id `.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param Filters A list of key-value pairs, and a comparator used to filter the search
#' results. Returns all entities matching the predicate.
#' 
#' The `Comparator` member of the `PropertyPredicate` struct is used only
#' for time fields, and can be omitted for other field types. Also, when
#' comparing string values, such as when `Key=Name`, a fuzzy match
#' algorithm is used. The `Key` field (for example, the value of the `Name`
#' field) is split on certain punctuation characters, for example, -, :,
#' #, etc. into tokens. Then each token is exact-match compared with the
#' `Value` member of `PropertyPredicate`. For example, if `Key=Name` and
#' `Value=link`, tables named `customer-link` and `xx-link-yy` are
#' returned, but `xxlinkyy` is not returned.
#' @param SearchText A string used for a text search.
#' 
#' Specifying a value in quotes filters based on an exact match to the
#' value.
#' @param SortCriteria A list of criteria for sorting the results by a field name, in an
#' ascending or descending order.
#' @param MaxResults The maximum number of tables to return in a single response.
#' @param ResourceShareType Allows you to specify that you want to search the tables shared with
#' your account. The allowable values are `FOREIGN` or `ALL`.
#' 
#' -   If set to `FOREIGN`, will search the tables shared with your
#'     account.
#' 
#' -   If set to `ALL`, will search the tables shared with your account, as
#'     well as the tables in yor local account.
#' @param IncludeStatusDetails Specifies whether to include status details related to a request to
#' create or update an Glue Data Catalog view.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   TableList = list(
#'     list(
#'       Name = "string",
#'       DatabaseName = "string",
#'       Description = "string",
#'       Owner = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       UpdateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Retention = 123,
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string",
#'             Parameters = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Location = "string",
#'         AdditionalLocations = list(
#'           "string"
#'         ),
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE,
#'         SchemaReference = list(
#'           SchemaId = list(
#'             SchemaArn = "string",
#'             SchemaName = "string",
#'             RegistryName = "string"
#'           ),
#'           SchemaVersionId = "string",
#'           SchemaVersionNumber = 123
#'         )
#'       ),
#'       PartitionKeys = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ViewOriginalText = "string",
#'       ViewExpandedText = "string",
#'       TableType = "string",
#'       Parameters = list(
#'         "string"
#'       ),
#'       CreatedBy = "string",
#'       IsRegisteredWithLakeFormation = TRUE|FALSE,
#'       TargetTable = list(
#'         CatalogId = "string",
#'         DatabaseName = "string",
#'         Name = "string",
#'         Region = "string"
#'       ),
#'       CatalogId = "string",
#'       VersionId = "string",
#'       FederatedTable = list(
#'         Identifier = "string",
#'         DatabaseIdentifier = "string",
#'         ConnectionName = "string"
#'       ),
#'       ViewDefinition = list(
#'         IsProtected = TRUE|FALSE,
#'         Definer = "string",
#'         SubObjects = list(
#'           "string"
#'         ),
#'         Representations = list(
#'           list(
#'             Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'             DialectVersion = "string",
#'             ViewOriginalText = "string",
#'             ViewExpandedText = "string",
#'             ValidationConnection = "string",
#'             IsStale = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       IsMultiDialectView = TRUE|FALSE,
#'       Status = list(
#'         RequestedBy = "string",
#'         UpdatedBy = "string",
#'         RequestTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         UpdateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Action = "UPDATE"|"CREATE",
#'         State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'         Error = list(
#'           ErrorCode = "string",
#'           ErrorMessage = "string"
#'         ),
#'         Details = list(
#'           RequestedChange = list(),
#'           ViewValidations = list(
#'             list(
#'               Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'               DialectVersion = "string",
#'               ViewValidationText = "string",
#'               UpdateTime = as.POSIXct(
#'                 "2015-01-01"
#'               ),
#'               State = "QUEUED"|"IN_PROGRESS"|"SUCCESS"|"STOPPED"|"FAILED",
#'               Error = list(
#'                 ErrorCode = "string",
#'                 ErrorMessage = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_tables(
#'   CatalogId = "string",
#'   NextToken = "string",
#'   Filters = list(
#'     list(
#'       Key = "string",
#'       Value = "string",
#'       Comparator = "EQUALS"|"GREATER_THAN"|"LESS_THAN"|"GREATER_THAN_EQUALS"|"LESS_THAN_EQUALS"
#'     )
#'   ),
#'   SearchText = "string",
#'   SortCriteria = list(
#'     list(
#'       FieldName = "string",
#'       Sort = "ASC"|"DESC"
#'     )
#'   ),
#'   MaxResults = 123,
#'   ResourceShareType = "FOREIGN"|"ALL"|"FEDERATED",
#'   IncludeStatusDetails = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_search_tables
#'
#' @aliases glue_search_tables
glue_search_tables <- function(CatalogId = NULL, NextToken = NULL, Filters = NULL, SearchText = NULL, SortCriteria = NULL, MaxResults = NULL, ResourceShareType = NULL, IncludeStatusDetails = NULL) {
  op <- new_operation(
    name = "SearchTables",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .glue$search_tables_input(CatalogId = CatalogId, NextToken = NextToken, Filters = Filters, SearchText = SearchText, SortCriteria = SortCriteria, MaxResults = MaxResults, ResourceShareType = ResourceShareType, IncludeStatusDetails = IncludeStatusDetails)
  output <- .glue$search_tables_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$search_tables <- glue_search_tables

#' Starts a new run of the specified blueprint
#'
#' @description
#' Starts a new run of the specified blueprint.
#'
#' @usage
#' glue_start_blueprint_run(BlueprintName, Parameters, RoleArn)
#'
#' @param BlueprintName &#91;required&#93; The name of the blueprint.
#' @param Parameters Specifies the parameters as a `BlueprintParameters` object.
#' @param RoleArn &#91;required&#93; Specifies the IAM role used to create the workflow.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_blueprint_run(
#'   BlueprintName = "string",
#'   Parameters = "string",
#'   RoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_blueprint_run
#'
#' @aliases glue_start_blueprint_run
glue_start_blueprint_run <- function(BlueprintName, Parameters = NULL, RoleArn) {
  op <- new_operation(
    name = "StartBlueprintRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_blueprint_run_input(BlueprintName = BlueprintName, Parameters = Parameters, RoleArn = RoleArn)
  output <- .glue$start_blueprint_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_blueprint_run <- glue_start_blueprint_run

#' Starts a column statistics task run, for a specified table and columns
#'
#' @description
#' Starts a column statistics task run, for a specified table and columns.
#'
#' @usage
#' glue_start_column_statistics_task_run(DatabaseName, TableName,
#'   ColumnNameList, Role, SampleSize, CatalogID, SecurityConfiguration)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table to generate statistics.
#' @param ColumnNameList A list of the column names to generate statistics. If none is supplied,
#' all column names for the table will be used by default.
#' @param Role &#91;required&#93; The IAM role that the service assumes to generate statistics.
#' @param SampleSize The percentage of rows used to generate statistics. If none is supplied,
#' the entire table will be used to generate stats.
#' @param CatalogID The ID of the Data Catalog where the table reside. If none is supplied,
#' the Amazon Web Services account ID is used by default.
#' @param SecurityConfiguration Name of the security configuration that is used to encrypt CloudWatch
#' logs for the column stats task run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ColumnStatisticsTaskRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_column_statistics_task_run(
#'   DatabaseName = "string",
#'   TableName = "string",
#'   ColumnNameList = list(
#'     "string"
#'   ),
#'   Role = "string",
#'   SampleSize = 123.0,
#'   CatalogID = "string",
#'   SecurityConfiguration = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_column_statistics_task_run
#'
#' @aliases glue_start_column_statistics_task_run
glue_start_column_statistics_task_run <- function(DatabaseName, TableName, ColumnNameList = NULL, Role, SampleSize = NULL, CatalogID = NULL, SecurityConfiguration = NULL) {
  op <- new_operation(
    name = "StartColumnStatisticsTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_column_statistics_task_run_input(DatabaseName = DatabaseName, TableName = TableName, ColumnNameList = ColumnNameList, Role = Role, SampleSize = SampleSize, CatalogID = CatalogID, SecurityConfiguration = SecurityConfiguration)
  output <- .glue$start_column_statistics_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_column_statistics_task_run <- glue_start_column_statistics_task_run

#' Starts a column statistics task run schedule
#'
#' @description
#' Starts a column statistics task run schedule.
#'
#' @usage
#' glue_start_column_statistics_task_run_schedule(DatabaseName, TableName)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to start a column statistic task run
#' schedule.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_column_statistics_task_run_schedule(
#'   DatabaseName = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_column_statistics_task_run_schedule
#'
#' @aliases glue_start_column_statistics_task_run_schedule
glue_start_column_statistics_task_run_schedule <- function(DatabaseName, TableName) {
  op <- new_operation(
    name = "StartColumnStatisticsTaskRunSchedule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_column_statistics_task_run_schedule_input(DatabaseName = DatabaseName, TableName = TableName)
  output <- .glue$start_column_statistics_task_run_schedule_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_column_statistics_task_run_schedule <- glue_start_column_statistics_task_run_schedule

#' Starts a crawl using the specified crawler, regardless of what is
#' scheduled
#'
#' @description
#' Starts a crawl using the specified crawler, regardless of what is
#' scheduled. If the crawler is already running, returns a
#' [CrawlerRunningException](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-exceptions.html#aws-glue-api-exceptions-CrawlerRunningException).
#'
#' @usage
#' glue_start_crawler(Name)
#'
#' @param Name &#91;required&#93; Name of the crawler to start.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_crawler
#'
#' @aliases glue_start_crawler
glue_start_crawler <- function(Name) {
  op <- new_operation(
    name = "StartCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_crawler_input(Name = Name)
  output <- .glue$start_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_crawler <- glue_start_crawler

#' Changes the schedule state of the specified crawler to SCHEDULED, unless
#' the crawler is already running or the schedule state is already
#' SCHEDULED
#'
#' @description
#' Changes the schedule state of the specified crawler to `SCHEDULED`,
#' unless the crawler is already running or the schedule state is already
#' `SCHEDULED`.
#'
#' @usage
#' glue_start_crawler_schedule(CrawlerName)
#'
#' @param CrawlerName &#91;required&#93; Name of the crawler to schedule.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_crawler_schedule(
#'   CrawlerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_crawler_schedule
#'
#' @aliases glue_start_crawler_schedule
glue_start_crawler_schedule <- function(CrawlerName) {
  op <- new_operation(
    name = "StartCrawlerSchedule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_crawler_schedule_input(CrawlerName = CrawlerName)
  output <- .glue$start_crawler_schedule_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_crawler_schedule <- glue_start_crawler_schedule

#' Starts a recommendation run that is used to generate rules when you
#' don't know what rules to write
#'
#' @description
#' Starts a recommendation run that is used to generate rules when you
#' don't know what rules to write. Glue Data Quality analyzes the data and
#' comes up with recommendations for a potential ruleset. You can then
#' triage the ruleset and modify the generated ruleset to your liking.
#' 
#' Recommendation runs are automatically deleted after 90 days.
#'
#' @usage
#' glue_start_data_quality_rule_recommendation_run(DataSource, Role,
#'   NumberOfWorkers, Timeout, CreatedRulesetName,
#'   DataQualitySecurityConfiguration, ClientToken)
#'
#' @param DataSource &#91;required&#93; The data source (Glue table) associated with this run.
#' @param Role &#91;required&#93; An IAM role supplied to encrypt the results of the run.
#' @param NumberOfWorkers The number of `G.1X` workers to be used in the run. The default is 5.
#' @param Timeout The timeout for a run in minutes. This is the maximum time that a run
#' can consume resources before it is terminated and enters `TIMEOUT`
#' status. The default is 2,880 minutes (48 hours).
#' @param CreatedRulesetName A name for the ruleset.
#' @param DataQualitySecurityConfiguration The name of the security configuration created with the data quality
#' encryption option.
#' @param ClientToken Used for idempotency and is recommended to be set to a random ID (such
#' as a UUID) to avoid creating or starting multiple instances of the same
#' resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_data_quality_rule_recommendation_run(
#'   DataSource = list(
#'     GlueTable = list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Role = "string",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   CreatedRulesetName = "string",
#'   DataQualitySecurityConfiguration = "string",
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_data_quality_rule_recommendation_run
#'
#' @aliases glue_start_data_quality_rule_recommendation_run
glue_start_data_quality_rule_recommendation_run <- function(DataSource, Role, NumberOfWorkers = NULL, Timeout = NULL, CreatedRulesetName = NULL, DataQualitySecurityConfiguration = NULL, ClientToken = NULL) {
  op <- new_operation(
    name = "StartDataQualityRuleRecommendationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_data_quality_rule_recommendation_run_input(DataSource = DataSource, Role = Role, NumberOfWorkers = NumberOfWorkers, Timeout = Timeout, CreatedRulesetName = CreatedRulesetName, DataQualitySecurityConfiguration = DataQualitySecurityConfiguration, ClientToken = ClientToken)
  output <- .glue$start_data_quality_rule_recommendation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_data_quality_rule_recommendation_run <- glue_start_data_quality_rule_recommendation_run

#' Once you have a ruleset definition (either recommended or your own), you
#' call this operation to evaluate the ruleset against a data source (Glue
#' table)
#'
#' @description
#' Once you have a ruleset definition (either recommended or your own), you
#' call this operation to evaluate the ruleset against a data source (Glue
#' table). The evaluation computes results which you can retrieve with the
#' [`get_data_quality_result`][glue_get_data_quality_result] API.
#'
#' @usage
#' glue_start_data_quality_ruleset_evaluation_run(DataSource, Role,
#'   NumberOfWorkers, Timeout, ClientToken, AdditionalRunOptions,
#'   RulesetNames, AdditionalDataSources)
#'
#' @param DataSource &#91;required&#93; The data source (Glue table) associated with this run.
#' @param Role &#91;required&#93; An IAM role supplied to encrypt the results of the run.
#' @param NumberOfWorkers The number of `G.1X` workers to be used in the run. The default is 5.
#' @param Timeout The timeout for a run in minutes. This is the maximum time that a run
#' can consume resources before it is terminated and enters `TIMEOUT`
#' status. The default is 2,880 minutes (48 hours).
#' @param ClientToken Used for idempotency and is recommended to be set to a random ID (such
#' as a UUID) to avoid creating or starting multiple instances of the same
#' resource.
#' @param AdditionalRunOptions Additional run options you can specify for an evaluation run.
#' @param RulesetNames &#91;required&#93; A list of ruleset names.
#' @param AdditionalDataSources A map of reference strings to additional data sources you can specify
#' for an evaluation run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_data_quality_ruleset_evaluation_run(
#'   DataSource = list(
#'     GlueTable = list(
#'       DatabaseName = "string",
#'       TableName = "string",
#'       CatalogId = "string",
#'       ConnectionName = "string",
#'       AdditionalOptions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   Role = "string",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   ClientToken = "string",
#'   AdditionalRunOptions = list(
#'     CloudWatchMetricsEnabled = TRUE|FALSE,
#'     ResultsS3Prefix = "string",
#'     CompositeRuleEvaluationMethod = "COLUMN"|"ROW"
#'   ),
#'   RulesetNames = list(
#'     "string"
#'   ),
#'   AdditionalDataSources = list(
#'     list(
#'       GlueTable = list(
#'         DatabaseName = "string",
#'         TableName = "string",
#'         CatalogId = "string",
#'         ConnectionName = "string",
#'         AdditionalOptions = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_data_quality_ruleset_evaluation_run
#'
#' @aliases glue_start_data_quality_ruleset_evaluation_run
glue_start_data_quality_ruleset_evaluation_run <- function(DataSource, Role, NumberOfWorkers = NULL, Timeout = NULL, ClientToken = NULL, AdditionalRunOptions = NULL, RulesetNames, AdditionalDataSources = NULL) {
  op <- new_operation(
    name = "StartDataQualityRulesetEvaluationRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_data_quality_ruleset_evaluation_run_input(DataSource = DataSource, Role = Role, NumberOfWorkers = NumberOfWorkers, Timeout = Timeout, ClientToken = ClientToken, AdditionalRunOptions = AdditionalRunOptions, RulesetNames = RulesetNames, AdditionalDataSources = AdditionalDataSources)
  output <- .glue$start_data_quality_ruleset_evaluation_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_data_quality_ruleset_evaluation_run <- glue_start_data_quality_ruleset_evaluation_run

#' Begins an asynchronous task to export all labeled data for a particular
#' transform
#'
#' @description
#' Begins an asynchronous task to export all labeled data for a particular
#' transform. This task is the only label-related API call that is not part
#' of the typical active learning workflow. You typically use
#' [`start_export_labels_task_run`][glue_start_export_labels_task_run] when
#' you want to work with all of your existing labels at the same time, such
#' as when you want to remove or change labels that were previously
#' submitted as truth. This API operation accepts the `TransformId` whose
#' labels you want to export and an Amazon Simple Storage Service (Amazon
#' S3) path to export the labels to. The operation returns a `TaskRunId`.
#' You can check on the status of your task run by calling the
#' [`get_ml_task_run`][glue_get_ml_task_run] API.
#'
#' @usage
#' glue_start_export_labels_task_run(TransformId, OutputS3Path)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param OutputS3Path &#91;required&#93; The Amazon S3 path where you export the labels.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_export_labels_task_run(
#'   TransformId = "string",
#'   OutputS3Path = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_export_labels_task_run
#'
#' @aliases glue_start_export_labels_task_run
glue_start_export_labels_task_run <- function(TransformId, OutputS3Path) {
  op <- new_operation(
    name = "StartExportLabelsTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_export_labels_task_run_input(TransformId = TransformId, OutputS3Path = OutputS3Path)
  output <- .glue$start_export_labels_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_export_labels_task_run <- glue_start_export_labels_task_run

#' Enables you to provide additional labels (examples of truth) to be used
#' to teach the machine learning transform and improve its quality
#'
#' @description
#' Enables you to provide additional labels (examples of truth) to be used
#' to teach the machine learning transform and improve its quality. This
#' API operation is generally used as part of the active learning workflow
#' that starts with the
#' [`start_ml_labeling_set_generation_task_run`][glue_start_ml_labeling_set_generation_task_run]
#' call and that ultimately results in improving the quality of your
#' machine learning transform.
#' 
#' After the
#' [`start_ml_labeling_set_generation_task_run`][glue_start_ml_labeling_set_generation_task_run]
#' finishes, Glue machine learning will have generated a series of
#' questions for humans to answer. (Answering these questions is often
#' called 'labeling' in the machine learning workflows). In the case of the
#' `FindMatches` transform, these questions are of the form, “What is the
#' correct way to group these rows together into groups composed entirely
#' of matching records?” After the labeling process is finished, users
#' upload their answers/labels with a call to
#' [`start_import_labels_task_run`][glue_start_import_labels_task_run].
#' After
#' [`start_import_labels_task_run`][glue_start_import_labels_task_run]
#' finishes, all future runs of the machine learning transform use the new
#' and improved labels and perform a higher-quality transformation.
#' 
#' By default,
#' [`start_ml_labeling_set_generation_task_run`][glue_start_ml_labeling_set_generation_task_run]
#' continually learns from and combines all labels that you upload unless
#' you set `Replace` to true. If you set `Replace` to true,
#' [`start_import_labels_task_run`][glue_start_import_labels_task_run]
#' deletes and forgets all previously uploaded labels and learns only from
#' the exact set that you upload. Replacing labels can be helpful if you
#' realize that you previously uploaded incorrect labels, and you believe
#' that they are having a negative effect on your transform quality.
#' 
#' You can check on the status of your task run by calling the
#' [`get_ml_task_run`][glue_get_ml_task_run] operation.
#'
#' @usage
#' glue_start_import_labels_task_run(TransformId, InputS3Path,
#'   ReplaceAllLabels)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param InputS3Path &#91;required&#93; The Amazon Simple Storage Service (Amazon S3) path from where you import
#' the labels.
#' @param ReplaceAllLabels Indicates whether to overwrite your existing labels.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_import_labels_task_run(
#'   TransformId = "string",
#'   InputS3Path = "string",
#'   ReplaceAllLabels = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_import_labels_task_run
#'
#' @aliases glue_start_import_labels_task_run
glue_start_import_labels_task_run <- function(TransformId, InputS3Path, ReplaceAllLabels = NULL) {
  op <- new_operation(
    name = "StartImportLabelsTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_import_labels_task_run_input(TransformId = TransformId, InputS3Path = InputS3Path, ReplaceAllLabels = ReplaceAllLabels)
  output <- .glue$start_import_labels_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_import_labels_task_run <- glue_start_import_labels_task_run

#' Starts a job run using a job definition
#'
#' @description
#' Starts a job run using a job definition.
#'
#' @usage
#' glue_start_job_run(JobName, JobRunQueuingEnabled, JobRunId, Arguments,
#'   AllocatedCapacity, Timeout, MaxCapacity, SecurityConfiguration,
#'   NotificationProperty, WorkerType, NumberOfWorkers, ExecutionClass)
#'
#' @param JobName &#91;required&#93; The name of the job definition to use.
#' @param JobRunQueuingEnabled Specifies whether job run queuing is enabled for the job run.
#' 
#' A value of true means job run queuing is enabled for the job run. If
#' false or not populated, the job run will not be considered for queueing.
#' @param JobRunId The ID of a previous `JobRun` to retry.
#' @param Arguments The job arguments associated with this run. For this job run, they
#' replace the default arguments set in the job definition itself.
#' 
#' You can specify arguments here that your own job-execution script
#' consumes, as well as arguments that Glue itself consumes.
#' 
#' Job arguments may be logged. Do not pass plaintext secrets as arguments.
#' Retrieve secrets from a Glue Connection, Secrets Manager or other secret
#' management mechanism if you intend to keep them within the Job.
#' 
#' For information about how to specify and consume your own Job arguments,
#' see the [Calling Glue APIs in
#' Python](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html)
#' topic in the developer guide.
#' 
#' For information about the arguments you can provide to this field when
#' configuring Spark jobs, see the [Special Parameters Used by
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html)
#' topic in the developer guide.
#' 
#' For information about the arguments you can provide to this field when
#' configuring Ray jobs, see [Using job parameters in Ray
#' jobs](https://docs.aws.amazon.com/glue/latest/dg/author-job-ray-job-parameters.html)
#' in the developer guide.
#' @param AllocatedCapacity This field is deprecated. Use `MaxCapacity` instead.
#' 
#' The number of Glue data processing units (DPUs) to allocate to this
#' JobRun. You can allocate a minimum of 2 DPUs; the default is 10. A DPU
#' is a relative measure of processing power that consists of 4 vCPUs of
#' compute capacity and 16 GB of memory. For more information, see the
#' [Glue pricing page](https://aws.amazon.com/glue/pricing/).
#' @param Timeout The `JobRun` timeout in minutes. This is the maximum time that a job run
#' can consume resources before it is terminated and enters `TIMEOUT`
#' status. This value overrides the timeout value set in the parent job.
#' 
#' Jobs must have timeout values less than 7 days or 10080 minutes.
#' Otherwise, the jobs will throw an exception.
#' 
#' When the value is left blank, the timeout is defaulted to 2880 minutes.
#' 
#' Any existing Glue jobs that had a timeout value greater than 7 days will
#' be defaulted to 7 days. For instance if you have specified a timeout of
#' 20 days for a batch job, it will be stopped on the 7th day.
#' @param MaxCapacity For Glue version 1.0 or earlier jobs, using the standard worker type,
#' the number of Glue data processing units (DPUs) that can be allocated
#' when this job runs. A DPU is a relative measure of processing power that
#' consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
#' information, see the [Glue pricing
#' page](https://aws.amazon.com/glue/pricing/).
#' 
#' For Glue version 2.0+ jobs, you cannot specify a `Maximum capacity`.
#' Instead, you should specify a `Worker type` and the `Number of workers`.
#' 
#' Do not set `MaxCapacity` if using `WorkerType` and `NumberOfWorkers`.
#' 
#' The value that can be allocated for `MaxCapacity` depends on whether you
#' are running a Python shell job, an Apache Spark ETL job, or an Apache
#' Spark streaming ETL job:
#' 
#' -   When you specify a Python shell job
#'     (`JobCommand.Name`="pythonshell"), you can allocate either 0.0625 or
#'     1 DPU. The default is 0.0625 DPU.
#' 
#' -   When you specify an Apache Spark ETL job
#'     (`JobCommand.Name`="glueetl") or Apache Spark streaming ETL job
#'     (`JobCommand.Name`="gluestreaming"), you can allocate from 2 to 100
#'     DPUs. The default is 10 DPUs. This job type cannot have a fractional
#'     DPU allocation.
#' @param SecurityConfiguration The name of the `SecurityConfiguration` structure to be used with this
#' job run.
#' @param NotificationProperty Specifies configuration properties of a job run notification.
#' @param WorkerType The type of predefined worker that is allocated when a job runs. Accepts
#' a value of G.1X, G.2X, G.4X, G.8X or G.025X for Spark jobs. Accepts the
#' value Z.2X for Ray jobs.
#' 
#' -   For the `G.1X` worker type, each worker maps to 1 DPU (4 vCPUs, 16
#'     GB of memory) with 94GB disk, and provides 1 executor per worker. We
#'     recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.2X` worker type, each worker maps to 2 DPU (8 vCPUs, 32
#'     GB of memory) with 138GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for workloads such as data transforms,
#'     joins, and queries, to offers a scalable and cost effective way to
#'     run most jobs.
#' 
#' -   For the `G.4X` worker type, each worker maps to 4 DPU (16 vCPUs, 64
#'     GB of memory) with 256GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs in the following Amazon Web Services Regions: US East
#'     (Ohio), US East (N. Virginia), US West (Oregon), Asia Pacific
#'     (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada
#'     (Central), Europe (Frankfurt), Europe (Ireland), and Europe
#'     (Stockholm).
#' 
#' -   For the `G.8X` worker type, each worker maps to 8 DPU (32 vCPUs, 128
#'     GB of memory) with 512GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for jobs whose workloads contain your
#'     most demanding transforms, aggregations, joins, and queries. This
#'     worker type is available only for Glue version 3.0 or later Spark
#'     ETL jobs, in the same Amazon Web Services Regions as supported for
#'     the `G.4X` worker type.
#' 
#' -   For the `G.025X` worker type, each worker maps to 0.25 DPU (2 vCPUs,
#'     4 GB of memory) with 84GB disk, and provides 1 executor per worker.
#'     We recommend this worker type for low volume streaming jobs. This
#'     worker type is only available for Glue version 3.0 or later
#'     streaming jobs.
#' 
#' -   For the `Z.2X` worker type, each worker maps to 2 M-DPU (8vCPUs, 64
#'     GB of memory) with 128 GB disk, and provides up to 8 Ray workers
#'     based on the autoscaler.
#' @param NumberOfWorkers The number of workers of a defined `workerType` that are allocated when
#' a job runs.
#' @param ExecutionClass Indicates whether the job is run with a standard or flexible execution
#' class. The standard execution-class is ideal for time-sensitive
#' workloads that require fast job startup and dedicated resources.
#' 
#' The flexible execution class is appropriate for time-insensitive jobs
#' whose start and completion times may vary.
#' 
#' Only jobs with Glue version 3.0 and above and command type `glueetl`
#' will be allowed to set `ExecutionClass` to `FLEX`. The flexible
#' execution class is available for Spark jobs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   JobName = "string",
#'   JobRunQueuingEnabled = TRUE|FALSE,
#'   JobRunId = "string",
#'   Arguments = list(
#'     "string"
#'   ),
#'   AllocatedCapacity = 123,
#'   Timeout = 123,
#'   MaxCapacity = 123.0,
#'   SecurityConfiguration = "string",
#'   NotificationProperty = list(
#'     NotifyDelayAfter = 123
#'   ),
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   NumberOfWorkers = 123,
#'   ExecutionClass = "FLEX"|"STANDARD"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_job_run
#'
#' @aliases glue_start_job_run
glue_start_job_run <- function(JobName, JobRunQueuingEnabled = NULL, JobRunId = NULL, Arguments = NULL, AllocatedCapacity = NULL, Timeout = NULL, MaxCapacity = NULL, SecurityConfiguration = NULL, NotificationProperty = NULL, WorkerType = NULL, NumberOfWorkers = NULL, ExecutionClass = NULL) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_job_run_input(JobName = JobName, JobRunQueuingEnabled = JobRunQueuingEnabled, JobRunId = JobRunId, Arguments = Arguments, AllocatedCapacity = AllocatedCapacity, Timeout = Timeout, MaxCapacity = MaxCapacity, SecurityConfiguration = SecurityConfiguration, NotificationProperty = NotificationProperty, WorkerType = WorkerType, NumberOfWorkers = NumberOfWorkers, ExecutionClass = ExecutionClass)
  output <- .glue$start_job_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_job_run <- glue_start_job_run

#' Starts a task to estimate the quality of the transform
#'
#' @description
#' Starts a task to estimate the quality of the transform.
#' 
#' When you provide label sets as examples of truth, Glue machine learning
#' uses some of those examples to learn from them. The rest of the labels
#' are used as a test to estimate quality.
#' 
#' Returns a unique identifier for the run. You can call
#' [`get_ml_task_run`][glue_get_ml_task_run] to get more information about
#' the stats of the `EvaluationTaskRun`.
#'
#' @usage
#' glue_start_ml_evaluation_task_run(TransformId)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_ml_evaluation_task_run(
#'   TransformId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_ml_evaluation_task_run
#'
#' @aliases glue_start_ml_evaluation_task_run
glue_start_ml_evaluation_task_run <- function(TransformId) {
  op <- new_operation(
    name = "StartMLEvaluationTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_ml_evaluation_task_run_input(TransformId = TransformId)
  output <- .glue$start_ml_evaluation_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_ml_evaluation_task_run <- glue_start_ml_evaluation_task_run

#' Starts the active learning workflow for your machine learning transform
#' to improve the transform's quality by generating label sets and adding
#' labels
#'
#' @description
#' Starts the active learning workflow for your machine learning transform
#' to improve the transform's quality by generating label sets and adding
#' labels.
#' 
#' When the
#' [`start_ml_labeling_set_generation_task_run`][glue_start_ml_labeling_set_generation_task_run]
#' finishes, Glue will have generated a "labeling set" or a set of
#' questions for humans to answer.
#' 
#' In the case of the `FindMatches` transform, these questions are of the
#' form, “What is the correct way to group these rows together into groups
#' composed entirely of matching records?”
#' 
#' After the labeling process is finished, you can upload your labels with
#' a call to
#' [`start_import_labels_task_run`][glue_start_import_labels_task_run].
#' After
#' [`start_import_labels_task_run`][glue_start_import_labels_task_run]
#' finishes, all future runs of the machine learning transform will use the
#' new and improved labels and perform a higher-quality transformation.
#'
#' @usage
#' glue_start_ml_labeling_set_generation_task_run(TransformId,
#'   OutputS3Path)
#'
#' @param TransformId &#91;required&#93; The unique identifier of the machine learning transform.
#' @param OutputS3Path &#91;required&#93; The Amazon Simple Storage Service (Amazon S3) path where you generate
#' the labeling set.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TaskRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_ml_labeling_set_generation_task_run(
#'   TransformId = "string",
#'   OutputS3Path = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_ml_labeling_set_generation_task_run
#'
#' @aliases glue_start_ml_labeling_set_generation_task_run
glue_start_ml_labeling_set_generation_task_run <- function(TransformId, OutputS3Path) {
  op <- new_operation(
    name = "StartMLLabelingSetGenerationTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_ml_labeling_set_generation_task_run_input(TransformId = TransformId, OutputS3Path = OutputS3Path)
  output <- .glue$start_ml_labeling_set_generation_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_ml_labeling_set_generation_task_run <- glue_start_ml_labeling_set_generation_task_run

#' Starts an existing trigger
#'
#' @description
#' Starts an existing trigger. See [Triggering
#' Jobs](https://docs.aws.amazon.com/glue/latest/dg/trigger-job.html) for
#' information about how different types of trigger are started.
#'
#' @usage
#' glue_start_trigger(Name)
#'
#' @param Name &#91;required&#93; The name of the trigger to start.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_trigger
#'
#' @aliases glue_start_trigger
glue_start_trigger <- function(Name) {
  op <- new_operation(
    name = "StartTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_trigger_input(Name = Name)
  output <- .glue$start_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_trigger <- glue_start_trigger

#' Starts a new run of the specified workflow
#'
#' @description
#' Starts a new run of the specified workflow.
#'
#' @usage
#' glue_start_workflow_run(Name, RunProperties)
#'
#' @param Name &#91;required&#93; The name of the workflow to start.
#' @param RunProperties The workflow run properties for the new workflow run.
#' 
#' Run properties may be logged. Do not pass plaintext secrets as
#' properties. Retrieve secrets from a Glue Connection, Amazon Web Services
#' Secrets Manager or other secret management mechanism if you intend to
#' use them within the workflow run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_workflow_run(
#'   Name = "string",
#'   RunProperties = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_start_workflow_run
#'
#' @aliases glue_start_workflow_run
glue_start_workflow_run <- function(Name, RunProperties = NULL) {
  op <- new_operation(
    name = "StartWorkflowRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$start_workflow_run_input(Name = Name, RunProperties = RunProperties)
  output <- .glue$start_workflow_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$start_workflow_run <- glue_start_workflow_run

#' Stops a task run for the specified table
#'
#' @description
#' Stops a task run for the specified table.
#'
#' @usage
#' glue_stop_column_statistics_task_run(DatabaseName, TableName)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_column_statistics_task_run(
#'   DatabaseName = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_column_statistics_task_run
#'
#' @aliases glue_stop_column_statistics_task_run
glue_stop_column_statistics_task_run <- function(DatabaseName, TableName) {
  op <- new_operation(
    name = "StopColumnStatisticsTaskRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_column_statistics_task_run_input(DatabaseName = DatabaseName, TableName = TableName)
  output <- .glue$stop_column_statistics_task_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_column_statistics_task_run <- glue_stop_column_statistics_task_run

#' Stops a column statistics task run schedule
#'
#' @description
#' Stops a column statistics task run schedule.
#'
#' @usage
#' glue_stop_column_statistics_task_run_schedule(DatabaseName, TableName)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to stop a column statistic task run
#' schedule.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_column_statistics_task_run_schedule(
#'   DatabaseName = "string",
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_column_statistics_task_run_schedule
#'
#' @aliases glue_stop_column_statistics_task_run_schedule
glue_stop_column_statistics_task_run_schedule <- function(DatabaseName, TableName) {
  op <- new_operation(
    name = "StopColumnStatisticsTaskRunSchedule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_column_statistics_task_run_schedule_input(DatabaseName = DatabaseName, TableName = TableName)
  output <- .glue$stop_column_statistics_task_run_schedule_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_column_statistics_task_run_schedule <- glue_stop_column_statistics_task_run_schedule

#' If the specified crawler is running, stops the crawl
#'
#' @description
#' If the specified crawler is running, stops the crawl.
#'
#' @usage
#' glue_stop_crawler(Name)
#'
#' @param Name &#91;required&#93; Name of the crawler to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_crawler
#'
#' @aliases glue_stop_crawler
glue_stop_crawler <- function(Name) {
  op <- new_operation(
    name = "StopCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_crawler_input(Name = Name)
  output <- .glue$stop_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_crawler <- glue_stop_crawler

#' Sets the schedule state of the specified crawler to NOT_SCHEDULED, but
#' does not stop the crawler if it is already running
#'
#' @description
#' Sets the schedule state of the specified crawler to `NOT_SCHEDULED`, but
#' does not stop the crawler if it is already running.
#'
#' @usage
#' glue_stop_crawler_schedule(CrawlerName)
#'
#' @param CrawlerName &#91;required&#93; Name of the crawler whose schedule state to set.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_crawler_schedule(
#'   CrawlerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_crawler_schedule
#'
#' @aliases glue_stop_crawler_schedule
glue_stop_crawler_schedule <- function(CrawlerName) {
  op <- new_operation(
    name = "StopCrawlerSchedule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_crawler_schedule_input(CrawlerName = CrawlerName)
  output <- .glue$stop_crawler_schedule_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_crawler_schedule <- glue_stop_crawler_schedule

#' Stops the session
#'
#' @description
#' Stops the session.
#'
#' @usage
#' glue_stop_session(Id, RequestOrigin)
#'
#' @param Id &#91;required&#93; The ID of the session to be stopped.
#' @param RequestOrigin The origin of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_session(
#'   Id = "string",
#'   RequestOrigin = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_session
#'
#' @aliases glue_stop_session
glue_stop_session <- function(Id, RequestOrigin = NULL) {
  op <- new_operation(
    name = "StopSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_session_input(Id = Id, RequestOrigin = RequestOrigin)
  output <- .glue$stop_session_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_session <- glue_stop_session

#' Stops a specified trigger
#'
#' @description
#' Stops a specified trigger.
#'
#' @usage
#' glue_stop_trigger(Name)
#'
#' @param Name &#91;required&#93; The name of the trigger to stop.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_trigger
#'
#' @aliases glue_stop_trigger
glue_stop_trigger <- function(Name) {
  op <- new_operation(
    name = "StopTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_trigger_input(Name = Name)
  output <- .glue$stop_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_trigger <- glue_stop_trigger

#' Stops the execution of the specified workflow run
#'
#' @description
#' Stops the execution of the specified workflow run.
#'
#' @usage
#' glue_stop_workflow_run(Name, RunId)
#'
#' @param Name &#91;required&#93; The name of the workflow to stop.
#' @param RunId &#91;required&#93; The ID of the workflow run to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_workflow_run(
#'   Name = "string",
#'   RunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_stop_workflow_run
#'
#' @aliases glue_stop_workflow_run
glue_stop_workflow_run <- function(Name, RunId) {
  op <- new_operation(
    name = "StopWorkflowRun",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$stop_workflow_run_input(Name = Name, RunId = RunId)
  output <- .glue$stop_workflow_run_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$stop_workflow_run <- glue_stop_workflow_run

#' Adds tags to a resource
#'
#' @description
#' Adds tags to a resource. A tag is a label you can assign to an Amazon
#' Web Services resource. In Glue, you can tag only certain resources. For
#' information about what resources you can tag, see [Amazon Web Services
#' Tags in
#' Glue](https://docs.aws.amazon.com/glue/latest/dg/monitor-tags.html).
#'
#' @usage
#' glue_tag_resource(ResourceArn, TagsToAdd)
#'
#' @param ResourceArn &#91;required&#93; The ARN of the Glue resource to which to add the tags. For more
#' information about Glue resource ARNs, see the [Glue ARN string
#' pattern](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-common.html#aws-glue-api-regex-aws-glue-arn-id).
#' @param TagsToAdd &#91;required&#93; Tags to add to this resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   TagsToAdd = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_tag_resource
#'
#' @aliases glue_tag_resource
glue_tag_resource <- function(ResourceArn, TagsToAdd) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$tag_resource_input(ResourceArn = ResourceArn, TagsToAdd = TagsToAdd)
  output <- .glue$tag_resource_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$tag_resource <- glue_tag_resource

#' Tests a connection to a service to validate the service credentials that
#' you provide
#'
#' @description
#' Tests a connection to a service to validate the service credentials that
#' you provide.
#' 
#' You can either provide an existing connection name or a
#' `TestConnectionInput` for testing a non-existing connection input.
#' Providing both at the same time will cause an error.
#' 
#' If the action is successful, the service sends back an HTTP 200
#' response.
#'
#' @usage
#' glue_test_connection(ConnectionName, CatalogId, TestConnectionInput)
#'
#' @param ConnectionName Optional. The name of the connection to test. If only name is provided,
#' the operation will get the connection and use that for testing.
#' @param CatalogId The catalog ID where the connection resides.
#' @param TestConnectionInput A structure that is used to specify testing a connection to a service.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$test_connection(
#'   ConnectionName = "string",
#'   CatalogId = "string",
#'   TestConnectionInput = list(
#'     ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     AuthenticationConfiguration = list(
#'       AuthenticationType = "BASIC"|"OAUTH2"|"CUSTOM"|"IAM",
#'       OAuth2Properties = list(
#'         OAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'         OAuth2ClientApplication = list(
#'           UserManagedClientApplicationClientId = "string",
#'           AWSManagedClientApplicationReference = "string"
#'         ),
#'         TokenUrl = "string",
#'         TokenUrlParametersMap = list(
#'           "string"
#'         ),
#'         AuthorizationCodeProperties = list(
#'           AuthorizationCode = "string",
#'           RedirectUri = "string"
#'         ),
#'         OAuth2Credentials = list(
#'           UserManagedClientApplicationClientSecret = "string",
#'           AccessToken = "string",
#'           RefreshToken = "string",
#'           JwtToken = "string"
#'         )
#'       ),
#'       SecretArn = "string",
#'       KmsKeyArn = "string",
#'       BasicAuthenticationCredentials = list(
#'         Username = "string",
#'         Password = "string"
#'       ),
#'       CustomAuthenticationCredentials = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_test_connection
#'
#' @aliases glue_test_connection
glue_test_connection <- function(ConnectionName = NULL, CatalogId = NULL, TestConnectionInput = NULL) {
  op <- new_operation(
    name = "TestConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$test_connection_input(ConnectionName = ConnectionName, CatalogId = CatalogId, TestConnectionInput = TestConnectionInput)
  output <- .glue$test_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$test_connection <- glue_test_connection

#' Removes tags from a resource
#'
#' @description
#' Removes tags from a resource.
#'
#' @usage
#' glue_untag_resource(ResourceArn, TagsToRemove)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource from which to remove the
#' tags.
#' @param TagsToRemove &#91;required&#93; Tags to remove from this resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagsToRemove = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_untag_resource
#'
#' @aliases glue_untag_resource
glue_untag_resource <- function(ResourceArn, TagsToRemove) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$untag_resource_input(ResourceArn = ResourceArn, TagsToRemove = TagsToRemove)
  output <- .glue$untag_resource_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$untag_resource <- glue_untag_resource

#' Updates a registered blueprint
#'
#' @description
#' Updates a registered blueprint.
#'
#' @usage
#' glue_update_blueprint(Name, Description, BlueprintLocation)
#'
#' @param Name &#91;required&#93; The name of the blueprint.
#' @param Description A description of the blueprint.
#' @param BlueprintLocation &#91;required&#93; Specifies a path in Amazon S3 where the blueprint is published.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_blueprint(
#'   Name = "string",
#'   Description = "string",
#'   BlueprintLocation = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_blueprint
#'
#' @aliases glue_update_blueprint
glue_update_blueprint <- function(Name, Description = NULL, BlueprintLocation) {
  op <- new_operation(
    name = "UpdateBlueprint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_blueprint_input(Name = Name, Description = Description, BlueprintLocation = BlueprintLocation)
  output <- .glue$update_blueprint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_blueprint <- glue_update_blueprint

#' Updates an existing catalog's properties in the Glue Data Catalog
#'
#' @description
#' Updates an existing catalog's properties in the Glue Data Catalog.
#'
#' @usage
#' glue_update_catalog(CatalogId, CatalogInput)
#'
#' @param CatalogId &#91;required&#93; The ID of the catalog.
#' @param CatalogInput &#91;required&#93; A `CatalogInput` object specifying the new properties of an existing
#' catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_catalog(
#'   CatalogId = "string",
#'   CatalogInput = list(
#'     Description = "string",
#'     FederatedCatalog = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     TargetRedshiftCatalog = list(
#'       CatalogArn = "string"
#'     ),
#'     CatalogProperties = list(
#'       DataLakeAccessProperties = list(
#'         DataLakeAccess = TRUE|FALSE,
#'         DataTransferRole = "string",
#'         KmsKey = "string",
#'         CatalogType = "string"
#'       ),
#'       CustomProperties = list(
#'         "string"
#'       )
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     CreateDatabaseDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_catalog
#'
#' @aliases glue_update_catalog
glue_update_catalog <- function(CatalogId, CatalogInput) {
  op <- new_operation(
    name = "UpdateCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_catalog_input(CatalogId = CatalogId, CatalogInput = CatalogInput)
  output <- .glue$update_catalog_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_catalog <- glue_update_catalog

#' Modifies an existing classifier (a GrokClassifier, an XMLClassifier, a
#' JsonClassifier, or a CsvClassifier, depending on which field is present)
#'
#' @description
#' Modifies an existing classifier (a `GrokClassifier`, an `XMLClassifier`,
#' a `JsonClassifier`, or a `CsvClassifier`, depending on which field is
#' present).
#'
#' @usage
#' glue_update_classifier(GrokClassifier, XMLClassifier, JsonClassifier,
#'   CsvClassifier)
#'
#' @param GrokClassifier A `GrokClassifier` object with updated fields.
#' @param XMLClassifier An `XMLClassifier` object with updated fields.
#' @param JsonClassifier A `JsonClassifier` object with updated fields.
#' @param CsvClassifier A `CsvClassifier` object with updated fields.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_classifier(
#'   GrokClassifier = list(
#'     Name = "string",
#'     Classification = "string",
#'     GrokPattern = "string",
#'     CustomPatterns = "string"
#'   ),
#'   XMLClassifier = list(
#'     Name = "string",
#'     Classification = "string",
#'     RowTag = "string"
#'   ),
#'   JsonClassifier = list(
#'     Name = "string",
#'     JsonPath = "string"
#'   ),
#'   CsvClassifier = list(
#'     Name = "string",
#'     Delimiter = "string",
#'     QuoteSymbol = "string",
#'     ContainsHeader = "UNKNOWN"|"PRESENT"|"ABSENT",
#'     Header = list(
#'       "string"
#'     ),
#'     DisableValueTrimming = TRUE|FALSE,
#'     AllowSingleColumn = TRUE|FALSE,
#'     CustomDatatypeConfigured = TRUE|FALSE,
#'     CustomDatatypes = list(
#'       "string"
#'     ),
#'     Serde = "OpenCSVSerDe"|"LazySimpleSerDe"|"None"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_classifier
#'
#' @aliases glue_update_classifier
glue_update_classifier <- function(GrokClassifier = NULL, XMLClassifier = NULL, JsonClassifier = NULL, CsvClassifier = NULL) {
  op <- new_operation(
    name = "UpdateClassifier",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_classifier_input(GrokClassifier = GrokClassifier, XMLClassifier = XMLClassifier, JsonClassifier = JsonClassifier, CsvClassifier = CsvClassifier)
  output <- .glue$update_classifier_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_classifier <- glue_update_classifier

#' Creates or updates partition statistics of columns
#'
#' @description
#' Creates or updates partition statistics of columns.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`update_partition`][glue_update_partition].
#'
#' @usage
#' glue_update_column_statistics_for_partition(CatalogId, DatabaseName,
#'   TableName, PartitionValues, ColumnStatisticsList)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param PartitionValues &#91;required&#93; A list of partition values identifying the partition.
#' @param ColumnStatisticsList &#91;required&#93; A list of the column statistics.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       ColumnStatistics = list(
#'         ColumnName = "string",
#'         ColumnType = "string",
#'         AnalyzedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         StatisticsData = list(
#'           Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'           BooleanColumnStatisticsData = list(
#'             NumberOfTrues = 123,
#'             NumberOfFalses = 123,
#'             NumberOfNulls = 123
#'           ),
#'           DateColumnStatisticsData = list(
#'             MinimumValue = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             MaximumValue = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           DecimalColumnStatisticsData = list(
#'             MinimumValue = list(
#'               UnscaledValue = raw,
#'               Scale = 123
#'             ),
#'             MaximumValue = list(
#'               UnscaledValue = raw,
#'               Scale = 123
#'             ),
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           DoubleColumnStatisticsData = list(
#'             MinimumValue = 123.0,
#'             MaximumValue = 123.0,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           LongColumnStatisticsData = list(
#'             MinimumValue = 123,
#'             MaximumValue = 123,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           StringColumnStatisticsData = list(
#'             MaximumLength = 123,
#'             AverageLength = 123.0,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           BinaryColumnStatisticsData = list(
#'             MaximumLength = 123,
#'             AverageLength = 123.0,
#'             NumberOfNulls = 123
#'           )
#'         )
#'       ),
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_column_statistics_for_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   ),
#'   ColumnStatisticsList = list(
#'     list(
#'       ColumnName = "string",
#'       ColumnType = "string",
#'       AnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StatisticsData = list(
#'         Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'         BooleanColumnStatisticsData = list(
#'           NumberOfTrues = 123,
#'           NumberOfFalses = 123,
#'           NumberOfNulls = 123
#'         ),
#'         DateColumnStatisticsData = list(
#'           MinimumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           MaximumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DecimalColumnStatisticsData = list(
#'           MinimumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           MaximumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DoubleColumnStatisticsData = list(
#'           MinimumValue = 123.0,
#'           MaximumValue = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         LongColumnStatisticsData = list(
#'           MinimumValue = 123,
#'           MaximumValue = 123,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         StringColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         BinaryColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_column_statistics_for_partition
#'
#' @aliases glue_update_column_statistics_for_partition
glue_update_column_statistics_for_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValues, ColumnStatisticsList) {
  op <- new_operation(
    name = "UpdateColumnStatisticsForPartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_column_statistics_for_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValues = PartitionValues, ColumnStatisticsList = ColumnStatisticsList)
  output <- .glue$update_column_statistics_for_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_column_statistics_for_partition <- glue_update_column_statistics_for_partition

#' Creates or updates table statistics of columns
#'
#' @description
#' Creates or updates table statistics of columns.
#' 
#' The Identity and Access Management (IAM) permission required for this
#' operation is [`update_table`][glue_update_table].
#'
#' @usage
#' glue_update_column_statistics_for_table(CatalogId, DatabaseName,
#'   TableName, ColumnStatisticsList)
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If
#' none is supplied, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions' table.
#' @param ColumnStatisticsList &#91;required&#93; A list of the column statistics.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Errors = list(
#'     list(
#'       ColumnStatistics = list(
#'         ColumnName = "string",
#'         ColumnType = "string",
#'         AnalyzedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         StatisticsData = list(
#'           Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'           BooleanColumnStatisticsData = list(
#'             NumberOfTrues = 123,
#'             NumberOfFalses = 123,
#'             NumberOfNulls = 123
#'           ),
#'           DateColumnStatisticsData = list(
#'             MinimumValue = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             MaximumValue = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           DecimalColumnStatisticsData = list(
#'             MinimumValue = list(
#'               UnscaledValue = raw,
#'               Scale = 123
#'             ),
#'             MaximumValue = list(
#'               UnscaledValue = raw,
#'               Scale = 123
#'             ),
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           DoubleColumnStatisticsData = list(
#'             MinimumValue = 123.0,
#'             MaximumValue = 123.0,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           LongColumnStatisticsData = list(
#'             MinimumValue = 123,
#'             MaximumValue = 123,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           StringColumnStatisticsData = list(
#'             MaximumLength = 123,
#'             AverageLength = 123.0,
#'             NumberOfNulls = 123,
#'             NumberOfDistinctValues = 123
#'           ),
#'           BinaryColumnStatisticsData = list(
#'             MaximumLength = 123,
#'             AverageLength = 123.0,
#'             NumberOfNulls = 123
#'           )
#'         )
#'       ),
#'       Error = list(
#'         ErrorCode = "string",
#'         ErrorMessage = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_column_statistics_for_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   ColumnStatisticsList = list(
#'     list(
#'       ColumnName = "string",
#'       ColumnType = "string",
#'       AnalyzedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       StatisticsData = list(
#'         Type = "BOOLEAN"|"DATE"|"DECIMAL"|"DOUBLE"|"LONG"|"STRING"|"BINARY",
#'         BooleanColumnStatisticsData = list(
#'           NumberOfTrues = 123,
#'           NumberOfFalses = 123,
#'           NumberOfNulls = 123
#'         ),
#'         DateColumnStatisticsData = list(
#'           MinimumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           MaximumValue = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DecimalColumnStatisticsData = list(
#'           MinimumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           MaximumValue = list(
#'             UnscaledValue = raw,
#'             Scale = 123
#'           ),
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         DoubleColumnStatisticsData = list(
#'           MinimumValue = 123.0,
#'           MaximumValue = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         LongColumnStatisticsData = list(
#'           MinimumValue = 123,
#'           MaximumValue = 123,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         StringColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123,
#'           NumberOfDistinctValues = 123
#'         ),
#'         BinaryColumnStatisticsData = list(
#'           MaximumLength = 123,
#'           AverageLength = 123.0,
#'           NumberOfNulls = 123
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_column_statistics_for_table
#'
#' @aliases glue_update_column_statistics_for_table
glue_update_column_statistics_for_table <- function(CatalogId = NULL, DatabaseName, TableName, ColumnStatisticsList) {
  op <- new_operation(
    name = "UpdateColumnStatisticsForTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_column_statistics_for_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, ColumnStatisticsList = ColumnStatisticsList)
  output <- .glue$update_column_statistics_for_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_column_statistics_for_table <- glue_update_column_statistics_for_table

#' Updates settings for a column statistics task
#'
#' @description
#' Updates settings for a column statistics task.
#'
#' @usage
#' glue_update_column_statistics_task_settings(DatabaseName, TableName,
#'   Role, Schedule, ColumnNameList, SampleSize, CatalogID,
#'   SecurityConfiguration)
#'
#' @param DatabaseName &#91;required&#93; The name of the database where the table resides.
#' @param TableName &#91;required&#93; The name of the table for which to generate column statistics.
#' @param Role The role used for running the column statistics.
#' @param Schedule A schedule for running the column statistics, specified in CRON syntax.
#' @param ColumnNameList A list of column names for which to run statistics.
#' @param SampleSize The percentage of data to sample.
#' @param CatalogID The ID of the Data Catalog in which the database resides.
#' @param SecurityConfiguration Name of the security configuration that is used to encrypt CloudWatch
#' logs.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_column_statistics_task_settings(
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Role = "string",
#'   Schedule = "string",
#'   ColumnNameList = list(
#'     "string"
#'   ),
#'   SampleSize = 123.0,
#'   CatalogID = "string",
#'   SecurityConfiguration = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_column_statistics_task_settings
#'
#' @aliases glue_update_column_statistics_task_settings
glue_update_column_statistics_task_settings <- function(DatabaseName, TableName, Role = NULL, Schedule = NULL, ColumnNameList = NULL, SampleSize = NULL, CatalogID = NULL, SecurityConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateColumnStatisticsTaskSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_column_statistics_task_settings_input(DatabaseName = DatabaseName, TableName = TableName, Role = Role, Schedule = Schedule, ColumnNameList = ColumnNameList, SampleSize = SampleSize, CatalogID = CatalogID, SecurityConfiguration = SecurityConfiguration)
  output <- .glue$update_column_statistics_task_settings_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_column_statistics_task_settings <- glue_update_column_statistics_task_settings

#' Updates a connection definition in the Data Catalog
#'
#' @description
#' Updates a connection definition in the Data Catalog.
#'
#' @usage
#' glue_update_connection(CatalogId, Name, ConnectionInput)
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is
#' provided, the Amazon Web Services account ID is used by default.
#' @param Name &#91;required&#93; The name of the connection definition to update.
#' @param ConnectionInput &#91;required&#93; A `ConnectionInput` object that redefines the connection in question.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_connection(
#'   CatalogId = "string",
#'   Name = "string",
#'   ConnectionInput = list(
#'     Name = "string",
#'     Description = "string",
#'     ConnectionType = "JDBC"|"SFTP"|"MONGODB"|"KAFKA"|"NETWORK"|"MARKETPLACE"|"CUSTOM"|"SALESFORCE"|"VIEW_VALIDATION_REDSHIFT"|"VIEW_VALIDATION_ATHENA"|"GOOGLEADS"|"GOOGLESHEETS"|"GOOGLEANALYTICS4"|"SERVICENOW"|"MARKETO"|"SAPODATA"|"ZENDESK"|"JIRACLOUD"|"NETSUITEERP"|"HUBSPOT"|"FACEBOOKADS"|"INSTAGRAMADS"|"ZOHOCRM"|"SALESFORCEPARDOT"|"SALESFORCEMARKETINGCLOUD"|"SLACK"|"STRIPE"|"INTERCOM"|"SNAPCHATADS",
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     AthenaProperties = list(
#'       "string"
#'     ),
#'     PythonProperties = list(
#'       "string"
#'     ),
#'     PhysicalConnectionRequirements = list(
#'       SubnetId = "string",
#'       SecurityGroupIdList = list(
#'         "string"
#'       ),
#'       AvailabilityZone = "string"
#'     ),
#'     AuthenticationConfiguration = list(
#'       AuthenticationType = "BASIC"|"OAUTH2"|"CUSTOM"|"IAM",
#'       OAuth2Properties = list(
#'         OAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'         OAuth2ClientApplication = list(
#'           UserManagedClientApplicationClientId = "string",
#'           AWSManagedClientApplicationReference = "string"
#'         ),
#'         TokenUrl = "string",
#'         TokenUrlParametersMap = list(
#'           "string"
#'         ),
#'         AuthorizationCodeProperties = list(
#'           AuthorizationCode = "string",
#'           RedirectUri = "string"
#'         ),
#'         OAuth2Credentials = list(
#'           UserManagedClientApplicationClientSecret = "string",
#'           AccessToken = "string",
#'           RefreshToken = "string",
#'           JwtToken = "string"
#'         )
#'       ),
#'       SecretArn = "string",
#'       KmsKeyArn = "string",
#'       BasicAuthenticationCredentials = list(
#'         Username = "string",
#'         Password = "string"
#'       ),
#'       CustomAuthenticationCredentials = list(
#'         "string"
#'       )
#'     ),
#'     ValidateCredentials = TRUE|FALSE,
#'     ValidateForComputeEnvironments = list(
#'       "SPARK"|"ATHENA"|"PYTHON"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_connection
#'
#' @aliases glue_update_connection
glue_update_connection <- function(CatalogId = NULL, Name, ConnectionInput) {
  op <- new_operation(
    name = "UpdateConnection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_connection_input(CatalogId = CatalogId, Name = Name, ConnectionInput = ConnectionInput)
  output <- .glue$update_connection_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_connection <- glue_update_connection

#' Updates a crawler
#'
#' @description
#' Updates a crawler. If a crawler is running, you must stop it using
#' [`stop_crawler`][glue_stop_crawler] before updating it.
#'
#' @usage
#' glue_update_crawler(Name, Role, DatabaseName, Description, Targets,
#'   Schedule, Classifiers, TablePrefix, SchemaChangePolicy, RecrawlPolicy,
#'   LineageConfiguration, LakeFormationConfiguration, Configuration,
#'   CrawlerSecurityConfiguration)
#'
#' @param Name &#91;required&#93; Name of the new crawler.
#' @param Role The IAM role or Amazon Resource Name (ARN) of an IAM role that is used
#' by the new crawler to access customer resources.
#' @param DatabaseName The Glue database where results are stored, such as:
#' `arn:aws:daylight:us-east-1::database/sometable/*`.
#' @param Description A description of the new crawler.
#' @param Targets A list of targets to crawl.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based
#' Schedules for Jobs and
#' Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html).
#' For example, to run something every day at 12:15 UTC, you would specify:
#' `cron(15 12 * * ? *)`.
#' @param Classifiers A list of custom classifiers that the user has registered. By default,
#' all built-in classifiers are included in a crawl, but these custom
#' classifiers always override the default classifiers for a given
#' classification.
#' @param TablePrefix The table prefix used for catalog tables that are created.
#' @param SchemaChangePolicy The policy for the crawler's update and deletion behavior.
#' @param RecrawlPolicy A policy that specifies whether to crawl the entire dataset again, or to
#' crawl only folders that were added since the last crawler run.
#' @param LineageConfiguration Specifies data lineage configuration settings for the crawler.
#' @param LakeFormationConfiguration Specifies Lake Formation configuration settings for the crawler.
#' @param Configuration Crawler configuration information. This versioned JSON string allows
#' users to specify aspects of a crawler's behavior. For more information,
#' see [Setting crawler configuration
#' options](https://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
#' @param CrawlerSecurityConfiguration The name of the `SecurityConfiguration` structure to be used by this
#' crawler.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_crawler(
#'   Name = "string",
#'   Role = "string",
#'   DatabaseName = "string",
#'   Description = "string",
#'   Targets = list(
#'     S3Targets = list(
#'       list(
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         SampleSize = 123,
#'         EventQueueArn = "string",
#'         DlqEventQueueArn = "string"
#'       )
#'     ),
#'     JdbcTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         EnableAdditionalMetadata = list(
#'           "COMMENTS"|"RAWTYPES"
#'         )
#'       )
#'     ),
#'     MongoDBTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         ScanAll = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDBTargets = list(
#'       list(
#'         Path = "string",
#'         scanAll = TRUE|FALSE,
#'         scanRate = 123.0
#'       )
#'     ),
#'     CatalogTargets = list(
#'       list(
#'         DatabaseName = "string",
#'         Tables = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         EventQueueArn = "string",
#'         DlqEventQueueArn = "string"
#'       )
#'     ),
#'     DeltaTargets = list(
#'       list(
#'         DeltaTables = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         WriteManifest = TRUE|FALSE,
#'         CreateNativeDeltaTable = TRUE|FALSE
#'       )
#'     ),
#'     IcebergTargets = list(
#'       list(
#'         Paths = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         MaximumTraversalDepth = 123
#'       )
#'     ),
#'     HudiTargets = list(
#'       list(
#'         Paths = list(
#'           "string"
#'         ),
#'         ConnectionName = "string",
#'         Exclusions = list(
#'           "string"
#'         ),
#'         MaximumTraversalDepth = 123
#'       )
#'     )
#'   ),
#'   Schedule = "string",
#'   Classifiers = list(
#'     "string"
#'   ),
#'   TablePrefix = "string",
#'   SchemaChangePolicy = list(
#'     UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'     DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'   ),
#'   RecrawlPolicy = list(
#'     RecrawlBehavior = "CRAWL_EVERYTHING"|"CRAWL_NEW_FOLDERS_ONLY"|"CRAWL_EVENT_MODE"
#'   ),
#'   LineageConfiguration = list(
#'     CrawlerLineageSettings = "ENABLE"|"DISABLE"
#'   ),
#'   LakeFormationConfiguration = list(
#'     UseLakeFormationCredentials = TRUE|FALSE,
#'     AccountId = "string"
#'   ),
#'   Configuration = "string",
#'   CrawlerSecurityConfiguration = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_crawler
#'
#' @aliases glue_update_crawler
glue_update_crawler <- function(Name, Role = NULL, DatabaseName = NULL, Description = NULL, Targets = NULL, Schedule = NULL, Classifiers = NULL, TablePrefix = NULL, SchemaChangePolicy = NULL, RecrawlPolicy = NULL, LineageConfiguration = NULL, LakeFormationConfiguration = NULL, Configuration = NULL, CrawlerSecurityConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateCrawler",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_crawler_input(Name = Name, Role = Role, DatabaseName = DatabaseName, Description = Description, Targets = Targets, Schedule = Schedule, Classifiers = Classifiers, TablePrefix = TablePrefix, SchemaChangePolicy = SchemaChangePolicy, RecrawlPolicy = RecrawlPolicy, LineageConfiguration = LineageConfiguration, LakeFormationConfiguration = LakeFormationConfiguration, Configuration = Configuration, CrawlerSecurityConfiguration = CrawlerSecurityConfiguration)
  output <- .glue$update_crawler_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_crawler <- glue_update_crawler

#' Updates the schedule of a crawler using a cron expression
#'
#' @description
#' Updates the schedule of a crawler using a `cron` expression.
#'
#' @usage
#' glue_update_crawler_schedule(CrawlerName, Schedule)
#'
#' @param CrawlerName &#91;required&#93; The name of the crawler whose schedule to update.
#' @param Schedule The updated `cron` expression used to specify the schedule (see
#' [Time-Based Schedules for Jobs and
#' Crawlers](https://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html).
#' For example, to run something every day at 12:15 UTC, you would specify:
#' `cron(15 12 * * ? *)`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_crawler_schedule(
#'   CrawlerName = "string",
#'   Schedule = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_crawler_schedule
#'
#' @aliases glue_update_crawler_schedule
glue_update_crawler_schedule <- function(CrawlerName, Schedule = NULL) {
  op <- new_operation(
    name = "UpdateCrawlerSchedule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_crawler_schedule_input(CrawlerName = CrawlerName, Schedule = Schedule)
  output <- .glue$update_crawler_schedule_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_crawler_schedule <- glue_update_crawler_schedule

#' Updates the specified data quality ruleset
#'
#' @description
#' Updates the specified data quality ruleset.
#'
#' @usage
#' glue_update_data_quality_ruleset(Name, Description, Ruleset)
#'
#' @param Name &#91;required&#93; The name of the data quality ruleset.
#' @param Description A description of the ruleset.
#' @param Ruleset A Data Quality Definition Language (DQDL) ruleset. For more information,
#' see the Glue developer guide.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string",
#'   Description = "string",
#'   Ruleset = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_data_quality_ruleset(
#'   Name = "string",
#'   Description = "string",
#'   Ruleset = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_data_quality_ruleset
#'
#' @aliases glue_update_data_quality_ruleset
glue_update_data_quality_ruleset <- function(Name, Description = NULL, Ruleset = NULL) {
  op <- new_operation(
    name = "UpdateDataQualityRuleset",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_data_quality_ruleset_input(Name = Name, Description = Description, Ruleset = Ruleset)
  output <- .glue$update_data_quality_ruleset_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_data_quality_ruleset <- glue_update_data_quality_ruleset

#' Updates an existing database definition in a Data Catalog
#'
#' @description
#' Updates an existing database definition in a Data Catalog.
#'
#' @usage
#' glue_update_database(CatalogId, Name, DatabaseInput)
#'
#' @param CatalogId The ID of the Data Catalog in which the metadata database resides. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param Name &#91;required&#93; The name of the database to update in the catalog. For Hive
#' compatibility, this is folded to lowercase.
#' @param DatabaseInput &#91;required&#93; A `DatabaseInput` object specifying the new definition of the metadata
#' database in the catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_database(
#'   CatalogId = "string",
#'   Name = "string",
#'   DatabaseInput = list(
#'     Name = "string",
#'     Description = "string",
#'     LocationUri = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     CreateTableDefaultPermissions = list(
#'       list(
#'         Principal = list(
#'           DataLakePrincipalIdentifier = "string"
#'         ),
#'         Permissions = list(
#'           "ALL"|"SELECT"|"ALTER"|"DROP"|"DELETE"|"INSERT"|"CREATE_DATABASE"|"CREATE_TABLE"|"DATA_LOCATION_ACCESS"
#'         )
#'       )
#'     ),
#'     TargetDatabase = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Region = "string"
#'     ),
#'     FederatedDatabase = list(
#'       Identifier = "string",
#'       ConnectionName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_database
#'
#' @aliases glue_update_database
glue_update_database <- function(CatalogId = NULL, Name, DatabaseInput) {
  op <- new_operation(
    name = "UpdateDatabase",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_database_input(CatalogId = CatalogId, Name = Name, DatabaseInput = DatabaseInput)
  output <- .glue$update_database_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_database <- glue_update_database

#' Updates a specified development endpoint
#'
#' @description
#' Updates a specified development endpoint.
#'
#' @usage
#' glue_update_dev_endpoint(EndpointName, PublicKey, AddPublicKeys,
#'   DeletePublicKeys, CustomLibraries, UpdateEtlLibraries, DeleteArguments,
#'   AddArguments)
#'
#' @param EndpointName &#91;required&#93; The name of the `DevEndpoint` to be updated.
#' @param PublicKey The public key for the `DevEndpoint` to use.
#' @param AddPublicKeys The list of public keys for the `DevEndpoint` to use.
#' @param DeletePublicKeys The list of public keys to be deleted from the `DevEndpoint`.
#' @param CustomLibraries Custom Python or Java libraries to be loaded in the `DevEndpoint`.
#' @param UpdateEtlLibraries `True` if the list of custom libraries to be loaded in the development
#' endpoint needs to be updated, or `False` if otherwise.
#' @param DeleteArguments The list of argument keys to be deleted from the map of arguments used
#' to configure the `DevEndpoint`.
#' @param AddArguments The map of arguments to add the map of arguments used to configure the
#' `DevEndpoint`.
#' 
#' Valid arguments are:
#' 
#' -   `"--enable-glue-datacatalog": ""`
#' 
#' You can specify a version of Python support for development endpoints by
#' using the `Arguments` parameter in the
#' [`create_dev_endpoint`][glue_create_dev_endpoint] or
#' [`update_dev_endpoint`][glue_update_dev_endpoint] APIs. If no arguments
#' are provided, the version defaults to Python 2.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_dev_endpoint(
#'   EndpointName = "string",
#'   PublicKey = "string",
#'   AddPublicKeys = list(
#'     "string"
#'   ),
#'   DeletePublicKeys = list(
#'     "string"
#'   ),
#'   CustomLibraries = list(
#'     ExtraPythonLibsS3Path = "string",
#'     ExtraJarsS3Path = "string"
#'   ),
#'   UpdateEtlLibraries = TRUE|FALSE,
#'   DeleteArguments = list(
#'     "string"
#'   ),
#'   AddArguments = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_dev_endpoint
#'
#' @aliases glue_update_dev_endpoint
glue_update_dev_endpoint <- function(EndpointName, PublicKey = NULL, AddPublicKeys = NULL, DeletePublicKeys = NULL, CustomLibraries = NULL, UpdateEtlLibraries = NULL, DeleteArguments = NULL, AddArguments = NULL) {
  op <- new_operation(
    name = "UpdateDevEndpoint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_dev_endpoint_input(EndpointName = EndpointName, PublicKey = PublicKey, AddPublicKeys = AddPublicKeys, DeletePublicKeys = DeletePublicKeys, CustomLibraries = CustomLibraries, UpdateEtlLibraries = UpdateEtlLibraries, DeleteArguments = DeleteArguments, AddArguments = AddArguments)
  output <- .glue$update_dev_endpoint_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_dev_endpoint <- glue_update_dev_endpoint

#' This API can be used for updating the ResourceProperty of the Glue
#' connection (for the source) or Glue database ARN (for the target)
#'
#' @description
#' This API can be used for updating the `ResourceProperty` of the Glue
#' connection (for the source) or Glue database ARN (for the target). These
#' properties can include the role to access the connection or database.
#' Since the same resource can be used across multiple integrations,
#' updating resource properties will impact all the integrations using it.
#'
#' @usage
#' glue_update_integration_resource_property(ResourceArn,
#'   SourceProcessingProperties, TargetProcessingProperties)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param SourceProcessingProperties The resource properties associated with the integration source.
#' @param TargetProcessingProperties The resource properties associated with the integration target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ResourceArn = "string",
#'   SourceProcessingProperties = list(
#'     RoleArn = "string"
#'   ),
#'   TargetProcessingProperties = list(
#'     RoleArn = "string",
#'     KmsArn = "string",
#'     ConnectionName = "string",
#'     EventBusArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_integration_resource_property(
#'   ResourceArn = "string",
#'   SourceProcessingProperties = list(
#'     RoleArn = "string"
#'   ),
#'   TargetProcessingProperties = list(
#'     RoleArn = "string",
#'     KmsArn = "string",
#'     ConnectionName = "string",
#'     EventBusArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_integration_resource_property
#'
#' @aliases glue_update_integration_resource_property
glue_update_integration_resource_property <- function(ResourceArn, SourceProcessingProperties = NULL, TargetProcessingProperties = NULL) {
  op <- new_operation(
    name = "UpdateIntegrationResourceProperty",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_integration_resource_property_input(ResourceArn = ResourceArn, SourceProcessingProperties = SourceProcessingProperties, TargetProcessingProperties = TargetProcessingProperties)
  output <- .glue$update_integration_resource_property_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_integration_resource_property <- glue_update_integration_resource_property

#' This API is used to provide optional override properties for the tables
#' that need to be replicated
#'
#' @description
#' This API is used to provide optional override properties for the tables
#' that need to be replicated. These properties can include properties for
#' filtering and partitioning for the source and target tables. To set both
#' source and target properties the same API need to be invoked with the
#' Glue connection ARN as `ResourceArn` with `SourceTableConfig`, and the
#' Glue database ARN as `ResourceArn` with `TargetTableConfig`
#' respectively.
#' 
#' The override will be reflected across all the integrations using same
#' `ResourceArn` and source table.
#'
#' @usage
#' glue_update_integration_table_properties(ResourceArn, TableName,
#'   SourceTableConfig, TargetTableConfig)
#'
#' @param ResourceArn &#91;required&#93; The connection ARN of the source, or the database ARN of the target.
#' @param TableName &#91;required&#93; The name of the table to be replicated.
#' @param SourceTableConfig A structure for the source table configuration.
#' @param TargetTableConfig A structure for the target table configuration.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_integration_table_properties(
#'   ResourceArn = "string",
#'   TableName = "string",
#'   SourceTableConfig = list(
#'     Fields = list(
#'       "string"
#'     ),
#'     FilterPredicate = "string",
#'     PrimaryKey = list(
#'       "string"
#'     ),
#'     RecordUpdateField = "string"
#'   ),
#'   TargetTableConfig = list(
#'     UnnestSpec = "TOPLEVEL"|"FULL"|"NOUNNEST",
#'     PartitionSpec = list(
#'       list(
#'         FieldName = "string",
#'         FunctionSpec = "string"
#'       )
#'     ),
#'     TargetTableName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_integration_table_properties
#'
#' @aliases glue_update_integration_table_properties
glue_update_integration_table_properties <- function(ResourceArn, TableName, SourceTableConfig = NULL, TargetTableConfig = NULL) {
  op <- new_operation(
    name = "UpdateIntegrationTableProperties",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_integration_table_properties_input(ResourceArn = ResourceArn, TableName = TableName, SourceTableConfig = SourceTableConfig, TargetTableConfig = TargetTableConfig)
  output <- .glue$update_integration_table_properties_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_integration_table_properties <- glue_update_integration_table_properties

#' Updates an existing job definition
#'
#' @description
#' Updates an existing job definition. The previous job definition is
#' completely overwritten by this information.
#'
#' @usage
#' glue_update_job(JobName, JobUpdate)
#'
#' @param JobName &#91;required&#93; The name of the job definition to update.
#' @param JobUpdate &#91;required&#93; Specifies the values with which to update the job definition.
#' Unspecified configuration is removed or reset to default values.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_job(
#'   JobName = "string",
#'   JobUpdate = list(
#'     JobMode = "SCRIPT"|"VISUAL"|"NOTEBOOK",
#'     JobRunQueuingEnabled = TRUE|FALSE,
#'     Description = "string",
#'     LogUri = "string",
#'     Role = "string",
#'     ExecutionProperty = list(
#'       MaxConcurrentRuns = 123
#'     ),
#'     Command = list(
#'       Name = "string",
#'       ScriptLocation = "string",
#'       PythonVersion = "string",
#'       Runtime = "string"
#'     ),
#'     DefaultArguments = list(
#'       "string"
#'     ),
#'     NonOverridableArguments = list(
#'       "string"
#'     ),
#'     Connections = list(
#'       Connections = list(
#'         "string"
#'       )
#'     ),
#'     MaxRetries = 123,
#'     AllocatedCapacity = 123,
#'     Timeout = 123,
#'     MaxCapacity = 123.0,
#'     WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'     NumberOfWorkers = 123,
#'     SecurityConfiguration = "string",
#'     NotificationProperty = list(
#'       NotifyDelayAfter = 123
#'     ),
#'     GlueVersion = "string",
#'     CodeGenConfigurationNodes = list(
#'       list(
#'         AthenaConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           ConnectionTable = "string",
#'           SchemaName = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         JDBCConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             FilterPredicate = "string",
#'             PartitionColumn = "string",
#'             LowerBound = 123,
#'             UpperBound = 123,
#'             NumPartitions = 123,
#'             JobBookmarkKeys = list(
#'               "string"
#'             ),
#'             JobBookmarkKeysSortOrder = "string",
#'             DataTypeMapping = list(
#'               "DATE"|"STRING"|"TIMESTAMP"|"INT"|"FLOAT"|"LONG"|"BIGDECIMAL"|"BYTE"|"SHORT"|"DOUBLE"
#'             )
#'           ),
#'           ConnectionTable = "string",
#'           Query = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkConnectorSource = list(
#'           Name = "string",
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         RedshiftSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           RedshiftTmpDir = "string",
#'           TmpDirIAMRole = "string"
#'         ),
#'         S3CatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           PartitionPredicate = "string",
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123
#'           )
#'         ),
#'         S3CsvSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "gzip"|"bzip2",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           Separator = "comma"|"ctrla"|"pipe"|"semicolon"|"tab",
#'           Escaper = "string",
#'           QuoteChar = "quote"|"quillemet"|"single_quote"|"disabled",
#'           Multiline = TRUE|FALSE,
#'           WithHeader = TRUE|FALSE,
#'           WriteHeader = TRUE|FALSE,
#'           SkipFirst = TRUE|FALSE,
#'           OptimizePerformance = TRUE|FALSE,
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3JsonSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "gzip"|"bzip2",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           JsonPath = "string",
#'           Multiline = TRUE|FALSE,
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3ParquetSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           CompressionType = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'           Exclusions = list(
#'             "string"
#'           ),
#'           GroupSize = "string",
#'           GroupFiles = "string",
#'           Recurse = TRUE|FALSE,
#'           MaxBand = 123,
#'           MaxFilesInBand = 123,
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         RelationalCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         DynamoDBCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         JDBCConnectorTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           ConnectionTable = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkConnectorTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ConnectionName = "string",
#'           ConnectorName = "string",
#'           ConnectionType = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         RedshiftTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string",
#'           RedshiftTmpDir = "string",
#'           TmpDirIAMRole = "string",
#'           UpsertRedshiftOptions = list(
#'             TableLocation = "string",
#'             ConnectionName = "string",
#'             UpsertKeys = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         S3CatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3GlueParquetTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "snappy"|"lzo"|"gzip"|"uncompressed"|"none",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         S3DirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "string",
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         ApplyMapping = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Mapping = list(
#'             list(
#'               ToKey = "string",
#'               FromPath = list(
#'                 "string"
#'               ),
#'               FromType = "string",
#'               ToType = "string",
#'               Dropped = TRUE|FALSE,
#'               Children = list()
#'             )
#'           )
#'         ),
#'         SelectFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         DropFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         RenameField = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           SourcePath = list(
#'             "string"
#'           ),
#'           TargetPath = list(
#'             "string"
#'           )
#'         ),
#'         Spigot = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Path = "string",
#'           Topk = 123,
#'           Prob = 123.0
#'         ),
#'         Join = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           JoinType = "equijoin"|"left"|"right"|"outer"|"leftsemi"|"leftanti",
#'           Columns = list(
#'             list(
#'               From = "string",
#'               Keys = list(
#'                 list(
#'                   "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SplitFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Paths = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         SelectFromCollection = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Index = 123
#'         ),
#'         FillMissingValues = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           ImputedPath = "string",
#'           FilledPath = "string"
#'         ),
#'         Filter = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           LogicalOperator = "AND"|"OR",
#'           Filters = list(
#'             list(
#'               Operation = "EQ"|"LT"|"GT"|"LTE"|"GTE"|"REGEX"|"ISNULL",
#'               Negated = TRUE|FALSE,
#'               Values = list(
#'                 list(
#'                   Type = "COLUMNEXTRACTED"|"CONSTANT",
#'                   Value = list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CustomCode = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Code = "string",
#'           ClassName = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SparkSQL = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           SqlQuery = "string",
#'           SqlAliases = list(
#'             list(
#'               From = "string",
#'               Alias = "string"
#'             )
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         DirectKinesisSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           StreamingOptions = list(
#'             EndpointUrl = "string",
#'             StreamName = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'             MaxFetchTimeInMs = 123,
#'             MaxFetchRecordsPerShard = 123,
#'             MaxRecordPerRead = 123,
#'             AddIdleTimeBetweenReads = TRUE|FALSE,
#'             IdleTimeBetweenReadsInMs = 123,
#'             DescribeShardInterval = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxRetryIntervalMs = 123,
#'             AvoidEmptyBatches = TRUE|FALSE,
#'             StreamArn = "string",
#'             RoleArn = "string",
#'             RoleSessionName = "string",
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         DirectKafkaSource = list(
#'           Name = "string",
#'           StreamingOptions = list(
#'             BootstrapServers = "string",
#'             SecurityProtocol = "string",
#'             ConnectionName = "string",
#'             TopicName = "string",
#'             Assign = "string",
#'             SubscribePattern = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingOffsets = "string",
#'             EndingOffsets = "string",
#'             PollTimeoutMs = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxOffsetsPerTrigger = 123,
#'             MinPartitions = 123,
#'             IncludeHeaders = TRUE|FALSE,
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         CatalogKinesisSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           Table = "string",
#'           Database = "string",
#'           StreamingOptions = list(
#'             EndpointUrl = "string",
#'             StreamName = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingPosition = "latest"|"trim_horizon"|"earliest"|"timestamp",
#'             MaxFetchTimeInMs = 123,
#'             MaxFetchRecordsPerShard = 123,
#'             MaxRecordPerRead = 123,
#'             AddIdleTimeBetweenReads = TRUE|FALSE,
#'             IdleTimeBetweenReadsInMs = 123,
#'             DescribeShardInterval = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxRetryIntervalMs = 123,
#'             AvoidEmptyBatches = TRUE|FALSE,
#'             StreamArn = "string",
#'             RoleArn = "string",
#'             RoleSessionName = "string",
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         CatalogKafkaSource = list(
#'           Name = "string",
#'           WindowSize = 123,
#'           DetectSchema = TRUE|FALSE,
#'           Table = "string",
#'           Database = "string",
#'           StreamingOptions = list(
#'             BootstrapServers = "string",
#'             SecurityProtocol = "string",
#'             ConnectionName = "string",
#'             TopicName = "string",
#'             Assign = "string",
#'             SubscribePattern = "string",
#'             Classification = "string",
#'             Delimiter = "string",
#'             StartingOffsets = "string",
#'             EndingOffsets = "string",
#'             PollTimeoutMs = 123,
#'             NumRetries = 123,
#'             RetryIntervalMs = 123,
#'             MaxOffsetsPerTrigger = 123,
#'             MinPartitions = 123,
#'             IncludeHeaders = TRUE|FALSE,
#'             AddRecordTimestamp = "string",
#'             EmitConsumerLagMetrics = "string",
#'             StartingTimestamp = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           ),
#'           DataPreviewOptions = list(
#'             PollingTime = 123,
#'             RecordPollingLimit = 123
#'           )
#'         ),
#'         DropNullFields = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           NullCheckBoxList = list(
#'             IsEmpty = TRUE|FALSE,
#'             IsNullString = TRUE|FALSE,
#'             IsNegOne = TRUE|FALSE
#'           ),
#'           NullTextList = list(
#'             list(
#'               Value = "string",
#'               Datatype = list(
#'                 Id = "string",
#'                 Label = "string"
#'               )
#'             )
#'           )
#'         ),
#'         Merge = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Source = "string",
#'           PrimaryKeys = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         Union = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           UnionType = "ALL"|"DISTINCT"
#'         ),
#'         PIIDetection = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PiiType = "RowAudit"|"RowMasking"|"ColumnAudit"|"ColumnMasking",
#'           EntityTypesToDetect = list(
#'             "string"
#'           ),
#'           OutputColumnName = "string",
#'           SampleFraction = 123.0,
#'           ThresholdFraction = 123.0,
#'           MaskValue = "string"
#'         ),
#'         Aggregate = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Groups = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Aggs = list(
#'             list(
#'               Column = list(
#'                 "string"
#'               ),
#'               AggFunc = "avg"|"countDistinct"|"count"|"first"|"last"|"kurtosis"|"max"|"min"|"skewness"|"stddev_samp"|"stddev_pop"|"sum"|"sumDistinct"|"var_samp"|"var_pop"
#'             )
#'           )
#'         ),
#'         DropDuplicates = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Columns = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         GovernedCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         GovernedCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           PartitionPredicate = "string",
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123
#'           )
#'         ),
#'         MicrosoftSQLServerCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MySQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         OracleSQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         PostgreSQLCatalogSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MicrosoftSQLServerCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         MySQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         OracleSQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         PostgreSQLCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Database = "string",
#'           Table = "string"
#'         ),
#'         DynamicTransform = list(
#'           Name = "string",
#'           TransformName = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Parameters = list(
#'             list(
#'               Name = "string",
#'               Type = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'               ValidationRule = "string",
#'               ValidationMessage = "string",
#'               Value = list(
#'                 "string"
#'               ),
#'               ListType = "str"|"int"|"float"|"complex"|"bool"|"list"|"null",
#'               IsOptional = TRUE|FALSE
#'             )
#'           ),
#'           FunctionName = "string",
#'           Path = "string",
#'           Version = "string",
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         EvaluateDataQuality = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Ruleset = "string",
#'           Output = "PrimaryInput"|"EvaluationResults",
#'           PublishingOptions = list(
#'             EvaluationContext = "string",
#'             ResultsS3Prefix = "string",
#'             CloudWatchMetricsEnabled = TRUE|FALSE,
#'             ResultsPublishingEnabled = TRUE|FALSE
#'           ),
#'           StopJobOnFailureOptions = list(
#'             StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'           )
#'         ),
#'         S3CatalogHudiSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogHudiSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3HudiSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           AdditionalHudiOptions = list(
#'             "string"
#'           ),
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3HudiCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3HudiDirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           Path = "string",
#'           Compression = "gzip"|"lzo"|"uncompressed"|"snappy",
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         DirectJDBCSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           ConnectionName = "string",
#'           ConnectionType = "sqlserver"|"mysql"|"oracle"|"postgresql"|"redshift",
#'           RedshiftTmpDir = "string"
#'         ),
#'         S3CatalogDeltaSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         CatalogDeltaSource = list(
#'           Name = "string",
#'           Database = "string",
#'           Table = "string",
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3DeltaSource = list(
#'           Name = "string",
#'           Paths = list(
#'             "string"
#'           ),
#'           AdditionalDeltaOptions = list(
#'             "string"
#'           ),
#'           AdditionalOptions = list(
#'             BoundedSize = 123,
#'             BoundedFiles = 123,
#'             EnableSamplePath = TRUE|FALSE,
#'             SamplePath = "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         S3DeltaCatalogTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Table = "string",
#'           Database = "string",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG"
#'           )
#'         ),
#'         S3DeltaDirectTarget = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           PartitionKeys = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           Path = "string",
#'           Compression = "uncompressed"|"snappy",
#'           Format = "json"|"csv"|"avro"|"orc"|"parquet"|"hudi"|"delta",
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           SchemaChangePolicy = list(
#'             EnableUpdateCatalog = TRUE|FALSE,
#'             UpdateBehavior = "UPDATE_IN_DATABASE"|"LOG",
#'             Table = "string",
#'             Database = "string"
#'           )
#'         ),
#'         AmazonRedshiftSource = list(
#'           Name = "string",
#'           Data = list(
#'             AccessType = "string",
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Table = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogDatabase = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogTable = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogRedshiftSchema = "string",
#'             CatalogRedshiftTable = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdvancedOptions = list(
#'               list(
#'                 Key = "string",
#'                 Value = "string"
#'               )
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             TablePrefix = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             CrawlerConnection = "string",
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           )
#'         ),
#'         AmazonRedshiftTarget = list(
#'           Name = "string",
#'           Data = list(
#'             AccessType = "string",
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Table = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogDatabase = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogTable = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             CatalogRedshiftSchema = "string",
#'             CatalogRedshiftTable = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdvancedOptions = list(
#'               list(
#'                 Key = "string",
#'                 Value = "string"
#'               )
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             TablePrefix = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             CrawlerConnection = "string",
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         ),
#'         EvaluateDataQualityMultiFrame = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           AdditionalDataSources = list(
#'             "string"
#'           ),
#'           Ruleset = "string",
#'           PublishingOptions = list(
#'             EvaluationContext = "string",
#'             ResultsS3Prefix = "string",
#'             CloudWatchMetricsEnabled = TRUE|FALSE,
#'             ResultsPublishingEnabled = TRUE|FALSE
#'           ),
#'           AdditionalOptions = list(
#'             "string"
#'           ),
#'           StopJobOnFailureOptions = list(
#'             StopJobOnFailureTiming = "Immediate"|"AfterDataLoad"
#'           )
#'         ),
#'         Recipe = list(
#'           Name = "string",
#'           Inputs = list(
#'             "string"
#'           ),
#'           RecipeReference = list(
#'             RecipeArn = "string",
#'             RecipeVersion = "string"
#'           ),
#'           RecipeSteps = list(
#'             list(
#'               Action = list(
#'                 Operation = "string",
#'                 Parameters = list(
#'                   "string"
#'                 )
#'               ),
#'               ConditionExpressions = list(
#'                 list(
#'                   Condition = "string",
#'                   Value = "string",
#'                   TargetColumn = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SnowflakeSource = list(
#'           Name = "string",
#'           Data = list(
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = "string",
#'             Table = "string",
#'             Database = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             AutoPushdown = TRUE|FALSE,
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         SnowflakeTarget = list(
#'           Name = "string",
#'           Data = list(
#'             SourceType = "string",
#'             Connection = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             Schema = "string",
#'             Table = "string",
#'             Database = "string",
#'             TempDir = "string",
#'             IamRole = list(
#'               Value = "string",
#'               Label = "string",
#'               Description = "string"
#'             ),
#'             AdditionalOptions = list(
#'               "string"
#'             ),
#'             SampleQuery = "string",
#'             PreAction = "string",
#'             PostAction = "string",
#'             Action = "string",
#'             Upsert = TRUE|FALSE,
#'             MergeAction = "string",
#'             MergeWhenMatched = "string",
#'             MergeWhenNotMatched = "string",
#'             MergeClause = "string",
#'             StagingTable = "string",
#'             SelectedColumns = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             ),
#'             AutoPushdown = TRUE|FALSE,
#'             TableSchema = list(
#'               list(
#'                 Value = "string",
#'                 Label = "string",
#'                 Description = "string"
#'               )
#'             )
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         ),
#'         ConnectorDataSource = list(
#'           Name = "string",
#'           ConnectionType = "string",
#'           Data = list(
#'             "string"
#'           ),
#'           OutputSchemas = list(
#'             list(
#'               Columns = list(
#'                 list(
#'                   Name = "string",
#'                   Type = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         ConnectorDataTarget = list(
#'           Name = "string",
#'           ConnectionType = "string",
#'           Data = list(
#'             "string"
#'           ),
#'           Inputs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ExecutionClass = "FLEX"|"STANDARD",
#'     SourceControlDetails = list(
#'       Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'       Repository = "string",
#'       Owner = "string",
#'       Branch = "string",
#'       Folder = "string",
#'       LastCommitId = "string",
#'       AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'       AuthToken = "string"
#'     ),
#'     MaintenanceWindow = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_job
#'
#' @aliases glue_update_job
glue_update_job <- function(JobName, JobUpdate) {
  op <- new_operation(
    name = "UpdateJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_job_input(JobName = JobName, JobUpdate = JobUpdate)
  output <- .glue$update_job_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_job <- glue_update_job

#' Synchronizes a job from the source control repository
#'
#' @description
#' Synchronizes a job from the source control repository. This operation
#' takes the job artifacts that are located in the remote repository and
#' updates the Glue internal stores with these artifacts.
#' 
#' This API supports optional parameters which take in the repository
#' information.
#'
#' @usage
#' glue_update_job_from_source_control(JobName, Provider, RepositoryName,
#'   RepositoryOwner, BranchName, Folder, CommitId, AuthStrategy, AuthToken)
#'
#' @param JobName The name of the Glue job to be synchronized to or from the remote
#' repository.
#' @param Provider The provider for the remote repository. Possible values: GITHUB,
#' AWS_CODE_COMMIT, GITLAB, BITBUCKET.
#' @param RepositoryName The name of the remote repository that contains the job artifacts. For
#' BitBucket providers, `RepositoryName` should include `WorkspaceName`.
#' Use the format `<WorkspaceName>/<RepositoryName>`.
#' @param RepositoryOwner The owner of the remote repository that contains the job artifacts.
#' @param BranchName An optional branch in the remote repository.
#' @param Folder An optional folder in the remote repository.
#' @param CommitId A commit ID for a commit in the remote repository.
#' @param AuthStrategy The type of authentication, which can be an authentication token stored
#' in Amazon Web Services Secrets Manager, or a personal access token.
#' @param AuthToken The value of the authorization token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_job_from_source_control(
#'   JobName = "string",
#'   Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'   RepositoryName = "string",
#'   RepositoryOwner = "string",
#'   BranchName = "string",
#'   Folder = "string",
#'   CommitId = "string",
#'   AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'   AuthToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_job_from_source_control
#'
#' @aliases glue_update_job_from_source_control
glue_update_job_from_source_control <- function(JobName = NULL, Provider = NULL, RepositoryName = NULL, RepositoryOwner = NULL, BranchName = NULL, Folder = NULL, CommitId = NULL, AuthStrategy = NULL, AuthToken = NULL) {
  op <- new_operation(
    name = "UpdateJobFromSourceControl",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_job_from_source_control_input(JobName = JobName, Provider = Provider, RepositoryName = RepositoryName, RepositoryOwner = RepositoryOwner, BranchName = BranchName, Folder = Folder, CommitId = CommitId, AuthStrategy = AuthStrategy, AuthToken = AuthToken)
  output <- .glue$update_job_from_source_control_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_job_from_source_control <- glue_update_job_from_source_control

#' Updates an existing machine learning transform
#'
#' @description
#' Updates an existing machine learning transform. Call this operation to
#' tune the algorithm parameters to achieve better results.
#' 
#' After calling this operation, you can call the
#' [`start_ml_evaluation_task_run`][glue_start_ml_evaluation_task_run]
#' operation to assess how well your new parameters achieved your goals
#' (such as improving the quality of your machine learning transform, or
#' making it more cost-effective).
#'
#' @usage
#' glue_update_ml_transform(TransformId, Name, Description, Parameters,
#'   Role, GlueVersion, MaxCapacity, WorkerType, NumberOfWorkers, Timeout,
#'   MaxRetries)
#'
#' @param TransformId &#91;required&#93; A unique identifier that was generated when the transform was created.
#' @param Name The unique name that you gave the transform when you created it.
#' @param Description A description of the transform. The default is an empty string.
#' @param Parameters The configuration parameters that are specific to the transform type
#' (algorithm) used. Conditionally dependent on the transform type.
#' @param Role The name or Amazon Resource Name (ARN) of the IAM role with the required
#' permissions.
#' @param GlueVersion This value determines which version of Glue this machine learning
#' transform is compatible with. Glue 1.0 is recommended for most
#' customers. If the value is not set, the Glue compatibility defaults to
#' Glue 0.9. For more information, see [Glue
#' Versions](https://docs.aws.amazon.com/glue/latest/dg/release-notes.html#release-notes-versions)
#' in the developer guide.
#' @param MaxCapacity The number of Glue data processing units (DPUs) that are allocated to
#' task runs for this transform. You can allocate from 2 to 100 DPUs; the
#' default is 10. A DPU is a relative measure of processing power that
#' consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
#' information, see the [Glue pricing
#' page](https://aws.amazon.com/glue/pricing/).
#' 
#' When the `WorkerType` field is set to a value other than `Standard`, the
#' `MaxCapacity` field is set automatically and becomes read-only.
#' @param WorkerType The type of predefined worker that is allocated when this task runs.
#' Accepts a value of Standard, G.1X, or G.2X.
#' 
#' -   For the `Standard` worker type, each worker provides 4 vCPU, 16 GB
#'     of memory and a 50GB disk, and 2 executors per worker.
#' 
#' -   For the `G.1X` worker type, each worker provides 4 vCPU, 16 GB of
#'     memory and a 64GB disk, and 1 executor per worker.
#' 
#' -   For the `G.2X` worker type, each worker provides 8 vCPU, 32 GB of
#'     memory and a 128GB disk, and 1 executor per worker.
#' @param NumberOfWorkers The number of workers of a defined `workerType` that are allocated when
#' this task runs.
#' @param Timeout The timeout for a task run for this transform in minutes. This is the
#' maximum time that a task run for this transform can consume resources
#' before it is terminated and enters `TIMEOUT` status. The default is
#' 2,880 minutes (48 hours).
#' @param MaxRetries The maximum number of times to retry a task for this transform after a
#' task run fails.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransformId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_ml_transform(
#'   TransformId = "string",
#'   Name = "string",
#'   Description = "string",
#'   Parameters = list(
#'     TransformType = "FIND_MATCHES",
#'     FindMatchesParameters = list(
#'       PrimaryKeyColumnName = "string",
#'       PrecisionRecallTradeoff = 123.0,
#'       AccuracyCostTradeoff = 123.0,
#'       EnforceProvidedLabels = TRUE|FALSE
#'     )
#'   ),
#'   Role = "string",
#'   GlueVersion = "string",
#'   MaxCapacity = 123.0,
#'   WorkerType = "Standard"|"G.1X"|"G.2X"|"G.025X"|"G.4X"|"G.8X"|"Z.2X",
#'   NumberOfWorkers = 123,
#'   Timeout = 123,
#'   MaxRetries = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_ml_transform
#'
#' @aliases glue_update_ml_transform
glue_update_ml_transform <- function(TransformId, Name = NULL, Description = NULL, Parameters = NULL, Role = NULL, GlueVersion = NULL, MaxCapacity = NULL, WorkerType = NULL, NumberOfWorkers = NULL, Timeout = NULL, MaxRetries = NULL) {
  op <- new_operation(
    name = "UpdateMLTransform",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_ml_transform_input(TransformId = TransformId, Name = Name, Description = Description, Parameters = Parameters, Role = Role, GlueVersion = GlueVersion, MaxCapacity = MaxCapacity, WorkerType = WorkerType, NumberOfWorkers = NumberOfWorkers, Timeout = Timeout, MaxRetries = MaxRetries)
  output <- .glue$update_ml_transform_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_ml_transform <- glue_update_ml_transform

#' Updates a partition
#'
#' @description
#' Updates a partition.
#'
#' @usage
#' glue_update_partition(CatalogId, DatabaseName, TableName,
#'   PartitionValueList, PartitionInput)
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be updated resides. If
#' none is provided, the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table in which the partition to be updated is located.
#' @param PartitionValueList &#91;required&#93; List of partition key values that define the partition to update.
#' @param PartitionInput &#91;required&#93; The new partition object to update the partition to.
#' 
#' The `Values` property can't be changed. If you want to change the
#' partition key values for a partition, delete and recreate the partition.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValueList = list(
#'     "string"
#'   ),
#'   PartitionInput = list(
#'     Values = list(
#'       "string"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_partition
#'
#' @aliases glue_update_partition
glue_update_partition <- function(CatalogId = NULL, DatabaseName, TableName, PartitionValueList, PartitionInput) {
  op <- new_operation(
    name = "UpdatePartition",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, PartitionValueList = PartitionValueList, PartitionInput = PartitionInput)
  output <- .glue$update_partition_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_partition <- glue_update_partition

#' Updates an existing registry which is used to hold a collection of
#' schemas
#'
#' @description
#' Updates an existing registry which is used to hold a collection of
#' schemas. The updated properties relate to the registry, and do not
#' modify any of the schemas within the registry.
#'
#' @usage
#' glue_update_registry(RegistryId, Description)
#'
#' @param RegistryId &#91;required&#93; This is a wrapper structure that may contain the registry name and
#' Amazon Resource Name (ARN).
#' @param Description &#91;required&#93; A description of the registry. If description is not provided, this
#' field will not be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RegistryName = "string",
#'   RegistryArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_registry(
#'   RegistryId = list(
#'     RegistryName = "string",
#'     RegistryArn = "string"
#'   ),
#'   Description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_registry
#'
#' @aliases glue_update_registry
glue_update_registry <- function(RegistryId, Description) {
  op <- new_operation(
    name = "UpdateRegistry",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_registry_input(RegistryId = RegistryId, Description = Description)
  output <- .glue$update_registry_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_registry <- glue_update_registry

#' Updates the description, compatibility setting, or version checkpoint
#' for a schema set
#'
#' @description
#' Updates the description, compatibility setting, or version checkpoint
#' for a schema set.
#' 
#' For updating the compatibility setting, the call will not validate
#' compatibility for the entire set of schema versions with the new
#' compatibility setting. If the value for `Compatibility` is provided, the
#' `VersionNumber` (a checkpoint) is also required. The API will validate
#' the checkpoint version number for consistency.
#' 
#' If the value for the `VersionNumber` (checkpoint) is provided,
#' `Compatibility` is optional and this can be used to set/reset a
#' checkpoint for the schema.
#' 
#' This update will happen only if the schema is in the AVAILABLE state.
#'
#' @usage
#' glue_update_schema(SchemaId, SchemaVersionNumber, Compatibility,
#'   Description)
#'
#' @param SchemaId &#91;required&#93; This is a wrapper structure to contain schema identity fields. The
#' structure contains:
#' 
#' -   SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema.
#'     One of `SchemaArn` or `SchemaName` has to be provided.
#' 
#' -   SchemaId$SchemaName: The name of the schema. One of `SchemaArn` or
#'     `SchemaName` has to be provided.
#' @param SchemaVersionNumber Version number required for check pointing. One of `VersionNumber` or
#' `Compatibility` has to be provided.
#' @param Compatibility The new compatibility setting for the schema.
#' @param Description The new description for the schema.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SchemaArn = "string",
#'   SchemaName = "string",
#'   RegistryName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_schema(
#'   SchemaId = list(
#'     SchemaArn = "string",
#'     SchemaName = "string",
#'     RegistryName = "string"
#'   ),
#'   SchemaVersionNumber = list(
#'     LatestVersion = TRUE|FALSE,
#'     VersionNumber = 123
#'   ),
#'   Compatibility = "NONE"|"DISABLED"|"BACKWARD"|"BACKWARD_ALL"|"FORWARD"|"FORWARD_ALL"|"FULL"|"FULL_ALL",
#'   Description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_schema
#'
#' @aliases glue_update_schema
glue_update_schema <- function(SchemaId, SchemaVersionNumber = NULL, Compatibility = NULL, Description = NULL) {
  op <- new_operation(
    name = "UpdateSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_schema_input(SchemaId = SchemaId, SchemaVersionNumber = SchemaVersionNumber, Compatibility = Compatibility, Description = Description)
  output <- .glue$update_schema_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_schema <- glue_update_schema

#' Synchronizes a job to the source control repository
#'
#' @description
#' Synchronizes a job to the source control repository. This operation
#' takes the job artifacts from the Glue internal stores and makes a commit
#' to the remote repository that is configured on the job.
#' 
#' This API supports optional parameters which take in the repository
#' information.
#'
#' @usage
#' glue_update_source_control_from_job(JobName, Provider, RepositoryName,
#'   RepositoryOwner, BranchName, Folder, CommitId, AuthStrategy, AuthToken)
#'
#' @param JobName The name of the Glue job to be synchronized to or from the remote
#' repository.
#' @param Provider The provider for the remote repository. Possible values: GITHUB,
#' AWS_CODE_COMMIT, GITLAB, BITBUCKET.
#' @param RepositoryName The name of the remote repository that contains the job artifacts. For
#' BitBucket providers, `RepositoryName` should include `WorkspaceName`.
#' Use the format `<WorkspaceName>/<RepositoryName>`.
#' @param RepositoryOwner The owner of the remote repository that contains the job artifacts.
#' @param BranchName An optional branch in the remote repository.
#' @param Folder An optional folder in the remote repository.
#' @param CommitId A commit ID for a commit in the remote repository.
#' @param AuthStrategy The type of authentication, which can be an authentication token stored
#' in Amazon Web Services Secrets Manager, or a personal access token.
#' @param AuthToken The value of the authorization token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   JobName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_source_control_from_job(
#'   JobName = "string",
#'   Provider = "GITHUB"|"GITLAB"|"BITBUCKET"|"AWS_CODE_COMMIT",
#'   RepositoryName = "string",
#'   RepositoryOwner = "string",
#'   BranchName = "string",
#'   Folder = "string",
#'   CommitId = "string",
#'   AuthStrategy = "PERSONAL_ACCESS_TOKEN"|"AWS_SECRETS_MANAGER",
#'   AuthToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_source_control_from_job
#'
#' @aliases glue_update_source_control_from_job
glue_update_source_control_from_job <- function(JobName = NULL, Provider = NULL, RepositoryName = NULL, RepositoryOwner = NULL, BranchName = NULL, Folder = NULL, CommitId = NULL, AuthStrategy = NULL, AuthToken = NULL) {
  op <- new_operation(
    name = "UpdateSourceControlFromJob",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_source_control_from_job_input(JobName = JobName, Provider = Provider, RepositoryName = RepositoryName, RepositoryOwner = RepositoryOwner, BranchName = BranchName, Folder = Folder, CommitId = CommitId, AuthStrategy = AuthStrategy, AuthToken = AuthToken)
  output <- .glue$update_source_control_from_job_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_source_control_from_job <- glue_update_source_control_from_job

#' Updates a metadata table in the Data Catalog
#'
#' @description
#' Updates a metadata table in the Data Catalog.
#'
#' @usage
#' glue_update_table(CatalogId, DatabaseName, TableInput, SkipArchive,
#'   TransactionId, VersionId, ViewUpdateAction, Force)
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is provided,
#' the Amazon Web Services account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table resides. For Hive
#' compatibility, this name is entirely lowercase.
#' @param TableInput &#91;required&#93; An updated `TableInput` object to define the metadata table in the
#' catalog.
#' @param SkipArchive By default, [`update_table`][glue_update_table] always creates an
#' archived version of the table before updating it. However, if
#' `skipArchive` is set to true, [`update_table`][glue_update_table] does
#' not create the archived version.
#' @param TransactionId The transaction ID at which to update the table contents.
#' @param VersionId The version ID at which to update the table contents.
#' @param ViewUpdateAction The operation to be performed when updating the view.
#' @param Force A flag that can be set to true to ignore matching storage descriptor and
#' subobject matching requirements.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableInput = list(
#'     Name = "string",
#'     Description = "string",
#'     Owner = "string",
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAnalyzedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       Location = "string",
#'       AdditionalLocations = list(
#'         "string"
#'       ),
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE,
#'       SchemaReference = list(
#'         SchemaId = list(
#'           SchemaArn = "string",
#'           SchemaName = "string",
#'           RegistryName = "string"
#'         ),
#'         SchemaVersionId = "string",
#'         SchemaVersionNumber = 123
#'       )
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     ),
#'     TargetTable = list(
#'       CatalogId = "string",
#'       DatabaseName = "string",
#'       Name = "string",
#'       Region = "string"
#'     ),
#'     ViewDefinition = list(
#'       IsProtected = TRUE|FALSE,
#'       Definer = "string",
#'       Representations = list(
#'         list(
#'           Dialect = "REDSHIFT"|"ATHENA"|"SPARK",
#'           DialectVersion = "string",
#'           ViewOriginalText = "string",
#'           ValidationConnection = "string",
#'           ViewExpandedText = "string"
#'         )
#'       ),
#'       SubObjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   SkipArchive = TRUE|FALSE,
#'   TransactionId = "string",
#'   VersionId = "string",
#'   ViewUpdateAction = "ADD"|"REPLACE"|"ADD_OR_REPLACE"|"DROP",
#'   Force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_table
#'
#' @aliases glue_update_table
glue_update_table <- function(CatalogId = NULL, DatabaseName, TableInput, SkipArchive = NULL, TransactionId = NULL, VersionId = NULL, ViewUpdateAction = NULL, Force = NULL) {
  op <- new_operation(
    name = "UpdateTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableInput = TableInput, SkipArchive = SkipArchive, TransactionId = TransactionId, VersionId = VersionId, ViewUpdateAction = ViewUpdateAction, Force = Force)
  output <- .glue$update_table_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_table <- glue_update_table

#' Updates the configuration for an existing table optimizer
#'
#' @description
#' Updates the configuration for an existing table optimizer.
#'
#' @usage
#' glue_update_table_optimizer(CatalogId, DatabaseName, TableName, Type,
#'   TableOptimizerConfiguration)
#'
#' @param CatalogId &#91;required&#93; The Catalog ID of the table.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides.
#' @param TableName &#91;required&#93; The name of the table.
#' @param Type &#91;required&#93; The type of table optimizer.
#' @param TableOptimizerConfiguration &#91;required&#93; A `TableOptimizerConfiguration` object representing the configuration of
#' a table optimizer.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_table_optimizer(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Type = "compaction"|"retention"|"orphan_file_deletion",
#'   TableOptimizerConfiguration = list(
#'     roleArn = "string",
#'     enabled = TRUE|FALSE,
#'     vpcConfiguration = list(
#'       glueConnectionName = "string"
#'     ),
#'     retentionConfiguration = list(
#'       icebergConfiguration = list(
#'         snapshotRetentionPeriodInDays = 123,
#'         numberOfSnapshotsToRetain = 123,
#'         cleanExpiredFiles = TRUE|FALSE
#'       )
#'     ),
#'     orphanFileDeletionConfiguration = list(
#'       icebergConfiguration = list(
#'         orphanFileRetentionPeriodInDays = 123,
#'         location = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_table_optimizer
#'
#' @aliases glue_update_table_optimizer
glue_update_table_optimizer <- function(CatalogId, DatabaseName, TableName, Type, TableOptimizerConfiguration) {
  op <- new_operation(
    name = "UpdateTableOptimizer",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_table_optimizer_input(CatalogId = CatalogId, DatabaseName = DatabaseName, TableName = TableName, Type = Type, TableOptimizerConfiguration = TableOptimizerConfiguration)
  output <- .glue$update_table_optimizer_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_table_optimizer <- glue_update_table_optimizer

#' Updates a trigger definition
#'
#' @description
#' Updates a trigger definition.
#' 
#' Job arguments may be logged. Do not pass plaintext secrets as arguments.
#' Retrieve secrets from a Glue Connection, Amazon Web Services Secrets
#' Manager or other secret management mechanism if you intend to keep them
#' within the Job.
#'
#' @usage
#' glue_update_trigger(Name, TriggerUpdate)
#'
#' @param Name &#91;required&#93; The name of the trigger to update.
#' @param TriggerUpdate &#91;required&#93; The new values with which to update the trigger.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Trigger = list(
#'     Name = "string",
#'     WorkflowName = "string",
#'     Id = "string",
#'     Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND"|"EVENT",
#'     State = "CREATING"|"CREATED"|"ACTIVATING"|"ACTIVATED"|"DEACTIVATING"|"DEACTIVATED"|"DELETING"|"UPDATING",
#'     Description = "string",
#'     Schedule = "string",
#'     Actions = list(
#'       list(
#'         JobName = "string",
#'         Arguments = list(
#'           "string"
#'         ),
#'         Timeout = 123,
#'         SecurityConfiguration = "string",
#'         NotificationProperty = list(
#'           NotifyDelayAfter = 123
#'         ),
#'         CrawlerName = "string"
#'       )
#'     ),
#'     Predicate = list(
#'       Logical = "AND"|"ANY",
#'       Conditions = list(
#'         list(
#'           LogicalOperator = "EQUALS",
#'           JobName = "string",
#'           State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'           CrawlerName = "string",
#'           CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'         )
#'       )
#'     ),
#'     EventBatchingCondition = list(
#'       BatchSize = 123,
#'       BatchWindow = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_trigger(
#'   Name = "string",
#'   TriggerUpdate = list(
#'     Name = "string",
#'     Description = "string",
#'     Schedule = "string",
#'     Actions = list(
#'       list(
#'         JobName = "string",
#'         Arguments = list(
#'           "string"
#'         ),
#'         Timeout = 123,
#'         SecurityConfiguration = "string",
#'         NotificationProperty = list(
#'           NotifyDelayAfter = 123
#'         ),
#'         CrawlerName = "string"
#'       )
#'     ),
#'     Predicate = list(
#'       Logical = "AND"|"ANY",
#'       Conditions = list(
#'         list(
#'           LogicalOperator = "EQUALS",
#'           JobName = "string",
#'           State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"|"ERROR"|"WAITING"|"EXPIRED",
#'           CrawlerName = "string",
#'           CrawlState = "RUNNING"|"CANCELLING"|"CANCELLED"|"SUCCEEDED"|"FAILED"|"ERROR"
#'         )
#'       )
#'     ),
#'     EventBatchingCondition = list(
#'       BatchSize = 123,
#'       BatchWindow = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_trigger
#'
#' @aliases glue_update_trigger
glue_update_trigger <- function(Name, TriggerUpdate) {
  op <- new_operation(
    name = "UpdateTrigger",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_trigger_input(Name = Name, TriggerUpdate = TriggerUpdate)
  output <- .glue$update_trigger_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_trigger <- glue_update_trigger

#' Update an Glue usage profile
#'
#' @description
#' Update an Glue usage profile.
#'
#' @usage
#' glue_update_usage_profile(Name, Description, Configuration)
#'
#' @param Name &#91;required&#93; The name of the usage profile.
#' @param Description A description of the usage profile.
#' @param Configuration &#91;required&#93; A `ProfileConfiguration` object specifying the job and session values
#' for the profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_usage_profile(
#'   Name = "string",
#'   Description = "string",
#'   Configuration = list(
#'     SessionConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     ),
#'     JobConfiguration = list(
#'       list(
#'         DefaultValue = "string",
#'         AllowedValues = list(
#'           "string"
#'         ),
#'         MinValue = "string",
#'         MaxValue = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_usage_profile
#'
#' @aliases glue_update_usage_profile
glue_update_usage_profile <- function(Name, Description = NULL, Configuration) {
  op <- new_operation(
    name = "UpdateUsageProfile",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_usage_profile_input(Name = Name, Description = Description, Configuration = Configuration)
  output <- .glue$update_usage_profile_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_usage_profile <- glue_update_usage_profile

#' Updates an existing function definition in the Data Catalog
#'
#' @description
#' Updates an existing function definition in the Data Catalog.
#'
#' @usage
#' glue_update_user_defined_function(CatalogId, DatabaseName, FunctionName,
#'   FunctionInput)
#'
#' @param CatalogId The ID of the Data Catalog where the function to be updated is located.
#' If none is provided, the Amazon Web Services account ID is used by
#' default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function to be updated is
#' located.
#' @param FunctionName &#91;required&#93; The name of the function.
#' @param FunctionInput &#91;required&#93; A `FunctionInput` object that redefines the function in the Data
#' Catalog.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string",
#'   FunctionInput = list(
#'     FunctionName = "string",
#'     ClassName = "string",
#'     OwnerName = "string",
#'     OwnerType = "USER"|"ROLE"|"GROUP",
#'     ResourceUris = list(
#'       list(
#'         ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'         Uri = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_user_defined_function
#'
#' @aliases glue_update_user_defined_function
glue_update_user_defined_function <- function(CatalogId = NULL, DatabaseName, FunctionName, FunctionInput) {
  op <- new_operation(
    name = "UpdateUserDefinedFunction",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_user_defined_function_input(CatalogId = CatalogId, DatabaseName = DatabaseName, FunctionName = FunctionName, FunctionInput = FunctionInput)
  output <- .glue$update_user_defined_function_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_user_defined_function <- glue_update_user_defined_function

#' Updates an existing workflow
#'
#' @description
#' Updates an existing workflow.
#'
#' @usage
#' glue_update_workflow(Name, Description, DefaultRunProperties,
#'   MaxConcurrentRuns)
#'
#' @param Name &#91;required&#93; Name of the workflow to be updated.
#' @param Description The description of the workflow.
#' @param DefaultRunProperties A collection of properties to be used as part of each execution of the
#' workflow.
#' 
#' Run properties may be logged. Do not pass plaintext secrets as
#' properties. Retrieve secrets from a Glue Connection, Amazon Web Services
#' Secrets Manager or other secret management mechanism if you intend to
#' use them within the workflow run.
#' @param MaxConcurrentRuns You can use this parameter to prevent unwanted multiple updates to data,
#' to control costs, or in some cases, to prevent exceeding the maximum
#' number of concurrent runs of any of the component jobs. If you leave
#' this parameter blank, there is no limit to the number of concurrent
#' workflow runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Name = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_workflow(
#'   Name = "string",
#'   Description = "string",
#'   DefaultRunProperties = list(
#'     "string"
#'   ),
#'   MaxConcurrentRuns = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname glue_update_workflow
#'
#' @aliases glue_update_workflow
glue_update_workflow <- function(Name, Description = NULL, DefaultRunProperties = NULL, MaxConcurrentRuns = NULL) {
  op <- new_operation(
    name = "UpdateWorkflow",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .glue$update_workflow_input(Name = Name, Description = Description, DefaultRunProperties = DefaultRunProperties, MaxConcurrentRuns = MaxConcurrentRuns)
  output <- .glue$update_workflow_output()
  config <- get_config()
  svc <- .glue$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.glue$operations$update_workflow <- glue_update_workflow

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include accessanalyzer_service.R
NULL

#' Retroactively applies the archive rule to existing findings that meet
#' the archive rule criteria
#'
#' @description
#' Retroactively applies the archive rule to existing findings that meet
#' the archive rule criteria.
#'
#' @usage
#' accessanalyzer_apply_archive_rule(analyzerArn, ruleName, clientToken)
#'
#' @param analyzerArn &#91;required&#93; The Amazon resource name (ARN) of the analyzer.
#' @param ruleName &#91;required&#93; The name of the rule to apply.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$apply_archive_rule(
#'   analyzerArn = "string",
#'   ruleName = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_apply_archive_rule
#'
#' @aliases accessanalyzer_apply_archive_rule
accessanalyzer_apply_archive_rule <- function(analyzerArn, ruleName, clientToken = NULL) {
  op <- new_operation(
    name = "ApplyArchiveRule",
    http_method = "PUT",
    http_path = "/archive-rule",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$apply_archive_rule_input(analyzerArn = analyzerArn, ruleName = ruleName, clientToken = clientToken)
  output <- .accessanalyzer$apply_archive_rule_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$apply_archive_rule <- accessanalyzer_apply_archive_rule

#' Cancels the requested policy generation
#'
#' @description
#' Cancels the requested policy generation.
#'
#' @usage
#' accessanalyzer_cancel_policy_generation(jobId)
#'
#' @param jobId &#91;required&#93; The `JobId` that is returned by the
#' [`start_policy_generation`][accessanalyzer_start_policy_generation]
#' operation. The `JobId` can be used with
#' [`get_generated_policy`][accessanalyzer_get_generated_policy] to
#' retrieve the generated policies or used with
#' [`cancel_policy_generation`][accessanalyzer_cancel_policy_generation] to
#' cancel the policy generation request.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_policy_generation(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_cancel_policy_generation
#'
#' @aliases accessanalyzer_cancel_policy_generation
accessanalyzer_cancel_policy_generation <- function(jobId) {
  op <- new_operation(
    name = "CancelPolicyGeneration",
    http_method = "PUT",
    http_path = "/policy/generation/{jobId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$cancel_policy_generation_input(jobId = jobId)
  output <- .accessanalyzer$cancel_policy_generation_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$cancel_policy_generation <- accessanalyzer_cancel_policy_generation

#' Checks whether the specified access isn't allowed by a policy
#'
#' @description
#' Checks whether the specified access isn't allowed by a policy.
#'
#' @usage
#' accessanalyzer_check_access_not_granted(policyDocument, access,
#'   policyType)
#'
#' @param policyDocument &#91;required&#93; The JSON policy document to use as the content for the policy.
#' @param access &#91;required&#93; An access object containing the permissions that shouldn't be granted by
#' the specified policy. If only actions are specified, IAM Access Analyzer
#' checks for access to peform at least one of the actions on any resource
#' in the policy. If only resources are specified, then IAM Access Analyzer
#' checks for access to perform any action on at least one of the
#' resources. If both actions and resources are specified, IAM Access
#' Analyzer checks for access to perform at least one of the specified
#' actions on at least one of the specified resources.
#' @param policyType &#91;required&#93; The type of policy. Identity policies grant permissions to IAM
#' principals. Identity policies include managed and inline policies for
#' IAM roles, users, and groups.
#' 
#' Resource policies grant permissions on Amazon Web Services resources.
#' Resource policies include trust policies for IAM roles and bucket
#' policies for Amazon S3 buckets.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   result = "PASS"|"FAIL",
#'   message = "string",
#'   reasons = list(
#'     list(
#'       description = "string",
#'       statementIndex = 123,
#'       statementId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$check_access_not_granted(
#'   policyDocument = "string",
#'   access = list(
#'     list(
#'       actions = list(
#'         "string"
#'       ),
#'       resources = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   policyType = "IDENTITY_POLICY"|"RESOURCE_POLICY"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_check_access_not_granted
#'
#' @aliases accessanalyzer_check_access_not_granted
accessanalyzer_check_access_not_granted <- function(policyDocument, access, policyType) {
  op <- new_operation(
    name = "CheckAccessNotGranted",
    http_method = "POST",
    http_path = "/policy/check-access-not-granted",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$check_access_not_granted_input(policyDocument = policyDocument, access = access, policyType = policyType)
  output <- .accessanalyzer$check_access_not_granted_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$check_access_not_granted <- accessanalyzer_check_access_not_granted

#' Checks whether new access is allowed for an updated policy when compared
#' to the existing policy
#'
#' @description
#' Checks whether new access is allowed for an updated policy when compared
#' to the existing policy.
#' 
#' You can find examples for reference policies and learn how to set up and
#' run a custom policy check for new access in the [IAM Access Analyzer
#' custom policy checks
#' samples](https://github.com/aws-samples/iam-access-analyzer-custom-policy-check-samples)
#' repository on GitHub. The reference policies in this repository are
#' meant to be passed to the `existingPolicyDocument` request parameter.
#'
#' @usage
#' accessanalyzer_check_no_new_access(newPolicyDocument,
#'   existingPolicyDocument, policyType)
#'
#' @param newPolicyDocument &#91;required&#93; The JSON policy document to use as the content for the updated policy.
#' @param existingPolicyDocument &#91;required&#93; The JSON policy document to use as the content for the existing policy.
#' @param policyType &#91;required&#93; The type of policy to compare. Identity policies grant permissions to
#' IAM principals. Identity policies include managed and inline policies
#' for IAM roles, users, and groups.
#' 
#' Resource policies grant permissions on Amazon Web Services resources.
#' Resource policies include trust policies for IAM roles and bucket
#' policies for Amazon S3 buckets. You can provide a generic input such as
#' identity policy or resource policy or a specific input such as managed
#' policy or Amazon S3 bucket policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   result = "PASS"|"FAIL",
#'   message = "string",
#'   reasons = list(
#'     list(
#'       description = "string",
#'       statementIndex = 123,
#'       statementId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$check_no_new_access(
#'   newPolicyDocument = "string",
#'   existingPolicyDocument = "string",
#'   policyType = "IDENTITY_POLICY"|"RESOURCE_POLICY"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_check_no_new_access
#'
#' @aliases accessanalyzer_check_no_new_access
accessanalyzer_check_no_new_access <- function(newPolicyDocument, existingPolicyDocument, policyType) {
  op <- new_operation(
    name = "CheckNoNewAccess",
    http_method = "POST",
    http_path = "/policy/check-no-new-access",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$check_no_new_access_input(newPolicyDocument = newPolicyDocument, existingPolicyDocument = existingPolicyDocument, policyType = policyType)
  output <- .accessanalyzer$check_no_new_access_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$check_no_new_access <- accessanalyzer_check_no_new_access

#' Checks whether a resource policy can grant public access to the
#' specified resource type
#'
#' @description
#' Checks whether a resource policy can grant public access to the
#' specified resource type.
#'
#' @usage
#' accessanalyzer_check_no_public_access(policyDocument, resourceType)
#'
#' @param policyDocument &#91;required&#93; The JSON policy document to evaluate for public access.
#' @param resourceType &#91;required&#93; The type of resource to evaluate for public access. For example, to
#' check for public access to Amazon S3 buckets, you can choose
#' `AWS::S3::Bucket` for the resource type.
#' 
#' For resource types not supported as valid values, IAM Access Analyzer
#' will return an error.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   result = "PASS"|"FAIL",
#'   message = "string",
#'   reasons = list(
#'     list(
#'       description = "string",
#'       statementIndex = 123,
#'       statementId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$check_no_public_access(
#'   policyDocument = "string",
#'   resourceType = "AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::EFS::FileSystem"|"AWS::OpenSearchService::Domain"|"AWS::Kinesis::Stream"|"AWS::Kinesis::StreamConsumer"|"AWS::KMS::Key"|"AWS::Lambda::Function"|"AWS::S3::Bucket"|"AWS::S3::AccessPoint"|"AWS::S3Express::DirectoryBucket"|"AWS::S3::Glacier"|"AWS::S3Outposts::Bucket"|"AWS::S3Outposts::AccessPoint"|"AWS::SecretsManager::Secret"|"AWS::SNS::Topic"|"AWS::SQS::Queue"|"AWS::IAM::AssumeRolePolicyDocument"|"AWS::S3Tables::TableBucket"|"AWS::ApiGateway::RestApi"|"AWS::CodeArtifact::Domain"|"AWS::Backup::BackupVault"|"AWS::CloudTrail::Dashboard"|"AWS::CloudTrail::EventDataStore"|"AWS::S3Tables::Table"|"AWS::S3Express::AccessPoint"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_check_no_public_access
#'
#' @aliases accessanalyzer_check_no_public_access
accessanalyzer_check_no_public_access <- function(policyDocument, resourceType) {
  op <- new_operation(
    name = "CheckNoPublicAccess",
    http_method = "POST",
    http_path = "/policy/check-no-public-access",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$check_no_public_access_input(policyDocument = policyDocument, resourceType = resourceType)
  output <- .accessanalyzer$check_no_public_access_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$check_no_public_access <- accessanalyzer_check_no_public_access

#' Creates an access preview that allows you to preview IAM Access Analyzer
#' findings for your resource before deploying resource permissions
#'
#' @description
#' Creates an access preview that allows you to preview IAM Access Analyzer
#' findings for your resource before deploying resource permissions.
#'
#' @usage
#' accessanalyzer_create_access_preview(analyzerArn, configurations,
#'   clientToken)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the account
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the access preview. You can only create an access
#' preview for analyzers with an `Account` type and `Active` status.
#' @param configurations &#91;required&#93; Access control configuration for your resource that is used to generate
#' the access preview. The access preview includes findings for external
#' access allowed to the resource with the proposed access control
#' configuration. The configuration must contain exactly one element.
#' @param clientToken A client token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_access_preview(
#'   analyzerArn = "string",
#'   configurations = list(
#'     list(
#'       ebsSnapshot = list(
#'         userIds = list(
#'           "string"
#'         ),
#'         groups = list(
#'           "string"
#'         ),
#'         kmsKeyId = "string"
#'       ),
#'       ecrRepository = list(
#'         repositoryPolicy = "string"
#'       ),
#'       iamRole = list(
#'         trustPolicy = "string"
#'       ),
#'       efsFileSystem = list(
#'         fileSystemPolicy = "string"
#'       ),
#'       kmsKey = list(
#'         keyPolicies = list(
#'           "string"
#'         ),
#'         grants = list(
#'           list(
#'             operations = list(
#'               "CreateGrant"|"Decrypt"|"DescribeKey"|"Encrypt"|"GenerateDataKey"|"GenerateDataKeyPair"|"GenerateDataKeyPairWithoutPlaintext"|"GenerateDataKeyWithoutPlaintext"|"GetPublicKey"|"ReEncryptFrom"|"ReEncryptTo"|"RetireGrant"|"Sign"|"Verify"
#'             ),
#'             granteePrincipal = "string",
#'             retiringPrincipal = "string",
#'             constraints = list(
#'               encryptionContextEquals = list(
#'                 "string"
#'               ),
#'               encryptionContextSubset = list(
#'                 "string"
#'               )
#'             ),
#'             issuingAccount = "string"
#'           )
#'         )
#'       ),
#'       rdsDbClusterSnapshot = list(
#'         attributes = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         kmsKeyId = "string"
#'       ),
#'       rdsDbSnapshot = list(
#'         attributes = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         kmsKeyId = "string"
#'       ),
#'       secretsManagerSecret = list(
#'         kmsKeyId = "string",
#'         secretPolicy = "string"
#'       ),
#'       s3Bucket = list(
#'         bucketPolicy = "string",
#'         bucketAclGrants = list(
#'           list(
#'             permission = "READ"|"WRITE"|"READ_ACP"|"WRITE_ACP"|"FULL_CONTROL",
#'             grantee = list(
#'               id = "string",
#'               uri = "string"
#'             )
#'           )
#'         ),
#'         bucketPublicAccessBlock = list(
#'           ignorePublicAcls = TRUE|FALSE,
#'           restrictPublicBuckets = TRUE|FALSE
#'         ),
#'         accessPoints = list(
#'           list(
#'             accessPointPolicy = "string",
#'             publicAccessBlock = list(
#'               ignorePublicAcls = TRUE|FALSE,
#'               restrictPublicBuckets = TRUE|FALSE
#'             ),
#'             networkOrigin = list(
#'               vpcConfiguration = list(
#'                 vpcId = "string"
#'               ),
#'               internetConfiguration = list()
#'             )
#'           )
#'         )
#'       ),
#'       snsTopic = list(
#'         topicPolicy = "string"
#'       ),
#'       sqsQueue = list(
#'         queuePolicy = "string"
#'       ),
#'       s3ExpressDirectoryBucket = list(
#'         bucketPolicy = "string",
#'         accessPoints = list(
#'           list(
#'             accessPointPolicy = "string",
#'             networkOrigin = list(
#'               vpcConfiguration = list(
#'                 vpcId = "string"
#'               ),
#'               internetConfiguration = list()
#'             )
#'           )
#'         )
#'       ),
#'       dynamodbStream = list(
#'         streamPolicy = "string"
#'       ),
#'       dynamodbTable = list(
#'         tablePolicy = "string"
#'       )
#'     )
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_create_access_preview
#'
#' @aliases accessanalyzer_create_access_preview
accessanalyzer_create_access_preview <- function(analyzerArn, configurations, clientToken = NULL) {
  op <- new_operation(
    name = "CreateAccessPreview",
    http_method = "PUT",
    http_path = "/access-preview",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$create_access_preview_input(analyzerArn = analyzerArn, configurations = configurations, clientToken = clientToken)
  output <- .accessanalyzer$create_access_preview_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$create_access_preview <- accessanalyzer_create_access_preview

#' Creates an analyzer for your account
#'
#' @description
#' Creates an analyzer for your account.
#'
#' @usage
#' accessanalyzer_create_analyzer(analyzerName, type, archiveRules, tags,
#'   clientToken, configuration)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to create.
#' @param type &#91;required&#93; The type of analyzer to create. You can create only one analyzer per
#' account per Region. You can create up to 5 analyzers per organization
#' per Region.
#' @param archiveRules Specifies the archive rules to add for the analyzer. Archive rules
#' automatically archive findings that meet the criteria you define for the
#' rule.
#' @param tags An array of key-value pairs to apply to the analyzer. You can use the
#' set of Unicode letters, digits, whitespace, `_`, `.`, `/`, `=`, `+`, and
#' `-`.
#' 
#' For the tag key, you can specify a value that is 1 to 128 characters in
#' length and cannot be prefixed with `aws:`.
#' 
#' For the tag value, you can specify a value that is 0 to 256 characters
#' in length.
#' @param clientToken A client token.
#' @param configuration Specifies the configuration of the analyzer. If the analyzer is an
#' unused access analyzer, the specified scope of unused access is used for
#' the configuration. If the analyzer is an internal access analyzer, the
#' specified internal access analysis rules are used for the configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_analyzer(
#'   analyzerName = "string",
#'   type = "ACCOUNT"|"ORGANIZATION"|"ACCOUNT_UNUSED_ACCESS"|"ORGANIZATION_UNUSED_ACCESS"|"ACCOUNT_INTERNAL_ACCESS"|"ORGANIZATION_INTERNAL_ACCESS",
#'   archiveRules = list(
#'     list(
#'       ruleName = "string",
#'       filter = list(
#'         list(
#'           eq = list(
#'             "string"
#'           ),
#'           neq = list(
#'             "string"
#'           ),
#'           contains = list(
#'             "string"
#'           ),
#'           exists = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientToken = "string",
#'   configuration = list(
#'     unusedAccess = list(
#'       unusedAccessAge = 123,
#'       analysisRule = list(
#'         exclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTags = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     internalAccess = list(
#'       analysisRule = list(
#'         inclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTypes = list(
#'               "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'             ),
#'             resourceArns = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_create_analyzer
#'
#' @aliases accessanalyzer_create_analyzer
accessanalyzer_create_analyzer <- function(analyzerName, type, archiveRules = NULL, tags = NULL, clientToken = NULL, configuration = NULL) {
  op <- new_operation(
    name = "CreateAnalyzer",
    http_method = "PUT",
    http_path = "/analyzer",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$create_analyzer_input(analyzerName = analyzerName, type = type, archiveRules = archiveRules, tags = tags, clientToken = clientToken, configuration = configuration)
  output <- .accessanalyzer$create_analyzer_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$create_analyzer <- accessanalyzer_create_analyzer

#' Creates an archive rule for the specified analyzer
#'
#' @description
#' Creates an archive rule for the specified analyzer. Archive rules
#' automatically archive new findings that meet the criteria you define
#' when you create the rule.
#' 
#' To learn about filter keys that you can use to create an archive rule,
#' see [IAM Access Analyzer filter
#' keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html)
#' in the **IAM User Guide**.
#'
#' @usage
#' accessanalyzer_create_archive_rule(analyzerName, ruleName, filter,
#'   clientToken)
#'
#' @param analyzerName &#91;required&#93; The name of the created analyzer.
#' @param ruleName &#91;required&#93; The name of the rule to create.
#' @param filter &#91;required&#93; The criteria for the rule.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_archive_rule(
#'   analyzerName = "string",
#'   ruleName = "string",
#'   filter = list(
#'     list(
#'       eq = list(
#'         "string"
#'       ),
#'       neq = list(
#'         "string"
#'       ),
#'       contains = list(
#'         "string"
#'       ),
#'       exists = TRUE|FALSE
#'     )
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_create_archive_rule
#'
#' @aliases accessanalyzer_create_archive_rule
accessanalyzer_create_archive_rule <- function(analyzerName, ruleName, filter, clientToken = NULL) {
  op <- new_operation(
    name = "CreateArchiveRule",
    http_method = "PUT",
    http_path = "/analyzer/{analyzerName}/archive-rule",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$create_archive_rule_input(analyzerName = analyzerName, ruleName = ruleName, filter = filter, clientToken = clientToken)
  output <- .accessanalyzer$create_archive_rule_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$create_archive_rule <- accessanalyzer_create_archive_rule

#' Deletes the specified analyzer
#'
#' @description
#' Deletes the specified analyzer. When you delete an analyzer, IAM Access
#' Analyzer is disabled for the account or organization in the current or
#' specific Region. All findings that were generated by the analyzer are
#' deleted. You cannot undo this action.
#'
#' @usage
#' accessanalyzer_delete_analyzer(analyzerName, clientToken)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to delete.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_analyzer(
#'   analyzerName = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_delete_analyzer
#'
#' @aliases accessanalyzer_delete_analyzer
accessanalyzer_delete_analyzer <- function(analyzerName, clientToken = NULL) {
  op <- new_operation(
    name = "DeleteAnalyzer",
    http_method = "DELETE",
    http_path = "/analyzer/{analyzerName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$delete_analyzer_input(analyzerName = analyzerName, clientToken = clientToken)
  output <- .accessanalyzer$delete_analyzer_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$delete_analyzer <- accessanalyzer_delete_analyzer

#' Deletes the specified archive rule
#'
#' @description
#' Deletes the specified archive rule.
#'
#' @usage
#' accessanalyzer_delete_archive_rule(analyzerName, ruleName, clientToken)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer that associated with the archive rule to
#' delete.
#' @param ruleName &#91;required&#93; The name of the rule to delete.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_archive_rule(
#'   analyzerName = "string",
#'   ruleName = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_delete_archive_rule
#'
#' @aliases accessanalyzer_delete_archive_rule
accessanalyzer_delete_archive_rule <- function(analyzerName, ruleName, clientToken = NULL) {
  op <- new_operation(
    name = "DeleteArchiveRule",
    http_method = "DELETE",
    http_path = "/analyzer/{analyzerName}/archive-rule/{ruleName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$delete_archive_rule_input(analyzerName = analyzerName, ruleName = ruleName, clientToken = clientToken)
  output <- .accessanalyzer$delete_archive_rule_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$delete_archive_rule <- accessanalyzer_delete_archive_rule

#' Creates a recommendation for an unused permissions finding
#'
#' @description
#' Creates a recommendation for an unused permissions finding.
#'
#' @usage
#' accessanalyzer_generate_finding_recommendation(analyzerArn, id)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the finding recommendation.
#' @param id &#91;required&#93; The unique ID for the finding recommendation.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$generate_finding_recommendation(
#'   analyzerArn = "string",
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_generate_finding_recommendation
#'
#' @aliases accessanalyzer_generate_finding_recommendation
accessanalyzer_generate_finding_recommendation <- function(analyzerArn, id) {
  op <- new_operation(
    name = "GenerateFindingRecommendation",
    http_method = "POST",
    http_path = "/recommendation/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$generate_finding_recommendation_input(analyzerArn = analyzerArn, id = id)
  output <- .accessanalyzer$generate_finding_recommendation_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$generate_finding_recommendation <- accessanalyzer_generate_finding_recommendation

#' Retrieves information about an access preview for the specified analyzer
#'
#' @description
#' Retrieves information about an access preview for the specified
#' analyzer.
#'
#' @usage
#' accessanalyzer_get_access_preview(accessPreviewId, analyzerArn)
#'
#' @param accessPreviewId &#91;required&#93; The unique ID for the access preview.
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the access preview.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessPreview = list(
#'     id = "string",
#'     analyzerArn = "string",
#'     configurations = list(
#'       list(
#'         ebsSnapshot = list(
#'           userIds = list(
#'             "string"
#'           ),
#'           groups = list(
#'             "string"
#'           ),
#'           kmsKeyId = "string"
#'         ),
#'         ecrRepository = list(
#'           repositoryPolicy = "string"
#'         ),
#'         iamRole = list(
#'           trustPolicy = "string"
#'         ),
#'         efsFileSystem = list(
#'           fileSystemPolicy = "string"
#'         ),
#'         kmsKey = list(
#'           keyPolicies = list(
#'             "string"
#'           ),
#'           grants = list(
#'             list(
#'               operations = list(
#'                 "CreateGrant"|"Decrypt"|"DescribeKey"|"Encrypt"|"GenerateDataKey"|"GenerateDataKeyPair"|"GenerateDataKeyPairWithoutPlaintext"|"GenerateDataKeyWithoutPlaintext"|"GetPublicKey"|"ReEncryptFrom"|"ReEncryptTo"|"RetireGrant"|"Sign"|"Verify"
#'               ),
#'               granteePrincipal = "string",
#'               retiringPrincipal = "string",
#'               constraints = list(
#'                 encryptionContextEquals = list(
#'                   "string"
#'                 ),
#'                 encryptionContextSubset = list(
#'                   "string"
#'                 )
#'               ),
#'               issuingAccount = "string"
#'             )
#'           )
#'         ),
#'         rdsDbClusterSnapshot = list(
#'           attributes = list(
#'             list(
#'               accountIds = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           kmsKeyId = "string"
#'         ),
#'         rdsDbSnapshot = list(
#'           attributes = list(
#'             list(
#'               accountIds = list(
#'                 "string"
#'               )
#'             )
#'           ),
#'           kmsKeyId = "string"
#'         ),
#'         secretsManagerSecret = list(
#'           kmsKeyId = "string",
#'           secretPolicy = "string"
#'         ),
#'         s3Bucket = list(
#'           bucketPolicy = "string",
#'           bucketAclGrants = list(
#'             list(
#'               permission = "READ"|"WRITE"|"READ_ACP"|"WRITE_ACP"|"FULL_CONTROL",
#'               grantee = list(
#'                 id = "string",
#'                 uri = "string"
#'               )
#'             )
#'           ),
#'           bucketPublicAccessBlock = list(
#'             ignorePublicAcls = TRUE|FALSE,
#'             restrictPublicBuckets = TRUE|FALSE
#'           ),
#'           accessPoints = list(
#'             list(
#'               accessPointPolicy = "string",
#'               publicAccessBlock = list(
#'                 ignorePublicAcls = TRUE|FALSE,
#'                 restrictPublicBuckets = TRUE|FALSE
#'               ),
#'               networkOrigin = list(
#'                 vpcConfiguration = list(
#'                   vpcId = "string"
#'                 ),
#'                 internetConfiguration = list()
#'               )
#'             )
#'           )
#'         ),
#'         snsTopic = list(
#'           topicPolicy = "string"
#'         ),
#'         sqsQueue = list(
#'           queuePolicy = "string"
#'         ),
#'         s3ExpressDirectoryBucket = list(
#'           bucketPolicy = "string",
#'           accessPoints = list(
#'             list(
#'               accessPointPolicy = "string",
#'               networkOrigin = list(
#'                 vpcConfiguration = list(
#'                   vpcId = "string"
#'                 ),
#'                 internetConfiguration = list()
#'               )
#'             )
#'           )
#'         ),
#'         dynamodbStream = list(
#'           streamPolicy = "string"
#'         ),
#'         dynamodbTable = list(
#'           tablePolicy = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "COMPLETED"|"CREATING"|"FAILED",
#'     statusReason = list(
#'       code = "INTERNAL_ERROR"|"INVALID_CONFIGURATION"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_access_preview(
#'   accessPreviewId = "string",
#'   analyzerArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_access_preview
#'
#' @aliases accessanalyzer_get_access_preview
accessanalyzer_get_access_preview <- function(accessPreviewId, analyzerArn) {
  op <- new_operation(
    name = "GetAccessPreview",
    http_method = "GET",
    http_path = "/access-preview/{accessPreviewId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_access_preview_input(accessPreviewId = accessPreviewId, analyzerArn = analyzerArn)
  output <- .accessanalyzer$get_access_preview_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_access_preview <- accessanalyzer_get_access_preview

#' Retrieves information about a resource that was analyzed
#'
#' @description
#' Retrieves information about a resource that was analyzed.
#' 
#' This action is supported only for external access analyzers.
#'
#' @usage
#' accessanalyzer_get_analyzed_resource(analyzerArn, resourceArn)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' to retrieve information from.
#' @param resourceArn &#91;required&#93; The ARN of the resource to retrieve information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   resource = list(
#'     resourceArn = "string",
#'     resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     analyzedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     isPublic = TRUE|FALSE,
#'     actions = list(
#'       "string"
#'     ),
#'     sharedVia = list(
#'       "string"
#'     ),
#'     status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'     resourceOwnerAccount = "string",
#'     error = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_analyzed_resource(
#'   analyzerArn = "string",
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_analyzed_resource
#'
#' @aliases accessanalyzer_get_analyzed_resource
accessanalyzer_get_analyzed_resource <- function(analyzerArn, resourceArn) {
  op <- new_operation(
    name = "GetAnalyzedResource",
    http_method = "GET",
    http_path = "/analyzed-resource",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_analyzed_resource_input(analyzerArn = analyzerArn, resourceArn = resourceArn)
  output <- .accessanalyzer$get_analyzed_resource_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_analyzed_resource <- accessanalyzer_get_analyzed_resource

#' Retrieves information about the specified analyzer
#'
#' @description
#' Retrieves information about the specified analyzer.
#'
#' @usage
#' accessanalyzer_get_analyzer(analyzerName)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   analyzer = list(
#'     arn = "string",
#'     name = "string",
#'     type = "ACCOUNT"|"ORGANIZATION"|"ACCOUNT_UNUSED_ACCESS"|"ORGANIZATION_UNUSED_ACCESS"|"ACCOUNT_INTERNAL_ACCESS"|"ORGANIZATION_INTERNAL_ACCESS",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     lastResourceAnalyzed = "string",
#'     lastResourceAnalyzedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     status = "ACTIVE"|"CREATING"|"DISABLED"|"FAILED",
#'     statusReason = list(
#'       code = "AWS_SERVICE_ACCESS_DISABLED"|"DELEGATED_ADMINISTRATOR_DEREGISTERED"|"ORGANIZATION_DELETED"|"SERVICE_LINKED_ROLE_CREATION_FAILED"
#'     ),
#'     configuration = list(
#'       unusedAccess = list(
#'         unusedAccessAge = 123,
#'         analysisRule = list(
#'           exclusions = list(
#'             list(
#'               accountIds = list(
#'                 "string"
#'               ),
#'               resourceTags = list(
#'                 list(
#'                   "string"
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       internalAccess = list(
#'         analysisRule = list(
#'           inclusions = list(
#'             list(
#'               accountIds = list(
#'                 "string"
#'               ),
#'               resourceTypes = list(
#'                 "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'               ),
#'               resourceArns = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_analyzer(
#'   analyzerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_analyzer
#'
#' @aliases accessanalyzer_get_analyzer
accessanalyzer_get_analyzer <- function(analyzerName) {
  op <- new_operation(
    name = "GetAnalyzer",
    http_method = "GET",
    http_path = "/analyzer/{analyzerName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_analyzer_input(analyzerName = analyzerName)
  output <- .accessanalyzer$get_analyzer_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_analyzer <- accessanalyzer_get_analyzer

#' Retrieves information about an archive rule
#'
#' @description
#' Retrieves information about an archive rule.
#' 
#' To learn about filter keys that you can use to create an archive rule,
#' see [IAM Access Analyzer filter
#' keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html)
#' in the **IAM User Guide**.
#'
#' @usage
#' accessanalyzer_get_archive_rule(analyzerName, ruleName)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to retrieve rules from.
#' @param ruleName &#91;required&#93; The name of the rule to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   archiveRule = list(
#'     ruleName = "string",
#'     filter = list(
#'       list(
#'         eq = list(
#'           "string"
#'         ),
#'         neq = list(
#'           "string"
#'         ),
#'         contains = list(
#'           "string"
#'         ),
#'         exists = TRUE|FALSE
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_archive_rule(
#'   analyzerName = "string",
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_archive_rule
#'
#' @aliases accessanalyzer_get_archive_rule
accessanalyzer_get_archive_rule <- function(analyzerName, ruleName) {
  op <- new_operation(
    name = "GetArchiveRule",
    http_method = "GET",
    http_path = "/analyzer/{analyzerName}/archive-rule/{ruleName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_archive_rule_input(analyzerName = analyzerName, ruleName = ruleName)
  output <- .accessanalyzer$get_archive_rule_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_archive_rule <- accessanalyzer_get_archive_rule

#' Retrieves information about the specified finding
#'
#' @description
#' Retrieves information about the specified finding. GetFinding and
#' GetFindingV2 both use `access-analyzer:GetFinding` in the `Action`
#' element of an IAM policy statement. You must have permission to perform
#' the `access-analyzer:GetFinding` action.
#' 
#' GetFinding is supported only for external access analyzers. You must use
#' GetFindingV2 for internal and unused access analyzers.
#'
#' @usage
#' accessanalyzer_get_finding(analyzerArn, id)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' that generated the finding.
#' @param id &#91;required&#93; The ID of the finding to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   finding = list(
#'     id = "string",
#'     principal = list(
#'       "string"
#'     ),
#'     action = list(
#'       "string"
#'     ),
#'     resource = "string",
#'     isPublic = TRUE|FALSE,
#'     resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'     condition = list(
#'       "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     analyzedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'     resourceOwnerAccount = "string",
#'     error = "string",
#'     sources = list(
#'       list(
#'         type = "POLICY"|"BUCKET_ACL"|"S3_ACCESS_POINT"|"S3_ACCESS_POINT_ACCOUNT",
#'         detail = list(
#'           accessPointArn = "string",
#'           accessPointAccount = "string"
#'         )
#'       )
#'     ),
#'     resourceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_RCP"|"NOT_APPLICABLE"|"APPLIED"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_finding(
#'   analyzerArn = "string",
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_finding
#'
#' @aliases accessanalyzer_get_finding
accessanalyzer_get_finding <- function(analyzerArn, id) {
  op <- new_operation(
    name = "GetFinding",
    http_method = "GET",
    http_path = "/finding/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_finding_input(analyzerArn = analyzerArn, id = id)
  output <- .accessanalyzer$get_finding_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_finding <- accessanalyzer_get_finding

#' Retrieves information about a finding recommendation for the specified
#' analyzer
#'
#' @description
#' Retrieves information about a finding recommendation for the specified
#' analyzer.
#'
#' @usage
#' accessanalyzer_get_finding_recommendation(analyzerArn, id, maxResults,
#'   nextToken)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the finding recommendation.
#' @param id &#91;required&#93; The unique ID for the finding recommendation.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken A token used for pagination of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   completedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   nextToken = "string",
#'   error = list(
#'     code = "string",
#'     message = "string"
#'   ),
#'   resourceArn = "string",
#'   recommendedSteps = list(
#'     list(
#'       unusedPermissionsRecommendedStep = list(
#'         policyUpdatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         recommendedAction = "CREATE_POLICY"|"DETACH_POLICY",
#'         recommendedPolicy = "string",
#'         existingPolicyId = "string"
#'       )
#'     )
#'   ),
#'   recommendationType = "UnusedPermissionRecommendation",
#'   status = "SUCCEEDED"|"FAILED"|"IN_PROGRESS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_finding_recommendation(
#'   analyzerArn = "string",
#'   id = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_finding_recommendation
#'
#' @aliases accessanalyzer_get_finding_recommendation
accessanalyzer_get_finding_recommendation <- function(analyzerArn, id, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "GetFindingRecommendation",
    http_method = "GET",
    http_path = "/recommendation/{id}",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "recommendedSteps"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_finding_recommendation_input(analyzerArn = analyzerArn, id = id, maxResults = maxResults, nextToken = nextToken)
  output <- .accessanalyzer$get_finding_recommendation_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_finding_recommendation <- accessanalyzer_get_finding_recommendation

#' Retrieves information about the specified finding
#'
#' @description
#' Retrieves information about the specified finding. GetFinding and
#' GetFindingV2 both use `access-analyzer:GetFinding` in the `Action`
#' element of an IAM policy statement. You must have permission to perform
#' the `access-analyzer:GetFinding` action.
#'
#' @usage
#' accessanalyzer_get_finding_v2(analyzerArn, id, maxResults, nextToken)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' that generated the finding.
#' @param id &#91;required&#93; The ID of the finding to retrieve.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken A token used for pagination of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   analyzedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   error = "string",
#'   id = "string",
#'   nextToken = "string",
#'   resource = "string",
#'   resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'   resourceOwnerAccount = "string",
#'   status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   findingDetails = list(
#'     list(
#'       internalAccessDetails = list(
#'         action = list(
#'           "string"
#'         ),
#'         condition = list(
#'           "string"
#'         ),
#'         principal = list(
#'           "string"
#'         ),
#'         principalOwnerAccount = "string",
#'         accessType = "INTRA_ACCOUNT"|"INTRA_ORG",
#'         principalType = "IAM_ROLE"|"IAM_USER",
#'         sources = list(
#'           list(
#'             type = "POLICY"|"BUCKET_ACL"|"S3_ACCESS_POINT"|"S3_ACCESS_POINT_ACCOUNT",
#'             detail = list(
#'               accessPointArn = "string",
#'               accessPointAccount = "string"
#'             )
#'           )
#'         ),
#'         resourceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_RCP"|"NOT_APPLICABLE"|"APPLIED",
#'         serviceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_SCP"|"NOT_APPLICABLE"|"APPLIED"
#'       ),
#'       externalAccessDetails = list(
#'         action = list(
#'           "string"
#'         ),
#'         condition = list(
#'           "string"
#'         ),
#'         isPublic = TRUE|FALSE,
#'         principal = list(
#'           "string"
#'         ),
#'         sources = list(
#'           list(
#'             type = "POLICY"|"BUCKET_ACL"|"S3_ACCESS_POINT"|"S3_ACCESS_POINT_ACCOUNT",
#'             detail = list(
#'               accessPointArn = "string",
#'               accessPointAccount = "string"
#'             )
#'           )
#'         ),
#'         resourceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_RCP"|"NOT_APPLICABLE"|"APPLIED"
#'       ),
#'       unusedPermissionDetails = list(
#'         actions = list(
#'           list(
#'             action = "string",
#'             lastAccessed = as.POSIXct(
#'               "2015-01-01"
#'             )
#'           )
#'         ),
#'         serviceNamespace = "string",
#'         lastAccessed = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       unusedIamUserAccessKeyDetails = list(
#'         accessKeyId = "string",
#'         lastAccessed = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       unusedIamRoleDetails = list(
#'         lastAccessed = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       unusedIamUserPasswordDetails = list(
#'         lastAccessed = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   ),
#'   findingType = "ExternalAccess"|"UnusedIAMRole"|"UnusedIAMUserAccessKey"|"UnusedIAMUserPassword"|"UnusedPermission"|"InternalAccess"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_finding_v2(
#'   analyzerArn = "string",
#'   id = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_finding_v2
#'
#' @aliases accessanalyzer_get_finding_v2
accessanalyzer_get_finding_v2 <- function(analyzerArn, id, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "GetFindingV2",
    http_method = "GET",
    http_path = "/findingv2/{id}",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "findingDetails"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_finding_v2_input(analyzerArn = analyzerArn, id = id, maxResults = maxResults, nextToken = nextToken)
  output <- .accessanalyzer$get_finding_v2_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_finding_v2 <- accessanalyzer_get_finding_v2

#' Retrieves a list of aggregated finding statistics for an external access
#' or unused access analyzer
#'
#' @description
#' Retrieves a list of aggregated finding statistics for an external access
#' or unused access analyzer.
#'
#' @usage
#' accessanalyzer_get_findings_statistics(analyzerArn)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the statistics.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   findingsStatistics = list(
#'     list(
#'       externalAccessFindingsStatistics = list(
#'         resourceTypeStatistics = list(
#'           list(
#'             totalActivePublic = 123,
#'             totalActiveCrossAccount = 123,
#'             totalActiveErrors = 123
#'           )
#'         ),
#'         totalActiveFindings = 123,
#'         totalArchivedFindings = 123,
#'         totalResolvedFindings = 123
#'       ),
#'       internalAccessFindingsStatistics = list(
#'         resourceTypeStatistics = list(
#'           list(
#'             totalActiveFindings = 123,
#'             totalResolvedFindings = 123,
#'             totalArchivedFindings = 123
#'           )
#'         ),
#'         totalActiveFindings = 123,
#'         totalArchivedFindings = 123,
#'         totalResolvedFindings = 123
#'       ),
#'       unusedAccessFindingsStatistics = list(
#'         unusedAccessTypeStatistics = list(
#'           list(
#'             unusedAccessType = "string",
#'             total = 123
#'           )
#'         ),
#'         topAccounts = list(
#'           list(
#'             account = "string",
#'             numberOfActiveFindings = 123,
#'             details = list(
#'               123
#'             )
#'           )
#'         ),
#'         totalActiveFindings = 123,
#'         totalArchivedFindings = 123,
#'         totalResolvedFindings = 123
#'       )
#'     )
#'   ),
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_findings_statistics(
#'   analyzerArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_findings_statistics
#'
#' @aliases accessanalyzer_get_findings_statistics
accessanalyzer_get_findings_statistics <- function(analyzerArn) {
  op <- new_operation(
    name = "GetFindingsStatistics",
    http_method = "POST",
    http_path = "/analyzer/findings/statistics",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_findings_statistics_input(analyzerArn = analyzerArn)
  output <- .accessanalyzer$get_findings_statistics_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_findings_statistics <- accessanalyzer_get_findings_statistics

#' Retrieves the policy that was generated using StartPolicyGeneration
#'
#' @description
#' Retrieves the policy that was generated using
#' [`start_policy_generation`][accessanalyzer_start_policy_generation].
#'
#' @usage
#' accessanalyzer_get_generated_policy(jobId, includeResourcePlaceholders,
#'   includeServiceLevelTemplate)
#'
#' @param jobId &#91;required&#93; The `JobId` that is returned by the
#' [`start_policy_generation`][accessanalyzer_start_policy_generation]
#' operation. The `JobId` can be used with
#' [`get_generated_policy`][accessanalyzer_get_generated_policy] to
#' retrieve the generated policies or used with
#' [`cancel_policy_generation`][accessanalyzer_cancel_policy_generation] to
#' cancel the policy generation request.
#' @param includeResourcePlaceholders The level of detail that you want to generate. You can specify whether
#' to generate policies with placeholders for resource ARNs for actions
#' that support resource level granularity in policies.
#' 
#' For example, in the resource section of a policy, you can receive a
#' placeholder such as `"Resource":"arn:aws:s3:::${BucketName}"` instead of
#' `"*"`.
#' @param includeServiceLevelTemplate The level of detail that you want to generate. You can specify whether
#' to generate service-level policies.
#' 
#' IAM Access Analyzer uses `iam:servicelastaccessed` to identify services
#' that have been used recently to create this service-level template.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobDetails = list(
#'     jobId = "string",
#'     status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"CANCELED",
#'     startedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     completedOn = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     jobError = list(
#'       code = "AUTHORIZATION_ERROR"|"RESOURCE_NOT_FOUND_ERROR"|"SERVICE_QUOTA_EXCEEDED_ERROR"|"SERVICE_ERROR",
#'       message = "string"
#'     )
#'   ),
#'   generatedPolicyResult = list(
#'     properties = list(
#'       isComplete = TRUE|FALSE,
#'       principalArn = "string",
#'       cloudTrailProperties = list(
#'         trailProperties = list(
#'           list(
#'             cloudTrailArn = "string",
#'             regions = list(
#'               "string"
#'             ),
#'             allRegions = TRUE|FALSE
#'           )
#'         ),
#'         startTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         endTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     ),
#'     generatedPolicies = list(
#'       list(
#'         policy = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_generated_policy(
#'   jobId = "string",
#'   includeResourcePlaceholders = TRUE|FALSE,
#'   includeServiceLevelTemplate = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_get_generated_policy
#'
#' @aliases accessanalyzer_get_generated_policy
accessanalyzer_get_generated_policy <- function(jobId, includeResourcePlaceholders = NULL, includeServiceLevelTemplate = NULL) {
  op <- new_operation(
    name = "GetGeneratedPolicy",
    http_method = "GET",
    http_path = "/policy/generation/{jobId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$get_generated_policy_input(jobId = jobId, includeResourcePlaceholders = includeResourcePlaceholders, includeServiceLevelTemplate = includeServiceLevelTemplate)
  output <- .accessanalyzer$get_generated_policy_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$get_generated_policy <- accessanalyzer_get_generated_policy

#' Retrieves a list of access preview findings generated by the specified
#' access preview
#'
#' @description
#' Retrieves a list of access preview findings generated by the specified
#' access preview.
#'
#' @usage
#' accessanalyzer_list_access_preview_findings(accessPreviewId,
#'   analyzerArn, filter, nextToken, maxResults)
#'
#' @param accessPreviewId &#91;required&#93; The unique ID for the access preview.
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the access.
#' @param filter Criteria to filter the returned findings.
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   findings = list(
#'     list(
#'       id = "string",
#'       existingFindingId = "string",
#'       existingFindingStatus = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'       principal = list(
#'         "string"
#'       ),
#'       action = list(
#'         "string"
#'       ),
#'       condition = list(
#'         "string"
#'       ),
#'       resource = "string",
#'       isPublic = TRUE|FALSE,
#'       resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       changeType = "CHANGED"|"NEW"|"UNCHANGED",
#'       status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'       resourceOwnerAccount = "string",
#'       error = "string",
#'       sources = list(
#'         list(
#'           type = "POLICY"|"BUCKET_ACL"|"S3_ACCESS_POINT"|"S3_ACCESS_POINT_ACCOUNT",
#'           detail = list(
#'             accessPointArn = "string",
#'             accessPointAccount = "string"
#'           )
#'         )
#'       ),
#'       resourceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_RCP"|"NOT_APPLICABLE"|"APPLIED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_access_preview_findings(
#'   accessPreviewId = "string",
#'   analyzerArn = "string",
#'   filter = list(
#'     list(
#'       eq = list(
#'         "string"
#'       ),
#'       neq = list(
#'         "string"
#'       ),
#'       contains = list(
#'         "string"
#'       ),
#'       exists = TRUE|FALSE
#'     )
#'   ),
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_access_preview_findings
#'
#' @aliases accessanalyzer_list_access_preview_findings
accessanalyzer_list_access_preview_findings <- function(accessPreviewId, analyzerArn, filter = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAccessPreviewFindings",
    http_method = "POST",
    http_path = "/access-preview/{accessPreviewId}",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "findings"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_access_preview_findings_input(accessPreviewId = accessPreviewId, analyzerArn = analyzerArn, filter = filter, nextToken = nextToken, maxResults = maxResults)
  output <- .accessanalyzer$list_access_preview_findings_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_access_preview_findings <- accessanalyzer_list_access_preview_findings

#' Retrieves a list of access previews for the specified analyzer
#'
#' @description
#' Retrieves a list of access previews for the specified analyzer.
#'
#' @usage
#' accessanalyzer_list_access_previews(analyzerArn, nextToken, maxResults)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' used to generate the access preview.
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessPreviews = list(
#'     list(
#'       id = "string",
#'       analyzerArn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "COMPLETED"|"CREATING"|"FAILED",
#'       statusReason = list(
#'         code = "INTERNAL_ERROR"|"INVALID_CONFIGURATION"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_access_previews(
#'   analyzerArn = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_access_previews
#'
#' @aliases accessanalyzer_list_access_previews
accessanalyzer_list_access_previews <- function(analyzerArn, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAccessPreviews",
    http_method = "GET",
    http_path = "/access-preview",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "accessPreviews"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_access_previews_input(analyzerArn = analyzerArn, nextToken = nextToken, maxResults = maxResults)
  output <- .accessanalyzer$list_access_previews_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_access_previews <- accessanalyzer_list_access_previews

#' Retrieves a list of resources of the specified type that have been
#' analyzed by the specified analyzer
#'
#' @description
#' Retrieves a list of resources of the specified type that have been
#' analyzed by the specified analyzer.
#'
#' @usage
#' accessanalyzer_list_analyzed_resources(analyzerArn, resourceType,
#'   nextToken, maxResults)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' to retrieve a list of analyzed resources from.
#' @param resourceType The type of resource.
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   analyzedResources = list(
#'     list(
#'       resourceArn = "string",
#'       resourceOwnerAccount = "string",
#'       resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_analyzed_resources(
#'   analyzerArn = "string",
#'   resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_analyzed_resources
#'
#' @aliases accessanalyzer_list_analyzed_resources
accessanalyzer_list_analyzed_resources <- function(analyzerArn, resourceType = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAnalyzedResources",
    http_method = "POST",
    http_path = "/analyzed-resource",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "analyzedResources"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_analyzed_resources_input(analyzerArn = analyzerArn, resourceType = resourceType, nextToken = nextToken, maxResults = maxResults)
  output <- .accessanalyzer$list_analyzed_resources_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_analyzed_resources <- accessanalyzer_list_analyzed_resources

#' Retrieves a list of analyzers
#'
#' @description
#' Retrieves a list of analyzers.
#'
#' @usage
#' accessanalyzer_list_analyzers(nextToken, maxResults, type)
#'
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the response.
#' @param type The type of analyzer.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   analyzers = list(
#'     list(
#'       arn = "string",
#'       name = "string",
#'       type = "ACCOUNT"|"ORGANIZATION"|"ACCOUNT_UNUSED_ACCESS"|"ORGANIZATION_UNUSED_ACCESS"|"ACCOUNT_INTERNAL_ACCESS"|"ORGANIZATION_INTERNAL_ACCESS",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastResourceAnalyzed = "string",
#'       lastResourceAnalyzedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       status = "ACTIVE"|"CREATING"|"DISABLED"|"FAILED",
#'       statusReason = list(
#'         code = "AWS_SERVICE_ACCESS_DISABLED"|"DELEGATED_ADMINISTRATOR_DEREGISTERED"|"ORGANIZATION_DELETED"|"SERVICE_LINKED_ROLE_CREATION_FAILED"
#'       ),
#'       configuration = list(
#'         unusedAccess = list(
#'           unusedAccessAge = 123,
#'           analysisRule = list(
#'             exclusions = list(
#'               list(
#'                 accountIds = list(
#'                   "string"
#'                 ),
#'                 resourceTags = list(
#'                   list(
#'                     "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         internalAccess = list(
#'           analysisRule = list(
#'             inclusions = list(
#'               list(
#'                 accountIds = list(
#'                   "string"
#'                 ),
#'                 resourceTypes = list(
#'                   "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'                 ),
#'                 resourceArns = list(
#'                   "string"
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_analyzers(
#'   nextToken = "string",
#'   maxResults = 123,
#'   type = "ACCOUNT"|"ORGANIZATION"|"ACCOUNT_UNUSED_ACCESS"|"ORGANIZATION_UNUSED_ACCESS"|"ACCOUNT_INTERNAL_ACCESS"|"ORGANIZATION_INTERNAL_ACCESS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_analyzers
#'
#' @aliases accessanalyzer_list_analyzers
accessanalyzer_list_analyzers <- function(nextToken = NULL, maxResults = NULL, type = NULL) {
  op <- new_operation(
    name = "ListAnalyzers",
    http_method = "GET",
    http_path = "/analyzer",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "analyzers"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_analyzers_input(nextToken = nextToken, maxResults = maxResults, type = type)
  output <- .accessanalyzer$list_analyzers_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_analyzers <- accessanalyzer_list_analyzers

#' Retrieves a list of archive rules created for the specified analyzer
#'
#' @description
#' Retrieves a list of archive rules created for the specified analyzer.
#'
#' @usage
#' accessanalyzer_list_archive_rules(analyzerName, nextToken, maxResults)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to retrieve rules from.
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   archiveRules = list(
#'     list(
#'       ruleName = "string",
#'       filter = list(
#'         list(
#'           eq = list(
#'             "string"
#'           ),
#'           neq = list(
#'             "string"
#'           ),
#'           contains = list(
#'             "string"
#'           ),
#'           exists = TRUE|FALSE
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_archive_rules(
#'   analyzerName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_archive_rules
#'
#' @aliases accessanalyzer_list_archive_rules
accessanalyzer_list_archive_rules <- function(analyzerName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListArchiveRules",
    http_method = "GET",
    http_path = "/analyzer/{analyzerName}/archive-rule",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "archiveRules"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_archive_rules_input(analyzerName = analyzerName, nextToken = nextToken, maxResults = maxResults)
  output <- .accessanalyzer$list_archive_rules_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_archive_rules <- accessanalyzer_list_archive_rules

#' Retrieves a list of findings generated by the specified analyzer
#'
#' @description
#' Retrieves a list of findings generated by the specified analyzer.
#' ListFindings and ListFindingsV2 both use `access-analyzer:ListFindings`
#' in the `Action` element of an IAM policy statement. You must have
#' permission to perform the `access-analyzer:ListFindings` action.
#' 
#' To learn about filter keys that you can use to retrieve a list of
#' findings, see [IAM Access Analyzer filter
#' keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html)
#' in the **IAM User Guide**.
#' 
#' ListFindings is supported only for external access analyzers. You must
#' use ListFindingsV2 for internal and unused access analyzers.
#'
#' @usage
#' accessanalyzer_list_findings(analyzerArn, filter, sort, nextToken,
#'   maxResults)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' to retrieve findings from.
#' @param filter A filter to match for the findings to return.
#' @param sort The sort order for the findings returned.
#' @param nextToken A token used for pagination of results returned.
#' @param maxResults The maximum number of results to return in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   findings = list(
#'     list(
#'       id = "string",
#'       principal = list(
#'         "string"
#'       ),
#'       action = list(
#'         "string"
#'       ),
#'       resource = "string",
#'       isPublic = TRUE|FALSE,
#'       resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'       condition = list(
#'         "string"
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       analyzedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'       resourceOwnerAccount = "string",
#'       error = "string",
#'       sources = list(
#'         list(
#'           type = "POLICY"|"BUCKET_ACL"|"S3_ACCESS_POINT"|"S3_ACCESS_POINT_ACCOUNT",
#'           detail = list(
#'             accessPointArn = "string",
#'             accessPointAccount = "string"
#'           )
#'         )
#'       ),
#'       resourceControlPolicyRestriction = "APPLICABLE"|"FAILED_TO_EVALUATE_RCP"|"NOT_APPLICABLE"|"APPLIED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_findings(
#'   analyzerArn = "string",
#'   filter = list(
#'     list(
#'       eq = list(
#'         "string"
#'       ),
#'       neq = list(
#'         "string"
#'       ),
#'       contains = list(
#'         "string"
#'       ),
#'       exists = TRUE|FALSE
#'     )
#'   ),
#'   sort = list(
#'     attributeName = "string",
#'     orderBy = "ASC"|"DESC"
#'   ),
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_findings
#'
#' @aliases accessanalyzer_list_findings
accessanalyzer_list_findings <- function(analyzerArn, filter = NULL, sort = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListFindings",
    http_method = "POST",
    http_path = "/finding",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "findings"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_findings_input(analyzerArn = analyzerArn, filter = filter, sort = sort, nextToken = nextToken, maxResults = maxResults)
  output <- .accessanalyzer$list_findings_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_findings <- accessanalyzer_list_findings

#' Retrieves a list of findings generated by the specified analyzer
#'
#' @description
#' Retrieves a list of findings generated by the specified analyzer.
#' ListFindings and ListFindingsV2 both use `access-analyzer:ListFindings`
#' in the `Action` element of an IAM policy statement. You must have
#' permission to perform the `access-analyzer:ListFindings` action.
#' 
#' To learn about filter keys that you can use to retrieve a list of
#' findings, see [IAM Access Analyzer filter
#' keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html)
#' in the **IAM User Guide**.
#'
#' @usage
#' accessanalyzer_list_findings_v2(analyzerArn, filter, maxResults,
#'   nextToken, sort)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' to retrieve findings from.
#' @param filter A filter to match for the findings to return.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken A token used for pagination of results returned.
#' @param sort 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   findings = list(
#'     list(
#'       analyzedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       error = "string",
#'       id = "string",
#'       resource = "string",
#'       resourceType = "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User",
#'       resourceOwnerAccount = "string",
#'       status = "ACTIVE"|"ARCHIVED"|"RESOLVED",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       findingType = "ExternalAccess"|"UnusedIAMRole"|"UnusedIAMUserAccessKey"|"UnusedIAMUserPassword"|"UnusedPermission"|"InternalAccess"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_findings_v2(
#'   analyzerArn = "string",
#'   filter = list(
#'     list(
#'       eq = list(
#'         "string"
#'       ),
#'       neq = list(
#'         "string"
#'       ),
#'       contains = list(
#'         "string"
#'       ),
#'       exists = TRUE|FALSE
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   sort = list(
#'     attributeName = "string",
#'     orderBy = "ASC"|"DESC"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_findings_v2
#'
#' @aliases accessanalyzer_list_findings_v2
accessanalyzer_list_findings_v2 <- function(analyzerArn, filter = NULL, maxResults = NULL, nextToken = NULL, sort = NULL) {
  op <- new_operation(
    name = "ListFindingsV2",
    http_method = "POST",
    http_path = "/findingv2",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "findings"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_findings_v2_input(analyzerArn = analyzerArn, filter = filter, maxResults = maxResults, nextToken = nextToken, sort = sort)
  output <- .accessanalyzer$list_findings_v2_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_findings_v2 <- accessanalyzer_list_findings_v2

#' Lists all of the policy generations requested in the last seven days
#'
#' @description
#' Lists all of the policy generations requested in the last seven days.
#'
#' @usage
#' accessanalyzer_list_policy_generations(principalArn, maxResults,
#'   nextToken)
#'
#' @param principalArn The ARN of the IAM entity (user or role) for which you are generating a
#' policy. Use this with `ListGeneratedPolicies` to filter the results to
#' only include results for a specific principal.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken A token used for pagination of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyGenerations = list(
#'     list(
#'       jobId = "string",
#'       principalArn = "string",
#'       status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"CANCELED",
#'       startedOn = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       completedOn = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_generations(
#'   principalArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_policy_generations
#'
#' @aliases accessanalyzer_list_policy_generations
accessanalyzer_list_policy_generations <- function(principalArn = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListPolicyGenerations",
    http_method = "GET",
    http_path = "/policy/generation",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "policyGenerations"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_policy_generations_input(principalArn = principalArn, maxResults = maxResults, nextToken = nextToken)
  output <- .accessanalyzer$list_policy_generations_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_policy_generations <- accessanalyzer_list_policy_generations

#' Retrieves a list of tags applied to the specified resource
#'
#' @description
#' Retrieves a list of tags applied to the specified resource.
#'
#' @usage
#' accessanalyzer_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to retrieve tags from.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_list_tags_for_resource
#'
#' @aliases accessanalyzer_list_tags_for_resource
accessanalyzer_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .accessanalyzer$list_tags_for_resource_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$list_tags_for_resource <- accessanalyzer_list_tags_for_resource

#' Starts the policy generation request
#'
#' @description
#' Starts the policy generation request.
#'
#' @usage
#' accessanalyzer_start_policy_generation(policyGenerationDetails,
#'   cloudTrailDetails, clientToken)
#'
#' @param policyGenerationDetails &#91;required&#93; Contains the ARN of the IAM entity (user or role) for which you are
#' generating a policy.
#' @param cloudTrailDetails A `CloudTrailDetails` object that contains details about a `Trail` that
#' you want to analyze to generate policies.
#' @param clientToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Idempotency ensures that an API request
#' completes only once. With an idempotent request, if the original request
#' completes successfully, the subsequent retries with the same client
#' token return the result from the original successful request and they
#' have no additional effect.
#' 
#' If you do not specify a client token, one is automatically generated by
#' the Amazon Web Services SDK.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_policy_generation(
#'   policyGenerationDetails = list(
#'     principalArn = "string"
#'   ),
#'   cloudTrailDetails = list(
#'     trails = list(
#'       list(
#'         cloudTrailArn = "string",
#'         regions = list(
#'           "string"
#'         ),
#'         allRegions = TRUE|FALSE
#'       )
#'     ),
#'     accessRole = "string",
#'     startTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_start_policy_generation
#'
#' @aliases accessanalyzer_start_policy_generation
accessanalyzer_start_policy_generation <- function(policyGenerationDetails, cloudTrailDetails = NULL, clientToken = NULL) {
  op <- new_operation(
    name = "StartPolicyGeneration",
    http_method = "PUT",
    http_path = "/policy/generation",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$start_policy_generation_input(policyGenerationDetails = policyGenerationDetails, cloudTrailDetails = cloudTrailDetails, clientToken = clientToken)
  output <- .accessanalyzer$start_policy_generation_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$start_policy_generation <- accessanalyzer_start_policy_generation

#' Immediately starts a scan of the policies applied to the specified
#' resource
#'
#' @description
#' Immediately starts a scan of the policies applied to the specified
#' resource.
#' 
#' This action is supported only for external access analyzers.
#'
#' @usage
#' accessanalyzer_start_resource_scan(analyzerArn, resourceArn,
#'   resourceOwnerAccount)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' to use to scan the policies applied to the specified resource.
#' @param resourceArn &#91;required&#93; The ARN of the resource to scan.
#' @param resourceOwnerAccount The Amazon Web Services account ID that owns the resource. For most
#' Amazon Web Services resources, the owning account is the account in
#' which the resource was created.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_resource_scan(
#'   analyzerArn = "string",
#'   resourceArn = "string",
#'   resourceOwnerAccount = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_start_resource_scan
#'
#' @aliases accessanalyzer_start_resource_scan
accessanalyzer_start_resource_scan <- function(analyzerArn, resourceArn, resourceOwnerAccount = NULL) {
  op <- new_operation(
    name = "StartResourceScan",
    http_method = "POST",
    http_path = "/resource/scan",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$start_resource_scan_input(analyzerArn = analyzerArn, resourceArn = resourceArn, resourceOwnerAccount = resourceOwnerAccount)
  output <- .accessanalyzer$start_resource_scan_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$start_resource_scan <- accessanalyzer_start_resource_scan

#' Adds a tag to the specified resource
#'
#' @description
#' Adds a tag to the specified resource.
#'
#' @usage
#' accessanalyzer_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to add the tag to.
#' @param tags &#91;required&#93; The tags to add to the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_tag_resource
#'
#' @aliases accessanalyzer_tag_resource
accessanalyzer_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .accessanalyzer$tag_resource_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$tag_resource <- accessanalyzer_tag_resource

#' Removes a tag from the specified resource
#'
#' @description
#' Removes a tag from the specified resource.
#'
#' @usage
#' accessanalyzer_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to remove the tag from.
#' @param tagKeys &#91;required&#93; The key for the tag to add.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_untag_resource
#'
#' @aliases accessanalyzer_untag_resource
accessanalyzer_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .accessanalyzer$untag_resource_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$untag_resource <- accessanalyzer_untag_resource

#' Modifies the configuration of an existing analyzer
#'
#' @description
#' Modifies the configuration of an existing analyzer.
#' 
#' This action is not supported for external access analyzers.
#'
#' @usage
#' accessanalyzer_update_analyzer(analyzerName, configuration)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to modify.
#' @param configuration 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   configuration = list(
#'     unusedAccess = list(
#'       unusedAccessAge = 123,
#'       analysisRule = list(
#'         exclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTags = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     internalAccess = list(
#'       analysisRule = list(
#'         inclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTypes = list(
#'               "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'             ),
#'             resourceArns = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_analyzer(
#'   analyzerName = "string",
#'   configuration = list(
#'     unusedAccess = list(
#'       unusedAccessAge = 123,
#'       analysisRule = list(
#'         exclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTags = list(
#'               list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     internalAccess = list(
#'       analysisRule = list(
#'         inclusions = list(
#'           list(
#'             accountIds = list(
#'               "string"
#'             ),
#'             resourceTypes = list(
#'               "AWS::S3::Bucket"|"AWS::IAM::Role"|"AWS::SQS::Queue"|"AWS::Lambda::Function"|"AWS::Lambda::LayerVersion"|"AWS::KMS::Key"|"AWS::SecretsManager::Secret"|"AWS::EFS::FileSystem"|"AWS::EC2::Snapshot"|"AWS::ECR::Repository"|"AWS::RDS::DBSnapshot"|"AWS::RDS::DBClusterSnapshot"|"AWS::SNS::Topic"|"AWS::S3Express::DirectoryBucket"|"AWS::DynamoDB::Table"|"AWS::DynamoDB::Stream"|"AWS::IAM::User"
#'             ),
#'             resourceArns = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_update_analyzer
#'
#' @aliases accessanalyzer_update_analyzer
accessanalyzer_update_analyzer <- function(analyzerName, configuration = NULL) {
  op <- new_operation(
    name = "UpdateAnalyzer",
    http_method = "PUT",
    http_path = "/analyzer/{analyzerName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$update_analyzer_input(analyzerName = analyzerName, configuration = configuration)
  output <- .accessanalyzer$update_analyzer_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$update_analyzer <- accessanalyzer_update_analyzer

#' Updates the criteria and values for the specified archive rule
#'
#' @description
#' Updates the criteria and values for the specified archive rule.
#'
#' @usage
#' accessanalyzer_update_archive_rule(analyzerName, ruleName, filter,
#'   clientToken)
#'
#' @param analyzerName &#91;required&#93; The name of the analyzer to update the archive rules for.
#' @param ruleName &#91;required&#93; The name of the rule to update.
#' @param filter &#91;required&#93; A filter to match for the rules to update. Only rules that match the
#' filter are updated.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_archive_rule(
#'   analyzerName = "string",
#'   ruleName = "string",
#'   filter = list(
#'     list(
#'       eq = list(
#'         "string"
#'       ),
#'       neq = list(
#'         "string"
#'       ),
#'       contains = list(
#'         "string"
#'       ),
#'       exists = TRUE|FALSE
#'     )
#'   ),
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_update_archive_rule
#'
#' @aliases accessanalyzer_update_archive_rule
accessanalyzer_update_archive_rule <- function(analyzerName, ruleName, filter, clientToken = NULL) {
  op <- new_operation(
    name = "UpdateArchiveRule",
    http_method = "PUT",
    http_path = "/analyzer/{analyzerName}/archive-rule/{ruleName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$update_archive_rule_input(analyzerName = analyzerName, ruleName = ruleName, filter = filter, clientToken = clientToken)
  output <- .accessanalyzer$update_archive_rule_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$update_archive_rule <- accessanalyzer_update_archive_rule

#' Updates the status for the specified findings
#'
#' @description
#' Updates the status for the specified findings.
#'
#' @usage
#' accessanalyzer_update_findings(analyzerArn, status, ids, resourceArn,
#'   clientToken)
#'
#' @param analyzerArn &#91;required&#93; The [ARN of the
#' analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources)
#' that generated the findings to update.
#' @param status &#91;required&#93; The state represents the action to take to update the finding Status.
#' Use `ARCHIVE` to change an Active finding to an Archived finding. Use
#' `ACTIVE` to change an Archived finding to an Active finding.
#' @param ids The IDs of the findings to update.
#' @param resourceArn The ARN of the resource identified in the finding.
#' @param clientToken A client token.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_findings(
#'   analyzerArn = "string",
#'   status = "ACTIVE"|"ARCHIVED",
#'   ids = list(
#'     "string"
#'   ),
#'   resourceArn = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_update_findings
#'
#' @aliases accessanalyzer_update_findings
accessanalyzer_update_findings <- function(analyzerArn, status, ids = NULL, resourceArn = NULL, clientToken = NULL) {
  op <- new_operation(
    name = "UpdateFindings",
    http_method = "PUT",
    http_path = "/finding",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .accessanalyzer$update_findings_input(analyzerArn = analyzerArn, status = status, ids = ids, resourceArn = resourceArn, clientToken = clientToken)
  output <- .accessanalyzer$update_findings_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$update_findings <- accessanalyzer_update_findings

#' Requests the validation of a policy and returns a list of findings
#'
#' @description
#' Requests the validation of a policy and returns a list of findings. The
#' findings help you identify issues and provide actionable recommendations
#' to resolve the issue and enable you to author functional policies that
#' meet security best practices.
#'
#' @usage
#' accessanalyzer_validate_policy(locale, maxResults, nextToken,
#'   policyDocument, policyType, validatePolicyResourceType)
#'
#' @param locale The locale to use for localizing the findings.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken A token used for pagination of results returned.
#' @param policyDocument &#91;required&#93; The JSON policy document to use as the content for the policy.
#' @param policyType &#91;required&#93; The type of policy to validate. Identity policies grant permissions to
#' IAM principals. Identity policies include managed and inline policies
#' for IAM roles, users, and groups.
#' 
#' Resource policies grant permissions on Amazon Web Services resources.
#' Resource policies include trust policies for IAM roles and bucket
#' policies for Amazon S3 buckets. You can provide a generic input such as
#' identity policy or resource policy or a specific input such as managed
#' policy or Amazon S3 bucket policy.
#' 
#' Service control policies (SCPs) are a type of organization policy
#' attached to an Amazon Web Services organization, organizational unit
#' (OU), or an account.
#' @param validatePolicyResourceType The type of resource to attach to your resource policy. Specify a value
#' for the policy validation resource type only if the policy type is
#' `RESOURCE_POLICY`. For example, to validate a resource policy to attach
#' to an Amazon S3 bucket, you can choose `AWS::S3::Bucket` for the policy
#' validation resource type.
#' 
#' For resource types not supported as valid values, IAM Access Analyzer
#' runs policy checks that apply to all resource policies. For example, to
#' validate a resource policy to attach to a KMS key, do not specify a
#' value for the policy validation resource type and IAM Access Analyzer
#' will run policy checks that apply to all resource policies.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   findings = list(
#'     list(
#'       findingDetails = "string",
#'       findingType = "ERROR"|"SECURITY_WARNING"|"SUGGESTION"|"WARNING",
#'       issueCode = "string",
#'       learnMoreLink = "string",
#'       locations = list(
#'         list(
#'           path = list(
#'             list(
#'               index = 123,
#'               key = "string",
#'               substring = list(
#'                 start = 123,
#'                 length = 123
#'               ),
#'               value = "string"
#'             )
#'           ),
#'           span = list(
#'             start = list(
#'               line = 123,
#'               column = 123,
#'               offset = 123
#'             ),
#'             end = list(
#'               line = 123,
#'               column = 123,
#'               offset = 123
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$validate_policy(
#'   locale = "DE"|"EN"|"ES"|"FR"|"IT"|"JA"|"KO"|"PT_BR"|"ZH_CN"|"ZH_TW",
#'   maxResults = 123,
#'   nextToken = "string",
#'   policyDocument = "string",
#'   policyType = "IDENTITY_POLICY"|"RESOURCE_POLICY"|"SERVICE_CONTROL_POLICY"|"RESOURCE_CONTROL_POLICY",
#'   validatePolicyResourceType = "AWS::S3::Bucket"|"AWS::S3::AccessPoint"|"AWS::S3::MultiRegionAccessPoint"|"AWS::S3ObjectLambda::AccessPoint"|"AWS::IAM::AssumeRolePolicyDocument"|"AWS::DynamoDB::Table"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname accessanalyzer_validate_policy
#'
#' @aliases accessanalyzer_validate_policy
accessanalyzer_validate_policy <- function(locale = NULL, maxResults = NULL, nextToken = NULL, policyDocument, policyType, validatePolicyResourceType = NULL) {
  op <- new_operation(
    name = "ValidatePolicy",
    http_method = "POST",
    http_path = "/policy/validation",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "findings"),
    stream_api = FALSE
  )
  input <- .accessanalyzer$validate_policy_input(locale = locale, maxResults = maxResults, nextToken = nextToken, policyDocument = policyDocument, policyType = policyType, validatePolicyResourceType = validatePolicyResourceType)
  output <- .accessanalyzer$validate_policy_output()
  config <- get_config()
  svc <- .accessanalyzer$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.accessanalyzer$operations$validate_policy <- accessanalyzer_validate_policy

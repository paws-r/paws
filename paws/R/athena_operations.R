# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include athena_service.R
NULL

#' Returns the details of a single named query or a list of up to 50
#' queries, which you provide as an array of query ID strings
#'
#' @description
#' Returns the details of a single named query or a list of up to 50
#' queries, which you provide as an array of query ID strings. Requires you
#' to have access to the workgroup in which the queries were saved. Use
#' ListNamedQueriesInput to get the list of named query IDs in the
#' specified workgroup. If information could not be retrieved for a
#' submitted query ID, information about the query ID submitted is listed
#' under UnprocessedNamedQueryId. Named queries differ from executed
#' queries. Use BatchGetQueryExecutionInput to get details about each
#' unique query execution, and ListQueryExecutionsInput to get a list of
#' query execution IDs.
#'
#' @usage
#' athena_batch_get_named_query(NamedQueryIds)
#'
#' @param NamedQueryIds &#91;required&#93; An array of query IDs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NamedQueries = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Database = "string",
#'       QueryString = "string",
#'       NamedQueryId = "string",
#'       WorkGroup = "string"
#'     )
#'   ),
#'   UnprocessedNamedQueryIds = list(
#'     list(
#'       NamedQueryId = "string",
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_named_query(
#'   NamedQueryIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_batch_get_named_query
#'
#' @aliases athena_batch_get_named_query
athena_batch_get_named_query <- function(NamedQueryIds) {
  op <- new_operation(
    name = "BatchGetNamedQuery",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$batch_get_named_query_input(NamedQueryIds = NamedQueryIds)
  output <- .athena$batch_get_named_query_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$batch_get_named_query <- athena_batch_get_named_query

#' Returns the details of a single prepared statement or a list of up to
#' 256 prepared statements for the array of prepared statement names that
#' you provide
#'
#' @description
#' Returns the details of a single prepared statement or a list of up to
#' 256 prepared statements for the array of prepared statement names that
#' you provide. Requires you to have access to the workgroup to which the
#' prepared statements belong. If a prepared statement cannot be retrieved
#' for the name specified, the statement is listed in
#' `UnprocessedPreparedStatementNames`.
#'
#' @usage
#' athena_batch_get_prepared_statement(PreparedStatementNames, WorkGroup)
#'
#' @param PreparedStatementNames &#91;required&#93; A list of prepared statement names to return.
#' @param WorkGroup &#91;required&#93; The name of the workgroup to which the prepared statements belong.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PreparedStatements = list(
#'     list(
#'       StatementName = "string",
#'       QueryStatement = "string",
#'       WorkGroupName = "string",
#'       Description = "string",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   UnprocessedPreparedStatementNames = list(
#'     list(
#'       StatementName = "string",
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_prepared_statement(
#'   PreparedStatementNames = list(
#'     "string"
#'   ),
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_batch_get_prepared_statement
#'
#' @aliases athena_batch_get_prepared_statement
athena_batch_get_prepared_statement <- function(PreparedStatementNames, WorkGroup) {
  op <- new_operation(
    name = "BatchGetPreparedStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$batch_get_prepared_statement_input(PreparedStatementNames = PreparedStatementNames, WorkGroup = WorkGroup)
  output <- .athena$batch_get_prepared_statement_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$batch_get_prepared_statement <- athena_batch_get_prepared_statement

#' Returns the details of a single query execution or a list of up to 50
#' query executions, which you provide as an array of query execution ID
#' strings
#'
#' @description
#' Returns the details of a single query execution or a list of up to 50
#' query executions, which you provide as an array of query execution ID
#' strings. Requires you to have access to the workgroup in which the
#' queries ran. To get a list of query execution IDs, use
#' ListQueryExecutionsInput$WorkGroup. Query executions differ from named
#' (saved) queries. Use BatchGetNamedQueryInput to get details about named
#' queries.
#'
#' @usage
#' athena_batch_get_query_execution(QueryExecutionIds)
#'
#' @param QueryExecutionIds &#91;required&#93; An array of query execution IDs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QueryExecutions = list(
#'     list(
#'       QueryExecutionId = "string",
#'       Query = "string",
#'       StatementType = "DDL"|"DML"|"UTILITY",
#'       ManagedQueryResultsConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         EncryptionConfiguration = list(
#'           KmsKey = "string"
#'         )
#'       ),
#'       ResultConfiguration = list(
#'         OutputLocation = "string",
#'         EncryptionConfiguration = list(
#'           EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'           KmsKey = "string"
#'         ),
#'         ExpectedBucketOwner = "string",
#'         AclConfiguration = list(
#'           S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'         )
#'       ),
#'       ResultReuseConfiguration = list(
#'         ResultReuseByAgeConfiguration = list(
#'           Enabled = TRUE|FALSE,
#'           MaxAgeInMinutes = 123
#'         )
#'       ),
#'       QueryExecutionContext = list(
#'         Database = "string",
#'         Catalog = "string"
#'       ),
#'       Status = list(
#'         State = "QUEUED"|"RUNNING"|"SUCCEEDED"|"FAILED"|"CANCELLED",
#'         StateChangeReason = "string",
#'         SubmissionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         CompletionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         AthenaError = list(
#'           ErrorCategory = 123,
#'           ErrorType = 123,
#'           Retryable = TRUE|FALSE,
#'           ErrorMessage = "string"
#'         )
#'       ),
#'       Statistics = list(
#'         EngineExecutionTimeInMillis = 123,
#'         DataScannedInBytes = 123,
#'         DataManifestLocation = "string",
#'         TotalExecutionTimeInMillis = 123,
#'         QueryQueueTimeInMillis = 123,
#'         ServicePreProcessingTimeInMillis = 123,
#'         QueryPlanningTimeInMillis = 123,
#'         ServiceProcessingTimeInMillis = 123,
#'         ResultReuseInformation = list(
#'           ReusedPreviousResult = TRUE|FALSE
#'         ),
#'         DpuCount = 123.0
#'       ),
#'       WorkGroup = "string",
#'       EngineVersion = list(
#'         SelectedEngineVersion = "string",
#'         EffectiveEngineVersion = "string"
#'       ),
#'       ExecutionParameters = list(
#'         "string"
#'       ),
#'       SubstatementType = "string",
#'       QueryResultsS3AccessGrantsConfiguration = list(
#'         EnableS3AccessGrants = TRUE|FALSE,
#'         CreateUserLevelPrefix = TRUE|FALSE,
#'         AuthenticationType = "DIRECTORY_IDENTITY"
#'       )
#'     )
#'   ),
#'   UnprocessedQueryExecutionIds = list(
#'     list(
#'       QueryExecutionId = "string",
#'       ErrorCode = "string",
#'       ErrorMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_query_execution(
#'   QueryExecutionIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_batch_get_query_execution
#'
#' @aliases athena_batch_get_query_execution
athena_batch_get_query_execution <- function(QueryExecutionIds) {
  op <- new_operation(
    name = "BatchGetQueryExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$batch_get_query_execution_input(QueryExecutionIds = QueryExecutionIds)
  output <- .athena$batch_get_query_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$batch_get_query_execution <- athena_batch_get_query_execution

#' Cancels the capacity reservation with the specified name
#'
#' @description
#' Cancels the capacity reservation with the specified name. Cancelled
#' reservations remain in your account and will be deleted 45 days after
#' cancellation. During the 45 days, you cannot re-purpose or reuse a
#' reservation that has been cancelled, but you can refer to its tags and
#' view it for historical reference.
#'
#' @usage
#' athena_cancel_capacity_reservation(Name)
#'
#' @param Name &#91;required&#93; The name of the capacity reservation to cancel.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_capacity_reservation(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_cancel_capacity_reservation
#'
#' @aliases athena_cancel_capacity_reservation
athena_cancel_capacity_reservation <- function(Name) {
  op <- new_operation(
    name = "CancelCapacityReservation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$cancel_capacity_reservation_input(Name = Name)
  output <- .athena$cancel_capacity_reservation_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$cancel_capacity_reservation <- athena_cancel_capacity_reservation

#' Creates a capacity reservation with the specified name and number of
#' requested data processing units
#'
#' @description
#' Creates a capacity reservation with the specified name and number of
#' requested data processing units.
#'
#' @usage
#' athena_create_capacity_reservation(TargetDpus, Name, Tags)
#'
#' @param TargetDpus &#91;required&#93; The number of requested data processing units.
#' @param Name &#91;required&#93; The name of the capacity reservation to create.
#' @param Tags The tags for the capacity reservation.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_capacity_reservation(
#'   TargetDpus = 123,
#'   Name = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_capacity_reservation
#'
#' @aliases athena_create_capacity_reservation
athena_create_capacity_reservation <- function(TargetDpus, Name, Tags = NULL) {
  op <- new_operation(
    name = "CreateCapacityReservation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_capacity_reservation_input(TargetDpus = TargetDpus, Name = Name, Tags = Tags)
  output <- .athena$create_capacity_reservation_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_capacity_reservation <- athena_create_capacity_reservation

#' Creates (registers) a data catalog with the specified name and
#' properties
#'
#' @description
#' Creates (registers) a data catalog with the specified name and
#' properties. Catalogs created are visible to all users of the same Amazon
#' Web Services account.
#' 
#' For a `FEDERATED` catalog, this API operation creates the following
#' resources.
#' 
#' -   CFN Stack Name with a maximum length of 128 characters and prefix
#'     `athenafederatedcatalog-CATALOG_NAME_SANITIZED` with length 23
#'     characters.
#' 
#' -   Lambda Function Name with a maximum length of 64 characters and
#'     prefix `athenafederatedcatalog_CATALOG_NAME_SANITIZED` with length
#'     23 characters.
#' 
#' -   Glue Connection Name with a maximum length of 255 characters and a
#'     prefix `athenafederatedcatalog_CATALOG_NAME_SANITIZED` with length
#'     23 characters.
#'
#' @usage
#' athena_create_data_catalog(Name, Type, Description, Parameters, Tags)
#'
#' @param Name &#91;required&#93; The name of the data catalog to create. The catalog name must be unique
#' for the Amazon Web Services account and can use a maximum of 127
#' alphanumeric, underscore, at sign, or hyphen characters. The remainder
#' of the length constraint of 256 is reserved for use by Athena.
#' 
#' For `FEDERATED` type the catalog name has following considerations and
#' limits:
#' 
#' -   The catalog name allows special characters such as `_ , @@ , \ , - `.
#'     These characters are replaced with a hyphen (-) when creating the
#'     CFN Stack Name and with an underscore (_) when creating the Lambda
#'     Function and Glue Connection Name.
#' 
#' -   The catalog name has a theoretical limit of 128 characters. However,
#'     since we use it to create other resources that allow less characters
#'     and we prepend a prefix to it, the actual catalog name limit for
#'     `FEDERATED` catalog is 64 - 23 = 41 characters.
#' @param Type &#91;required&#93; The type of data catalog to create: `LAMBDA` for a federated catalog,
#' `GLUE` for an Glue Data Catalog, and `HIVE` for an external Apache Hive
#' metastore. `FEDERATED` is a federated catalog for which Athena creates
#' the connection and the Lambda function for you based on the parameters
#' that you pass.
#' 
#' For `FEDERATED` type, we do not support IAM identity center.
#' @param Description A description of the data catalog to be created.
#' @param Parameters Specifies the Lambda function or functions to use for creating the data
#' catalog. This is a mapping whose values depend on the catalog type.
#' 
#' -   For the `HIVE` data catalog type, use the following syntax. The
#'     `metadata-function` parameter is required. `The sdk-version`
#'     parameter is optional and defaults to the currently supported
#'     version.
#' 
#'     `metadata-function=lambda_arn, sdk-version=version_number `
#' 
#' -   For the `LAMBDA` data catalog type, use one of the following sets of
#'     required parameters, but not both.
#' 
#'     -   If you have one Lambda function that processes metadata and
#'         another for reading the actual data, use the following syntax.
#'         Both parameters are required.
#' 
#'         `metadata-function=lambda_arn, record-function=lambda_arn `
#' 
#'     -   If you have a composite Lambda function that processes both
#'         metadata and data, use the following syntax to specify your
#'         Lambda function.
#' 
#'         `function=lambda_arn `
#' 
#' -   The `GLUE` type takes a catalog ID parameter and is required. The
#'     ` catalog_id ` is the account ID of the Amazon Web Services account
#'     to which the Glue Data Catalog belongs.
#' 
#'     `catalog-id=catalog_id `
#' 
#'     -   The `GLUE` data catalog type also applies to the default
#'         `AwsDataCatalog` that already exists in your account, of which
#'         you can have only one and cannot modify.
#' 
#' -   The `FEDERATED` data catalog type uses one of the following
#'     parameters, but not both. Use `connection-arn` for an existing Glue
#'     connection. Use `connection-type` and `connection-properties` to
#'     specify the configuration setting for a new connection.
#' 
#'     -   `connection-arn:<glue_connection_arn_to_reuse> `
#' 
#'     -   `lambda-role-arn` (optional): The execution role to use for the
#'         Lambda function. If not provided, one is created.
#' 
#'     -   `connection-type:MYSQL|REDSHIFT|...., connection-properties:"<json_string>"`
#' 
#'         For *\<json_string\>* , use escaped JSON text, as in the
#'         following example.
#' 
#'         `"{\"spill_bucket\":\"my_spill\",\"spill_prefix\":\"athena-spill\",\"host\":\"abc12345.snowflakecomputing.com\",\"port\":\"1234\",\"warehouse\":\"DEV_WH\",\"database\":\"TEST\",\"schema\":\"PUBLIC\",\"SecretArn\":\"arn:aws:secretsmanager:ap-south-1:111122223333:secret:snowflake-XHb67j\"}"`
#' @param Tags A list of comma separated tags to add to the data catalog that is
#' created. All the resources that are created by the
#' [`create_data_catalog`][athena_create_data_catalog] API operation with
#' `FEDERATED` type will have the tag
#' `federated_athena_datacatalog="true"`. This includes the CFN Stack, Glue
#' Connection, Athena DataCatalog, and all the resources created as part of
#' the CFN Stack (Lambda Function, IAM policies/roles).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DataCatalog = list(
#'     Name = "string",
#'     Description = "string",
#'     Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'     Parameters = list(
#'       "string"
#'     ),
#'     Status = "CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"|"CREATE_FAILED_CLEANUP_IN_PROGRESS"|"CREATE_FAILED_CLEANUP_COMPLETE"|"CREATE_FAILED_CLEANUP_FAILED"|"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED",
#'     ConnectionType = "DYNAMODB"|"MYSQL"|"POSTGRESQL"|"REDSHIFT"|"ORACLE"|"SYNAPSE"|"SQLSERVER"|"DB2"|"OPENSEARCH"|"BIGQUERY"|"GOOGLECLOUDSTORAGE"|"HBASE"|"DOCUMENTDB"|"CMDB"|"TPCDS"|"TIMESTREAM"|"SAPHANA"|"SNOWFLAKE"|"DATALAKEGEN2"|"DB2AS400",
#'     Error = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_catalog(
#'   Name = "string",
#'   Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'   Description = "string",
#'   Parameters = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_data_catalog
#'
#' @aliases athena_create_data_catalog
athena_create_data_catalog <- function(Name, Type, Description = NULL, Parameters = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateDataCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_data_catalog_input(Name = Name, Type = Type, Description = Description, Parameters = Parameters, Tags = Tags)
  output <- .athena$create_data_catalog_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_data_catalog <- athena_create_data_catalog

#' Creates a named query in the specified workgroup
#'
#' @description
#' Creates a named query in the specified workgroup. Requires that you have
#' access to the workgroup.
#'
#' @usage
#' athena_create_named_query(Name, Description, Database, QueryString,
#'   ClientRequestToken, WorkGroup)
#'
#' @param Name &#91;required&#93; The query name.
#' @param Description The query description.
#' @param Database &#91;required&#93; The database to which the query belongs.
#' @param QueryString &#91;required&#93; The contents of the query with all query statements.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' query is idempotent (executes only once). If another
#' [`create_named_query`][athena_create_named_query] request is received,
#' the same response is returned and another query is not created. If a
#' parameter has changed, for example, the `QueryString`, an error is
#' returned.
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for users. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#' @param WorkGroup The name of the workgroup in which the named query is being created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NamedQueryId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_named_query(
#'   Name = "string",
#'   Description = "string",
#'   Database = "string",
#'   QueryString = "string",
#'   ClientRequestToken = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_named_query
#'
#' @aliases athena_create_named_query
athena_create_named_query <- function(Name, Description = NULL, Database, QueryString, ClientRequestToken = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "CreateNamedQuery",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_named_query_input(Name = Name, Description = Description, Database = Database, QueryString = QueryString, ClientRequestToken = ClientRequestToken, WorkGroup = WorkGroup)
  output <- .athena$create_named_query_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_named_query <- athena_create_named_query

#' Creates an empty ipynb file in the specified Apache Spark enabled
#' workgroup
#'
#' @description
#' Creates an empty `ipynb` file in the specified Apache Spark enabled
#' workgroup. Throws an error if a file in the workgroup with the same name
#' already exists.
#'
#' @usage
#' athena_create_notebook(WorkGroup, Name, ClientRequestToken)
#'
#' @param WorkGroup &#91;required&#93; The name of the Spark enabled workgroup in which the notebook will be
#' created.
#' @param Name &#91;required&#93; The name of the `ipynb` file to be created in the Spark workgroup,
#' without the `.ipynb` extension.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' notebook is idempotent (executes only once).
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for you. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_notebook(
#'   WorkGroup = "string",
#'   Name = "string",
#'   ClientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_notebook
#'
#' @aliases athena_create_notebook
athena_create_notebook <- function(WorkGroup, Name, ClientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateNotebook",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_notebook_input(WorkGroup = WorkGroup, Name = Name, ClientRequestToken = ClientRequestToken)
  output <- .athena$create_notebook_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_notebook <- athena_create_notebook

#' Creates a prepared statement for use with SQL queries in Athena
#'
#' @description
#' Creates a prepared statement for use with SQL queries in Athena.
#'
#' @usage
#' athena_create_prepared_statement(StatementName, WorkGroup,
#'   QueryStatement, Description)
#'
#' @param StatementName &#91;required&#93; The name of the prepared statement.
#' @param WorkGroup &#91;required&#93; The name of the workgroup to which the prepared statement belongs.
#' @param QueryStatement &#91;required&#93; The query string for the prepared statement.
#' @param Description The description of the prepared statement.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_prepared_statement(
#'   StatementName = "string",
#'   WorkGroup = "string",
#'   QueryStatement = "string",
#'   Description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_prepared_statement
#'
#' @aliases athena_create_prepared_statement
athena_create_prepared_statement <- function(StatementName, WorkGroup, QueryStatement, Description = NULL) {
  op <- new_operation(
    name = "CreatePreparedStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_prepared_statement_input(StatementName = StatementName, WorkGroup = WorkGroup, QueryStatement = QueryStatement, Description = Description)
  output <- .athena$create_prepared_statement_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_prepared_statement <- athena_create_prepared_statement

#' Gets an authentication token and the URL at which the notebook can be
#' accessed
#'
#' @description
#' Gets an authentication token and the URL at which the notebook can be
#' accessed. During programmatic access,
#' [`create_presigned_notebook_url`][athena_create_presigned_notebook_url]
#' must be called every 10 minutes to refresh the authentication token. For
#' information about granting programmatic access, see [Grant programmatic
#' access](https://docs.aws.amazon.com/athena/latest/ug/setting-up.html#setting-up-grant-programmatic-access).
#'
#' @usage
#' athena_create_presigned_notebook_url(SessionId)
#'
#' @param SessionId &#91;required&#93; The session ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookUrl = "string",
#'   AuthToken = "string",
#'   AuthTokenExpirationTime = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_presigned_notebook_url(
#'   SessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_presigned_notebook_url
#'
#' @aliases athena_create_presigned_notebook_url
athena_create_presigned_notebook_url <- function(SessionId) {
  op <- new_operation(
    name = "CreatePresignedNotebookUrl",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_presigned_notebook_url_input(SessionId = SessionId)
  output <- .athena$create_presigned_notebook_url_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_presigned_notebook_url <- athena_create_presigned_notebook_url

#' Creates a workgroup with the specified name
#'
#' @description
#' Creates a workgroup with the specified name. A workgroup can be an
#' Apache Spark enabled workgroup or an Athena SQL workgroup.
#'
#' @usage
#' athena_create_work_group(Name, Configuration, Description, Tags)
#'
#' @param Name &#91;required&#93; The workgroup name.
#' @param Configuration Contains configuration information for creating an Athena SQL workgroup
#' or Spark enabled Athena workgroup. Athena SQL workgroup configuration
#' includes the location in Amazon S3 where query and calculation results
#' are stored, the encryption configuration, if any, used for encrypting
#' query results, whether the Amazon CloudWatch Metrics are enabled for the
#' workgroup, the limit for the amount of bytes scanned (cutoff) per query,
#' if it is specified, and whether workgroup's settings (specified with
#' `EnforceWorkGroupConfiguration`) in the `WorkGroupConfiguration`
#' override client-side settings. See
#' WorkGroupConfiguration$EnforceWorkGroupConfiguration.
#' @param Description The workgroup description.
#' @param Tags A list of comma separated tags to add to the workgroup that is created.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_work_group(
#'   Name = "string",
#'   Configuration = list(
#'     ResultConfiguration = list(
#'       OutputLocation = "string",
#'       EncryptionConfiguration = list(
#'         EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'         KmsKey = "string"
#'       ),
#'       ExpectedBucketOwner = "string",
#'       AclConfiguration = list(
#'         S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'       )
#'     ),
#'     ManagedQueryResultsConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       EncryptionConfiguration = list(
#'         KmsKey = "string"
#'       )
#'     ),
#'     EnforceWorkGroupConfiguration = TRUE|FALSE,
#'     PublishCloudWatchMetricsEnabled = TRUE|FALSE,
#'     BytesScannedCutoffPerQuery = 123,
#'     RequesterPaysEnabled = TRUE|FALSE,
#'     EngineVersion = list(
#'       SelectedEngineVersion = "string",
#'       EffectiveEngineVersion = "string"
#'     ),
#'     AdditionalConfiguration = "string",
#'     ExecutionRole = "string",
#'     MonitoringConfiguration = list(
#'       CloudWatchLoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string",
#'         LogStreamNamePrefix = "string",
#'         LogTypes = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ManagedLoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         KmsKey = "string"
#'       ),
#'       S3LoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         KmsKey = "string",
#'         LogLocation = "string"
#'       )
#'     ),
#'     EngineConfiguration = list(
#'       CoordinatorDpuSize = 123,
#'       MaxConcurrentDpus = 123,
#'       DefaultExecutorDpuSize = 123,
#'       AdditionalConfigs = list(
#'         "string"
#'       ),
#'       SparkProperties = list(
#'         "string"
#'       ),
#'       Classifications = list(
#'         list(
#'           Name = "string",
#'           Properties = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     CustomerContentEncryptionConfiguration = list(
#'       KmsKey = "string"
#'     ),
#'     EnableMinimumEncryptionConfiguration = TRUE|FALSE,
#'     IdentityCenterConfiguration = list(
#'       EnableIdentityCenter = TRUE|FALSE,
#'       IdentityCenterInstanceArn = "string"
#'     ),
#'     QueryResultsS3AccessGrantsConfiguration = list(
#'       EnableS3AccessGrants = TRUE|FALSE,
#'       CreateUserLevelPrefix = TRUE|FALSE,
#'       AuthenticationType = "DIRECTORY_IDENTITY"
#'     )
#'   ),
#'   Description = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_create_work_group
#'
#' @aliases athena_create_work_group
athena_create_work_group <- function(Name, Configuration = NULL, Description = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateWorkGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$create_work_group_input(Name = Name, Configuration = Configuration, Description = Description, Tags = Tags)
  output <- .athena$create_work_group_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$create_work_group <- athena_create_work_group

#' Deletes a cancelled capacity reservation
#'
#' @description
#' Deletes a cancelled capacity reservation. A reservation must be
#' cancelled before it can be deleted. A deleted reservation is immediately
#' removed from your account and can no longer be referenced, including by
#' its ARN. A deleted reservation cannot be called by
#' [`get_capacity_reservation`][athena_get_capacity_reservation], and
#' deleted reservations do not appear in the output of
#' [`list_capacity_reservations`][athena_list_capacity_reservations].
#'
#' @usage
#' athena_delete_capacity_reservation(Name)
#'
#' @param Name &#91;required&#93; The name of the capacity reservation to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_capacity_reservation(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_capacity_reservation
#'
#' @aliases athena_delete_capacity_reservation
athena_delete_capacity_reservation <- function(Name) {
  op <- new_operation(
    name = "DeleteCapacityReservation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_capacity_reservation_input(Name = Name)
  output <- .athena$delete_capacity_reservation_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_capacity_reservation <- athena_delete_capacity_reservation

#' Deletes a data catalog
#'
#' @description
#' Deletes a data catalog.
#'
#' @usage
#' athena_delete_data_catalog(Name, DeleteCatalogOnly)
#'
#' @param Name &#91;required&#93; The name of the data catalog to delete.
#' @param DeleteCatalogOnly Deletes the Athena Data Catalog. You can only use this with the
#' `FEDERATED` catalogs. You usually perform this before registering the
#' connector with Glue Data Catalog. After deletion, you will have to
#' manage the Glue Connection and Lambda function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DataCatalog = list(
#'     Name = "string",
#'     Description = "string",
#'     Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'     Parameters = list(
#'       "string"
#'     ),
#'     Status = "CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"|"CREATE_FAILED_CLEANUP_IN_PROGRESS"|"CREATE_FAILED_CLEANUP_COMPLETE"|"CREATE_FAILED_CLEANUP_FAILED"|"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED",
#'     ConnectionType = "DYNAMODB"|"MYSQL"|"POSTGRESQL"|"REDSHIFT"|"ORACLE"|"SYNAPSE"|"SQLSERVER"|"DB2"|"OPENSEARCH"|"BIGQUERY"|"GOOGLECLOUDSTORAGE"|"HBASE"|"DOCUMENTDB"|"CMDB"|"TPCDS"|"TIMESTREAM"|"SAPHANA"|"SNOWFLAKE"|"DATALAKEGEN2"|"DB2AS400",
#'     Error = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_catalog(
#'   Name = "string",
#'   DeleteCatalogOnly = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_data_catalog
#'
#' @aliases athena_delete_data_catalog
athena_delete_data_catalog <- function(Name, DeleteCatalogOnly = NULL) {
  op <- new_operation(
    name = "DeleteDataCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_data_catalog_input(Name = Name, DeleteCatalogOnly = DeleteCatalogOnly)
  output <- .athena$delete_data_catalog_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_data_catalog <- athena_delete_data_catalog

#' Deletes the named query if you have access to the workgroup in which the
#' query was saved
#'
#' @description
#' Deletes the named query if you have access to the workgroup in which the
#' query was saved.
#'
#' @usage
#' athena_delete_named_query(NamedQueryId)
#'
#' @param NamedQueryId &#91;required&#93; The unique ID of the query to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_named_query(
#'   NamedQueryId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_named_query
#'
#' @aliases athena_delete_named_query
athena_delete_named_query <- function(NamedQueryId) {
  op <- new_operation(
    name = "DeleteNamedQuery",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_named_query_input(NamedQueryId = NamedQueryId)
  output <- .athena$delete_named_query_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_named_query <- athena_delete_named_query

#' Deletes the specified notebook
#'
#' @description
#' Deletes the specified notebook.
#'
#' @usage
#' athena_delete_notebook(NotebookId)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_notebook(
#'   NotebookId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_notebook
#'
#' @aliases athena_delete_notebook
athena_delete_notebook <- function(NotebookId) {
  op <- new_operation(
    name = "DeleteNotebook",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_notebook_input(NotebookId = NotebookId)
  output <- .athena$delete_notebook_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_notebook <- athena_delete_notebook

#' Deletes the prepared statement with the specified name from the
#' specified workgroup
#'
#' @description
#' Deletes the prepared statement with the specified name from the
#' specified workgroup.
#'
#' @usage
#' athena_delete_prepared_statement(StatementName, WorkGroup)
#'
#' @param StatementName &#91;required&#93; The name of the prepared statement to delete.
#' @param WorkGroup &#91;required&#93; The workgroup to which the statement to be deleted belongs.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_prepared_statement(
#'   StatementName = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_prepared_statement
#'
#' @aliases athena_delete_prepared_statement
athena_delete_prepared_statement <- function(StatementName, WorkGroup) {
  op <- new_operation(
    name = "DeletePreparedStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_prepared_statement_input(StatementName = StatementName, WorkGroup = WorkGroup)
  output <- .athena$delete_prepared_statement_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_prepared_statement <- athena_delete_prepared_statement

#' Deletes the workgroup with the specified name
#'
#' @description
#' Deletes the workgroup with the specified name. The primary workgroup
#' cannot be deleted.
#'
#' @usage
#' athena_delete_work_group(WorkGroup, RecursiveDeleteOption)
#'
#' @param WorkGroup &#91;required&#93; The unique name of the workgroup to delete.
#' @param RecursiveDeleteOption The option to delete the workgroup and its contents even if the
#' workgroup contains any named queries, query executions, or notebooks.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_work_group(
#'   WorkGroup = "string",
#'   RecursiveDeleteOption = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_delete_work_group
#'
#' @aliases athena_delete_work_group
athena_delete_work_group <- function(WorkGroup, RecursiveDeleteOption = NULL) {
  op <- new_operation(
    name = "DeleteWorkGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$delete_work_group_input(WorkGroup = WorkGroup, RecursiveDeleteOption = RecursiveDeleteOption)
  output <- .athena$delete_work_group_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$delete_work_group <- athena_delete_work_group

#' Exports the specified notebook and its metadata
#'
#' @description
#' Exports the specified notebook and its metadata.
#'
#' @usage
#' athena_export_notebook(NotebookId)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook to export.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookMetadata = list(
#'     NotebookId = "string",
#'     Name = "string",
#'     WorkGroup = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Type = "IPYNB",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   Payload = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$export_notebook(
#'   NotebookId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_export_notebook
#'
#' @aliases athena_export_notebook
athena_export_notebook <- function(NotebookId) {
  op <- new_operation(
    name = "ExportNotebook",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$export_notebook_input(NotebookId = NotebookId)
  output <- .athena$export_notebook_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$export_notebook <- athena_export_notebook

#' Describes a previously submitted calculation execution
#'
#' @description
#' Describes a previously submitted calculation execution.
#'
#' @usage
#' athena_get_calculation_execution(CalculationExecutionId)
#'
#' @param CalculationExecutionId &#91;required&#93; The calculation execution UUID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CalculationExecutionId = "string",
#'   SessionId = "string",
#'   Description = "string",
#'   WorkingDirectory = "string",
#'   Status = list(
#'     SubmissionDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     State = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED",
#'     StateChangeReason = "string"
#'   ),
#'   Statistics = list(
#'     DpuExecutionInMillis = 123,
#'     Progress = "string"
#'   ),
#'   Result = list(
#'     StdOutS3Uri = "string",
#'     StdErrorS3Uri = "string",
#'     ResultS3Uri = "string",
#'     ResultType = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_calculation_execution(
#'   CalculationExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_calculation_execution
#'
#' @aliases athena_get_calculation_execution
athena_get_calculation_execution <- function(CalculationExecutionId) {
  op <- new_operation(
    name = "GetCalculationExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_calculation_execution_input(CalculationExecutionId = CalculationExecutionId)
  output <- .athena$get_calculation_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_calculation_execution <- athena_get_calculation_execution

#' Retrieves the unencrypted code that was executed for the calculation
#'
#' @description
#' Retrieves the unencrypted code that was executed for the calculation.
#'
#' @usage
#' athena_get_calculation_execution_code(CalculationExecutionId)
#'
#' @param CalculationExecutionId &#91;required&#93; The calculation execution UUID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeBlock = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_calculation_execution_code(
#'   CalculationExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_calculation_execution_code
#'
#' @aliases athena_get_calculation_execution_code
athena_get_calculation_execution_code <- function(CalculationExecutionId) {
  op <- new_operation(
    name = "GetCalculationExecutionCode",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_calculation_execution_code_input(CalculationExecutionId = CalculationExecutionId)
  output <- .athena$get_calculation_execution_code_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_calculation_execution_code <- athena_get_calculation_execution_code

#' Gets the status of a current calculation
#'
#' @description
#' Gets the status of a current calculation.
#'
#' @usage
#' athena_get_calculation_execution_status(CalculationExecutionId)
#'
#' @param CalculationExecutionId &#91;required&#93; The calculation execution UUID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = list(
#'     SubmissionDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CompletionDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     State = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED",
#'     StateChangeReason = "string"
#'   ),
#'   Statistics = list(
#'     DpuExecutionInMillis = 123,
#'     Progress = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_calculation_execution_status(
#'   CalculationExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_calculation_execution_status
#'
#' @aliases athena_get_calculation_execution_status
athena_get_calculation_execution_status <- function(CalculationExecutionId) {
  op <- new_operation(
    name = "GetCalculationExecutionStatus",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_calculation_execution_status_input(CalculationExecutionId = CalculationExecutionId)
  output <- .athena$get_calculation_execution_status_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_calculation_execution_status <- athena_get_calculation_execution_status

#' Gets the capacity assignment configuration for a capacity reservation,
#' if one exists
#'
#' @description
#' Gets the capacity assignment configuration for a capacity reservation,
#' if one exists.
#'
#' @usage
#' athena_get_capacity_assignment_configuration(CapacityReservationName)
#'
#' @param CapacityReservationName &#91;required&#93; The name of the capacity reservation to retrieve the capacity assignment
#' configuration for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityAssignmentConfiguration = list(
#'     CapacityReservationName = "string",
#'     CapacityAssignments = list(
#'       list(
#'         WorkGroupNames = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_capacity_assignment_configuration(
#'   CapacityReservationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_capacity_assignment_configuration
#'
#' @aliases athena_get_capacity_assignment_configuration
athena_get_capacity_assignment_configuration <- function(CapacityReservationName) {
  op <- new_operation(
    name = "GetCapacityAssignmentConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_capacity_assignment_configuration_input(CapacityReservationName = CapacityReservationName)
  output <- .athena$get_capacity_assignment_configuration_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_capacity_assignment_configuration <- athena_get_capacity_assignment_configuration

#' Returns information about the capacity reservation with the specified
#' name
#'
#' @description
#' Returns information about the capacity reservation with the specified
#' name.
#'
#' @usage
#' athena_get_capacity_reservation(Name)
#'
#' @param Name &#91;required&#93; The name of the capacity reservation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityReservation = list(
#'     Name = "string",
#'     Status = "PENDING"|"ACTIVE"|"CANCELLING"|"CANCELLED"|"FAILED"|"UPDATE_PENDING",
#'     TargetDpus = 123,
#'     AllocatedDpus = 123,
#'     LastAllocation = list(
#'       Status = "PENDING"|"SUCCEEDED"|"FAILED",
#'       StatusMessage = "string",
#'       RequestTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RequestCompletionTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LastSuccessfulAllocationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_capacity_reservation(
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_capacity_reservation
#'
#' @aliases athena_get_capacity_reservation
athena_get_capacity_reservation <- function(Name) {
  op <- new_operation(
    name = "GetCapacityReservation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_capacity_reservation_input(Name = Name)
  output <- .athena$get_capacity_reservation_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_capacity_reservation <- athena_get_capacity_reservation

#' Returns the specified data catalog
#'
#' @description
#' Returns the specified data catalog.
#'
#' @usage
#' athena_get_data_catalog(Name, WorkGroup)
#'
#' @param Name &#91;required&#93; The name of the data catalog to return.
#' @param WorkGroup The name of the workgroup. Required if making an IAM Identity Center
#' request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DataCatalog = list(
#'     Name = "string",
#'     Description = "string",
#'     Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'     Parameters = list(
#'       "string"
#'     ),
#'     Status = "CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"|"CREATE_FAILED_CLEANUP_IN_PROGRESS"|"CREATE_FAILED_CLEANUP_COMPLETE"|"CREATE_FAILED_CLEANUP_FAILED"|"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED",
#'     ConnectionType = "DYNAMODB"|"MYSQL"|"POSTGRESQL"|"REDSHIFT"|"ORACLE"|"SYNAPSE"|"SQLSERVER"|"DB2"|"OPENSEARCH"|"BIGQUERY"|"GOOGLECLOUDSTORAGE"|"HBASE"|"DOCUMENTDB"|"CMDB"|"TPCDS"|"TIMESTREAM"|"SAPHANA"|"SNOWFLAKE"|"DATALAKEGEN2"|"DB2AS400",
#'     Error = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_catalog(
#'   Name = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_data_catalog
#'
#' @aliases athena_get_data_catalog
athena_get_data_catalog <- function(Name, WorkGroup = NULL) {
  op <- new_operation(
    name = "GetDataCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_data_catalog_input(Name = Name, WorkGroup = WorkGroup)
  output <- .athena$get_data_catalog_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_data_catalog <- athena_get_data_catalog

#' Returns a database object for the specified database and data catalog
#'
#' @description
#' Returns a database object for the specified database and data catalog.
#'
#' @usage
#' athena_get_database(CatalogName, DatabaseName, WorkGroup)
#'
#' @param CatalogName &#91;required&#93; The name of the data catalog that contains the database to return.
#' @param DatabaseName &#91;required&#93; The name of the database to return.
#' @param WorkGroup The name of the workgroup for which the metadata is being fetched.
#' Required if requesting an IAM Identity Center enabled Glue Data Catalog.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Database = list(
#'     Name = "string",
#'     Description = "string",
#'     Parameters = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_database(
#'   CatalogName = "string",
#'   DatabaseName = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_database
#'
#' @aliases athena_get_database
athena_get_database <- function(CatalogName, DatabaseName, WorkGroup = NULL) {
  op <- new_operation(
    name = "GetDatabase",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_database_input(CatalogName = CatalogName, DatabaseName = DatabaseName, WorkGroup = WorkGroup)
  output <- .athena$get_database_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_database <- athena_get_database

#' Returns information about a single query
#'
#' @description
#' Returns information about a single query. Requires that you have access
#' to the workgroup in which the query was saved.
#'
#' @usage
#' athena_get_named_query(NamedQueryId)
#'
#' @param NamedQueryId &#91;required&#93; The unique ID of the query. Use
#' [`list_named_queries`][athena_list_named_queries] to get query IDs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NamedQuery = list(
#'     Name = "string",
#'     Description = "string",
#'     Database = "string",
#'     QueryString = "string",
#'     NamedQueryId = "string",
#'     WorkGroup = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_named_query(
#'   NamedQueryId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_named_query
#'
#' @aliases athena_get_named_query
athena_get_named_query <- function(NamedQueryId) {
  op <- new_operation(
    name = "GetNamedQuery",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_named_query_input(NamedQueryId = NamedQueryId)
  output <- .athena$get_named_query_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_named_query <- athena_get_named_query

#' Retrieves notebook metadata for the specified notebook ID
#'
#' @description
#' Retrieves notebook metadata for the specified notebook ID.
#'
#' @usage
#' athena_get_notebook_metadata(NotebookId)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook whose metadata is to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookMetadata = list(
#'     NotebookId = "string",
#'     Name = "string",
#'     WorkGroup = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Type = "IPYNB",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_notebook_metadata(
#'   NotebookId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_notebook_metadata
#'
#' @aliases athena_get_notebook_metadata
athena_get_notebook_metadata <- function(NotebookId) {
  op <- new_operation(
    name = "GetNotebookMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_notebook_metadata_input(NotebookId = NotebookId)
  output <- .athena$get_notebook_metadata_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_notebook_metadata <- athena_get_notebook_metadata

#' Retrieves the prepared statement with the specified name from the
#' specified workgroup
#'
#' @description
#' Retrieves the prepared statement with the specified name from the
#' specified workgroup.
#'
#' @usage
#' athena_get_prepared_statement(StatementName, WorkGroup)
#'
#' @param StatementName &#91;required&#93; The name of the prepared statement to retrieve.
#' @param WorkGroup &#91;required&#93; The workgroup to which the statement to be retrieved belongs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PreparedStatement = list(
#'     StatementName = "string",
#'     QueryStatement = "string",
#'     WorkGroupName = "string",
#'     Description = "string",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_prepared_statement(
#'   StatementName = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_prepared_statement
#'
#' @aliases athena_get_prepared_statement
athena_get_prepared_statement <- function(StatementName, WorkGroup) {
  op <- new_operation(
    name = "GetPreparedStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_prepared_statement_input(StatementName = StatementName, WorkGroup = WorkGroup)
  output <- .athena$get_prepared_statement_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_prepared_statement <- athena_get_prepared_statement

#' Returns information about a single execution of a query if you have
#' access to the workgroup in which the query ran
#'
#' @description
#' Returns information about a single execution of a query if you have
#' access to the workgroup in which the query ran. Each time a query
#' executes, information about the query execution is saved with a unique
#' ID.
#'
#' @usage
#' athena_get_query_execution(QueryExecutionId)
#'
#' @param QueryExecutionId &#91;required&#93; The unique ID of the query execution.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QueryExecution = list(
#'     QueryExecutionId = "string",
#'     Query = "string",
#'     StatementType = "DDL"|"DML"|"UTILITY",
#'     ManagedQueryResultsConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       EncryptionConfiguration = list(
#'         KmsKey = "string"
#'       )
#'     ),
#'     ResultConfiguration = list(
#'       OutputLocation = "string",
#'       EncryptionConfiguration = list(
#'         EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'         KmsKey = "string"
#'       ),
#'       ExpectedBucketOwner = "string",
#'       AclConfiguration = list(
#'         S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'       )
#'     ),
#'     ResultReuseConfiguration = list(
#'       ResultReuseByAgeConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         MaxAgeInMinutes = 123
#'       )
#'     ),
#'     QueryExecutionContext = list(
#'       Database = "string",
#'       Catalog = "string"
#'     ),
#'     Status = list(
#'       State = "QUEUED"|"RUNNING"|"SUCCEEDED"|"FAILED"|"CANCELLED",
#'       StateChangeReason = "string",
#'       SubmissionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CompletionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AthenaError = list(
#'         ErrorCategory = 123,
#'         ErrorType = 123,
#'         Retryable = TRUE|FALSE,
#'         ErrorMessage = "string"
#'       )
#'     ),
#'     Statistics = list(
#'       EngineExecutionTimeInMillis = 123,
#'       DataScannedInBytes = 123,
#'       DataManifestLocation = "string",
#'       TotalExecutionTimeInMillis = 123,
#'       QueryQueueTimeInMillis = 123,
#'       ServicePreProcessingTimeInMillis = 123,
#'       QueryPlanningTimeInMillis = 123,
#'       ServiceProcessingTimeInMillis = 123,
#'       ResultReuseInformation = list(
#'         ReusedPreviousResult = TRUE|FALSE
#'       ),
#'       DpuCount = 123.0
#'     ),
#'     WorkGroup = "string",
#'     EngineVersion = list(
#'       SelectedEngineVersion = "string",
#'       EffectiveEngineVersion = "string"
#'     ),
#'     ExecutionParameters = list(
#'       "string"
#'     ),
#'     SubstatementType = "string",
#'     QueryResultsS3AccessGrantsConfiguration = list(
#'       EnableS3AccessGrants = TRUE|FALSE,
#'       CreateUserLevelPrefix = TRUE|FALSE,
#'       AuthenticationType = "DIRECTORY_IDENTITY"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_query_execution(
#'   QueryExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_query_execution
#'
#' @aliases athena_get_query_execution
athena_get_query_execution <- function(QueryExecutionId) {
  op <- new_operation(
    name = "GetQueryExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_query_execution_input(QueryExecutionId = QueryExecutionId)
  output <- .athena$get_query_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_query_execution <- athena_get_query_execution

#' Streams the results of a single query execution specified by
#' QueryExecutionId from the Athena query results location in Amazon S3
#'
#' @description
#' Streams the results of a single query execution specified by
#' `QueryExecutionId` from the Athena query results location in Amazon S3.
#' For more information, see [Working with query results, recent queries,
#' and output
#' files](https://docs.aws.amazon.com/athena/latest/ug/querying.html) in
#' the *Amazon Athena User Guide*. This request does not execute the query
#' but returns results. Use
#' [`start_query_execution`][athena_start_query_execution] to run a query.
#' 
#' To stream query results successfully, the IAM principal with permission
#' to call [`get_query_results`][athena_get_query_results] also must have
#' permissions to the Amazon S3 `GetObject` action for the Athena query
#' results location.
#' 
#' IAM principals with permission to the Amazon S3 `GetObject` action for
#' the query results location are able to retrieve query results from
#' Amazon S3 even if permission to the
#' [`get_query_results`][athena_get_query_results] action is denied. To
#' restrict user or role access, ensure that Amazon S3 permissions to the
#' Athena query location are denied.
#'
#' @usage
#' athena_get_query_results(QueryExecutionId, NextToken, MaxResults,
#'   QueryResultType)
#'
#' @param QueryExecutionId &#91;required&#93; The unique ID of the query execution.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of results (rows) to return in this request.
#' @param QueryResultType When you set this to `DATA_ROWS` or empty,
#' [`get_query_results`][athena_get_query_results] returns the query
#' results in rows. If set to `DATA_MANIFEST`, it returns the manifest file
#' in rows. Only the query types `CREATE TABLE AS SELECT`, `UNLOAD`, and
#' `INSERT` can generate a manifest file. If you use `DATA_MANIFEST` for
#' other query types, the query will fail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateCount = 123,
#'   ResultSet = list(
#'     Rows = list(
#'       list(
#'         Data = list(
#'           list(
#'             VarCharValue = "string"
#'           )
#'         )
#'       )
#'     ),
#'     ResultSetMetadata = list(
#'       ColumnInfo = list(
#'         list(
#'           CatalogName = "string",
#'           SchemaName = "string",
#'           TableName = "string",
#'           Name = "string",
#'           Label = "string",
#'           Type = "string",
#'           Precision = 123,
#'           Scale = 123,
#'           Nullable = "NOT_NULL"|"NULLABLE"|"UNKNOWN",
#'           CaseSensitive = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_query_results(
#'   QueryExecutionId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   QueryResultType = "DATA_MANIFEST"|"DATA_ROWS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_query_results
#'
#' @aliases athena_get_query_results
athena_get_query_results <- function(QueryExecutionId, NextToken = NULL, MaxResults = NULL, QueryResultType = NULL) {
  op <- new_operation(
    name = "GetQueryResults",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ResultSet.Rows", non_aggregate_keys = list( "ResultSet.ResultSetMetadata", "UpdateCount")),
    stream_api = FALSE
  )
  input <- .athena$get_query_results_input(QueryExecutionId = QueryExecutionId, NextToken = NextToken, MaxResults = MaxResults, QueryResultType = QueryResultType)
  output <- .athena$get_query_results_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_query_results <- athena_get_query_results

#' Returns query execution runtime statistics related to a single execution
#' of a query if you have access to the workgroup in which the query ran
#'
#' @description
#' Returns query execution runtime statistics related to a single execution
#' of a query if you have access to the workgroup in which the query ran.
#' Statistics from the `Timeline` section of the response object are
#' available as soon as QueryExecutionStatus$State is in a SUCCEEDED or
#' FAILED state. The remaining non-timeline statistics in the response
#' (like stage-level input and output row count and data size) are updated
#' asynchronously and may not be available immediately after a query
#' completes or, in some cases, may not be returned. The non-timeline
#' statistics are also not included when a query has row-level filters
#' defined in Lake Formation.
#'
#' @usage
#' athena_get_query_runtime_statistics(QueryExecutionId)
#'
#' @param QueryExecutionId &#91;required&#93; The unique ID of the query execution.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QueryRuntimeStatistics = list(
#'     Timeline = list(
#'       QueryQueueTimeInMillis = 123,
#'       ServicePreProcessingTimeInMillis = 123,
#'       QueryPlanningTimeInMillis = 123,
#'       EngineExecutionTimeInMillis = 123,
#'       ServiceProcessingTimeInMillis = 123,
#'       TotalExecutionTimeInMillis = 123
#'     ),
#'     Rows = list(
#'       InputRows = 123,
#'       InputBytes = 123,
#'       OutputBytes = 123,
#'       OutputRows = 123
#'     ),
#'     OutputStage = list(
#'       StageId = 123,
#'       State = "string",
#'       OutputBytes = 123,
#'       OutputRows = 123,
#'       InputBytes = 123,
#'       InputRows = 123,
#'       ExecutionTime = 123,
#'       QueryStagePlan = list(
#'         Name = "string",
#'         Identifier = "string",
#'         Children = list(
#'           list()
#'         ),
#'         RemoteSources = list(
#'           "string"
#'         )
#'       ),
#'       SubStages = list(
#'         list()
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_query_runtime_statistics(
#'   QueryExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_query_runtime_statistics
#'
#' @aliases athena_get_query_runtime_statistics
athena_get_query_runtime_statistics <- function(QueryExecutionId) {
  op <- new_operation(
    name = "GetQueryRuntimeStatistics",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_query_runtime_statistics_input(QueryExecutionId = QueryExecutionId)
  output <- .athena$get_query_runtime_statistics_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_query_runtime_statistics <- athena_get_query_runtime_statistics

#' Gets the Live UI/Persistence UI for a session
#'
#' @description
#' Gets the Live UI/Persistence UI for a session.
#'
#' @usage
#' athena_get_resource_dashboard(ResourceARN)
#'
#' @param ResourceARN &#91;required&#93; The The Amazon Resource Name (ARN) for a session.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Url = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_resource_dashboard(
#'   ResourceARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_resource_dashboard
#'
#' @aliases athena_get_resource_dashboard
athena_get_resource_dashboard <- function(ResourceARN) {
  op <- new_operation(
    name = "GetResourceDashboard",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_resource_dashboard_input(ResourceARN = ResourceARN)
  output <- .athena$get_resource_dashboard_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_resource_dashboard <- athena_get_resource_dashboard

#' Gets the full details of a previously created session, including the
#' session status and configuration
#'
#' @description
#' Gets the full details of a previously created session, including the
#' session status and configuration.
#'
#' @usage
#' athena_get_session(SessionId)
#'
#' @param SessionId &#91;required&#93; The session ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SessionId = "string",
#'   Description = "string",
#'   WorkGroup = "string",
#'   EngineVersion = "string",
#'   EngineConfiguration = list(
#'     CoordinatorDpuSize = 123,
#'     MaxConcurrentDpus = 123,
#'     DefaultExecutorDpuSize = 123,
#'     AdditionalConfigs = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     Classifications = list(
#'       list(
#'         Name = "string",
#'         Properties = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   NotebookVersion = "string",
#'   MonitoringConfiguration = list(
#'     CloudWatchLoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       LogGroup = "string",
#'       LogStreamNamePrefix = "string",
#'       LogTypes = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ManagedLoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       KmsKey = "string"
#'     ),
#'     S3LoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       KmsKey = "string",
#'       LogLocation = "string"
#'     )
#'   ),
#'   SessionConfiguration = list(
#'     ExecutionRole = "string",
#'     WorkingDirectory = "string",
#'     IdleTimeoutSeconds = 123,
#'     SessionIdleTimeoutInMinutes = 123,
#'     EncryptionConfiguration = list(
#'       EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'       KmsKey = "string"
#'     )
#'   ),
#'   Status = list(
#'     StartDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     IdleSinceDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     State = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED",
#'     StateChangeReason = "string"
#'   ),
#'   Statistics = list(
#'     DpuExecutionInMillis = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session(
#'   SessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_session
#'
#' @aliases athena_get_session
athena_get_session <- function(SessionId) {
  op <- new_operation(
    name = "GetSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_session_input(SessionId = SessionId)
  output <- .athena$get_session_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_session <- athena_get_session

#' Gets a connection endpoint and authentication token for a given session
#' Id
#'
#' @description
#' Gets a connection endpoint and authentication token for a given session
#' Id.
#'
#' @usage
#' athena_get_session_endpoint(SessionId)
#'
#' @param SessionId &#91;required&#93; The session ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   EndpointUrl = "string",
#'   AuthToken = "string",
#'   AuthTokenExpirationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session_endpoint(
#'   SessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_session_endpoint
#'
#' @aliases athena_get_session_endpoint
athena_get_session_endpoint <- function(SessionId) {
  op <- new_operation(
    name = "GetSessionEndpoint",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_session_endpoint_input(SessionId = SessionId)
  output <- .athena$get_session_endpoint_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_session_endpoint <- athena_get_session_endpoint

#' Gets the current status of a session
#'
#' @description
#' Gets the current status of a session.
#'
#' @usage
#' athena_get_session_status(SessionId)
#'
#' @param SessionId &#91;required&#93; The session ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SessionId = "string",
#'   Status = list(
#'     StartDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastModifiedDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     IdleSinceDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     State = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED",
#'     StateChangeReason = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session_status(
#'   SessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_session_status
#'
#' @aliases athena_get_session_status
athena_get_session_status <- function(SessionId) {
  op <- new_operation(
    name = "GetSessionStatus",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_session_status_input(SessionId = SessionId)
  output <- .athena$get_session_status_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_session_status <- athena_get_session_status

#' Returns table metadata for the specified catalog, database, and table
#'
#' @description
#' Returns table metadata for the specified catalog, database, and table.
#'
#' @usage
#' athena_get_table_metadata(CatalogName, DatabaseName, TableName,
#'   WorkGroup)
#'
#' @param CatalogName &#91;required&#93; The name of the data catalog that contains the database and table
#' metadata to return.
#' @param DatabaseName &#91;required&#93; The name of the database that contains the table metadata to return.
#' @param TableName &#91;required&#93; The name of the table for which metadata is returned.
#' @param WorkGroup The name of the workgroup for which the metadata is being fetched.
#' Required if requesting an IAM Identity Center enabled Glue Data Catalog.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableMetadata = list(
#'     Name = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     LastAccessTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     TableType = "string",
#'     Columns = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string"
#'       )
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string"
#'       )
#'     ),
#'     Parameters = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_table_metadata(
#'   CatalogName = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_table_metadata
#'
#' @aliases athena_get_table_metadata
athena_get_table_metadata <- function(CatalogName, DatabaseName, TableName, WorkGroup = NULL) {
  op <- new_operation(
    name = "GetTableMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_table_metadata_input(CatalogName = CatalogName, DatabaseName = DatabaseName, TableName = TableName, WorkGroup = WorkGroup)
  output <- .athena$get_table_metadata_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_table_metadata <- athena_get_table_metadata

#' Returns information about the workgroup with the specified name
#'
#' @description
#' Returns information about the workgroup with the specified name.
#'
#' @usage
#' athena_get_work_group(WorkGroup)
#'
#' @param WorkGroup &#91;required&#93; The name of the workgroup.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   WorkGroup = list(
#'     Name = "string",
#'     State = "ENABLED"|"DISABLED",
#'     Configuration = list(
#'       ResultConfiguration = list(
#'         OutputLocation = "string",
#'         EncryptionConfiguration = list(
#'           EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'           KmsKey = "string"
#'         ),
#'         ExpectedBucketOwner = "string",
#'         AclConfiguration = list(
#'           S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'         )
#'       ),
#'       ManagedQueryResultsConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         EncryptionConfiguration = list(
#'           KmsKey = "string"
#'         )
#'       ),
#'       EnforceWorkGroupConfiguration = TRUE|FALSE,
#'       PublishCloudWatchMetricsEnabled = TRUE|FALSE,
#'       BytesScannedCutoffPerQuery = 123,
#'       RequesterPaysEnabled = TRUE|FALSE,
#'       EngineVersion = list(
#'         SelectedEngineVersion = "string",
#'         EffectiveEngineVersion = "string"
#'       ),
#'       AdditionalConfiguration = "string",
#'       ExecutionRole = "string",
#'       MonitoringConfiguration = list(
#'         CloudWatchLoggingConfiguration = list(
#'           Enabled = TRUE|FALSE,
#'           LogGroup = "string",
#'           LogStreamNamePrefix = "string",
#'           LogTypes = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         ManagedLoggingConfiguration = list(
#'           Enabled = TRUE|FALSE,
#'           KmsKey = "string"
#'         ),
#'         S3LoggingConfiguration = list(
#'           Enabled = TRUE|FALSE,
#'           KmsKey = "string",
#'           LogLocation = "string"
#'         )
#'       ),
#'       EngineConfiguration = list(
#'         CoordinatorDpuSize = 123,
#'         MaxConcurrentDpus = 123,
#'         DefaultExecutorDpuSize = 123,
#'         AdditionalConfigs = list(
#'           "string"
#'         ),
#'         SparkProperties = list(
#'           "string"
#'         ),
#'         Classifications = list(
#'           list(
#'             Name = "string",
#'             Properties = list(
#'               "string"
#'             )
#'           )
#'         )
#'       ),
#'       CustomerContentEncryptionConfiguration = list(
#'         KmsKey = "string"
#'       ),
#'       EnableMinimumEncryptionConfiguration = TRUE|FALSE,
#'       IdentityCenterConfiguration = list(
#'         EnableIdentityCenter = TRUE|FALSE,
#'         IdentityCenterInstanceArn = "string"
#'       ),
#'       QueryResultsS3AccessGrantsConfiguration = list(
#'         EnableS3AccessGrants = TRUE|FALSE,
#'         CreateUserLevelPrefix = TRUE|FALSE,
#'         AuthenticationType = "DIRECTORY_IDENTITY"
#'       )
#'     ),
#'     Description = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     IdentityCenterApplicationArn = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_work_group(
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_get_work_group
#'
#' @aliases athena_get_work_group
athena_get_work_group <- function(WorkGroup) {
  op <- new_operation(
    name = "GetWorkGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$get_work_group_input(WorkGroup = WorkGroup)
  output <- .athena$get_work_group_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$get_work_group <- athena_get_work_group

#' Imports a single ipynb file to a Spark enabled workgroup
#'
#' @description
#' Imports a single `ipynb` file to a Spark enabled workgroup. To import
#' the notebook, the request must specify a value for either `Payload` or
#' `NoteBookS3LocationUri`. If neither is specified or both are specified,
#' an `InvalidRequestException` occurs. The maximum file size that can be
#' imported is 10 megabytes. If an `ipynb` file with the same name already
#' exists in the workgroup, throws an error.
#'
#' @usage
#' athena_import_notebook(WorkGroup, Name, Payload, Type,
#'   NotebookS3LocationUri, ClientRequestToken)
#'
#' @param WorkGroup &#91;required&#93; The name of the Spark enabled workgroup to import the notebook to.
#' @param Name &#91;required&#93; The name of the notebook to import.
#' @param Payload The notebook content to be imported. The payload must be in `ipynb`
#' format.
#' @param Type &#91;required&#93; The notebook content type. Currently, the only valid type is `IPYNB`.
#' @param NotebookS3LocationUri A URI that specifies the Amazon S3 location of a notebook file in
#' `ipynb` format.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to import the
#' notebook is idempotent (executes only once).
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for you. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$import_notebook(
#'   WorkGroup = "string",
#'   Name = "string",
#'   Payload = "string",
#'   Type = "IPYNB",
#'   NotebookS3LocationUri = "string",
#'   ClientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_import_notebook
#'
#' @aliases athena_import_notebook
athena_import_notebook <- function(WorkGroup, Name, Payload = NULL, Type, NotebookS3LocationUri = NULL, ClientRequestToken = NULL) {
  op <- new_operation(
    name = "ImportNotebook",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$import_notebook_input(WorkGroup = WorkGroup, Name = Name, Payload = Payload, Type = Type, NotebookS3LocationUri = NotebookS3LocationUri, ClientRequestToken = ClientRequestToken)
  output <- .athena$import_notebook_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$import_notebook <- athena_import_notebook

#' Returns the supported DPU sizes for the supported application runtimes
#' (for example, Athena notebook version 1)
#'
#' @description
#' Returns the supported DPU sizes for the supported application runtimes
#' (for example, `Athena notebook version 1`).
#'
#' @usage
#' athena_list_application_dpu_sizes(MaxResults, NextToken)
#'
#' @param MaxResults Specifies the maximum number of results to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ApplicationDPUSizes = list(
#'     list(
#'       ApplicationRuntimeId = "string",
#'       SupportedDPUSizes = list(
#'         123
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_application_dpu_sizes(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_application_dpu_sizes
#'
#' @aliases athena_list_application_dpu_sizes
athena_list_application_dpu_sizes <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListApplicationDPUSizes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_application_dpu_sizes_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .athena$list_application_dpu_sizes_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_application_dpu_sizes <- athena_list_application_dpu_sizes

#' Lists the calculations that have been submitted to a session in
#' descending order
#'
#' @description
#' Lists the calculations that have been submitted to a session in
#' descending order. Newer calculations are listed first; older
#' calculations are listed later.
#'
#' @usage
#' athena_list_calculation_executions(SessionId, StateFilter, MaxResults,
#'   NextToken)
#'
#' @param SessionId &#91;required&#93; The session ID.
#' @param StateFilter A filter for a specific calculation execution state. A description of
#' each state follows.
#' 
#' `CREATING` - The calculation is in the process of being created.
#' 
#' `CREATED` - The calculation has been created and is ready to run.
#' 
#' `QUEUED` - The calculation has been queued for processing.
#' 
#' `RUNNING` - The calculation is running.
#' 
#' `CANCELING` - A request to cancel the calculation has been received and
#' the system is working to stop it.
#' 
#' `CANCELED` - The calculation is no longer running as the result of a
#' cancel request.
#' 
#' `COMPLETED` - The calculation has completed without error.
#' 
#' `FAILED` - The calculation failed and is no longer running.
#' @param MaxResults The maximum number of calculation executions to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Calculations = list(
#'     list(
#'       CalculationExecutionId = "string",
#'       Description = "string",
#'       Status = list(
#'         SubmissionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         CompletionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         State = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED",
#'         StateChangeReason = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_calculation_executions(
#'   SessionId = "string",
#'   StateFilter = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_calculation_executions
#'
#' @aliases athena_list_calculation_executions
athena_list_calculation_executions <- function(SessionId, StateFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListCalculationExecutions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_calculation_executions_input(SessionId = SessionId, StateFilter = StateFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .athena$list_calculation_executions_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_calculation_executions <- athena_list_calculation_executions

#' Lists the capacity reservations for the current account
#'
#' @description
#' Lists the capacity reservations for the current account.
#'
#' @usage
#' athena_list_capacity_reservations(NextToken, MaxResults)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated.
#' @param MaxResults Specifies the maximum number of results to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   CapacityReservations = list(
#'     list(
#'       Name = "string",
#'       Status = "PENDING"|"ACTIVE"|"CANCELLING"|"CANCELLED"|"FAILED"|"UPDATE_PENDING",
#'       TargetDpus = 123,
#'       AllocatedDpus = 123,
#'       LastAllocation = list(
#'         Status = "PENDING"|"SUCCEEDED"|"FAILED",
#'         StatusMessage = "string",
#'         RequestTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         RequestCompletionTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       LastSuccessfulAllocationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_capacity_reservations(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_capacity_reservations
#'
#' @aliases athena_list_capacity_reservations
athena_list_capacity_reservations <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListCapacityReservations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_capacity_reservations_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .athena$list_capacity_reservations_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_capacity_reservations <- athena_list_capacity_reservations

#' Lists the data catalogs in the current Amazon Web Services account
#'
#' @description
#' Lists the data catalogs in the current Amazon Web Services account.
#' 
#' In the Athena console, data catalogs are listed as "data sources" on the
#' **Data sources** page under the **Data source name** column.
#'
#' @usage
#' athena_list_data_catalogs(NextToken, MaxResults, WorkGroup)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the NextToken from the response object of the previous
#' page call.
#' @param MaxResults Specifies the maximum number of data catalogs to return.
#' @param WorkGroup The name of the workgroup. Required if making an IAM Identity Center
#' request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DataCatalogsSummary = list(
#'     list(
#'       CatalogName = "string",
#'       Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'       Status = "CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"|"CREATE_FAILED_CLEANUP_IN_PROGRESS"|"CREATE_FAILED_CLEANUP_COMPLETE"|"CREATE_FAILED_CLEANUP_FAILED"|"DELETE_IN_PROGRESS"|"DELETE_COMPLETE"|"DELETE_FAILED",
#'       ConnectionType = "DYNAMODB"|"MYSQL"|"POSTGRESQL"|"REDSHIFT"|"ORACLE"|"SYNAPSE"|"SQLSERVER"|"DB2"|"OPENSEARCH"|"BIGQUERY"|"GOOGLECLOUDSTORAGE"|"HBASE"|"DOCUMENTDB"|"CMDB"|"TPCDS"|"TIMESTREAM"|"SAPHANA"|"SNOWFLAKE"|"DATALAKEGEN2"|"DB2AS400",
#'       Error = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_catalogs(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_data_catalogs
#'
#' @aliases athena_list_data_catalogs
athena_list_data_catalogs <- function(NextToken = NULL, MaxResults = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "ListDataCatalogs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "DataCatalogsSummary"),
    stream_api = FALSE
  )
  input <- .athena$list_data_catalogs_input(NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_data_catalogs_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_data_catalogs <- athena_list_data_catalogs

#' Lists the databases in the specified data catalog
#'
#' @description
#' Lists the databases in the specified data catalog.
#'
#' @usage
#' athena_list_databases(CatalogName, NextToken, MaxResults, WorkGroup)
#'
#' @param CatalogName &#91;required&#93; The name of the data catalog that contains the databases to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults Specifies the maximum number of results to return.
#' @param WorkGroup The name of the workgroup for which the metadata is being fetched.
#' Required if requesting an IAM Identity Center enabled Glue Data Catalog.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DatabaseList = list(
#'     list(
#'       Name = "string",
#'       Description = "string",
#'       Parameters = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_databases(
#'   CatalogName = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_databases
#'
#' @aliases athena_list_databases
athena_list_databases <- function(CatalogName, NextToken = NULL, MaxResults = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "ListDatabases",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "DatabaseList"),
    stream_api = FALSE
  )
  input <- .athena$list_databases_input(CatalogName = CatalogName, NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_databases_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_databases <- athena_list_databases

#' Returns a list of engine versions that are available to choose from,
#' including the Auto option
#'
#' @description
#' Returns a list of engine versions that are available to choose from,
#' including the Auto option.
#'
#' @usage
#' athena_list_engine_versions(NextToken, MaxResults)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of engine versions to return in this request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   EngineVersions = list(
#'     list(
#'       SelectedEngineVersion = "string",
#'       EffectiveEngineVersion = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_engine_versions(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_engine_versions
#'
#' @aliases athena_list_engine_versions
athena_list_engine_versions <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListEngineVersions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_engine_versions_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .athena$list_engine_versions_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_engine_versions <- athena_list_engine_versions

#' Lists, in descending order, the executors that joined a session
#'
#' @description
#' Lists, in descending order, the executors that joined a session. Newer
#' executors are listed first; older executors are listed later. The result
#' can be optionally filtered by state.
#'
#' @usage
#' athena_list_executors(SessionId, ExecutorStateFilter, MaxResults,
#'   NextToken)
#'
#' @param SessionId &#91;required&#93; The session ID.
#' @param ExecutorStateFilter A filter for a specific executor state. A description of each state
#' follows.
#' 
#' `CREATING` - The executor is being started, including acquiring
#' resources.
#' 
#' `CREATED` - The executor has been started.
#' 
#' `REGISTERED` - The executor has been registered.
#' 
#' `TERMINATING` - The executor is in the process of shutting down.
#' 
#' `TERMINATED` - The executor is no longer running.
#' 
#' `FAILED` - Due to a failure, the executor is no longer running.
#' @param MaxResults The maximum number of executors to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SessionId = "string",
#'   NextToken = "string",
#'   ExecutorsSummary = list(
#'     list(
#'       ExecutorId = "string",
#'       ExecutorType = "COORDINATOR"|"GATEWAY"|"WORKER",
#'       StartDateTime = 123,
#'       TerminationDateTime = 123,
#'       ExecutorState = "CREATING"|"CREATED"|"REGISTERED"|"TERMINATING"|"TERMINATED"|"FAILED",
#'       ExecutorSize = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_executors(
#'   SessionId = "string",
#'   ExecutorStateFilter = "CREATING"|"CREATED"|"REGISTERED"|"TERMINATING"|"TERMINATED"|"FAILED",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_executors
#'
#' @aliases athena_list_executors
athena_list_executors <- function(SessionId, ExecutorStateFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListExecutors",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_executors_input(SessionId = SessionId, ExecutorStateFilter = ExecutorStateFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .athena$list_executors_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_executors <- athena_list_executors

#' Provides a list of available query IDs only for queries saved in the
#' specified workgroup
#'
#' @description
#' Provides a list of available query IDs only for queries saved in the
#' specified workgroup. Requires that you have access to the specified
#' workgroup. If a workgroup is not specified, lists the saved queries for
#' the primary workgroup.
#'
#' @usage
#' athena_list_named_queries(NextToken, MaxResults, WorkGroup)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of queries to return in this request.
#' @param WorkGroup The name of the workgroup from which the named queries are being
#' returned. If a workgroup is not specified, the saved queries for the
#' primary workgroup are returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NamedQueryIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_named_queries(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_named_queries
#'
#' @aliases athena_list_named_queries
athena_list_named_queries <- function(NextToken = NULL, MaxResults = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "ListNamedQueries",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "NamedQueryIds"),
    stream_api = FALSE
  )
  input <- .athena$list_named_queries_input(NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_named_queries_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_named_queries <- athena_list_named_queries

#' Displays the notebook files for the specified workgroup in paginated
#' format
#'
#' @description
#' Displays the notebook files for the specified workgroup in paginated
#' format.
#'
#' @usage
#' athena_list_notebook_metadata(Filters, NextToken, MaxResults, WorkGroup)
#'
#' @param Filters Search filter string.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated.
#' @param MaxResults Specifies the maximum number of results to return.
#' @param WorkGroup &#91;required&#93; The name of the Spark enabled workgroup to retrieve notebook metadata
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NotebookMetadataList = list(
#'     list(
#'       NotebookId = "string",
#'       Name = "string",
#'       WorkGroup = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Type = "IPYNB",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_notebook_metadata(
#'   Filters = list(
#'     Name = "string"
#'   ),
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_notebook_metadata
#'
#' @aliases athena_list_notebook_metadata
athena_list_notebook_metadata <- function(Filters = NULL, NextToken = NULL, MaxResults = NULL, WorkGroup) {
  op <- new_operation(
    name = "ListNotebookMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$list_notebook_metadata_input(Filters = Filters, NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_notebook_metadata_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_notebook_metadata <- athena_list_notebook_metadata

#' Lists, in descending order, the sessions that have been created in a
#' notebook that are in an active state like CREATING, CREATED, IDLE or
#' BUSY
#'
#' @description
#' Lists, in descending order, the sessions that have been created in a
#' notebook that are in an active state like `CREATING`, `CREATED`, `IDLE`
#' or `BUSY`. Newer sessions are listed first; older sessions are listed
#' later.
#'
#' @usage
#' athena_list_notebook_sessions(NotebookId, MaxResults, NextToken)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook to list sessions for.
#' @param MaxResults The maximum number of notebook sessions to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotebookSessionsList = list(
#'     list(
#'       SessionId = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_notebook_sessions(
#'   NotebookId = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_notebook_sessions
#'
#' @aliases athena_list_notebook_sessions
athena_list_notebook_sessions <- function(NotebookId, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListNotebookSessions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$list_notebook_sessions_input(NotebookId = NotebookId, MaxResults = MaxResults, NextToken = NextToken)
  output <- .athena$list_notebook_sessions_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_notebook_sessions <- athena_list_notebook_sessions

#' Lists the prepared statements in the specified workgroup
#'
#' @description
#' Lists the prepared statements in the specified workgroup.
#'
#' @usage
#' athena_list_prepared_statements(WorkGroup, NextToken, MaxResults)
#'
#' @param WorkGroup &#91;required&#93; The workgroup to list the prepared statements for.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of results to return in this request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   PreparedStatements = list(
#'     list(
#'       StatementName = "string",
#'       LastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_prepared_statements(
#'   WorkGroup = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_prepared_statements
#'
#' @aliases athena_list_prepared_statements
athena_list_prepared_statements <- function(WorkGroup, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListPreparedStatements",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_prepared_statements_input(WorkGroup = WorkGroup, NextToken = NextToken, MaxResults = MaxResults)
  output <- .athena$list_prepared_statements_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_prepared_statements <- athena_list_prepared_statements

#' Provides a list of available query execution IDs for the queries in the
#' specified workgroup
#'
#' @description
#' Provides a list of available query execution IDs for the queries in the
#' specified workgroup. Athena keeps a query history for 45 days. If a
#' workgroup is not specified, returns a list of query execution IDs for
#' the primary workgroup. Requires you to have access to the workgroup in
#' which the queries ran.
#'
#' @usage
#' athena_list_query_executions(NextToken, MaxResults, WorkGroup)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of query executions to return in this request.
#' @param WorkGroup The name of the workgroup from which queries are being returned. If a
#' workgroup is not specified, a list of available query execution IDs for
#' the queries in the primary workgroup is returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QueryExecutionIds = list(
#'     "string"
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_query_executions(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_query_executions
#'
#' @aliases athena_list_query_executions
athena_list_query_executions <- function(NextToken = NULL, MaxResults = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "ListQueryExecutions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "QueryExecutionIds"),
    stream_api = FALSE
  )
  input <- .athena$list_query_executions_input(NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_query_executions_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_query_executions <- athena_list_query_executions

#' Lists the sessions in a workgroup that are in an active state like
#' CREATING, CREATED, IDLE, or BUSY
#'
#' @description
#' Lists the sessions in a workgroup that are in an active state like
#' `CREATING`, `CREATED`, `IDLE`, or `BUSY`. Newer sessions are listed
#' first; older sessions are listed later.
#'
#' @usage
#' athena_list_sessions(WorkGroup, StateFilter, MaxResults, NextToken)
#'
#' @param WorkGroup &#91;required&#93; The workgroup to which the session belongs.
#' @param StateFilter A filter for a specific session state. A description of each state
#' follows.
#' 
#' `CREATING` - The session is being started, including acquiring
#' resources.
#' 
#' `CREATED` - The session has been started.
#' 
#' `IDLE` - The session is able to accept a calculation.
#' 
#' `BUSY` - The session is processing another task and is unable to accept
#' a calculation.
#' 
#' `TERMINATING` - The session is in the process of shutting down.
#' 
#' `TERMINATED` - The session and its resources are no longer running.
#' 
#' `DEGRADED` - The session has no healthy coordinators.
#' 
#' `FAILED` - Due to a failure, the session and its resources are no longer
#' running.
#' @param MaxResults The maximum number of sessions to return.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Sessions = list(
#'     list(
#'       SessionId = "string",
#'       Description = "string",
#'       EngineVersion = list(
#'         SelectedEngineVersion = "string",
#'         EffectiveEngineVersion = "string"
#'       ),
#'       NotebookVersion = "string",
#'       Status = list(
#'         StartDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         LastModifiedDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         EndDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         IdleSinceDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         State = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED",
#'         StateChangeReason = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_sessions(
#'   WorkGroup = "string",
#'   StateFilter = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_sessions
#'
#' @aliases athena_list_sessions
athena_list_sessions <- function(WorkGroup, StateFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListSessions",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_sessions_input(WorkGroup = WorkGroup, StateFilter = StateFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .athena$list_sessions_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_sessions <- athena_list_sessions

#' Lists the metadata for the tables in the specified data catalog database
#'
#' @description
#' Lists the metadata for the tables in the specified data catalog
#' database.
#'
#' @usage
#' athena_list_table_metadata(CatalogName, DatabaseName, Expression,
#'   NextToken, MaxResults, WorkGroup)
#'
#' @param CatalogName &#91;required&#93; The name of the data catalog for which table metadata should be
#' returned.
#' @param DatabaseName &#91;required&#93; The name of the database for which table metadata should be returned.
#' @param Expression A regex filter that pattern-matches table names. If no expression is
#' supplied, metadata for all tables are listed.
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the NextToken from the response object of the previous
#' page call.
#' @param MaxResults Specifies the maximum number of results to return.
#' @param WorkGroup The name of the workgroup for which the metadata is being fetched.
#' Required if requesting an IAM Identity Center enabled Glue Data Catalog.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableMetadataList = list(
#'     list(
#'       Name = "string",
#'       CreateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       TableType = "string",
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       PartitionKeys = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_table_metadata(
#'   CatalogName = "string",
#'   DatabaseName = "string",
#'   Expression = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   WorkGroup = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_table_metadata
#'
#' @aliases athena_list_table_metadata
athena_list_table_metadata <- function(CatalogName, DatabaseName, Expression = NULL, NextToken = NULL, MaxResults = NULL, WorkGroup = NULL) {
  op <- new_operation(
    name = "ListTableMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "TableMetadataList"),
    stream_api = FALSE
  )
  input <- .athena$list_table_metadata_input(CatalogName = CatalogName, DatabaseName = DatabaseName, Expression = Expression, NextToken = NextToken, MaxResults = MaxResults, WorkGroup = WorkGroup)
  output <- .athena$list_table_metadata_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_table_metadata <- athena_list_table_metadata

#' Lists the tags associated with an Athena resource
#'
#' @description
#' Lists the tags associated with an Athena resource.
#'
#' @usage
#' athena_list_tags_for_resource(ResourceARN, NextToken, MaxResults)
#'
#' @param ResourceARN &#91;required&#93; Lists the tags for the resource with the specified ARN.
#' @param NextToken The token for the next set of results, or null if there are no
#' additional results for this request, where the request lists the tags
#' for the resource with the specified ARN.
#' @param MaxResults The maximum number of results to be returned per request that lists the
#' tags for the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceARN = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_tags_for_resource
#'
#' @aliases athena_list_tags_for_resource
athena_list_tags_for_resource <- function(ResourceARN, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "Tags"),
    stream_api = FALSE
  )
  input <- .athena$list_tags_for_resource_input(ResourceARN = ResourceARN, NextToken = NextToken, MaxResults = MaxResults)
  output <- .athena$list_tags_for_resource_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_tags_for_resource <- athena_list_tags_for_resource

#' Lists available workgroups for the account
#'
#' @description
#' Lists available workgroups for the account.
#'
#' @usage
#' athena_list_work_groups(NextToken, MaxResults)
#'
#' @param NextToken A token generated by the Athena service that specifies where to continue
#' pagination if a previous request was truncated. To obtain the next set
#' of pages, pass in the `NextToken` from the response object of the
#' previous page call.
#' @param MaxResults The maximum number of workgroups to return in this request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   WorkGroups = list(
#'     list(
#'       Name = "string",
#'       State = "ENABLED"|"DISABLED",
#'       Description = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EngineVersion = list(
#'         SelectedEngineVersion = "string",
#'         EffectiveEngineVersion = "string"
#'       ),
#'       IdentityCenterApplicationArn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_work_groups(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_list_work_groups
#'
#' @aliases athena_list_work_groups
athena_list_work_groups <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListWorkGroups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .athena$list_work_groups_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .athena$list_work_groups_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$list_work_groups <- athena_list_work_groups

#' Puts a new capacity assignment configuration for a specified capacity
#' reservation
#'
#' @description
#' Puts a new capacity assignment configuration for a specified capacity
#' reservation. If a capacity assignment configuration already exists for
#' the capacity reservation, replaces the existing capacity assignment
#' configuration.
#'
#' @usage
#' athena_put_capacity_assignment_configuration(CapacityReservationName,
#'   CapacityAssignments)
#'
#' @param CapacityReservationName &#91;required&#93; The name of the capacity reservation to put a capacity assignment
#' configuration for.
#' @param CapacityAssignments &#91;required&#93; The list of assignments for the capacity assignment configuration.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_capacity_assignment_configuration(
#'   CapacityReservationName = "string",
#'   CapacityAssignments = list(
#'     list(
#'       WorkGroupNames = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_put_capacity_assignment_configuration
#'
#' @aliases athena_put_capacity_assignment_configuration
athena_put_capacity_assignment_configuration <- function(CapacityReservationName, CapacityAssignments) {
  op <- new_operation(
    name = "PutCapacityAssignmentConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$put_capacity_assignment_configuration_input(CapacityReservationName = CapacityReservationName, CapacityAssignments = CapacityAssignments)
  output <- .athena$put_capacity_assignment_configuration_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$put_capacity_assignment_configuration <- athena_put_capacity_assignment_configuration

#' Submits calculations for execution within a session
#'
#' @description
#' Submits calculations for execution within a session. You can supply the
#' code to run as an inline code block within the request.
#' 
#' The request syntax requires the
#' StartCalculationExecutionRequest$CodeBlock parameter or the
#' CalculationConfiguration$CodeBlock parameter, but not both. Because
#' CalculationConfiguration$CodeBlock is deprecated, use the
#' StartCalculationExecutionRequest$CodeBlock parameter instead.
#'
#' @usage
#' athena_start_calculation_execution(SessionId, Description,
#'   CalculationConfiguration, CodeBlock, ClientRequestToken)
#'
#' @param SessionId &#91;required&#93; The session ID.
#' @param Description A description of the calculation.
#' @param CalculationConfiguration Contains configuration information for the calculation.
#' @param CodeBlock A string that contains the code of the calculation. Use this parameter
#' instead of CalculationConfiguration$CodeBlock, which is deprecated.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' calculation is idempotent (executes only once). If another
#' `StartCalculationExecutionRequest` is received, the same response is
#' returned and another calculation is not created. If a parameter has
#' changed, an error is returned.
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for users. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CalculationExecutionId = "string",
#'   State = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_calculation_execution(
#'   SessionId = "string",
#'   Description = "string",
#'   CalculationConfiguration = list(
#'     CodeBlock = "string"
#'   ),
#'   CodeBlock = "string",
#'   ClientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_start_calculation_execution
#'
#' @aliases athena_start_calculation_execution
athena_start_calculation_execution <- function(SessionId, Description = NULL, CalculationConfiguration = NULL, CodeBlock = NULL, ClientRequestToken = NULL) {
  op <- new_operation(
    name = "StartCalculationExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$start_calculation_execution_input(SessionId = SessionId, Description = Description, CalculationConfiguration = CalculationConfiguration, CodeBlock = CodeBlock, ClientRequestToken = ClientRequestToken)
  output <- .athena$start_calculation_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$start_calculation_execution <- athena_start_calculation_execution

#' Runs the SQL query statements contained in the Query
#'
#' @description
#' Runs the SQL query statements contained in the `Query`. Requires you to
#' have access to the workgroup in which the query ran. Running queries
#' against an external catalog requires
#' [`get_data_catalog`][athena_get_data_catalog] permission to the catalog.
#' For code samples using the Amazon Web Services SDK for Java, see
#' [Examples and Code
#' Samples](https://docs.aws.amazon.com/athena/latest/ug/code-samples.html)
#' in the *Amazon Athena User Guide*.
#'
#' @usage
#' athena_start_query_execution(QueryString, ClientRequestToken,
#'   QueryExecutionContext, ResultConfiguration, WorkGroup,
#'   ExecutionParameters, ResultReuseConfiguration, EngineConfiguration)
#'
#' @param QueryString &#91;required&#93; The SQL query statements to be executed.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' query is idempotent (executes only once). If another
#' [`start_query_execution`][athena_start_query_execution] request is
#' received, the same response is returned and another query is not
#' created. An error is returned if a parameter, such as `QueryString`, has
#' changed. A call to
#' [`start_query_execution`][athena_start_query_execution] that uses a
#' previous client request token returns the same `QueryExecutionId` even
#' if the requester doesn't have permission on the tables specified in
#' `QueryString`.
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for users. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#' @param QueryExecutionContext The database within which the query executes.
#' @param ResultConfiguration Specifies information about where and how to save the results of the
#' query execution. If the query runs in a workgroup, then workgroup's
#' settings may override query settings. This affects the query results
#' location. The workgroup settings override is specified in
#' EnforceWorkGroupConfiguration (true/false) in the
#' WorkGroupConfiguration. See
#' WorkGroupConfiguration$EnforceWorkGroupConfiguration.
#' @param WorkGroup The name of the workgroup in which the query is being started.
#' @param ExecutionParameters A list of values for the parameters in a query. The values are applied
#' sequentially to the parameters in the query in the order in which the
#' parameters occur.
#' @param ResultReuseConfiguration Specifies the query result reuse behavior for the query.
#' @param EngineConfiguration 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QueryExecutionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_query_execution(
#'   QueryString = "string",
#'   ClientRequestToken = "string",
#'   QueryExecutionContext = list(
#'     Database = "string",
#'     Catalog = "string"
#'   ),
#'   ResultConfiguration = list(
#'     OutputLocation = "string",
#'     EncryptionConfiguration = list(
#'       EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'       KmsKey = "string"
#'     ),
#'     ExpectedBucketOwner = "string",
#'     AclConfiguration = list(
#'       S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'     )
#'   ),
#'   WorkGroup = "string",
#'   ExecutionParameters = list(
#'     "string"
#'   ),
#'   ResultReuseConfiguration = list(
#'     ResultReuseByAgeConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       MaxAgeInMinutes = 123
#'     )
#'   ),
#'   EngineConfiguration = list(
#'     CoordinatorDpuSize = 123,
#'     MaxConcurrentDpus = 123,
#'     DefaultExecutorDpuSize = 123,
#'     AdditionalConfigs = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     Classifications = list(
#'       list(
#'         Name = "string",
#'         Properties = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_start_query_execution
#'
#' @aliases athena_start_query_execution
athena_start_query_execution <- function(QueryString, ClientRequestToken = NULL, QueryExecutionContext = NULL, ResultConfiguration = NULL, WorkGroup = NULL, ExecutionParameters = NULL, ResultReuseConfiguration = NULL, EngineConfiguration = NULL) {
  op <- new_operation(
    name = "StartQueryExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$start_query_execution_input(QueryString = QueryString, ClientRequestToken = ClientRequestToken, QueryExecutionContext = QueryExecutionContext, ResultConfiguration = ResultConfiguration, WorkGroup = WorkGroup, ExecutionParameters = ExecutionParameters, ResultReuseConfiguration = ResultReuseConfiguration, EngineConfiguration = EngineConfiguration)
  output <- .athena$start_query_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$start_query_execution <- athena_start_query_execution

#' Creates a session for running calculations within a workgroup
#'
#' @description
#' Creates a session for running calculations within a workgroup. The
#' session is ready when it reaches an `IDLE` state.
#'
#' @usage
#' athena_start_session(Description, WorkGroup, EngineConfiguration,
#'   ExecutionRole, MonitoringConfiguration, NotebookVersion,
#'   SessionIdleTimeoutInMinutes, ClientRequestToken, Tags,
#'   CopyWorkGroupTags)
#'
#' @param Description The session description.
#' @param WorkGroup &#91;required&#93; The workgroup to which the session belongs.
#' @param EngineConfiguration &#91;required&#93; Contains engine data processing unit (DPU) configuration settings and
#' parameter mappings.
#' @param ExecutionRole The ARN of the execution role used to access user resources for Spark
#' sessions and Identity Center enabled workgroups. This property applies
#' only to Spark enabled workgroups and Identity Center enabled workgroups.
#' @param MonitoringConfiguration Contains the configuration settings for managed log persistence,
#' delivering logs to Amazon S3 buckets, Amazon CloudWatch log groups etc.
#' @param NotebookVersion The notebook version. This value is supplied automatically for notebook
#' sessions in the Athena console and is not required for programmatic
#' session access. The only valid notebook version is
#' `Athena notebook version 1`. If you specify a value for
#' `NotebookVersion`, you must also specify a value for `NotebookId`. See
#' EngineConfiguration$AdditionalConfigs.
#' @param SessionIdleTimeoutInMinutes The idle timeout in minutes for the session.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' session is idempotent (executes only once). If another
#' `StartSessionRequest` is received, the same response is returned and
#' another session is not created. If a parameter has changed, an error is
#' returned.
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for users. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#' @param Tags A list of comma separated tags to add to the session that is created.
#' @param CopyWorkGroupTags Copies the tags from the Workgroup to the Session when.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   SessionId = "string",
#'   State = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_session(
#'   Description = "string",
#'   WorkGroup = "string",
#'   EngineConfiguration = list(
#'     CoordinatorDpuSize = 123,
#'     MaxConcurrentDpus = 123,
#'     DefaultExecutorDpuSize = 123,
#'     AdditionalConfigs = list(
#'       "string"
#'     ),
#'     SparkProperties = list(
#'       "string"
#'     ),
#'     Classifications = list(
#'       list(
#'         Name = "string",
#'         Properties = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ExecutionRole = "string",
#'   MonitoringConfiguration = list(
#'     CloudWatchLoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       LogGroup = "string",
#'       LogStreamNamePrefix = "string",
#'       LogTypes = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ManagedLoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       KmsKey = "string"
#'     ),
#'     S3LoggingConfiguration = list(
#'       Enabled = TRUE|FALSE,
#'       KmsKey = "string",
#'       LogLocation = "string"
#'     )
#'   ),
#'   NotebookVersion = "string",
#'   SessionIdleTimeoutInMinutes = 123,
#'   ClientRequestToken = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   CopyWorkGroupTags = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_start_session
#'
#' @aliases athena_start_session
athena_start_session <- function(Description = NULL, WorkGroup, EngineConfiguration, ExecutionRole = NULL, MonitoringConfiguration = NULL, NotebookVersion = NULL, SessionIdleTimeoutInMinutes = NULL, ClientRequestToken = NULL, Tags = NULL, CopyWorkGroupTags = NULL) {
  op <- new_operation(
    name = "StartSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$start_session_input(Description = Description, WorkGroup = WorkGroup, EngineConfiguration = EngineConfiguration, ExecutionRole = ExecutionRole, MonitoringConfiguration = MonitoringConfiguration, NotebookVersion = NotebookVersion, SessionIdleTimeoutInMinutes = SessionIdleTimeoutInMinutes, ClientRequestToken = ClientRequestToken, Tags = Tags, CopyWorkGroupTags = CopyWorkGroupTags)
  output <- .athena$start_session_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$start_session <- athena_start_session

#' Requests the cancellation of a calculation
#'
#' @description
#' Requests the cancellation of a calculation. A
#' [`stop_calculation_execution`][athena_stop_calculation_execution] call
#' on a calculation that is already in a terminal state (for example,
#' `STOPPED`, `FAILED`, or `COMPLETED`) succeeds but has no effect.
#' 
#' Cancelling a calculation is done on a best effort basis. If a
#' calculation cannot be cancelled, you can be charged for its completion.
#' If you are concerned about being charged for a calculation that cannot
#' be cancelled, consider terminating the session in which the calculation
#' is running.
#'
#' @usage
#' athena_stop_calculation_execution(CalculationExecutionId)
#'
#' @param CalculationExecutionId &#91;required&#93; The calculation execution UUID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   State = "CREATING"|"CREATED"|"QUEUED"|"RUNNING"|"CANCELING"|"CANCELED"|"COMPLETED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_calculation_execution(
#'   CalculationExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_stop_calculation_execution
#'
#' @aliases athena_stop_calculation_execution
athena_stop_calculation_execution <- function(CalculationExecutionId) {
  op <- new_operation(
    name = "StopCalculationExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$stop_calculation_execution_input(CalculationExecutionId = CalculationExecutionId)
  output <- .athena$stop_calculation_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$stop_calculation_execution <- athena_stop_calculation_execution

#' Stops a query execution
#'
#' @description
#' Stops a query execution. Requires you to have access to the workgroup in
#' which the query ran.
#'
#' @usage
#' athena_stop_query_execution(QueryExecutionId)
#'
#' @param QueryExecutionId &#91;required&#93; The unique ID of the query execution to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_query_execution(
#'   QueryExecutionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_stop_query_execution
#'
#' @aliases athena_stop_query_execution
athena_stop_query_execution <- function(QueryExecutionId) {
  op <- new_operation(
    name = "StopQueryExecution",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$stop_query_execution_input(QueryExecutionId = QueryExecutionId)
  output <- .athena$stop_query_execution_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$stop_query_execution <- athena_stop_query_execution

#' Adds one or more tags to an Athena resource
#'
#' @description
#' Adds one or more tags to an Athena resource. A tag is a label that you
#' assign to a resource. Each tag consists of a key and an optional value,
#' both of which you define. For example, you can use tags to categorize
#' Athena workgroups, data catalogs, or capacity reservations by purpose,
#' owner, or environment. Use a consistent set of tag keys to make it
#' easier to search and filter the resources in your account. For best
#' practices, see [Tagging Best
#' Practices](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/tagging-best-practices.html).
#' Tag keys can be from 1 to 128 UTF-8 Unicode characters, and tag values
#' can be from 0 to 256 UTF-8 Unicode characters. Tags can use letters and
#' numbers representable in UTF-8, and the following characters: + - = . _
#' : / @@. Tag keys and values are case-sensitive. Tag keys must be unique
#' per resource. If you specify more than one tag, separate them by commas.
#'
#' @usage
#' athena_tag_resource(ResourceARN, Tags)
#'
#' @param ResourceARN &#91;required&#93; Specifies the ARN of the Athena resource to which tags are to be added.
#' @param Tags &#91;required&#93; A collection of one or more tags, separated by commas, to be added to an
#' Athena resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceARN = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_tag_resource
#'
#' @aliases athena_tag_resource
athena_tag_resource <- function(ResourceARN, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$tag_resource_input(ResourceARN = ResourceARN, Tags = Tags)
  output <- .athena$tag_resource_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$tag_resource <- athena_tag_resource

#' Terminates an active session
#'
#' @description
#' Terminates an active session. A
#' [`terminate_session`][athena_terminate_session] call on a session that
#' is already inactive (for example, in a `FAILED`, `TERMINATED` or
#' `TERMINATING` state) succeeds but has no effect. Calculations running in
#' the session when [`terminate_session`][athena_terminate_session] is
#' called are forcefully stopped, but may display as `FAILED` instead of
#' `STOPPED`.
#'
#' @usage
#' athena_terminate_session(SessionId)
#'
#' @param SessionId &#91;required&#93; The session ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   State = "CREATING"|"CREATED"|"IDLE"|"BUSY"|"TERMINATING"|"TERMINATED"|"DEGRADED"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$terminate_session(
#'   SessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_terminate_session
#'
#' @aliases athena_terminate_session
athena_terminate_session <- function(SessionId) {
  op <- new_operation(
    name = "TerminateSession",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$terminate_session_input(SessionId = SessionId)
  output <- .athena$terminate_session_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$terminate_session <- athena_terminate_session

#' Removes one or more tags from an Athena resource
#'
#' @description
#' Removes one or more tags from an Athena resource.
#'
#' @usage
#' athena_untag_resource(ResourceARN, TagKeys)
#'
#' @param ResourceARN &#91;required&#93; Specifies the ARN of the resource from which tags are to be removed.
#' @param TagKeys &#91;required&#93; A comma-separated list of one or more tag keys whose tags are to be
#' removed from the specified resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceARN = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_untag_resource
#'
#' @aliases athena_untag_resource
athena_untag_resource <- function(ResourceARN, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$untag_resource_input(ResourceARN = ResourceARN, TagKeys = TagKeys)
  output <- .athena$untag_resource_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$untag_resource <- athena_untag_resource

#' Updates the number of requested data processing units for the capacity
#' reservation with the specified name
#'
#' @description
#' Updates the number of requested data processing units for the capacity
#' reservation with the specified name.
#'
#' @usage
#' athena_update_capacity_reservation(TargetDpus, Name)
#'
#' @param TargetDpus &#91;required&#93; The new number of requested data processing units.
#' @param Name &#91;required&#93; The name of the capacity reservation.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_capacity_reservation(
#'   TargetDpus = 123,
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_capacity_reservation
#'
#' @aliases athena_update_capacity_reservation
athena_update_capacity_reservation <- function(TargetDpus, Name) {
  op <- new_operation(
    name = "UpdateCapacityReservation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_capacity_reservation_input(TargetDpus = TargetDpus, Name = Name)
  output <- .athena$update_capacity_reservation_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_capacity_reservation <- athena_update_capacity_reservation

#' Updates the data catalog that has the specified name
#'
#' @description
#' Updates the data catalog that has the specified name.
#'
#' @usage
#' athena_update_data_catalog(Name, Type, Description, Parameters)
#'
#' @param Name &#91;required&#93; The name of the data catalog to update. The catalog name must be unique
#' for the Amazon Web Services account and can use a maximum of 127
#' alphanumeric, underscore, at sign, or hyphen characters. The remainder
#' of the length constraint of 256 is reserved for use by Athena.
#' @param Type &#91;required&#93; Specifies the type of data catalog to update. Specify `LAMBDA` for a
#' federated catalog, `HIVE` for an external hive metastore, or `GLUE` for
#' an Glue Data Catalog.
#' @param Description New or modified text that describes the data catalog.
#' @param Parameters Specifies the Lambda function or functions to use for updating the data
#' catalog. This is a mapping whose values depend on the catalog type.
#' 
#' -   For the `HIVE` data catalog type, use the following syntax. The
#'     `metadata-function` parameter is required. `The sdk-version`
#'     parameter is optional and defaults to the currently supported
#'     version.
#' 
#'     `metadata-function=lambda_arn, sdk-version=version_number `
#' 
#' -   For the `LAMBDA` data catalog type, use one of the following sets of
#'     required parameters, but not both.
#' 
#'     -   If you have one Lambda function that processes metadata and
#'         another for reading the actual data, use the following syntax.
#'         Both parameters are required.
#' 
#'         `metadata-function=lambda_arn, record-function=lambda_arn `
#' 
#'     -   If you have a composite Lambda function that processes both
#'         metadata and data, use the following syntax to specify your
#'         Lambda function.
#' 
#'         `function=lambda_arn `
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_data_catalog(
#'   Name = "string",
#'   Type = "LAMBDA"|"GLUE"|"HIVE"|"FEDERATED",
#'   Description = "string",
#'   Parameters = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_data_catalog
#'
#' @aliases athena_update_data_catalog
athena_update_data_catalog <- function(Name, Type, Description = NULL, Parameters = NULL) {
  op <- new_operation(
    name = "UpdateDataCatalog",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_data_catalog_input(Name = Name, Type = Type, Description = Description, Parameters = Parameters)
  output <- .athena$update_data_catalog_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_data_catalog <- athena_update_data_catalog

#' Updates a NamedQuery object
#'
#' @description
#' Updates a NamedQuery object. The database or workgroup cannot be
#' updated.
#'
#' @usage
#' athena_update_named_query(NamedQueryId, Name, Description, QueryString)
#'
#' @param NamedQueryId &#91;required&#93; The unique identifier (UUID) of the query.
#' @param Name &#91;required&#93; The name of the query.
#' @param Description The query description.
#' @param QueryString &#91;required&#93; The contents of the query with all query statements.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_named_query(
#'   NamedQueryId = "string",
#'   Name = "string",
#'   Description = "string",
#'   QueryString = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_named_query
#'
#' @aliases athena_update_named_query
athena_update_named_query <- function(NamedQueryId, Name, Description = NULL, QueryString) {
  op <- new_operation(
    name = "UpdateNamedQuery",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_named_query_input(NamedQueryId = NamedQueryId, Name = Name, Description = Description, QueryString = QueryString)
  output <- .athena$update_named_query_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_named_query <- athena_update_named_query

#' Updates the contents of a Spark notebook
#'
#' @description
#' Updates the contents of a Spark notebook.
#'
#' @usage
#' athena_update_notebook(NotebookId, Payload, Type, SessionId,
#'   ClientRequestToken)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook to update.
#' @param Payload &#91;required&#93; The updated content for the notebook.
#' @param Type &#91;required&#93; The notebook content type. Currently, the only valid type is `IPYNB`.
#' @param SessionId The active notebook session ID. Required if the notebook has an active
#' session.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' notebook is idempotent (executes only once).
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for you. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_notebook(
#'   NotebookId = "string",
#'   Payload = "string",
#'   Type = "IPYNB",
#'   SessionId = "string",
#'   ClientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_notebook
#'
#' @aliases athena_update_notebook
athena_update_notebook <- function(NotebookId, Payload, Type, SessionId = NULL, ClientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateNotebook",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_notebook_input(NotebookId = NotebookId, Payload = Payload, Type = Type, SessionId = SessionId, ClientRequestToken = ClientRequestToken)
  output <- .athena$update_notebook_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_notebook <- athena_update_notebook

#' Updates the metadata for a notebook
#'
#' @description
#' Updates the metadata for a notebook.
#'
#' @usage
#' athena_update_notebook_metadata(NotebookId, ClientRequestToken, Name)
#'
#' @param NotebookId &#91;required&#93; The ID of the notebook to update the metadata for.
#' @param ClientRequestToken A unique case-sensitive string used to ensure the request to create the
#' notebook is idempotent (executes only once).
#' 
#' This token is listed as not required because Amazon Web Services SDKs
#' (for example the Amazon Web Services SDK for Java) auto-generate the
#' token for you. If you are not using the Amazon Web Services SDK or the
#' Amazon Web Services CLI, you must provide this token or the action will
#' fail.
#' @param Name &#91;required&#93; The name to update the notebook to.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_notebook_metadata(
#'   NotebookId = "string",
#'   ClientRequestToken = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_notebook_metadata
#'
#' @aliases athena_update_notebook_metadata
athena_update_notebook_metadata <- function(NotebookId, ClientRequestToken = NULL, Name) {
  op <- new_operation(
    name = "UpdateNotebookMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_notebook_metadata_input(NotebookId = NotebookId, ClientRequestToken = ClientRequestToken, Name = Name)
  output <- .athena$update_notebook_metadata_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_notebook_metadata <- athena_update_notebook_metadata

#' Updates a prepared statement
#'
#' @description
#' Updates a prepared statement.
#'
#' @usage
#' athena_update_prepared_statement(StatementName, WorkGroup,
#'   QueryStatement, Description)
#'
#' @param StatementName &#91;required&#93; The name of the prepared statement.
#' @param WorkGroup &#91;required&#93; The workgroup for the prepared statement.
#' @param QueryStatement &#91;required&#93; The query string for the prepared statement.
#' @param Description The description of the prepared statement.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_prepared_statement(
#'   StatementName = "string",
#'   WorkGroup = "string",
#'   QueryStatement = "string",
#'   Description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_prepared_statement
#'
#' @aliases athena_update_prepared_statement
athena_update_prepared_statement <- function(StatementName, WorkGroup, QueryStatement, Description = NULL) {
  op <- new_operation(
    name = "UpdatePreparedStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_prepared_statement_input(StatementName = StatementName, WorkGroup = WorkGroup, QueryStatement = QueryStatement, Description = Description)
  output <- .athena$update_prepared_statement_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_prepared_statement <- athena_update_prepared_statement

#' Updates the workgroup with the specified name
#'
#' @description
#' Updates the workgroup with the specified name. The workgroup's name
#' cannot be changed. Only `ConfigurationUpdates` can be specified.
#'
#' @usage
#' athena_update_work_group(WorkGroup, Description, ConfigurationUpdates,
#'   State)
#'
#' @param WorkGroup &#91;required&#93; The specified workgroup that will be updated.
#' @param Description The workgroup description.
#' @param ConfigurationUpdates Contains configuration updates for an Athena SQL workgroup.
#' @param State The workgroup state that will be updated for the given workgroup.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_work_group(
#'   WorkGroup = "string",
#'   Description = "string",
#'   ConfigurationUpdates = list(
#'     EnforceWorkGroupConfiguration = TRUE|FALSE,
#'     ResultConfigurationUpdates = list(
#'       OutputLocation = "string",
#'       RemoveOutputLocation = TRUE|FALSE,
#'       EncryptionConfiguration = list(
#'         EncryptionOption = "SSE_S3"|"SSE_KMS"|"CSE_KMS",
#'         KmsKey = "string"
#'       ),
#'       RemoveEncryptionConfiguration = TRUE|FALSE,
#'       ExpectedBucketOwner = "string",
#'       RemoveExpectedBucketOwner = TRUE|FALSE,
#'       AclConfiguration = list(
#'         S3AclOption = "BUCKET_OWNER_FULL_CONTROL"
#'       ),
#'       RemoveAclConfiguration = TRUE|FALSE
#'     ),
#'     ManagedQueryResultsConfigurationUpdates = list(
#'       Enabled = TRUE|FALSE,
#'       EncryptionConfiguration = list(
#'         KmsKey = "string"
#'       ),
#'       RemoveEncryptionConfiguration = TRUE|FALSE
#'     ),
#'     PublishCloudWatchMetricsEnabled = TRUE|FALSE,
#'     BytesScannedCutoffPerQuery = 123,
#'     RemoveBytesScannedCutoffPerQuery = TRUE|FALSE,
#'     RequesterPaysEnabled = TRUE|FALSE,
#'     EngineVersion = list(
#'       SelectedEngineVersion = "string",
#'       EffectiveEngineVersion = "string"
#'     ),
#'     RemoveCustomerContentEncryptionConfiguration = TRUE|FALSE,
#'     AdditionalConfiguration = "string",
#'     ExecutionRole = "string",
#'     CustomerContentEncryptionConfiguration = list(
#'       KmsKey = "string"
#'     ),
#'     EnableMinimumEncryptionConfiguration = TRUE|FALSE,
#'     QueryResultsS3AccessGrantsConfiguration = list(
#'       EnableS3AccessGrants = TRUE|FALSE,
#'       CreateUserLevelPrefix = TRUE|FALSE,
#'       AuthenticationType = "DIRECTORY_IDENTITY"
#'     ),
#'     MonitoringConfiguration = list(
#'       CloudWatchLoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string",
#'         LogStreamNamePrefix = "string",
#'         LogTypes = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ManagedLoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         KmsKey = "string"
#'       ),
#'       S3LoggingConfiguration = list(
#'         Enabled = TRUE|FALSE,
#'         KmsKey = "string",
#'         LogLocation = "string"
#'       )
#'     ),
#'     EngineConfiguration = list(
#'       CoordinatorDpuSize = 123,
#'       MaxConcurrentDpus = 123,
#'       DefaultExecutorDpuSize = 123,
#'       AdditionalConfigs = list(
#'         "string"
#'       ),
#'       SparkProperties = list(
#'         "string"
#'       ),
#'       Classifications = list(
#'         list(
#'           Name = "string",
#'           Properties = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   State = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname athena_update_work_group
#'
#' @aliases athena_update_work_group
athena_update_work_group <- function(WorkGroup, Description = NULL, ConfigurationUpdates = NULL, State = NULL) {
  op <- new_operation(
    name = "UpdateWorkGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .athena$update_work_group_input(WorkGroup = WorkGroup, Description = Description, ConfigurationUpdates = ConfigurationUpdates, State = State)
  output <- .athena$update_work_group_output()
  config <- get_config()
  svc <- .athena$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.athena$operations$update_work_group <- athena_update_work_group

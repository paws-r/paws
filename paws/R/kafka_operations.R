# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include kafka_service.R
NULL

#' Associates one or more Scram Secrets with an Amazon MSK cluster
#'
#' @description
#' Associates one or more Scram Secrets with an Amazon MSK cluster.
#'
#' @usage
#' kafka_batch_associate_scram_secret(ClusterArn, SecretArnList)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param SecretArnList &#91;required&#93; List of AWS Secrets Manager secret ARNs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   UnprocessedScramSecrets = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string",
#'       SecretArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_associate_scram_secret(
#'   ClusterArn = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_batch_associate_scram_secret
#'
#' @aliases kafka_batch_associate_scram_secret
kafka_batch_associate_scram_secret <- function(ClusterArn, SecretArnList) {
  op <- new_operation(
    name = "BatchAssociateScramSecret",
    http_method = "POST",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$batch_associate_scram_secret_input(ClusterArn = ClusterArn, SecretArnList = SecretArnList)
  output <- .kafka$batch_associate_scram_secret_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$batch_associate_scram_secret <- kafka_batch_associate_scram_secret

#' Creates a new MSK cluster
#'
#' @description
#' Creates a new MSK cluster.
#'
#' @usage
#' kafka_create_cluster(BrokerNodeGroupInfo, Rebalancing,
#'   ClientAuthentication, ClusterName, ConfigurationInfo, EncryptionInfo,
#'   EnhancedMonitoring, OpenMonitoring, KafkaVersion, LoggingInfo,
#'   NumberOfBrokerNodes, Tags, StorageMode)
#'
#' @param BrokerNodeGroupInfo &#91;required&#93; Information about the broker nodes in the cluster.
#' @param Rebalancing Specifies if intelligent rebalancing should be turned on for the new MSK
#' Provisioned cluster with Express brokers. By default, intelligent
#' rebalancing status is ACTIVE for all new clusters.
#' @param ClientAuthentication Includes all client authentication related information.
#' @param ClusterName &#91;required&#93; The name of the cluster.
#' @param ConfigurationInfo Represents the configuration that you want MSK to use for the brokers in
#' a cluster.
#' @param EncryptionInfo Includes all encryption-related information.
#' @param EnhancedMonitoring Specifies the level of monitoring for the MSK cluster. The possible
#' values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and
#' PER_TOPIC_PER_PARTITION.
#' @param OpenMonitoring The settings for open monitoring.
#' @param KafkaVersion &#91;required&#93; The version of Apache Kafka.
#' @param LoggingInfo 
#' @param NumberOfBrokerNodes &#91;required&#93; The number of broker nodes in the cluster.
#' @param Tags Create tags when creating the cluster.
#' @param StorageMode This controls storage mode for supported storage tiers.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterName = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster(
#'   BrokerNodeGroupInfo = list(
#'     BrokerAZDistribution = "DEFAULT",
#'     ClientSubnets = list(
#'       "string"
#'     ),
#'     InstanceType = "string",
#'     SecurityGroups = list(
#'       "string"
#'     ),
#'     StorageInfo = list(
#'       EbsStorageInfo = list(
#'         ProvisionedThroughput = list(
#'           Enabled = TRUE|FALSE,
#'           VolumeThroughput = 123
#'         ),
#'         VolumeSize = 123
#'       )
#'     ),
#'     ConnectivityInfo = list(
#'       PublicAccess = list(
#'         Type = "string"
#'       ),
#'       VpcConnectivity = list(
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         )
#'       )
#'     ),
#'     ZoneIds = list(
#'       "string"
#'     )
#'   ),
#'   Rebalancing = list(
#'     Status = "PAUSED"|"ACTIVE"
#'   ),
#'   ClientAuthentication = list(
#'     Sasl = list(
#'       Scram = list(
#'         Enabled = TRUE|FALSE
#'       ),
#'       Iam = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     Tls = list(
#'       CertificateAuthorityArnList = list(
#'         "string"
#'       ),
#'       Enabled = TRUE|FALSE
#'     ),
#'     Unauthenticated = list(
#'       Enabled = TRUE|FALSE
#'     )
#'   ),
#'   ClusterName = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   EncryptionInfo = list(
#'     EncryptionAtRest = list(
#'       DataVolumeKMSKeyId = "string"
#'     ),
#'     EncryptionInTransit = list(
#'       ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'       InCluster = TRUE|FALSE
#'     )
#'   ),
#'   EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'   OpenMonitoring = list(
#'     Prometheus = list(
#'       JmxExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       ),
#'       NodeExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   KafkaVersion = "string",
#'   LoggingInfo = list(
#'     BrokerLogs = list(
#'       CloudWatchLogs = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string"
#'       ),
#'       Firehose = list(
#'         DeliveryStream = "string",
#'         Enabled = TRUE|FALSE
#'       ),
#'       S3 = list(
#'         Bucket = "string",
#'         Enabled = TRUE|FALSE,
#'         Prefix = "string"
#'       )
#'     )
#'   ),
#'   NumberOfBrokerNodes = 123,
#'   Tags = list(
#'     "string"
#'   ),
#'   StorageMode = "LOCAL"|"TIERED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_cluster
#'
#' @aliases kafka_create_cluster
kafka_create_cluster <- function(BrokerNodeGroupInfo, Rebalancing = NULL, ClientAuthentication = NULL, ClusterName, ConfigurationInfo = NULL, EncryptionInfo = NULL, EnhancedMonitoring = NULL, OpenMonitoring = NULL, KafkaVersion, LoggingInfo = NULL, NumberOfBrokerNodes, Tags = NULL, StorageMode = NULL) {
  op <- new_operation(
    name = "CreateCluster",
    http_method = "POST",
    http_path = "/v1/clusters",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$create_cluster_input(BrokerNodeGroupInfo = BrokerNodeGroupInfo, Rebalancing = Rebalancing, ClientAuthentication = ClientAuthentication, ClusterName = ClusterName, ConfigurationInfo = ConfigurationInfo, EncryptionInfo = EncryptionInfo, EnhancedMonitoring = EnhancedMonitoring, OpenMonitoring = OpenMonitoring, KafkaVersion = KafkaVersion, LoggingInfo = LoggingInfo, NumberOfBrokerNodes = NumberOfBrokerNodes, Tags = Tags, StorageMode = StorageMode)
  output <- .kafka$create_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_cluster <- kafka_create_cluster

#' Creates a new MSK cluster
#'
#' @description
#' Creates a new MSK cluster.
#'
#' @usage
#' kafka_create_cluster_v2(ClusterName, Tags, Provisioned, Serverless)
#'
#' @param ClusterName &#91;required&#93; The name of the cluster.
#' @param Tags A map of tags that you want the cluster to have.
#' @param Provisioned Information about the provisioned cluster.
#' @param Serverless Information about the serverless cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterName = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'   ClusterType = "PROVISIONED"|"SERVERLESS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster_v2(
#'   ClusterName = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Provisioned = list(
#'     BrokerNodeGroupInfo = list(
#'       BrokerAZDistribution = "DEFAULT",
#'       ClientSubnets = list(
#'         "string"
#'       ),
#'       InstanceType = "string",
#'       SecurityGroups = list(
#'         "string"
#'       ),
#'       StorageInfo = list(
#'         EbsStorageInfo = list(
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSize = 123
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         ),
#'         VpcConnectivity = list(
#'           ClientAuthentication = list(
#'             Sasl = list(
#'               Scram = list(
#'                 Enabled = TRUE|FALSE
#'               ),
#'               Iam = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             ),
#'             Tls = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       ),
#'       ZoneIds = list(
#'         "string"
#'       )
#'     ),
#'     Rebalancing = list(
#'       Status = "PAUSED"|"ACTIVE"
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Scram = list(
#'           Enabled = TRUE|FALSE
#'         ),
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       Tls = list(
#'         CertificateAuthorityArnList = list(
#'           "string"
#'         ),
#'         Enabled = TRUE|FALSE
#'       ),
#'       Unauthenticated = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     ConfigurationInfo = list(
#'       Arn = "string",
#'       Revision = 123
#'     ),
#'     EncryptionInfo = list(
#'       EncryptionAtRest = list(
#'         DataVolumeKMSKeyId = "string"
#'       ),
#'       EncryptionInTransit = list(
#'         ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'         InCluster = TRUE|FALSE
#'       )
#'     ),
#'     EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'     OpenMonitoring = list(
#'       Prometheus = list(
#'         JmxExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         ),
#'         NodeExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     KafkaVersion = "string",
#'     LoggingInfo = list(
#'       BrokerLogs = list(
#'         CloudWatchLogs = list(
#'           Enabled = TRUE|FALSE,
#'           LogGroup = "string"
#'         ),
#'         Firehose = list(
#'           DeliveryStream = "string",
#'           Enabled = TRUE|FALSE
#'         ),
#'         S3 = list(
#'           Bucket = "string",
#'           Enabled = TRUE|FALSE,
#'           Prefix = "string"
#'         )
#'       )
#'     ),
#'     NumberOfBrokerNodes = 123,
#'     StorageMode = "LOCAL"|"TIERED"
#'   ),
#'   Serverless = list(
#'     VpcConfigs = list(
#'       list(
#'         SubnetIds = list(
#'           "string"
#'         ),
#'         SecurityGroupIds = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_cluster_v2
#'
#' @aliases kafka_create_cluster_v2
kafka_create_cluster_v2 <- function(ClusterName, Tags = NULL, Provisioned = NULL, Serverless = NULL) {
  op <- new_operation(
    name = "CreateClusterV2",
    http_method = "POST",
    http_path = "/api/v2/clusters",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$create_cluster_v2_input(ClusterName = ClusterName, Tags = Tags, Provisioned = Provisioned, Serverless = Serverless)
  output <- .kafka$create_cluster_v2_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_cluster_v2 <- kafka_create_cluster_v2

#' Creates a new MSK configuration
#'
#' @description
#' Creates a new MSK configuration.
#'
#' @usage
#' kafka_create_configuration(Description, KafkaVersions, Name,
#'   ServerProperties)
#'
#' @param Description The description of the configuration.
#' @param KafkaVersions The versions of Apache Kafka with which you can use this MSK
#' configuration.
#' @param Name &#91;required&#93; The name of the configuration.
#' @param ServerProperties &#91;required&#93; Contents of the server.properties file. When using the API, you must
#' ensure that the contents of the file are base64 encoded. When using the
#' AWS Management Console, the SDK, or the AWS CLI, the contents of
#' server.properties can be in plaintext.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   ),
#'   Name = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_configuration(
#'   Description = "string",
#'   KafkaVersions = list(
#'     "string"
#'   ),
#'   Name = "string",
#'   ServerProperties = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_configuration
#'
#' @aliases kafka_create_configuration
kafka_create_configuration <- function(Description = NULL, KafkaVersions = NULL, Name, ServerProperties) {
  op <- new_operation(
    name = "CreateConfiguration",
    http_method = "POST",
    http_path = "/v1/configurations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$create_configuration_input(Description = Description, KafkaVersions = KafkaVersions, Name = Name, ServerProperties = ServerProperties)
  output <- .kafka$create_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_configuration <- kafka_create_configuration

#' Creates the replicator
#'
#' @description
#' Creates the replicator.
#'
#' @usage
#' kafka_create_replicator(Description, KafkaClusters, ReplicationInfoList,
#'   ReplicatorName, ServiceExecutionRoleArn, Tags)
#'
#' @param Description A summary description of the replicator.
#' @param KafkaClusters &#91;required&#93; Kafka Clusters to use in setting up sources / targets for replication.
#' @param ReplicationInfoList &#91;required&#93; A list of replication configurations, where each configuration targets a
#' given source cluster to target cluster replication flow.
#' @param ReplicatorName &#91;required&#93; The name of the replicator. Alpha-numeric characters with '-' are
#' allowed.
#' @param ServiceExecutionRoleArn &#91;required&#93; The ARN of the IAM role used by the replicator to access resources in
#' the customer's account (e.g source and target clusters)
#' @param Tags List of tags to attach to created Replicator.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ReplicatorArn = "string",
#'   ReplicatorName = "string",
#'   ReplicatorState = "RUNNING"|"CREATING"|"UPDATING"|"DELETING"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_replicator(
#'   Description = "string",
#'   KafkaClusters = list(
#'     list(
#'       AmazonMskCluster = list(
#'         MskClusterArn = "string"
#'       ),
#'       VpcConfig = list(
#'         SecurityGroupIds = list(
#'           "string"
#'         ),
#'         SubnetIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ReplicationInfoList = list(
#'     list(
#'       ConsumerGroupReplication = list(
#'         ConsumerGroupsToExclude = list(
#'           "string"
#'         ),
#'         ConsumerGroupsToReplicate = list(
#'           "string"
#'         ),
#'         DetectAndCopyNewConsumerGroups = TRUE|FALSE,
#'         SynchroniseConsumerGroupOffsets = TRUE|FALSE
#'       ),
#'       SourceKafkaClusterArn = "string",
#'       TargetCompressionType = "NONE"|"GZIP"|"SNAPPY"|"LZ4"|"ZSTD",
#'       TargetKafkaClusterArn = "string",
#'       TopicReplication = list(
#'         CopyAccessControlListsForTopics = TRUE|FALSE,
#'         CopyTopicConfigurations = TRUE|FALSE,
#'         DetectAndCopyNewTopics = TRUE|FALSE,
#'         StartingPosition = list(
#'           Type = "LATEST"|"EARLIEST"
#'         ),
#'         TopicNameConfiguration = list(
#'           Type = "PREFIXED_WITH_SOURCE_CLUSTER_ALIAS"|"IDENTICAL"
#'         ),
#'         TopicsToExclude = list(
#'           "string"
#'         ),
#'         TopicsToReplicate = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ReplicatorName = "string",
#'   ServiceExecutionRoleArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_replicator
#'
#' @aliases kafka_create_replicator
kafka_create_replicator <- function(Description = NULL, KafkaClusters, ReplicationInfoList, ReplicatorName, ServiceExecutionRoleArn, Tags = NULL) {
  op <- new_operation(
    name = "CreateReplicator",
    http_method = "POST",
    http_path = "/replication/v1/replicators",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$create_replicator_input(Description = Description, KafkaClusters = KafkaClusters, ReplicationInfoList = ReplicationInfoList, ReplicatorName = ReplicatorName, ServiceExecutionRoleArn = ServiceExecutionRoleArn, Tags = Tags)
  output <- .kafka$create_replicator_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_replicator <- kafka_create_replicator

#' Creates a new MSK VPC connection
#'
#' @description
#' Creates a new MSK VPC connection.
#'
#' @usage
#' kafka_create_vpc_connection(TargetClusterArn, Authentication, VpcId,
#'   ClientSubnets, SecurityGroups, Tags)
#'
#' @param TargetClusterArn &#91;required&#93; The cluster Amazon Resource Name (ARN) for the VPC connection.
#' @param Authentication &#91;required&#93; The authentication type of VPC connection.
#' @param VpcId &#91;required&#93; The VPC ID of VPC connection.
#' @param ClientSubnets &#91;required&#93; The list of client subnets.
#' @param SecurityGroups &#91;required&#93; The list of security groups.
#' @param Tags A map of tags for the VPC connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcConnectionArn = "string",
#'   State = "CREATING"|"AVAILABLE"|"INACTIVE"|"DEACTIVATING"|"DELETING"|"FAILED"|"REJECTED"|"REJECTING",
#'   Authentication = "string",
#'   VpcId = "string",
#'   ClientSubnets = list(
#'     "string"
#'   ),
#'   SecurityGroups = list(
#'     "string"
#'   ),
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_vpc_connection(
#'   TargetClusterArn = "string",
#'   Authentication = "string",
#'   VpcId = "string",
#'   ClientSubnets = list(
#'     "string"
#'   ),
#'   SecurityGroups = list(
#'     "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_vpc_connection
#'
#' @aliases kafka_create_vpc_connection
kafka_create_vpc_connection <- function(TargetClusterArn, Authentication, VpcId, ClientSubnets, SecurityGroups, Tags = NULL) {
  op <- new_operation(
    name = "CreateVpcConnection",
    http_method = "POST",
    http_path = "/v1/vpc-connection",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$create_vpc_connection_input(TargetClusterArn = TargetClusterArn, Authentication = Authentication, VpcId = VpcId, ClientSubnets = ClientSubnets, SecurityGroups = SecurityGroups, Tags = Tags)
  output <- .kafka$create_vpc_connection_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_vpc_connection <- kafka_create_vpc_connection

#' Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in
#' the request
#'
#' @description
#' Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in
#' the request.
#'
#' @usage
#' kafka_delete_cluster(ClusterArn, CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion The current version of the MSK cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_cluster(
#'   ClusterArn = "string",
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_cluster
#'
#' @aliases kafka_delete_cluster
kafka_delete_cluster <- function(ClusterArn, CurrentVersion = NULL) {
  op <- new_operation(
    name = "DeleteCluster",
    http_method = "DELETE",
    http_path = "/v1/clusters/{clusterArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$delete_cluster_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion)
  output <- .kafka$delete_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_cluster <- kafka_delete_cluster

#' Deletes the MSK cluster policy specified by the Amazon Resource Name
#' (ARN) in the request
#'
#' @description
#' Deletes the MSK cluster policy specified by the Amazon Resource Name
#' (ARN) in the request.
#'
#' @usage
#' kafka_delete_cluster_policy(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_cluster_policy(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_cluster_policy
#'
#' @aliases kafka_delete_cluster_policy
kafka_delete_cluster_policy <- function(ClusterArn) {
  op <- new_operation(
    name = "DeleteClusterPolicy",
    http_method = "DELETE",
    http_path = "/v1/clusters/{clusterArn}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$delete_cluster_policy_input(ClusterArn = ClusterArn)
  output <- .kafka$delete_cluster_policy_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_cluster_policy <- kafka_delete_cluster_policy

#' Deletes an MSK Configuration
#'
#' @description
#' Deletes an MSK Configuration.
#'
#' @usage
#' kafka_delete_configuration(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_configuration(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_configuration
#'
#' @aliases kafka_delete_configuration
kafka_delete_configuration <- function(Arn) {
  op <- new_operation(
    name = "DeleteConfiguration",
    http_method = "DELETE",
    http_path = "/v1/configurations/{arn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$delete_configuration_input(Arn = Arn)
  output <- .kafka$delete_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_configuration <- kafka_delete_configuration

#' Deletes a replicator
#'
#' @description
#' Deletes a replicator.
#'
#' @usage
#' kafka_delete_replicator(CurrentVersion, ReplicatorArn)
#'
#' @param CurrentVersion The current version of the replicator.
#' @param ReplicatorArn &#91;required&#93; The Amazon Resource Name (ARN) of the replicator to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ReplicatorArn = "string",
#'   ReplicatorState = "RUNNING"|"CREATING"|"UPDATING"|"DELETING"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_replicator(
#'   CurrentVersion = "string",
#'   ReplicatorArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_replicator
#'
#' @aliases kafka_delete_replicator
kafka_delete_replicator <- function(CurrentVersion = NULL, ReplicatorArn) {
  op <- new_operation(
    name = "DeleteReplicator",
    http_method = "DELETE",
    http_path = "/replication/v1/replicators/{replicatorArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$delete_replicator_input(CurrentVersion = CurrentVersion, ReplicatorArn = ReplicatorArn)
  output <- .kafka$delete_replicator_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_replicator <- kafka_delete_replicator

#' Deletes a MSK VPC connection
#'
#' @description
#' Deletes a MSK VPC connection.
#'
#' @usage
#' kafka_delete_vpc_connection(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC
#' connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcConnectionArn = "string",
#'   State = "CREATING"|"AVAILABLE"|"INACTIVE"|"DEACTIVATING"|"DELETING"|"FAILED"|"REJECTED"|"REJECTING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_vpc_connection(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_vpc_connection
#'
#' @aliases kafka_delete_vpc_connection
kafka_delete_vpc_connection <- function(Arn) {
  op <- new_operation(
    name = "DeleteVpcConnection",
    http_method = "DELETE",
    http_path = "/v1/vpc-connection/{arn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$delete_vpc_connection_input(Arn = Arn)
  output <- .kafka$delete_vpc_connection_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_vpc_connection <- kafka_delete_vpc_connection

#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request
#'
#' @description
#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request.
#'
#' @usage
#' kafka_describe_cluster(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfo = list(
#'     ActiveOperationArn = "string",
#'     BrokerNodeGroupInfo = list(
#'       BrokerAZDistribution = "DEFAULT",
#'       ClientSubnets = list(
#'         "string"
#'       ),
#'       InstanceType = "string",
#'       SecurityGroups = list(
#'         "string"
#'       ),
#'       StorageInfo = list(
#'         EbsStorageInfo = list(
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSize = 123
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         ),
#'         VpcConnectivity = list(
#'           ClientAuthentication = list(
#'             Sasl = list(
#'               Scram = list(
#'                 Enabled = TRUE|FALSE
#'               ),
#'               Iam = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             ),
#'             Tls = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       ),
#'       ZoneIds = list(
#'         "string"
#'       )
#'     ),
#'     Rebalancing = list(
#'       Status = "PAUSED"|"ACTIVE"
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Scram = list(
#'           Enabled = TRUE|FALSE
#'         ),
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       Tls = list(
#'         CertificateAuthorityArnList = list(
#'           "string"
#'         ),
#'         Enabled = TRUE|FALSE
#'       ),
#'       Unauthenticated = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     ClusterArn = "string",
#'     ClusterName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CurrentBrokerSoftwareInfo = list(
#'       ConfigurationArn = "string",
#'       ConfigurationRevision = 123,
#'       KafkaVersion = "string"
#'     ),
#'     CurrentVersion = "string",
#'     EncryptionInfo = list(
#'       EncryptionAtRest = list(
#'         DataVolumeKMSKeyId = "string"
#'       ),
#'       EncryptionInTransit = list(
#'         ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'         InCluster = TRUE|FALSE
#'       )
#'     ),
#'     EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'     OpenMonitoring = list(
#'       Prometheus = list(
#'         JmxExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         ),
#'         NodeExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     LoggingInfo = list(
#'       BrokerLogs = list(
#'         CloudWatchLogs = list(
#'           Enabled = TRUE|FALSE,
#'           LogGroup = "string"
#'         ),
#'         Firehose = list(
#'           DeliveryStream = "string",
#'           Enabled = TRUE|FALSE
#'         ),
#'         S3 = list(
#'           Bucket = "string",
#'           Enabled = TRUE|FALSE,
#'           Prefix = "string"
#'         )
#'       )
#'     ),
#'     NumberOfBrokerNodes = 123,
#'     State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'     StateInfo = list(
#'       Code = "string",
#'       Message = "string"
#'     ),
#'     Tags = list(
#'       "string"
#'     ),
#'     ZookeeperConnectString = "string",
#'     ZookeeperConnectStringTls = "string",
#'     StorageMode = "LOCAL"|"TIERED",
#'     CustomerActionStatus = "CRITICAL_ACTION_REQUIRED"|"ACTION_RECOMMENDED"|"NONE"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster
#'
#' @aliases kafka_describe_cluster
kafka_describe_cluster <- function(ClusterArn) {
  op <- new_operation(
    name = "DescribeCluster",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_cluster_input(ClusterArn = ClusterArn)
  output <- .kafka$describe_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster <- kafka_describe_cluster

#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request
#'
#' @description
#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request.
#'
#' @usage
#' kafka_describe_cluster_v2(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfo = list(
#'     ActiveOperationArn = "string",
#'     ClusterType = "PROVISIONED"|"SERVERLESS",
#'     ClusterArn = "string",
#'     ClusterName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CurrentVersion = "string",
#'     State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'     StateInfo = list(
#'       Code = "string",
#'       Message = "string"
#'     ),
#'     Tags = list(
#'       "string"
#'     ),
#'     Provisioned = list(
#'       BrokerNodeGroupInfo = list(
#'         BrokerAZDistribution = "DEFAULT",
#'         ClientSubnets = list(
#'           "string"
#'         ),
#'         InstanceType = "string",
#'         SecurityGroups = list(
#'           "string"
#'         ),
#'         StorageInfo = list(
#'           EbsStorageInfo = list(
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSize = 123
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         ZoneIds = list(
#'           "string"
#'         )
#'       ),
#'       Rebalancing = list(
#'         Status = "PAUSED"|"ACTIVE"
#'       ),
#'       CurrentBrokerSoftwareInfo = list(
#'         ConfigurationArn = "string",
#'         ConfigurationRevision = 123,
#'         KafkaVersion = "string"
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       ZookeeperConnectString = "string",
#'       ZookeeperConnectStringTls = "string",
#'       StorageMode = "LOCAL"|"TIERED",
#'       CustomerActionStatus = "CRITICAL_ACTION_REQUIRED"|"ACTION_RECOMMENDED"|"NONE"
#'     ),
#'     Serverless = list(
#'       VpcConfigs = list(
#'         list(
#'           SubnetIds = list(
#'             "string"
#'           ),
#'           SecurityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_v2(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster_v2
#'
#' @aliases kafka_describe_cluster_v2
kafka_describe_cluster_v2 <- function(ClusterArn) {
  op <- new_operation(
    name = "DescribeClusterV2",
    http_method = "GET",
    http_path = "/api/v2/clusters/{clusterArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_cluster_v2_input(ClusterArn = ClusterArn)
  output <- .kafka$describe_cluster_v2_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster_v2 <- kafka_describe_cluster_v2

#' Returns a description of the cluster operation specified by the ARN
#'
#' @description
#' Returns a description of the cluster operation specified by the ARN.
#'
#' @usage
#' kafka_describe_cluster_operation(ClusterOperationArn)
#'
#' @param ClusterOperationArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster
#' operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfo = list(
#'     ClientRequestId = "string",
#'     ClusterArn = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ErrorInfo = list(
#'       ErrorCode = "string",
#'       ErrorString = "string"
#'     ),
#'     OperationArn = "string",
#'     OperationState = "string",
#'     OperationSteps = list(
#'       list(
#'         StepInfo = list(
#'           StepStatus = "string"
#'         ),
#'         StepName = "string"
#'       )
#'     ),
#'     OperationType = "string",
#'     SourceClusterInfo = list(
#'       BrokerEBSVolumeInfo = list(
#'         list(
#'           KafkaBrokerNodeId = "string",
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSizeGB = 123
#'         )
#'       ),
#'       ConfigurationInfo = list(
#'         Arn = "string",
#'         Revision = 123
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       KafkaVersion = "string",
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       InstanceType = "string",
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         ),
#'         VpcConnectivity = list(
#'           ClientAuthentication = list(
#'             Sasl = list(
#'               Scram = list(
#'                 Enabled = TRUE|FALSE
#'               ),
#'               Iam = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             ),
#'             Tls = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       ),
#'       StorageMode = "LOCAL"|"TIERED",
#'       BrokerCountUpdateInfo = list(
#'         CreatedBrokerIds = list(
#'           123.0
#'         ),
#'         DeletedBrokerIds = list(
#'           123.0
#'         )
#'       ),
#'       Rebalancing = list(
#'         Status = "PAUSED"|"ACTIVE"
#'       )
#'     ),
#'     TargetClusterInfo = list(
#'       BrokerEBSVolumeInfo = list(
#'         list(
#'           KafkaBrokerNodeId = "string",
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSizeGB = 123
#'         )
#'       ),
#'       ConfigurationInfo = list(
#'         Arn = "string",
#'         Revision = 123
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       KafkaVersion = "string",
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       InstanceType = "string",
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         ),
#'         VpcConnectivity = list(
#'           ClientAuthentication = list(
#'             Sasl = list(
#'               Scram = list(
#'                 Enabled = TRUE|FALSE
#'               ),
#'               Iam = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             ),
#'             Tls = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       ),
#'       StorageMode = "LOCAL"|"TIERED",
#'       BrokerCountUpdateInfo = list(
#'         CreatedBrokerIds = list(
#'           123.0
#'         ),
#'         DeletedBrokerIds = list(
#'           123.0
#'         )
#'       ),
#'       Rebalancing = list(
#'         Status = "PAUSED"|"ACTIVE"
#'       )
#'     ),
#'     VpcConnectionInfo = list(
#'       VpcConnectionArn = "string",
#'       Owner = "string",
#'       UserIdentity = list(
#'         Type = "AWSACCOUNT"|"AWSSERVICE",
#'         PrincipalId = "string"
#'       ),
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_operation(
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster_operation
#'
#' @aliases kafka_describe_cluster_operation
kafka_describe_cluster_operation <- function(ClusterOperationArn) {
  op <- new_operation(
    name = "DescribeClusterOperation",
    http_method = "GET",
    http_path = "/v1/operations/{clusterOperationArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_cluster_operation_input(ClusterOperationArn = ClusterOperationArn)
  output <- .kafka$describe_cluster_operation_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster_operation <- kafka_describe_cluster_operation

#' Returns a description of the cluster operation specified by the ARN
#'
#' @description
#' Returns a description of the cluster operation specified by the ARN.
#'
#' @usage
#' kafka_describe_cluster_operation_v2(ClusterOperationArn)
#'
#' @param ClusterOperationArn &#91;required&#93; ARN of the cluster operation to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfo = list(
#'     ClusterArn = "string",
#'     ClusterType = "PROVISIONED"|"SERVERLESS",
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ErrorInfo = list(
#'       ErrorCode = "string",
#'       ErrorString = "string"
#'     ),
#'     OperationArn = "string",
#'     OperationState = "string",
#'     OperationType = "string",
#'     Provisioned = list(
#'       OperationSteps = list(
#'         list(
#'           StepInfo = list(
#'             StepStatus = "string"
#'           ),
#'           StepName = "string"
#'         )
#'       ),
#'       SourceClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         StorageMode = "LOCAL"|"TIERED",
#'         BrokerCountUpdateInfo = list(
#'           CreatedBrokerIds = list(
#'             123.0
#'           ),
#'           DeletedBrokerIds = list(
#'             123.0
#'           )
#'         ),
#'         Rebalancing = list(
#'           Status = "PAUSED"|"ACTIVE"
#'         )
#'       ),
#'       TargetClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         StorageMode = "LOCAL"|"TIERED",
#'         BrokerCountUpdateInfo = list(
#'           CreatedBrokerIds = list(
#'             123.0
#'           ),
#'           DeletedBrokerIds = list(
#'             123.0
#'           )
#'         ),
#'         Rebalancing = list(
#'           Status = "PAUSED"|"ACTIVE"
#'         )
#'       ),
#'       VpcConnectionInfo = list(
#'         VpcConnectionArn = "string",
#'         Owner = "string",
#'         UserIdentity = list(
#'           Type = "AWSACCOUNT"|"AWSSERVICE",
#'           PrincipalId = "string"
#'         ),
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     ),
#'     Serverless = list(
#'       VpcConnectionInfo = list(
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Owner = "string",
#'         UserIdentity = list(
#'           Type = "AWSACCOUNT"|"AWSSERVICE",
#'           PrincipalId = "string"
#'         ),
#'         VpcConnectionArn = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_operation_v2(
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster_operation_v2
#'
#' @aliases kafka_describe_cluster_operation_v2
kafka_describe_cluster_operation_v2 <- function(ClusterOperationArn) {
  op <- new_operation(
    name = "DescribeClusterOperationV2",
    http_method = "GET",
    http_path = "/api/v2/operations/{clusterOperationArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_cluster_operation_v2_input(ClusterOperationArn = ClusterOperationArn)
  output <- .kafka$describe_cluster_operation_v2_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster_operation_v2 <- kafka_describe_cluster_operation_v2

#' Returns a description of this MSK configuration
#'
#' @description
#' Returns a description of this MSK configuration.
#'
#' @usage
#' kafka_describe_configuration(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   KafkaVersions = list(
#'     "string"
#'   ),
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   ),
#'   Name = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_configuration(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_configuration
#'
#' @aliases kafka_describe_configuration
kafka_describe_configuration <- function(Arn) {
  op <- new_operation(
    name = "DescribeConfiguration",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_configuration_input(Arn = Arn)
  output <- .kafka$describe_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_configuration <- kafka_describe_configuration

#' Returns a description of this revision of the configuration
#'
#' @description
#' Returns a description of this revision of the configuration.
#'
#' @usage
#' kafka_describe_configuration_revision(Arn, Revision)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#' @param Revision &#91;required&#93; A string that uniquely identifies a revision of an MSK configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   Revision = 123,
#'   ServerProperties = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_configuration_revision(
#'   Arn = "string",
#'   Revision = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_configuration_revision
#'
#' @aliases kafka_describe_configuration_revision
kafka_describe_configuration_revision <- function(Arn, Revision) {
  op <- new_operation(
    name = "DescribeConfigurationRevision",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}/revisions/{revision}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_configuration_revision_input(Arn = Arn, Revision = Revision)
  output <- .kafka$describe_configuration_revision_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_configuration_revision <- kafka_describe_configuration_revision

#' Describes a replicator
#'
#' @description
#' Describes a replicator.
#'
#' @usage
#' kafka_describe_replicator(ReplicatorArn)
#'
#' @param ReplicatorArn &#91;required&#93; The Amazon Resource Name (ARN) of the replicator to be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   CurrentVersion = "string",
#'   IsReplicatorReference = TRUE|FALSE,
#'   KafkaClusters = list(
#'     list(
#'       AmazonMskCluster = list(
#'         MskClusterArn = "string"
#'       ),
#'       KafkaClusterAlias = "string",
#'       VpcConfig = list(
#'         SecurityGroupIds = list(
#'           "string"
#'         ),
#'         SubnetIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ReplicationInfoList = list(
#'     list(
#'       ConsumerGroupReplication = list(
#'         ConsumerGroupsToExclude = list(
#'           "string"
#'         ),
#'         ConsumerGroupsToReplicate = list(
#'           "string"
#'         ),
#'         DetectAndCopyNewConsumerGroups = TRUE|FALSE,
#'         SynchroniseConsumerGroupOffsets = TRUE|FALSE
#'       ),
#'       SourceKafkaClusterAlias = "string",
#'       TargetCompressionType = "NONE"|"GZIP"|"SNAPPY"|"LZ4"|"ZSTD",
#'       TargetKafkaClusterAlias = "string",
#'       TopicReplication = list(
#'         CopyAccessControlListsForTopics = TRUE|FALSE,
#'         CopyTopicConfigurations = TRUE|FALSE,
#'         DetectAndCopyNewTopics = TRUE|FALSE,
#'         StartingPosition = list(
#'           Type = "LATEST"|"EARLIEST"
#'         ),
#'         TopicNameConfiguration = list(
#'           Type = "PREFIXED_WITH_SOURCE_CLUSTER_ALIAS"|"IDENTICAL"
#'         ),
#'         TopicsToExclude = list(
#'           "string"
#'         ),
#'         TopicsToReplicate = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ReplicatorArn = "string",
#'   ReplicatorDescription = "string",
#'   ReplicatorName = "string",
#'   ReplicatorResourceArn = "string",
#'   ReplicatorState = "RUNNING"|"CREATING"|"UPDATING"|"DELETING"|"FAILED",
#'   ServiceExecutionRoleArn = "string",
#'   StateInfo = list(
#'     Code = "string",
#'     Message = "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_replicator(
#'   ReplicatorArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_replicator
#'
#' @aliases kafka_describe_replicator
kafka_describe_replicator <- function(ReplicatorArn) {
  op <- new_operation(
    name = "DescribeReplicator",
    http_method = "GET",
    http_path = "/replication/v1/replicators/{replicatorArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_replicator_input(ReplicatorArn = ReplicatorArn)
  output <- .kafka$describe_replicator_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_replicator <- kafka_describe_replicator

#' Returns topic details of this topic on a MSK cluster
#'
#' @description
#' Returns topic details of this topic on a MSK cluster.
#'
#' @usage
#' kafka_describe_topic(ClusterArn, TopicName)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param TopicName &#91;required&#93; The Kafka topic name that uniquely identifies the topic.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TopicArn = "string",
#'   TopicName = "string",
#'   ReplicationFactor = 123,
#'   PartitionCount = 123,
#'   Configs = "string",
#'   Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_topic(
#'   ClusterArn = "string",
#'   TopicName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_topic
#'
#' @aliases kafka_describe_topic
kafka_describe_topic <- function(ClusterArn, TopicName) {
  op <- new_operation(
    name = "DescribeTopic",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/topics/{topicName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_topic_input(ClusterArn = ClusterArn, TopicName = TopicName)
  output <- .kafka$describe_topic_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_topic <- kafka_describe_topic

#' Returns partition details of this topic on a MSK cluster
#'
#' @description
#' Returns partition details of this topic on a MSK cluster.
#'
#' @usage
#' kafka_describe_topic_partitions(ClusterArn, TopicName, MaxResults,
#'   NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param TopicName &#91;required&#93; The Kafka topic name that uniquely identifies the topic.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Partitions = list(
#'     list(
#'       Partition = 123,
#'       Leader = 123,
#'       Replicas = list(
#'         123
#'       ),
#'       Isr = list(
#'         123
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_topic_partitions(
#'   ClusterArn = "string",
#'   TopicName = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_topic_partitions
#'
#' @aliases kafka_describe_topic_partitions
kafka_describe_topic_partitions <- function(ClusterArn, TopicName, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "DescribeTopicPartitions",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/topics/{topicName}/partitions",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Partitions"),
    stream_api = FALSE
  )
  input <- .kafka$describe_topic_partitions_input(ClusterArn = ClusterArn, TopicName = TopicName, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$describe_topic_partitions_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_topic_partitions <- kafka_describe_topic_partitions

#' Returns a description of this MSK VPC connection
#'
#' @description
#' Returns a description of this MSK VPC connection.
#'
#' @usage
#' kafka_describe_vpc_connection(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC
#' connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcConnectionArn = "string",
#'   TargetClusterArn = "string",
#'   State = "CREATING"|"AVAILABLE"|"INACTIVE"|"DEACTIVATING"|"DELETING"|"FAILED"|"REJECTED"|"REJECTING",
#'   Authentication = "string",
#'   VpcId = "string",
#'   Subnets = list(
#'     "string"
#'   ),
#'   SecurityGroups = list(
#'     "string"
#'   ),
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_vpc_connection(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_vpc_connection
#'
#' @aliases kafka_describe_vpc_connection
kafka_describe_vpc_connection <- function(Arn) {
  op <- new_operation(
    name = "DescribeVpcConnection",
    http_method = "GET",
    http_path = "/v1/vpc-connection/{arn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$describe_vpc_connection_input(Arn = Arn)
  output <- .kafka$describe_vpc_connection_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_vpc_connection <- kafka_describe_vpc_connection

#' Disassociates one or more Scram Secrets from an Amazon MSK cluster
#'
#' @description
#' Disassociates one or more Scram Secrets from an Amazon MSK cluster.
#'
#' @usage
#' kafka_batch_disassociate_scram_secret(ClusterArn, SecretArnList)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param SecretArnList &#91;required&#93; List of AWS Secrets Manager secret ARNs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   UnprocessedScramSecrets = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string",
#'       SecretArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_disassociate_scram_secret(
#'   ClusterArn = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_batch_disassociate_scram_secret
#'
#' @aliases kafka_batch_disassociate_scram_secret
kafka_batch_disassociate_scram_secret <- function(ClusterArn, SecretArnList) {
  op <- new_operation(
    name = "BatchDisassociateScramSecret",
    http_method = "PATCH",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$batch_disassociate_scram_secret_input(ClusterArn = ClusterArn, SecretArnList = SecretArnList)
  output <- .kafka$batch_disassociate_scram_secret_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$batch_disassociate_scram_secret <- kafka_batch_disassociate_scram_secret

#' A list of brokers that a client application can use to bootstrap
#'
#' @description
#' A list of brokers that a client application can use to bootstrap. This
#' list doesn't necessarily include all of the brokers in the cluster. The
#' following Python 3.6 example shows how you can use the Amazon Resource
#' Name (ARN) of a cluster to get its bootstrap brokers. If you don't know
#' the ARN of your cluster, you can use the
#' [`list_clusters`][kafka_list_clusters] operation to get the ARNs of all
#' the clusters in this account and Region.
#'
#' @usage
#' kafka_get_bootstrap_brokers(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BootstrapBrokerString = "string",
#'   BootstrapBrokerStringTls = "string",
#'   BootstrapBrokerStringSaslScram = "string",
#'   BootstrapBrokerStringSaslIam = "string",
#'   BootstrapBrokerStringPublicTls = "string",
#'   BootstrapBrokerStringPublicSaslScram = "string",
#'   BootstrapBrokerStringPublicSaslIam = "string",
#'   BootstrapBrokerStringVpcConnectivityTls = "string",
#'   BootstrapBrokerStringVpcConnectivitySaslScram = "string",
#'   BootstrapBrokerStringVpcConnectivitySaslIam = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_bootstrap_brokers(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_get_bootstrap_brokers
#'
#' @aliases kafka_get_bootstrap_brokers
kafka_get_bootstrap_brokers <- function(ClusterArn) {
  op <- new_operation(
    name = "GetBootstrapBrokers",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/bootstrap-brokers",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$get_bootstrap_brokers_input(ClusterArn = ClusterArn)
  output <- .kafka$get_bootstrap_brokers_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$get_bootstrap_brokers <- kafka_get_bootstrap_brokers

#' Gets the Apache Kafka versions to which you can update the MSK cluster
#'
#' @description
#' Gets the Apache Kafka versions to which you can update the MSK cluster.
#'
#' @usage
#' kafka_get_compatible_kafka_versions(ClusterArn)
#'
#' @param ClusterArn The Amazon Resource Name (ARN) of the cluster check.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CompatibleKafkaVersions = list(
#'     list(
#'       SourceVersion = "string",
#'       TargetVersions = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_compatible_kafka_versions(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_get_compatible_kafka_versions
#'
#' @aliases kafka_get_compatible_kafka_versions
kafka_get_compatible_kafka_versions <- function(ClusterArn = NULL) {
  op <- new_operation(
    name = "GetCompatibleKafkaVersions",
    http_method = "GET",
    http_path = "/v1/compatible-kafka-versions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$get_compatible_kafka_versions_input(ClusterArn = ClusterArn)
  output <- .kafka$get_compatible_kafka_versions_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$get_compatible_kafka_versions <- kafka_get_compatible_kafka_versions

#' Get the MSK cluster policy specified by the Amazon Resource Name (ARN)
#' in the request
#'
#' @description
#' Get the MSK cluster policy specified by the Amazon Resource Name (ARN)
#' in the request.
#'
#' @usage
#' kafka_get_cluster_policy(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CurrentVersion = "string",
#'   Policy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_cluster_policy(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_get_cluster_policy
#'
#' @aliases kafka_get_cluster_policy
kafka_get_cluster_policy <- function(ClusterArn) {
  op <- new_operation(
    name = "GetClusterPolicy",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$get_cluster_policy_input(ClusterArn = ClusterArn)
  output <- .kafka$get_cluster_policy_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$get_cluster_policy <- kafka_get_cluster_policy

#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster
#'
#' @description
#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster.
#'
#' @usage
#' kafka_list_cluster_operations(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfoList = list(
#'     list(
#'       ClientRequestId = "string",
#'       ClusterArn = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ErrorInfo = list(
#'         ErrorCode = "string",
#'         ErrorString = "string"
#'       ),
#'       OperationArn = "string",
#'       OperationState = "string",
#'       OperationSteps = list(
#'         list(
#'           StepInfo = list(
#'             StepStatus = "string"
#'           ),
#'           StepName = "string"
#'         )
#'       ),
#'       OperationType = "string",
#'       SourceClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         StorageMode = "LOCAL"|"TIERED",
#'         BrokerCountUpdateInfo = list(
#'           CreatedBrokerIds = list(
#'             123.0
#'           ),
#'           DeletedBrokerIds = list(
#'             123.0
#'           )
#'         ),
#'         Rebalancing = list(
#'           Status = "PAUSED"|"ACTIVE"
#'         )
#'       ),
#'       TargetClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         StorageMode = "LOCAL"|"TIERED",
#'         BrokerCountUpdateInfo = list(
#'           CreatedBrokerIds = list(
#'             123.0
#'           ),
#'           DeletedBrokerIds = list(
#'             123.0
#'           )
#'         ),
#'         Rebalancing = list(
#'           Status = "PAUSED"|"ACTIVE"
#'         )
#'       ),
#'       VpcConnectionInfo = list(
#'         VpcConnectionArn = "string",
#'         Owner = "string",
#'         UserIdentity = list(
#'           Type = "AWSACCOUNT"|"AWSSERVICE",
#'           PrincipalId = "string"
#'         ),
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_cluster_operations(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_cluster_operations
#'
#' @aliases kafka_list_cluster_operations
kafka_list_cluster_operations <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClusterOperations",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/operations",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ClusterOperationInfoList"),
    stream_api = FALSE
  )
  input <- .kafka$list_cluster_operations_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_cluster_operations_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_cluster_operations <- kafka_list_cluster_operations

#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster
#'
#' @description
#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster.
#'
#' @usage
#' kafka_list_cluster_operations_v2(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The arn of the cluster whose operations are being requested.
#' @param MaxResults The maxResults of the query.
#' @param NextToken The nextToken of the query.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfoList = list(
#'     list(
#'       ClusterArn = "string",
#'       ClusterType = "PROVISIONED"|"SERVERLESS",
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       OperationArn = "string",
#'       OperationState = "string",
#'       OperationType = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_cluster_operations_v2(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_cluster_operations_v2
#'
#' @aliases kafka_list_cluster_operations_v2
kafka_list_cluster_operations_v2 <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClusterOperationsV2",
    http_method = "GET",
    http_path = "/api/v2/clusters/{clusterArn}/operations",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ClusterOperationInfoList"),
    stream_api = FALSE
  )
  input <- .kafka$list_cluster_operations_v2_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_cluster_operations_v2_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_cluster_operations_v2 <- kafka_list_cluster_operations_v2

#' Returns a list of all the MSK clusters in the current Region
#'
#' @description
#' Returns a list of all the MSK clusters in the current Region.
#'
#' @usage
#' kafka_list_clusters(ClusterNameFilter, MaxResults, NextToken)
#'
#' @param ClusterNameFilter Specify a prefix of the name of the clusters that you want to list. The
#' service lists all the clusters whose names start with this prefix.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfoList = list(
#'     list(
#'       ActiveOperationArn = "string",
#'       BrokerNodeGroupInfo = list(
#'         BrokerAZDistribution = "DEFAULT",
#'         ClientSubnets = list(
#'           "string"
#'         ),
#'         InstanceType = "string",
#'         SecurityGroups = list(
#'           "string"
#'         ),
#'         StorageInfo = list(
#'           EbsStorageInfo = list(
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSize = 123
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           ),
#'           VpcConnectivity = list(
#'             ClientAuthentication = list(
#'               Sasl = list(
#'                 Scram = list(
#'                   Enabled = TRUE|FALSE
#'                 ),
#'                 Iam = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               ),
#'               Tls = list(
#'                 Enabled = TRUE|FALSE
#'               )
#'             )
#'           )
#'         ),
#'         ZoneIds = list(
#'           "string"
#'         )
#'       ),
#'       Rebalancing = list(
#'         Status = "PAUSED"|"ACTIVE"
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       ClusterArn = "string",
#'       ClusterName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CurrentBrokerSoftwareInfo = list(
#'         ConfigurationArn = "string",
#'         ConfigurationRevision = 123,
#'         KafkaVersion = "string"
#'       ),
#'       CurrentVersion = "string",
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'       StateInfo = list(
#'         Code = "string",
#'         Message = "string"
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       ZookeeperConnectString = "string",
#'       ZookeeperConnectStringTls = "string",
#'       StorageMode = "LOCAL"|"TIERED",
#'       CustomerActionStatus = "CRITICAL_ACTION_REQUIRED"|"ACTION_RECOMMENDED"|"NONE"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters(
#'   ClusterNameFilter = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_clusters
#'
#' @aliases kafka_list_clusters
kafka_list_clusters <- function(ClusterNameFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClusters",
    http_method = "GET",
    http_path = "/v1/clusters",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "ClusterInfoList"),
    stream_api = FALSE
  )
  input <- .kafka$list_clusters_input(ClusterNameFilter = ClusterNameFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_clusters_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_clusters <- kafka_list_clusters

#' Returns a list of all the MSK clusters in the current Region
#'
#' @description
#' Returns a list of all the MSK clusters in the current Region.
#'
#' @usage
#' kafka_list_clusters_v2(ClusterNameFilter, ClusterTypeFilter, MaxResults,
#'   NextToken)
#'
#' @param ClusterNameFilter Specify a prefix of the names of the clusters that you want to list. The
#' service lists all the clusters whose names start with this prefix.
#' @param ClusterTypeFilter Specify either PROVISIONED or SERVERLESS.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfoList = list(
#'     list(
#'       ActiveOperationArn = "string",
#'       ClusterType = "PROVISIONED"|"SERVERLESS",
#'       ClusterArn = "string",
#'       ClusterName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CurrentVersion = "string",
#'       State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'       StateInfo = list(
#'         Code = "string",
#'         Message = "string"
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       Provisioned = list(
#'         BrokerNodeGroupInfo = list(
#'           BrokerAZDistribution = "DEFAULT",
#'           ClientSubnets = list(
#'             "string"
#'           ),
#'           InstanceType = "string",
#'           SecurityGroups = list(
#'             "string"
#'           ),
#'           StorageInfo = list(
#'             EbsStorageInfo = list(
#'               ProvisionedThroughput = list(
#'                 Enabled = TRUE|FALSE,
#'                 VolumeThroughput = 123
#'               ),
#'               VolumeSize = 123
#'             )
#'           ),
#'           ConnectivityInfo = list(
#'             PublicAccess = list(
#'               Type = "string"
#'             ),
#'             VpcConnectivity = list(
#'               ClientAuthentication = list(
#'                 Sasl = list(
#'                   Scram = list(
#'                     Enabled = TRUE|FALSE
#'                   ),
#'                   Iam = list(
#'                     Enabled = TRUE|FALSE
#'                   )
#'                 ),
#'                 Tls = list(
#'                   Enabled = TRUE|FALSE
#'                 )
#'               )
#'             )
#'           ),
#'           ZoneIds = list(
#'             "string"
#'           )
#'         ),
#'         Rebalancing = list(
#'           Status = "PAUSED"|"ACTIVE"
#'         ),
#'         CurrentBrokerSoftwareInfo = list(
#'           ConfigurationArn = "string",
#'           ConfigurationRevision = 123,
#'           KafkaVersion = "string"
#'         ),
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         ZookeeperConnectString = "string",
#'         ZookeeperConnectStringTls = "string",
#'         StorageMode = "LOCAL"|"TIERED",
#'         CustomerActionStatus = "CRITICAL_ACTION_REQUIRED"|"ACTION_RECOMMENDED"|"NONE"
#'       ),
#'       Serverless = list(
#'         VpcConfigs = list(
#'           list(
#'             SubnetIds = list(
#'               "string"
#'             ),
#'             SecurityGroupIds = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters_v2(
#'   ClusterNameFilter = "string",
#'   ClusterTypeFilter = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_clusters_v2
#'
#' @aliases kafka_list_clusters_v2
kafka_list_clusters_v2 <- function(ClusterNameFilter = NULL, ClusterTypeFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClustersV2",
    http_method = "GET",
    http_path = "/api/v2/clusters",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ClusterInfoList"),
    stream_api = FALSE
  )
  input <- .kafka$list_clusters_v2_input(ClusterNameFilter = ClusterNameFilter, ClusterTypeFilter = ClusterTypeFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_clusters_v2_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_clusters_v2 <- kafka_list_clusters_v2

#' Returns a list of all the MSK configurations in this Region
#'
#' @description
#' Returns a list of all the MSK configurations in this Region.
#'
#' @usage
#' kafka_list_configuration_revisions(Arn, MaxResults, NextToken)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Revisions = list(
#'     list(
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       Revision = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_configuration_revisions(
#'   Arn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_configuration_revisions
#'
#' @aliases kafka_list_configuration_revisions
kafka_list_configuration_revisions <- function(Arn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListConfigurationRevisions",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}/revisions",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Revisions"),
    stream_api = FALSE
  )
  input <- .kafka$list_configuration_revisions_input(Arn = Arn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_configuration_revisions_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_configuration_revisions <- kafka_list_configuration_revisions

#' Returns a list of all the MSK configurations in this Region
#'
#' @description
#' Returns a list of all the MSK configurations in this Region.
#'
#' @usage
#' kafka_list_configurations(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Configurations = list(
#'     list(
#'       Arn = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       KafkaVersions = list(
#'         "string"
#'       ),
#'       LatestRevision = list(
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Description = "string",
#'         Revision = 123
#'       ),
#'       Name = "string",
#'       State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_configurations(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_configurations
#'
#' @aliases kafka_list_configurations
kafka_list_configurations <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListConfigurations",
    http_method = "GET",
    http_path = "/v1/configurations",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Configurations"),
    stream_api = FALSE
  )
  input <- .kafka$list_configurations_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_configurations_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_configurations <- kafka_list_configurations

#' Returns a list of Apache Kafka versions
#'
#' @description
#' Returns a list of Apache Kafka versions.
#'
#' @usage
#' kafka_list_kafka_versions(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   KafkaVersions = list(
#'     list(
#'       Version = "string",
#'       Status = "ACTIVE"|"DEPRECATED"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_kafka_versions(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_kafka_versions
#'
#' @aliases kafka_list_kafka_versions
kafka_list_kafka_versions <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListKafkaVersions",
    http_method = "GET",
    http_path = "/v1/kafka-versions",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "KafkaVersions"),
    stream_api = FALSE
  )
  input <- .kafka$list_kafka_versions_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_kafka_versions_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_kafka_versions <- kafka_list_kafka_versions

#' Returns a list of the broker nodes in the cluster
#'
#' @description
#' Returns a list of the broker nodes in the cluster.
#'
#' @usage
#' kafka_list_nodes(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NodeInfoList = list(
#'     list(
#'       AddedToClusterTime = "string",
#'       BrokerNodeInfo = list(
#'         AttachedENIId = "string",
#'         BrokerId = 123.0,
#'         ClientSubnet = "string",
#'         ClientVpcIpAddress = "string",
#'         CurrentBrokerSoftwareInfo = list(
#'           ConfigurationArn = "string",
#'           ConfigurationRevision = 123,
#'           KafkaVersion = "string"
#'         ),
#'         Endpoints = list(
#'           "string"
#'         )
#'       ),
#'       ControllerNodeInfo = list(
#'         Endpoints = list(
#'           "string"
#'         )
#'       ),
#'       InstanceType = "string",
#'       NodeARN = "string",
#'       NodeType = "BROKER",
#'       ZookeeperNodeInfo = list(
#'         AttachedENIId = "string",
#'         ClientVpcIpAddress = "string",
#'         Endpoints = list(
#'           "string"
#'         ),
#'         ZookeeperId = 123.0,
#'         ZookeeperVersion = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_nodes(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_nodes
#'
#' @aliases kafka_list_nodes
kafka_list_nodes <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListNodes",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/nodes",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken", result_key = "NodeInfoList"),
    stream_api = FALSE
  )
  input <- .kafka$list_nodes_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_nodes_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_nodes <- kafka_list_nodes

#' Lists the replicators
#'
#' @description
#' Lists the replicators.
#'
#' @usage
#' kafka_list_replicators(MaxResults, NextToken, ReplicatorNameFilter)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken If the response of ListReplicators is truncated, it returns a NextToken
#' in the response. This NextToken should be sent in the subsequent request
#' to ListReplicators.
#' @param ReplicatorNameFilter Returns replicators starting with given name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Replicators = list(
#'     list(
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CurrentVersion = "string",
#'       IsReplicatorReference = TRUE|FALSE,
#'       KafkaClustersSummary = list(
#'         list(
#'           AmazonMskCluster = list(
#'             MskClusterArn = "string"
#'           ),
#'           KafkaClusterAlias = "string"
#'         )
#'       ),
#'       ReplicationInfoSummaryList = list(
#'         list(
#'           SourceKafkaClusterAlias = "string",
#'           TargetKafkaClusterAlias = "string"
#'         )
#'       ),
#'       ReplicatorArn = "string",
#'       ReplicatorName = "string",
#'       ReplicatorResourceArn = "string",
#'       ReplicatorState = "RUNNING"|"CREATING"|"UPDATING"|"DELETING"|"FAILED"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_replicators(
#'   MaxResults = 123,
#'   NextToken = "string",
#'   ReplicatorNameFilter = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_replicators
#'
#' @aliases kafka_list_replicators
kafka_list_replicators <- function(MaxResults = NULL, NextToken = NULL, ReplicatorNameFilter = NULL) {
  op <- new_operation(
    name = "ListReplicators",
    http_method = "GET",
    http_path = "/replication/v1/replicators",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Replicators"),
    stream_api = FALSE
  )
  input <- .kafka$list_replicators_input(MaxResults = MaxResults, NextToken = NextToken, ReplicatorNameFilter = ReplicatorNameFilter)
  output <- .kafka$list_replicators_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_replicators <- kafka_list_replicators

#' Returns a list of the Scram Secrets associated with an Amazon MSK
#' cluster
#'
#' @description
#' Returns a list of the Scram Secrets associated with an Amazon MSK
#' cluster.
#'
#' @usage
#' kafka_list_scram_secrets(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The arn of the cluster.
#' @param MaxResults The maxResults of the query.
#' @param NextToken The nextToken of the query.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_scram_secrets(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_scram_secrets
#'
#' @aliases kafka_list_scram_secrets
kafka_list_scram_secrets <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListScramSecrets",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "SecretArnList"),
    stream_api = FALSE
  )
  input <- .kafka$list_scram_secrets_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_scram_secrets_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_scram_secrets <- kafka_list_scram_secrets

#' Returns a list of the tags associated with the specified resource
#'
#' @description
#' Returns a list of the tags associated with the specified resource.
#'
#' @usage
#' kafka_list_tags_for_resource(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_tags_for_resource
#'
#' @aliases kafka_list_tags_for_resource
kafka_list_tags_for_resource <- function(ResourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$list_tags_for_resource_input(ResourceArn = ResourceArn)
  output <- .kafka$list_tags_for_resource_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_tags_for_resource <- kafka_list_tags_for_resource

#' Returns a list of all the VPC connections in this Region
#'
#' @description
#' Returns a list of all the VPC connections in this Region.
#'
#' @usage
#' kafka_list_client_vpc_connections(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClientVpcConnections = list(
#'     list(
#'       Authentication = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       State = "CREATING"|"AVAILABLE"|"INACTIVE"|"DEACTIVATING"|"DELETING"|"FAILED"|"REJECTED"|"REJECTING",
#'       VpcConnectionArn = "string",
#'       Owner = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_client_vpc_connections(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_client_vpc_connections
#'
#' @aliases kafka_list_client_vpc_connections
kafka_list_client_vpc_connections <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClientVpcConnections",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/client-vpc-connections",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ClientVpcConnections"),
    stream_api = FALSE
  )
  input <- .kafka$list_client_vpc_connections_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_client_vpc_connections_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_client_vpc_connections <- kafka_list_client_vpc_connections

#' List topics in a MSK cluster
#'
#' @description
#' List topics in a MSK cluster.
#'
#' @usage
#' kafka_list_topics(ClusterArn, MaxResults, NextToken, TopicNameFilter)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#' @param TopicNameFilter Returns topics starting with given name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Topics = list(
#'     list(
#'       TopicArn = "string",
#'       TopicName = "string",
#'       ReplicationFactor = 123,
#'       PartitionCount = 123,
#'       OutOfSyncReplicaCount = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_topics(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string",
#'   TopicNameFilter = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_topics
#'
#' @aliases kafka_list_topics
kafka_list_topics <- function(ClusterArn, MaxResults = NULL, NextToken = NULL, TopicNameFilter = NULL) {
  op <- new_operation(
    name = "ListTopics",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/topics",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Topics"),
    stream_api = FALSE
  )
  input <- .kafka$list_topics_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken, TopicNameFilter = TopicNameFilter)
  output <- .kafka$list_topics_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_topics <- kafka_list_topics

#' Returns a list of all the VPC connections in this Region
#'
#' @description
#' Returns a list of all the VPC connections in this Region.
#'
#' @usage
#' kafka_list_vpc_connections(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcConnections = list(
#'     list(
#'       VpcConnectionArn = "string",
#'       TargetClusterArn = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Authentication = "string",
#'       VpcId = "string",
#'       State = "CREATING"|"AVAILABLE"|"INACTIVE"|"DEACTIVATING"|"DELETING"|"FAILED"|"REJECTED"|"REJECTING"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_vpc_connections(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_vpc_connections
#'
#' @aliases kafka_list_vpc_connections
kafka_list_vpc_connections <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListVpcConnections",
    http_method = "GET",
    http_path = "/v1/vpc-connections",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "VpcConnections"),
    stream_api = FALSE
  )
  input <- .kafka$list_vpc_connections_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_vpc_connections_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_vpc_connections <- kafka_list_vpc_connections

#' Returns empty response
#'
#' @description
#' Returns empty response.
#'
#' @usage
#' kafka_reject_client_vpc_connection(ClusterArn, VpcConnectionArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#' @param VpcConnectionArn &#91;required&#93; The VPC connection ARN.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$reject_client_vpc_connection(
#'   ClusterArn = "string",
#'   VpcConnectionArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_reject_client_vpc_connection
#'
#' @aliases kafka_reject_client_vpc_connection
kafka_reject_client_vpc_connection <- function(ClusterArn, VpcConnectionArn) {
  op <- new_operation(
    name = "RejectClientVpcConnection",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/client-vpc-connection",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$reject_client_vpc_connection_input(ClusterArn = ClusterArn, VpcConnectionArn = VpcConnectionArn)
  output <- .kafka$reject_client_vpc_connection_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$reject_client_vpc_connection <- kafka_reject_client_vpc_connection

#' Creates or updates the MSK cluster policy specified by the cluster
#' Amazon Resource Name (ARN) in the request
#'
#' @description
#' Creates or updates the MSK cluster policy specified by the cluster
#' Amazon Resource Name (ARN) in the request.
#'
#' @usage
#' kafka_put_cluster_policy(ClusterArn, CurrentVersion, Policy)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#' @param CurrentVersion The policy version.
#' @param Policy &#91;required&#93; The policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_cluster_policy(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   Policy = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_put_cluster_policy
#'
#' @aliases kafka_put_cluster_policy
kafka_put_cluster_policy <- function(ClusterArn, CurrentVersion = NULL, Policy) {
  op <- new_operation(
    name = "PutClusterPolicy",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$put_cluster_policy_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, Policy = Policy)
  output <- .kafka$put_cluster_policy_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$put_cluster_policy <- kafka_put_cluster_policy

#' Reboots brokers
#'
#' @description
#' Reboots brokers.
#'
#' @usage
#' kafka_reboot_broker(BrokerIds, ClusterArn)
#'
#' @param BrokerIds &#91;required&#93; The list of broker IDs to be rebooted. The reboot-broker operation
#' supports rebooting one broker at a time.
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reboot_broker(
#'   BrokerIds = list(
#'     "string"
#'   ),
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_reboot_broker
#'
#' @aliases kafka_reboot_broker
kafka_reboot_broker <- function(BrokerIds, ClusterArn) {
  op <- new_operation(
    name = "RebootBroker",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/reboot-broker",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$reboot_broker_input(BrokerIds = BrokerIds, ClusterArn = ClusterArn)
  output <- .kafka$reboot_broker_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$reboot_broker <- kafka_reboot_broker

#' Adds tags to the specified MSK resource
#'
#' @description
#' Adds tags to the specified MSK resource.
#'
#' @usage
#' kafka_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#' @param Tags &#91;required&#93; The key-value pair for the resource tag.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_tag_resource
#'
#' @aliases kafka_tag_resource
kafka_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .kafka$tag_resource_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$tag_resource <- kafka_tag_resource

#' Removes the tags associated with the keys that are provided in the query
#'
#' @description
#' Removes the tags associated with the keys that are provided in the
#' query.
#'
#' @usage
#' kafka_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#' @param TagKeys &#91;required&#93; Tag keys must be unique for a given cluster. In addition, the following
#' restrictions apply:
#' 
#' -   Each tag key must be unique. If you add a tag with a key that's
#'     already in use, your new tag overwrites the existing key-value pair.
#' 
#' -   You can't start a tag key with aws: because this prefix is reserved
#'     for use by AWS. AWS creates tags that begin with this prefix on your
#'     behalf, but you can't edit or delete them.
#' 
#' -   Tag keys must be between 1 and 128 Unicode characters in length.
#' 
#' -   Tag keys must consist of the following characters: Unicode letters,
#'     digits, white space, and the following special characters: _ . /
#'     = + - @@.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_untag_resource
#'
#' @aliases kafka_untag_resource
kafka_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .kafka$untag_resource_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$untag_resource <- kafka_untag_resource

#' Updates the number of broker nodes in the cluster
#'
#' @description
#' Updates the number of broker nodes in the cluster.
#'
#' @usage
#' kafka_update_broker_count(ClusterArn, CurrentVersion,
#'   TargetNumberOfBrokerNodes)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of cluster to update from. A successful operation will then
#' generate a new version.
#' @param TargetNumberOfBrokerNodes &#91;required&#93; The number of broker nodes that you want the cluster to have after this
#' operation completes successfully.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_count(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetNumberOfBrokerNodes = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_count
#'
#' @aliases kafka_update_broker_count
kafka_update_broker_count <- function(ClusterArn, CurrentVersion, TargetNumberOfBrokerNodes) {
  op <- new_operation(
    name = "UpdateBrokerCount",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/count",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_broker_count_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetNumberOfBrokerNodes = TargetNumberOfBrokerNodes)
  output <- .kafka$update_broker_count_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_count <- kafka_update_broker_count

#' Updates EC2 instance type
#'
#' @description
#' Updates EC2 instance type.
#'
#' @usage
#' kafka_update_broker_type(ClusterArn, CurrentVersion, TargetInstanceType)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The cluster version that you want to change. After this operation
#' completes successfully, the cluster will have a new version.
#' @param TargetInstanceType &#91;required&#93; The Amazon MSK broker type that you want all of the brokers in this
#' cluster to be.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_type(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetInstanceType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_type
#'
#' @aliases kafka_update_broker_type
kafka_update_broker_type <- function(ClusterArn, CurrentVersion, TargetInstanceType) {
  op <- new_operation(
    name = "UpdateBrokerType",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/type",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_broker_type_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetInstanceType = TargetInstanceType)
  output <- .kafka$update_broker_type_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_type <- kafka_update_broker_type

#' Updates the EBS storage associated with MSK brokers
#'
#' @description
#' Updates the EBS storage associated with MSK brokers.
#'
#' @usage
#' kafka_update_broker_storage(ClusterArn, CurrentVersion,
#'   TargetBrokerEBSVolumeInfo)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of cluster to update from. A successful operation will then
#' generate a new version.
#' @param TargetBrokerEBSVolumeInfo &#91;required&#93; Describes the target volume size and the ID of the broker to apply the
#' update to.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_storage(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetBrokerEBSVolumeInfo = list(
#'     list(
#'       KafkaBrokerNodeId = "string",
#'       ProvisionedThroughput = list(
#'         Enabled = TRUE|FALSE,
#'         VolumeThroughput = 123
#'       ),
#'       VolumeSizeGB = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_storage
#'
#' @aliases kafka_update_broker_storage
kafka_update_broker_storage <- function(ClusterArn, CurrentVersion, TargetBrokerEBSVolumeInfo) {
  op <- new_operation(
    name = "UpdateBrokerStorage",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/storage",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_broker_storage_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetBrokerEBSVolumeInfo = TargetBrokerEBSVolumeInfo)
  output <- .kafka$update_broker_storage_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_storage <- kafka_update_broker_storage

#' Updates an MSK configuration
#'
#' @description
#' Updates an MSK configuration.
#'
#' @usage
#' kafka_update_configuration(Arn, Description, ServerProperties)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) of the configuration.
#' @param Description The description of the configuration revision.
#' @param ServerProperties &#91;required&#93; Contents of the server.properties file. When using the API, you must
#' ensure that the contents of the file are base64 encoded. When using the
#' AWS Management Console, the SDK, or the AWS CLI, the contents of
#' server.properties can be in plaintext.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_configuration(
#'   Arn = "string",
#'   Description = "string",
#'   ServerProperties = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_configuration
#'
#' @aliases kafka_update_configuration
kafka_update_configuration <- function(Arn, Description = NULL, ServerProperties) {
  op <- new_operation(
    name = "UpdateConfiguration",
    http_method = "PUT",
    http_path = "/v1/configurations/{arn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_configuration_input(Arn = Arn, Description = Description, ServerProperties = ServerProperties)
  output <- .kafka$update_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_configuration <- kafka_update_configuration

#' Updates the cluster's connectivity configuration
#'
#' @description
#' Updates the cluster's connectivity configuration.
#'
#' @usage
#' kafka_update_connectivity(ClusterArn, ConnectivityInfo, CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the configuration.
#' @param ConnectivityInfo &#91;required&#93; Information about the broker access configuration.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_connectivity(
#'   ClusterArn = "string",
#'   ConnectivityInfo = list(
#'     PublicAccess = list(
#'       Type = "string"
#'     ),
#'     VpcConnectivity = list(
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_connectivity
#'
#' @aliases kafka_update_connectivity
kafka_update_connectivity <- function(ClusterArn, ConnectivityInfo, CurrentVersion) {
  op <- new_operation(
    name = "UpdateConnectivity",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/connectivity",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_connectivity_input(ClusterArn = ClusterArn, ConnectivityInfo = ConnectivityInfo, CurrentVersion = CurrentVersion)
  output <- .kafka$update_connectivity_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_connectivity <- kafka_update_connectivity

#' Updates the cluster with the configuration that is specified in the
#' request body
#'
#' @description
#' Updates the cluster with the configuration that is specified in the
#' request body.
#'
#' @usage
#' kafka_update_cluster_configuration(ClusterArn, ConfigurationInfo,
#'   CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param ConfigurationInfo &#91;required&#93; Represents the configuration that you want MSK to use for the brokers in
#' a cluster.
#' @param CurrentVersion &#91;required&#93; The version of the cluster that needs to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_configuration(
#'   ClusterArn = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_cluster_configuration
#'
#' @aliases kafka_update_cluster_configuration
kafka_update_cluster_configuration <- function(ClusterArn, ConfigurationInfo, CurrentVersion) {
  op <- new_operation(
    name = "UpdateClusterConfiguration",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_cluster_configuration_input(ClusterArn = ClusterArn, ConfigurationInfo = ConfigurationInfo, CurrentVersion = CurrentVersion)
  output <- .kafka$update_cluster_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_cluster_configuration <- kafka_update_cluster_configuration

#' Updates the Apache Kafka version for the cluster
#'
#' @description
#' Updates the Apache Kafka version for the cluster.
#'
#' @usage
#' kafka_update_cluster_kafka_version(ClusterArn, ConfigurationInfo,
#'   CurrentVersion, TargetKafkaVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param ConfigurationInfo The custom configuration that should be applied on the new version of
#' cluster.
#' @param CurrentVersion &#91;required&#93; Current cluster version.
#' @param TargetKafkaVersion &#91;required&#93; Target Kafka version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_kafka_version(
#'   ClusterArn = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   CurrentVersion = "string",
#'   TargetKafkaVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_cluster_kafka_version
#'
#' @aliases kafka_update_cluster_kafka_version
kafka_update_cluster_kafka_version <- function(ClusterArn, ConfigurationInfo = NULL, CurrentVersion, TargetKafkaVersion) {
  op <- new_operation(
    name = "UpdateClusterKafkaVersion",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/version",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_cluster_kafka_version_input(ClusterArn = ClusterArn, ConfigurationInfo = ConfigurationInfo, CurrentVersion = CurrentVersion, TargetKafkaVersion = TargetKafkaVersion)
  output <- .kafka$update_cluster_kafka_version_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_cluster_kafka_version <- kafka_update_cluster_kafka_version

#' Updates the monitoring settings for the cluster
#'
#' @description
#' Updates the monitoring settings for the cluster. You can use this
#' operation to specify which Apache Kafka metrics you want Amazon MSK to
#' send to Amazon CloudWatch. You can also specify settings for open
#' monitoring with Prometheus.
#'
#' @usage
#' kafka_update_monitoring(ClusterArn, CurrentVersion, EnhancedMonitoring,
#'   OpenMonitoring, LoggingInfo)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#' @param EnhancedMonitoring Specifies which Apache Kafka metrics Amazon MSK gathers and sends to
#' Amazon CloudWatch for this cluster.
#' @param OpenMonitoring The settings for open monitoring.
#' @param LoggingInfo 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_monitoring(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'   OpenMonitoring = list(
#'     Prometheus = list(
#'       JmxExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       ),
#'       NodeExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   LoggingInfo = list(
#'     BrokerLogs = list(
#'       CloudWatchLogs = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string"
#'       ),
#'       Firehose = list(
#'         DeliveryStream = "string",
#'         Enabled = TRUE|FALSE
#'       ),
#'       S3 = list(
#'         Bucket = "string",
#'         Enabled = TRUE|FALSE,
#'         Prefix = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_monitoring
#'
#' @aliases kafka_update_monitoring
kafka_update_monitoring <- function(ClusterArn, CurrentVersion, EnhancedMonitoring = NULL, OpenMonitoring = NULL, LoggingInfo = NULL) {
  op <- new_operation(
    name = "UpdateMonitoring",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/monitoring",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_monitoring_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, EnhancedMonitoring = EnhancedMonitoring, OpenMonitoring = OpenMonitoring, LoggingInfo = LoggingInfo)
  output <- .kafka$update_monitoring_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_monitoring <- kafka_update_monitoring

#' Use this resource to update the intelligent rebalancing status of an
#' Amazon MSK Provisioned cluster with Express brokers
#'
#' @description
#' Use this resource to update the intelligent rebalancing status of an
#' Amazon MSK Provisioned cluster with Express brokers.
#'
#' @usage
#' kafka_update_rebalancing(ClusterArn, CurrentVersion, Rebalancing)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster.
#' @param CurrentVersion &#91;required&#93; The current version of the cluster.
#' @param Rebalancing &#91;required&#93; Specifies if intelligent rebalancing should be turned on for your
#' cluster. The default intelligent rebalancing status is ACTIVE for all
#' new MSK Provisioned clusters that you create with Express brokers.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_rebalancing(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   Rebalancing = list(
#'     Status = "PAUSED"|"ACTIVE"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_rebalancing
#'
#' @aliases kafka_update_rebalancing
kafka_update_rebalancing <- function(ClusterArn, CurrentVersion, Rebalancing) {
  op <- new_operation(
    name = "UpdateRebalancing",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/rebalancing",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_rebalancing_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, Rebalancing = Rebalancing)
  output <- .kafka$update_rebalancing_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_rebalancing <- kafka_update_rebalancing

#' Updates replication info of a replicator
#'
#' @description
#' Updates replication info of a replicator.
#'
#' @usage
#' kafka_update_replication_info(ConsumerGroupReplication, CurrentVersion,
#'   ReplicatorArn, SourceKafkaClusterArn, TargetKafkaClusterArn,
#'   TopicReplication)
#'
#' @param ConsumerGroupReplication Updated consumer group replication information.
#' @param CurrentVersion &#91;required&#93; Current replicator version.
#' @param ReplicatorArn &#91;required&#93; The Amazon Resource Name (ARN) of the replicator to be updated.
#' @param SourceKafkaClusterArn &#91;required&#93; The ARN of the source Kafka cluster.
#' @param TargetKafkaClusterArn &#91;required&#93; The ARN of the target Kafka cluster.
#' @param TopicReplication Updated topic replication information.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ReplicatorArn = "string",
#'   ReplicatorState = "RUNNING"|"CREATING"|"UPDATING"|"DELETING"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_info(
#'   ConsumerGroupReplication = list(
#'     ConsumerGroupsToExclude = list(
#'       "string"
#'     ),
#'     ConsumerGroupsToReplicate = list(
#'       "string"
#'     ),
#'     DetectAndCopyNewConsumerGroups = TRUE|FALSE,
#'     SynchroniseConsumerGroupOffsets = TRUE|FALSE
#'   ),
#'   CurrentVersion = "string",
#'   ReplicatorArn = "string",
#'   SourceKafkaClusterArn = "string",
#'   TargetKafkaClusterArn = "string",
#'   TopicReplication = list(
#'     CopyAccessControlListsForTopics = TRUE|FALSE,
#'     CopyTopicConfigurations = TRUE|FALSE,
#'     DetectAndCopyNewTopics = TRUE|FALSE,
#'     TopicsToExclude = list(
#'       "string"
#'     ),
#'     TopicsToReplicate = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_replication_info
#'
#' @aliases kafka_update_replication_info
kafka_update_replication_info <- function(ConsumerGroupReplication = NULL, CurrentVersion, ReplicatorArn, SourceKafkaClusterArn, TargetKafkaClusterArn, TopicReplication = NULL) {
  op <- new_operation(
    name = "UpdateReplicationInfo",
    http_method = "PUT",
    http_path = "/replication/v1/replicators/{replicatorArn}/replication-info",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_replication_info_input(ConsumerGroupReplication = ConsumerGroupReplication, CurrentVersion = CurrentVersion, ReplicatorArn = ReplicatorArn, SourceKafkaClusterArn = SourceKafkaClusterArn, TargetKafkaClusterArn = TargetKafkaClusterArn, TopicReplication = TopicReplication)
  output <- .kafka$update_replication_info_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_replication_info <- kafka_update_replication_info

#' Updates the security settings for the cluster
#'
#' @description
#' Updates the security settings for the cluster. You can use this
#' operation to specify encryption and authentication on existing clusters.
#'
#' @usage
#' kafka_update_security(ClientAuthentication, ClusterArn, CurrentVersion,
#'   EncryptionInfo)
#'
#' @param ClientAuthentication Includes all client authentication related information.
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#' @param EncryptionInfo Includes all encryption-related information.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_security(
#'   ClientAuthentication = list(
#'     Sasl = list(
#'       Scram = list(
#'         Enabled = TRUE|FALSE
#'       ),
#'       Iam = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     Tls = list(
#'       CertificateAuthorityArnList = list(
#'         "string"
#'       ),
#'       Enabled = TRUE|FALSE
#'     ),
#'     Unauthenticated = list(
#'       Enabled = TRUE|FALSE
#'     )
#'   ),
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   EncryptionInfo = list(
#'     EncryptionAtRest = list(
#'       DataVolumeKMSKeyId = "string"
#'     ),
#'     EncryptionInTransit = list(
#'       ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'       InCluster = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_security
#'
#' @aliases kafka_update_security
kafka_update_security <- function(ClientAuthentication = NULL, ClusterArn, CurrentVersion, EncryptionInfo = NULL) {
  op <- new_operation(
    name = "UpdateSecurity",
    http_method = "PATCH",
    http_path = "/v1/clusters/{clusterArn}/security",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_security_input(ClientAuthentication = ClientAuthentication, ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, EncryptionInfo = EncryptionInfo)
  output <- .kafka$update_security_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_security <- kafka_update_security

#' Updates cluster broker volume size (or) sets cluster storage mode to
#' TIERED
#'
#' @description
#' Updates cluster broker volume size (or) sets cluster storage mode to
#' TIERED.
#'
#' @usage
#' kafka_update_storage(ClusterArn, CurrentVersion, ProvisionedThroughput,
#'   StorageMode, VolumeSizeGB)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param CurrentVersion &#91;required&#93; The version of cluster to update from. A successful operation will then
#' generate a new version.
#' @param ProvisionedThroughput EBS volume provisioned throughput information.
#' @param StorageMode Controls storage mode for supported storage tiers.
#' @param VolumeSizeGB size of the EBS volume to update.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_storage(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   ProvisionedThroughput = list(
#'     Enabled = TRUE|FALSE,
#'     VolumeThroughput = 123
#'   ),
#'   StorageMode = "LOCAL"|"TIERED",
#'   VolumeSizeGB = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_storage
#'
#' @aliases kafka_update_storage
kafka_update_storage <- function(ClusterArn, CurrentVersion, ProvisionedThroughput = NULL, StorageMode = NULL, VolumeSizeGB = NULL) {
  op <- new_operation(
    name = "UpdateStorage",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/storage",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .kafka$update_storage_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, ProvisionedThroughput = ProvisionedThroughput, StorageMode = StorageMode, VolumeSizeGB = VolumeSizeGB)
  output <- .kafka$update_storage_output()
  config <- get_config()
  svc <- .kafka$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_storage <- kafka_update_storage

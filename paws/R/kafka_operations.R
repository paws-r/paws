# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include kafka_service.R
NULL

#' Associates one or more Scram Secrets with an Amazon MSK cluster
#'
#' @description
#' Associates one or more Scram Secrets with an Amazon MSK cluster.
#'
#' @usage
#' kafka_batch_associate_scram_secret(ClusterArn, SecretArnList)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param SecretArnList &#91;required&#93; List of AWS Secrets Manager secret ARNs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   UnprocessedScramSecrets = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string",
#'       SecretArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_associate_scram_secret(
#'   ClusterArn = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_batch_associate_scram_secret
kafka_batch_associate_scram_secret <- function(ClusterArn, SecretArnList) {
  op <- new_operation(
    name = "BatchAssociateScramSecret",
    http_method = "POST",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    paginator = list()
  )
  input <- .kafka$batch_associate_scram_secret_input(ClusterArn = ClusterArn, SecretArnList = SecretArnList)
  output <- .kafka$batch_associate_scram_secret_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$batch_associate_scram_secret <- kafka_batch_associate_scram_secret

#' Creates a new MSK cluster
#'
#' @description
#' Creates a new MSK cluster.
#'
#' @usage
#' kafka_create_cluster(BrokerNodeGroupInfo, ClientAuthentication,
#'   ClusterName, ConfigurationInfo, EncryptionInfo, EnhancedMonitoring,
#'   OpenMonitoring, KafkaVersion, LoggingInfo, NumberOfBrokerNodes, Tags)
#'
#' @param BrokerNodeGroupInfo &#91;required&#93; Information about the broker nodes in the cluster.
#' @param ClientAuthentication Includes all client authentication related information.
#' @param ClusterName &#91;required&#93; The name of the cluster.
#' @param ConfigurationInfo Represents the configuration that you want MSK to use for the brokers in
#' a cluster.
#' @param EncryptionInfo Includes all encryption-related information.
#' @param EnhancedMonitoring Specifies the level of monitoring for the MSK cluster. The possible
#' values are DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and
#' PER_TOPIC_PER_PARTITION.
#' @param OpenMonitoring The settings for open monitoring.
#' @param KafkaVersion &#91;required&#93; The version of Apache Kafka.
#' @param LoggingInfo 
#' @param NumberOfBrokerNodes &#91;required&#93; The number of broker nodes in the cluster.
#' @param Tags Create tags when creating the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterName = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster(
#'   BrokerNodeGroupInfo = list(
#'     BrokerAZDistribution = "DEFAULT",
#'     ClientSubnets = list(
#'       "string"
#'     ),
#'     InstanceType = "string",
#'     SecurityGroups = list(
#'       "string"
#'     ),
#'     StorageInfo = list(
#'       EbsStorageInfo = list(
#'         ProvisionedThroughput = list(
#'           Enabled = TRUE|FALSE,
#'           VolumeThroughput = 123
#'         ),
#'         VolumeSize = 123
#'       )
#'     ),
#'     ConnectivityInfo = list(
#'       PublicAccess = list(
#'         Type = "string"
#'       )
#'     )
#'   ),
#'   ClientAuthentication = list(
#'     Sasl = list(
#'       Scram = list(
#'         Enabled = TRUE|FALSE
#'       ),
#'       Iam = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     Tls = list(
#'       CertificateAuthorityArnList = list(
#'         "string"
#'       ),
#'       Enabled = TRUE|FALSE
#'     ),
#'     Unauthenticated = list(
#'       Enabled = TRUE|FALSE
#'     )
#'   ),
#'   ClusterName = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   EncryptionInfo = list(
#'     EncryptionAtRest = list(
#'       DataVolumeKMSKeyId = "string"
#'     ),
#'     EncryptionInTransit = list(
#'       ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'       InCluster = TRUE|FALSE
#'     )
#'   ),
#'   EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'   OpenMonitoring = list(
#'     Prometheus = list(
#'       JmxExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       ),
#'       NodeExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   KafkaVersion = "string",
#'   LoggingInfo = list(
#'     BrokerLogs = list(
#'       CloudWatchLogs = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string"
#'       ),
#'       Firehose = list(
#'         DeliveryStream = "string",
#'         Enabled = TRUE|FALSE
#'       ),
#'       S3 = list(
#'         Bucket = "string",
#'         Enabled = TRUE|FALSE,
#'         Prefix = "string"
#'       )
#'     )
#'   ),
#'   NumberOfBrokerNodes = 123,
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_cluster
kafka_create_cluster <- function(BrokerNodeGroupInfo, ClientAuthentication = NULL, ClusterName, ConfigurationInfo = NULL, EncryptionInfo = NULL, EnhancedMonitoring = NULL, OpenMonitoring = NULL, KafkaVersion, LoggingInfo = NULL, NumberOfBrokerNodes, Tags = NULL) {
  op <- new_operation(
    name = "CreateCluster",
    http_method = "POST",
    http_path = "/v1/clusters",
    paginator = list()
  )
  input <- .kafka$create_cluster_input(BrokerNodeGroupInfo = BrokerNodeGroupInfo, ClientAuthentication = ClientAuthentication, ClusterName = ClusterName, ConfigurationInfo = ConfigurationInfo, EncryptionInfo = EncryptionInfo, EnhancedMonitoring = EnhancedMonitoring, OpenMonitoring = OpenMonitoring, KafkaVersion = KafkaVersion, LoggingInfo = LoggingInfo, NumberOfBrokerNodes = NumberOfBrokerNodes, Tags = Tags)
  output <- .kafka$create_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_cluster <- kafka_create_cluster

#' Creates a new MSK cluster
#'
#' @description
#' Creates a new MSK cluster.
#'
#' @usage
#' kafka_create_cluster_v2(ClusterName, Tags, Provisioned, Serverless)
#'
#' @param ClusterName &#91;required&#93; The name of the cluster.
#' @param Tags A map of tags that you want the cluster to have.
#' @param Provisioned Information about the provisioned cluster.
#' @param Serverless Information about the serverless cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterName = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'   ClusterType = "PROVISIONED"|"SERVERLESS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster_v2(
#'   ClusterName = "string",
#'   Tags = list(
#'     "string"
#'   ),
#'   Provisioned = list(
#'     BrokerNodeGroupInfo = list(
#'       BrokerAZDistribution = "DEFAULT",
#'       ClientSubnets = list(
#'         "string"
#'       ),
#'       InstanceType = "string",
#'       SecurityGroups = list(
#'         "string"
#'       ),
#'       StorageInfo = list(
#'         EbsStorageInfo = list(
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSize = 123
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         )
#'       )
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Scram = list(
#'           Enabled = TRUE|FALSE
#'         ),
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       Tls = list(
#'         CertificateAuthorityArnList = list(
#'           "string"
#'         ),
#'         Enabled = TRUE|FALSE
#'       ),
#'       Unauthenticated = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     ConfigurationInfo = list(
#'       Arn = "string",
#'       Revision = 123
#'     ),
#'     EncryptionInfo = list(
#'       EncryptionAtRest = list(
#'         DataVolumeKMSKeyId = "string"
#'       ),
#'       EncryptionInTransit = list(
#'         ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'         InCluster = TRUE|FALSE
#'       )
#'     ),
#'     EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'     OpenMonitoring = list(
#'       Prometheus = list(
#'         JmxExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         ),
#'         NodeExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     KafkaVersion = "string",
#'     LoggingInfo = list(
#'       BrokerLogs = list(
#'         CloudWatchLogs = list(
#'           Enabled = TRUE|FALSE,
#'           LogGroup = "string"
#'         ),
#'         Firehose = list(
#'           DeliveryStream = "string",
#'           Enabled = TRUE|FALSE
#'         ),
#'         S3 = list(
#'           Bucket = "string",
#'           Enabled = TRUE|FALSE,
#'           Prefix = "string"
#'         )
#'       )
#'     ),
#'     NumberOfBrokerNodes = 123
#'   ),
#'   Serverless = list(
#'     VpcConfigs = list(
#'       list(
#'         SubnetIds = list(
#'           "string"
#'         ),
#'         SecurityGroupIds = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_cluster_v2
kafka_create_cluster_v2 <- function(ClusterName, Tags = NULL, Provisioned = NULL, Serverless = NULL) {
  op <- new_operation(
    name = "CreateClusterV2",
    http_method = "POST",
    http_path = "/api/v2/clusters",
    paginator = list()
  )
  input <- .kafka$create_cluster_v2_input(ClusterName = ClusterName, Tags = Tags, Provisioned = Provisioned, Serverless = Serverless)
  output <- .kafka$create_cluster_v2_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_cluster_v2 <- kafka_create_cluster_v2

#' Creates a new MSK configuration
#'
#' @description
#' Creates a new MSK configuration.
#'
#' @usage
#' kafka_create_configuration(Description, KafkaVersions, Name,
#'   ServerProperties)
#'
#' @param Description The description of the configuration.
#' @param KafkaVersions The versions of Apache Kafka with which you can use this MSK
#' configuration.
#' @param Name &#91;required&#93; The name of the configuration.
#' @param ServerProperties &#91;required&#93; Contents of the server.properties file. When using the API, you must
#' ensure that the contents of the file are base64 encoded. When using the
#' AWS Management Console, the SDK, or the AWS CLI, the contents of
#' server.properties can be in plaintext.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   ),
#'   Name = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_configuration(
#'   Description = "string",
#'   KafkaVersions = list(
#'     "string"
#'   ),
#'   Name = "string",
#'   ServerProperties = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_create_configuration
kafka_create_configuration <- function(Description = NULL, KafkaVersions = NULL, Name, ServerProperties) {
  op <- new_operation(
    name = "CreateConfiguration",
    http_method = "POST",
    http_path = "/v1/configurations",
    paginator = list()
  )
  input <- .kafka$create_configuration_input(Description = Description, KafkaVersions = KafkaVersions, Name = Name, ServerProperties = ServerProperties)
  output <- .kafka$create_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$create_configuration <- kafka_create_configuration

#' Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in
#' the request
#'
#' @description
#' Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in
#' the request.
#'
#' @usage
#' kafka_delete_cluster(ClusterArn, CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion The current version of the MSK cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_cluster(
#'   ClusterArn = "string",
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_cluster
kafka_delete_cluster <- function(ClusterArn, CurrentVersion = NULL) {
  op <- new_operation(
    name = "DeleteCluster",
    http_method = "DELETE",
    http_path = "/v1/clusters/{clusterArn}",
    paginator = list()
  )
  input <- .kafka$delete_cluster_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion)
  output <- .kafka$delete_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_cluster <- kafka_delete_cluster

#' Deletes an MSK Configuration
#'
#' @description
#' Deletes an MSK Configuration.
#'
#' @usage
#' kafka_delete_configuration(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_configuration(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_delete_configuration
kafka_delete_configuration <- function(Arn) {
  op <- new_operation(
    name = "DeleteConfiguration",
    http_method = "DELETE",
    http_path = "/v1/configurations/{arn}",
    paginator = list()
  )
  input <- .kafka$delete_configuration_input(Arn = Arn)
  output <- .kafka$delete_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$delete_configuration <- kafka_delete_configuration

#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request
#'
#' @description
#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request.
#'
#' @usage
#' kafka_describe_cluster(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfo = list(
#'     ActiveOperationArn = "string",
#'     BrokerNodeGroupInfo = list(
#'       BrokerAZDistribution = "DEFAULT",
#'       ClientSubnets = list(
#'         "string"
#'       ),
#'       InstanceType = "string",
#'       SecurityGroups = list(
#'         "string"
#'       ),
#'       StorageInfo = list(
#'         EbsStorageInfo = list(
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSize = 123
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         )
#'       )
#'     ),
#'     ClientAuthentication = list(
#'       Sasl = list(
#'         Scram = list(
#'           Enabled = TRUE|FALSE
#'         ),
#'         Iam = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       Tls = list(
#'         CertificateAuthorityArnList = list(
#'           "string"
#'         ),
#'         Enabled = TRUE|FALSE
#'       ),
#'       Unauthenticated = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     ClusterArn = "string",
#'     ClusterName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CurrentBrokerSoftwareInfo = list(
#'       ConfigurationArn = "string",
#'       ConfigurationRevision = 123,
#'       KafkaVersion = "string"
#'     ),
#'     CurrentVersion = "string",
#'     EncryptionInfo = list(
#'       EncryptionAtRest = list(
#'         DataVolumeKMSKeyId = "string"
#'       ),
#'       EncryptionInTransit = list(
#'         ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'         InCluster = TRUE|FALSE
#'       )
#'     ),
#'     EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'     OpenMonitoring = list(
#'       Prometheus = list(
#'         JmxExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         ),
#'         NodeExporter = list(
#'           EnabledInBroker = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     LoggingInfo = list(
#'       BrokerLogs = list(
#'         CloudWatchLogs = list(
#'           Enabled = TRUE|FALSE,
#'           LogGroup = "string"
#'         ),
#'         Firehose = list(
#'           DeliveryStream = "string",
#'           Enabled = TRUE|FALSE
#'         ),
#'         S3 = list(
#'           Bucket = "string",
#'           Enabled = TRUE|FALSE,
#'           Prefix = "string"
#'         )
#'       )
#'     ),
#'     NumberOfBrokerNodes = 123,
#'     State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'     StateInfo = list(
#'       Code = "string",
#'       Message = "string"
#'     ),
#'     Tags = list(
#'       "string"
#'     ),
#'     ZookeeperConnectString = "string",
#'     ZookeeperConnectStringTls = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster
kafka_describe_cluster <- function(ClusterArn) {
  op <- new_operation(
    name = "DescribeCluster",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}",
    paginator = list()
  )
  input <- .kafka$describe_cluster_input(ClusterArn = ClusterArn)
  output <- .kafka$describe_cluster_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster <- kafka_describe_cluster

#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request
#'
#' @description
#' Returns a description of the MSK cluster whose Amazon Resource Name
#' (ARN) is specified in the request.
#'
#' @usage
#' kafka_describe_cluster_v2(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfo = list(
#'     ActiveOperationArn = "string",
#'     ClusterType = "PROVISIONED"|"SERVERLESS",
#'     ClusterArn = "string",
#'     ClusterName = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     CurrentVersion = "string",
#'     State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'     StateInfo = list(
#'       Code = "string",
#'       Message = "string"
#'     ),
#'     Tags = list(
#'       "string"
#'     ),
#'     Provisioned = list(
#'       BrokerNodeGroupInfo = list(
#'         BrokerAZDistribution = "DEFAULT",
#'         ClientSubnets = list(
#'           "string"
#'         ),
#'         InstanceType = "string",
#'         SecurityGroups = list(
#'           "string"
#'         ),
#'         StorageInfo = list(
#'           EbsStorageInfo = list(
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSize = 123
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           )
#'         )
#'       ),
#'       CurrentBrokerSoftwareInfo = list(
#'         ConfigurationArn = "string",
#'         ConfigurationRevision = 123,
#'         KafkaVersion = "string"
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       ZookeeperConnectString = "string",
#'       ZookeeperConnectStringTls = "string"
#'     ),
#'     Serverless = list(
#'       VpcConfigs = list(
#'         list(
#'           SubnetIds = list(
#'             "string"
#'           ),
#'           SecurityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_v2(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster_v2
kafka_describe_cluster_v2 <- function(ClusterArn) {
  op <- new_operation(
    name = "DescribeClusterV2",
    http_method = "GET",
    http_path = "/api/v2/clusters/{clusterArn}",
    paginator = list()
  )
  input <- .kafka$describe_cluster_v2_input(ClusterArn = ClusterArn)
  output <- .kafka$describe_cluster_v2_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster_v2 <- kafka_describe_cluster_v2

#' Returns a description of the cluster operation specified by the ARN
#'
#' @description
#' Returns a description of the cluster operation specified by the ARN.
#'
#' @usage
#' kafka_describe_cluster_operation(ClusterOperationArn)
#'
#' @param ClusterOperationArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster
#' operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfo = list(
#'     ClientRequestId = "string",
#'     ClusterArn = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ErrorInfo = list(
#'       ErrorCode = "string",
#'       ErrorString = "string"
#'     ),
#'     OperationArn = "string",
#'     OperationState = "string",
#'     OperationSteps = list(
#'       list(
#'         StepInfo = list(
#'           StepStatus = "string"
#'         ),
#'         StepName = "string"
#'       )
#'     ),
#'     OperationType = "string",
#'     SourceClusterInfo = list(
#'       BrokerEBSVolumeInfo = list(
#'         list(
#'           KafkaBrokerNodeId = "string",
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSizeGB = 123
#'         )
#'       ),
#'       ConfigurationInfo = list(
#'         Arn = "string",
#'         Revision = 123
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       KafkaVersion = "string",
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       InstanceType = "string",
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         )
#'       )
#'     ),
#'     TargetClusterInfo = list(
#'       BrokerEBSVolumeInfo = list(
#'         list(
#'           KafkaBrokerNodeId = "string",
#'           ProvisionedThroughput = list(
#'             Enabled = TRUE|FALSE,
#'             VolumeThroughput = 123
#'           ),
#'           VolumeSizeGB = 123
#'         )
#'       ),
#'       ConfigurationInfo = list(
#'         Arn = "string",
#'         Revision = 123
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       KafkaVersion = "string",
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       InstanceType = "string",
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       ConnectivityInfo = list(
#'         PublicAccess = list(
#'           Type = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_operation(
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_cluster_operation
kafka_describe_cluster_operation <- function(ClusterOperationArn) {
  op <- new_operation(
    name = "DescribeClusterOperation",
    http_method = "GET",
    http_path = "/v1/operations/{clusterOperationArn}",
    paginator = list()
  )
  input <- .kafka$describe_cluster_operation_input(ClusterOperationArn = ClusterOperationArn)
  output <- .kafka$describe_cluster_operation_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_cluster_operation <- kafka_describe_cluster_operation

#' Returns a description of this MSK configuration
#'
#' @description
#' Returns a description of this MSK configuration.
#'
#' @usage
#' kafka_describe_configuration(Arn)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   KafkaVersions = list(
#'     "string"
#'   ),
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   ),
#'   Name = "string",
#'   State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_configuration(
#'   Arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_configuration
kafka_describe_configuration <- function(Arn) {
  op <- new_operation(
    name = "DescribeConfiguration",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}",
    paginator = list()
  )
  input <- .kafka$describe_configuration_input(Arn = Arn)
  output <- .kafka$describe_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_configuration <- kafka_describe_configuration

#' Returns a description of this revision of the configuration
#'
#' @description
#' Returns a description of this revision of the configuration.
#'
#' @usage
#' kafka_describe_configuration_revision(Arn, Revision)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#' @param Revision &#91;required&#93; A string that uniquely identifies a revision of an MSK configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   CreationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Description = "string",
#'   Revision = 123,
#'   ServerProperties = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_configuration_revision(
#'   Arn = "string",
#'   Revision = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_describe_configuration_revision
kafka_describe_configuration_revision <- function(Arn, Revision) {
  op <- new_operation(
    name = "DescribeConfigurationRevision",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}/revisions/{revision}",
    paginator = list()
  )
  input <- .kafka$describe_configuration_revision_input(Arn = Arn, Revision = Revision)
  output <- .kafka$describe_configuration_revision_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$describe_configuration_revision <- kafka_describe_configuration_revision

#' Disassociates one or more Scram Secrets from an Amazon MSK cluster
#'
#' @description
#' Disassociates one or more Scram Secrets from an Amazon MSK cluster.
#'
#' @usage
#' kafka_batch_disassociate_scram_secret(ClusterArn, SecretArnList)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param SecretArnList &#91;required&#93; List of AWS Secrets Manager secret ARNs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   UnprocessedScramSecrets = list(
#'     list(
#'       ErrorCode = "string",
#'       ErrorMessage = "string",
#'       SecretArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_disassociate_scram_secret(
#'   ClusterArn = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_batch_disassociate_scram_secret
kafka_batch_disassociate_scram_secret <- function(ClusterArn, SecretArnList) {
  op <- new_operation(
    name = "BatchDisassociateScramSecret",
    http_method = "PATCH",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    paginator = list()
  )
  input <- .kafka$batch_disassociate_scram_secret_input(ClusterArn = ClusterArn, SecretArnList = SecretArnList)
  output <- .kafka$batch_disassociate_scram_secret_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$batch_disassociate_scram_secret <- kafka_batch_disassociate_scram_secret

#' A list of brokers that a client application can use to bootstrap
#'
#' @description
#' A list of brokers that a client application can use to bootstrap.
#'
#' @usage
#' kafka_get_bootstrap_brokers(ClusterArn)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BootstrapBrokerString = "string",
#'   BootstrapBrokerStringTls = "string",
#'   BootstrapBrokerStringSaslScram = "string",
#'   BootstrapBrokerStringSaslIam = "string",
#'   BootstrapBrokerStringPublicTls = "string",
#'   BootstrapBrokerStringPublicSaslScram = "string",
#'   BootstrapBrokerStringPublicSaslIam = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_bootstrap_brokers(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_get_bootstrap_brokers
kafka_get_bootstrap_brokers <- function(ClusterArn) {
  op <- new_operation(
    name = "GetBootstrapBrokers",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/bootstrap-brokers",
    paginator = list()
  )
  input <- .kafka$get_bootstrap_brokers_input(ClusterArn = ClusterArn)
  output <- .kafka$get_bootstrap_brokers_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$get_bootstrap_brokers <- kafka_get_bootstrap_brokers

#' Gets the Apache Kafka versions to which you can update the MSK cluster
#'
#' @description
#' Gets the Apache Kafka versions to which you can update the MSK cluster.
#'
#' @usage
#' kafka_get_compatible_kafka_versions(ClusterArn)
#'
#' @param ClusterArn The Amazon Resource Name (ARN) of the cluster check.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CompatibleKafkaVersions = list(
#'     list(
#'       SourceVersion = "string",
#'       TargetVersions = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_compatible_kafka_versions(
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_get_compatible_kafka_versions
kafka_get_compatible_kafka_versions <- function(ClusterArn = NULL) {
  op <- new_operation(
    name = "GetCompatibleKafkaVersions",
    http_method = "GET",
    http_path = "/v1/compatible-kafka-versions",
    paginator = list()
  )
  input <- .kafka$get_compatible_kafka_versions_input(ClusterArn = ClusterArn)
  output <- .kafka$get_compatible_kafka_versions_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$get_compatible_kafka_versions <- kafka_get_compatible_kafka_versions

#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster
#'
#' @description
#' Returns a list of all the operations that have been performed on the
#' specified MSK cluster.
#'
#' @usage
#' kafka_list_cluster_operations(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterOperationInfoList = list(
#'     list(
#'       ClientRequestId = "string",
#'       ClusterArn = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ErrorInfo = list(
#'         ErrorCode = "string",
#'         ErrorString = "string"
#'       ),
#'       OperationArn = "string",
#'       OperationState = "string",
#'       OperationSteps = list(
#'         list(
#'           StepInfo = list(
#'             StepStatus = "string"
#'           ),
#'           StepName = "string"
#'         )
#'       ),
#'       OperationType = "string",
#'       SourceClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           )
#'         )
#'       ),
#'       TargetClusterInfo = list(
#'         BrokerEBSVolumeInfo = list(
#'           list(
#'             KafkaBrokerNodeId = "string",
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSizeGB = 123
#'           )
#'         ),
#'         ConfigurationInfo = list(
#'           Arn = "string",
#'           Revision = 123
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         KafkaVersion = "string",
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         InstanceType = "string",
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_cluster_operations(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_cluster_operations
kafka_list_cluster_operations <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClusterOperations",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/operations",
    paginator = list()
  )
  input <- .kafka$list_cluster_operations_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_cluster_operations_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_cluster_operations <- kafka_list_cluster_operations

#' Returns a list of all the MSK clusters in the current Region
#'
#' @description
#' Returns a list of all the MSK clusters in the current Region.
#'
#' @usage
#' kafka_list_clusters(ClusterNameFilter, MaxResults, NextToken)
#'
#' @param ClusterNameFilter Specify a prefix of the name of the clusters that you want to list. The
#' service lists all the clusters whose names start with this prefix.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfoList = list(
#'     list(
#'       ActiveOperationArn = "string",
#'       BrokerNodeGroupInfo = list(
#'         BrokerAZDistribution = "DEFAULT",
#'         ClientSubnets = list(
#'           "string"
#'         ),
#'         InstanceType = "string",
#'         SecurityGroups = list(
#'           "string"
#'         ),
#'         StorageInfo = list(
#'           EbsStorageInfo = list(
#'             ProvisionedThroughput = list(
#'               Enabled = TRUE|FALSE,
#'               VolumeThroughput = 123
#'             ),
#'             VolumeSize = 123
#'           )
#'         ),
#'         ConnectivityInfo = list(
#'           PublicAccess = list(
#'             Type = "string"
#'           )
#'         )
#'       ),
#'       ClientAuthentication = list(
#'         Sasl = list(
#'           Scram = list(
#'             Enabled = TRUE|FALSE
#'           ),
#'           Iam = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         Tls = list(
#'           CertificateAuthorityArnList = list(
#'             "string"
#'           ),
#'           Enabled = TRUE|FALSE
#'         ),
#'         Unauthenticated = list(
#'           Enabled = TRUE|FALSE
#'         )
#'       ),
#'       ClusterArn = "string",
#'       ClusterName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CurrentBrokerSoftwareInfo = list(
#'         ConfigurationArn = "string",
#'         ConfigurationRevision = 123,
#'         KafkaVersion = "string"
#'       ),
#'       CurrentVersion = "string",
#'       EncryptionInfo = list(
#'         EncryptionAtRest = list(
#'           DataVolumeKMSKeyId = "string"
#'         ),
#'         EncryptionInTransit = list(
#'           ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'           InCluster = TRUE|FALSE
#'         )
#'       ),
#'       EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'       OpenMonitoring = list(
#'         Prometheus = list(
#'           JmxExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           ),
#'           NodeExporter = list(
#'             EnabledInBroker = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       LoggingInfo = list(
#'         BrokerLogs = list(
#'           CloudWatchLogs = list(
#'             Enabled = TRUE|FALSE,
#'             LogGroup = "string"
#'           ),
#'           Firehose = list(
#'             DeliveryStream = "string",
#'             Enabled = TRUE|FALSE
#'           ),
#'           S3 = list(
#'             Bucket = "string",
#'             Enabled = TRUE|FALSE,
#'             Prefix = "string"
#'           )
#'         )
#'       ),
#'       NumberOfBrokerNodes = 123,
#'       State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'       StateInfo = list(
#'         Code = "string",
#'         Message = "string"
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       ZookeeperConnectString = "string",
#'       ZookeeperConnectStringTls = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters(
#'   ClusterNameFilter = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_clusters
kafka_list_clusters <- function(ClusterNameFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClusters",
    http_method = "GET",
    http_path = "/v1/clusters",
    paginator = list()
  )
  input <- .kafka$list_clusters_input(ClusterNameFilter = ClusterNameFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_clusters_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_clusters <- kafka_list_clusters

#' Returns a list of all the MSK clusters in the current Region
#'
#' @description
#' Returns a list of all the MSK clusters in the current Region.
#'
#' @usage
#' kafka_list_clusters_v2(ClusterNameFilter, ClusterTypeFilter, MaxResults,
#'   NextToken)
#'
#' @param ClusterNameFilter Specify a prefix of the names of the clusters that you want to list. The
#' service lists all the clusters whose names start with this prefix.
#' @param ClusterTypeFilter Specify either PROVISIONED or SERVERLESS.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterInfoList = list(
#'     list(
#'       ActiveOperationArn = "string",
#'       ClusterType = "PROVISIONED"|"SERVERLESS",
#'       ClusterArn = "string",
#'       ClusterName = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       CurrentVersion = "string",
#'       State = "ACTIVE"|"CREATING"|"DELETING"|"FAILED"|"HEALING"|"MAINTENANCE"|"REBOOTING_BROKER"|"UPDATING",
#'       StateInfo = list(
#'         Code = "string",
#'         Message = "string"
#'       ),
#'       Tags = list(
#'         "string"
#'       ),
#'       Provisioned = list(
#'         BrokerNodeGroupInfo = list(
#'           BrokerAZDistribution = "DEFAULT",
#'           ClientSubnets = list(
#'             "string"
#'           ),
#'           InstanceType = "string",
#'           SecurityGroups = list(
#'             "string"
#'           ),
#'           StorageInfo = list(
#'             EbsStorageInfo = list(
#'               ProvisionedThroughput = list(
#'                 Enabled = TRUE|FALSE,
#'                 VolumeThroughput = 123
#'               ),
#'               VolumeSize = 123
#'             )
#'           ),
#'           ConnectivityInfo = list(
#'             PublicAccess = list(
#'               Type = "string"
#'             )
#'           )
#'         ),
#'         CurrentBrokerSoftwareInfo = list(
#'           ConfigurationArn = "string",
#'           ConfigurationRevision = 123,
#'           KafkaVersion = "string"
#'         ),
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Scram = list(
#'               Enabled = TRUE|FALSE
#'             ),
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           ),
#'           Tls = list(
#'             CertificateAuthorityArnList = list(
#'               "string"
#'             ),
#'             Enabled = TRUE|FALSE
#'           ),
#'           Unauthenticated = list(
#'             Enabled = TRUE|FALSE
#'           )
#'         ),
#'         EncryptionInfo = list(
#'           EncryptionAtRest = list(
#'             DataVolumeKMSKeyId = "string"
#'           ),
#'           EncryptionInTransit = list(
#'             ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'             InCluster = TRUE|FALSE
#'           )
#'         ),
#'         EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'         OpenMonitoring = list(
#'           Prometheus = list(
#'             JmxExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             ),
#'             NodeExporter = list(
#'               EnabledInBroker = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         LoggingInfo = list(
#'           BrokerLogs = list(
#'             CloudWatchLogs = list(
#'               Enabled = TRUE|FALSE,
#'               LogGroup = "string"
#'             ),
#'             Firehose = list(
#'               DeliveryStream = "string",
#'               Enabled = TRUE|FALSE
#'             ),
#'             S3 = list(
#'               Bucket = "string",
#'               Enabled = TRUE|FALSE,
#'               Prefix = "string"
#'             )
#'           )
#'         ),
#'         NumberOfBrokerNodes = 123,
#'         ZookeeperConnectString = "string",
#'         ZookeeperConnectStringTls = "string"
#'       ),
#'       Serverless = list(
#'         VpcConfigs = list(
#'           list(
#'             SubnetIds = list(
#'               "string"
#'             ),
#'             SecurityGroupIds = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         ClientAuthentication = list(
#'           Sasl = list(
#'             Iam = list(
#'               Enabled = TRUE|FALSE
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters_v2(
#'   ClusterNameFilter = "string",
#'   ClusterTypeFilter = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_clusters_v2
kafka_list_clusters_v2 <- function(ClusterNameFilter = NULL, ClusterTypeFilter = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListClustersV2",
    http_method = "GET",
    http_path = "/api/v2/clusters",
    paginator = list()
  )
  input <- .kafka$list_clusters_v2_input(ClusterNameFilter = ClusterNameFilter, ClusterTypeFilter = ClusterTypeFilter, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_clusters_v2_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_clusters_v2 <- kafka_list_clusters_v2

#' Returns a list of all the MSK configurations in this Region
#'
#' @description
#' Returns a list of all the MSK configurations in this Region.
#'
#' @usage
#' kafka_list_configuration_revisions(Arn, MaxResults, NextToken)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies an MSK
#' configuration and all of its revisions.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Revisions = list(
#'     list(
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       Revision = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_configuration_revisions(
#'   Arn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_configuration_revisions
kafka_list_configuration_revisions <- function(Arn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListConfigurationRevisions",
    http_method = "GET",
    http_path = "/v1/configurations/{arn}/revisions",
    paginator = list()
  )
  input <- .kafka$list_configuration_revisions_input(Arn = Arn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_configuration_revisions_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_configuration_revisions <- kafka_list_configuration_revisions

#' Returns a list of all the MSK configurations in this Region
#'
#' @description
#' Returns a list of all the MSK configurations in this Region.
#'
#' @usage
#' kafka_list_configurations(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Configurations = list(
#'     list(
#'       Arn = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Description = "string",
#'       KafkaVersions = list(
#'         "string"
#'       ),
#'       LatestRevision = list(
#'         CreationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Description = "string",
#'         Revision = 123
#'       ),
#'       Name = "string",
#'       State = "ACTIVE"|"DELETING"|"DELETE_FAILED"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_configurations(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_configurations
kafka_list_configurations <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListConfigurations",
    http_method = "GET",
    http_path = "/v1/configurations",
    paginator = list()
  )
  input <- .kafka$list_configurations_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_configurations_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_configurations <- kafka_list_configurations

#' Returns a list of Apache Kafka versions
#'
#' @description
#' Returns a list of Apache Kafka versions.
#'
#' @usage
#' kafka_list_kafka_versions(MaxResults, NextToken)
#'
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   KafkaVersions = list(
#'     list(
#'       Version = "string",
#'       Status = "ACTIVE"|"DEPRECATED"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_kafka_versions(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_kafka_versions
kafka_list_kafka_versions <- function(MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListKafkaVersions",
    http_method = "GET",
    http_path = "/v1/kafka-versions",
    paginator = list()
  )
  input <- .kafka$list_kafka_versions_input(MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_kafka_versions_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_kafka_versions <- kafka_list_kafka_versions

#' Returns a list of the broker nodes in the cluster
#'
#' @description
#' Returns a list of the broker nodes in the cluster.
#'
#' @usage
#' kafka_list_nodes(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param MaxResults The maximum number of results to return in the response. If there are
#' more results, the response includes a NextToken parameter.
#' @param NextToken The paginated results marker. When the result of the operation is
#' truncated, the call returns NextToken in the response. To get the next
#' batch, provide this token in your next request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NodeInfoList = list(
#'     list(
#'       AddedToClusterTime = "string",
#'       BrokerNodeInfo = list(
#'         AttachedENIId = "string",
#'         BrokerId = 123.0,
#'         ClientSubnet = "string",
#'         ClientVpcIpAddress = "string",
#'         CurrentBrokerSoftwareInfo = list(
#'           ConfigurationArn = "string",
#'           ConfigurationRevision = 123,
#'           KafkaVersion = "string"
#'         ),
#'         Endpoints = list(
#'           "string"
#'         )
#'       ),
#'       InstanceType = "string",
#'       NodeARN = "string",
#'       NodeType = "BROKER",
#'       ZookeeperNodeInfo = list(
#'         AttachedENIId = "string",
#'         ClientVpcIpAddress = "string",
#'         Endpoints = list(
#'           "string"
#'         ),
#'         ZookeeperId = 123.0,
#'         ZookeeperVersion = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_nodes(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_nodes
kafka_list_nodes <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListNodes",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/nodes",
    paginator = list()
  )
  input <- .kafka$list_nodes_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_nodes_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_nodes <- kafka_list_nodes

#' Returns a list of the Scram Secrets associated with an Amazon MSK
#' cluster
#'
#' @description
#' Returns a list of the Scram Secrets associated with an Amazon MSK
#' cluster.
#'
#' @usage
#' kafka_list_scram_secrets(ClusterArn, MaxResults, NextToken)
#'
#' @param ClusterArn &#91;required&#93; The arn of the cluster.
#' @param MaxResults The maxResults of the query.
#' @param NextToken The nextToken of the query.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   SecretArnList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_scram_secrets(
#'   ClusterArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_scram_secrets
kafka_list_scram_secrets <- function(ClusterArn, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListScramSecrets",
    http_method = "GET",
    http_path = "/v1/clusters/{clusterArn}/scram-secrets",
    paginator = list()
  )
  input <- .kafka$list_scram_secrets_input(ClusterArn = ClusterArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .kafka$list_scram_secrets_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_scram_secrets <- kafka_list_scram_secrets

#' Returns a list of the tags associated with the specified resource
#'
#' @description
#' Returns a list of the tags associated with the specified resource.
#'
#' @usage
#' kafka_list_tags_for_resource(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_list_tags_for_resource
kafka_list_tags_for_resource <- function(ResourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/v1/tags/{resourceArn}",
    paginator = list()
  )
  input <- .kafka$list_tags_for_resource_input(ResourceArn = ResourceArn)
  output <- .kafka$list_tags_for_resource_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$list_tags_for_resource <- kafka_list_tags_for_resource

#' Reboots brokers
#'
#' @description
#' Reboots brokers.
#'
#' @usage
#' kafka_reboot_broker(BrokerIds, ClusterArn)
#'
#' @param BrokerIds &#91;required&#93; The list of broker IDs to be rebooted. The reboot-broker operation
#' supports rebooting one broker at a time.
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reboot_broker(
#'   BrokerIds = list(
#'     "string"
#'   ),
#'   ClusterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_reboot_broker
kafka_reboot_broker <- function(BrokerIds, ClusterArn) {
  op <- new_operation(
    name = "RebootBroker",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/reboot-broker",
    paginator = list()
  )
  input <- .kafka$reboot_broker_input(BrokerIds = BrokerIds, ClusterArn = ClusterArn)
  output <- .kafka$reboot_broker_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$reboot_broker <- kafka_reboot_broker

#' Adds tags to the specified MSK resource
#'
#' @description
#' Adds tags to the specified MSK resource.
#'
#' @usage
#' kafka_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#' @param Tags &#91;required&#93; The key-value pair for the resource tag.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_tag_resource
kafka_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/v1/tags/{resourceArn}",
    paginator = list()
  )
  input <- .kafka$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .kafka$tag_resource_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$tag_resource <- kafka_tag_resource

#' Removes the tags associated with the keys that are provided in the query
#'
#' @description
#' Removes the tags associated with the keys that are provided in the
#' query.
#'
#' @usage
#' kafka_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the resource
#' that's associated with the tags.
#' @param TagKeys &#91;required&#93; Tag keys must be unique for a given cluster. In addition, the following
#' restrictions apply:
#' 
#' -   Each tag key must be unique. If you add a tag with a key that's
#'     already in use, your new tag overwrites the existing key-value pair.
#' 
#' -   You can't start a tag key with aws: because this prefix is reserved
#'     for use by AWS. AWS creates tags that begin with this prefix on your
#'     behalf, but you can't edit or delete them.
#' 
#' -   Tag keys must be between 1 and 128 Unicode characters in length.
#' 
#' -   Tag keys must consist of the following characters: Unicode letters,
#'     digits, white space, and the following special characters: _ . /
#'     = + - @@.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_untag_resource
kafka_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/v1/tags/{resourceArn}",
    paginator = list()
  )
  input <- .kafka$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .kafka$untag_resource_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$untag_resource <- kafka_untag_resource

#' Updates the number of broker nodes in the cluster
#'
#' @description
#' Updates the number of broker nodes in the cluster.
#'
#' @usage
#' kafka_update_broker_count(ClusterArn, CurrentVersion,
#'   TargetNumberOfBrokerNodes)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of cluster to update from. A successful operation will then
#' generate a new version.
#' @param TargetNumberOfBrokerNodes &#91;required&#93; The number of broker nodes that you want the cluster to have after this
#' operation completes successfully.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_count(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetNumberOfBrokerNodes = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_count
kafka_update_broker_count <- function(ClusterArn, CurrentVersion, TargetNumberOfBrokerNodes) {
  op <- new_operation(
    name = "UpdateBrokerCount",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/count",
    paginator = list()
  )
  input <- .kafka$update_broker_count_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetNumberOfBrokerNodes = TargetNumberOfBrokerNodes)
  output <- .kafka$update_broker_count_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_count <- kafka_update_broker_count

#' Updates EC2 instance type
#'
#' @description
#' Updates EC2 instance type.
#'
#' @usage
#' kafka_update_broker_type(ClusterArn, CurrentVersion, TargetInstanceType)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The cluster version that you want to change. After this operation
#' completes successfully, the cluster will have a new version.
#' @param TargetInstanceType &#91;required&#93; The Amazon MSK broker type that you want all of the brokers in this
#' cluster to be.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_type(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetInstanceType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_type
kafka_update_broker_type <- function(ClusterArn, CurrentVersion, TargetInstanceType) {
  op <- new_operation(
    name = "UpdateBrokerType",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/type",
    paginator = list()
  )
  input <- .kafka$update_broker_type_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetInstanceType = TargetInstanceType)
  output <- .kafka$update_broker_type_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_type <- kafka_update_broker_type

#' Updates the EBS storage associated with MSK brokers
#'
#' @description
#' Updates the EBS storage associated with MSK brokers.
#'
#' @usage
#' kafka_update_broker_storage(ClusterArn, CurrentVersion,
#'   TargetBrokerEBSVolumeInfo)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of cluster to update from. A successful operation will then
#' generate a new version.
#' @param TargetBrokerEBSVolumeInfo &#91;required&#93; Describes the target volume size and the ID of the broker to apply the
#' update to.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_broker_storage(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   TargetBrokerEBSVolumeInfo = list(
#'     list(
#'       KafkaBrokerNodeId = "string",
#'       ProvisionedThroughput = list(
#'         Enabled = TRUE|FALSE,
#'         VolumeThroughput = 123
#'       ),
#'       VolumeSizeGB = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_broker_storage
kafka_update_broker_storage <- function(ClusterArn, CurrentVersion, TargetBrokerEBSVolumeInfo) {
  op <- new_operation(
    name = "UpdateBrokerStorage",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/nodes/storage",
    paginator = list()
  )
  input <- .kafka$update_broker_storage_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, TargetBrokerEBSVolumeInfo = TargetBrokerEBSVolumeInfo)
  output <- .kafka$update_broker_storage_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_broker_storage <- kafka_update_broker_storage

#' Updates an MSK configuration
#'
#' @description
#' Updates an MSK configuration.
#'
#' @usage
#' kafka_update_configuration(Arn, Description, ServerProperties)
#'
#' @param Arn &#91;required&#93; The Amazon Resource Name (ARN) of the configuration.
#' @param Description The description of the configuration revision.
#' @param ServerProperties &#91;required&#93; Contents of the server.properties file. When using the API, you must
#' ensure that the contents of the file are base64 encoded. When using the
#' AWS Management Console, the SDK, or the AWS CLI, the contents of
#' server.properties can be in plaintext.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Arn = "string",
#'   LatestRevision = list(
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Description = "string",
#'     Revision = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_configuration(
#'   Arn = "string",
#'   Description = "string",
#'   ServerProperties = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_configuration
kafka_update_configuration <- function(Arn, Description = NULL, ServerProperties) {
  op <- new_operation(
    name = "UpdateConfiguration",
    http_method = "PUT",
    http_path = "/v1/configurations/{arn}",
    paginator = list()
  )
  input <- .kafka$update_configuration_input(Arn = Arn, Description = Description, ServerProperties = ServerProperties)
  output <- .kafka$update_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_configuration <- kafka_update_configuration

#' Updates the cluster's connectivity configuration
#'
#' @description
#' Updates the cluster's connectivity configuration.
#'
#' @usage
#' kafka_update_connectivity(ClusterArn, ConnectivityInfo, CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the configuration.
#' @param ConnectivityInfo &#91;required&#93; Information about the broker access configuration.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_connectivity(
#'   ClusterArn = "string",
#'   ConnectivityInfo = list(
#'     PublicAccess = list(
#'       Type = "string"
#'     )
#'   ),
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_connectivity
kafka_update_connectivity <- function(ClusterArn, ConnectivityInfo, CurrentVersion) {
  op <- new_operation(
    name = "UpdateConnectivity",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/connectivity",
    paginator = list()
  )
  input <- .kafka$update_connectivity_input(ClusterArn = ClusterArn, ConnectivityInfo = ConnectivityInfo, CurrentVersion = CurrentVersion)
  output <- .kafka$update_connectivity_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_connectivity <- kafka_update_connectivity

#' Updates the cluster with the configuration that is specified in the
#' request body
#'
#' @description
#' Updates the cluster with the configuration that is specified in the
#' request body.
#'
#' @usage
#' kafka_update_cluster_configuration(ClusterArn, ConfigurationInfo,
#'   CurrentVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param ConfigurationInfo &#91;required&#93; Represents the configuration that you want MSK to use for the brokers in
#' a cluster.
#' @param CurrentVersion &#91;required&#93; The version of the cluster that needs to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_configuration(
#'   ClusterArn = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   CurrentVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_cluster_configuration
kafka_update_cluster_configuration <- function(ClusterArn, ConfigurationInfo, CurrentVersion) {
  op <- new_operation(
    name = "UpdateClusterConfiguration",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/configuration",
    paginator = list()
  )
  input <- .kafka$update_cluster_configuration_input(ClusterArn = ClusterArn, ConfigurationInfo = ConfigurationInfo, CurrentVersion = CurrentVersion)
  output <- .kafka$update_cluster_configuration_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_cluster_configuration <- kafka_update_cluster_configuration

#' Updates the Apache Kafka version for the cluster
#'
#' @description
#' Updates the Apache Kafka version for the cluster.
#'
#' @usage
#' kafka_update_cluster_kafka_version(ClusterArn, ConfigurationInfo,
#'   CurrentVersion, TargetKafkaVersion)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) of the cluster to be updated.
#' @param ConfigurationInfo The custom configuration that should be applied on the new version of
#' cluster.
#' @param CurrentVersion &#91;required&#93; Current cluster version.
#' @param TargetKafkaVersion &#91;required&#93; Target Kafka version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_kafka_version(
#'   ClusterArn = "string",
#'   ConfigurationInfo = list(
#'     Arn = "string",
#'     Revision = 123
#'   ),
#'   CurrentVersion = "string",
#'   TargetKafkaVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_cluster_kafka_version
kafka_update_cluster_kafka_version <- function(ClusterArn, ConfigurationInfo = NULL, CurrentVersion, TargetKafkaVersion) {
  op <- new_operation(
    name = "UpdateClusterKafkaVersion",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/version",
    paginator = list()
  )
  input <- .kafka$update_cluster_kafka_version_input(ClusterArn = ClusterArn, ConfigurationInfo = ConfigurationInfo, CurrentVersion = CurrentVersion, TargetKafkaVersion = TargetKafkaVersion)
  output <- .kafka$update_cluster_kafka_version_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_cluster_kafka_version <- kafka_update_cluster_kafka_version

#' Updates the monitoring settings for the cluster
#'
#' @description
#' Updates the monitoring settings for the cluster. You can use this
#' operation to specify which Apache Kafka metrics you want Amazon MSK to
#' send to Amazon CloudWatch. You can also specify settings for open
#' monitoring with Prometheus.
#'
#' @usage
#' kafka_update_monitoring(ClusterArn, CurrentVersion, EnhancedMonitoring,
#'   OpenMonitoring, LoggingInfo)
#'
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#' @param EnhancedMonitoring Specifies which Apache Kafka metrics Amazon MSK gathers and sends to
#' Amazon CloudWatch for this cluster.
#' @param OpenMonitoring The settings for open monitoring.
#' @param LoggingInfo 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_monitoring(
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   EnhancedMonitoring = "DEFAULT"|"PER_BROKER"|"PER_TOPIC_PER_BROKER"|"PER_TOPIC_PER_PARTITION",
#'   OpenMonitoring = list(
#'     Prometheus = list(
#'       JmxExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       ),
#'       NodeExporter = list(
#'         EnabledInBroker = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   LoggingInfo = list(
#'     BrokerLogs = list(
#'       CloudWatchLogs = list(
#'         Enabled = TRUE|FALSE,
#'         LogGroup = "string"
#'       ),
#'       Firehose = list(
#'         DeliveryStream = "string",
#'         Enabled = TRUE|FALSE
#'       ),
#'       S3 = list(
#'         Bucket = "string",
#'         Enabled = TRUE|FALSE,
#'         Prefix = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_monitoring
kafka_update_monitoring <- function(ClusterArn, CurrentVersion, EnhancedMonitoring = NULL, OpenMonitoring = NULL, LoggingInfo = NULL) {
  op <- new_operation(
    name = "UpdateMonitoring",
    http_method = "PUT",
    http_path = "/v1/clusters/{clusterArn}/monitoring",
    paginator = list()
  )
  input <- .kafka$update_monitoring_input(ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, EnhancedMonitoring = EnhancedMonitoring, OpenMonitoring = OpenMonitoring, LoggingInfo = LoggingInfo)
  output <- .kafka$update_monitoring_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_monitoring <- kafka_update_monitoring

#' Updates the security settings for the cluster
#'
#' @description
#' Updates the security settings for the cluster. You can use this
#' operation to specify encryption and authentication on existing clusters.
#'
#' @usage
#' kafka_update_security(ClientAuthentication, ClusterArn, CurrentVersion,
#'   EncryptionInfo)
#'
#' @param ClientAuthentication Includes all client authentication related information.
#' @param ClusterArn &#91;required&#93; The Amazon Resource Name (ARN) that uniquely identifies the cluster.
#' @param CurrentVersion &#91;required&#93; The version of the MSK cluster to update. Cluster versions aren't simple
#' numbers. You can describe an MSK cluster to find its version. When this
#' update operation is successful, it generates a new cluster version.
#' @param EncryptionInfo Includes all encryption-related information.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ClusterArn = "string",
#'   ClusterOperationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_security(
#'   ClientAuthentication = list(
#'     Sasl = list(
#'       Scram = list(
#'         Enabled = TRUE|FALSE
#'       ),
#'       Iam = list(
#'         Enabled = TRUE|FALSE
#'       )
#'     ),
#'     Tls = list(
#'       CertificateAuthorityArnList = list(
#'         "string"
#'       ),
#'       Enabled = TRUE|FALSE
#'     ),
#'     Unauthenticated = list(
#'       Enabled = TRUE|FALSE
#'     )
#'   ),
#'   ClusterArn = "string",
#'   CurrentVersion = "string",
#'   EncryptionInfo = list(
#'     EncryptionAtRest = list(
#'       DataVolumeKMSKeyId = "string"
#'     ),
#'     EncryptionInTransit = list(
#'       ClientBroker = "TLS"|"TLS_PLAINTEXT"|"PLAINTEXT",
#'       InCluster = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname kafka_update_security
kafka_update_security <- function(ClientAuthentication = NULL, ClusterArn, CurrentVersion, EncryptionInfo = NULL) {
  op <- new_operation(
    name = "UpdateSecurity",
    http_method = "PATCH",
    http_path = "/v1/clusters/{clusterArn}/security",
    paginator = list()
  )
  input <- .kafka$update_security_input(ClientAuthentication = ClientAuthentication, ClusterArn = ClusterArn, CurrentVersion = CurrentVersion, EncryptionInfo = EncryptionInfo)
  output <- .kafka$update_security_output()
  config <- get_config()
  svc <- .kafka$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.kafka$operations$update_security <- kafka_update_security

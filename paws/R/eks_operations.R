# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include eks_service.R
NULL

#' Associate encryption configuration to an existing cluster
#'
#' @description
#' Associate encryption configuration to an existing cluster.
#' 
#' You can use this API to enable encryption on existing clusters which do
#' not have encryption already enabled. This allows you to implement a
#' defense-in-depth security strategy without migrating applications to new
#' Amazon EKS clusters.
#'
#' @usage
#' eks_associate_encryption_config(clusterName, encryptionConfig,
#'   clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of the cluster that you are associating with encryption
#' configuration.
#' @param encryptionConfig &#91;required&#93; The configuration you are using for encryption.
#' @param clientRequestToken The client request token you are using with the encryption
#' configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_encryption_config(
#'   clusterName = "string",
#'   encryptionConfig = list(
#'     list(
#'       resources = list(
#'         "string"
#'       ),
#'       provider = list(
#'         keyArn = "string"
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_associate_encryption_config
#'
#' @aliases eks_associate_encryption_config
eks_associate_encryption_config <- function(clusterName, encryptionConfig, clientRequestToken = NULL) {
  op <- new_operation(
    name = "AssociateEncryptionConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/encryption-config/associate",
    paginator = list()
  )
  input <- .eks$associate_encryption_config_input(clusterName = clusterName, encryptionConfig = encryptionConfig, clientRequestToken = clientRequestToken)
  output <- .eks$associate_encryption_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$associate_encryption_config <- eks_associate_encryption_config

#' Associate an identity provider configuration to a cluster
#'
#' @description
#' Associate an identity provider configuration to a cluster.
#' 
#' If you want to authenticate identities using an identity provider, you
#' can create an identity provider configuration and associate it to your
#' cluster. After configuring authentication to your cluster you can create
#' Kubernetes `roles` and `clusterroles` to assign permissions to the
#' roles, and then bind the roles to the identities using Kubernetes
#' `rolebindings` and `clusterrolebindings`. For more information see
#' [Using RBAC
#' Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
#' in the Kubernetes documentation.
#'
#' @usage
#' eks_associate_identity_provider_config(clusterName, oidc, tags,
#'   clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to associate the configuration to.
#' @param oidc &#91;required&#93; An object representing an OpenID Connect (OIDC) identity provider
#' configuration.
#' @param tags The metadata to apply to the configuration to assist with categorization
#' and organization. Each tag consists of a key and an optional value. You
#' define both.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_identity_provider_config(
#'   clusterName = "string",
#'   oidc = list(
#'     identityProviderConfigName = "string",
#'     issuerUrl = "string",
#'     clientId = "string",
#'     usernameClaim = "string",
#'     usernamePrefix = "string",
#'     groupsClaim = "string",
#'     groupsPrefix = "string",
#'     requiredClaims = list(
#'       "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_associate_identity_provider_config
#'
#' @aliases eks_associate_identity_provider_config
eks_associate_identity_provider_config <- function(clusterName, oidc, tags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "AssociateIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/associate",
    paginator = list()
  )
  input <- .eks$associate_identity_provider_config_input(clusterName = clusterName, oidc = oidc, tags = tags, clientRequestToken = clientRequestToken)
  output <- .eks$associate_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$associate_identity_provider_config <- eks_associate_identity_provider_config

#' Creates an Amazon EKS add-on
#'
#' @description
#' Creates an Amazon EKS add-on.
#' 
#' Amazon EKS add-ons help to automate the provisioning and lifecycle
#' management of common operational software for Amazon EKS clusters. For
#' more information, see [Amazon EKS
#' add-ons](https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_addon(clusterName, addonName, addonVersion,
#'   serviceAccountRoleArn, resolveConflicts, clientRequestToken, tags,
#'   configurationValues)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to create the add-on for.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names that
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' returns.
#' @param addonVersion The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#' @param serviceAccountRoleArn The Amazon Resource Name (ARN) of an existing IAM role to bind to the
#' add-on's service account. The role must be assigned the IAM permissions
#' required by the add-on. If you don't specify an existing IAM role, then
#' the add-on uses the permissions assigned to the node IAM role. For more
#' information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' To specify an existing IAM role, you must have an IAM OpenID Connect
#' (OIDC) provider created for your cluster. For more information, see
#' [Enabling IAM roles for service accounts on your
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)
#' in the *Amazon EKS User Guide*.
#' @param resolveConflicts How to resolve field value conflicts for an Amazon EKS add-on. Conflicts
#' are handled based on the value you choose:
#' 
#' -   **None** – If the self-managed version of the add-on is installed on
#'     your cluster, Amazon EKS doesn't change the value. Creation of the
#'     add-on might fail.
#' 
#' -   **Overwrite** – If the self-managed version of the add-on is
#'     installed on your cluster and the Amazon EKS default value is
#'     different than the existing value, Amazon EKS changes the value to
#'     the Amazon EKS default value.
#' 
#' -   **Preserve** – This is similar to the NONE option. If the
#'     self-managed version of the add-on is installed on your cluster
#'     Amazon EKS doesn't change the add-on resource properties. Creation
#'     of the add-on might fail if conflicts are detected. This option
#'     works differently during the update operation. For more information,
#'     see [`update_addon`][eks_update_addon].
#' 
#' If you don't currently have the self-managed version of the add-on
#' installed on your cluster, the Amazon EKS add-on is installed. Amazon
#' EKS sets all values to default values, regardless of the option that you
#' specify.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata to apply to the cluster to assist with categorization and
#' organization. Each tag consists of a key and an optional value. You
#' define both.
#' @param configurationValues The set of configuration values for the add-on that's created. The
#' values that you provide are validated against the schema in
#' [`describe_addon_configuration`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonConfiguration.html)
#' .
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   addonVersion = "string",
#'   serviceAccountRoleArn = "string",
#'   resolveConflicts = "OVERWRITE"|"NONE"|"PRESERVE",
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   configurationValues = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_addon
#'
#' @aliases eks_create_addon
eks_create_addon <- function(clusterName, addonName, addonVersion = NULL, serviceAccountRoleArn = NULL, resolveConflicts = NULL, clientRequestToken = NULL, tags = NULL, configurationValues = NULL) {
  op <- new_operation(
    name = "CreateAddon",
    http_method = "POST",
    http_path = "/clusters/{name}/addons",
    paginator = list()
  )
  input <- .eks$create_addon_input(clusterName = clusterName, addonName = addonName, addonVersion = addonVersion, serviceAccountRoleArn = serviceAccountRoleArn, resolveConflicts = resolveConflicts, clientRequestToken = clientRequestToken, tags = tags, configurationValues = configurationValues)
  output <- .eks$create_addon_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_addon <- eks_create_addon

#' Creates an Amazon EKS control plane
#'
#' @description
#' Creates an Amazon EKS control plane.
#' 
#' The Amazon EKS control plane consists of control plane instances that
#' run the Kubernetes software, such as `etcd` and the API server. The
#' control plane runs in an account managed by Amazon Web Services, and the
#' Kubernetes API is exposed by the Amazon EKS API server endpoint. Each
#' Amazon EKS cluster control plane is single tenant and unique. It runs on
#' its own set of Amazon EC2 instances.
#' 
#' The cluster control plane is provisioned across multiple Availability
#' Zones and fronted by an Elastic Load Balancing Network Load Balancer.
#' Amazon EKS also provisions elastic network interfaces in your VPC
#' subnets to provide connectivity from the control plane instances to the
#' nodes (for example, to support `kubectl exec`, `logs`, and `proxy` data
#' flows).
#' 
#' Amazon EKS nodes run in your Amazon Web Services account and connect to
#' your cluster's control plane over the Kubernetes API server endpoint and
#' a certificate file that is created for your cluster.
#' 
#' In most cases, it takes several minutes to create a cluster. After you
#' create an Amazon EKS cluster, you must configure your Kubernetes tooling
#' to communicate with the API server and launch nodes into your cluster.
#' For more information, see [Managing Cluster
#' Authentication](https://docs.aws.amazon.com/eks/latest/userguide/) and
#' [Launching Amazon EKS
#' nodes](https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_cluster(name, version, roleArn, resourcesVpcConfig,
#'   kubernetesNetworkConfig, logging, clientRequestToken, tags,
#'   encryptionConfig, outpostConfig)
#'
#' @param name &#91;required&#93; The unique name to give to your cluster.
#' @param version The desired Kubernetes version for your cluster. If you don't specify a
#' value here, the default version available in Amazon EKS is used.
#' 
#' The default version might not be the latest version available.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role that provides permissions
#' for the Kubernetes control plane to make calls to Amazon Web Services
#' API operations on your behalf. For more information, see [Amazon EKS
#' Service IAM
#' Role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html)
#' in the *Amazon EKS User Guide* .
#' @param resourcesVpcConfig &#91;required&#93; The VPC configuration that's used by the cluster control plane. Amazon
#' EKS VPC resources have specific requirements to work properly with
#' Kubernetes. For more information, see [Cluster VPC
#' Considerations](https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html)
#' and [Cluster Security Group
#' Considerations](https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html)
#' in the *Amazon EKS User Guide*. You must specify at least two subnets.
#' You can specify up to five security groups. However, we recommend that
#' you use a dedicated security group for your cluster control plane.
#' @param kubernetesNetworkConfig The Kubernetes network configuration for the cluster.
#' @param logging Enable or disable exporting the Kubernetes control plane logs for your
#' cluster to CloudWatch Logs. By default, cluster control plane logs
#' aren't exported to CloudWatch Logs. For more information, see [Amazon
#' EKS Cluster control plane
#' logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata to apply to the cluster to assist with categorization and
#' organization. Each tag consists of a key and an optional value. You
#' define both.
#' @param encryptionConfig The encryption configuration for the cluster.
#' @param outpostConfig An object representing the configuration of your local Amazon EKS
#' cluster on an Amazon Web Services Outpost. Before creating a local
#' cluster on an Outpost, review [Local clusters for Amazon EKS on Amazon
#' Web Services
#' Outposts](https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-local-cluster-overview.html)
#' in the *Amazon EKS User Guide*. This object isn't available for creating
#' Amazon EKS clusters on the Amazon Web Services cloud.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6"
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster(
#'   name = "string",
#'   version = "string",
#'   roleArn = "string",
#'   resourcesVpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     ),
#'     endpointPublicAccess = TRUE|FALSE,
#'     endpointPrivateAccess = TRUE|FALSE,
#'     publicAccessCidrs = list(
#'       "string"
#'     )
#'   ),
#'   kubernetesNetworkConfig = list(
#'     serviceIpv4Cidr = "string",
#'     ipFamily = "ipv4"|"ipv6"
#'   ),
#'   logging = list(
#'     clusterLogging = list(
#'       list(
#'         types = list(
#'           "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'         ),
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   encryptionConfig = list(
#'     list(
#'       resources = list(
#'         "string"
#'       ),
#'       provider = list(
#'         keyArn = "string"
#'       )
#'     )
#'   ),
#'   outpostConfig = list(
#'     outpostArns = list(
#'       "string"
#'     ),
#'     controlPlaneInstanceType = "string",
#'     controlPlanePlacement = list(
#'       groupName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates an Amazon EKS cluster called prod.
#' svc$create_cluster(
#'   version = "1.10",
#'   name = "prod",
#'   clientRequestToken = "1d2129a1-3d38-460a-9756-e5b91fddb951",
#'   resourcesVpcConfig = list(
#'     securityGroupIds = list(
#'       "sg-6979fe18"
#'     ),
#'     subnetIds = list(
#'       "subnet-6782e71e",
#'       "subnet-e7e761ac"
#'     )
#'   ),
#'   roleArn = "arn:aws:iam::012345678910:role/eks-service-role-AWSServiceRole..."
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_create_cluster
#'
#' @aliases eks_create_cluster
eks_create_cluster <- function(name, version = NULL, roleArn, resourcesVpcConfig, kubernetesNetworkConfig = NULL, logging = NULL, clientRequestToken = NULL, tags = NULL, encryptionConfig = NULL, outpostConfig = NULL) {
  op <- new_operation(
    name = "CreateCluster",
    http_method = "POST",
    http_path = "/clusters",
    paginator = list()
  )
  input <- .eks$create_cluster_input(name = name, version = version, roleArn = roleArn, resourcesVpcConfig = resourcesVpcConfig, kubernetesNetworkConfig = kubernetesNetworkConfig, logging = logging, clientRequestToken = clientRequestToken, tags = tags, encryptionConfig = encryptionConfig, outpostConfig = outpostConfig)
  output <- .eks$create_cluster_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_cluster <- eks_create_cluster

#' Creates an EKS Anywhere subscription
#'
#' @description
#' Creates an EKS Anywhere subscription. When a subscription is created, it
#' is a contract agreement for the length of the term specified in the
#' request. Licenses that are used to validate support are provisioned in
#' Amazon Web Services License Manager and the caller account is granted
#' access to EKS Anywhere Curated Packages.
#'
#' @usage
#' eks_create_eks_anywhere_subscription(name, term, licenseQuantity,
#'   licenseType, autoRenew, clientRequestToken, tags)
#'
#' @param name &#91;required&#93; The unique name for your subscription. It must be unique in your Amazon
#' Web Services account in the Amazon Web Services Region you're creating
#' the subscription in. The name can contain only alphanumeric characters
#' (case-sensitive), hyphens, and underscores. It must start with an
#' alphabetic character and can't be longer than 100 characters.
#' @param term &#91;required&#93; An object representing the term duration and term unit type of your
#' subscription. This determines the term length of your subscription.
#' Valid values are MONTHS for term unit and 12 or 36 for term duration,
#' indicating a 12 month or 36 month subscription. This value cannot be
#' changed after creating the subscription.
#' @param licenseQuantity The number of licenses to purchase with the subscription. Valid values
#' are between 1 and 1000. This value cannot be changed after creating the
#' subscription.
#' @param licenseType The license type for all licenses in the subscription. Valid value is
#' CLUSTER. With the CLUSTER license type, each license covers support for
#' a single EKS Anywhere cluster.
#' @param autoRenew A boolean indicating whether the subscription auto renews at the end of
#' the term.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata for a subscription to assist with categorization and
#' organization. Each tag consists of a key and an optional value.
#' Subscription tags do not propagate to any other resources associated
#' with the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_eks_anywhere_subscription(
#'   name = "string",
#'   term = list(
#'     duration = 123,
#'     unit = "MONTHS"
#'   ),
#'   licenseQuantity = 123,
#'   licenseType = "Cluster",
#'   autoRenew = TRUE|FALSE,
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_eks_anywhere_subscription
#'
#' @aliases eks_create_eks_anywhere_subscription
eks_create_eks_anywhere_subscription <- function(name, term, licenseQuantity = NULL, licenseType = NULL, autoRenew = NULL, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateEksAnywhereSubscription",
    http_method = "POST",
    http_path = "/eks-anywhere-subscriptions",
    paginator = list()
  )
  input <- .eks$create_eks_anywhere_subscription_input(name = name, term = term, licenseQuantity = licenseQuantity, licenseType = licenseType, autoRenew = autoRenew, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$create_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_eks_anywhere_subscription <- eks_create_eks_anywhere_subscription

#' Creates an Fargate profile for your Amazon EKS cluster
#'
#' @description
#' Creates an Fargate profile for your Amazon EKS cluster. You must have at
#' least one Fargate profile in a cluster to be able to run pods on
#' Fargate.
#' 
#' The Fargate profile allows an administrator to declare which pods run on
#' Fargate and specify which pods run on which Fargate profile. This
#' declaration is done through the profile’s selectors. Each profile can
#' have up to five selectors that contain a namespace and labels. A
#' namespace is required for every selector. The label field consists of
#' multiple optional key-value pairs. Pods that match the selectors are
#' scheduled on Fargate. If a to-be-scheduled pod matches any of the
#' selectors in the Fargate profile, then that pod is run on Fargate.
#' 
#' When you create a Fargate profile, you must specify a pod execution role
#' to use with the pods that are scheduled with the profile. This role is
#' added to the cluster's Kubernetes [Role Based Access
#' Control](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
#' (RBAC) for authorization so that the `kubelet` that is running on the
#' Fargate infrastructure can register with your Amazon EKS cluster so that
#' it can appear in your cluster as a node. The pod execution role also
#' provides IAM permissions to the Fargate infrastructure to allow read
#' access to Amazon ECR image repositories. For more information, see [Pod
#' Execution
#' Role](https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' Fargate profiles are immutable. However, you can create a new updated
#' profile to replace an existing profile and then delete the original
#' after the updated profile has finished creating.
#' 
#' If any Fargate profiles in a cluster are in the `DELETING` status, you
#' must wait for that Fargate profile to finish deleting before you can
#' create any other profiles in that cluster.
#' 
#' For more information, see [Fargate
#' Profile](https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_fargate_profile(fargateProfileName, clusterName,
#'   podExecutionRoleArn, subnets, selectors, clientRequestToken, tags)
#'
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile.
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster to apply the Fargate profile to.
#' @param podExecutionRoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the pod execution role to use for pods
#' that match the selectors in the Fargate profile. The pod execution role
#' allows Fargate infrastructure to register with your cluster as a node,
#' and it provides read access to Amazon ECR image repositories. For more
#' information, see [Pod Execution
#' Role](https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html)
#' in the *Amazon EKS User Guide*.
#' @param subnets The IDs of subnets to launch your pods into. At this time, pods running
#' on Fargate are not assigned public IP addresses, so only private subnets
#' (with no direct route to an Internet Gateway) are accepted for this
#' parameter.
#' @param selectors The selectors to match for pods to use this Fargate profile. Each
#' selector must have an associated namespace. Optionally, you can also
#' specify labels for a namespace. You may specify up to five selectors in
#' a Fargate profile.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata to apply to the Fargate profile to assist with
#' categorization and organization. Each tag consists of a key and an
#' optional value. You define both. Fargate profile tags do not propagate
#' to any other resources associated with the Fargate profile, such as the
#' pods that are scheduled with it.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_fargate_profile(
#'   fargateProfileName = "string",
#'   clusterName = "string",
#'   podExecutionRoleArn = "string",
#'   subnets = list(
#'     "string"
#'   ),
#'   selectors = list(
#'     list(
#'       namespace = "string",
#'       labels = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_fargate_profile
#'
#' @aliases eks_create_fargate_profile
eks_create_fargate_profile <- function(fargateProfileName, clusterName, podExecutionRoleArn, subnets = NULL, selectors = NULL, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateFargateProfile",
    http_method = "POST",
    http_path = "/clusters/{name}/fargate-profiles",
    paginator = list()
  )
  input <- .eks$create_fargate_profile_input(fargateProfileName = fargateProfileName, clusterName = clusterName, podExecutionRoleArn = podExecutionRoleArn, subnets = subnets, selectors = selectors, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$create_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_fargate_profile <- eks_create_fargate_profile

#' Creates a managed node group for an Amazon EKS cluster
#'
#' @description
#' Creates a managed node group for an Amazon EKS cluster. You can only
#' create a node group for your cluster that is equal to the current
#' Kubernetes version for the cluster.
#' 
#' An Amazon EKS managed node group is an Amazon EC2 Auto Scaling group and
#' associated Amazon EC2 instances that are managed by Amazon Web Services
#' for an Amazon EKS cluster. For more information, see [Managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html)
#' in the *Amazon EKS User Guide*.
#' 
#' Windows AMI types are only supported for commercial Regions that support
#' Windows Amazon EKS.
#'
#' @usage
#' eks_create_nodegroup(clusterName, nodegroupName, scalingConfig,
#'   diskSize, subnets, instanceTypes, amiType, remoteAccess, nodeRole,
#'   labels, taints, tags, clientRequestToken, launchTemplate, updateConfig,
#'   capacityType, version, releaseVersion)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to create the node group in.
#' @param nodegroupName &#91;required&#93; The unique name to give your node group.
#' @param scalingConfig The scaling configuration details for the Auto Scaling group that is
#' created for your node group.
#' @param diskSize The root device disk size (in GiB) for your node group instances. The
#' default disk size is 20 GiB for Linux and Bottlerocket. The default disk
#' size is 50 GiB for Windows. If you specify `launchTemplate`, then don't
#' specify `diskSize`, or the node group deployment will fail. For more
#' information about using launch templates with Amazon EKS, see [Launch
#' template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param subnets &#91;required&#93; The subnets to use for the Auto Scaling group that is created for your
#' node group. If you specify `launchTemplate`, then don't specify
#' [`SubnetId`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateNetworkInterface.html)
#' in your launch template, or the node group deployment will fail. For
#' more information about using launch templates with Amazon EKS, see
#' [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param instanceTypes Specify the instance types for a node group. If you specify a GPU
#' instance type, make sure to also specify an applicable GPU AMI type with
#' the `amiType` parameter. If you specify `launchTemplate`, then you can
#' specify zero or one instance type in your launch template *or* you can
#' specify 0-20 instance types for `instanceTypes`. If however, you specify
#' an instance type in your launch template *and* specify any
#' `instanceTypes`, the node group deployment will fail. If you don't
#' specify an instance type in a launch template or for `instanceTypes`,
#' then `t3.medium` is used, by default. If you specify `Spot` for
#' `capacityType`, then we recommend specifying multiple values for
#' `instanceTypes`. For more information, see [Managed node group capacity
#' types](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types)
#' and [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param amiType The AMI type for your node group. If you specify `launchTemplate`, and
#' your launch template uses a custom AMI, then don't specify `amiType`, or
#' the node group deployment will fail. If your launch template uses a
#' Windows custom AMI, then add `eks:kube-proxy-windows` to your Windows
#' nodes `rolearn` in the `aws-auth` `ConfigMap`. For more information
#' about using launch templates with Amazon EKS, see [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param remoteAccess The remote access configuration to use with your node group. For Linux,
#' the protocol is SSH. For Windows, the protocol is RDP. If you specify
#' `launchTemplate`, then don't specify `remoteAccess`, or the node group
#' deployment will fail. For more information about using launch templates
#' with Amazon EKS, see [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param nodeRole &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role to associate with your
#' node group. The Amazon EKS worker node `kubelet` daemon makes calls to
#' Amazon Web Services APIs on your behalf. Nodes receive permissions for
#' these API calls through an IAM instance profile and associated policies.
#' Before you can launch nodes and register them into a cluster, you must
#' create an IAM role for those nodes to use when they are launched. For
#' more information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide* . If you specify `launchTemplate`, then
#' don't specify
#' [`IamInstanceProfile`](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IamInstanceProfile.html)
#' in your launch template, or the node group deployment will fail. For
#' more information about using launch templates with Amazon EKS, see
#' [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param labels The Kubernetes labels to be applied to the nodes in the node group when
#' they are created.
#' @param taints The Kubernetes taints to be applied to the nodes in the node group. For
#' more information, see [Node taints on managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html).
#' @param tags The metadata to apply to the node group to assist with categorization
#' and organization. Each tag consists of a key and an optional value. You
#' define both. Node group tags do not propagate to any other resources
#' associated with the node group, such as the Amazon EC2 instances or
#' subnets.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param launchTemplate An object representing a node group's launch template specification. If
#' specified, then do not specify `instanceTypes`, `diskSize`, or
#' `remoteAccess` and make sure that the launch template meets the
#' requirements in `launchTemplateSpecification`.
#' @param updateConfig The node group update configuration.
#' @param capacityType The capacity type for your node group.
#' @param version The Kubernetes version to use for your managed nodes. By default, the
#' Kubernetes version of the cluster is used, and this is the only accepted
#' specified value. If you specify `launchTemplate`, and your launch
#' template uses a custom AMI, then don't specify `version`, or the node
#' group deployment will fail. For more information about using launch
#' templates with Amazon EKS, see [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param releaseVersion The AMI version of the Amazon EKS optimized AMI to use with your node
#' group. By default, the latest available AMI version for the node group's
#' current Kubernetes version is used. For information about Linux
#' versions, see [Amazon EKS optimized Amazon Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. Amazon EKS managed node groups support
#' the November 2022 and later releases of the Windows AMIs. For
#' information about Windows versions, see [Amazon EKS optimized Windows
#' AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you specify `launchTemplate`, and your launch template uses a custom
#' AMI, then don't specify `releaseVersion`, or the node group deployment
#' will fail. For more information about using launch templates with Amazon
#' EKS, see [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   scalingConfig = list(
#'     minSize = 123,
#'     maxSize = 123,
#'     desiredSize = 123
#'   ),
#'   diskSize = 123,
#'   subnets = list(
#'     "string"
#'   ),
#'   instanceTypes = list(
#'     "string"
#'   ),
#'   amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64",
#'   remoteAccess = list(
#'     ec2SshKey = "string",
#'     sourceSecurityGroups = list(
#'       "string"
#'     )
#'   ),
#'   nodeRole = "string",
#'   labels = list(
#'     "string"
#'   ),
#'   taints = list(
#'     list(
#'       key = "string",
#'       value = "string",
#'       effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string",
#'   launchTemplate = list(
#'     name = "string",
#'     version = "string",
#'     id = "string"
#'   ),
#'   updateConfig = list(
#'     maxUnavailable = 123,
#'     maxUnavailablePercentage = 123
#'   ),
#'   capacityType = "ON_DEMAND"|"SPOT",
#'   version = "string",
#'   releaseVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_nodegroup
#'
#' @aliases eks_create_nodegroup
eks_create_nodegroup <- function(clusterName, nodegroupName, scalingConfig = NULL, diskSize = NULL, subnets, instanceTypes = NULL, amiType = NULL, remoteAccess = NULL, nodeRole, labels = NULL, taints = NULL, tags = NULL, clientRequestToken = NULL, launchTemplate = NULL, updateConfig = NULL, capacityType = NULL, version = NULL, releaseVersion = NULL) {
  op <- new_operation(
    name = "CreateNodegroup",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups",
    paginator = list()
  )
  input <- .eks$create_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName, scalingConfig = scalingConfig, diskSize = diskSize, subnets = subnets, instanceTypes = instanceTypes, amiType = amiType, remoteAccess = remoteAccess, nodeRole = nodeRole, labels = labels, taints = taints, tags = tags, clientRequestToken = clientRequestToken, launchTemplate = launchTemplate, updateConfig = updateConfig, capacityType = capacityType, version = version, releaseVersion = releaseVersion)
  output <- .eks$create_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_nodegroup <- eks_create_nodegroup

#' Delete an Amazon EKS add-on
#'
#' @description
#' Delete an Amazon EKS add-on.
#' 
#' When you remove the add-on, it will also be deleted from the cluster.
#' You can always manually start an add-on on the cluster using the
#' Kubernetes API.
#'
#' @usage
#' eks_delete_addon(clusterName, addonName, preserve)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to delete the add-on from.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param preserve Specifying this option preserves the add-on software on your cluster but
#' Amazon EKS stops managing any settings for the add-on. If an IAM account
#' is associated with the add-on, it isn't removed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   preserve = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_addon
#'
#' @aliases eks_delete_addon
eks_delete_addon <- function(clusterName, addonName, preserve = NULL) {
  op <- new_operation(
    name = "DeleteAddon",
    http_method = "DELETE",
    http_path = "/clusters/{name}/addons/{addonName}",
    paginator = list()
  )
  input <- .eks$delete_addon_input(clusterName = clusterName, addonName = addonName, preserve = preserve)
  output <- .eks$delete_addon_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_addon <- eks_delete_addon

#' Deletes the Amazon EKS cluster control plane
#'
#' @description
#' Deletes the Amazon EKS cluster control plane.
#' 
#' If you have active services in your cluster that are associated with a
#' load balancer, you must delete those services before deleting the
#' cluster so that the load balancers are deleted properly. Otherwise, you
#' can have orphaned resources in your VPC that prevent you from being able
#' to delete the VPC. For more information, see [Deleting a
#' Cluster](https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you have managed node groups or Fargate profiles attached to the
#' cluster, you must delete them first. For more information, see
#' [`delete_nodegroup`][eks_delete_nodegroup] and
#' [`delete_fargate_profile`][eks_delete_fargate_profile].
#'
#' @usage
#' eks_delete_cluster(name)
#'
#' @param name &#91;required&#93; The name of the cluster to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6"
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command deletes a cluster named `devel` in your default
#' # region.
#' svc$delete_cluster(
#'   name = "devel"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_delete_cluster
#'
#' @aliases eks_delete_cluster
eks_delete_cluster <- function(name) {
  op <- new_operation(
    name = "DeleteCluster",
    http_method = "DELETE",
    http_path = "/clusters/{name}",
    paginator = list()
  )
  input <- .eks$delete_cluster_input(name = name)
  output <- .eks$delete_cluster_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_cluster <- eks_delete_cluster

#' Deletes an expired / inactive subscription
#'
#' @description
#' Deletes an expired / inactive subscription. Deleting inactive
#' subscriptions removes them from the Amazon Web Services Management
#' Console view and from list/describe API responses. Subscriptions can
#' only be cancelled within 7 days of creation, and are cancelled by
#' creating a ticket in the Amazon Web Services Support Center.
#'
#' @usage
#' eks_delete_eks_anywhere_subscription(id)
#'
#' @param id &#91;required&#93; The ID of the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_eks_anywhere_subscription(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_eks_anywhere_subscription
#'
#' @aliases eks_delete_eks_anywhere_subscription
eks_delete_eks_anywhere_subscription <- function(id) {
  op <- new_operation(
    name = "DeleteEksAnywhereSubscription",
    http_method = "DELETE",
    http_path = "/eks-anywhere-subscriptions/{id}",
    paginator = list()
  )
  input <- .eks$delete_eks_anywhere_subscription_input(id = id)
  output <- .eks$delete_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_eks_anywhere_subscription <- eks_delete_eks_anywhere_subscription

#' Deletes an Fargate profile
#'
#' @description
#' Deletes an Fargate profile.
#' 
#' When you delete a Fargate profile, any pods running on Fargate that were
#' created with the profile are deleted. If those pods match another
#' Fargate profile, then they are scheduled on Fargate with that profile.
#' If they no longer match any Fargate profiles, then they are not
#' scheduled on Fargate and they may remain in a pending state.
#' 
#' Only one Fargate profile in a cluster can be in the `DELETING` status at
#' a time. You must wait for a Fargate profile to finish deleting before
#' you can delete any other profiles in that cluster.
#'
#' @usage
#' eks_delete_fargate_profile(clusterName, fargateProfileName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster associated with the Fargate profile
#' to delete.
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_fargate_profile(
#'   clusterName = "string",
#'   fargateProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_fargate_profile
#'
#' @aliases eks_delete_fargate_profile
eks_delete_fargate_profile <- function(clusterName, fargateProfileName) {
  op <- new_operation(
    name = "DeleteFargateProfile",
    http_method = "DELETE",
    http_path = "/clusters/{name}/fargate-profiles/{fargateProfileName}",
    paginator = list()
  )
  input <- .eks$delete_fargate_profile_input(clusterName = clusterName, fargateProfileName = fargateProfileName)
  output <- .eks$delete_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_fargate_profile <- eks_delete_fargate_profile

#' Deletes an Amazon EKS node group for a cluster
#'
#' @description
#' Deletes an Amazon EKS node group for a cluster.
#'
#' @usage
#' eks_delete_nodegroup(clusterName, nodegroupName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that is associated with your node
#' group.
#' @param nodegroupName &#91;required&#93; The name of the node group to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_nodegroup
#'
#' @aliases eks_delete_nodegroup
eks_delete_nodegroup <- function(clusterName, nodegroupName) {
  op <- new_operation(
    name = "DeleteNodegroup",
    http_method = "DELETE",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}",
    paginator = list()
  )
  input <- .eks$delete_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName)
  output <- .eks$delete_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_nodegroup <- eks_delete_nodegroup

#' Deregisters a connected cluster to remove it from the Amazon EKS control
#' plane
#'
#' @description
#' Deregisters a connected cluster to remove it from the Amazon EKS control
#' plane.
#'
#' @usage
#' eks_deregister_cluster(name)
#'
#' @param name &#91;required&#93; The name of the connected cluster to deregister.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6"
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$deregister_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_deregister_cluster
#'
#' @aliases eks_deregister_cluster
eks_deregister_cluster <- function(name) {
  op <- new_operation(
    name = "DeregisterCluster",
    http_method = "DELETE",
    http_path = "/cluster-registrations/{name}",
    paginator = list()
  )
  input <- .eks$deregister_cluster_input(name = name)
  output <- .eks$deregister_cluster_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$deregister_cluster <- eks_deregister_cluster

#' Describes an Amazon EKS add-on
#'
#' @description
#' Describes an Amazon EKS add-on.
#'
#' @usage
#' eks_describe_addon(clusterName, addonName)
#'
#' @param clusterName &#91;required&#93; The name of the cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon(
#'   clusterName = "string",
#'   addonName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon
#'
#' @aliases eks_describe_addon
eks_describe_addon <- function(clusterName, addonName) {
  op <- new_operation(
    name = "DescribeAddon",
    http_method = "GET",
    http_path = "/clusters/{name}/addons/{addonName}",
    paginator = list()
  )
  input <- .eks$describe_addon_input(clusterName = clusterName, addonName = addonName)
  output <- .eks$describe_addon_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon <- eks_describe_addon

#' Returns configuration options
#'
#' @description
#' Returns configuration options.
#'
#' @usage
#' eks_describe_addon_configuration(addonName, addonVersion)
#'
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names that
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' returns.
#' @param addonVersion &#91;required&#93; The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addonName = "string",
#'   addonVersion = "string",
#'   configurationSchema = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon_configuration(
#'   addonName = "string",
#'   addonVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon_configuration
#'
#' @aliases eks_describe_addon_configuration
eks_describe_addon_configuration <- function(addonName, addonVersion) {
  op <- new_operation(
    name = "DescribeAddonConfiguration",
    http_method = "GET",
    http_path = "/addons/configuration-schemas",
    paginator = list()
  )
  input <- .eks$describe_addon_configuration_input(addonName = addonName, addonVersion = addonVersion)
  output <- .eks$describe_addon_configuration_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon_configuration <- eks_describe_addon_configuration

#' Describes the versions for an add-on
#'
#' @description
#' Describes the versions for an add-on. Information such as the Kubernetes
#' versions that you can use the add-on with, the `owner`, `publisher`, and
#' the `type` of the add-on are returned.
#'
#' @usage
#' eks_describe_addon_versions(kubernetesVersion, maxResults, nextToken,
#'   addonName, types, publishers, owners)
#'
#' @param kubernetesVersion The Kubernetes versions that you can use the add-on with.
#' @param maxResults The maximum number of results to return.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' `DescribeAddonVersionsRequest` where `maxResults` was used and the
#' results exceeded the value of that parameter. Pagination continues from
#' the end of the previous results that returned the `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#' @param addonName The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param types The type of the add-on. For valid `types`, don't specify a value for
#' this property.
#' @param publishers The publisher of the add-on. For valid `publishers`, don't specify a
#' value for this property.
#' @param owners The owner of the add-on. For valid `owners`, don't specify a value for
#' this property.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addons = list(
#'     list(
#'       addonName = "string",
#'       type = "string",
#'       addonVersions = list(
#'         list(
#'           addonVersion = "string",
#'           architecture = list(
#'             "string"
#'           ),
#'           compatibilities = list(
#'             list(
#'               clusterVersion = "string",
#'               platformVersions = list(
#'                 "string"
#'               ),
#'               defaultVersion = TRUE|FALSE
#'             )
#'           ),
#'           requiresConfiguration = TRUE|FALSE
#'         )
#'       ),
#'       publisher = "string",
#'       owner = "string",
#'       marketplaceInformation = list(
#'         productId = "string",
#'         productUrl = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon_versions(
#'   kubernetesVersion = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   addonName = "string",
#'   types = list(
#'     "string"
#'   ),
#'   publishers = list(
#'     "string"
#'   ),
#'   owners = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon_versions
#'
#' @aliases eks_describe_addon_versions
eks_describe_addon_versions <- function(kubernetesVersion = NULL, maxResults = NULL, nextToken = NULL, addonName = NULL, types = NULL, publishers = NULL, owners = NULL) {
  op <- new_operation(
    name = "DescribeAddonVersions",
    http_method = "GET",
    http_path = "/addons/supported-versions",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "addons")
  )
  input <- .eks$describe_addon_versions_input(kubernetesVersion = kubernetesVersion, maxResults = maxResults, nextToken = nextToken, addonName = addonName, types = types, publishers = publishers, owners = owners)
  output <- .eks$describe_addon_versions_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon_versions <- eks_describe_addon_versions

#' Returns descriptive information about an Amazon EKS cluster
#'
#' @description
#' Returns descriptive information about an Amazon EKS cluster.
#' 
#' The API server endpoint and certificate authority data returned by this
#' operation are required for `kubelet` and `kubectl` to communicate with
#' your Kubernetes API server. For more information, see [Create a
#' kubeconfig for Amazon
#' EKS](https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html).
#' 
#' The API server endpoint and certificate authority data aren't available
#' until the cluster reaches the `ACTIVE` state.
#'
#' @usage
#' eks_describe_cluster(name)
#'
#' @param name &#91;required&#93; The name of the cluster to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6"
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command provides a description of the specified cluster in
#' # your default region.
#' svc$describe_cluster(
#'   name = "devel"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_describe_cluster
#'
#' @aliases eks_describe_cluster
eks_describe_cluster <- function(name) {
  op <- new_operation(
    name = "DescribeCluster",
    http_method = "GET",
    http_path = "/clusters/{name}",
    paginator = list()
  )
  input <- .eks$describe_cluster_input(name = name)
  output <- .eks$describe_cluster_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_cluster <- eks_describe_cluster

#' Returns descriptive information about a subscription
#'
#' @description
#' Returns descriptive information about a subscription.
#'
#' @usage
#' eks_describe_eks_anywhere_subscription(id)
#'
#' @param id &#91;required&#93; The ID of the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_eks_anywhere_subscription(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_eks_anywhere_subscription
#'
#' @aliases eks_describe_eks_anywhere_subscription
eks_describe_eks_anywhere_subscription <- function(id) {
  op <- new_operation(
    name = "DescribeEksAnywhereSubscription",
    http_method = "GET",
    http_path = "/eks-anywhere-subscriptions/{id}",
    paginator = list()
  )
  input <- .eks$describe_eks_anywhere_subscription_input(id = id)
  output <- .eks$describe_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_eks_anywhere_subscription <- eks_describe_eks_anywhere_subscription

#' Returns descriptive information about an Fargate profile
#'
#' @description
#' Returns descriptive information about an Fargate profile.
#'
#' @usage
#' eks_describe_fargate_profile(clusterName, fargateProfileName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster associated with the Fargate profile.
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_fargate_profile(
#'   clusterName = "string",
#'   fargateProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_fargate_profile
#'
#' @aliases eks_describe_fargate_profile
eks_describe_fargate_profile <- function(clusterName, fargateProfileName) {
  op <- new_operation(
    name = "DescribeFargateProfile",
    http_method = "GET",
    http_path = "/clusters/{name}/fargate-profiles/{fargateProfileName}",
    paginator = list()
  )
  input <- .eks$describe_fargate_profile_input(clusterName = clusterName, fargateProfileName = fargateProfileName)
  output <- .eks$describe_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_fargate_profile <- eks_describe_fargate_profile

#' Returns descriptive information about an identity provider configuration
#'
#' @description
#' Returns descriptive information about an identity provider
#' configuration.
#'
#' @usage
#' eks_describe_identity_provider_config(clusterName,
#'   identityProviderConfig)
#'
#' @param clusterName &#91;required&#93; The cluster name that the identity provider configuration is associated
#' to.
#' @param identityProviderConfig &#91;required&#93; An object representing an identity provider configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   identityProviderConfig = list(
#'     oidc = list(
#'       identityProviderConfigName = "string",
#'       identityProviderConfigArn = "string",
#'       clusterName = "string",
#'       issuerUrl = "string",
#'       clientId = "string",
#'       usernameClaim = "string",
#'       usernamePrefix = "string",
#'       groupsClaim = "string",
#'       groupsPrefix = "string",
#'       requiredClaims = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       status = "CREATING"|"DELETING"|"ACTIVE"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_identity_provider_config(
#'   clusterName = "string",
#'   identityProviderConfig = list(
#'     type = "string",
#'     name = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_identity_provider_config
#'
#' @aliases eks_describe_identity_provider_config
eks_describe_identity_provider_config <- function(clusterName, identityProviderConfig) {
  op <- new_operation(
    name = "DescribeIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/describe",
    paginator = list()
  )
  input <- .eks$describe_identity_provider_config_input(clusterName = clusterName, identityProviderConfig = identityProviderConfig)
  output <- .eks$describe_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_identity_provider_config <- eks_describe_identity_provider_config

#' Returns descriptive information about an Amazon EKS node group
#'
#' @description
#' Returns descriptive information about an Amazon EKS node group.
#'
#' @usage
#' eks_describe_nodegroup(clusterName, nodegroupName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster associated with the node group.
#' @param nodegroupName &#91;required&#93; The name of the node group to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_nodegroup
#'
#' @aliases eks_describe_nodegroup
eks_describe_nodegroup <- function(clusterName, nodegroupName) {
  op <- new_operation(
    name = "DescribeNodegroup",
    http_method = "GET",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}",
    paginator = list()
  )
  input <- .eks$describe_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName)
  output <- .eks$describe_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_nodegroup <- eks_describe_nodegroup

#' Returns descriptive information about an update against your Amazon EKS
#' cluster or associated managed node group or Amazon EKS add-on
#'
#' @description
#' Returns descriptive information about an update against your Amazon EKS
#' cluster or associated managed node group or Amazon EKS add-on.
#' 
#' When the status of the update is `Succeeded`, the update is complete. If
#' an update fails, the status is `Failed`, and an error detail explains
#' the reason for the failure.
#'
#' @usage
#' eks_describe_update(name, updateId, nodegroupName, addonName)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster associated with the update.
#' @param updateId &#91;required&#93; The ID of the update to describe.
#' @param nodegroupName The name of the Amazon EKS node group associated with the update. This
#' parameter is required if the update is a node group update.
#' @param addonName The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' . This parameter is required if the update is an add-on update.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_update(
#'   name = "string",
#'   updateId = "string",
#'   nodegroupName = "string",
#'   addonName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_update
#'
#' @aliases eks_describe_update
eks_describe_update <- function(name, updateId, nodegroupName = NULL, addonName = NULL) {
  op <- new_operation(
    name = "DescribeUpdate",
    http_method = "GET",
    http_path = "/clusters/{name}/updates/{updateId}",
    paginator = list()
  )
  input <- .eks$describe_update_input(name = name, updateId = updateId, nodegroupName = nodegroupName, addonName = addonName)
  output <- .eks$describe_update_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_update <- eks_describe_update

#' Disassociates an identity provider configuration from a cluster
#'
#' @description
#' Disassociates an identity provider configuration from a cluster. If you
#' disassociate an identity provider from your cluster, users included in
#' the provider can no longer access the cluster. However, you can still
#' access the cluster with [IAM
#' principals](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts.html).
#'
#' @usage
#' eks_disassociate_identity_provider_config(clusterName,
#'   identityProviderConfig, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to disassociate an identity provider from.
#' @param identityProviderConfig &#91;required&#93; An object representing an identity provider configuration.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_identity_provider_config(
#'   clusterName = "string",
#'   identityProviderConfig = list(
#'     type = "string",
#'     name = "string"
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_disassociate_identity_provider_config
#'
#' @aliases eks_disassociate_identity_provider_config
eks_disassociate_identity_provider_config <- function(clusterName, identityProviderConfig, clientRequestToken = NULL) {
  op <- new_operation(
    name = "DisassociateIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/disassociate",
    paginator = list()
  )
  input <- .eks$disassociate_identity_provider_config_input(clusterName = clusterName, identityProviderConfig = identityProviderConfig, clientRequestToken = clientRequestToken)
  output <- .eks$disassociate_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$disassociate_identity_provider_config <- eks_disassociate_identity_provider_config

#' Lists the installed add-ons
#'
#' @description
#' Lists the installed add-ons.
#'
#' @usage
#' eks_list_addons(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of the cluster.
#' @param maxResults The maximum number of add-on results returned by `ListAddonsRequest` in
#' paginated output. When you use this parameter, `ListAddonsRequest`
#' returns only `maxResults` results in a single page along with a
#' `nextToken` response element. You can see the remaining results of the
#' initial request by sending another `ListAddonsRequest` request with the
#' returned `nextToken` value. This value can be between 1 and 100. If you
#' don't use this parameter, `ListAddonsRequest` returns up to 100 results
#' and a `nextToken` value, if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' `ListAddonsRequest` where `maxResults` was used and the results exceeded
#' the value of that parameter. Pagination continues from the end of the
#' previous results that returned the `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addons = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_addons(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_addons
#'
#' @aliases eks_list_addons
eks_list_addons <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAddons",
    http_method = "GET",
    http_path = "/clusters/{name}/addons",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "addons")
  )
  input <- .eks$list_addons_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_addons_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_addons <- eks_list_addons

#' Lists the Amazon EKS clusters in your Amazon Web Services account in the
#' specified Region
#'
#' @description
#' Lists the Amazon EKS clusters in your Amazon Web Services account in the
#' specified Region.
#'
#' @usage
#' eks_list_clusters(maxResults, nextToken, include)
#'
#' @param maxResults The maximum number of cluster results returned by
#' [`list_clusters`][eks_list_clusters] in paginated output. When you use
#' this parameter, [`list_clusters`][eks_list_clusters] returns only
#' `maxResults` results in a single page along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another [`list_clusters`][eks_list_clusters] request with the
#' returned `nextToken` value. This value can be between 1 and 100. If you
#' don't use this parameter, [`list_clusters`][eks_list_clusters] returns
#' up to 100 results and a `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_clusters`][eks_list_clusters] request where `maxResults` was used
#' and the results exceeded the value of that parameter. Pagination
#' continues from the end of the previous results that returned the
#' `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#' @param include Indicates whether external clusters are included in the returned list.
#' Use '`all`' to return connected clusters, or blank to return only Amazon
#' EKS clusters. '`all`' must be in lowercase otherwise an error occurs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   clusters = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters(
#'   maxResults = 123,
#'   nextToken = "string",
#'   include = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command lists all of your available clusters in your
#' # default region.
#' svc$list_clusters()
#' }
#'
#' @keywords internal
#'
#' @rdname eks_list_clusters
#'
#' @aliases eks_list_clusters
eks_list_clusters <- function(maxResults = NULL, nextToken = NULL, include = NULL) {
  op <- new_operation(
    name = "ListClusters",
    http_method = "GET",
    http_path = "/clusters",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "clusters")
  )
  input <- .eks$list_clusters_input(maxResults = maxResults, nextToken = nextToken, include = include)
  output <- .eks$list_clusters_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_clusters <- eks_list_clusters

#' Displays the full description of the subscription
#'
#' @description
#' Displays the full description of the subscription.
#'
#' @usage
#' eks_list_eks_anywhere_subscriptions(maxResults, nextToken,
#'   includeStatus)
#'
#' @param maxResults The maximum number of cluster results returned by
#' ListEksAnywhereSubscriptions in paginated output. When you use this
#' parameter, ListEksAnywhereSubscriptions returns only maxResults results
#' in a single page along with a nextToken response element. You can see
#' the remaining results of the initial request by sending another
#' ListEksAnywhereSubscriptions request with the returned nextToken value.
#' This value can be between 1 and 100. If you don't use this parameter,
#' ListEksAnywhereSubscriptions returns up to 10 results and a nextToken
#' value if applicable.
#' @param nextToken The nextToken value to include in a future ListEksAnywhereSubscriptions
#' request. When the results of a ListEksAnywhereSubscriptions request
#' exceed maxResults, you can use this value to retrieve the next page of
#' results. This value is null when there are no more results to return.
#' @param includeStatus An array of subscription statuses to filter on.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriptions = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       effectiveDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       expirationDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       licenseQuantity = 123,
#'       licenseType = "Cluster",
#'       term = list(
#'         duration = 123,
#'         unit = "MONTHS"
#'       ),
#'       status = "string",
#'       autoRenew = TRUE|FALSE,
#'       licenseArns = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_eks_anywhere_subscriptions(
#'   maxResults = 123,
#'   nextToken = "string",
#'   includeStatus = list(
#'     "CREATING"|"ACTIVE"|"UPDATING"|"EXPIRING"|"EXPIRED"|"DELETING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_eks_anywhere_subscriptions
#'
#' @aliases eks_list_eks_anywhere_subscriptions
eks_list_eks_anywhere_subscriptions <- function(maxResults = NULL, nextToken = NULL, includeStatus = NULL) {
  op <- new_operation(
    name = "ListEksAnywhereSubscriptions",
    http_method = "GET",
    http_path = "/eks-anywhere-subscriptions",
    paginator = list()
  )
  input <- .eks$list_eks_anywhere_subscriptions_input(maxResults = maxResults, nextToken = nextToken, includeStatus = includeStatus)
  output <- .eks$list_eks_anywhere_subscriptions_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_eks_anywhere_subscriptions <- eks_list_eks_anywhere_subscriptions

#' Lists the Fargate profiles associated with the specified cluster in your
#' Amazon Web Services account in the specified Region
#'
#' @description
#' Lists the Fargate profiles associated with the specified cluster in your
#' Amazon Web Services account in the specified Region.
#'
#' @usage
#' eks_list_fargate_profiles(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that you would like to list Fargate
#' profiles in.
#' @param maxResults The maximum number of Fargate profile results returned by
#' [`list_fargate_profiles`][eks_list_fargate_profiles] in paginated
#' output. When you use this parameter,
#' [`list_fargate_profiles`][eks_list_fargate_profiles] returns only
#' `maxResults` results in a single page along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another [`list_fargate_profiles`][eks_list_fargate_profiles]
#' request with the returned `nextToken` value. This value can be between 1
#' and 100. If you don't use this parameter,
#' [`list_fargate_profiles`][eks_list_fargate_profiles] returns up to 100
#' results and a `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_fargate_profiles`][eks_list_fargate_profiles] request where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfileNames = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_fargate_profiles(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_fargate_profiles
#'
#' @aliases eks_list_fargate_profiles
eks_list_fargate_profiles <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListFargateProfiles",
    http_method = "GET",
    http_path = "/clusters/{name}/fargate-profiles",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "fargateProfileNames")
  )
  input <- .eks$list_fargate_profiles_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_fargate_profiles_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_fargate_profiles <- eks_list_fargate_profiles

#' A list of identity provider configurations
#'
#' @description
#' A list of identity provider configurations.
#'
#' @usage
#' eks_list_identity_provider_configs(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The cluster name that you want to list identity provider configurations
#' for.
#' @param maxResults The maximum number of identity provider configurations returned by
#' [`list_identity_provider_configs`][eks_list_identity_provider_configs]
#' in paginated output. When you use this parameter,
#' [`list_identity_provider_configs`][eks_list_identity_provider_configs]
#' returns only `maxResults` results in a single page along with a
#' `nextToken` response element. You can see the remaining results of the
#' initial request by sending another
#' [`list_identity_provider_configs`][eks_list_identity_provider_configs]
#' request with the returned `nextToken` value. This value can be between 1
#' and 100. If you don't use this parameter,
#' [`list_identity_provider_configs`][eks_list_identity_provider_configs]
#' returns up to 100 results and a `nextToken` value, if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' `IdentityProviderConfigsRequest` where `maxResults` was used and the
#' results exceeded the value of that parameter. Pagination continues from
#' the end of the previous results that returned the `nextToken` value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   identityProviderConfigs = list(
#'     list(
#'       type = "string",
#'       name = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_identity_provider_configs(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_identity_provider_configs
#'
#' @aliases eks_list_identity_provider_configs
eks_list_identity_provider_configs <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListIdentityProviderConfigs",
    http_method = "GET",
    http_path = "/clusters/{name}/identity-provider-configs",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "identityProviderConfigs")
  )
  input <- .eks$list_identity_provider_configs_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_identity_provider_configs_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_identity_provider_configs <- eks_list_identity_provider_configs

#' Lists the Amazon EKS managed node groups associated with the specified
#' cluster in your Amazon Web Services account in the specified Region
#'
#' @description
#' Lists the Amazon EKS managed node groups associated with the specified
#' cluster in your Amazon Web Services account in the specified Region.
#' Self-managed node groups are not listed.
#'
#' @usage
#' eks_list_nodegroups(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that you would like to list node
#' groups in.
#' @param maxResults The maximum number of node group results returned by
#' [`list_nodegroups`][eks_list_nodegroups] in paginated output. When you
#' use this parameter, [`list_nodegroups`][eks_list_nodegroups] returns
#' only `maxResults` results in a single page along with a `nextToken`
#' response element. You can see the remaining results of the initial
#' request by sending another [`list_nodegroups`][eks_list_nodegroups]
#' request with the returned `nextToken` value. This value can be between 1
#' and 100. If you don't use this parameter,
#' [`list_nodegroups`][eks_list_nodegroups] returns up to 100 results and a
#' `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_nodegroups`][eks_list_nodegroups] request where `maxResults` was
#' used and the results exceeded the value of that parameter. Pagination
#' continues from the end of the previous results that returned the
#' `nextToken` value.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroups = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_nodegroups(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_nodegroups
#'
#' @aliases eks_list_nodegroups
eks_list_nodegroups <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListNodegroups",
    http_method = "GET",
    http_path = "/clusters/{name}/node-groups",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "nodegroups")
  )
  input <- .eks$list_nodegroups_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_nodegroups_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_nodegroups <- eks_list_nodegroups

#' List the tags for an Amazon EKS resource
#'
#' @description
#' List the tags for an Amazon EKS resource.
#'
#' @usage
#' eks_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource for which to
#' list the tags. Currently, the supported resources are Amazon EKS
#' clusters and managed node groups.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example lists all of the tags for the `beta` cluster.
#' svc$list_tags_for_resource(
#'   resourceArn = "arn:aws:eks:us-west-2:012345678910:cluster/beta"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_list_tags_for_resource
#'
#' @aliases eks_list_tags_for_resource
eks_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .eks$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .eks$list_tags_for_resource_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_tags_for_resource <- eks_list_tags_for_resource

#' Lists the updates associated with an Amazon EKS cluster or managed node
#' group in your Amazon Web Services account, in the specified Region
#'
#' @description
#' Lists the updates associated with an Amazon EKS cluster or managed node
#' group in your Amazon Web Services account, in the specified Region.
#'
#' @usage
#' eks_list_updates(name, nodegroupName, addonName, nextToken, maxResults)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to list updates for.
#' @param nodegroupName The name of the Amazon EKS managed node group to list updates for.
#' @param addonName The names of the installed add-ons that have available updates.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_updates`][eks_list_updates] request where `maxResults` was used
#' and the results exceeded the value of that parameter. Pagination
#' continues from the end of the previous results that returned the
#' `nextToken` value.
#' @param maxResults The maximum number of update results returned by
#' [`list_updates`][eks_list_updates] in paginated output. When you use
#' this parameter, [`list_updates`][eks_list_updates] returns only
#' `maxResults` results in a single page along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another [`list_updates`][eks_list_updates] request with the
#' returned `nextToken` value. This value can be between 1 and 100. If you
#' don't use this parameter, [`list_updates`][eks_list_updates] returns up
#' to 100 results and a `nextToken` value if applicable.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   updateIds = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_updates(
#'   name = "string",
#'   nodegroupName = "string",
#'   addonName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_updates
#'
#' @aliases eks_list_updates
eks_list_updates <- function(name, nodegroupName = NULL, addonName = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListUpdates",
    http_method = "GET",
    http_path = "/clusters/{name}/updates",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "updateIds")
  )
  input <- .eks$list_updates_input(name = name, nodegroupName = nodegroupName, addonName = addonName, nextToken = nextToken, maxResults = maxResults)
  output <- .eks$list_updates_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_updates <- eks_list_updates

#' Connects a Kubernetes cluster to the Amazon EKS control plane
#'
#' @description
#' Connects a Kubernetes cluster to the Amazon EKS control plane.
#' 
#' Any Kubernetes cluster can be connected to the Amazon EKS control plane
#' to view current information about the cluster and its nodes.
#' 
#' Cluster connection requires two steps. First, send a
#' ` RegisterClusterRequest ` to add it to the Amazon EKS control plane.
#' 
#' Second, a
#' [Manifest](https://amazon-eks.s3.us-west-2.amazonaws.com/eks-connector/manifests/eks-connector/latest/eks-connector.yaml)
#' containing the `activationID` and `activationCode` must be applied to
#' the Kubernetes cluster through it's native provider to provide
#' visibility.
#' 
#' After the Manifest is updated and applied, then the connected cluster is
#' visible to the Amazon EKS control plane. If the Manifest is not applied
#' within three days, then the connected cluster will no longer be visible
#' and must be deregistered. See
#' [`deregister_cluster`][eks_deregister_cluster].
#'
#' @usage
#' eks_register_cluster(name, connectorConfig, clientRequestToken, tags)
#'
#' @param name &#91;required&#93; Define a unique name for this cluster for your Region.
#' @param connectorConfig &#91;required&#93; The configuration settings required to connect the Kubernetes cluster to
#' the Amazon EKS control plane.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata that you apply to the cluster to assist with categorization
#' and organization. Each tag consists of a key and an optional value, both
#' of which you define. Cluster tags do not propagate to any other
#' resources associated with the cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6"
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$register_cluster(
#'   name = "string",
#'   connectorConfig = list(
#'     roleArn = "string",
#'     provider = "EKS_ANYWHERE"|"ANTHOS"|"GKE"|"AKS"|"OPENSHIFT"|"TANZU"|"RANCHER"|"EC2"|"OTHER"
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_register_cluster
#'
#' @aliases eks_register_cluster
eks_register_cluster <- function(name, connectorConfig, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "RegisterCluster",
    http_method = "POST",
    http_path = "/cluster-registrations",
    paginator = list()
  )
  input <- .eks$register_cluster_input(name = name, connectorConfig = connectorConfig, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$register_cluster_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$register_cluster <- eks_register_cluster

#' Associates the specified tags to a resource with the specified
#' resourceArn
#'
#' @description
#' Associates the specified tags to a resource with the specified
#' `resourceArn`. If existing tags on a resource are not specified in the
#' request parameters, they are not changed. When a resource is deleted,
#' the tags associated with that resource are deleted as well. Tags that
#' you create for Amazon EKS resources do not propagate to any other
#' resources associated with the cluster. For example, if you tag a cluster
#' with this operation, that tag does not automatically propagate to the
#' subnets and nodes associated with the cluster.
#'
#' @usage
#' eks_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource to which to add tags.
#' Currently, the supported resources are Amazon EKS clusters and managed
#' node groups.
#' @param tags &#91;required&#93; The tags to add to the resource. A tag is an array of key-value pairs.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_tag_resource
#'
#' @aliases eks_tag_resource
eks_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .eks$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .eks$tag_resource_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$tag_resource <- eks_tag_resource

#' Deletes specified tags from a resource
#'
#' @description
#' Deletes specified tags from a resource.
#'
#' @usage
#' eks_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource from which to delete
#' tags. Currently, the supported resources are Amazon EKS clusters and
#' managed node groups.
#' @param tagKeys &#91;required&#93; The keys of the tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_untag_resource
#'
#' @aliases eks_untag_resource
eks_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .eks$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .eks$untag_resource_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$untag_resource <- eks_untag_resource

#' Updates an Amazon EKS add-on
#'
#' @description
#' Updates an Amazon EKS add-on.
#'
#' @usage
#' eks_update_addon(clusterName, addonName, addonVersion,
#'   serviceAccountRoleArn, resolveConflicts, clientRequestToken,
#'   configurationValues)
#'
#' @param clusterName &#91;required&#93; The name of the cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param addonVersion The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#' @param serviceAccountRoleArn The Amazon Resource Name (ARN) of an existing IAM role to bind to the
#' add-on's service account. The role must be assigned the IAM permissions
#' required by the add-on. If you don't specify an existing IAM role, then
#' the add-on uses the permissions assigned to the node IAM role. For more
#' information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' To specify an existing IAM role, you must have an IAM OpenID Connect
#' (OIDC) provider created for your cluster. For more information, see
#' [Enabling IAM roles for service accounts on your
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)
#' in the *Amazon EKS User Guide*.
#' @param resolveConflicts How to resolve field value conflicts for an Amazon EKS add-on if you've
#' changed a value from the Amazon EKS default value. Conflicts are handled
#' based on the option you choose:
#' 
#' -   **None** – Amazon EKS doesn't change the value. The update might
#'     fail.
#' 
#' -   **Overwrite** – Amazon EKS overwrites the changed value back to the
#'     Amazon EKS default value.
#' 
#' -   **Preserve** – Amazon EKS preserves the value. If you choose this
#'     option, we recommend that you test any field and value changes on a
#'     non-production cluster before updating the add-on on your production
#'     cluster.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param configurationValues The set of configuration values for the add-on that's created. The
#' values that you provide are validated against the schema in
#' [`describe_addon_configuration`][eks_describe_addon_configuration].
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   addonVersion = "string",
#'   serviceAccountRoleArn = "string",
#'   resolveConflicts = "OVERWRITE"|"NONE"|"PRESERVE",
#'   clientRequestToken = "string",
#'   configurationValues = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_addon
#'
#' @aliases eks_update_addon
eks_update_addon <- function(clusterName, addonName, addonVersion = NULL, serviceAccountRoleArn = NULL, resolveConflicts = NULL, clientRequestToken = NULL, configurationValues = NULL) {
  op <- new_operation(
    name = "UpdateAddon",
    http_method = "POST",
    http_path = "/clusters/{name}/addons/{addonName}/update",
    paginator = list()
  )
  input <- .eks$update_addon_input(clusterName = clusterName, addonName = addonName, addonVersion = addonVersion, serviceAccountRoleArn = serviceAccountRoleArn, resolveConflicts = resolveConflicts, clientRequestToken = clientRequestToken, configurationValues = configurationValues)
  output <- .eks$update_addon_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_addon <- eks_update_addon

#' Updates an Amazon EKS cluster configuration
#'
#' @description
#' Updates an Amazon EKS cluster configuration. Your cluster continues to
#' function during the update. The response output includes an update ID
#' that you can use to track the status of your cluster update with the
#' [`describe_update`][eks_describe_update] API operation.
#' 
#' You can use this API operation to enable or disable exporting the
#' Kubernetes control plane logs for your cluster to CloudWatch Logs. By
#' default, cluster control plane logs aren't exported to CloudWatch Logs.
#' For more information, see [Amazon EKS Cluster Control Plane
#' Logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' 
#' You can also use this API operation to enable or disable public and
#' private access to your cluster's Kubernetes API server endpoint. By
#' default, public access is enabled, and private access is disabled. For
#' more information, see [Amazon EKS cluster endpoint access
#' control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html)
#' in the *Amazon EKS User Guide* .
#' 
#' You can't update the subnets or security group IDs for an existing
#' cluster.
#' 
#' Cluster updates are asynchronous, and they should finish within a few
#' minutes. During an update, the cluster status moves to `UPDATING` (this
#' status transition is eventually consistent). When the update is complete
#' (either `Failed` or `Successful`), the cluster status moves to `Active`.
#'
#' @usage
#' eks_update_cluster_config(name, resourcesVpcConfig, logging,
#'   clientRequestToken)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to update.
#' @param resourcesVpcConfig 
#' @param logging Enable or disable exporting the Kubernetes control plane logs for your
#' cluster to CloudWatch Logs. By default, cluster control plane logs
#' aren't exported to CloudWatch Logs. For more information, see [Amazon
#' EKS cluster control plane
#' logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_config(
#'   name = "string",
#'   resourcesVpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     ),
#'     endpointPublicAccess = TRUE|FALSE,
#'     endpointPrivateAccess = TRUE|FALSE,
#'     publicAccessCidrs = list(
#'       "string"
#'     )
#'   ),
#'   logging = list(
#'     clusterLogging = list(
#'       list(
#'         types = list(
#'           "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'         ),
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_cluster_config
#'
#' @aliases eks_update_cluster_config
eks_update_cluster_config <- function(name, resourcesVpcConfig = NULL, logging = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateClusterConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/update-config",
    paginator = list()
  )
  input <- .eks$update_cluster_config_input(name = name, resourcesVpcConfig = resourcesVpcConfig, logging = logging, clientRequestToken = clientRequestToken)
  output <- .eks$update_cluster_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_cluster_config <- eks_update_cluster_config

#' Updates an Amazon EKS cluster to the specified Kubernetes version
#'
#' @description
#' Updates an Amazon EKS cluster to the specified Kubernetes version. Your
#' cluster continues to function during the update. The response output
#' includes an update ID that you can use to track the status of your
#' cluster update with the [`describe_update`][eks_describe_update] API
#' operation.
#' 
#' Cluster updates are asynchronous, and they should finish within a few
#' minutes. During an update, the cluster status moves to `UPDATING` (this
#' status transition is eventually consistent). When the update is complete
#' (either `Failed` or `Successful`), the cluster status moves to `Active`.
#' 
#' If your cluster has managed node groups attached to it, all of your node
#' groups’ Kubernetes versions must match the cluster’s Kubernetes version
#' in order to update the cluster to a new Kubernetes version.
#'
#' @usage
#' eks_update_cluster_version(name, version, clientRequestToken)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to update.
#' @param version &#91;required&#93; The desired Kubernetes version following a successful update.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_version(
#'   name = "string",
#'   version = "string",
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_cluster_version
#'
#' @aliases eks_update_cluster_version
eks_update_cluster_version <- function(name, version, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateClusterVersion",
    http_method = "POST",
    http_path = "/clusters/{name}/updates",
    paginator = list()
  )
  input <- .eks$update_cluster_version_input(name = name, version = version, clientRequestToken = clientRequestToken)
  output <- .eks$update_cluster_version_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_cluster_version <- eks_update_cluster_version

#' Update an EKS Anywhere Subscription
#'
#' @description
#' Update an EKS Anywhere Subscription. Only auto renewal and tags can be
#' updated after subscription creation.
#'
#' @usage
#' eks_update_eks_anywhere_subscription(id, autoRenew, clientRequestToken)
#'
#' @param id &#91;required&#93; 
#' @param autoRenew &#91;required&#93; A boolean indicating whether or not to automatically renew the
#' subscription.
#' @param clientRequestToken Unique, case-sensitive identifier to ensure the idempotency of the
#' request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_eks_anywhere_subscription(
#'   id = "string",
#'   autoRenew = TRUE|FALSE,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_eks_anywhere_subscription
#'
#' @aliases eks_update_eks_anywhere_subscription
eks_update_eks_anywhere_subscription <- function(id, autoRenew, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateEksAnywhereSubscription",
    http_method = "POST",
    http_path = "/eks-anywhere-subscriptions/{id}",
    paginator = list()
  )
  input <- .eks$update_eks_anywhere_subscription_input(id = id, autoRenew = autoRenew, clientRequestToken = clientRequestToken)
  output <- .eks$update_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_eks_anywhere_subscription <- eks_update_eks_anywhere_subscription

#' Updates an Amazon EKS managed node group configuration
#'
#' @description
#' Updates an Amazon EKS managed node group configuration. Your node group
#' continues to function during the update. The response output includes an
#' update ID that you can use to track the status of your node group update
#' with the [`describe_update`][eks_describe_update] API operation.
#' Currently you can update the Kubernetes labels for a node group or the
#' scaling configuration.
#'
#' @usage
#' eks_update_nodegroup_config(clusterName, nodegroupName, labels, taints,
#'   scalingConfig, updateConfig, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that the managed node group resides
#' in.
#' @param nodegroupName &#91;required&#93; The name of the managed node group to update.
#' @param labels The Kubernetes labels to be applied to the nodes in the node group after
#' the update.
#' @param taints The Kubernetes taints to be applied to the nodes in the node group after
#' the update. For more information, see [Node taints on managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html).
#' @param scalingConfig The scaling configuration details for the Auto Scaling group after the
#' update.
#' @param updateConfig The node group update configuration.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_nodegroup_config(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   labels = list(
#'     addOrUpdateLabels = list(
#'       "string"
#'     ),
#'     removeLabels = list(
#'       "string"
#'     )
#'   ),
#'   taints = list(
#'     addOrUpdateTaints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     removeTaints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     )
#'   ),
#'   scalingConfig = list(
#'     minSize = 123,
#'     maxSize = 123,
#'     desiredSize = 123
#'   ),
#'   updateConfig = list(
#'     maxUnavailable = 123,
#'     maxUnavailablePercentage = 123
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_nodegroup_config
#'
#' @aliases eks_update_nodegroup_config
eks_update_nodegroup_config <- function(clusterName, nodegroupName, labels = NULL, taints = NULL, scalingConfig = NULL, updateConfig = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateNodegroupConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}/update-config",
    paginator = list()
  )
  input <- .eks$update_nodegroup_config_input(clusterName = clusterName, nodegroupName = nodegroupName, labels = labels, taints = taints, scalingConfig = scalingConfig, updateConfig = updateConfig, clientRequestToken = clientRequestToken)
  output <- .eks$update_nodegroup_config_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_nodegroup_config <- eks_update_nodegroup_config

#' Updates the Kubernetes version or AMI version of an Amazon EKS managed
#' node group
#'
#' @description
#' Updates the Kubernetes version or AMI version of an Amazon EKS managed
#' node group.
#' 
#' You can update a node group using a launch template only if the node
#' group was originally deployed with a launch template. If you need to
#' update a custom AMI in a node group that was deployed with a launch
#' template, then update your custom AMI, specify the new ID in a new
#' version of the launch template, and then update the node group to the
#' new version of the launch template.
#' 
#' If you update without a launch template, then you can update to the
#' latest available AMI version of a node group's current Kubernetes
#' version by not specifying a Kubernetes version in the request. You can
#' update to the latest AMI version of your cluster's current Kubernetes
#' version by specifying your cluster's Kubernetes version in the request.
#' For information about Linux versions, see [Amazon EKS optimized Amazon
#' Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. For information about Windows versions,
#' see [Amazon EKS optimized Windows AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' You cannot roll back a node group to an earlier Kubernetes version or
#' AMI version.
#' 
#' When a node in a managed node group is terminated due to a scaling
#' action or update, the pods in that node are drained first. Amazon EKS
#' attempts to drain the nodes gracefully and will fail if it is unable to
#' do so. You can `force` the update if Amazon EKS is unable to drain the
#' nodes as a result of a pod disruption budget issue.
#'
#' @usage
#' eks_update_nodegroup_version(clusterName, nodegroupName, version,
#'   releaseVersion, launchTemplate, force, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that is associated with the managed
#' node group to update.
#' @param nodegroupName &#91;required&#93; The name of the managed node group to update.
#' @param version The Kubernetes version to update to. If no version is specified, then
#' the Kubernetes version of the node group does not change. You can
#' specify the Kubernetes version of the cluster to update the node group
#' to the latest AMI version of the cluster's Kubernetes version. If you
#' specify `launchTemplate`, and your launch template uses a custom AMI,
#' then don't specify `version`, or the node group update will fail. For
#' more information about using launch templates with Amazon EKS, see
#' [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param releaseVersion The AMI version of the Amazon EKS optimized AMI to use for the update.
#' By default, the latest available AMI version for the node group's
#' Kubernetes version is used. For information about Linux versions, see
#' [Amazon EKS optimized Amazon Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. Amazon EKS managed node groups support
#' the November 2022 and later releases of the Windows AMIs. For
#' information about Windows versions, see [Amazon EKS optimized Windows
#' AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you specify `launchTemplate`, and your launch template uses a custom
#' AMI, then don't specify `releaseVersion`, or the node group update will
#' fail. For more information about using launch templates with Amazon EKS,
#' see [Launch template
#' support](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param launchTemplate An object representing a node group's launch template specification. You
#' can only update a node group using a launch template if the node group
#' was originally deployed with a launch template.
#' @param force Force the update if the existing node group's pods are unable to be
#' drained due to a pod disruption budget issue. If an update fails because
#' pods could not be drained, you can force the update after it fails to
#' terminate the old node whether or not any pods are running on the node.
#' @param clientRequestToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"ConfigurationValues"|"SecurityGroups"|"Subnets",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_nodegroup_version(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   version = "string",
#'   releaseVersion = "string",
#'   launchTemplate = list(
#'     name = "string",
#'     version = "string",
#'     id = "string"
#'   ),
#'   force = TRUE|FALSE,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_nodegroup_version
#'
#' @aliases eks_update_nodegroup_version
eks_update_nodegroup_version <- function(clusterName, nodegroupName, version = NULL, releaseVersion = NULL, launchTemplate = NULL, force = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateNodegroupVersion",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}/update-version",
    paginator = list()
  )
  input <- .eks$update_nodegroup_version_input(clusterName = clusterName, nodegroupName = nodegroupName, version = version, releaseVersion = releaseVersion, launchTemplate = launchTemplate, force = force, clientRequestToken = clientRequestToken)
  output <- .eks$update_nodegroup_version_output()
  config <- get_config()
  svc <- .eks$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_nodegroup_version <- eks_update_nodegroup_version

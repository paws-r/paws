# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include eks_service.R
NULL

#' Associates an access policy and its scope to an access entry
#'
#' @description
#' Associates an access policy and its scope to an access entry. For more
#' information about associating access policies, see [Associating and
#' disassociating access policies to and from access
#' entries](https://docs.aws.amazon.com/eks/latest/userguide/access-policies.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_associate_access_policy(clusterName, principalArn, policyArn,
#'   accessScope)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM user or role for the
#' `AccessEntry` that you're associating the access policy to.
#' @param policyArn &#91;required&#93; The ARN of the `AccessPolicy` that you're associating. For a list of
#' ARNs, use [`list_access_policies`][eks_list_access_policies].
#' @param accessScope &#91;required&#93; The scope for the `AccessPolicy`. You can scope access policies to an
#' entire cluster or to specific Kubernetes namespaces.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   clusterName = "string",
#'   principalArn = "string",
#'   associatedAccessPolicy = list(
#'     policyArn = "string",
#'     accessScope = list(
#'       type = "cluster"|"namespace",
#'       namespaces = list(
#'         "string"
#'       )
#'     ),
#'     associatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_access_policy(
#'   clusterName = "string",
#'   principalArn = "string",
#'   policyArn = "string",
#'   accessScope = list(
#'     type = "cluster"|"namespace",
#'     namespaces = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_associate_access_policy
#'
#' @aliases eks_associate_access_policy
eks_associate_access_policy <- function(clusterName, principalArn, policyArn, accessScope) {
  op <- new_operation(
    name = "AssociateAccessPolicy",
    http_method = "POST",
    http_path = "/clusters/{name}/access-entries/{principalArn}/access-policies",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$associate_access_policy_input(clusterName = clusterName, principalArn = principalArn, policyArn = policyArn, accessScope = accessScope)
  output <- .eks$associate_access_policy_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$associate_access_policy <- eks_associate_access_policy

#' Associates an encryption configuration to an existing cluster
#'
#' @description
#' Associates an encryption configuration to an existing cluster.
#' 
#' Use this API to enable encryption on existing clusters that don't
#' already have encryption enabled. This allows you to implement a
#' defense-in-depth security strategy without migrating applications to new
#' Amazon EKS clusters.
#'
#' @usage
#' eks_associate_encryption_config(clusterName, encryptionConfig,
#'   clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param encryptionConfig &#91;required&#93; The configuration you are using for encryption.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_encryption_config(
#'   clusterName = "string",
#'   encryptionConfig = list(
#'     list(
#'       resources = list(
#'         "string"
#'       ),
#'       provider = list(
#'         keyArn = "string"
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_associate_encryption_config
#'
#' @aliases eks_associate_encryption_config
eks_associate_encryption_config <- function(clusterName, encryptionConfig, clientRequestToken = NULL) {
  op <- new_operation(
    name = "AssociateEncryptionConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/encryption-config/associate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$associate_encryption_config_input(clusterName = clusterName, encryptionConfig = encryptionConfig, clientRequestToken = clientRequestToken)
  output <- .eks$associate_encryption_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$associate_encryption_config <- eks_associate_encryption_config

#' Associates an identity provider configuration to a cluster
#'
#' @description
#' Associates an identity provider configuration to a cluster.
#' 
#' If you want to authenticate identities using an identity provider, you
#' can create an identity provider configuration and associate it to your
#' cluster. After configuring authentication to your cluster you can create
#' Kubernetes `Role` and `ClusterRole` objects, assign permissions to them,
#' and then bind them to the identities using Kubernetes `RoleBinding` and
#' `ClusterRoleBinding` objects. For more information see [Using RBAC
#' Authorization](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
#' in the Kubernetes documentation.
#'
#' @usage
#' eks_associate_identity_provider_config(clusterName, oidc, tags,
#'   clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param oidc &#91;required&#93; An object representing an OpenID Connect (OIDC) identity provider
#' configuration.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_identity_provider_config(
#'   clusterName = "string",
#'   oidc = list(
#'     identityProviderConfigName = "string",
#'     issuerUrl = "string",
#'     clientId = "string",
#'     usernameClaim = "string",
#'     usernamePrefix = "string",
#'     groupsClaim = "string",
#'     groupsPrefix = "string",
#'     requiredClaims = list(
#'       "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_associate_identity_provider_config
#'
#' @aliases eks_associate_identity_provider_config
eks_associate_identity_provider_config <- function(clusterName, oidc, tags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "AssociateIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/associate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$associate_identity_provider_config_input(clusterName = clusterName, oidc = oidc, tags = tags, clientRequestToken = clientRequestToken)
  output <- .eks$associate_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$associate_identity_provider_config <- eks_associate_identity_provider_config

#' Creates an access entry
#'
#' @description
#' Creates an access entry.
#' 
#' An access entry allows an IAM principal to access your cluster. Access
#' entries can replace the need to maintain entries in the `aws-auth`
#' `ConfigMap` for authentication. You have the following options for
#' authorizing an IAM principal to access Kubernetes objects on your
#' cluster: Kubernetes role-based access control (RBAC), Amazon EKS, or
#' both. Kubernetes RBAC authorization requires you to create and manage
#' Kubernetes `Role`, `ClusterRole`, `RoleBinding`, and
#' `ClusterRoleBinding` objects, in addition to managing access entries. If
#' you use Amazon EKS authorization exclusively, you don't need to create
#' and manage Kubernetes `Role`, `ClusterRole`, `RoleBinding`, and
#' `ClusterRoleBinding` objects.
#' 
#' For more information about access entries, see [Access
#' entries](https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_access_entry(clusterName, principalArn, kubernetesGroups,
#'   tags, clientRequestToken, username, type)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`. You can specify one
#' ARN for each access entry. You can't specify the same ARN in more than
#' one access entry. This value can't be changed after access entry
#' creation.
#' 
#' The valid principals differ depending on the type of the access entry in
#' the `type` field. For `STANDARD` access entries, you can use every IAM
#' principal type. For nodes (`EC2` (for EKS Auto Mode), `EC2_LINUX`,
#' `EC2_WINDOWS`, `FARGATE_LINUX`, and `HYBRID_LINUX`), the only valid ARN
#' is IAM roles. You can't use the STS session principal type with access
#' entries because this is a temporary principal for each session and not a
#' permanent identity that can be assigned permissions.
#' 
#' [IAM best
#' practices](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#bp-users-federation-idp)
#' recommend using IAM roles with temporary credentials, rather than IAM
#' users with long-term credentials.
#' @param kubernetesGroups The value for `name` that you've specified for `kind: Group` as a
#' `subject` in a Kubernetes `RoleBinding` or `ClusterRoleBinding` object.
#' Amazon EKS doesn't confirm that the value for `name` exists in any
#' bindings on your cluster. You can specify one or more names.
#' 
#' Kubernetes authorizes the `principalArn` of the access entry to access
#' any cluster objects that you've specified in a Kubernetes `Role` or
#' `ClusterRole` object that is also specified in a binding's `roleRef`.
#' For more information about creating Kubernetes `RoleBinding`,
#' `ClusterRoleBinding`, `Role`, or `ClusterRole` objects, see [Using RBAC
#' Authorization in the Kubernetes
#' documentation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
#' 
#' If you want Amazon EKS to authorize the `principalArn` (instead of, or
#' in addition to Kubernetes authorizing the `principalArn`), you can
#' associate one or more access policies to the access entry using
#' [`associate_access_policy`][eks_associate_access_policy]. If you
#' associate any access policies, the `principalARN` has all permissions
#' assigned in the associated access policies and all permissions in any
#' Kubernetes `Role` or `ClusterRole` objects that the group names are
#' bound to.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param username The username to authenticate to Kubernetes with. We recommend not
#' specifying a username and letting Amazon EKS specify it for you. For
#' more information about the value Amazon EKS specifies for you, or
#' constraints before specifying your own username, see [Creating access
#' entries](https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries)
#' in the *Amazon EKS User Guide*.
#' @param type The type of the new access entry. Valid values are `STANDARD`,
#' `FARGATE_LINUX`, `EC2_LINUX`, `EC2_WINDOWS`, `EC2` (for EKS Auto Mode),
#' `HYBRID_LINUX`, and `HYPERPOD_LINUX`.
#' 
#' If the `principalArn` is for an IAM role that's used for self-managed
#' Amazon EC2 nodes, specify `EC2_LINUX` or `EC2_WINDOWS`. Amazon EKS
#' grants the necessary permissions to the node for you. If the
#' `principalArn` is for any other purpose, specify `STANDARD`. If you
#' don't specify a value, Amazon EKS sets the value to `STANDARD`. If you
#' have the access mode of the cluster set to `API_AND_CONFIG_MAP`, it's
#' unnecessary to create access entries for IAM roles used with Fargate
#' profiles or managed Amazon EC2 nodes, because Amazon EKS creates entries
#' in the `aws-auth` `ConfigMap` for the roles. You can't change this value
#' once you've created the access entry.
#' 
#' If you set the value to `EC2_LINUX` or `EC2_WINDOWS`, you can't specify
#' values for `kubernetesGroups`, or associate an `AccessPolicy` to the
#' access entry.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessEntry = list(
#'     clusterName = "string",
#'     principalArn = "string",
#'     kubernetesGroups = list(
#'       "string"
#'     ),
#'     accessEntryArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     username = "string",
#'     type = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_access_entry(
#'   clusterName = "string",
#'   principalArn = "string",
#'   kubernetesGroups = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string",
#'   username = "string",
#'   type = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_access_entry
#'
#' @aliases eks_create_access_entry
eks_create_access_entry <- function(clusterName, principalArn, kubernetesGroups = NULL, tags = NULL, clientRequestToken = NULL, username = NULL, type = NULL) {
  op <- new_operation(
    name = "CreateAccessEntry",
    http_method = "POST",
    http_path = "/clusters/{name}/access-entries",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_access_entry_input(clusterName = clusterName, principalArn = principalArn, kubernetesGroups = kubernetesGroups, tags = tags, clientRequestToken = clientRequestToken, username = username, type = type)
  output <- .eks$create_access_entry_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_access_entry <- eks_create_access_entry

#' Creates an Amazon EKS add-on
#'
#' @description
#' Creates an Amazon EKS add-on.
#' 
#' Amazon EKS add-ons help to automate the provisioning and lifecycle
#' management of common operational software for Amazon EKS clusters. For
#' more information, see [Amazon EKS
#' add-ons](https://docs.aws.amazon.com/eks/latest/userguide/eks-add-ons.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_addon(clusterName, addonName, addonVersion,
#'   serviceAccountRoleArn, resolveConflicts, clientRequestToken, tags,
#'   configurationValues, podIdentityAssociations, namespaceConfig)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`describe_addon_versions`][eks_describe_addon_versions].
#' @param addonVersion The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#' @param serviceAccountRoleArn The Amazon Resource Name (ARN) of an existing IAM role to bind to the
#' add-on's service account. The role must be assigned the IAM permissions
#' required by the add-on. If you don't specify an existing IAM role, then
#' the add-on uses the permissions assigned to the node IAM role. For more
#' information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' To specify an existing IAM role, you must have an IAM OpenID Connect
#' (OIDC) provider created for your cluster. For more information, see
#' [Enabling IAM roles for service accounts on your
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)
#' in the *Amazon EKS User Guide*.
#' @param resolveConflicts How to resolve field value conflicts for an Amazon EKS add-on. Conflicts
#' are handled based on the value you choose:
#' 
#' -   **None** – If the self-managed version of the add-on is installed on
#'     your cluster, Amazon EKS doesn't change the value. Creation of the
#'     add-on might fail.
#' 
#' -   **Overwrite** – If the self-managed version of the add-on is
#'     installed on your cluster and the Amazon EKS default value is
#'     different than the existing value, Amazon EKS changes the value to
#'     the Amazon EKS default value.
#' 
#' -   **Preserve** – This is similar to the NONE option. If the
#'     self-managed version of the add-on is installed on your cluster
#'     Amazon EKS doesn't change the add-on resource properties. Creation
#'     of the add-on might fail if conflicts are detected. This option
#'     works differently during the update operation. For more information,
#'     see
#'     [`update_addon`](https://docs.aws.amazon.com/eks/latest/APIReference/API_UpdateAddon.html)
#'     .
#' 
#' If you don't currently have the self-managed version of the add-on
#' installed on your cluster, the Amazon EKS add-on is installed. Amazon
#' EKS sets all values to default values, regardless of the option that you
#' specify.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' @param configurationValues The set of configuration values for the add-on that's created. The
#' values that you provide are validated against the schema returned by
#' [`describe_addon_configuration`][eks_describe_addon_configuration].
#' @param podIdentityAssociations An array of EKS Pod Identity associations to be created. Each
#' association maps a Kubernetes service account to an IAM role.
#' 
#' For more information, see [Attach an IAM Role to an Amazon EKS add-on
#' using EKS Pod
#' Identity](https://docs.aws.amazon.com/eks/latest/userguide/add-ons-iam.html)
#' in the *Amazon EKS User Guide*.
#' @param namespaceConfig The namespace configuration for the addon. If specified, this will
#' override the default namespace for the addon.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound"|"AddonSubscriptionNeeded"|"AddonPermissionFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string",
#'     podIdentityAssociations = list(
#'       "string"
#'     ),
#'     namespaceConfig = list(
#'       namespace = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   addonVersion = "string",
#'   serviceAccountRoleArn = "string",
#'   resolveConflicts = "OVERWRITE"|"NONE"|"PRESERVE",
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   configurationValues = "string",
#'   podIdentityAssociations = list(
#'     list(
#'       serviceAccount = "string",
#'       roleArn = "string"
#'     )
#'   ),
#'   namespaceConfig = list(
#'     namespace = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_addon
#'
#' @aliases eks_create_addon
eks_create_addon <- function(clusterName, addonName, addonVersion = NULL, serviceAccountRoleArn = NULL, resolveConflicts = NULL, clientRequestToken = NULL, tags = NULL, configurationValues = NULL, podIdentityAssociations = NULL, namespaceConfig = NULL) {
  op <- new_operation(
    name = "CreateAddon",
    http_method = "POST",
    http_path = "/clusters/{name}/addons",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_addon_input(clusterName = clusterName, addonName = addonName, addonVersion = addonVersion, serviceAccountRoleArn = serviceAccountRoleArn, resolveConflicts = resolveConflicts, clientRequestToken = clientRequestToken, tags = tags, configurationValues = configurationValues, podIdentityAssociations = podIdentityAssociations, namespaceConfig = namespaceConfig)
  output <- .eks$create_addon_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_addon <- eks_create_addon

#' Creates a managed capability resource for an Amazon EKS cluster
#'
#' @description
#' Creates a managed capability resource for an Amazon EKS cluster.
#' 
#' Capabilities provide fully managed capabilities to build and scale with
#' Kubernetes. When you create a capability, Amazon EKSprovisions and
#' manages the infrastructure required to run the capability outside of
#' your cluster. This approach reduces operational overhead and preserves
#' cluster resources.
#' 
#' You can only create one Capability of each type on a given Amazon EKS
#' cluster. Valid types are Argo CD for declarative GitOps deployment,
#' Amazon Web Services Controllers for Kubernetes (ACK) for resource
#' management, and Kube Resource Orchestrator (KRO) for Kubernetes custom
#' resource orchestration.
#' 
#' For more information, see [EKS
#' Capabilities](https://docs.aws.amazon.com/eks/latest/userguide/capabilities.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_capability(capabilityName, clusterName, clientRequestToken,
#'   type, roleArn, configuration, tags, deletePropagationPolicy)
#'
#' @param capabilityName &#91;required&#93; A unique name for the capability. The name must be unique within your
#' cluster and can contain alphanumeric characters, hyphens, and
#' underscores.
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster where you want to create the
#' capability.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. This token is valid for 24 hours after
#' creation. If you retry a request with the same client request token and
#' the same parameters after the original request has completed
#' successfully, the result of the original request is returned.
#' @param type &#91;required&#93; The type of capability to create. Valid values are:
#' 
#' -   `ACK` – Amazon Web Services Controllers for Kubernetes (ACK), which
#'     lets you manage resources directly from Kubernetes.
#' 
#' -   `ARGOCD` – Argo CD for GitOps-based continuous delivery.
#' 
#' -   `KRO` – Kube Resource Orchestrator (KRO) for composing and managing
#'     custom Kubernetes resources.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role that the capability uses
#' to interact with Amazon Web Services services. This role must have a
#' trust policy that allows the EKS service principal to assume it, and it
#' must have the necessary permissions for the capability type you're
#' creating.
#' 
#' For ACK capabilities, the role needs permissions to manage the resources
#' you want to control through Kubernetes. For Argo CD capabilities, the
#' role needs permissions to access Git repositories and Secrets Manager.
#' For KRO capabilities, the role needs permissions based on the resources
#' you'll be orchestrating.
#' @param configuration The configuration settings for the capability. The structure of this
#' object varies depending on the capability type. For Argo CD
#' capabilities, you can configure IAM Identity CenterIAM; Identity Center
#' integration, RBAC role mappings, and network access settings.
#' @param tags 
#' @param deletePropagationPolicy &#91;required&#93; Specifies how Kubernetes resources managed by the capability should be
#' handled when the capability is deleted. Currently, the only supported
#' value is `RETAIN` which retains all Kubernetes resources managed by the
#' capability when the capability is deleted.
#' 
#' Because resources are retained, all Kubernetes resources created by the
#' capability should be deleted from the cluster before deleting the
#' capability itself. After the capability is deleted, these resources
#' become difficult to manage because the controller is no longer
#' available.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   capability = list(
#'     capabilityName = "string",
#'     arn = "string",
#'     clusterName = "string",
#'     type = "ACK"|"KRO"|"ARGOCD",
#'     roleArn = "string",
#'     status = "CREATING"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"ACTIVE"|"DEGRADED",
#'     version = "string",
#'     configuration = list(
#'       argoCd = list(
#'         namespace = "string",
#'         awsIdc = list(
#'           idcInstanceArn = "string",
#'           idcRegion = "string",
#'           idcManagedApplicationArn = "string"
#'         ),
#'         rbacRoleMappings = list(
#'           list(
#'             role = "ADMIN"|"EDITOR"|"VIEWER",
#'             identities = list(
#'               list(
#'                 id = "string",
#'                 type = "SSO_USER"|"SSO_GROUP"
#'               )
#'             )
#'           )
#'         ),
#'         networkAccess = list(
#'           vpceIds = list(
#'             "string"
#'           )
#'         ),
#'         serverUrl = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     deletePropagationPolicy = "RETAIN"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_capability(
#'   capabilityName = "string",
#'   clusterName = "string",
#'   clientRequestToken = "string",
#'   type = "ACK"|"KRO"|"ARGOCD",
#'   roleArn = "string",
#'   configuration = list(
#'     argoCd = list(
#'       namespace = "string",
#'       awsIdc = list(
#'         idcInstanceArn = "string",
#'         idcRegion = "string"
#'       ),
#'       rbacRoleMappings = list(
#'         list(
#'           role = "ADMIN"|"EDITOR"|"VIEWER",
#'           identities = list(
#'             list(
#'               id = "string",
#'               type = "SSO_USER"|"SSO_GROUP"
#'             )
#'           )
#'         )
#'       ),
#'       networkAccess = list(
#'         vpceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   deletePropagationPolicy = "RETAIN"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_capability
#'
#' @aliases eks_create_capability
eks_create_capability <- function(capabilityName, clusterName, clientRequestToken = NULL, type, roleArn, configuration = NULL, tags = NULL, deletePropagationPolicy) {
  op <- new_operation(
    name = "CreateCapability",
    http_method = "POST",
    http_path = "/clusters/{name}/capabilities",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_capability_input(capabilityName = capabilityName, clusterName = clusterName, clientRequestToken = clientRequestToken, type = type, roleArn = roleArn, configuration = configuration, tags = tags, deletePropagationPolicy = deletePropagationPolicy)
  output <- .eks$create_capability_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_capability <- eks_create_capability

#' Creates an Amazon EKS control plane
#'
#' @description
#' Creates an Amazon EKS control plane.
#' 
#' The Amazon EKS control plane consists of control plane instances that
#' run the Kubernetes software, such as `etcd` and the API server. The
#' control plane runs in an account managed by Amazon Web Services, and the
#' Kubernetes API is exposed by the Amazon EKS API server endpoint. Each
#' Amazon EKS cluster control plane is single tenant and unique. It runs on
#' its own set of Amazon EC2 instances.
#' 
#' The cluster control plane is provisioned across multiple Availability
#' Zones and fronted by an ELB Network Load Balancer. Amazon EKS also
#' provisions elastic network interfaces in your VPC subnets to provide
#' connectivity from the control plane instances to the nodes (for example,
#' to support `kubectl exec`, `logs`, and `proxy` data flows).
#' 
#' Amazon EKS nodes run in your Amazon Web Services account and connect to
#' your cluster's control plane over the Kubernetes API server endpoint and
#' a certificate file that is created for your cluster.
#' 
#' You can use the `endpointPublicAccess` and `endpointPrivateAccess`
#' parameters to enable or disable public and private access to your
#' cluster's Kubernetes API server endpoint. By default, public access is
#' enabled, and private access is disabled. The endpoint domain name and IP
#' address family depends on the value of the `ipFamily` for the cluster.
#' For more information, see [Amazon EKS Cluster Endpoint Access
#' Control](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html)
#' in the *Amazon EKS User Guide* .
#' 
#' You can use the `logging` parameter to enable or disable exporting the
#' Kubernetes control plane logs for your cluster to CloudWatch Logs. By
#' default, cluster control plane logs aren't exported to CloudWatch Logs.
#' For more information, see [Amazon EKS Cluster Control Plane
#' Logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' 
#' In most cases, it takes several minutes to create a cluster. After you
#' create an Amazon EKS cluster, you must configure your Kubernetes tooling
#' to communicate with the API server and launch nodes into your cluster.
#' For more information, see [Allowing users to access your
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/cluster-auth.html)
#' and [Launching Amazon EKS
#' nodes](https://docs.aws.amazon.com/eks/latest/userguide/launch-workers.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_cluster(name, version, roleArn, resourcesVpcConfig,
#'   kubernetesNetworkConfig, logging, clientRequestToken, tags,
#'   encryptionConfig, outpostConfig, accessConfig,
#'   bootstrapSelfManagedAddons, upgradePolicy, zonalShiftConfig,
#'   remoteNetworkConfig, computeConfig, storageConfig, deletionProtection,
#'   controlPlaneScalingConfig)
#'
#' @param name &#91;required&#93; The unique name to give to your cluster. The name can contain only
#' alphanumeric characters (case-sensitive), hyphens, and underscores. It
#' must start with an alphanumeric character and can't be longer than 100
#' characters. The name must be unique within the Amazon Web Services
#' Region and Amazon Web Services account that you're creating the cluster
#' in.
#' @param version The desired Kubernetes version for your cluster. If you don't specify a
#' value here, the default version available in Amazon EKS is used.
#' 
#' The default version might not be the latest version available.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role that provides permissions
#' for the Kubernetes control plane to make calls to Amazon Web Services
#' API operations on your behalf. For more information, see [Amazon EKS
#' Service IAM
#' Role](https://docs.aws.amazon.com/eks/latest/userguide/cluster-iam-role.html)
#' in the *Amazon EKS User Guide* .
#' @param resourcesVpcConfig &#91;required&#93; The VPC configuration that's used by the cluster control plane. Amazon
#' EKS VPC resources have specific requirements to work properly with
#' Kubernetes. For more information, see [Cluster VPC
#' Considerations](https://docs.aws.amazon.com/eks/latest/userguide/network-reqs.html)
#' and [Cluster Security Group
#' Considerations](https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html)
#' in the *Amazon EKS User Guide*. You must specify at least two subnets.
#' You can specify up to five security groups. However, we recommend that
#' you use a dedicated security group for your cluster control plane.
#' @param kubernetesNetworkConfig The Kubernetes network configuration for the cluster.
#' @param logging Enable or disable exporting the Kubernetes control plane logs for your
#' cluster to CloudWatch Logs . By default, cluster control plane logs
#' aren't exported to CloudWatch Logs . For more information, see [Amazon
#' EKS Cluster control plane
#' logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' @param encryptionConfig The encryption configuration for the cluster.
#' @param outpostConfig An object representing the configuration of your local Amazon EKS
#' cluster on an Amazon Web Services Outpost. Before creating a local
#' cluster on an Outpost, review [Local clusters for Amazon EKS on Amazon
#' Web Services
#' Outposts](https://docs.aws.amazon.com/eks/latest/userguide/eks-outposts-local-cluster-overview.html)
#' in the *Amazon EKS User Guide*. This object isn't available for creating
#' Amazon EKS clusters on the Amazon Web Services cloud.
#' @param accessConfig The access configuration for the cluster.
#' @param bootstrapSelfManagedAddons If you set this value to `False` when creating a cluster, the default
#' networking add-ons will not be installed.
#' 
#' The default networking add-ons include `vpc-cni`, `coredns`, and
#' `kube-proxy`.
#' 
#' Use this option when you plan to install third-party alternative add-ons
#' or self-manage the default networking add-ons.
#' @param upgradePolicy New clusters, by default, have extended support enabled. You can disable
#' extended support when creating a cluster by setting this value to
#' `STANDARD`.
#' @param zonalShiftConfig Enable or disable ARC zonal shift for the cluster. If zonal shift is
#' enabled, Amazon Web Services configures zonal autoshift for the cluster.
#' 
#' Zonal shift is a feature of Amazon Application Recovery Controller
#' (ARC). ARC zonal shift is designed to be a temporary measure that allows
#' you to move traffic for a resource away from an impaired AZ until the
#' zonal shift expires or you cancel it. You can extend the zonal shift if
#' necessary.
#' 
#' You can start a zonal shift for an Amazon EKS cluster, or you can allow
#' Amazon Web Services to do it for you by enabling *zonal autoshift*. This
#' shift updates the flow of east-to-west network traffic in your cluster
#' to only consider network endpoints for Pods running on worker nodes in
#' healthy AZs. Additionally, any ALB or NLB handling ingress traffic for
#' applications in your Amazon EKS cluster will automatically route traffic
#' to targets in the healthy AZs. For more information about zonal shift in
#' EKS, see [Learn about Amazon Application Recovery Controller (ARC) Zonal
#' Shift in Amazon
#' EKS](https://docs.aws.amazon.com/eks/latest/userguide/zone-shift.html)
#' in the *Amazon EKS User Guide* .
#' @param remoteNetworkConfig The configuration in the cluster for EKS Hybrid Nodes. You can add,
#' change, or remove this configuration after the cluster is created.
#' @param computeConfig Enable or disable the compute capability of EKS Auto Mode when creating
#' your EKS Auto Mode cluster. If the compute capability is enabled, EKS
#' Auto Mode will create and delete EC2 Managed Instances in your Amazon
#' Web Services account
#' @param storageConfig Enable or disable the block storage capability of EKS Auto Mode when
#' creating your EKS Auto Mode cluster. If the block storage capability is
#' enabled, EKS Auto Mode will create and delete EBS volumes in your Amazon
#' Web Services account.
#' @param deletionProtection Indicates whether to enable deletion protection for the cluster. When
#' enabled, the cluster cannot be deleted unless deletion protection is
#' first disabled. This helps prevent accidental cluster deletion. Default
#' value is `false`.
#' @param controlPlaneScalingConfig The control plane scaling tier configuration. For more information, see
#' EKS Provisioned Control Plane in the Amazon EKS User Guide.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6",
#'       elasticLoadBalancing = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     ),
#'     accessConfig = list(
#'       bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'       authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'     ),
#'     upgradePolicy = list(
#'       supportType = "STANDARD"|"EXTENDED"
#'     ),
#'     zonalShiftConfig = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     remoteNetworkConfig = list(
#'       remoteNodeNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       remotePodNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     computeConfig = list(
#'       enabled = TRUE|FALSE,
#'       nodePools = list(
#'         "string"
#'       ),
#'       nodeRoleArn = "string"
#'     ),
#'     storageConfig = list(
#'       blockStorage = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     deletionProtection = TRUE|FALSE,
#'     controlPlaneScalingConfig = list(
#'       tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_cluster(
#'   name = "string",
#'   version = "string",
#'   roleArn = "string",
#'   resourcesVpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     ),
#'     endpointPublicAccess = TRUE|FALSE,
#'     endpointPrivateAccess = TRUE|FALSE,
#'     publicAccessCidrs = list(
#'       "string"
#'     )
#'   ),
#'   kubernetesNetworkConfig = list(
#'     serviceIpv4Cidr = "string",
#'     ipFamily = "ipv4"|"ipv6",
#'     elasticLoadBalancing = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   logging = list(
#'     clusterLogging = list(
#'       list(
#'         types = list(
#'           "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'         ),
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   encryptionConfig = list(
#'     list(
#'       resources = list(
#'         "string"
#'       ),
#'       provider = list(
#'         keyArn = "string"
#'       )
#'     )
#'   ),
#'   outpostConfig = list(
#'     outpostArns = list(
#'       "string"
#'     ),
#'     controlPlaneInstanceType = "string",
#'     controlPlanePlacement = list(
#'       groupName = "string"
#'     )
#'   ),
#'   accessConfig = list(
#'     bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'     authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'   ),
#'   bootstrapSelfManagedAddons = TRUE|FALSE,
#'   upgradePolicy = list(
#'     supportType = "STANDARD"|"EXTENDED"
#'   ),
#'   zonalShiftConfig = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   remoteNetworkConfig = list(
#'     remoteNodeNetworks = list(
#'       list(
#'         cidrs = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     remotePodNetworks = list(
#'       list(
#'         cidrs = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   computeConfig = list(
#'     enabled = TRUE|FALSE,
#'     nodePools = list(
#'       "string"
#'     ),
#'     nodeRoleArn = "string"
#'   ),
#'   storageConfig = list(
#'     blockStorage = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   deletionProtection = TRUE|FALSE,
#'   controlPlaneScalingConfig = list(
#'     tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates an Amazon EKS cluster called prod.
#' svc$create_cluster(
#'   version = "1.10",
#'   name = "prod",
#'   clientRequestToken = "1d2129a1-3d38-460a-9756-e5b91fddb951",
#'   resourcesVpcConfig = list(
#'     securityGroupIds = list(
#'       "sg-6979fe18"
#'     ),
#'     subnetIds = list(
#'       "subnet-6782e71e",
#'       "subnet-e7e761ac"
#'     )
#'   ),
#'   roleArn = "arn:aws:iam::012345678910:role/eks-service-role-AWSServiceRole..."
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_create_cluster
#'
#' @aliases eks_create_cluster
eks_create_cluster <- function(name, version = NULL, roleArn, resourcesVpcConfig, kubernetesNetworkConfig = NULL, logging = NULL, clientRequestToken = NULL, tags = NULL, encryptionConfig = NULL, outpostConfig = NULL, accessConfig = NULL, bootstrapSelfManagedAddons = NULL, upgradePolicy = NULL, zonalShiftConfig = NULL, remoteNetworkConfig = NULL, computeConfig = NULL, storageConfig = NULL, deletionProtection = NULL, controlPlaneScalingConfig = NULL) {
  op <- new_operation(
    name = "CreateCluster",
    http_method = "POST",
    http_path = "/clusters",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_cluster_input(name = name, version = version, roleArn = roleArn, resourcesVpcConfig = resourcesVpcConfig, kubernetesNetworkConfig = kubernetesNetworkConfig, logging = logging, clientRequestToken = clientRequestToken, tags = tags, encryptionConfig = encryptionConfig, outpostConfig = outpostConfig, accessConfig = accessConfig, bootstrapSelfManagedAddons = bootstrapSelfManagedAddons, upgradePolicy = upgradePolicy, zonalShiftConfig = zonalShiftConfig, remoteNetworkConfig = remoteNetworkConfig, computeConfig = computeConfig, storageConfig = storageConfig, deletionProtection = deletionProtection, controlPlaneScalingConfig = controlPlaneScalingConfig)
  output <- .eks$create_cluster_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_cluster <- eks_create_cluster

#' Creates an EKS Anywhere subscription
#'
#' @description
#' Creates an EKS Anywhere subscription. When a subscription is created, it
#' is a contract agreement for the length of the term specified in the
#' request. Licenses that are used to validate support are provisioned in
#' Amazon Web Services License Manager and the caller account is granted
#' access to EKS Anywhere Curated Packages.
#'
#' @usage
#' eks_create_eks_anywhere_subscription(name, term, licenseQuantity,
#'   licenseType, autoRenew, clientRequestToken, tags)
#'
#' @param name &#91;required&#93; The unique name for your subscription. It must be unique in your Amazon
#' Web Services account in the Amazon Web Services Region you're creating
#' the subscription in. The name can contain only alphanumeric characters
#' (case-sensitive), hyphens, and underscores. It must start with an
#' alphabetic character and can't be longer than 100 characters.
#' @param term &#91;required&#93; An object representing the term duration and term unit type of your
#' subscription. This determines the term length of your subscription.
#' Valid values are MONTHS for term unit and 12 or 36 for term duration,
#' indicating a 12 month or 36 month subscription. This value cannot be
#' changed after creating the subscription.
#' @param licenseQuantity The number of licenses to purchase with the subscription. Valid values
#' are between 1 and 100. This value can't be changed after creating the
#' subscription.
#' @param licenseType The license type for all licenses in the subscription. Valid value is
#' CLUSTER. With the CLUSTER license type, each license covers support for
#' a single EKS Anywhere cluster.
#' @param autoRenew A boolean indicating whether the subscription auto renews at the end of
#' the term.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags The metadata for a subscription to assist with categorization and
#' organization. Each tag consists of a key and an optional value.
#' Subscription tags don't propagate to any other resources associated with
#' the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     licenses = list(
#'       list(
#'         id = "string",
#'         token = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_eks_anywhere_subscription(
#'   name = "string",
#'   term = list(
#'     duration = 123,
#'     unit = "MONTHS"
#'   ),
#'   licenseQuantity = 123,
#'   licenseType = "Cluster",
#'   autoRenew = TRUE|FALSE,
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_eks_anywhere_subscription
#'
#' @aliases eks_create_eks_anywhere_subscription
eks_create_eks_anywhere_subscription <- function(name, term, licenseQuantity = NULL, licenseType = NULL, autoRenew = NULL, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateEksAnywhereSubscription",
    http_method = "POST",
    http_path = "/eks-anywhere-subscriptions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_eks_anywhere_subscription_input(name = name, term = term, licenseQuantity = licenseQuantity, licenseType = licenseType, autoRenew = autoRenew, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$create_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_eks_anywhere_subscription <- eks_create_eks_anywhere_subscription

#' Creates an Fargate profile for your Amazon EKS cluster
#'
#' @description
#' Creates an Fargate profile for your Amazon EKS cluster. You must have at
#' least one Fargate profile in a cluster to be able to run pods on
#' Fargate.
#' 
#' The Fargate profile allows an administrator to declare which pods run on
#' Fargate and specify which pods run on which Fargate profile. This
#' declaration is done through the profile's selectors. Each profile can
#' have up to five selectors that contain a namespace and labels. A
#' namespace is required for every selector. The label field consists of
#' multiple optional key-value pairs. Pods that match the selectors are
#' scheduled on Fargate. If a to-be-scheduled pod matches any of the
#' selectors in the Fargate profile, then that pod is run on Fargate.
#' 
#' When you create a Fargate profile, you must specify a pod execution role
#' to use with the pods that are scheduled with the profile. This role is
#' added to the cluster's Kubernetes [Role Based Access
#' Control](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)
#' (RBAC) for authorization so that the `kubelet` that is running on the
#' Fargate infrastructure can register with your Amazon EKS cluster so that
#' it can appear in your cluster as a node. The pod execution role also
#' provides IAM permissions to the Fargate infrastructure to allow read
#' access to Amazon ECR image repositories. For more information, see [Pod
#' Execution
#' Role](https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' Fargate profiles are immutable. However, you can create a new updated
#' profile to replace an existing profile and then delete the original
#' after the updated profile has finished creating.
#' 
#' If any Fargate profiles in a cluster are in the `DELETING` status, you
#' must wait for that Fargate profile to finish deleting before you can
#' create any other profiles in that cluster.
#' 
#' For more information, see [Fargate
#' profile](https://docs.aws.amazon.com/eks/latest/userguide/fargate-profile.html)
#' in the *Amazon EKS User Guide*.
#'
#' @usage
#' eks_create_fargate_profile(fargateProfileName, clusterName,
#'   podExecutionRoleArn, subnets, selectors, clientRequestToken, tags)
#'
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile.
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param podExecutionRoleArn &#91;required&#93; The Amazon Resource Name (ARN) of the `Pod` execution role to use for a
#' `Pod` that matches the selectors in the Fargate profile. The `Pod`
#' execution role allows Fargate infrastructure to register with your
#' cluster as a node, and it provides read access to Amazon ECR image
#' repositories. For more information, see [`Pod` execution
#' role](https://docs.aws.amazon.com/eks/latest/userguide/pod-execution-role.html)
#' in the *Amazon EKS User Guide*.
#' @param subnets The IDs of subnets to launch a `Pod` into. A `Pod` running on Fargate
#' isn't assigned a public IP address, so only private subnets (with no
#' direct route to an Internet Gateway) are accepted for this parameter.
#' @param selectors The selectors to match for a `Pod` to use this Fargate profile. Each
#' selector must have an associated Kubernetes `namespace`. Optionally, you
#' can also specify `labels` for a `namespace`. You may specify up to five
#' selectors in a Fargate profile.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "PodExecutionRoleAlreadyInUse"|"AccessDenied"|"ClusterUnreachable"|"InternalFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_fargate_profile(
#'   fargateProfileName = "string",
#'   clusterName = "string",
#'   podExecutionRoleArn = "string",
#'   subnets = list(
#'     "string"
#'   ),
#'   selectors = list(
#'     list(
#'       namespace = "string",
#'       labels = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_fargate_profile
#'
#' @aliases eks_create_fargate_profile
eks_create_fargate_profile <- function(fargateProfileName, clusterName, podExecutionRoleArn, subnets = NULL, selectors = NULL, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateFargateProfile",
    http_method = "POST",
    http_path = "/clusters/{name}/fargate-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_fargate_profile_input(fargateProfileName = fargateProfileName, clusterName = clusterName, podExecutionRoleArn = podExecutionRoleArn, subnets = subnets, selectors = selectors, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$create_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_fargate_profile <- eks_create_fargate_profile

#' Creates a managed node group for an Amazon EKS cluster
#'
#' @description
#' Creates a managed node group for an Amazon EKS cluster.
#' 
#' You can only create a node group for your cluster that is equal to the
#' current Kubernetes version for the cluster. All node groups are created
#' with the latest AMI release version for the respective minor Kubernetes
#' version of the cluster, unless you deploy a custom AMI using a launch
#' template.
#' 
#' For later updates, you will only be able to update a node group using a
#' launch template only if it was originally deployed with a launch
#' template. Additionally, the launch template ID or name must match what
#' was used when the node group was created. You can update the launch
#' template version with necessary changes. For more information about
#' using launch templates, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html).
#' 
#' An Amazon EKS managed node group is an Amazon EC2 Amazon EC2 Auto
#' Scaling group and associated Amazon EC2 instances that are managed by
#' Amazon Web Services for an Amazon EKS cluster. For more information, see
#' [Managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html)
#' in the *Amazon EKS User Guide*.
#' 
#' Windows AMI types are only supported for commercial Amazon Web Services
#' Regions that support Windows on Amazon EKS.
#'
#' @usage
#' eks_create_nodegroup(clusterName, nodegroupName, scalingConfig,
#'   diskSize, subnets, instanceTypes, amiType, remoteAccess, nodeRole,
#'   labels, taints, tags, clientRequestToken, launchTemplate, updateConfig,
#'   nodeRepairConfig, capacityType, version, releaseVersion)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param nodegroupName &#91;required&#93; The unique name to give your node group.
#' @param scalingConfig The scaling configuration details for the Auto Scaling group that is
#' created for your node group.
#' @param diskSize The root device disk size (in GiB) for your node group instances. The
#' default disk size is 20 GiB for Linux and Bottlerocket. The default disk
#' size is 50 GiB for Windows. If you specify `launchTemplate`, then don't
#' specify `diskSize`, or the node group deployment will fail. For more
#' information about using launch templates with Amazon EKS, see
#' [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param subnets &#91;required&#93; The subnets to use for the Auto Scaling group that is created for your
#' node group. If you specify `launchTemplate`, then don't specify
#' ` SubnetId ` in your launch template, or the node group deployment will
#' fail. For more information about using launch templates with Amazon EKS,
#' see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param instanceTypes Specify the instance types for a node group. If you specify a GPU
#' instance type, make sure to also specify an applicable GPU AMI type with
#' the `amiType` parameter. If you specify `launchTemplate`, then you can
#' specify zero or one instance type in your launch template *or* you can
#' specify 0-20 instance types for `instanceTypes`. If however, you specify
#' an instance type in your launch template *and* specify any
#' `instanceTypes`, the node group deployment will fail. If you don't
#' specify an instance type in a launch template or for `instanceTypes`,
#' then `t3.medium` is used, by default. If you specify `Spot` for
#' `capacityType`, then we recommend specifying multiple values for
#' `instanceTypes`. For more information, see [Managed node group capacity
#' types](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html#managed-node-group-capacity-types)
#' and [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param amiType The AMI type for your node group. If you specify `launchTemplate`, and
#' your launch template uses a custom AMI, then don't specify `amiType`, or
#' the node group deployment will fail. If your launch template uses a
#' Windows custom AMI, then add `eks:kube-proxy-windows` to your Windows
#' nodes `rolearn` in the `aws-auth` `ConfigMap`. For more information
#' about using launch templates with Amazon EKS, see [Customizing managed
#' nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param remoteAccess The remote access configuration to use with your node group. For Linux,
#' the protocol is SSH. For Windows, the protocol is RDP. If you specify
#' `launchTemplate`, then don't specify `remoteAccess`, or the node group
#' deployment will fail. For more information about using launch templates
#' with Amazon EKS, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param nodeRole &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role to associate with your
#' node group. The Amazon EKS worker node `kubelet` daemon makes calls to
#' Amazon Web Services APIs on your behalf. Nodes receive permissions for
#' these API calls through an IAM instance profile and associated policies.
#' Before you can launch nodes and register them into a cluster, you must
#' create an IAM role for those nodes to use when they are launched. For
#' more information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide* . If you specify `launchTemplate`, then
#' don't specify ` IamInstanceProfile ` in your launch template, or the
#' node group deployment will fail. For more information about using launch
#' templates with Amazon EKS, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param labels The Kubernetes `labels` to apply to the nodes in the node group when
#' they are created.
#' @param taints The Kubernetes taints to be applied to the nodes in the node group. For
#' more information, see [Node taints on managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html).
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param launchTemplate An object representing a node group's launch template specification.
#' When using this object, don't directly specify `instanceTypes`,
#' `diskSize`, or `remoteAccess`. You cannot later specify a different
#' launch template ID or name than what was used to create the node group.
#' 
#' Make sure that the launch template meets the requirements in
#' `launchTemplateSpecification`. Also refer to [Customizing managed nodes
#' with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param updateConfig The node group update configuration.
#' @param nodeRepairConfig The node auto repair configuration for the node group.
#' @param capacityType The capacity type for your node group.
#' @param version The Kubernetes version to use for your managed nodes. By default, the
#' Kubernetes version of the cluster is used, and this is the only accepted
#' specified value. If you specify `launchTemplate`, and your launch
#' template uses a custom AMI, then don't specify `version`, or the node
#' group deployment will fail. For more information about using launch
#' templates with Amazon EKS, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param releaseVersion The AMI version of the Amazon EKS optimized AMI to use with your node
#' group. By default, the latest available AMI version for the node group's
#' current Kubernetes version is used. For information about Linux
#' versions, see [Amazon EKS optimized Amazon Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. Amazon EKS managed node groups support
#' the November 2022 and later releases of the Windows AMIs. For
#' information about Windows versions, see [Amazon EKS optimized Windows
#' AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you specify `launchTemplate`, and your launch template uses a custom
#' AMI, then don't specify `releaseVersion`, or the node group deployment
#' will fail. For more information about using launch templates with Amazon
#' EKS, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT"|"CAPACITY_BLOCK",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_FIPS"|"BOTTLEROCKET_x86_64_FIPS"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64"|"AL2023_x86_64_STANDARD"|"AL2023_ARM_64_STANDARD"|"AL2023_x86_64_NEURON"|"AL2023_x86_64_NVIDIA"|"AL2023_ARM_64_NVIDIA",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive"|"KubernetesLabelInvalid"|"Ec2LaunchTemplateVersionMaxLimitExceeded"|"Ec2InstanceTypeDoesNotExist",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123,
#'       updateStrategy = "DEFAULT"|"MINIMAL"
#'     ),
#'     nodeRepairConfig = list(
#'       enabled = TRUE|FALSE,
#'       maxUnhealthyNodeThresholdCount = 123,
#'       maxUnhealthyNodeThresholdPercentage = 123,
#'       maxParallelNodesRepairedCount = 123,
#'       maxParallelNodesRepairedPercentage = 123,
#'       nodeRepairConfigOverrides = list(
#'         list(
#'           nodeMonitoringCondition = "string",
#'           nodeUnhealthyReason = "string",
#'           minRepairWaitTimeMins = 123,
#'           repairAction = "Replace"|"Reboot"|"NoAction"
#'         )
#'       )
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   scalingConfig = list(
#'     minSize = 123,
#'     maxSize = 123,
#'     desiredSize = 123
#'   ),
#'   diskSize = 123,
#'   subnets = list(
#'     "string"
#'   ),
#'   instanceTypes = list(
#'     "string"
#'   ),
#'   amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_FIPS"|"BOTTLEROCKET_x86_64_FIPS"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64"|"AL2023_x86_64_STANDARD"|"AL2023_ARM_64_STANDARD"|"AL2023_x86_64_NEURON"|"AL2023_x86_64_NVIDIA"|"AL2023_ARM_64_NVIDIA",
#'   remoteAccess = list(
#'     ec2SshKey = "string",
#'     sourceSecurityGroups = list(
#'       "string"
#'     )
#'   ),
#'   nodeRole = "string",
#'   labels = list(
#'     "string"
#'   ),
#'   taints = list(
#'     list(
#'       key = "string",
#'       value = "string",
#'       effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string",
#'   launchTemplate = list(
#'     name = "string",
#'     version = "string",
#'     id = "string"
#'   ),
#'   updateConfig = list(
#'     maxUnavailable = 123,
#'     maxUnavailablePercentage = 123,
#'     updateStrategy = "DEFAULT"|"MINIMAL"
#'   ),
#'   nodeRepairConfig = list(
#'     enabled = TRUE|FALSE,
#'     maxUnhealthyNodeThresholdCount = 123,
#'     maxUnhealthyNodeThresholdPercentage = 123,
#'     maxParallelNodesRepairedCount = 123,
#'     maxParallelNodesRepairedPercentage = 123,
#'     nodeRepairConfigOverrides = list(
#'       list(
#'         nodeMonitoringCondition = "string",
#'         nodeUnhealthyReason = "string",
#'         minRepairWaitTimeMins = 123,
#'         repairAction = "Replace"|"Reboot"|"NoAction"
#'       )
#'     )
#'   ),
#'   capacityType = "ON_DEMAND"|"SPOT"|"CAPACITY_BLOCK",
#'   version = "string",
#'   releaseVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_nodegroup
#'
#' @aliases eks_create_nodegroup
eks_create_nodegroup <- function(clusterName, nodegroupName, scalingConfig = NULL, diskSize = NULL, subnets, instanceTypes = NULL, amiType = NULL, remoteAccess = NULL, nodeRole, labels = NULL, taints = NULL, tags = NULL, clientRequestToken = NULL, launchTemplate = NULL, updateConfig = NULL, nodeRepairConfig = NULL, capacityType = NULL, version = NULL, releaseVersion = NULL) {
  op <- new_operation(
    name = "CreateNodegroup",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName, scalingConfig = scalingConfig, diskSize = diskSize, subnets = subnets, instanceTypes = instanceTypes, amiType = amiType, remoteAccess = remoteAccess, nodeRole = nodeRole, labels = labels, taints = taints, tags = tags, clientRequestToken = clientRequestToken, launchTemplate = launchTemplate, updateConfig = updateConfig, nodeRepairConfig = nodeRepairConfig, capacityType = capacityType, version = version, releaseVersion = releaseVersion)
  output <- .eks$create_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_nodegroup <- eks_create_nodegroup

#' Creates an EKS Pod Identity association between a service account in an
#' Amazon EKS cluster and an IAM role with EKS Pod Identity
#'
#' @description
#' Creates an EKS Pod Identity association between a service account in an
#' Amazon EKS cluster and an IAM role with *EKS Pod Identity*. Use EKS Pod
#' Identity to give temporary IAM credentials to Pods and the credentials
#' are rotated automatically.
#' 
#' Amazon EKS Pod Identity associations provide the ability to manage
#' credentials for your applications, similar to the way that Amazon EC2
#' instance profiles provide credentials to Amazon EC2 instances.
#' 
#' If a Pod uses a service account that has an association, Amazon EKS sets
#' environment variables in the containers of the Pod. The environment
#' variables configure the Amazon Web Services SDKs, including the Command
#' Line Interface, to use the EKS Pod Identity credentials.
#' 
#' EKS Pod Identity is a simpler method than *IAM roles for service
#' accounts*, as this method doesn't use OIDC identity providers.
#' Additionally, you can configure a role for EKS Pod Identity once, and
#' reuse it across clusters.
#' 
#' Similar to Amazon Web Services IAM behavior, EKS Pod Identity
#' associations are eventually consistent, and may take several seconds to
#' be effective after the initial API call returns successfully. You must
#' design your applications to account for these potential delays. We
#' recommend that you don’t include association create/updates in the
#' critical, high-availability code paths of your application. Instead,
#' make changes in a separate initialization or setup routine that you run
#' less frequently.
#' 
#' You can set a *target IAM role* in the same or a different account for
#' advanced scenarios. With a target role, EKS Pod Identity automatically
#' performs two role assumptions in sequence: first assuming the role in
#' the association that is in this account, then using those credentials to
#' assume the target IAM role. This process provides your Pod with
#' temporary credentials that have the permissions defined in the target
#' role, allowing secure access to resources in another Amazon Web Services
#' account.
#'
#' @usage
#' eks_create_pod_identity_association(clusterName, namespace,
#'   serviceAccount, roleArn, clientRequestToken, tags, disableSessionTags,
#'   targetRoleArn)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to create the EKS Pod Identity association in.
#' @param namespace &#91;required&#93; The name of the Kubernetes namespace inside the cluster to create the
#' EKS Pod Identity association in. The service account and the Pods that
#' use the service account must be in this namespace.
#' @param serviceAccount &#91;required&#93; The name of the Kubernetes service account inside the cluster to
#' associate the IAM credentials with.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the IAM role to associate with the
#' service account. The EKS Pod Identity agent manages credentials to
#' assume this role for applications in the containers in the Pods that use
#' this service account.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#' 
#' The following basic restrictions apply to tags:
#' 
#' -   Maximum number of tags per resource – 50
#' 
#' -   For each resource, each tag key must be unique, and each tag key can
#'     have only one value.
#' 
#' -   Maximum key length – 128 Unicode characters in UTF-8
#' 
#' -   Maximum value length – 256 Unicode characters in UTF-8
#' 
#' -   If your tagging schema is used across multiple services and
#'     resources, remember that other services may have restrictions on
#'     allowed characters. Generally allowed characters are: letters,
#'     numbers, and spaces representable in UTF-8, and the following
#'     characters: + - = . _ : / @@.
#' 
#' -   Tag keys and values are case-sensitive.
#' 
#' -   Do not use `aws:`, `AWS:`, or any upper or lowercase combination of
#'     such as a prefix for either keys or values as it is reserved for
#'     Amazon Web Services use. You cannot edit or delete tag keys or
#'     values with this prefix. Tags with this prefix do not count against
#'     your tags per resource limit.
#' @param disableSessionTags Disable the automatic sessions tags that are appended by EKS Pod
#' Identity.
#' 
#' EKS Pod Identity adds a pre-defined set of session tags when it assumes
#' the role. You can use these tags to author a single role that can work
#' across resources by allowing access to Amazon Web Services resources
#' based on matching tags. By default, EKS Pod Identity attaches six tags,
#' including tags for cluster name, namespace, and service account name.
#' For the list of tags added by EKS Pod Identity, see [List of session
#' tags added by EKS Pod
#' Identity](https://docs.aws.amazon.com/eks/latest/userguide/pod-id-abac.html#pod-id-abac-tags)
#' in the *Amazon EKS User Guide*.
#' 
#' Amazon Web Services compresses inline session policies, managed policy
#' ARNs, and session tags into a packed binary format that has a separate
#' limit. If you receive a `PackedPolicyTooLarge` error indicating the
#' packed binary format has exceeded the size limit, you can attempt to
#' reduce the size by disabling the session tags added by EKS Pod Identity.
#' @param targetRoleArn The Amazon Resource Name (ARN) of the target IAM role to associate with
#' the service account. This role is assumed by using the EKS Pod Identity
#' association role, then the credentials for this role are injected into
#' the Pod.
#' 
#' When you run applications on Amazon EKS, your application might need to
#' access Amazon Web Services resources from a different role that exists
#' in the same or different Amazon Web Services account. For example, your
#' application running in “Account A” might need to access resources, such
#' as Amazon S3 buckets in “Account B” or within “Account A” itself. You
#' can create a association to access Amazon Web Services resources in
#' “Account B” by creating two IAM roles: a role in “Account A” and a role
#' in “Account B” (which can be the same or different account), each with
#' the necessary trust and permission policies. After you provide these
#' roles in the *IAM role* and *Target IAM role* fields, EKS will perform
#' role chaining to ensure your application gets the required permissions.
#' This means Role A will assume Role B, allowing your Pods to securely
#' access resources like S3 buckets in the target account.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   association = list(
#'     clusterName = "string",
#'     namespace = "string",
#'     serviceAccount = "string",
#'     roleArn = "string",
#'     associationArn = "string",
#'     associationId = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ownerArn = "string",
#'     disableSessionTags = TRUE|FALSE,
#'     targetRoleArn = "string",
#'     externalId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_pod_identity_association(
#'   clusterName = "string",
#'   namespace = "string",
#'   serviceAccount = "string",
#'   roleArn = "string",
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   disableSessionTags = TRUE|FALSE,
#'   targetRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_create_pod_identity_association
#'
#' @aliases eks_create_pod_identity_association
eks_create_pod_identity_association <- function(clusterName, namespace, serviceAccount, roleArn, clientRequestToken = NULL, tags = NULL, disableSessionTags = NULL, targetRoleArn = NULL) {
  op <- new_operation(
    name = "CreatePodIdentityAssociation",
    http_method = "POST",
    http_path = "/clusters/{name}/pod-identity-associations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$create_pod_identity_association_input(clusterName = clusterName, namespace = namespace, serviceAccount = serviceAccount, roleArn = roleArn, clientRequestToken = clientRequestToken, tags = tags, disableSessionTags = disableSessionTags, targetRoleArn = targetRoleArn)
  output <- .eks$create_pod_identity_association_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$create_pod_identity_association <- eks_create_pod_identity_association

#' Deletes an access entry
#'
#' @description
#' Deletes an access entry.
#' 
#' Deleting an access entry of a type other than `Standard` can cause your
#' cluster to function improperly. If you delete an access entry in error,
#' you can recreate it.
#'
#' @usage
#' eks_delete_access_entry(clusterName, principalArn)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_access_entry(
#'   clusterName = "string",
#'   principalArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_access_entry
#'
#' @aliases eks_delete_access_entry
eks_delete_access_entry <- function(clusterName, principalArn) {
  op <- new_operation(
    name = "DeleteAccessEntry",
    http_method = "DELETE",
    http_path = "/clusters/{name}/access-entries/{principalArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_access_entry_input(clusterName = clusterName, principalArn = principalArn)
  output <- .eks$delete_access_entry_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_access_entry <- eks_delete_access_entry

#' Deletes an Amazon EKS add-on
#'
#' @description
#' Deletes an Amazon EKS add-on.
#' 
#' When you remove an add-on, it's deleted from the cluster. You can always
#' manually start an add-on on the cluster using the Kubernetes API.
#'
#' @usage
#' eks_delete_addon(clusterName, addonName, preserve)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param preserve Specifying this option preserves the add-on software on your cluster but
#' Amazon EKS stops managing any settings for the add-on. If an IAM account
#' is associated with the add-on, it isn't removed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound"|"AddonSubscriptionNeeded"|"AddonPermissionFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string",
#'     podIdentityAssociations = list(
#'       "string"
#'     ),
#'     namespaceConfig = list(
#'       namespace = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   preserve = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_addon
#'
#' @aliases eks_delete_addon
eks_delete_addon <- function(clusterName, addonName, preserve = NULL) {
  op <- new_operation(
    name = "DeleteAddon",
    http_method = "DELETE",
    http_path = "/clusters/{name}/addons/{addonName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_addon_input(clusterName = clusterName, addonName = addonName, preserve = preserve)
  output <- .eks$delete_addon_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_addon <- eks_delete_addon

#' Deletes a managed capability from your Amazon EKS cluster
#'
#' @description
#' Deletes a managed capability from your Amazon EKS cluster. When you
#' delete a capability, Amazon EKS removes the capability infrastructure
#' but retains all resources that were managed by the capability.
#' 
#' Before deleting a capability, you should delete all Kubernetes resources
#' that were created by the capability. After the capability is deleted,
#' these resources become difficult to manage because the controller that
#' managed them is no longer available. To delete resources before removing
#' the capability, use `kubectl delete` or remove them through your GitOps
#' workflow.
#'
#' @usage
#' eks_delete_capability(clusterName, capabilityName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that contains the capability you want
#' to delete.
#' @param capabilityName &#91;required&#93; The name of the capability to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   capability = list(
#'     capabilityName = "string",
#'     arn = "string",
#'     clusterName = "string",
#'     type = "ACK"|"KRO"|"ARGOCD",
#'     roleArn = "string",
#'     status = "CREATING"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"ACTIVE"|"DEGRADED",
#'     version = "string",
#'     configuration = list(
#'       argoCd = list(
#'         namespace = "string",
#'         awsIdc = list(
#'           idcInstanceArn = "string",
#'           idcRegion = "string",
#'           idcManagedApplicationArn = "string"
#'         ),
#'         rbacRoleMappings = list(
#'           list(
#'             role = "ADMIN"|"EDITOR"|"VIEWER",
#'             identities = list(
#'               list(
#'                 id = "string",
#'                 type = "SSO_USER"|"SSO_GROUP"
#'               )
#'             )
#'           )
#'         ),
#'         networkAccess = list(
#'           vpceIds = list(
#'             "string"
#'           )
#'         ),
#'         serverUrl = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     deletePropagationPolicy = "RETAIN"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_capability(
#'   clusterName = "string",
#'   capabilityName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_capability
#'
#' @aliases eks_delete_capability
eks_delete_capability <- function(clusterName, capabilityName) {
  op <- new_operation(
    name = "DeleteCapability",
    http_method = "DELETE",
    http_path = "/clusters/{name}/capabilities/{capabilityName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_capability_input(clusterName = clusterName, capabilityName = capabilityName)
  output <- .eks$delete_capability_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_capability <- eks_delete_capability

#' Deletes an Amazon EKS cluster control plane
#'
#' @description
#' Deletes an Amazon EKS cluster control plane.
#' 
#' If you have active services in your cluster that are associated with a
#' load balancer, you must delete those services before deleting the
#' cluster so that the load balancers are deleted properly. Otherwise, you
#' can have orphaned resources in your VPC that prevent you from being able
#' to delete the VPC. For more information, see [Deleting a
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you have managed node groups or Fargate profiles attached to the
#' cluster, you must delete them first. For more information, see
#' `DeleteNodgroup` and
#' [`delete_fargate_profile`][eks_delete_fargate_profile].
#'
#' @usage
#' eks_delete_cluster(name)
#'
#' @param name &#91;required&#93; The name of the cluster to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6",
#'       elasticLoadBalancing = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     ),
#'     accessConfig = list(
#'       bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'       authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'     ),
#'     upgradePolicy = list(
#'       supportType = "STANDARD"|"EXTENDED"
#'     ),
#'     zonalShiftConfig = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     remoteNetworkConfig = list(
#'       remoteNodeNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       remotePodNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     computeConfig = list(
#'       enabled = TRUE|FALSE,
#'       nodePools = list(
#'         "string"
#'       ),
#'       nodeRoleArn = "string"
#'     ),
#'     storageConfig = list(
#'       blockStorage = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     deletionProtection = TRUE|FALSE,
#'     controlPlaneScalingConfig = list(
#'       tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command deletes a cluster named `devel` in your default
#' # region.
#' svc$delete_cluster(
#'   name = "devel"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_delete_cluster
#'
#' @aliases eks_delete_cluster
eks_delete_cluster <- function(name) {
  op <- new_operation(
    name = "DeleteCluster",
    http_method = "DELETE",
    http_path = "/clusters/{name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_cluster_input(name = name)
  output <- .eks$delete_cluster_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_cluster <- eks_delete_cluster

#' Deletes an expired or inactive subscription
#'
#' @description
#' Deletes an expired or inactive subscription. Deleting inactive
#' subscriptions removes them from the Amazon Web Services Management
#' Console view and from list/describe API responses. Subscriptions can
#' only be cancelled within 7 days of creation and are cancelled by
#' creating a ticket in the Amazon Web Services Support Center.
#'
#' @usage
#' eks_delete_eks_anywhere_subscription(id)
#'
#' @param id &#91;required&#93; The ID of the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     licenses = list(
#'       list(
#'         id = "string",
#'         token = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_eks_anywhere_subscription(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_eks_anywhere_subscription
#'
#' @aliases eks_delete_eks_anywhere_subscription
eks_delete_eks_anywhere_subscription <- function(id) {
  op <- new_operation(
    name = "DeleteEksAnywhereSubscription",
    http_method = "DELETE",
    http_path = "/eks-anywhere-subscriptions/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_eks_anywhere_subscription_input(id = id)
  output <- .eks$delete_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_eks_anywhere_subscription <- eks_delete_eks_anywhere_subscription

#' Deletes an Fargate profile
#'
#' @description
#' Deletes an Fargate profile.
#' 
#' When you delete a Fargate profile, any `Pod` running on Fargate that was
#' created with the profile is deleted. If the `Pod` matches another
#' Fargate profile, then it is scheduled on Fargate with that profile. If
#' it no longer matches any Fargate profiles, then it's not scheduled on
#' Fargate and may remain in a pending state.
#' 
#' Only one Fargate profile in a cluster can be in the `DELETING` status at
#' a time. You must wait for a Fargate profile to finish deleting before
#' you can delete any other profiles in that cluster.
#'
#' @usage
#' eks_delete_fargate_profile(clusterName, fargateProfileName)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "PodExecutionRoleAlreadyInUse"|"AccessDenied"|"ClusterUnreachable"|"InternalFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_fargate_profile(
#'   clusterName = "string",
#'   fargateProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_fargate_profile
#'
#' @aliases eks_delete_fargate_profile
eks_delete_fargate_profile <- function(clusterName, fargateProfileName) {
  op <- new_operation(
    name = "DeleteFargateProfile",
    http_method = "DELETE",
    http_path = "/clusters/{name}/fargate-profiles/{fargateProfileName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_fargate_profile_input(clusterName = clusterName, fargateProfileName = fargateProfileName)
  output <- .eks$delete_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_fargate_profile <- eks_delete_fargate_profile

#' Deletes a managed node group
#'
#' @description
#' Deletes a managed node group.
#'
#' @usage
#' eks_delete_nodegroup(clusterName, nodegroupName)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param nodegroupName &#91;required&#93; The name of the node group to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT"|"CAPACITY_BLOCK",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_FIPS"|"BOTTLEROCKET_x86_64_FIPS"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64"|"AL2023_x86_64_STANDARD"|"AL2023_ARM_64_STANDARD"|"AL2023_x86_64_NEURON"|"AL2023_x86_64_NVIDIA"|"AL2023_ARM_64_NVIDIA",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive"|"KubernetesLabelInvalid"|"Ec2LaunchTemplateVersionMaxLimitExceeded"|"Ec2InstanceTypeDoesNotExist",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123,
#'       updateStrategy = "DEFAULT"|"MINIMAL"
#'     ),
#'     nodeRepairConfig = list(
#'       enabled = TRUE|FALSE,
#'       maxUnhealthyNodeThresholdCount = 123,
#'       maxUnhealthyNodeThresholdPercentage = 123,
#'       maxParallelNodesRepairedCount = 123,
#'       maxParallelNodesRepairedPercentage = 123,
#'       nodeRepairConfigOverrides = list(
#'         list(
#'           nodeMonitoringCondition = "string",
#'           nodeUnhealthyReason = "string",
#'           minRepairWaitTimeMins = 123,
#'           repairAction = "Replace"|"Reboot"|"NoAction"
#'         )
#'       )
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_nodegroup
#'
#' @aliases eks_delete_nodegroup
eks_delete_nodegroup <- function(clusterName, nodegroupName) {
  op <- new_operation(
    name = "DeleteNodegroup",
    http_method = "DELETE",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName)
  output <- .eks$delete_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_nodegroup <- eks_delete_nodegroup

#' Deletes a EKS Pod Identity association
#'
#' @description
#' Deletes a EKS Pod Identity association.
#' 
#' The temporary Amazon Web Services credentials from the previous IAM role
#' session might still be valid until the session expiry. If you need to
#' immediately revoke the temporary session credentials, then go to the
#' role in the IAM console.
#'
#' @usage
#' eks_delete_pod_identity_association(clusterName, associationId)
#'
#' @param clusterName &#91;required&#93; The cluster name that
#' @param associationId &#91;required&#93; The ID of the association to be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   association = list(
#'     clusterName = "string",
#'     namespace = "string",
#'     serviceAccount = "string",
#'     roleArn = "string",
#'     associationArn = "string",
#'     associationId = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ownerArn = "string",
#'     disableSessionTags = TRUE|FALSE,
#'     targetRoleArn = "string",
#'     externalId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_pod_identity_association(
#'   clusterName = "string",
#'   associationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_delete_pod_identity_association
#'
#' @aliases eks_delete_pod_identity_association
eks_delete_pod_identity_association <- function(clusterName, associationId) {
  op <- new_operation(
    name = "DeletePodIdentityAssociation",
    http_method = "DELETE",
    http_path = "/clusters/{name}/pod-identity-associations/{associationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$delete_pod_identity_association_input(clusterName = clusterName, associationId = associationId)
  output <- .eks$delete_pod_identity_association_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$delete_pod_identity_association <- eks_delete_pod_identity_association

#' Deregisters a connected cluster to remove it from the Amazon EKS control
#' plane
#'
#' @description
#' Deregisters a connected cluster to remove it from the Amazon EKS control
#' plane.
#' 
#' A connected cluster is a Kubernetes cluster that you've connected to
#' your control plane using the [Amazon EKS
#' Connector](https://docs.aws.amazon.com/eks/latest/userguide/eks-connector.html).
#'
#' @usage
#' eks_deregister_cluster(name)
#'
#' @param name &#91;required&#93; The name of the connected cluster to deregister.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6",
#'       elasticLoadBalancing = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     ),
#'     accessConfig = list(
#'       bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'       authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'     ),
#'     upgradePolicy = list(
#'       supportType = "STANDARD"|"EXTENDED"
#'     ),
#'     zonalShiftConfig = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     remoteNetworkConfig = list(
#'       remoteNodeNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       remotePodNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     computeConfig = list(
#'       enabled = TRUE|FALSE,
#'       nodePools = list(
#'         "string"
#'       ),
#'       nodeRoleArn = "string"
#'     ),
#'     storageConfig = list(
#'       blockStorage = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     deletionProtection = TRUE|FALSE,
#'     controlPlaneScalingConfig = list(
#'       tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$deregister_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_deregister_cluster
#'
#' @aliases eks_deregister_cluster
eks_deregister_cluster <- function(name) {
  op <- new_operation(
    name = "DeregisterCluster",
    http_method = "DELETE",
    http_path = "/cluster-registrations/{name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$deregister_cluster_input(name = name)
  output <- .eks$deregister_cluster_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$deregister_cluster <- eks_deregister_cluster

#' Describes an access entry
#'
#' @description
#' Describes an access entry.
#'
#' @usage
#' eks_describe_access_entry(clusterName, principalArn)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessEntry = list(
#'     clusterName = "string",
#'     principalArn = "string",
#'     kubernetesGroups = list(
#'       "string"
#'     ),
#'     accessEntryArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     username = "string",
#'     type = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_access_entry(
#'   clusterName = "string",
#'   principalArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_access_entry
#'
#' @aliases eks_describe_access_entry
eks_describe_access_entry <- function(clusterName, principalArn) {
  op <- new_operation(
    name = "DescribeAccessEntry",
    http_method = "GET",
    http_path = "/clusters/{name}/access-entries/{principalArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_access_entry_input(clusterName = clusterName, principalArn = principalArn)
  output <- .eks$describe_access_entry_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_access_entry <- eks_describe_access_entry

#' Describes an Amazon EKS add-on
#'
#' @description
#' Describes an Amazon EKS add-on.
#'
#' @usage
#' eks_describe_addon(clusterName, addonName)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addon = list(
#'     addonName = "string",
#'     clusterName = "string",
#'     status = "CREATING"|"ACTIVE"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"DEGRADED"|"UPDATE_FAILED",
#'     addonVersion = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound"|"AddonSubscriptionNeeded"|"AddonPermissionFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     addonArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     serviceAccountRoleArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     publisher = "string",
#'     owner = "string",
#'     marketplaceInformation = list(
#'       productId = "string",
#'       productUrl = "string"
#'     ),
#'     configurationValues = "string",
#'     podIdentityAssociations = list(
#'       "string"
#'     ),
#'     namespaceConfig = list(
#'       namespace = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon(
#'   clusterName = "string",
#'   addonName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon
#'
#' @aliases eks_describe_addon
eks_describe_addon <- function(clusterName, addonName) {
  op <- new_operation(
    name = "DescribeAddon",
    http_method = "GET",
    http_path = "/clusters/{name}/addons/{addonName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_addon_input(clusterName = clusterName, addonName = addonName)
  output <- .eks$describe_addon_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon <- eks_describe_addon

#' Returns configuration options
#'
#' @description
#' Returns configuration options.
#'
#' @usage
#' eks_describe_addon_configuration(addonName, addonVersion)
#'
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`describe_addon_versions`][eks_describe_addon_versions].
#' @param addonVersion &#91;required&#93; The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addonName = "string",
#'   addonVersion = "string",
#'   configurationSchema = "string",
#'   podIdentityConfiguration = list(
#'     list(
#'       serviceAccount = "string",
#'       recommendedManagedPolicies = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon_configuration(
#'   addonName = "string",
#'   addonVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon_configuration
#'
#' @aliases eks_describe_addon_configuration
eks_describe_addon_configuration <- function(addonName, addonVersion) {
  op <- new_operation(
    name = "DescribeAddonConfiguration",
    http_method = "GET",
    http_path = "/addons/configuration-schemas",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_addon_configuration_input(addonName = addonName, addonVersion = addonVersion)
  output <- .eks$describe_addon_configuration_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon_configuration <- eks_describe_addon_configuration

#' Describes the versions for an add-on
#'
#' @description
#' Describes the versions for an add-on.
#' 
#' Information such as the Kubernetes versions that you can use the add-on
#' with, the `owner`, `publisher`, and the `type` of the add-on are
#' returned.
#'
#' @usage
#' eks_describe_addon_versions(kubernetesVersion, maxResults, nextToken,
#'   addonName, types, publishers, owners)
#'
#' @param kubernetesVersion The Kubernetes versions that you can use the add-on with.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#' @param addonName The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param types The type of the add-on. For valid `types`, don't specify a value for
#' this property.
#' @param publishers The publisher of the add-on. For valid `publishers`, don't specify a
#' value for this property.
#' @param owners The owner of the add-on. For valid `owners`, don't specify a value for
#' this property.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addons = list(
#'     list(
#'       addonName = "string",
#'       type = "string",
#'       addonVersions = list(
#'         list(
#'           addonVersion = "string",
#'           architecture = list(
#'             "string"
#'           ),
#'           computeTypes = list(
#'             "string"
#'           ),
#'           compatibilities = list(
#'             list(
#'               clusterVersion = "string",
#'               platformVersions = list(
#'                 "string"
#'               ),
#'               defaultVersion = TRUE|FALSE
#'             )
#'           ),
#'           requiresConfiguration = TRUE|FALSE,
#'           requiresIamPermissions = TRUE|FALSE
#'         )
#'       ),
#'       publisher = "string",
#'       owner = "string",
#'       marketplaceInformation = list(
#'         productId = "string",
#'         productUrl = "string"
#'       ),
#'       defaultNamespace = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_addon_versions(
#'   kubernetesVersion = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   addonName = "string",
#'   types = list(
#'     "string"
#'   ),
#'   publishers = list(
#'     "string"
#'   ),
#'   owners = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_addon_versions
#'
#' @aliases eks_describe_addon_versions
eks_describe_addon_versions <- function(kubernetesVersion = NULL, maxResults = NULL, nextToken = NULL, addonName = NULL, types = NULL, publishers = NULL, owners = NULL) {
  op <- new_operation(
    name = "DescribeAddonVersions",
    http_method = "GET",
    http_path = "/addons/supported-versions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "addons"),
    stream_api = FALSE
  )
  input <- .eks$describe_addon_versions_input(kubernetesVersion = kubernetesVersion, maxResults = maxResults, nextToken = nextToken, addonName = addonName, types = types, publishers = publishers, owners = owners)
  output <- .eks$describe_addon_versions_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_addon_versions <- eks_describe_addon_versions

#' Returns detailed information about a specific managed capability in your
#' Amazon EKS cluster, including its current status, configuration, health
#' information, and any issues that may be affecting its operation
#'
#' @description
#' Returns detailed information about a specific managed capability in your
#' Amazon EKS cluster, including its current status, configuration, health
#' information, and any issues that may be affecting its operation.
#'
#' @usage
#' eks_describe_capability(clusterName, capabilityName)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that contains the capability you want
#' to describe.
#' @param capabilityName &#91;required&#93; The name of the capability to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   capability = list(
#'     capabilityName = "string",
#'     arn = "string",
#'     clusterName = "string",
#'     type = "ACK"|"KRO"|"ARGOCD",
#'     roleArn = "string",
#'     status = "CREATING"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"ACTIVE"|"DEGRADED",
#'     version = "string",
#'     configuration = list(
#'       argoCd = list(
#'         namespace = "string",
#'         awsIdc = list(
#'           idcInstanceArn = "string",
#'           idcRegion = "string",
#'           idcManagedApplicationArn = "string"
#'         ),
#'         rbacRoleMappings = list(
#'           list(
#'             role = "ADMIN"|"EDITOR"|"VIEWER",
#'             identities = list(
#'               list(
#'                 id = "string",
#'                 type = "SSO_USER"|"SSO_GROUP"
#'               )
#'             )
#'           )
#'         ),
#'         networkAccess = list(
#'           vpceIds = list(
#'             "string"
#'           )
#'         ),
#'         serverUrl = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     deletePropagationPolicy = "RETAIN"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_capability(
#'   clusterName = "string",
#'   capabilityName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_capability
#'
#' @aliases eks_describe_capability
eks_describe_capability <- function(clusterName, capabilityName) {
  op <- new_operation(
    name = "DescribeCapability",
    http_method = "GET",
    http_path = "/clusters/{name}/capabilities/{capabilityName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_capability_input(clusterName = clusterName, capabilityName = capabilityName)
  output <- .eks$describe_capability_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_capability <- eks_describe_capability

#' Describes an Amazon EKS cluster
#'
#' @description
#' Describes an Amazon EKS cluster.
#' 
#' The API server endpoint and certificate authority data returned by this
#' operation are required for `kubelet` and `kubectl` to communicate with
#' your Kubernetes API server. For more information, see [Creating or
#' updating a `kubeconfig` file for an Amazon EKS
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html).
#' 
#' The API server endpoint and certificate authority data aren't available
#' until the cluster reaches the `ACTIVE` state.
#'
#' @usage
#' eks_describe_cluster(name)
#'
#' @param name &#91;required&#93; The name of your cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6",
#'       elasticLoadBalancing = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     ),
#'     accessConfig = list(
#'       bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'       authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'     ),
#'     upgradePolicy = list(
#'       supportType = "STANDARD"|"EXTENDED"
#'     ),
#'     zonalShiftConfig = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     remoteNetworkConfig = list(
#'       remoteNodeNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       remotePodNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     computeConfig = list(
#'       enabled = TRUE|FALSE,
#'       nodePools = list(
#'         "string"
#'       ),
#'       nodeRoleArn = "string"
#'     ),
#'     storageConfig = list(
#'       blockStorage = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     deletionProtection = TRUE|FALSE,
#'     controlPlaneScalingConfig = list(
#'       tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster(
#'   name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command provides a description of the specified cluster in
#' # your default region.
#' svc$describe_cluster(
#'   name = "devel"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_describe_cluster
#'
#' @aliases eks_describe_cluster
eks_describe_cluster <- function(name) {
  op <- new_operation(
    name = "DescribeCluster",
    http_method = "GET",
    http_path = "/clusters/{name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_cluster_input(name = name)
  output <- .eks$describe_cluster_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_cluster <- eks_describe_cluster

#' Lists available Kubernetes versions for Amazon EKS clusters
#'
#' @description
#' Lists available Kubernetes versions for Amazon EKS clusters.
#'
#' @usage
#' eks_describe_cluster_versions(clusterType, maxResults, nextToken,
#'   defaultOnly, includeAll, clusterVersions, status, versionStatus)
#'
#' @param clusterType The type of cluster to filter versions by.
#' @param maxResults Maximum number of results to return.
#' @param nextToken Pagination token for the next set of results.
#' @param defaultOnly Filter to show only default versions.
#' @param includeAll Include all available versions in the response.
#' @param clusterVersions List of specific cluster versions to describe.
#' @param status This field is deprecated. Use `versionStatus` instead, as that field
#' matches for input and output of this action.
#' 
#' Filter versions by their current status.
#' @param versionStatus Filter versions by their current status.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   clusterVersions = list(
#'     list(
#'       clusterVersion = "string",
#'       clusterType = "string",
#'       defaultPlatformVersion = "string",
#'       defaultVersion = TRUE|FALSE,
#'       releaseDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endOfStandardSupportDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endOfExtendedSupportDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "unsupported"|"standard-support"|"extended-support",
#'       versionStatus = "UNSUPPORTED"|"STANDARD_SUPPORT"|"EXTENDED_SUPPORT",
#'       kubernetesPatchVersion = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_cluster_versions(
#'   clusterType = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   defaultOnly = TRUE|FALSE,
#'   includeAll = TRUE|FALSE,
#'   clusterVersions = list(
#'     "string"
#'   ),
#'   status = "unsupported"|"standard-support"|"extended-support",
#'   versionStatus = "UNSUPPORTED"|"STANDARD_SUPPORT"|"EXTENDED_SUPPORT"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_cluster_versions
#'
#' @aliases eks_describe_cluster_versions
eks_describe_cluster_versions <- function(clusterType = NULL, maxResults = NULL, nextToken = NULL, defaultOnly = NULL, includeAll = NULL, clusterVersions = NULL, status = NULL, versionStatus = NULL) {
  op <- new_operation(
    name = "DescribeClusterVersions",
    http_method = "GET",
    http_path = "/cluster-versions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "clusterVersions"),
    stream_api = FALSE
  )
  input <- .eks$describe_cluster_versions_input(clusterType = clusterType, maxResults = maxResults, nextToken = nextToken, defaultOnly = defaultOnly, includeAll = includeAll, clusterVersions = clusterVersions, status = status, versionStatus = versionStatus)
  output <- .eks$describe_cluster_versions_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_cluster_versions <- eks_describe_cluster_versions

#' Returns descriptive information about a subscription
#'
#' @description
#' Returns descriptive information about a subscription.
#'
#' @usage
#' eks_describe_eks_anywhere_subscription(id)
#'
#' @param id &#91;required&#93; The ID of the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     licenses = list(
#'       list(
#'         id = "string",
#'         token = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_eks_anywhere_subscription(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_eks_anywhere_subscription
#'
#' @aliases eks_describe_eks_anywhere_subscription
eks_describe_eks_anywhere_subscription <- function(id) {
  op <- new_operation(
    name = "DescribeEksAnywhereSubscription",
    http_method = "GET",
    http_path = "/eks-anywhere-subscriptions/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_eks_anywhere_subscription_input(id = id)
  output <- .eks$describe_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_eks_anywhere_subscription <- eks_describe_eks_anywhere_subscription

#' Describes an Fargate profile
#'
#' @description
#' Describes an Fargate profile.
#'
#' @usage
#' eks_describe_fargate_profile(clusterName, fargateProfileName)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param fargateProfileName &#91;required&#93; The name of the Fargate profile to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfile = list(
#'     fargateProfileName = "string",
#'     fargateProfileArn = "string",
#'     clusterName = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     podExecutionRoleArn = "string",
#'     subnets = list(
#'       "string"
#'     ),
#'     selectors = list(
#'       list(
#'         namespace = "string",
#'         labels = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED",
#'     tags = list(
#'       "string"
#'     ),
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "PodExecutionRoleAlreadyInUse"|"AccessDenied"|"ClusterUnreachable"|"InternalFailure",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_fargate_profile(
#'   clusterName = "string",
#'   fargateProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_fargate_profile
#'
#' @aliases eks_describe_fargate_profile
eks_describe_fargate_profile <- function(clusterName, fargateProfileName) {
  op <- new_operation(
    name = "DescribeFargateProfile",
    http_method = "GET",
    http_path = "/clusters/{name}/fargate-profiles/{fargateProfileName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_fargate_profile_input(clusterName = clusterName, fargateProfileName = fargateProfileName)
  output <- .eks$describe_fargate_profile_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_fargate_profile <- eks_describe_fargate_profile

#' Describes an identity provider configuration
#'
#' @description
#' Describes an identity provider configuration.
#'
#' @usage
#' eks_describe_identity_provider_config(clusterName,
#'   identityProviderConfig)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param identityProviderConfig &#91;required&#93; An object representing an identity provider configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   identityProviderConfig = list(
#'     oidc = list(
#'       identityProviderConfigName = "string",
#'       identityProviderConfigArn = "string",
#'       clusterName = "string",
#'       issuerUrl = "string",
#'       clientId = "string",
#'       usernameClaim = "string",
#'       usernamePrefix = "string",
#'       groupsClaim = "string",
#'       groupsPrefix = "string",
#'       requiredClaims = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       status = "CREATING"|"DELETING"|"ACTIVE"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_identity_provider_config(
#'   clusterName = "string",
#'   identityProviderConfig = list(
#'     type = "string",
#'     name = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_identity_provider_config
#'
#' @aliases eks_describe_identity_provider_config
eks_describe_identity_provider_config <- function(clusterName, identityProviderConfig) {
  op <- new_operation(
    name = "DescribeIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/describe",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_identity_provider_config_input(clusterName = clusterName, identityProviderConfig = identityProviderConfig)
  output <- .eks$describe_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_identity_provider_config <- eks_describe_identity_provider_config

#' Returns details about an insight that you specify using its ID
#'
#' @description
#' Returns details about an insight that you specify using its ID.
#'
#' @usage
#' eks_describe_insight(clusterName, id)
#'
#' @param clusterName &#91;required&#93; The name of the cluster to describe the insight for.
#' @param id &#91;required&#93; The identity of the insight to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   insight = list(
#'     id = "string",
#'     name = "string",
#'     category = "UPGRADE_READINESS"|"MISCONFIGURATION",
#'     kubernetesVersion = "string",
#'     lastRefreshTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     lastTransitionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     description = "string",
#'     insightStatus = list(
#'       status = "PASSING"|"WARNING"|"ERROR"|"UNKNOWN",
#'       reason = "string"
#'     ),
#'     recommendation = "string",
#'     additionalInfo = list(
#'       "string"
#'     ),
#'     resources = list(
#'       list(
#'         insightStatus = list(
#'           status = "PASSING"|"WARNING"|"ERROR"|"UNKNOWN",
#'           reason = "string"
#'         ),
#'         kubernetesResourceUri = "string",
#'         arn = "string"
#'       )
#'     ),
#'     categorySpecificSummary = list(
#'       deprecationDetails = list(
#'         list(
#'           usage = "string",
#'           replacedWith = "string",
#'           stopServingVersion = "string",
#'           startServingReplacementVersion = "string",
#'           clientStats = list(
#'             list(
#'               userAgent = "string",
#'               numberOfRequestsLast30Days = 123,
#'               lastRequestTime = as.POSIXct(
#'                 "2015-01-01"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       addonCompatibilityDetails = list(
#'         list(
#'           name = "string",
#'           compatibleVersions = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_insight(
#'   clusterName = "string",
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_insight
#'
#' @aliases eks_describe_insight
eks_describe_insight <- function(clusterName, id) {
  op <- new_operation(
    name = "DescribeInsight",
    http_method = "GET",
    http_path = "/clusters/{name}/insights/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_insight_input(clusterName = clusterName, id = id)
  output <- .eks$describe_insight_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_insight <- eks_describe_insight

#' Returns the status of the latest on-demand cluster insights refresh
#' operation
#'
#' @description
#' Returns the status of the latest on-demand cluster insights refresh
#' operation.
#'
#' @usage
#' eks_describe_insights_refresh(clusterName)
#'
#' @param clusterName &#91;required&#93; The name of the cluster associated with the insights refresh operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   message = "string",
#'   status = "IN_PROGRESS"|"FAILED"|"COMPLETED",
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_insights_refresh(
#'   clusterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_insights_refresh
#'
#' @aliases eks_describe_insights_refresh
eks_describe_insights_refresh <- function(clusterName) {
  op <- new_operation(
    name = "DescribeInsightsRefresh",
    http_method = "GET",
    http_path = "/clusters/{name}/insights-refresh",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_insights_refresh_input(clusterName = clusterName)
  output <- .eks$describe_insights_refresh_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_insights_refresh <- eks_describe_insights_refresh

#' Describes a managed node group
#'
#' @description
#' Describes a managed node group.
#'
#' @usage
#' eks_describe_nodegroup(clusterName, nodegroupName)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param nodegroupName &#91;required&#93; The name of the node group to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroup = list(
#'     nodegroupName = "string",
#'     nodegroupArn = "string",
#'     clusterName = "string",
#'     version = "string",
#'     releaseVersion = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     status = "CREATING"|"ACTIVE"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"DELETE_FAILED"|"DEGRADED",
#'     capacityType = "ON_DEMAND"|"SPOT"|"CAPACITY_BLOCK",
#'     scalingConfig = list(
#'       minSize = 123,
#'       maxSize = 123,
#'       desiredSize = 123
#'     ),
#'     instanceTypes = list(
#'       "string"
#'     ),
#'     subnets = list(
#'       "string"
#'     ),
#'     remoteAccess = list(
#'       ec2SshKey = "string",
#'       sourceSecurityGroups = list(
#'         "string"
#'       )
#'     ),
#'     amiType = "AL2_x86_64"|"AL2_x86_64_GPU"|"AL2_ARM_64"|"CUSTOM"|"BOTTLEROCKET_ARM_64"|"BOTTLEROCKET_x86_64"|"BOTTLEROCKET_ARM_64_FIPS"|"BOTTLEROCKET_x86_64_FIPS"|"BOTTLEROCKET_ARM_64_NVIDIA"|"BOTTLEROCKET_x86_64_NVIDIA"|"WINDOWS_CORE_2019_x86_64"|"WINDOWS_FULL_2019_x86_64"|"WINDOWS_CORE_2022_x86_64"|"WINDOWS_FULL_2022_x86_64"|"AL2023_x86_64_STANDARD"|"AL2023_ARM_64_STANDARD"|"AL2023_x86_64_NEURON"|"AL2023_x86_64_NVIDIA"|"AL2023_ARM_64_NVIDIA",
#'     nodeRole = "string",
#'     labels = list(
#'       "string"
#'     ),
#'     taints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     resources = list(
#'       autoScalingGroups = list(
#'         list(
#'           name = "string"
#'         )
#'       ),
#'       remoteAccessSecurityGroup = "string"
#'     ),
#'     diskSize = 123,
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AutoScalingGroupNotFound"|"AutoScalingGroupInvalidConfiguration"|"Ec2SecurityGroupNotFound"|"Ec2SecurityGroupDeletionFailure"|"Ec2LaunchTemplateNotFound"|"Ec2LaunchTemplateVersionMismatch"|"Ec2SubnetNotFound"|"Ec2SubnetInvalidConfiguration"|"IamInstanceProfileNotFound"|"Ec2SubnetMissingIpv6Assignment"|"IamLimitExceeded"|"IamNodeRoleNotFound"|"NodeCreationFailure"|"AsgInstanceLaunchFailures"|"InstanceLimitExceeded"|"InsufficientFreeAddresses"|"AccessDenied"|"InternalFailure"|"ClusterUnreachable"|"AmiIdNotFound"|"AutoScalingGroupOptInRequired"|"AutoScalingGroupRateLimitExceeded"|"Ec2LaunchTemplateDeletionFailure"|"Ec2LaunchTemplateInvalidConfiguration"|"Ec2LaunchTemplateMaxLimitExceeded"|"Ec2SubnetListTooLong"|"IamThrottling"|"NodeTerminationFailure"|"PodEvictionFailure"|"SourceEc2LaunchTemplateNotFound"|"LimitExceeded"|"Unknown"|"AutoScalingGroupInstanceRefreshActive"|"KubernetesLabelInvalid"|"Ec2LaunchTemplateVersionMaxLimitExceeded"|"Ec2InstanceTypeDoesNotExist",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     updateConfig = list(
#'       maxUnavailable = 123,
#'       maxUnavailablePercentage = 123,
#'       updateStrategy = "DEFAULT"|"MINIMAL"
#'     ),
#'     nodeRepairConfig = list(
#'       enabled = TRUE|FALSE,
#'       maxUnhealthyNodeThresholdCount = 123,
#'       maxUnhealthyNodeThresholdPercentage = 123,
#'       maxParallelNodesRepairedCount = 123,
#'       maxParallelNodesRepairedPercentage = 123,
#'       nodeRepairConfigOverrides = list(
#'         list(
#'           nodeMonitoringCondition = "string",
#'           nodeUnhealthyReason = "string",
#'           minRepairWaitTimeMins = 123,
#'           repairAction = "Replace"|"Reboot"|"NoAction"
#'         )
#'       )
#'     ),
#'     launchTemplate = list(
#'       name = "string",
#'       version = "string",
#'       id = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_nodegroup(
#'   clusterName = "string",
#'   nodegroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_nodegroup
#'
#' @aliases eks_describe_nodegroup
eks_describe_nodegroup <- function(clusterName, nodegroupName) {
  op <- new_operation(
    name = "DescribeNodegroup",
    http_method = "GET",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_nodegroup_input(clusterName = clusterName, nodegroupName = nodegroupName)
  output <- .eks$describe_nodegroup_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_nodegroup <- eks_describe_nodegroup

#' Returns descriptive information about an EKS Pod Identity association
#'
#' @description
#' Returns descriptive information about an EKS Pod Identity association.
#' 
#' This action requires the ID of the association. You can get the ID from
#' the response to the `CreatePodIdentityAssocation` for newly created
#' associations. Or, you can list the IDs for associations with
#' [`list_pod_identity_associations`][eks_list_pod_identity_associations]
#' and filter the list by namespace or service account.
#'
#' @usage
#' eks_describe_pod_identity_association(clusterName, associationId)
#'
#' @param clusterName &#91;required&#93; The name of the cluster that the association is in.
#' @param associationId &#91;required&#93; The ID of the association that you want the description of.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   association = list(
#'     clusterName = "string",
#'     namespace = "string",
#'     serviceAccount = "string",
#'     roleArn = "string",
#'     associationArn = "string",
#'     associationId = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ownerArn = "string",
#'     disableSessionTags = TRUE|FALSE,
#'     targetRoleArn = "string",
#'     externalId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_pod_identity_association(
#'   clusterName = "string",
#'   associationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_pod_identity_association
#'
#' @aliases eks_describe_pod_identity_association
eks_describe_pod_identity_association <- function(clusterName, associationId) {
  op <- new_operation(
    name = "DescribePodIdentityAssociation",
    http_method = "GET",
    http_path = "/clusters/{name}/pod-identity-associations/{associationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_pod_identity_association_input(clusterName = clusterName, associationId = associationId)
  output <- .eks$describe_pod_identity_association_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_pod_identity_association <- eks_describe_pod_identity_association

#' Describes an update to an Amazon EKS resource
#'
#' @description
#' Describes an update to an Amazon EKS resource.
#' 
#' When the status of the update is `Successful`, the update is complete.
#' If an update fails, the status is `Failed`, and an error detail explains
#' the reason for the failure.
#'
#' @usage
#' eks_describe_update(name, updateId, nodegroupName, addonName,
#'   capabilityName)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster associated with the update.
#' @param updateId &#91;required&#93; The ID of the update to describe.
#' @param nodegroupName The name of the Amazon EKS node group associated with the update. This
#' parameter is required if the update is a node group update.
#' @param addonName The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' . This parameter is required if the update is an add-on update.
#' @param capabilityName The name of the capability for which you want to describe updates.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_update(
#'   name = "string",
#'   updateId = "string",
#'   nodegroupName = "string",
#'   addonName = "string",
#'   capabilityName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_describe_update
#'
#' @aliases eks_describe_update
eks_describe_update <- function(name, updateId, nodegroupName = NULL, addonName = NULL, capabilityName = NULL) {
  op <- new_operation(
    name = "DescribeUpdate",
    http_method = "GET",
    http_path = "/clusters/{name}/updates/{updateId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$describe_update_input(name = name, updateId = updateId, nodegroupName = nodegroupName, addonName = addonName, capabilityName = capabilityName)
  output <- .eks$describe_update_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$describe_update <- eks_describe_update

#' Disassociates an access policy from an access entry
#'
#' @description
#' Disassociates an access policy from an access entry.
#'
#' @usage
#' eks_disassociate_access_policy(clusterName, principalArn, policyArn)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`.
#' @param policyArn &#91;required&#93; The ARN of the policy to disassociate from the access entry. For a list
#' of associated policies ARNs, use
#' [`list_associated_access_policies`][eks_list_associated_access_policies].
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_access_policy(
#'   clusterName = "string",
#'   principalArn = "string",
#'   policyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_disassociate_access_policy
#'
#' @aliases eks_disassociate_access_policy
eks_disassociate_access_policy <- function(clusterName, principalArn, policyArn) {
  op <- new_operation(
    name = "DisassociateAccessPolicy",
    http_method = "DELETE",
    http_path = "/clusters/{name}/access-entries/{principalArn}/access-policies/{policyArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$disassociate_access_policy_input(clusterName = clusterName, principalArn = principalArn, policyArn = policyArn)
  output <- .eks$disassociate_access_policy_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$disassociate_access_policy <- eks_disassociate_access_policy

#' Disassociates an identity provider configuration from a cluster
#'
#' @description
#' Disassociates an identity provider configuration from a cluster.
#' 
#' If you disassociate an identity provider from your cluster, users
#' included in the provider can no longer access the cluster. However, you
#' can still access the cluster with IAM principals.
#'
#' @usage
#' eks_disassociate_identity_provider_config(clusterName,
#'   identityProviderConfig, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param identityProviderConfig &#91;required&#93; An object representing an identity provider configuration.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_identity_provider_config(
#'   clusterName = "string",
#'   identityProviderConfig = list(
#'     type = "string",
#'     name = "string"
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_disassociate_identity_provider_config
#'
#' @aliases eks_disassociate_identity_provider_config
eks_disassociate_identity_provider_config <- function(clusterName, identityProviderConfig, clientRequestToken = NULL) {
  op <- new_operation(
    name = "DisassociateIdentityProviderConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/identity-provider-configs/disassociate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$disassociate_identity_provider_config_input(clusterName = clusterName, identityProviderConfig = identityProviderConfig, clientRequestToken = clientRequestToken)
  output <- .eks$disassociate_identity_provider_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$disassociate_identity_provider_config <- eks_disassociate_identity_provider_config

#' Lists the access entries for your cluster
#'
#' @description
#' Lists the access entries for your cluster.
#'
#' @usage
#' eks_list_access_entries(clusterName, associatedPolicyArn, maxResults,
#'   nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param associatedPolicyArn The ARN of an `AccessPolicy`. When you specify an access policy ARN,
#' only the access entries associated to that access policy are returned.
#' For a list of available policy ARNs, use
#' [`list_access_policies`][eks_list_access_policies].
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessEntries = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_access_entries(
#'   clusterName = "string",
#'   associatedPolicyArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_access_entries
#'
#' @aliases eks_list_access_entries
eks_list_access_entries <- function(clusterName, associatedPolicyArn = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAccessEntries",
    http_method = "GET",
    http_path = "/clusters/{name}/access-entries",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "accessEntries"),
    stream_api = FALSE
  )
  input <- .eks$list_access_entries_input(clusterName = clusterName, associatedPolicyArn = associatedPolicyArn, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_access_entries_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_access_entries <- eks_list_access_entries

#' Lists the available access policies
#'
#' @description
#' Lists the available access policies.
#'
#' @usage
#' eks_list_access_policies(maxResults, nextToken)
#'
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessPolicies = list(
#'     list(
#'       name = "string",
#'       arn = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_access_policies(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_access_policies
#'
#' @aliases eks_list_access_policies
eks_list_access_policies <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAccessPolicies",
    http_method = "GET",
    http_path = "/access-policies",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "accessPolicies"),
    stream_api = FALSE
  )
  input <- .eks$list_access_policies_input(maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_access_policies_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_access_policies <- eks_list_access_policies

#' Lists the installed add-ons
#'
#' @description
#' Lists the installed add-ons.
#'
#' @usage
#' eks_list_addons(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   addons = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_addons(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_addons
#'
#' @aliases eks_list_addons
eks_list_addons <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAddons",
    http_method = "GET",
    http_path = "/clusters/{name}/addons",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "addons"),
    stream_api = FALSE
  )
  input <- .eks$list_addons_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_addons_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_addons <- eks_list_addons

#' Lists the access policies associated with an access entry
#'
#' @description
#' Lists the access policies associated with an access entry.
#'
#' @usage
#' eks_list_associated_access_policies(clusterName, principalArn,
#'   maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   clusterName = "string",
#'   principalArn = "string",
#'   nextToken = "string",
#'   associatedAccessPolicies = list(
#'     list(
#'       policyArn = "string",
#'       accessScope = list(
#'         type = "cluster"|"namespace",
#'         namespaces = list(
#'           "string"
#'         )
#'       ),
#'       associatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       modifiedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_associated_access_policies(
#'   clusterName = "string",
#'   principalArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_associated_access_policies
#'
#' @aliases eks_list_associated_access_policies
eks_list_associated_access_policies <- function(clusterName, principalArn, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAssociatedAccessPolicies",
    http_method = "GET",
    http_path = "/clusters/{name}/access-entries/{principalArn}/access-policies",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", non_aggregate_keys = list( "clusterName", "principalArn"), output_token = "nextToken", result_key = "associatedAccessPolicies"),
    stream_api = FALSE
  )
  input <- .eks$list_associated_access_policies_input(clusterName = clusterName, principalArn = principalArn, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_associated_access_policies_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_associated_access_policies <- eks_list_associated_access_policies

#' Lists all managed capabilities in your Amazon EKS cluster
#'
#' @description
#' Lists all managed capabilities in your Amazon EKS cluster. You can use
#' this operation to get an overview of all capabilities and their current
#' status.
#'
#' @usage
#' eks_list_capabilities(clusterName, nextToken, maxResults)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster for which you want to list
#' capabilities.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' @param maxResults The maximum number of results to return in a single call. To retrieve
#' the remaining results, make another call with the returned `nextToken`
#' value. If you don't specify a value, the default is 100 results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   capabilities = list(
#'     list(
#'       capabilityName = "string",
#'       arn = "string",
#'       type = "ACK"|"KRO"|"ARGOCD",
#'       status = "CREATING"|"CREATE_FAILED"|"UPDATING"|"DELETING"|"DELETE_FAILED"|"ACTIVE"|"DEGRADED",
#'       version = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       modifiedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_capabilities(
#'   clusterName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_capabilities
#'
#' @aliases eks_list_capabilities
eks_list_capabilities <- function(clusterName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListCapabilities",
    http_method = "GET",
    http_path = "/clusters/{name}/capabilities",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "capabilities"),
    stream_api = FALSE
  )
  input <- .eks$list_capabilities_input(clusterName = clusterName, nextToken = nextToken, maxResults = maxResults)
  output <- .eks$list_capabilities_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_capabilities <- eks_list_capabilities

#' Lists the Amazon EKS clusters in your Amazon Web Services account in the
#' specified Amazon Web Services Region
#'
#' @description
#' Lists the Amazon EKS clusters in your Amazon Web Services account in the
#' specified Amazon Web Services Region.
#'
#' @usage
#' eks_list_clusters(maxResults, nextToken, include)
#'
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#' @param include Indicates whether external clusters are included in the returned list.
#' Use '`all`' to return
#' <https://docs.aws.amazon.com/eks/latest/userguide/eks-connector.html>connected
#' clusters, or blank to return only Amazon EKS clusters. '`all`' must be
#' in lowercase otherwise an error occurs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   clusters = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_clusters(
#'   maxResults = 123,
#'   nextToken = "string",
#'   include = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example command lists all of your available clusters in your
#' # default region.
#' svc$list_clusters()
#' }
#'
#' @keywords internal
#'
#' @rdname eks_list_clusters
#'
#' @aliases eks_list_clusters
eks_list_clusters <- function(maxResults = NULL, nextToken = NULL, include = NULL) {
  op <- new_operation(
    name = "ListClusters",
    http_method = "GET",
    http_path = "/clusters",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "clusters"),
    stream_api = FALSE
  )
  input <- .eks$list_clusters_input(maxResults = maxResults, nextToken = nextToken, include = include)
  output <- .eks$list_clusters_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_clusters <- eks_list_clusters

#' Displays the full description of the subscription
#'
#' @description
#' Displays the full description of the subscription.
#'
#' @usage
#' eks_list_eks_anywhere_subscriptions(maxResults, nextToken,
#'   includeStatus)
#'
#' @param maxResults The maximum number of cluster results returned by
#' ListEksAnywhereSubscriptions in paginated output. When you use this
#' parameter, ListEksAnywhereSubscriptions returns only maxResults results
#' in a single page along with a nextToken response element. You can see
#' the remaining results of the initial request by sending another
#' ListEksAnywhereSubscriptions request with the returned nextToken value.
#' This value can be between 1 and 100. If you don't use this parameter,
#' ListEksAnywhereSubscriptions returns up to 10 results and a nextToken
#' value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_eks_anywhere_subscriptions`][eks_list_eks_anywhere_subscriptions]
#' request where `maxResults` was used and the results exceeded the value
#' of that parameter. Pagination continues from the end of the previous
#' results that returned the `nextToken` value.
#' @param includeStatus An array of subscription statuses to filter on.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriptions = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       effectiveDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       expirationDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       licenseQuantity = 123,
#'       licenseType = "Cluster",
#'       term = list(
#'         duration = 123,
#'         unit = "MONTHS"
#'       ),
#'       status = "string",
#'       autoRenew = TRUE|FALSE,
#'       licenseArns = list(
#'         "string"
#'       ),
#'       licenses = list(
#'         list(
#'           id = "string",
#'           token = "string"
#'         )
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_eks_anywhere_subscriptions(
#'   maxResults = 123,
#'   nextToken = "string",
#'   includeStatus = list(
#'     "CREATING"|"ACTIVE"|"UPDATING"|"EXPIRING"|"EXPIRED"|"DELETING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_eks_anywhere_subscriptions
#'
#' @aliases eks_list_eks_anywhere_subscriptions
eks_list_eks_anywhere_subscriptions <- function(maxResults = NULL, nextToken = NULL, includeStatus = NULL) {
  op <- new_operation(
    name = "ListEksAnywhereSubscriptions",
    http_method = "GET",
    http_path = "/eks-anywhere-subscriptions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "subscriptions"),
    stream_api = FALSE
  )
  input <- .eks$list_eks_anywhere_subscriptions_input(maxResults = maxResults, nextToken = nextToken, includeStatus = includeStatus)
  output <- .eks$list_eks_anywhere_subscriptions_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_eks_anywhere_subscriptions <- eks_list_eks_anywhere_subscriptions

#' Lists the Fargate profiles associated with the specified cluster in your
#' Amazon Web Services account in the specified Amazon Web Services Region
#'
#' @description
#' Lists the Fargate profiles associated with the specified cluster in your
#' Amazon Web Services account in the specified Amazon Web Services Region.
#'
#' @usage
#' eks_list_fargate_profiles(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   fargateProfileNames = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_fargate_profiles(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_fargate_profiles
#'
#' @aliases eks_list_fargate_profiles
eks_list_fargate_profiles <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListFargateProfiles",
    http_method = "GET",
    http_path = "/clusters/{name}/fargate-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "fargateProfileNames"),
    stream_api = FALSE
  )
  input <- .eks$list_fargate_profiles_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_fargate_profiles_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_fargate_profiles <- eks_list_fargate_profiles

#' Lists the identity provider configurations for your cluster
#'
#' @description
#' Lists the identity provider configurations for your cluster.
#'
#' @usage
#' eks_list_identity_provider_configs(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   identityProviderConfigs = list(
#'     list(
#'       type = "string",
#'       name = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_identity_provider_configs(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_identity_provider_configs
#'
#' @aliases eks_list_identity_provider_configs
eks_list_identity_provider_configs <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListIdentityProviderConfigs",
    http_method = "GET",
    http_path = "/clusters/{name}/identity-provider-configs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "identityProviderConfigs"),
    stream_api = FALSE
  )
  input <- .eks$list_identity_provider_configs_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_identity_provider_configs_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_identity_provider_configs <- eks_list_identity_provider_configs

#' Returns a list of all insights checked for against the specified cluster
#'
#' @description
#' Returns a list of all insights checked for against the specified
#' cluster. You can filter which insights are returned by category,
#' associated Kubernetes version, and status. The default filter lists all
#' categories and every status.
#' 
#' The following lists the available categories:
#' 
#' -   `UPGRADE_READINESS`: Amazon EKS identifies issues that could impact
#'     your ability to upgrade to new versions of Kubernetes. These are
#'     called upgrade insights.
#' 
#' -   `MISCONFIGURATION`: Amazon EKS identifies misconfiguration in your
#'     EKS Hybrid Nodes setup that could impair functionality of your
#'     cluster or workloads. These are called configuration insights.
#'
#' @usage
#' eks_list_insights(clusterName, filter, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster associated with the insights.
#' @param filter The criteria to filter your list of insights for your cluster. You can
#' filter which insights are returned by category, associated Kubernetes
#' version, and status.
#' @param maxResults The maximum number of identity provider configurations returned by
#' [`list_insights`][eks_list_insights] in paginated output. When you use
#' this parameter, [`list_insights`][eks_list_insights] returns only
#' `maxResults` results in a single page along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another [`list_insights`][eks_list_insights] request with the
#' returned `nextToken` value. This value can be between 1 and 100. If you
#' don't use this parameter, [`list_insights`][eks_list_insights] returns
#' up to 100 results and a `nextToken` value, if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_insights`][eks_list_insights] request. When the results of a
#' [`list_insights`][eks_list_insights] request exceed `maxResults`, you
#' can use this value to retrieve the next page of results. This value is
#' `null` when there are no more results to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   insights = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       category = "UPGRADE_READINESS"|"MISCONFIGURATION",
#'       kubernetesVersion = "string",
#'       lastRefreshTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastTransitionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       description = "string",
#'       insightStatus = list(
#'         status = "PASSING"|"WARNING"|"ERROR"|"UNKNOWN",
#'         reason = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_insights(
#'   clusterName = "string",
#'   filter = list(
#'     categories = list(
#'       "UPGRADE_READINESS"|"MISCONFIGURATION"
#'     ),
#'     kubernetesVersions = list(
#'       "string"
#'     ),
#'     statuses = list(
#'       "PASSING"|"WARNING"|"ERROR"|"UNKNOWN"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_insights
#'
#' @aliases eks_list_insights
eks_list_insights <- function(clusterName, filter = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListInsights",
    http_method = "POST",
    http_path = "/clusters/{name}/insights",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "insights"),
    stream_api = FALSE
  )
  input <- .eks$list_insights_input(clusterName = clusterName, filter = filter, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_insights_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_insights <- eks_list_insights

#' Lists the managed node groups associated with the specified cluster in
#' your Amazon Web Services account in the specified Amazon Web Services
#' Region
#'
#' @description
#' Lists the managed node groups associated with the specified cluster in
#' your Amazon Web Services account in the specified Amazon Web Services
#' Region. Self-managed node groups aren't listed.
#'
#' @usage
#' eks_list_nodegroups(clusterName, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nodegroups = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_nodegroups(
#'   clusterName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_nodegroups
#'
#' @aliases eks_list_nodegroups
eks_list_nodegroups <- function(clusterName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListNodegroups",
    http_method = "GET",
    http_path = "/clusters/{name}/node-groups",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "nodegroups"),
    stream_api = FALSE
  )
  input <- .eks$list_nodegroups_input(clusterName = clusterName, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_nodegroups_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_nodegroups <- eks_list_nodegroups

#' List the EKS Pod Identity associations in a cluster
#'
#' @description
#' List the EKS Pod Identity associations in a cluster. You can filter the
#' list by the namespace that the association is in or the service account
#' that the association uses.
#'
#' @usage
#' eks_list_pod_identity_associations(clusterName, namespace,
#'   serviceAccount, maxResults, nextToken)
#'
#' @param clusterName &#91;required&#93; The name of the cluster that the associations are in.
#' @param namespace The name of the Kubernetes namespace inside the cluster that the
#' associations are in.
#' @param serviceAccount The name of the Kubernetes service account that the associations use.
#' @param maxResults The maximum number of EKS Pod Identity association results returned by
#' [`list_pod_identity_associations`][eks_list_pod_identity_associations]
#' in paginated output. When you use this parameter,
#' [`list_pod_identity_associations`][eks_list_pod_identity_associations]
#' returns only `maxResults` results in a single page along with a
#' `nextToken` response element. You can see the remaining results of the
#' initial request by sending another
#' [`list_pod_identity_associations`][eks_list_pod_identity_associations]
#' request with the returned `nextToken` value. This value can be between 1
#' and 100. If you don't use this parameter,
#' [`list_pod_identity_associations`][eks_list_pod_identity_associations]
#' returns up to 100 results and a `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' [`list_updates`][eks_list_updates] request where `maxResults` was used
#' and the results exceeded the value of that parameter. Pagination
#' continues from the end of the previous results that returned the
#' `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associations = list(
#'     list(
#'       clusterName = "string",
#'       namespace = "string",
#'       serviceAccount = "string",
#'       associationArn = "string",
#'       associationId = "string",
#'       ownerArn = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_pod_identity_associations(
#'   clusterName = "string",
#'   namespace = "string",
#'   serviceAccount = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_pod_identity_associations
#'
#' @aliases eks_list_pod_identity_associations
eks_list_pod_identity_associations <- function(clusterName, namespace = NULL, serviceAccount = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListPodIdentityAssociations",
    http_method = "GET",
    http_path = "/clusters/{name}/pod-identity-associations",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "associations"),
    stream_api = FALSE
  )
  input <- .eks$list_pod_identity_associations_input(clusterName = clusterName, namespace = namespace, serviceAccount = serviceAccount, maxResults = maxResults, nextToken = nextToken)
  output <- .eks$list_pod_identity_associations_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_pod_identity_associations <- eks_list_pod_identity_associations

#' List the tags for an Amazon EKS resource
#'
#' @description
#' List the tags for an Amazon EKS resource.
#'
#' @usage
#' eks_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list tags
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example lists all of the tags for the `beta` cluster.
#' svc$list_tags_for_resource(
#'   resourceArn = "arn:aws:eks:us-west-2:012345678910:cluster/beta"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname eks_list_tags_for_resource
#'
#' @aliases eks_list_tags_for_resource
eks_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .eks$list_tags_for_resource_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_tags_for_resource <- eks_list_tags_for_resource

#' Lists the updates associated with an Amazon EKS resource in your Amazon
#' Web Services account, in the specified Amazon Web Services Region
#'
#' @description
#' Lists the updates associated with an Amazon EKS resource in your Amazon
#' Web Services account, in the specified Amazon Web Services Region.
#'
#' @usage
#' eks_list_updates(name, nodegroupName, addonName, capabilityName,
#'   nextToken, maxResults)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to list updates for.
#' @param nodegroupName The name of the Amazon EKS managed node group to list updates for.
#' @param addonName The names of the installed add-ons that have available updates.
#' @param capabilityName The name of the capability for which you want to list updates.
#' @param nextToken The `nextToken` value returned from a previous paginated request, where
#' `maxResults` was used and the results exceeded the value of that
#' parameter. Pagination continues from the end of the previous results
#' that returned the `nextToken` value. This value is null when there are
#' no more results to return.
#' 
#' This token should be treated as an opaque identifier that is used only
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#' @param maxResults The maximum number of results, returned in paginated output. You receive
#' `maxResults` in a single page, along with a `nextToken` response
#' element. You can see the remaining results of the initial request by
#' sending another request with the returned `nextToken` value. This value
#' can be between 1 and 100. If you don't use this parameter, 100 results
#' and a `nextToken` value, if applicable, are returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   updateIds = list(
#'     "string"
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_updates(
#'   name = "string",
#'   nodegroupName = "string",
#'   addonName = "string",
#'   capabilityName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_list_updates
#'
#' @aliases eks_list_updates
eks_list_updates <- function(name, nodegroupName = NULL, addonName = NULL, capabilityName = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListUpdates",
    http_method = "GET",
    http_path = "/clusters/{name}/updates",
    host_prefix = "",
    paginator = list(input_token = "nextToken", limit_key = "maxResults", output_token = "nextToken", result_key = "updateIds"),
    stream_api = FALSE
  )
  input <- .eks$list_updates_input(name = name, nodegroupName = nodegroupName, addonName = addonName, capabilityName = capabilityName, nextToken = nextToken, maxResults = maxResults)
  output <- .eks$list_updates_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$list_updates <- eks_list_updates

#' Connects a Kubernetes cluster to the Amazon EKS control plane
#'
#' @description
#' Connects a Kubernetes cluster to the Amazon EKS control plane.
#' 
#' Any Kubernetes cluster can be connected to the Amazon EKS control plane
#' to view current information about the cluster and its nodes.
#' 
#' Cluster connection requires two steps. First, send a
#' [`RegisterClusterRequest`](https://docs.aws.amazon.com/eks/latest/APIReference/)
#' to add it to the Amazon EKS control plane.
#' 
#' Second, a
#' [Manifest](https://amazon-eks.s3.us-west-2.amazonaws.com/eks-connector/manifests/eks-connector/latest/eks-connector.yaml)
#' containing the `activationID` and `activationCode` must be applied to
#' the Kubernetes cluster through it's native provider to provide
#' visibility.
#' 
#' After the manifest is updated and applied, the connected cluster is
#' visible to the Amazon EKS control plane. If the manifest isn't applied
#' within three days, the connected cluster will no longer be visible and
#' must be deregistered using
#' [`deregister_cluster`][eks_deregister_cluster].
#'
#' @usage
#' eks_register_cluster(name, connectorConfig, clientRequestToken, tags)
#'
#' @param name &#91;required&#93; A unique name for this cluster in your Amazon Web Services Region.
#' @param connectorConfig &#91;required&#93; The configuration settings required to connect the Kubernetes cluster to
#' the Amazon EKS control plane.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param tags Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   cluster = list(
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     version = "string",
#'     endpoint = "string",
#'     roleArn = "string",
#'     resourcesVpcConfig = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       ),
#'       clusterSecurityGroupId = "string",
#'       vpcId = "string",
#'       endpointPublicAccess = TRUE|FALSE,
#'       endpointPrivateAccess = TRUE|FALSE,
#'       publicAccessCidrs = list(
#'         "string"
#'       )
#'     ),
#'     kubernetesNetworkConfig = list(
#'       serviceIpv4Cidr = "string",
#'       serviceIpv6Cidr = "string",
#'       ipFamily = "ipv4"|"ipv6",
#'       elasticLoadBalancing = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     logging = list(
#'       clusterLogging = list(
#'         list(
#'           types = list(
#'             "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'           ),
#'           enabled = TRUE|FALSE
#'         )
#'       )
#'     ),
#'     identity = list(
#'       oidc = list(
#'         issuer = "string"
#'       )
#'     ),
#'     status = "CREATING"|"ACTIVE"|"DELETING"|"FAILED"|"UPDATING"|"PENDING",
#'     certificateAuthority = list(
#'       data = "string"
#'     ),
#'     clientRequestToken = "string",
#'     platformVersion = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     encryptionConfig = list(
#'       list(
#'         resources = list(
#'           "string"
#'         ),
#'         provider = list(
#'           keyArn = "string"
#'         )
#'       )
#'     ),
#'     connectorConfig = list(
#'       activationId = "string",
#'       activationCode = "string",
#'       activationExpiry = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       provider = "string",
#'       roleArn = "string"
#'     ),
#'     id = "string",
#'     health = list(
#'       issues = list(
#'         list(
#'           code = "AccessDenied"|"ClusterUnreachable"|"ConfigurationConflict"|"InternalFailure"|"ResourceLimitExceeded"|"ResourceNotFound"|"IamRoleNotFound"|"VpcNotFound"|"InsufficientFreeAddresses"|"Ec2ServiceNotSubscribed"|"Ec2SubnetNotFound"|"Ec2SecurityGroupNotFound"|"KmsGrantRevoked"|"KmsKeyNotFound"|"KmsKeyMarkedForDeletion"|"KmsKeyDisabled"|"StsRegionalEndpointDisabled"|"UnsupportedVersion"|"Other",
#'           message = "string",
#'           resourceIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     outpostConfig = list(
#'       outpostArns = list(
#'         "string"
#'       ),
#'       controlPlaneInstanceType = "string",
#'       controlPlanePlacement = list(
#'         groupName = "string"
#'       )
#'     ),
#'     accessConfig = list(
#'       bootstrapClusterCreatorAdminPermissions = TRUE|FALSE,
#'       authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'     ),
#'     upgradePolicy = list(
#'       supportType = "STANDARD"|"EXTENDED"
#'     ),
#'     zonalShiftConfig = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     remoteNetworkConfig = list(
#'       remoteNodeNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       remotePodNetworks = list(
#'         list(
#'           cidrs = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     computeConfig = list(
#'       enabled = TRUE|FALSE,
#'       nodePools = list(
#'         "string"
#'       ),
#'       nodeRoleArn = "string"
#'     ),
#'     storageConfig = list(
#'       blockStorage = list(
#'         enabled = TRUE|FALSE
#'       )
#'     ),
#'     deletionProtection = TRUE|FALSE,
#'     controlPlaneScalingConfig = list(
#'       tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$register_cluster(
#'   name = "string",
#'   connectorConfig = list(
#'     roleArn = "string",
#'     provider = "EKS_ANYWHERE"|"ANTHOS"|"GKE"|"AKS"|"OPENSHIFT"|"TANZU"|"RANCHER"|"EC2"|"OTHER"
#'   ),
#'   clientRequestToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_register_cluster
#'
#' @aliases eks_register_cluster
eks_register_cluster <- function(name, connectorConfig, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "RegisterCluster",
    http_method = "POST",
    http_path = "/cluster-registrations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$register_cluster_input(name = name, connectorConfig = connectorConfig, clientRequestToken = clientRequestToken, tags = tags)
  output <- .eks$register_cluster_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$register_cluster <- eks_register_cluster

#' Initiates an on-demand refresh operation for cluster insights, getting
#' the latest analysis outside of the standard refresh schedule
#'
#' @description
#' Initiates an on-demand refresh operation for cluster insights, getting
#' the latest analysis outside of the standard refresh schedule.
#'
#' @usage
#' eks_start_insights_refresh(clusterName)
#'
#' @param clusterName &#91;required&#93; The name of the cluster for the refresh insights operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   message = "string",
#'   status = "IN_PROGRESS"|"FAILED"|"COMPLETED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_insights_refresh(
#'   clusterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_start_insights_refresh
#'
#' @aliases eks_start_insights_refresh
eks_start_insights_refresh <- function(clusterName) {
  op <- new_operation(
    name = "StartInsightsRefresh",
    http_method = "POST",
    http_path = "/clusters/{name}/insights-refresh",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$start_insights_refresh_input(clusterName = clusterName)
  output <- .eks$start_insights_refresh_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$start_insights_refresh <- eks_start_insights_refresh

#' Associates the specified tags to an Amazon EKS resource with the
#' specified resourceArn
#'
#' @description
#' Associates the specified tags to an Amazon EKS resource with the
#' specified `resourceArn`. If existing tags on a resource are not
#' specified in the request parameters, they aren't changed. When a
#' resource is deleted, the tags associated with that resource are also
#' deleted. Tags that you create for Amazon EKS resources don't propagate
#' to any other resources associated with the cluster. For example, if you
#' tag a cluster with this operation, that tag doesn't automatically
#' propagate to the subnets and nodes associated with the cluster.
#'
#' @usage
#' eks_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource to add tags to.
#' @param tags &#91;required&#93; Metadata that assists with categorization and organization. Each tag
#' consists of a key and an optional value. You define both. Tags don't
#' propagate to any other cluster or Amazon Web Services resources.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_tag_resource
#'
#' @aliases eks_tag_resource
eks_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .eks$tag_resource_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$tag_resource <- eks_tag_resource

#' Deletes specified tags from an Amazon EKS resource
#'
#' @description
#' Deletes specified tags from an Amazon EKS resource.
#'
#' @usage
#' eks_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource to delete tags from.
#' @param tagKeys &#91;required&#93; The keys of the tags to remove.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_untag_resource
#'
#' @aliases eks_untag_resource
eks_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .eks$untag_resource_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$untag_resource <- eks_untag_resource

#' Updates an access entry
#'
#' @description
#' Updates an access entry.
#'
#' @usage
#' eks_update_access_entry(clusterName, principalArn, kubernetesGroups,
#'   clientRequestToken, username)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param principalArn &#91;required&#93; The ARN of the IAM principal for the `AccessEntry`.
#' @param kubernetesGroups The value for `name` that you've specified for `kind: Group` as a
#' `subject` in a Kubernetes `RoleBinding` or `ClusterRoleBinding` object.
#' Amazon EKS doesn't confirm that the value for `name` exists in any
#' bindings on your cluster. You can specify one or more names.
#' 
#' Kubernetes authorizes the `principalArn` of the access entry to access
#' any cluster objects that you've specified in a Kubernetes `Role` or
#' `ClusterRole` object that is also specified in a binding's `roleRef`.
#' For more information about creating Kubernetes `RoleBinding`,
#' `ClusterRoleBinding`, `Role`, or `ClusterRole` objects, see [Using RBAC
#' Authorization in the Kubernetes
#' documentation](https://kubernetes.io/docs/reference/access-authn-authz/rbac/).
#' 
#' If you want Amazon EKS to authorize the `principalArn` (instead of, or
#' in addition to Kubernetes authorizing the `principalArn`), you can
#' associate one or more access policies to the access entry using
#' [`associate_access_policy`][eks_associate_access_policy]. If you
#' associate any access policies, the `principalARN` has all permissions
#' assigned in the associated access policies and all permissions in any
#' Kubernetes `Role` or `ClusterRole` objects that the group names are
#' bound to.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param username The username to authenticate to Kubernetes with. We recommend not
#' specifying a username and letting Amazon EKS specify it for you. For
#' more information about the value Amazon EKS specifies for you, or
#' constraints before specifying your own username, see [Creating access
#' entries](https://docs.aws.amazon.com/eks/latest/userguide/access-entries.html#creating-access-entries)
#' in the *Amazon EKS User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessEntry = list(
#'     clusterName = "string",
#'     principalArn = "string",
#'     kubernetesGroups = list(
#'       "string"
#'     ),
#'     accessEntryArn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     username = "string",
#'     type = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_access_entry(
#'   clusterName = "string",
#'   principalArn = "string",
#'   kubernetesGroups = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string",
#'   username = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_access_entry
#'
#' @aliases eks_update_access_entry
eks_update_access_entry <- function(clusterName, principalArn, kubernetesGroups = NULL, clientRequestToken = NULL, username = NULL) {
  op <- new_operation(
    name = "UpdateAccessEntry",
    http_method = "POST",
    http_path = "/clusters/{name}/access-entries/{principalArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_access_entry_input(clusterName = clusterName, principalArn = principalArn, kubernetesGroups = kubernetesGroups, clientRequestToken = clientRequestToken, username = username)
  output <- .eks$update_access_entry_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_access_entry <- eks_update_access_entry

#' Updates an Amazon EKS add-on
#'
#' @description
#' Updates an Amazon EKS add-on.
#'
#' @usage
#' eks_update_addon(clusterName, addonName, addonVersion,
#'   serviceAccountRoleArn, resolveConflicts, clientRequestToken,
#'   configurationValues, podIdentityAssociations)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param addonName &#91;required&#93; The name of the add-on. The name must match one of the names returned by
#' [`list_addons`](https://docs.aws.amazon.com/eks/latest/APIReference/API_ListAddons.html)
#' .
#' @param addonVersion The version of the add-on. The version must match one of the versions
#' returned by
#' [`describe_addon_versions`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeAddonVersions.html)
#' .
#' @param serviceAccountRoleArn The Amazon Resource Name (ARN) of an existing IAM role to bind to the
#' add-on's service account. The role must be assigned the IAM permissions
#' required by the add-on. If you don't specify an existing IAM role, then
#' the add-on uses the permissions assigned to the node IAM role. For more
#' information, see [Amazon EKS node IAM
#' role](https://docs.aws.amazon.com/eks/latest/userguide/create-node-role.html)
#' in the *Amazon EKS User Guide*.
#' 
#' To specify an existing IAM role, you must have an IAM OpenID Connect
#' (OIDC) provider created for your cluster. For more information, see
#' [Enabling IAM roles for service accounts on your
#' cluster](https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html)
#' in the *Amazon EKS User Guide*.
#' @param resolveConflicts How to resolve field value conflicts for an Amazon EKS add-on if you've
#' changed a value from the Amazon EKS default value. Conflicts are handled
#' based on the option you choose:
#' 
#' -   **None** – Amazon EKS doesn't change the value. The update might
#'     fail.
#' 
#' -   **Overwrite** – Amazon EKS overwrites the changed value back to the
#'     Amazon EKS default value.
#' 
#' -   **Preserve** – Amazon EKS preserves the value. If you choose this
#'     option, we recommend that you test any field and value changes on a
#'     non-production cluster before updating the add-on on your production
#'     cluster.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param configurationValues The set of configuration values for the add-on that's created. The
#' values that you provide are validated against the schema returned by
#' [`describe_addon_configuration`][eks_describe_addon_configuration].
#' @param podIdentityAssociations An array of EKS Pod Identity associations to be updated. Each
#' association maps a Kubernetes service account to an IAM role. If this
#' value is left blank, no change. If an empty array is provided, existing
#' associations owned by the add-on are deleted.
#' 
#' For more information, see [Attach an IAM Role to an Amazon EKS add-on
#' using EKS Pod
#' Identity](https://docs.aws.amazon.com/eks/latest/userguide/add-ons-iam.html)
#' in the *Amazon EKS User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_addon(
#'   clusterName = "string",
#'   addonName = "string",
#'   addonVersion = "string",
#'   serviceAccountRoleArn = "string",
#'   resolveConflicts = "OVERWRITE"|"NONE"|"PRESERVE",
#'   clientRequestToken = "string",
#'   configurationValues = "string",
#'   podIdentityAssociations = list(
#'     list(
#'       serviceAccount = "string",
#'       roleArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_addon
#'
#' @aliases eks_update_addon
eks_update_addon <- function(clusterName, addonName, addonVersion = NULL, serviceAccountRoleArn = NULL, resolveConflicts = NULL, clientRequestToken = NULL, configurationValues = NULL, podIdentityAssociations = NULL) {
  op <- new_operation(
    name = "UpdateAddon",
    http_method = "POST",
    http_path = "/clusters/{name}/addons/{addonName}/update",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_addon_input(clusterName = clusterName, addonName = addonName, addonVersion = addonVersion, serviceAccountRoleArn = serviceAccountRoleArn, resolveConflicts = resolveConflicts, clientRequestToken = clientRequestToken, configurationValues = configurationValues, podIdentityAssociations = podIdentityAssociations)
  output <- .eks$update_addon_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_addon <- eks_update_addon

#' Updates the configuration of a managed capability in your Amazon EKS
#' cluster
#'
#' @description
#' Updates the configuration of a managed capability in your Amazon EKS
#' cluster. You can update the IAM role, configuration settings, and delete
#' propagation policy for a capability.
#' 
#' When you update a capability, Amazon EKS applies the changes and may
#' restart capability components as needed. The capability remains
#' available during the update process, but some operations may be
#' temporarily unavailable.
#'
#' @usage
#' eks_update_capability(clusterName, capabilityName, roleArn,
#'   configuration, clientRequestToken, deletePropagationPolicy)
#'
#' @param clusterName &#91;required&#93; The name of the Amazon EKS cluster that contains the capability you want
#' to update configuration for.
#' @param capabilityName &#91;required&#93; The name of the capability to update configuration for.
#' @param roleArn The Amazon Resource Name (ARN) of the IAM role that the capability uses
#' to interact with Amazon Web Services services. If you specify a new role
#' ARN, the capability will start using the new role for all subsequent
#' operations.
#' @param configuration The updated configuration settings for the capability. You only need to
#' specify the configuration parameters you want to change. For Argo CD
#' capabilities, you can update RBAC role mappings and network access
#' settings.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. This token is valid for 24 hours after
#' creation.
#' @param deletePropagationPolicy The updated delete propagation policy for the capability. Currently, the
#' only supported value is `RETAIN`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_capability(
#'   clusterName = "string",
#'   capabilityName = "string",
#'   roleArn = "string",
#'   configuration = list(
#'     argoCd = list(
#'       rbacRoleMappings = list(
#'         addOrUpdateRoleMappings = list(
#'           list(
#'             role = "ADMIN"|"EDITOR"|"VIEWER",
#'             identities = list(
#'               list(
#'                 id = "string",
#'                 type = "SSO_USER"|"SSO_GROUP"
#'               )
#'             )
#'           )
#'         ),
#'         removeRoleMappings = list(
#'           list(
#'             role = "ADMIN"|"EDITOR"|"VIEWER",
#'             identities = list(
#'               list(
#'                 id = "string",
#'                 type = "SSO_USER"|"SSO_GROUP"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       networkAccess = list(
#'         vpceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   deletePropagationPolicy = "RETAIN"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_capability
#'
#' @aliases eks_update_capability
eks_update_capability <- function(clusterName, capabilityName, roleArn = NULL, configuration = NULL, clientRequestToken = NULL, deletePropagationPolicy = NULL) {
  op <- new_operation(
    name = "UpdateCapability",
    http_method = "POST",
    http_path = "/clusters/{name}/capabilities/{capabilityName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_capability_input(clusterName = clusterName, capabilityName = capabilityName, roleArn = roleArn, configuration = configuration, clientRequestToken = clientRequestToken, deletePropagationPolicy = deletePropagationPolicy)
  output <- .eks$update_capability_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_capability <- eks_update_capability

#' Updates an Amazon EKS cluster configuration
#'
#' @description
#' Updates an Amazon EKS cluster configuration. Your cluster continues to
#' function during the update. The response output includes an update ID
#' that you can use to track the status of your cluster update with
#' [`describe_update`][eks_describe_update].
#' 
#' You can use this operation to do the following actions:
#' 
#' -   You can use this API operation to enable or disable exporting the
#'     Kubernetes control plane logs for your cluster to CloudWatch Logs.
#'     By default, cluster control plane logs aren't exported to CloudWatch
#'     Logs. For more information, see [Amazon EKS Cluster control plane
#'     logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#'     in the *Amazon EKS User Guide* .
#' 
#'     CloudWatch Logs ingestion, archive storage, and data scanning rates
#'     apply to exported control plane logs. For more information, see
#'     [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' 
#' -   You can also use this API operation to enable or disable public and
#'     private access to your cluster's Kubernetes API server endpoint. By
#'     default, public access is enabled, and private access is disabled.
#'     For more information, see [Cluster API server
#'     endpoint](https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html)
#'     in the *Amazon EKS User Guide* .
#' 
#' -   You can also use this API operation to choose different subnets and
#'     security groups for the cluster. You must specify at least two
#'     subnets that are in different Availability Zones. You can't change
#'     which VPC the subnets are from, the subnets must be in the same VPC
#'     as the subnets that the cluster was created with. For more
#'     information about the VPC requirements, see
#'     [https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html](https://docs.aws.amazon.com/eks/latest/userguide/network-reqs.html)
#'     in the *Amazon EKS User Guide* .
#' 
#' -   You can also use this API operation to enable or disable ARC zonal
#'     shift. If zonal shift is enabled, Amazon Web Services configures
#'     zonal autoshift for the cluster.
#' 
#' -   You can also use this API operation to add, change, or remove the
#'     configuration in the cluster for EKS Hybrid Nodes. To remove the
#'     configuration, use the `remoteNetworkConfig` key with an object
#'     containing both subkeys with empty arrays for each. Here is an
#'     inline example:
#'     `"remoteNetworkConfig": { "remoteNodeNetworks": [], "remotePodNetworks": [] }`.
#' 
#' Cluster updates are asynchronous, and they should finish within a few
#' minutes. During an update, the cluster status moves to `UPDATING` (this
#' status transition is eventually consistent). When the update is complete
#' (either `Failed` or `Successful`), the cluster status moves to `Active`.
#'
#' @usage
#' eks_update_cluster_config(name, resourcesVpcConfig, logging,
#'   clientRequestToken, accessConfig, upgradePolicy, zonalShiftConfig,
#'   computeConfig, kubernetesNetworkConfig, storageConfig,
#'   remoteNetworkConfig, deletionProtection, controlPlaneScalingConfig)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to update.
#' @param resourcesVpcConfig 
#' @param logging Enable or disable exporting the Kubernetes control plane logs for your
#' cluster to CloudWatch Logs . By default, cluster control plane logs
#' aren't exported to CloudWatch Logs . For more information, see [Amazon
#' EKS cluster control plane
#' logs](https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html)
#' in the *Amazon EKS User Guide* .
#' 
#' CloudWatch Logs ingestion, archive storage, and data scanning rates
#' apply to exported control plane logs. For more information, see
#' [CloudWatch Pricing](https://aws.amazon.com/cloudwatch/pricing/).
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param accessConfig The access configuration for the cluster.
#' @param upgradePolicy You can enable or disable extended support for clusters currently on
#' standard support. You cannot disable extended support once it starts.
#' You must enable extended support before your cluster exits standard
#' support.
#' @param zonalShiftConfig Enable or disable ARC zonal shift for the cluster. If zonal shift is
#' enabled, Amazon Web Services configures zonal autoshift for the cluster.
#' 
#' Zonal shift is a feature of Amazon Application Recovery Controller
#' (ARC). ARC zonal shift is designed to be a temporary measure that allows
#' you to move traffic for a resource away from an impaired AZ until the
#' zonal shift expires or you cancel it. You can extend the zonal shift if
#' necessary.
#' 
#' You can start a zonal shift for an EKS cluster, or you can allow Amazon
#' Web Services to do it for you by enabling *zonal autoshift*. This shift
#' updates the flow of east-to-west network traffic in your cluster to only
#' consider network endpoints for Pods running on worker nodes in healthy
#' AZs. Additionally, any ALB or NLB handling ingress traffic for
#' applications in your EKS cluster will automatically route traffic to
#' targets in the healthy AZs. For more information about zonal shift in
#' EKS, see [Learn about Amazon Application Recovery Controller (ARC) Zonal
#' Shift in Amazon
#' EKS](https://docs.aws.amazon.com/eks/latest/userguide/zone-shift.html)
#' in the *Amazon EKS User Guide* .
#' @param computeConfig Update the configuration of the compute capability of your EKS Auto Mode
#' cluster. For example, enable the capability.
#' @param kubernetesNetworkConfig 
#' @param storageConfig Update the configuration of the block storage capability of your EKS
#' Auto Mode cluster. For example, enable the capability.
#' @param remoteNetworkConfig 
#' @param deletionProtection Specifies whether to enable or disable deletion protection for the
#' cluster. When enabled (`true`), the cluster cannot be deleted until
#' deletion protection is explicitly disabled. When disabled (`false`), the
#' cluster can be deleted normally.
#' @param controlPlaneScalingConfig The control plane scaling tier configuration. For more information, see
#' EKS Provisioned Control Plane in the Amazon EKS User Guide.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_config(
#'   name = "string",
#'   resourcesVpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     ),
#'     endpointPublicAccess = TRUE|FALSE,
#'     endpointPrivateAccess = TRUE|FALSE,
#'     publicAccessCidrs = list(
#'       "string"
#'     )
#'   ),
#'   logging = list(
#'     clusterLogging = list(
#'       list(
#'         types = list(
#'           "api"|"audit"|"authenticator"|"controllerManager"|"scheduler"
#'         ),
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   accessConfig = list(
#'     authenticationMode = "API"|"API_AND_CONFIG_MAP"|"CONFIG_MAP"
#'   ),
#'   upgradePolicy = list(
#'     supportType = "STANDARD"|"EXTENDED"
#'   ),
#'   zonalShiftConfig = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   computeConfig = list(
#'     enabled = TRUE|FALSE,
#'     nodePools = list(
#'       "string"
#'     ),
#'     nodeRoleArn = "string"
#'   ),
#'   kubernetesNetworkConfig = list(
#'     serviceIpv4Cidr = "string",
#'     ipFamily = "ipv4"|"ipv6",
#'     elasticLoadBalancing = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   storageConfig = list(
#'     blockStorage = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   remoteNetworkConfig = list(
#'     remoteNodeNetworks = list(
#'       list(
#'         cidrs = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     remotePodNetworks = list(
#'       list(
#'         cidrs = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   deletionProtection = TRUE|FALSE,
#'   controlPlaneScalingConfig = list(
#'     tier = "standard"|"tier-xl"|"tier-2xl"|"tier-4xl"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_cluster_config
#'
#' @aliases eks_update_cluster_config
eks_update_cluster_config <- function(name, resourcesVpcConfig = NULL, logging = NULL, clientRequestToken = NULL, accessConfig = NULL, upgradePolicy = NULL, zonalShiftConfig = NULL, computeConfig = NULL, kubernetesNetworkConfig = NULL, storageConfig = NULL, remoteNetworkConfig = NULL, deletionProtection = NULL, controlPlaneScalingConfig = NULL) {
  op <- new_operation(
    name = "UpdateClusterConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/update-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_cluster_config_input(name = name, resourcesVpcConfig = resourcesVpcConfig, logging = logging, clientRequestToken = clientRequestToken, accessConfig = accessConfig, upgradePolicy = upgradePolicy, zonalShiftConfig = zonalShiftConfig, computeConfig = computeConfig, kubernetesNetworkConfig = kubernetesNetworkConfig, storageConfig = storageConfig, remoteNetworkConfig = remoteNetworkConfig, deletionProtection = deletionProtection, controlPlaneScalingConfig = controlPlaneScalingConfig)
  output <- .eks$update_cluster_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_cluster_config <- eks_update_cluster_config

#' Updates an Amazon EKS cluster to the specified Kubernetes version
#'
#' @description
#' Updates an Amazon EKS cluster to the specified Kubernetes version. Your
#' cluster continues to function during the update. The response output
#' includes an update ID that you can use to track the status of your
#' cluster update with the
#' [`describe_update`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeUpdate.html)
#' API operation.
#' 
#' Cluster updates are asynchronous, and they should finish within a few
#' minutes. During an update, the cluster status moves to `UPDATING` (this
#' status transition is eventually consistent). When the update is complete
#' (either `Failed` or `Successful`), the cluster status moves to `Active`.
#' 
#' If your cluster has managed node groups attached to it, all of your node
#' groups' Kubernetes versions must match the cluster's Kubernetes version
#' in order to update the cluster to a new Kubernetes version.
#'
#' @usage
#' eks_update_cluster_version(name, version, clientRequestToken, force)
#'
#' @param name &#91;required&#93; The name of the Amazon EKS cluster to update.
#' @param version &#91;required&#93; The desired Kubernetes version following a successful update.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param force Set this value to `true` to override upgrade-blocking readiness checks
#' when updating a cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_cluster_version(
#'   name = "string",
#'   version = "string",
#'   clientRequestToken = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_cluster_version
#'
#' @aliases eks_update_cluster_version
eks_update_cluster_version <- function(name, version, clientRequestToken = NULL, force = NULL) {
  op <- new_operation(
    name = "UpdateClusterVersion",
    http_method = "POST",
    http_path = "/clusters/{name}/updates",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_cluster_version_input(name = name, version = version, clientRequestToken = clientRequestToken, force = force)
  output <- .eks$update_cluster_version_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_cluster_version <- eks_update_cluster_version

#' Update an EKS Anywhere Subscription
#'
#' @description
#' Update an EKS Anywhere Subscription. Only auto renewal and tags can be
#' updated after subscription creation.
#'
#' @usage
#' eks_update_eks_anywhere_subscription(id, autoRenew, clientRequestToken)
#'
#' @param id &#91;required&#93; The ID of the subscription.
#' @param autoRenew &#91;required&#93; A boolean indicating whether or not to automatically renew the
#' subscription.
#' @param clientRequestToken Unique, case-sensitive identifier to ensure the idempotency of the
#' request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscription = list(
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     effectiveDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     expirationDate = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     licenseQuantity = 123,
#'     licenseType = "Cluster",
#'     term = list(
#'       duration = 123,
#'       unit = "MONTHS"
#'     ),
#'     status = "string",
#'     autoRenew = TRUE|FALSE,
#'     licenseArns = list(
#'       "string"
#'     ),
#'     licenses = list(
#'       list(
#'         id = "string",
#'         token = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_eks_anywhere_subscription(
#'   id = "string",
#'   autoRenew = TRUE|FALSE,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_eks_anywhere_subscription
#'
#' @aliases eks_update_eks_anywhere_subscription
eks_update_eks_anywhere_subscription <- function(id, autoRenew, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateEksAnywhereSubscription",
    http_method = "POST",
    http_path = "/eks-anywhere-subscriptions/{id}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_eks_anywhere_subscription_input(id = id, autoRenew = autoRenew, clientRequestToken = clientRequestToken)
  output <- .eks$update_eks_anywhere_subscription_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_eks_anywhere_subscription <- eks_update_eks_anywhere_subscription

#' Updates an Amazon EKS managed node group configuration
#'
#' @description
#' Updates an Amazon EKS managed node group configuration. Your node group
#' continues to function during the update. The response output includes an
#' update ID that you can use to track the status of your node group update
#' with the
#' [`describe_update`](https://docs.aws.amazon.com/eks/latest/APIReference/API_DescribeUpdate.html)
#' API operation. You can update the Kubernetes labels and taints for a
#' node group and the scaling and version update configuration.
#'
#' @usage
#' eks_update_nodegroup_config(clusterName, nodegroupName, labels, taints,
#'   scalingConfig, updateConfig, nodeRepairConfig, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param nodegroupName &#91;required&#93; The name of the managed node group to update.
#' @param labels The Kubernetes `labels` to apply to the nodes in the node group after
#' the update.
#' @param taints The Kubernetes taints to be applied to the nodes in the node group after
#' the update. For more information, see [Node taints on managed node
#' groups](https://docs.aws.amazon.com/eks/latest/userguide/node-taints-managed-node-groups.html).
#' @param scalingConfig The scaling configuration details for the Auto Scaling group after the
#' update.
#' @param updateConfig The node group update configuration.
#' @param nodeRepairConfig The node auto repair configuration for the node group.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_nodegroup_config(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   labels = list(
#'     addOrUpdateLabels = list(
#'       "string"
#'     ),
#'     removeLabels = list(
#'       "string"
#'     )
#'   ),
#'   taints = list(
#'     addOrUpdateTaints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     ),
#'     removeTaints = list(
#'       list(
#'         key = "string",
#'         value = "string",
#'         effect = "NO_SCHEDULE"|"NO_EXECUTE"|"PREFER_NO_SCHEDULE"
#'       )
#'     )
#'   ),
#'   scalingConfig = list(
#'     minSize = 123,
#'     maxSize = 123,
#'     desiredSize = 123
#'   ),
#'   updateConfig = list(
#'     maxUnavailable = 123,
#'     maxUnavailablePercentage = 123,
#'     updateStrategy = "DEFAULT"|"MINIMAL"
#'   ),
#'   nodeRepairConfig = list(
#'     enabled = TRUE|FALSE,
#'     maxUnhealthyNodeThresholdCount = 123,
#'     maxUnhealthyNodeThresholdPercentage = 123,
#'     maxParallelNodesRepairedCount = 123,
#'     maxParallelNodesRepairedPercentage = 123,
#'     nodeRepairConfigOverrides = list(
#'       list(
#'         nodeMonitoringCondition = "string",
#'         nodeUnhealthyReason = "string",
#'         minRepairWaitTimeMins = 123,
#'         repairAction = "Replace"|"Reboot"|"NoAction"
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_nodegroup_config
#'
#' @aliases eks_update_nodegroup_config
eks_update_nodegroup_config <- function(clusterName, nodegroupName, labels = NULL, taints = NULL, scalingConfig = NULL, updateConfig = NULL, nodeRepairConfig = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateNodegroupConfig",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}/update-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_nodegroup_config_input(clusterName = clusterName, nodegroupName = nodegroupName, labels = labels, taints = taints, scalingConfig = scalingConfig, updateConfig = updateConfig, nodeRepairConfig = nodeRepairConfig, clientRequestToken = clientRequestToken)
  output <- .eks$update_nodegroup_config_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_nodegroup_config <- eks_update_nodegroup_config

#' Updates the Kubernetes version or AMI version of an Amazon EKS managed
#' node group
#'
#' @description
#' Updates the Kubernetes version or AMI version of an Amazon EKS managed
#' node group.
#' 
#' You can update a node group using a launch template only if the node
#' group was originally deployed with a launch template. Additionally, the
#' launch template ID or name must match what was used when the node group
#' was created. You can update the launch template version with necessary
#' changes.
#' 
#' If you need to update a custom AMI in a node group that was deployed
#' with a launch template, then update your custom AMI, specify the new ID
#' in a new version of the launch template, and then update the node group
#' to the new version of the launch template.
#' 
#' If you update without a launch template, then you can update to the
#' latest available AMI version of a node group's current Kubernetes
#' version by not specifying a Kubernetes version in the request. You can
#' update to the latest AMI version of your cluster's current Kubernetes
#' version by specifying your cluster's Kubernetes version in the request.
#' For information about Linux versions, see [Amazon EKS optimized Amazon
#' Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. For information about Windows versions,
#' see [Amazon EKS optimized Windows AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' You cannot roll back a node group to an earlier Kubernetes version or
#' AMI version.
#' 
#' When a node in a managed node group is terminated due to a scaling
#' action or update, every `Pod` on that node is drained first. Amazon EKS
#' attempts to drain the nodes gracefully and will fail if it is unable to
#' do so. You can `force` the update if Amazon EKS is unable to drain the
#' nodes as a result of a `Pod` disruption budget issue.
#'
#' @usage
#' eks_update_nodegroup_version(clusterName, nodegroupName, version,
#'   releaseVersion, launchTemplate, force, clientRequestToken)
#'
#' @param clusterName &#91;required&#93; The name of your cluster.
#' @param nodegroupName &#91;required&#93; The name of the managed node group to update.
#' @param version The Kubernetes version to update to. If no version is specified, then
#' the node group will be updated to match the cluster's current Kubernetes
#' version, and the latest available AMI for that version will be used. You
#' can also specify the Kubernetes version of the cluster to update the
#' node group to the latest AMI version of the cluster's Kubernetes
#' version. If you specify `launchTemplate`, and your launch template uses
#' a custom AMI, then don't specify `version`, or the node group update
#' will fail. For more information about using launch templates with Amazon
#' EKS, see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param releaseVersion The AMI version of the Amazon EKS optimized AMI to use for the update.
#' By default, the latest available AMI version for the node group's
#' Kubernetes version is used. For information about Linux versions, see
#' [Amazon EKS optimized Amazon Linux AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-linux-ami-versions.html)
#' in the *Amazon EKS User Guide*. Amazon EKS managed node groups support
#' the November 2022 and later releases of the Windows AMIs. For
#' information about Windows versions, see [Amazon EKS optimized Windows
#' AMI
#' versions](https://docs.aws.amazon.com/eks/latest/userguide/eks-ami-versions-windows.html)
#' in the *Amazon EKS User Guide*.
#' 
#' If you specify `launchTemplate`, and your launch template uses a custom
#' AMI, then don't specify `releaseVersion`, or the node group update will
#' fail. For more information about using launch templates with Amazon EKS,
#' see [Customizing managed nodes with launch
#' templates](https://docs.aws.amazon.com/eks/latest/userguide/launch-templates.html)
#' in the *Amazon EKS User Guide*.
#' @param launchTemplate An object representing a node group's launch template specification. You
#' can only update a node group using a launch template if the node group
#' was originally deployed with a launch template. When updating, you must
#' specify the same launch template ID or name that was used to create the
#' node group.
#' @param force Force the update if any `Pod` on the existing node group can't be
#' drained due to a `Pod` disruption budget issue. If an update fails
#' because all Pods can't be drained, you can force the update after it
#' fails to terminate the old node whether or not any `Pod` is running on
#' the node.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   update = list(
#'     id = "string",
#'     status = "InProgress"|"Failed"|"Cancelled"|"Successful",
#'     type = "VersionUpdate"|"EndpointAccessUpdate"|"LoggingUpdate"|"ConfigUpdate"|"AssociateIdentityProviderConfig"|"DisassociateIdentityProviderConfig"|"AssociateEncryptionConfig"|"AddonUpdate"|"VpcConfigUpdate"|"AccessConfigUpdate"|"UpgradePolicyUpdate"|"ZonalShiftConfigUpdate"|"AutoModeUpdate"|"RemoteNetworkConfigUpdate"|"DeletionProtectionUpdate"|"ControlPlaneScalingConfigUpdate",
#'     params = list(
#'       list(
#'         type = "Version"|"PlatformVersion"|"EndpointPrivateAccess"|"EndpointPublicAccess"|"ClusterLogging"|"DesiredSize"|"LabelsToAdd"|"LabelsToRemove"|"TaintsToAdd"|"TaintsToRemove"|"MaxSize"|"MinSize"|"ReleaseVersion"|"PublicAccessCidrs"|"LaunchTemplateName"|"LaunchTemplateVersion"|"IdentityProviderConfig"|"EncryptionConfig"|"AddonVersion"|"ServiceAccountRoleArn"|"ResolveConflicts"|"MaxUnavailable"|"MaxUnavailablePercentage"|"NodeRepairEnabled"|"UpdateStrategy"|"ConfigurationValues"|"SecurityGroups"|"Subnets"|"AuthenticationMode"|"PodIdentityAssociations"|"UpgradePolicy"|"ZonalShiftConfig"|"ComputeConfig"|"StorageConfig"|"KubernetesNetworkConfig"|"RemoteNetworkConfig"|"DeletionProtection"|"NodeRepairConfig"|"UpdatedTier"|"PreviousTier",
#'         value = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     errors = list(
#'       list(
#'         errorCode = "SubnetNotFound"|"SecurityGroupNotFound"|"EniLimitReached"|"IpNotAvailable"|"AccessDenied"|"OperationNotPermitted"|"VpcIdNotFound"|"Unknown"|"NodeCreationFailure"|"PodEvictionFailure"|"InsufficientFreeAddresses"|"ClusterUnreachable"|"InsufficientNumberOfReplicas"|"ConfigurationConflict"|"AdmissionRequestDenied"|"UnsupportedAddonModification"|"K8sResourceNotFound",
#'         errorMessage = "string",
#'         resourceIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_nodegroup_version(
#'   clusterName = "string",
#'   nodegroupName = "string",
#'   version = "string",
#'   releaseVersion = "string",
#'   launchTemplate = list(
#'     name = "string",
#'     version = "string",
#'     id = "string"
#'   ),
#'   force = TRUE|FALSE,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_nodegroup_version
#'
#' @aliases eks_update_nodegroup_version
eks_update_nodegroup_version <- function(clusterName, nodegroupName, version = NULL, releaseVersion = NULL, launchTemplate = NULL, force = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateNodegroupVersion",
    http_method = "POST",
    http_path = "/clusters/{name}/node-groups/{nodegroupName}/update-version",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_nodegroup_version_input(clusterName = clusterName, nodegroupName = nodegroupName, version = version, releaseVersion = releaseVersion, launchTemplate = launchTemplate, force = force, clientRequestToken = clientRequestToken)
  output <- .eks$update_nodegroup_version_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_nodegroup_version <- eks_update_nodegroup_version

#' Updates a EKS Pod Identity association
#'
#' @description
#' Updates a EKS Pod Identity association. In an update, you can change the
#' IAM role, the target IAM role, or `disableSessionTags`. You must change
#' at least one of these in an update. An association can't be moved
#' between clusters, namespaces, or service accounts. If you need to edit
#' the namespace or service account, you need to delete the association and
#' then create a new association with your desired settings.
#' 
#' Similar to Amazon Web Services IAM behavior, EKS Pod Identity
#' associations are eventually consistent, and may take several seconds to
#' be effective after the initial API call returns successfully. You must
#' design your applications to account for these potential delays. We
#' recommend that you don’t include association create/updates in the
#' critical, high-availability code paths of your application. Instead,
#' make changes in a separate initialization or setup routine that you run
#' less frequently.
#' 
#' You can set a *target IAM role* in the same or a different account for
#' advanced scenarios. With a target role, EKS Pod Identity automatically
#' performs two role assumptions in sequence: first assuming the role in
#' the association that is in this account, then using those credentials to
#' assume the target IAM role. This process provides your Pod with
#' temporary credentials that have the permissions defined in the target
#' role, allowing secure access to resources in another Amazon Web Services
#' account.
#'
#' @usage
#' eks_update_pod_identity_association(clusterName, associationId, roleArn,
#'   clientRequestToken, disableSessionTags, targetRoleArn)
#'
#' @param clusterName &#91;required&#93; The name of the cluster that you want to update the association in.
#' @param associationId &#91;required&#93; The ID of the association to be updated.
#' @param roleArn The new IAM role to change in the association.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request.
#' @param disableSessionTags Disable the automatic sessions tags that are appended by EKS Pod
#' Identity.
#' 
#' EKS Pod Identity adds a pre-defined set of session tags when it assumes
#' the role. You can use these tags to author a single role that can work
#' across resources by allowing access to Amazon Web Services resources
#' based on matching tags. By default, EKS Pod Identity attaches six tags,
#' including tags for cluster name, namespace, and service account name.
#' For the list of tags added by EKS Pod Identity, see [List of session
#' tags added by EKS Pod
#' Identity](https://docs.aws.amazon.com/eks/latest/userguide/pod-id-abac.html#pod-id-abac-tags)
#' in the *Amazon EKS User Guide*.
#' 
#' Amazon Web Services compresses inline session policies, managed policy
#' ARNs, and session tags into a packed binary format that has a separate
#' limit. If you receive a `PackedPolicyTooLarge` error indicating the
#' packed binary format has exceeded the size limit, you can attempt to
#' reduce the size by disabling the session tags added by EKS Pod Identity.
#' @param targetRoleArn The Amazon Resource Name (ARN) of the target IAM role to associate with
#' the service account. This role is assumed by using the EKS Pod Identity
#' association role, then the credentials for this role are injected into
#' the Pod.
#' 
#' When you run applications on Amazon EKS, your application might need to
#' access Amazon Web Services resources from a different role that exists
#' in the same or different Amazon Web Services account. For example, your
#' application running in “Account A” might need to access resources, such
#' as buckets in “Account B” or within “Account A” itself. You can create a
#' association to access Amazon Web Services resources in “Account B” by
#' creating two IAM roles: a role in “Account A” and a role in “Account B”
#' (which can be the same or different account), each with the necessary
#' trust and permission policies. After you provide these roles in the *IAM
#' role* and *Target IAM role* fields, EKS will perform role chaining to
#' ensure your application gets the required permissions. This means Role A
#' will assume Role B, allowing your Pods to securely access resources like
#' S3 buckets in the target account.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   association = list(
#'     clusterName = "string",
#'     namespace = "string",
#'     serviceAccount = "string",
#'     roleArn = "string",
#'     associationArn = "string",
#'     associationId = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     modifiedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ownerArn = "string",
#'     disableSessionTags = TRUE|FALSE,
#'     targetRoleArn = "string",
#'     externalId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_pod_identity_association(
#'   clusterName = "string",
#'   associationId = "string",
#'   roleArn = "string",
#'   clientRequestToken = "string",
#'   disableSessionTags = TRUE|FALSE,
#'   targetRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname eks_update_pod_identity_association
#'
#' @aliases eks_update_pod_identity_association
eks_update_pod_identity_association <- function(clusterName, associationId, roleArn = NULL, clientRequestToken = NULL, disableSessionTags = NULL, targetRoleArn = NULL) {
  op <- new_operation(
    name = "UpdatePodIdentityAssociation",
    http_method = "POST",
    http_path = "/clusters/{name}/pod-identity-associations/{associationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .eks$update_pod_identity_association_input(clusterName = clusterName, associationId = associationId, roleArn = roleArn, clientRequestToken = clientRequestToken, disableSessionTags = disableSessionTags, targetRoleArn = targetRoleArn)
  output <- .eks$update_pod_identity_association_output()
  config <- get_config()
  svc <- .eks$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.eks$operations$update_pod_identity_association <- eks_update_pod_identity_association

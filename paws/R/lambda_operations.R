# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include lambda_service.R
NULL

#' Adds permissions to the resource-based policy of a version of an Lambda
#' layer
#'
#' @description
#' Adds permissions to the resource-based policy of a version of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html).
#' Use this action to grant layer usage permission to other accounts. You
#' can grant permission to a single account, all accounts in an
#' organization, or all Amazon Web Services accounts.
#' 
#' To revoke permission, call
#' [`remove_layer_version_permission`][lambda_remove_layer_version_permission]
#' with the statement ID that you specified when you added it.
#'
#' @usage
#' lambda_add_layer_version_permission(LayerName, VersionNumber,
#'   StatementId, Action, Principal, OrganizationId, RevisionId)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param VersionNumber &#91;required&#93; The version number.
#' @param StatementId &#91;required&#93; An identifier that distinguishes the policy from others on the same
#' layer version.
#' @param Action &#91;required&#93; The API action that grants access to the layer. For example,
#' `lambda:GetLayerVersion`.
#' @param Principal &#91;required&#93; An account ID, or `*` to grant layer usage permission to all accounts in
#' an organization, or all Amazon Web Services accounts (if
#' `organizationId` is not specified). For the last case, make sure that
#' you really do want all Amazon Web Services accounts to have usage
#' permission to this layer.
#' @param OrganizationId With the principal set to `*`, grant permission to all accounts in the
#' specified organization.
#' @param RevisionId Only update the policy if the revision ID matches the ID specified. Use
#' this option to avoid modifying a policy that has changed since you last
#' read it.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Statement = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$add_layer_version_permission(
#'   LayerName = "string",
#'   VersionNumber = 123,
#'   StatementId = "string",
#'   Action = "string",
#'   Principal = "string",
#'   OrganizationId = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example grants permission for the account 223456789012 to
#' # use version 1 of a layer named my-layer.
#' svc$add_layer_version_permission(
#'   Action = "lambda:GetLayerVersion",
#'   LayerName = "my-layer",
#'   Principal = "223456789012",
#'   StatementId = "xaccount",
#'   VersionNumber = 1L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_add_layer_version_permission
#'
#' @aliases lambda_add_layer_version_permission
lambda_add_layer_version_permission <- function(LayerName, VersionNumber, StatementId, Action, Principal, OrganizationId = NULL, RevisionId = NULL) {
  op <- new_operation(
    name = "AddLayerVersionPermission",
    http_method = "POST",
    http_path = "/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$add_layer_version_permission_input(LayerName = LayerName, VersionNumber = VersionNumber, StatementId = StatementId, Action = Action, Principal = Principal, OrganizationId = OrganizationId, RevisionId = RevisionId)
  output <- .lambda$add_layer_version_permission_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$add_layer_version_permission <- lambda_add_layer_version_permission

#' Grants a principal permission to use a function
#'
#' @description
#' Grants a
#' [principal](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_principal.html#Principal_specifying)
#' permission to use a function. You can apply the policy at the function
#' level, or specify a qualifier to restrict access to a single version or
#' alias. If you use a qualifier, the invoker must use the full Amazon
#' Resource Name (ARN) of that version or alias to invoke the function.
#' Note: Lambda does not support adding policies to version $LATEST.
#' 
#' To grant permission to another account, specify the account ID as the
#' `Principal`. To grant permission to an organization defined in
#' Organizations, specify the organization ID as the `PrincipalOrgID`. For
#' Amazon Web Services services, the principal is a domain-style identifier
#' that the service defines, such as `s3.amazonaws.com` or
#' `sns.amazonaws.com`. For Amazon Web Services services, you can also
#' specify the ARN of the associated resource as the `SourceArn`. If you
#' grant permission to a service principal without specifying the source,
#' other accounts could potentially configure resources in their account to
#' invoke your Lambda function.
#' 
#' This operation adds a statement to a resource-based permissions policy
#' for the function. For more information about function policies, see
#' [Using resource-based policies for
#' Lambda](https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html).
#'
#' @usage
#' lambda_add_permission(FunctionName, StatementId, Action, Principal,
#'   SourceArn, SourceAccount, EventSourceToken, Qualifier, RevisionId,
#'   PrincipalOrgID, FunctionUrlAuthType, InvokedViaFunctionUrl)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param StatementId &#91;required&#93; A statement identifier that differentiates the statement from others in
#' the same policy.
#' @param Action &#91;required&#93; The action that the principal can use on the function. For example,
#' `lambda:InvokeFunction` or `lambda:GetFunction`.
#' @param Principal &#91;required&#93; The Amazon Web Services service, Amazon Web Services account, IAM user,
#' or IAM role that invokes the function. If you specify a service, use
#' `SourceArn` or `SourceAccount` to limit who can invoke the function
#' through that service.
#' @param SourceArn For Amazon Web Services services, the ARN of the Amazon Web Services
#' resource that invokes the function. For example, an Amazon S3 bucket or
#' Amazon SNS topic.
#' 
#' Note that Lambda configures the comparison using the `StringLike`
#' operator.
#' @param SourceAccount For Amazon Web Services service, the ID of the Amazon Web Services
#' account that owns the resource. Use this together with `SourceArn` to
#' ensure that the specified account owns the resource. It is possible for
#' an Amazon S3 bucket to be deleted by its owner and recreated by another
#' account.
#' @param EventSourceToken For Alexa Smart Home functions, a token that the invoker must supply.
#' @param Qualifier Specify a version or alias to add permissions to a published version of
#' the function.
#' @param RevisionId Update the policy only if the revision ID matches the ID that's
#' specified. Use this option to avoid modifying a policy that has changed
#' since you last read it.
#' @param PrincipalOrgID The identifier for your organization in Organizations. Use this to grant
#' permissions to all the Amazon Web Services accounts under this
#' organization.
#' @param FunctionUrlAuthType The type of authentication that your function URL uses. Set to `AWS_IAM`
#' if you want to restrict access to authenticated users only. Set to
#' `NONE` if you want to bypass IAM authentication to create a public
#' endpoint. For more information, see [Control access to Lambda function
#' URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
#' @param InvokedViaFunctionUrl Indicates whether the permission applies when the function is invoked
#' through a function URL.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Statement = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$add_permission(
#'   FunctionName = "string",
#'   StatementId = "string",
#'   Action = "string",
#'   Principal = "string",
#'   SourceArn = "string",
#'   SourceAccount = "string",
#'   EventSourceToken = "string",
#'   Qualifier = "string",
#'   RevisionId = "string",
#'   PrincipalOrgID = "string",
#'   FunctionUrlAuthType = "NONE"|"AWS_IAM",
#'   InvokedViaFunctionUrl = TRUE|FALSE
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example adds permission for Amazon S3 to invoke a Lambda
#' # function named my-function for notifications from a bucket named
#' # my-bucket-1xpuxmplzrlbh in account 123456789012.
#' svc$add_permission(
#'   Action = "lambda:InvokeFunction",
#'   FunctionName = "my-function",
#'   Principal = "s3.amazonaws.com",
#'   SourceAccount = "123456789012",
#'   SourceArn = "arn:aws:s3:::my-bucket-1xpuxmplzrlbh/*",
#'   StatementId = "s3"
#' )
#' 
#' # The following example adds permission for account 223456789012 invoke a
#' # Lambda function named my-function.
#' svc$add_permission(
#'   Action = "lambda:InvokeFunction",
#'   FunctionName = "my-function",
#'   Principal = "223456789012",
#'   StatementId = "xaccount"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_add_permission
#'
#' @aliases lambda_add_permission
lambda_add_permission <- function(FunctionName, StatementId, Action, Principal, SourceArn = NULL, SourceAccount = NULL, EventSourceToken = NULL, Qualifier = NULL, RevisionId = NULL, PrincipalOrgID = NULL, FunctionUrlAuthType = NULL, InvokedViaFunctionUrl = NULL) {
  op <- new_operation(
    name = "AddPermission",
    http_method = "POST",
    http_path = "/2015-03-31/functions/{FunctionName}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$add_permission_input(FunctionName = FunctionName, StatementId = StatementId, Action = Action, Principal = Principal, SourceArn = SourceArn, SourceAccount = SourceAccount, EventSourceToken = EventSourceToken, Qualifier = Qualifier, RevisionId = RevisionId, PrincipalOrgID = PrincipalOrgID, FunctionUrlAuthType = FunctionUrlAuthType, InvokedViaFunctionUrl = InvokedViaFunctionUrl)
  output <- .lambda$add_permission_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$add_permission <- lambda_add_permission

#' Saves the progress of a durable function execution during runtime
#'
#' @description
#' Saves the progress of a [durable
#' function](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html)
#' execution during runtime. This API is used by the Lambda durable
#' functions SDK to checkpoint completed steps and schedule asynchronous
#' operations. You typically don't need to call this API directly as the
#' SDK handles checkpointing automatically.
#' 
#' Each checkpoint operation consumes the current checkpoint token and
#' returns a new one for the next checkpoint. This ensures that checkpoints
#' are applied in the correct order and prevents duplicate or out-of-order
#' state updates.
#'
#' @usage
#' lambda_checkpoint_durable_execution(DurableExecutionArn,
#'   CheckpointToken, Updates, ClientToken)
#'
#' @param DurableExecutionArn &#91;required&#93; The Amazon Resource Name (ARN) of the durable execution.
#' @param CheckpointToken &#91;required&#93; A unique token that identifies the current checkpoint state. This token
#' is provided by the Lambda runtime and must be used to ensure checkpoints
#' are applied in the correct order. Each checkpoint operation consumes
#' this token and returns a new one.
#' @param Updates An array of state updates to apply during this checkpoint. Each update
#' represents a change to the execution state, such as completing a step,
#' starting a callback, or scheduling a timer. Updates are applied
#' atomically as part of the checkpoint operation.
#' @param ClientToken An optional idempotency token to ensure that duplicate checkpoint
#' requests are handled correctly. If provided, Lambda uses this token to
#' detect and handle duplicate requests within a 15-minute window.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CheckpointToken = "string",
#'   NewExecutionState = list(
#'     Operations = list(
#'       list(
#'         Id = "string",
#'         ParentId = "string",
#'         Name = "string",
#'         Type = "EXECUTION"|"CONTEXT"|"STEP"|"WAIT"|"CALLBACK"|"CHAINED_INVOKE",
#'         SubType = "string",
#'         StartTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         EndTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Status = "STARTED"|"PENDING"|"READY"|"SUCCEEDED"|"FAILED"|"CANCELLED"|"TIMED_OUT"|"STOPPED",
#'         ExecutionDetails = list(
#'           InputPayload = "string"
#'         ),
#'         ContextDetails = list(
#'           ReplayChildren = TRUE|FALSE,
#'           Result = "string",
#'           Error = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         StepDetails = list(
#'           Attempt = 123,
#'           NextAttemptTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           Result = "string",
#'           Error = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         WaitDetails = list(
#'           ScheduledEndTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         CallbackDetails = list(
#'           CallbackId = "string",
#'           Result = "string",
#'           Error = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         ChainedInvokeDetails = list(
#'           Result = "string",
#'           Error = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     NextMarker = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$checkpoint_durable_execution(
#'   DurableExecutionArn = "string",
#'   CheckpointToken = "string",
#'   Updates = list(
#'     list(
#'       Id = "string",
#'       ParentId = "string",
#'       Name = "string",
#'       Type = "EXECUTION"|"CONTEXT"|"STEP"|"WAIT"|"CALLBACK"|"CHAINED_INVOKE",
#'       SubType = "string",
#'       Action = "START"|"SUCCEED"|"FAIL"|"RETRY"|"CANCEL",
#'       Payload = "string",
#'       Error = list(
#'         ErrorMessage = "string",
#'         ErrorType = "string",
#'         ErrorData = "string",
#'         StackTrace = list(
#'           "string"
#'         )
#'       ),
#'       ContextOptions = list(
#'         ReplayChildren = TRUE|FALSE
#'       ),
#'       StepOptions = list(
#'         NextAttemptDelaySeconds = 123
#'       ),
#'       WaitOptions = list(
#'         WaitSeconds = 123
#'       ),
#'       CallbackOptions = list(
#'         TimeoutSeconds = 123,
#'         HeartbeatTimeoutSeconds = 123
#'       ),
#'       ChainedInvokeOptions = list(
#'         FunctionName = "string",
#'         TenantId = "string"
#'       )
#'     )
#'   ),
#'   ClientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_checkpoint_durable_execution
#'
#' @aliases lambda_checkpoint_durable_execution
lambda_checkpoint_durable_execution <- function(DurableExecutionArn, CheckpointToken, Updates = NULL, ClientToken = NULL) {
  op <- new_operation(
    name = "CheckpointDurableExecution",
    http_method = "POST",
    http_path = "/2025-12-01/durable-executions/{DurableExecutionArn}/checkpoint",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$checkpoint_durable_execution_input(DurableExecutionArn = DurableExecutionArn, CheckpointToken = CheckpointToken, Updates = Updates, ClientToken = ClientToken)
  output <- .lambda$checkpoint_durable_execution_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$checkpoint_durable_execution <- lambda_checkpoint_durable_execution

#' Creates an alias for a Lambda function version
#'
#' @description
#' Creates an
#' [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html)
#' for a Lambda function version. Use aliases to provide clients with a
#' function identifier that you can update to invoke a different version.
#' 
#' You can also map an alias to split invocation requests between two
#' versions. Use the `RoutingConfig` parameter to specify a second version
#' and the percentage of invocation requests that it receives.
#'
#' @usage
#' lambda_create_alias(FunctionName, Name, FunctionVersion, Description,
#'   RoutingConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Name &#91;required&#93; The name of the alias.
#' @param FunctionVersion &#91;required&#93; The function version that the alias invokes.
#' @param Description A description of the alias.
#' @param RoutingConfig The [routing
#' configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing)
#' of the alias.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AliasArn = "string",
#'   Name = "string",
#'   FunctionVersion = "string",
#'   Description = "string",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       123.0
#'     )
#'   ),
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_alias(
#'   FunctionName = "string",
#'   Name = "string",
#'   FunctionVersion = "string",
#'   Description = "string",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       123.0
#'     )
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates an alias named LIVE that points to version
#' # 1 of the my-function Lambda function.
#' svc$create_alias(
#'   Description = "alias for live version of function",
#'   FunctionName = "my-function",
#'   FunctionVersion = "1",
#'   Name = "LIVE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_create_alias
#'
#' @aliases lambda_create_alias
lambda_create_alias <- function(FunctionName, Name, FunctionVersion, Description = NULL, RoutingConfig = NULL) {
  op <- new_operation(
    name = "CreateAlias",
    http_method = "POST",
    http_path = "/2015-03-31/functions/{FunctionName}/aliases",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_alias_input(FunctionName = FunctionName, Name = Name, FunctionVersion = FunctionVersion, Description = Description, RoutingConfig = RoutingConfig)
  output <- .lambda$create_alias_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_alias <- lambda_create_alias

#' Creates a capacity provider that manages compute resources for Lambda
#' functions
#'
#' @description
#' Creates a capacity provider that manages compute resources for Lambda
#' functions
#'
#' @usage
#' lambda_create_capacity_provider(CapacityProviderName, VpcConfig,
#'   PermissionsConfig, InstanceRequirements, CapacityProviderScalingConfig,
#'   KmsKeyArn, Tags)
#'
#' @param CapacityProviderName &#91;required&#93; The name of the capacity provider.
#' @param VpcConfig &#91;required&#93; The VPC configuration for the capacity provider, including subnet IDs
#' and security group IDs where compute instances will be launched.
#' @param PermissionsConfig &#91;required&#93; The permissions configuration that specifies the IAM role ARN used by
#' the capacity provider to manage compute resources.
#' @param InstanceRequirements The instance requirements that specify the compute instance
#' characteristics, including architectures and allowed or excluded
#' instance types.
#' @param CapacityProviderScalingConfig The scaling configuration that defines how the capacity provider scales
#' compute instances, including maximum vCPU count and scaling policies.
#' @param KmsKeyArn The ARN of the KMS key used to encrypt data associated with the capacity
#' provider.
#' @param Tags A list of tags to associate with the capacity provider.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProvider = list(
#'     CapacityProviderArn = "string",
#'     State = "Pending"|"Active"|"Failed"|"Deleting",
#'     VpcConfig = list(
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       SecurityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     PermissionsConfig = list(
#'       CapacityProviderOperatorRoleArn = "string"
#'     ),
#'     InstanceRequirements = list(
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       AllowedInstanceTypes = list(
#'         "string"
#'       ),
#'       ExcludedInstanceTypes = list(
#'         "string"
#'       )
#'     ),
#'     CapacityProviderScalingConfig = list(
#'       MaxVCpuCount = 123,
#'       ScalingMode = "Auto"|"Manual",
#'       ScalingPolicies = list(
#'         list(
#'           PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'           TargetValue = 123.0
#'         )
#'       )
#'     ),
#'     KmsKeyArn = "string",
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_capacity_provider(
#'   CapacityProviderName = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   PermissionsConfig = list(
#'     CapacityProviderOperatorRoleArn = "string"
#'   ),
#'   InstanceRequirements = list(
#'     Architectures = list(
#'       "x86_64"|"arm64"
#'     ),
#'     AllowedInstanceTypes = list(
#'       "string"
#'     ),
#'     ExcludedInstanceTypes = list(
#'       "string"
#'     )
#'   ),
#'   CapacityProviderScalingConfig = list(
#'     MaxVCpuCount = 123,
#'     ScalingMode = "Auto"|"Manual",
#'     ScalingPolicies = list(
#'       list(
#'         PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'         TargetValue = 123.0
#'       )
#'     )
#'   ),
#'   KmsKeyArn = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_create_capacity_provider
#'
#' @aliases lambda_create_capacity_provider
lambda_create_capacity_provider <- function(CapacityProviderName, VpcConfig, PermissionsConfig, InstanceRequirements = NULL, CapacityProviderScalingConfig = NULL, KmsKeyArn = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateCapacityProvider",
    http_method = "POST",
    http_path = "/2025-11-30/capacity-providers",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_capacity_provider_input(CapacityProviderName = CapacityProviderName, VpcConfig = VpcConfig, PermissionsConfig = PermissionsConfig, InstanceRequirements = InstanceRequirements, CapacityProviderScalingConfig = CapacityProviderScalingConfig, KmsKeyArn = KmsKeyArn, Tags = Tags)
  output <- .lambda$create_capacity_provider_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_capacity_provider <- lambda_create_capacity_provider

#' Creates a code signing configuration
#'
#' @description
#' Creates a code signing configuration. A [code signing
#' configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html)
#' defines a list of allowed signing profiles and defines the code-signing
#' validation policy (action to be taken if deployment validation checks
#' fail).
#'
#' @usage
#' lambda_create_code_signing_config(Description, AllowedPublishers,
#'   CodeSigningPolicies, Tags)
#'
#' @param Description Descriptive name for this code signing configuration.
#' @param AllowedPublishers &#91;required&#93; Signing profiles for this code signing configuration.
#' @param CodeSigningPolicies The code signing policies define the actions to take if the validation
#' checks fail.
#' @param Tags A list of tags to add to the code signing configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeSigningConfig = list(
#'     CodeSigningConfigId = "string",
#'     CodeSigningConfigArn = "string",
#'     Description = "string",
#'     AllowedPublishers = list(
#'       SigningProfileVersionArns = list(
#'         "string"
#'       )
#'     ),
#'     CodeSigningPolicies = list(
#'       UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'     ),
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_code_signing_config(
#'   Description = "string",
#'   AllowedPublishers = list(
#'     SigningProfileVersionArns = list(
#'       "string"
#'     )
#'   ),
#'   CodeSigningPolicies = list(
#'     UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'   ),
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_create_code_signing_config
#'
#' @aliases lambda_create_code_signing_config
lambda_create_code_signing_config <- function(Description = NULL, AllowedPublishers, CodeSigningPolicies = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateCodeSigningConfig",
    http_method = "POST",
    http_path = "/2020-04-22/code-signing-configs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_code_signing_config_input(Description = Description, AllowedPublishers = AllowedPublishers, CodeSigningPolicies = CodeSigningPolicies, Tags = Tags)
  output <- .lambda$create_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_code_signing_config <- lambda_create_code_signing_config

#' Creates a mapping between an event source and an Lambda function
#'
#' @description
#' Creates a mapping between an event source and an Lambda function. Lambda
#' reads items from the event source and invokes the function.
#' 
#' For details about how to configure different event sources, see the
#' following topics.
#' 
#' -   [Amazon DynamoDB
#'     Streams](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-dynamodb-eventsourcemapping)
#' 
#' -   [Amazon
#'     Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-eventsourcemapping)
#' 
#' -   [Amazon
#'     SQS](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-eventsource)
#' 
#' -   [Amazon MQ and
#'     RabbitMQ](https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html#services-mq-eventsourcemapping)
#' 
#' -   [Amazon
#'     MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html)
#' 
#' -   [Apache
#'     Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html)
#' 
#' -   [Amazon
#'     DocumentDB](https://docs.aws.amazon.com/lambda/latest/dg/with-documentdb.html)
#' 
#' The following error handling options are available for stream sources
#' (DynamoDB, Kinesis, Amazon MSK, and self-managed Apache Kafka):
#' 
#' -   `BisectBatchOnFunctionError` – If the function returns an error,
#'     split the batch in two and retry.
#' 
#' -   `MaximumRecordAgeInSeconds` – Discard records older than the
#'     specified age. The default value is infinite (-1). When set to
#'     infinite (-1), failed records are retried until the record expires
#' 
#' -   `MaximumRetryAttempts` – Discard records after the specified number
#'     of retries. The default value is infinite (-1). When set to infinite
#'     (-1), failed records are retried until the record expires.
#' 
#' -   `OnFailure` – Send discarded records to an Amazon SQS queue, Amazon
#'     SNS topic, Kafka topic, or Amazon S3 bucket. For more information,
#'     see [Adding a
#'     destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
#' 
#' The following option is available only for DynamoDB and Kinesis event
#' sources:
#' 
#' -   `ParallelizationFactor` – Process multiple batches from each shard
#'     concurrently.
#' 
#' For information about which configuration parameters apply to each event
#' source, see the following topics.
#' 
#' -   [Amazon DynamoDB
#'     Streams](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-params)
#' 
#' -   [Amazon
#'     Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-params)
#' 
#' -   [Amazon
#'     SQS](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#services-sqs-params)
#' 
#' -   [Amazon MQ and
#'     RabbitMQ](https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html#services-mq-params)
#' 
#' -   [Amazon
#'     MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-parms)
#' 
#' -   [Apache
#'     Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-kafka-parms)
#' 
#' -   [Amazon
#'     DocumentDB](https://docs.aws.amazon.com/lambda/latest/dg/with-documentdb.html#docdb-configuration)
#'
#' @usage
#' lambda_create_event_source_mapping(EventSourceArn, FunctionName,
#'   Enabled, BatchSize, FilterCriteria, MaximumBatchingWindowInSeconds,
#'   ParallelizationFactor, StartingPosition, StartingPositionTimestamp,
#'   DestinationConfig, MaximumRecordAgeInSeconds,
#'   BisectBatchOnFunctionError, MaximumRetryAttempts, Tags,
#'   TumblingWindowInSeconds, Topics, Queues, SourceAccessConfigurations,
#'   SelfManagedEventSource, FunctionResponseTypes,
#'   AmazonManagedKafkaEventSourceConfig, SelfManagedKafkaEventSourceConfig,
#'   ScalingConfig, DocumentDBEventSourceConfig, KMSKeyArn, MetricsConfig,
#'   ProvisionedPollerConfig)
#'
#' @param EventSourceArn The Amazon Resource Name (ARN) of the event source.
#' 
#' -   **Amazon Kinesis** – The ARN of the data stream or a stream
#'     consumer.
#' 
#' -   **Amazon DynamoDB Streams** – The ARN of the stream.
#' 
#' -   **Amazon Simple Queue Service** – The ARN of the queue.
#' 
#' -   **Amazon Managed Streaming for Apache Kafka** – The ARN of the
#'     cluster or the ARN of the VPC connection (for [cross-account event
#'     source
#'     mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
#' 
#' -   **Amazon MQ** – The ARN of the broker.
#' 
#' -   **Amazon DocumentDB** – The ARN of the DocumentDB change stream.
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `MyFunction`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Version or Alias ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD`.
#' 
#' -   **Partial ARN** – `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it's limited to 64 characters in length.
#' @param Enabled When true, the event source mapping is active. When false, Lambda pauses
#' polling and invocation.
#' 
#' Default: True
#' @param BatchSize The maximum number of records in each batch that Lambda pulls from your
#' stream or queue and sends to your function. Lambda passes all of the
#' records in the batch to the function in a single call, up to the payload
#' limit for synchronous invocation (6 MB).
#' 
#' -   **Amazon Kinesis** – Default 100. Max 10,000.
#' 
#' -   **Amazon DynamoDB Streams** – Default 100. Max 10,000.
#' 
#' -   **Amazon Simple Queue Service** – Default 10. For standard queues
#'     the max is 10,000. For FIFO queues the max is 10.
#' 
#' -   **Amazon Managed Streaming for Apache Kafka** – Default 100. Max
#'     10,000.
#' 
#' -   **Self-managed Apache Kafka** – Default 100. Max 10,000.
#' 
#' -   **Amazon MQ (ActiveMQ and RabbitMQ)** – Default 100. Max 10,000.
#' 
#' -   **DocumentDB** – Default 100. Max 10,000.
#' @param FilterCriteria An object that defines the filter criteria that determine whether Lambda
#' should process an event. For more information, see [Lambda event
#' filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
#' @param MaximumBatchingWindowInSeconds The maximum amount of time, in seconds, that Lambda spends gathering
#' records before invoking the function. You can configure
#' `MaximumBatchingWindowInSeconds` to any value from 0 seconds to 300
#' seconds in increments of seconds.
#' 
#' For Kinesis, DynamoDB, and Amazon SQS event sources, the default
#' batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka,
#' Amazon MQ, and DocumentDB event sources, the default batching window is
#' 500 ms. Note that because you can only change
#' `MaximumBatchingWindowInSeconds` in increments of seconds, you cannot
#' revert back to the 500 ms default batching window after you have changed
#' it. To restore the default batching window, you must create a new event
#' source mapping.
#' 
#' Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources,
#' when you set `BatchSize` to a value greater than 10, you must set
#' `MaximumBatchingWindowInSeconds` to at least 1.
#' @param ParallelizationFactor (Kinesis and DynamoDB Streams only) The number of batches to process
#' from each shard concurrently.
#' @param StartingPosition The position in a stream from which to start reading. Required for
#' Amazon Kinesis and Amazon DynamoDB Stream event sources. `AT_TIMESTAMP`
#' is supported only for Amazon Kinesis streams, Amazon DocumentDB, Amazon
#' MSK, and self-managed Apache Kafka.
#' @param StartingPositionTimestamp With `StartingPosition` set to `AT_TIMESTAMP`, the time from which to
#' start reading. `StartingPositionTimestamp` cannot be in the future.
#' @param DestinationConfig (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A
#' configuration object that specifies the destination of an event after
#' Lambda processes it.
#' @param MaximumRecordAgeInSeconds (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' Discard records older than the specified age. The default value is
#' infinite (-1).
#' @param BisectBatchOnFunctionError (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' If the function returns an error, split the batch in two and retry.
#' @param MaximumRetryAttempts (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' Discard records after the specified number of retries. The default value
#' is infinite (-1). When set to infinite (-1), failed records are retried
#' until the record expires.
#' @param Tags A list of tags to apply to the event source mapping.
#' @param TumblingWindowInSeconds (Kinesis and DynamoDB Streams only) The duration in seconds of a
#' processing window for DynamoDB and Kinesis Streams event sources. A
#' value of 0 seconds indicates no tumbling window.
#' @param Topics The name of the Kafka topic.
#' @param Queues (MQ) The name of the Amazon MQ broker destination queue to consume.
#' @param SourceAccessConfigurations An array of authentication protocols or VPC components required to
#' secure your event source.
#' @param SelfManagedEventSource The self-managed Apache Kafka cluster to receive records from.
#' @param FunctionResponseTypes (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and
#' Amazon SQS) A list of current response type enums applied to the event
#' source mapping.
#' @param AmazonManagedKafkaEventSourceConfig Specific configuration settings for an Amazon Managed Streaming for
#' Apache Kafka (Amazon MSK) event source.
#' @param SelfManagedKafkaEventSourceConfig Specific configuration settings for a self-managed Apache Kafka event
#' source.
#' @param ScalingConfig (Amazon SQS only) The scaling configuration for the event source. For
#' more information, see [Configuring maximum concurrency for Amazon SQS
#' event
#' sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
#' @param DocumentDBEventSourceConfig Specific configuration settings for a DocumentDB event source.
#' @param KMSKeyArn The ARN of the Key Management Service (KMS) customer managed key that
#' Lambda uses to encrypt your function's [filter
#' criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
#' By default, Lambda does not encrypt your filter criteria object. Specify
#' this property to encrypt data using your own customer managed key.
#' @param MetricsConfig The metrics configuration for your event source. For more information,
#' see [Event source mapping
#' metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
#' @param ProvisionedPollerConfig (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The
#' provisioned mode configuration for the event source. For more
#' information, see [provisioned
#' mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UUID = "string",
#'   StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'   StartingPositionTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BatchSize = 123,
#'   MaximumBatchingWindowInSeconds = 123,
#'   ParallelizationFactor = 123,
#'   EventSourceArn = "string",
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   FunctionArn = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastProcessingResult = "string",
#'   State = "string",
#'   StateTransitionReason = "string",
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   Topics = list(
#'     "string"
#'   ),
#'   Queues = list(
#'     "string"
#'   ),
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   SelfManagedEventSource = list(
#'     Endpoints = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   TumblingWindowInSeconds = 123,
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   FilterCriteriaError = list(
#'     ErrorCode = "string",
#'     Message = "string"
#'   ),
#'   EventSourceMappingArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_event_source_mapping(
#'   EventSourceArn = "string",
#'   FunctionName = "string",
#'   Enabled = TRUE|FALSE,
#'   BatchSize = 123,
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   MaximumBatchingWindowInSeconds = 123,
#'   ParallelizationFactor = 123,
#'   StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'   StartingPositionTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   Tags = list(
#'     "string"
#'   ),
#'   TumblingWindowInSeconds = 123,
#'   Topics = list(
#'     "string"
#'   ),
#'   Queues = list(
#'     "string"
#'   ),
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   SelfManagedEventSource = list(
#'     Endpoints = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates a mapping between an SQS queue and the
#' # my-function Lambda function.
#' svc$create_event_source_mapping(
#'   BatchSize = 5L,
#'   EventSourceArn = "arn:aws:sqs:us-west-2:123456789012:my-queue",
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_create_event_source_mapping
#'
#' @aliases lambda_create_event_source_mapping
lambda_create_event_source_mapping <- function(EventSourceArn = NULL, FunctionName, Enabled = NULL, BatchSize = NULL, FilterCriteria = NULL, MaximumBatchingWindowInSeconds = NULL, ParallelizationFactor = NULL, StartingPosition = NULL, StartingPositionTimestamp = NULL, DestinationConfig = NULL, MaximumRecordAgeInSeconds = NULL, BisectBatchOnFunctionError = NULL, MaximumRetryAttempts = NULL, Tags = NULL, TumblingWindowInSeconds = NULL, Topics = NULL, Queues = NULL, SourceAccessConfigurations = NULL, SelfManagedEventSource = NULL, FunctionResponseTypes = NULL, AmazonManagedKafkaEventSourceConfig = NULL, SelfManagedKafkaEventSourceConfig = NULL, ScalingConfig = NULL, DocumentDBEventSourceConfig = NULL, KMSKeyArn = NULL, MetricsConfig = NULL, ProvisionedPollerConfig = NULL) {
  op <- new_operation(
    name = "CreateEventSourceMapping",
    http_method = "POST",
    http_path = "/2015-03-31/event-source-mappings",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_event_source_mapping_input(EventSourceArn = EventSourceArn, FunctionName = FunctionName, Enabled = Enabled, BatchSize = BatchSize, FilterCriteria = FilterCriteria, MaximumBatchingWindowInSeconds = MaximumBatchingWindowInSeconds, ParallelizationFactor = ParallelizationFactor, StartingPosition = StartingPosition, StartingPositionTimestamp = StartingPositionTimestamp, DestinationConfig = DestinationConfig, MaximumRecordAgeInSeconds = MaximumRecordAgeInSeconds, BisectBatchOnFunctionError = BisectBatchOnFunctionError, MaximumRetryAttempts = MaximumRetryAttempts, Tags = Tags, TumblingWindowInSeconds = TumblingWindowInSeconds, Topics = Topics, Queues = Queues, SourceAccessConfigurations = SourceAccessConfigurations, SelfManagedEventSource = SelfManagedEventSource, FunctionResponseTypes = FunctionResponseTypes, AmazonManagedKafkaEventSourceConfig = AmazonManagedKafkaEventSourceConfig, SelfManagedKafkaEventSourceConfig = SelfManagedKafkaEventSourceConfig, ScalingConfig = ScalingConfig, DocumentDBEventSourceConfig = DocumentDBEventSourceConfig, KMSKeyArn = KMSKeyArn, MetricsConfig = MetricsConfig, ProvisionedPollerConfig = ProvisionedPollerConfig)
  output <- .lambda$create_event_source_mapping_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_event_source_mapping <- lambda_create_event_source_mapping

#' Creates a Lambda function
#'
#' @description
#' Creates a Lambda function. To create a function, you need a [deployment
#' package](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-zip.html)
#' and an [execution
#' role](https://docs.aws.amazon.com/lambda/latest/dg/lambda-permissions.html#lambda-intro-execution-role).
#' The deployment package is a .zip file archive or container image that
#' contains your function code. The execution role grants the function
#' permission to use Amazon Web Services services, such as Amazon
#' CloudWatch Logs for log streaming and X-Ray for request tracing.
#' 
#' If the deployment package is a [container
#' image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html),
#' then you set the package type to `Image`. For a container image, the
#' code property must include the URI of a container image in the Amazon
#' ECR registry. You do not need to specify the handler and runtime
#' properties.
#' 
#' If the deployment package is a [.zip file
#' archive](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-zip.html#gettingstarted-package-zip),
#' then you set the package type to `Zip`. For a .zip file archive, the
#' code property specifies the location of the .zip file. You must also
#' specify the handler and runtime properties. The code in the deployment
#' package must be compatible with the target instruction set architecture
#' of the function (`x86-64` or `arm64`). If you do not specify the
#' architecture, then the default value is `x86-64`.
#' 
#' When you create a function, Lambda provisions an instance of the
#' function and its supporting resources. If your function connects to a
#' VPC, this process can take a minute or so. During this time, you can't
#' invoke or modify the function. The `State`, `StateReason`, and
#' `StateReasonCode` fields in the response from
#' [`get_function_configuration`][lambda_get_function_configuration]
#' indicate when the function is ready to invoke. For more information, see
#' [Lambda function
#' states](https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html).
#' 
#' A function has an unpublished version, and can have published versions
#' and aliases. The unpublished version changes when you update your
#' function's code and configuration. A published version is a snapshot of
#' your function code and configuration that can't be changed. An alias is
#' a named resource that maps to a version, and can be changed to map to a
#' different version. Use the `Publish` parameter to create version `1` of
#' your function from its initial configuration.
#' 
#' The other parameters let you configure version-specific and
#' function-level settings. You can modify version-specific settings later
#' with
#' [`update_function_configuration`][lambda_update_function_configuration].
#' Function-level settings apply to both the unpublished and published
#' versions of the function, and include tags
#' ([`tag_resource`][lambda_tag_resource]) and per-function concurrency
#' limits ([`put_function_concurrency`][lambda_put_function_concurrency]).
#' 
#' You can use code signing if your deployment package is a .zip file
#' archive. To enable code signing for this function, specify the ARN of a
#' code-signing configuration. When a user attempts to deploy a code
#' package with [`update_function_code`][lambda_update_function_code],
#' Lambda checks that the code package has a valid signature from a trusted
#' publisher. The code-signing configuration includes set of signing
#' profiles, which define the trusted publishers for this function.
#' 
#' If another Amazon Web Services account or an Amazon Web Services service
#' invokes your function, use [`add_permission`][lambda_add_permission] to
#' grant permission by creating a resource-based Identity and Access
#' Management (IAM) policy. You can grant permissions at the function
#' level, on a version, or on an alias.
#' 
#' To invoke your function directly, use [`invoke`][lambda_invoke]. To
#' invoke your function in response to events in other Amazon Web Services
#' services, create an event source mapping
#' ([`create_event_source_mapping`][lambda_create_event_source_mapping]),
#' or configure a function trigger in the other service. For more
#' information, see [Invoking Lambda
#' functions](https://docs.aws.amazon.com/lambda/latest/dg/lambda-invocation.html).
#'
#' @usage
#' lambda_create_function(FunctionName, Runtime, Role, Handler, Code,
#'   Description, Timeout, MemorySize, Publish, VpcConfig, PackageType,
#'   DeadLetterConfig, Environment, KMSKeyArn, TracingConfig, Tags, Layers,
#'   FileSystemConfigs, ImageConfig, CodeSigningConfigArn, Architectures,
#'   EphemeralStorage, SnapStart, LoggingConfig, CapacityProviderConfig,
#'   PublishTo, DurableConfig, TenancyConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Runtime The identifier of the function's
#' [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).
#' Runtime is required if the deployment package is a .zip file archive.
#' Specifying a runtime results in an error if you're deploying a function
#' using a container image.
#' 
#' The following list includes deprecated runtimes. Lambda blocks creating
#' new functions and updating existing functions shortly after each runtime
#' is deprecated. For more information, see [Runtime use after
#' deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels).
#' 
#' For a list of all currently supported runtimes, see [Supported
#' runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
#' @param Role &#91;required&#93; The Amazon Resource Name (ARN) of the function's execution role.
#' @param Handler The name of the method within your code that Lambda calls to run your
#' function. Handler is required if the deployment package is a .zip file
#' archive. The format includes the file name. It can also include
#' namespaces and other qualifiers, depending on the runtime. For more
#' information, see [Lambda programming
#' model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
#' @param Code &#91;required&#93; The code for the function.
#' @param Description A description of the function.
#' @param Timeout The amount of time (in seconds) that Lambda allows a function to run
#' before stopping it. The default is 3 seconds. The maximum allowed value
#' is 900 seconds. For more information, see [Lambda execution
#' environment](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html).
#' @param MemorySize The amount of [memory available to the
#' function](https://docs.aws.amazon.com/lambda/latest/dg/lambda-functions.html#configuration-memory-console)
#' at runtime. Increasing the function memory also increases its CPU
#' allocation. The default value is 128 MB. The value can be any multiple
#' of 1 MB.
#' @param Publish Set to true to publish the first version of the function during
#' creation.
#' @param VpcConfig For network connectivity to Amazon Web Services resources in a VPC,
#' specify a list of security groups and subnets in the VPC. When you
#' connect a function to a VPC, it can access resources and the internet
#' only through that VPC. For more information, see [Configuring a Lambda
#' function to access resources in a
#' VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
#' @param PackageType The type of deployment package. Set to `Image` for container image and
#' set to `Zip` for .zip file archive.
#' @param DeadLetterConfig A dead-letter queue configuration that specifies the queue or topic
#' where Lambda sends asynchronous events when they fail processing. For
#' more information, see [Dead-letter
#' queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
#' @param Environment Environment variables that are accessible from function code during
#' execution.
#' @param KMSKeyArn The ARN of the Key Management Service (KMS) customer managed key that's
#' used to encrypt the following resources:
#' 
#' -   The function's [environment
#'     variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
#' 
#' -   The function's [Lambda
#'     SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html)
#'     snapshots.
#' 
#' -   When used with `SourceKMSKeyArn`, the unzipped version of the .zip
#'     deployment package that's used for function invocations. For more
#'     information, see [Specifying a customer managed key for
#'     Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
#' 
#' -   The optimized version of the container image that's used for
#'     function invocations. Note that this is not the same key that's used
#'     to protect your container image in the Amazon Elastic Container
#'     Registry (Amazon ECR). For more information, see [Function
#'     lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
#' 
#' If you don't provide a customer managed key, Lambda uses an [Amazon Web
#' Services owned
#' key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk)
#' or an [Amazon Web Services managed
#' key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
#' @param TracingConfig Set `Mode` to `Active` to sample and trace a subset of incoming requests
#' with
#' [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
#' @param Tags A list of
#' [tags](https://docs.aws.amazon.com/lambda/latest/dg/configuration-tags.html)
#' to apply to the function.
#' @param Layers A list of [function
#' layers](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)
#' to add to the function's execution environment. Specify each layer by
#' its ARN, including the version.
#' @param FileSystemConfigs Connection settings for an Amazon EFS file system.
#' @param ImageConfig Container image [configuration
#' values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms)
#' that override the values in the container image Dockerfile.
#' @param CodeSigningConfigArn To enable code signing for this function, specify the ARN of a
#' code-signing configuration. A code-signing configuration includes a set
#' of signing profiles, which define the trusted publishers for this
#' function.
#' @param Architectures The instruction set architecture that the function supports. Enter a
#' string array with one of the valid values (arm64 or x86_64). The default
#' value is `x86_64`.
#' @param EphemeralStorage The size of the function's `/tmp` directory in MB. The default value is
#' 512, but can be any whole number between 512 and 10,240 MB. For more
#' information, see [Configuring ephemeral storage
#' (console)](https://docs.aws.amazon.com/lambda/latest/dg/lambda-functions.html#configuration-ephemeral-storage).
#' @param SnapStart The function's
#' [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html)
#' setting.
#' @param LoggingConfig The function's Amazon CloudWatch Logs configuration settings.
#' @param CapacityProviderConfig Configuration for the capacity provider that manages compute resources
#' for Lambda functions.
#' @param PublishTo Specifies where to publish the function version or configuration.
#' @param DurableConfig Configuration settings for durable functions. Enables creating functions
#' with durability that can remember their state and continue execution
#' even after interruptions.
#' @param TenancyConfig Configuration for multi-tenant applications that use Lambda functions.
#' Defines tenant isolation settings and resource allocations. Required for
#' functions supporting multiple tenants.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionName = "string",
#'   FunctionArn = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   CodeSize = 123,
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   LastModified = "string",
#'   CodeSha256 = "string",
#'   Version = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     VpcId = "string",
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   MasterArn = "string",
#'   RevisionId = "string",
#'   Layers = list(
#'     list(
#'       Arn = "string",
#'       CodeSize = 123,
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string"
#'     )
#'   ),
#'   State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'   StateReason = "string",
#'   StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'   LastUpdateStatusReason = "string",
#'   LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   PackageType = "Zip"|"Image",
#'   ImageConfigResponse = list(
#'     ImageConfig = list(
#'       EntryPoint = list(
#'         "string"
#'       ),
#'       Command = list(
#'         "string"
#'       ),
#'       WorkingDirectory = "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   SigningProfileVersionArn = "string",
#'   SigningJobArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None",
#'     OptimizationStatus = "On"|"Off"
#'   ),
#'   RuntimeVersionConfig = list(
#'     RuntimeVersionArn = "string",
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   ConfigSha256 = "string",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_function(
#'   FunctionName = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   Code = list(
#'     ZipFile = raw,
#'     S3Bucket = "string",
#'     S3Key = "string",
#'     S3ObjectVersion = "string",
#'     ImageUri = "string",
#'     SourceKMSKeyArn = "string"
#'   ),
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   Publish = TRUE|FALSE,
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   PackageType = "Zip"|"Image",
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   Tags = list(
#'     "string"
#'   ),
#'   Layers = list(
#'     "string"
#'   ),
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   ImageConfig = list(
#'     EntryPoint = list(
#'       "string"
#'     ),
#'     Command = list(
#'       "string"
#'     ),
#'     WorkingDirectory = "string"
#'   ),
#'   CodeSigningConfigArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None"
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   PublishTo = "LATEST_PUBLISHED",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates a function with a deployment package in
#' # Amazon S3 and enables X-Ray tracing and environment variable encryption.
#' svc$create_function(
#'   Code = list(
#'     S3Bucket = "my-bucket-1xpuxmplzrlbh",
#'     S3Key = "function.zip"
#'   ),
#'   Description = "Process image objects from Amazon S3.",
#'   Environment = list(
#'     Variables = list(
#'       BUCKET = "my-bucket-1xpuxmplzrlbh",
#'       PREFIX = "inbound"
#'     )
#'   ),
#'   FunctionName = "my-function",
#'   Handler = "index.handler",
#'   KMSKeyArn = "arn:aws:kms:us-west-2:123456789012:key/b0844d6c-xmpl-4463-97a4-d49f50839966",
#'   MemorySize = 256L,
#'   Publish = TRUE,
#'   Role = "arn:aws:iam::123456789012:role/lambda-role",
#'   Runtime = "nodejs12.x",
#'   Tags = list(
#'     DEPARTMENT = "Assets"
#'   ),
#'   Timeout = 15L,
#'   TracingConfig = list(
#'     Mode = "Active"
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_create_function
#'
#' @aliases lambda_create_function
lambda_create_function <- function(FunctionName, Runtime = NULL, Role, Handler = NULL, Code, Description = NULL, Timeout = NULL, MemorySize = NULL, Publish = NULL, VpcConfig = NULL, PackageType = NULL, DeadLetterConfig = NULL, Environment = NULL, KMSKeyArn = NULL, TracingConfig = NULL, Tags = NULL, Layers = NULL, FileSystemConfigs = NULL, ImageConfig = NULL, CodeSigningConfigArn = NULL, Architectures = NULL, EphemeralStorage = NULL, SnapStart = NULL, LoggingConfig = NULL, CapacityProviderConfig = NULL, PublishTo = NULL, DurableConfig = NULL, TenancyConfig = NULL) {
  op <- new_operation(
    name = "CreateFunction",
    http_method = "POST",
    http_path = "/2015-03-31/functions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_function_input(FunctionName = FunctionName, Runtime = Runtime, Role = Role, Handler = Handler, Code = Code, Description = Description, Timeout = Timeout, MemorySize = MemorySize, Publish = Publish, VpcConfig = VpcConfig, PackageType = PackageType, DeadLetterConfig = DeadLetterConfig, Environment = Environment, KMSKeyArn = KMSKeyArn, TracingConfig = TracingConfig, Tags = Tags, Layers = Layers, FileSystemConfigs = FileSystemConfigs, ImageConfig = ImageConfig, CodeSigningConfigArn = CodeSigningConfigArn, Architectures = Architectures, EphemeralStorage = EphemeralStorage, SnapStart = SnapStart, LoggingConfig = LoggingConfig, CapacityProviderConfig = CapacityProviderConfig, PublishTo = PublishTo, DurableConfig = DurableConfig, TenancyConfig = TenancyConfig)
  output <- .lambda$create_function_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_function <- lambda_create_function

#' Creates a Lambda function URL with the specified configuration
#' parameters
#'
#' @description
#' Creates a Lambda function URL with the specified configuration
#' parameters. A function URL is a dedicated HTTP(S) endpoint that you can
#' use to invoke your function.
#'
#' @usage
#' lambda_create_function_url_config(FunctionName, Qualifier, AuthType,
#'   Cors, InvokeMode)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier The alias name.
#' @param AuthType &#91;required&#93; The type of authentication that your function URL uses. Set to `AWS_IAM`
#' if you want to restrict access to authenticated users only. Set to
#' `NONE` if you want to bypass IAM authentication to create a public
#' endpoint. For more information, see [Control access to Lambda function
#' URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
#' @param Cors The [cross-origin resource sharing
#' (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS)
#' settings for your function URL.
#' @param InvokeMode Use one of the following options:
#' 
#' -   `BUFFERED` – This is the default option. Lambda invokes your
#'     function using the [`invoke`][lambda_invoke] API operation.
#'     Invocation results are available when the payload is complete. The
#'     maximum payload size is 6 MB.
#' 
#' -   `RESPONSE_STREAM` – Your function streams payload results as they
#'     become available. Lambda invokes your function using the
#'     [`invoke_with_response_stream`][lambda_invoke_with_response_stream]
#'     API operation. The maximum response payload size is 200 MB.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionUrl = "string",
#'   FunctionArn = "string",
#'   AuthType = "NONE"|"AWS_IAM",
#'   Cors = list(
#'     AllowCredentials = TRUE|FALSE,
#'     AllowHeaders = list(
#'       "string"
#'     ),
#'     AllowMethods = list(
#'       "string"
#'     ),
#'     AllowOrigins = list(
#'       "string"
#'     ),
#'     ExposeHeaders = list(
#'       "string"
#'     ),
#'     MaxAge = 123
#'   ),
#'   CreationTime = "string",
#'   InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_function_url_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   AuthType = "NONE"|"AWS_IAM",
#'   Cors = list(
#'     AllowCredentials = TRUE|FALSE,
#'     AllowHeaders = list(
#'       "string"
#'     ),
#'     AllowMethods = list(
#'       "string"
#'     ),
#'     AllowOrigins = list(
#'       "string"
#'     ),
#'     ExposeHeaders = list(
#'       "string"
#'     ),
#'     MaxAge = 123
#'   ),
#'   InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_create_function_url_config
#'
#' @aliases lambda_create_function_url_config
lambda_create_function_url_config <- function(FunctionName, Qualifier = NULL, AuthType, Cors = NULL, InvokeMode = NULL) {
  op <- new_operation(
    name = "CreateFunctionUrlConfig",
    http_method = "POST",
    http_path = "/2021-10-31/functions/{FunctionName}/url",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$create_function_url_config_input(FunctionName = FunctionName, Qualifier = Qualifier, AuthType = AuthType, Cors = Cors, InvokeMode = InvokeMode)
  output <- .lambda$create_function_url_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$create_function_url_config <- lambda_create_function_url_config

#' Deletes a Lambda function alias
#'
#' @description
#' Deletes a Lambda function
#' [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
#'
#' @usage
#' lambda_delete_alias(FunctionName, Name)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Name &#91;required&#93; The name of the alias.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_alias(
#'   FunctionName = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes an alias named BLUE from a function named
#' # my-function
#' svc$delete_alias(
#'   FunctionName = "my-function",
#'   Name = "BLUE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_alias
#'
#' @aliases lambda_delete_alias
lambda_delete_alias <- function(FunctionName, Name) {
  op <- new_operation(
    name = "DeleteAlias",
    http_method = "DELETE",
    http_path = "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_alias_input(FunctionName = FunctionName, Name = Name)
  output <- .lambda$delete_alias_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_alias <- lambda_delete_alias

#' Deletes a capacity provider
#'
#' @description
#' Deletes a capacity provider. You cannot delete a capacity provider that
#' is currently being used by Lambda functions.
#'
#' @usage
#' lambda_delete_capacity_provider(CapacityProviderName)
#'
#' @param CapacityProviderName &#91;required&#93; The name of the capacity provider to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProvider = list(
#'     CapacityProviderArn = "string",
#'     State = "Pending"|"Active"|"Failed"|"Deleting",
#'     VpcConfig = list(
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       SecurityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     PermissionsConfig = list(
#'       CapacityProviderOperatorRoleArn = "string"
#'     ),
#'     InstanceRequirements = list(
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       AllowedInstanceTypes = list(
#'         "string"
#'       ),
#'       ExcludedInstanceTypes = list(
#'         "string"
#'       )
#'     ),
#'     CapacityProviderScalingConfig = list(
#'       MaxVCpuCount = 123,
#'       ScalingMode = "Auto"|"Manual",
#'       ScalingPolicies = list(
#'         list(
#'           PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'           TargetValue = 123.0
#'         )
#'       )
#'     ),
#'     KmsKeyArn = "string",
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_capacity_provider(
#'   CapacityProviderName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_delete_capacity_provider
#'
#' @aliases lambda_delete_capacity_provider
lambda_delete_capacity_provider <- function(CapacityProviderName) {
  op <- new_operation(
    name = "DeleteCapacityProvider",
    http_method = "DELETE",
    http_path = "/2025-11-30/capacity-providers/{CapacityProviderName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_capacity_provider_input(CapacityProviderName = CapacityProviderName)
  output <- .lambda$delete_capacity_provider_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_capacity_provider <- lambda_delete_capacity_provider

#' Deletes the code signing configuration
#'
#' @description
#' Deletes the code signing configuration. You can delete the code signing
#' configuration only if no function is using it.
#'
#' @usage
#' lambda_delete_code_signing_config(CodeSigningConfigArn)
#'
#' @param CodeSigningConfigArn &#91;required&#93; The The Amazon Resource Name (ARN) of the code signing configuration.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_code_signing_config(
#'   CodeSigningConfigArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_delete_code_signing_config
#'
#' @aliases lambda_delete_code_signing_config
lambda_delete_code_signing_config <- function(CodeSigningConfigArn) {
  op <- new_operation(
    name = "DeleteCodeSigningConfig",
    http_method = "DELETE",
    http_path = "/2020-04-22/code-signing-configs/{CodeSigningConfigArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_code_signing_config_input(CodeSigningConfigArn = CodeSigningConfigArn)
  output <- .lambda$delete_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_code_signing_config <- lambda_delete_code_signing_config

#' Deletes an event source mapping
#'
#' @description
#' Deletes an [event source
#' mapping](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html).
#' You can get the identifier of a mapping from the output of
#' [`list_event_source_mappings`][lambda_list_event_source_mappings].
#' 
#' When you delete an event source mapping, it enters a `Deleting` state
#' and might not be completely deleted for several seconds.
#'
#' @usage
#' lambda_delete_event_source_mapping(UUID)
#'
#' @param UUID &#91;required&#93; The identifier of the event source mapping.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UUID = "string",
#'   StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'   StartingPositionTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BatchSize = 123,
#'   MaximumBatchingWindowInSeconds = 123,
#'   ParallelizationFactor = 123,
#'   EventSourceArn = "string",
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   FunctionArn = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastProcessingResult = "string",
#'   State = "string",
#'   StateTransitionReason = "string",
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   Topics = list(
#'     "string"
#'   ),
#'   Queues = list(
#'     "string"
#'   ),
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   SelfManagedEventSource = list(
#'     Endpoints = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   TumblingWindowInSeconds = 123,
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   FilterCriteriaError = list(
#'     ErrorCode = "string",
#'     Message = "string"
#'   ),
#'   EventSourceMappingArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_event_source_mapping(
#'   UUID = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes an event source mapping. To get a
#' # mapping's UUID, use ListEventSourceMappings.
#' svc$delete_event_source_mapping(
#'   UUID = "14e0db71-xmpl-4eb5-b481-8945cf9d10c2"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_event_source_mapping
#'
#' @aliases lambda_delete_event_source_mapping
lambda_delete_event_source_mapping <- function(UUID) {
  op <- new_operation(
    name = "DeleteEventSourceMapping",
    http_method = "DELETE",
    http_path = "/2015-03-31/event-source-mappings/{UUID}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_event_source_mapping_input(UUID = UUID)
  output <- .lambda$delete_event_source_mapping_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_event_source_mapping <- lambda_delete_event_source_mapping

#' Deletes a Lambda function
#'
#' @description
#' Deletes a Lambda function. To delete a specific function version, use
#' the `Qualifier` parameter. Otherwise, all versions and aliases are
#' deleted. This doesn't require the user to have explicit permissions for
#' [`delete_alias`][lambda_delete_alias].
#' 
#' A deleted Lambda function cannot be recovered. Ensure that you specify
#' the correct function name and version before deleting.
#' 
#' To delete Lambda event source mappings that invoke a function, use
#' [`delete_event_source_mapping`][lambda_delete_event_source_mapping]. For
#' Amazon Web Services services and resources that invoke your function
#' directly, delete the trigger in the service where you originally
#' configured it.
#'
#' @usage
#' lambda_delete_function(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function or version.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:1` (with
#'     version).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version to delete. You can't delete a version that an alias
#' references.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   StatusCode = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_function(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes version 1 of a Lambda function named
#' # my-function.
#' svc$delete_function(
#'   FunctionName = "my-function",
#'   Qualifier = "1"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_function
#'
#' @aliases lambda_delete_function
lambda_delete_function <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "DeleteFunction",
    http_method = "DELETE",
    http_path = "/2015-03-31/functions/{FunctionName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_function_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$delete_function_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_function <- lambda_delete_function

#' Removes the code signing configuration from the function
#'
#' @description
#' Removes the code signing configuration from the function.
#'
#' @usage
#' lambda_delete_function_code_signing_config(FunctionName)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_function_code_signing_config(
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_delete_function_code_signing_config
#'
#' @aliases lambda_delete_function_code_signing_config
lambda_delete_function_code_signing_config <- function(FunctionName) {
  op <- new_operation(
    name = "DeleteFunctionCodeSigningConfig",
    http_method = "DELETE",
    http_path = "/2020-06-30/functions/{FunctionName}/code-signing-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_function_code_signing_config_input(FunctionName = FunctionName)
  output <- .lambda$delete_function_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_function_code_signing_config <- lambda_delete_function_code_signing_config

#' Removes a concurrent execution limit from a function
#'
#' @description
#' Removes a concurrent execution limit from a function.
#'
#' @usage
#' lambda_delete_function_concurrency(FunctionName)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_function_concurrency(
#'   FunctionName = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes the reserved concurrent execution limit
#' # from a function named my-function.
#' svc$delete_function_concurrency(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_function_concurrency
#'
#' @aliases lambda_delete_function_concurrency
lambda_delete_function_concurrency <- function(FunctionName) {
  op <- new_operation(
    name = "DeleteFunctionConcurrency",
    http_method = "DELETE",
    http_path = "/2017-10-31/functions/{FunctionName}/concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_function_concurrency_input(FunctionName = FunctionName)
  output <- .lambda$delete_function_concurrency_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_function_concurrency <- lambda_delete_function_concurrency

#' Deletes the configuration for asynchronous invocation for a function,
#' version, or alias
#'
#' @description
#' Deletes the configuration for asynchronous invocation for a function,
#' version, or alias.
#' 
#' To configure options for asynchronous invocation, use
#' [`put_function_event_invoke_config`][lambda_put_function_event_invoke_config].
#'
#' @usage
#' lambda_delete_function_event_invoke_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** - `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier A version number or alias name.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_function_event_invoke_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes the asynchronous invocation configuration
#' # for the GREEN alias of a function named my-function.
#' svc$delete_function_event_invoke_config(
#'   FunctionName = "my-function",
#'   Qualifier = "GREEN"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_function_event_invoke_config
#'
#' @aliases lambda_delete_function_event_invoke_config
lambda_delete_function_event_invoke_config <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "DeleteFunctionEventInvokeConfig",
    http_method = "DELETE",
    http_path = "/2019-09-25/functions/{FunctionName}/event-invoke-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_function_event_invoke_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$delete_function_event_invoke_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_function_event_invoke_config <- lambda_delete_function_event_invoke_config

#' Deletes a Lambda function URL
#'
#' @description
#' Deletes a Lambda function URL. When you delete a function URL, you can't
#' recover it. Creating a new function URL results in a different URL
#' address.
#'
#' @usage
#' lambda_delete_function_url_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier The alias name.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_function_url_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_delete_function_url_config
#'
#' @aliases lambda_delete_function_url_config
lambda_delete_function_url_config <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "DeleteFunctionUrlConfig",
    http_method = "DELETE",
    http_path = "/2021-10-31/functions/{FunctionName}/url",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_function_url_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$delete_function_url_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_function_url_config <- lambda_delete_function_url_config

#' Deletes a version of an Lambda layer
#'
#' @description
#' Deletes a version of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html).
#' Deleted versions can no longer be viewed or added to functions. To avoid
#' breaking functions, a copy of the version remains in Lambda until no
#' functions refer to it.
#'
#' @usage
#' lambda_delete_layer_version(LayerName, VersionNumber)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param VersionNumber &#91;required&#93; The version number.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_layer_version(
#'   LayerName = "string",
#'   VersionNumber = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes version 2 of a layer named my-layer.
#' svc$delete_layer_version(
#'   LayerName = "my-layer",
#'   VersionNumber = 2L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_layer_version
#'
#' @aliases lambda_delete_layer_version
lambda_delete_layer_version <- function(LayerName, VersionNumber) {
  op <- new_operation(
    name = "DeleteLayerVersion",
    http_method = "DELETE",
    http_path = "/2018-10-31/layers/{LayerName}/versions/{VersionNumber}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_layer_version_input(LayerName = LayerName, VersionNumber = VersionNumber)
  output <- .lambda$delete_layer_version_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_layer_version <- lambda_delete_layer_version

#' Deletes the provisioned concurrency configuration for a function
#'
#' @description
#' Deletes the provisioned concurrency configuration for a function.
#'
#' @usage
#' lambda_delete_provisioned_concurrency_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier &#91;required&#93; The version number or alias name.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_provisioned_concurrency_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes the provisioned concurrency configuration
#' # for the GREEN alias of a function named my-function.
#' svc$delete_provisioned_concurrency_config(
#'   FunctionName = "my-function",
#'   Qualifier = "GREEN"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_delete_provisioned_concurrency_config
#'
#' @aliases lambda_delete_provisioned_concurrency_config
lambda_delete_provisioned_concurrency_config <- function(FunctionName, Qualifier) {
  op <- new_operation(
    name = "DeleteProvisionedConcurrencyConfig",
    http_method = "DELETE",
    http_path = "/2019-09-30/functions/{FunctionName}/provisioned-concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$delete_provisioned_concurrency_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$delete_provisioned_concurrency_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$delete_provisioned_concurrency_config <- lambda_delete_provisioned_concurrency_config

#' Retrieves details about your account's limits and usage in an Amazon Web
#' Services Region
#'
#' @description
#' Retrieves details about your account's
#' [limits](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html)
#' and usage in an Amazon Web Services Region.
#'
#' @usage
#' lambda_get_account_settings()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AccountLimit = list(
#'     TotalCodeSize = 123,
#'     CodeSizeUnzipped = 123,
#'     CodeSizeZipped = 123,
#'     ConcurrentExecutions = 123,
#'     UnreservedConcurrentExecutions = 123
#'   ),
#'   AccountUsage = list(
#'     TotalCodeSize = 123,
#'     FunctionCount = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_account_settings()
#' ```
#'
#' @examples
#' \dontrun{
#' # This operation takes no parameters and returns details about storage and
#' # concurrency quotas in the current Region.
#' svc$get_account_settings()
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_account_settings
#'
#' @aliases lambda_get_account_settings
lambda_get_account_settings <- function() {
  op <- new_operation(
    name = "GetAccountSettings",
    http_method = "GET",
    http_path = "/2016-08-19/account-settings",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_account_settings_input()
  output <- .lambda$get_account_settings_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_account_settings <- lambda_get_account_settings

#' Returns details about a Lambda function alias
#'
#' @description
#' Returns details about a Lambda function
#' [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
#'
#' @usage
#' lambda_get_alias(FunctionName, Name)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Name &#91;required&#93; The name of the alias.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AliasArn = "string",
#'   Name = "string",
#'   FunctionVersion = "string",
#'   Description = "string",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       123.0
#'     )
#'   ),
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_alias(
#'   FunctionName = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns details about an alias named BLUE for a
#' # function named my-function
#' svc$get_alias(
#'   FunctionName = "my-function",
#'   Name = "BLUE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_alias
#'
#' @aliases lambda_get_alias
lambda_get_alias <- function(FunctionName, Name) {
  op <- new_operation(
    name = "GetAlias",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_alias_input(FunctionName = FunctionName, Name = Name)
  output <- .lambda$get_alias_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_alias <- lambda_get_alias

#' Retrieves information about a specific capacity provider, including its
#' configuration, state, and associated resources
#'
#' @description
#' Retrieves information about a specific capacity provider, including its
#' configuration, state, and associated resources.
#'
#' @usage
#' lambda_get_capacity_provider(CapacityProviderName)
#'
#' @param CapacityProviderName &#91;required&#93; The name of the capacity provider to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProvider = list(
#'     CapacityProviderArn = "string",
#'     State = "Pending"|"Active"|"Failed"|"Deleting",
#'     VpcConfig = list(
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       SecurityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     PermissionsConfig = list(
#'       CapacityProviderOperatorRoleArn = "string"
#'     ),
#'     InstanceRequirements = list(
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       AllowedInstanceTypes = list(
#'         "string"
#'       ),
#'       ExcludedInstanceTypes = list(
#'         "string"
#'       )
#'     ),
#'     CapacityProviderScalingConfig = list(
#'       MaxVCpuCount = 123,
#'       ScalingMode = "Auto"|"Manual",
#'       ScalingPolicies = list(
#'         list(
#'           PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'           TargetValue = 123.0
#'         )
#'       )
#'     ),
#'     KmsKeyArn = "string",
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_capacity_provider(
#'   CapacityProviderName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_capacity_provider
#'
#' @aliases lambda_get_capacity_provider
lambda_get_capacity_provider <- function(CapacityProviderName) {
  op <- new_operation(
    name = "GetCapacityProvider",
    http_method = "GET",
    http_path = "/2025-11-30/capacity-providers/{CapacityProviderName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_capacity_provider_input(CapacityProviderName = CapacityProviderName)
  output <- .lambda$get_capacity_provider_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_capacity_provider <- lambda_get_capacity_provider

#' Returns information about the specified code signing configuration
#'
#' @description
#' Returns information about the specified code signing configuration.
#'
#' @usage
#' lambda_get_code_signing_config(CodeSigningConfigArn)
#'
#' @param CodeSigningConfigArn &#91;required&#93; The The Amazon Resource Name (ARN) of the code signing configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeSigningConfig = list(
#'     CodeSigningConfigId = "string",
#'     CodeSigningConfigArn = "string",
#'     Description = "string",
#'     AllowedPublishers = list(
#'       SigningProfileVersionArns = list(
#'         "string"
#'       )
#'     ),
#'     CodeSigningPolicies = list(
#'       UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'     ),
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_code_signing_config(
#'   CodeSigningConfigArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_code_signing_config
#'
#' @aliases lambda_get_code_signing_config
lambda_get_code_signing_config <- function(CodeSigningConfigArn) {
  op <- new_operation(
    name = "GetCodeSigningConfig",
    http_method = "GET",
    http_path = "/2020-04-22/code-signing-configs/{CodeSigningConfigArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_code_signing_config_input(CodeSigningConfigArn = CodeSigningConfigArn)
  output <- .lambda$get_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_code_signing_config <- lambda_get_code_signing_config

#' Retrieves detailed information about a specific durable execution,
#' including its current status, input payload, result or error
#' information, and execution metadata such as start time and usage
#' statistics
#'
#' @description
#' Retrieves detailed information about a specific [durable
#' execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html),
#' including its current status, input payload, result or error
#' information, and execution metadata such as start time and usage
#' statistics.
#'
#' @usage
#' lambda_get_durable_execution(DurableExecutionArn)
#'
#' @param DurableExecutionArn &#91;required&#93; The Amazon Resource Name (ARN) of the durable execution.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DurableExecutionArn = "string",
#'   DurableExecutionName = "string",
#'   FunctionArn = "string",
#'   InputPayload = "string",
#'   Result = "string",
#'   Error = list(
#'     ErrorMessage = "string",
#'     ErrorType = "string",
#'     ErrorData = "string",
#'     StackTrace = list(
#'       "string"
#'     )
#'   ),
#'   StartTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Status = "RUNNING"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"STOPPED",
#'   EndTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Version = "string",
#'   TraceHeader = list(
#'     XAmznTraceId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_durable_execution(
#'   DurableExecutionArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_durable_execution
#'
#' @aliases lambda_get_durable_execution
lambda_get_durable_execution <- function(DurableExecutionArn) {
  op <- new_operation(
    name = "GetDurableExecution",
    http_method = "GET",
    http_path = "/2025-12-01/durable-executions/{DurableExecutionArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_durable_execution_input(DurableExecutionArn = DurableExecutionArn)
  output <- .lambda$get_durable_execution_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_durable_execution <- lambda_get_durable_execution

#' Retrieves the execution history for a durable execution, showing all the
#' steps, callbacks, and events that occurred during the execution
#'
#' @description
#' Retrieves the execution history for a [durable
#' execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html),
#' showing all the steps, callbacks, and events that occurred during the
#' execution. This provides a detailed audit trail of the execution's
#' progress over time.
#' 
#' The history is available while the execution is running and for a
#' retention period after it completes (1-90 days, default 30 days). You
#' can control whether to include execution data such as step results and
#' callback payloads.
#'
#' @usage
#' lambda_get_durable_execution_history(DurableExecutionArn,
#'   IncludeExecutionData, MaxItems, Marker, ReverseOrder)
#'
#' @param DurableExecutionArn &#91;required&#93; The Amazon Resource Name (ARN) of the durable execution.
#' @param IncludeExecutionData Specifies whether to include execution data such as step results and
#' callback payloads in the history events. Set to `true` to include data,
#' or `false` to exclude it for a more compact response. The default is
#' `true`.
#' @param MaxItems The maximum number of history events to return per call. You can use
#' `Marker` to retrieve additional pages of results. The default is 100 and
#' the maximum allowed is 1000. A value of 0 uses the default.
#' @param Marker If `NextMarker` was returned from a previous request, use this value to
#' retrieve the next page of results. Each pagination token expires after
#' 24 hours.
#' @param ReverseOrder When set to `true`, returns the history events in reverse chronological
#' order (newest first). By default, events are returned in chronological
#' order (oldest first).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Events = list(
#'     list(
#'       EventType = "ExecutionStarted"|"ExecutionSucceeded"|"ExecutionFailed"|"ExecutionTimedOut"|"ExecutionStopped"|"ContextStarted"|"ContextSucceeded"|"ContextFailed"|"WaitStarted"|"WaitSucceeded"|"WaitCancelled"|"StepStarted"|"StepSucceeded"|"StepFailed"|"ChainedInvokeStarted"|"ChainedInvokeSucceeded"|"ChainedInvokeFailed"|"ChainedInvokeTimedOut"|"ChainedInvokeStopped"|"CallbackStarted"|"CallbackSucceeded"|"CallbackFailed"|"CallbackTimedOut"|"InvocationCompleted",
#'       SubType = "string",
#'       EventId = 123,
#'       Id = "string",
#'       Name = "string",
#'       EventTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ParentId = "string",
#'       ExecutionStartedDetails = list(
#'         Input = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         ),
#'         ExecutionTimeout = 123
#'       ),
#'       ExecutionSucceededDetails = list(
#'         Result = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ExecutionFailedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ExecutionTimedOutDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ExecutionStoppedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ContextStartedDetails = list(),
#'       ContextSucceededDetails = list(
#'         Result = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ContextFailedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       WaitStartedDetails = list(
#'         Duration = 123,
#'         ScheduledEndTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       WaitSucceededDetails = list(
#'         Duration = 123
#'       ),
#'       WaitCancelledDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       StepStartedDetails = list(),
#'       StepSucceededDetails = list(
#'         Result = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         ),
#'         RetryDetails = list(
#'           CurrentAttempt = 123,
#'           NextAttemptDelaySeconds = 123
#'         )
#'       ),
#'       StepFailedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         ),
#'         RetryDetails = list(
#'           CurrentAttempt = 123,
#'           NextAttemptDelaySeconds = 123
#'         )
#'       ),
#'       ChainedInvokeStartedDetails = list(
#'         FunctionName = "string",
#'         TenantId = "string",
#'         Input = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         ),
#'         ExecutedVersion = "string",
#'         DurableExecutionArn = "string"
#'       ),
#'       ChainedInvokeSucceededDetails = list(
#'         Result = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ChainedInvokeFailedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ChainedInvokeTimedOutDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       ChainedInvokeStoppedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       CallbackStartedDetails = list(
#'         CallbackId = "string",
#'         HeartbeatTimeout = 123,
#'         Timeout = 123
#'       ),
#'       CallbackSucceededDetails = list(
#'         Result = list(
#'           Payload = "string",
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       CallbackFailedDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       CallbackTimedOutDetails = list(
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       ),
#'       InvocationCompletedDetails = list(
#'         StartTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         EndTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         RequestId = "string",
#'         Error = list(
#'           Payload = list(
#'             ErrorMessage = "string",
#'             ErrorType = "string",
#'             ErrorData = "string",
#'             StackTrace = list(
#'               "string"
#'             )
#'           ),
#'           Truncated = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_durable_execution_history(
#'   DurableExecutionArn = "string",
#'   IncludeExecutionData = TRUE|FALSE,
#'   MaxItems = 123,
#'   Marker = "string",
#'   ReverseOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_durable_execution_history
#'
#' @aliases lambda_get_durable_execution_history
lambda_get_durable_execution_history <- function(DurableExecutionArn, IncludeExecutionData = NULL, MaxItems = NULL, Marker = NULL, ReverseOrder = NULL) {
  op <- new_operation(
    name = "GetDurableExecutionHistory",
    http_method = "GET",
    http_path = "/2025-12-01/durable-executions/{DurableExecutionArn}/history",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "Events"),
    stream_api = FALSE
  )
  input <- .lambda$get_durable_execution_history_input(DurableExecutionArn = DurableExecutionArn, IncludeExecutionData = IncludeExecutionData, MaxItems = MaxItems, Marker = Marker, ReverseOrder = ReverseOrder)
  output <- .lambda$get_durable_execution_history_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_durable_execution_history <- lambda_get_durable_execution_history

#' Retrieves the current execution state required for the replay process
#' during durable function execution
#'
#' @description
#' Retrieves the current execution state required for the replay process
#' during [durable
#' function](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html)
#' execution. This API is used by the Lambda durable functions SDK to get
#' state information needed for replay. You typically don't need to call
#' this API directly as the SDK handles state management automatically.
#' 
#' The response contains operations ordered by start sequence number in
#' ascending order. Completed operations with children don't include child
#' operation details since they don't need to be replayed.
#'
#' @usage
#' lambda_get_durable_execution_state(DurableExecutionArn, CheckpointToken,
#'   Marker, MaxItems)
#'
#' @param DurableExecutionArn &#91;required&#93; The Amazon Resource Name (ARN) of the durable execution.
#' @param CheckpointToken &#91;required&#93; A checkpoint token that identifies the current state of the execution.
#' This token is provided by the Lambda runtime and ensures that state
#' retrieval is consistent with the current execution context.
#' @param Marker If `NextMarker` was returned from a previous request, use this value to
#' retrieve the next page of operations. Each pagination token expires
#' after 24 hours.
#' @param MaxItems The maximum number of operations to return per call. You can use
#' `Marker` to retrieve additional pages of results. The default is 100 and
#' the maximum allowed is 1000. A value of 0 uses the default.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Operations = list(
#'     list(
#'       Id = "string",
#'       ParentId = "string",
#'       Name = "string",
#'       Type = "EXECUTION"|"CONTEXT"|"STEP"|"WAIT"|"CALLBACK"|"CHAINED_INVOKE",
#'       SubType = "string",
#'       StartTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Status = "STARTED"|"PENDING"|"READY"|"SUCCEEDED"|"FAILED"|"CANCELLED"|"TIMED_OUT"|"STOPPED",
#'       ExecutionDetails = list(
#'         InputPayload = "string"
#'       ),
#'       ContextDetails = list(
#'         ReplayChildren = TRUE|FALSE,
#'         Result = "string",
#'         Error = list(
#'           ErrorMessage = "string",
#'           ErrorType = "string",
#'           ErrorData = "string",
#'           StackTrace = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       StepDetails = list(
#'         Attempt = 123,
#'         NextAttemptTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Result = "string",
#'         Error = list(
#'           ErrorMessage = "string",
#'           ErrorType = "string",
#'           ErrorData = "string",
#'           StackTrace = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       WaitDetails = list(
#'         ScheduledEndTimestamp = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       CallbackDetails = list(
#'         CallbackId = "string",
#'         Result = "string",
#'         Error = list(
#'           ErrorMessage = "string",
#'           ErrorType = "string",
#'           ErrorData = "string",
#'           StackTrace = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       ChainedInvokeDetails = list(
#'         Result = "string",
#'         Error = list(
#'           ErrorMessage = "string",
#'           ErrorType = "string",
#'           ErrorData = "string",
#'           StackTrace = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_durable_execution_state(
#'   DurableExecutionArn = "string",
#'   CheckpointToken = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_durable_execution_state
#'
#' @aliases lambda_get_durable_execution_state
lambda_get_durable_execution_state <- function(DurableExecutionArn, CheckpointToken, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "GetDurableExecutionState",
    http_method = "GET",
    http_path = "/2025-12-01/durable-executions/{DurableExecutionArn}/state",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "Operations"),
    stream_api = FALSE
  )
  input <- .lambda$get_durable_execution_state_input(DurableExecutionArn = DurableExecutionArn, CheckpointToken = CheckpointToken, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$get_durable_execution_state_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_durable_execution_state <- lambda_get_durable_execution_state

#' Returns details about an event source mapping
#'
#' @description
#' Returns details about an event source mapping. You can get the
#' identifier of a mapping from the output of
#' [`list_event_source_mappings`][lambda_list_event_source_mappings].
#'
#' @usage
#' lambda_get_event_source_mapping(UUID)
#'
#' @param UUID &#91;required&#93; The identifier of the event source mapping.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UUID = "string",
#'   StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'   StartingPositionTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BatchSize = 123,
#'   MaximumBatchingWindowInSeconds = 123,
#'   ParallelizationFactor = 123,
#'   EventSourceArn = "string",
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   FunctionArn = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastProcessingResult = "string",
#'   State = "string",
#'   StateTransitionReason = "string",
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   Topics = list(
#'     "string"
#'   ),
#'   Queues = list(
#'     "string"
#'   ),
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   SelfManagedEventSource = list(
#'     Endpoints = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   TumblingWindowInSeconds = 123,
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   FilterCriteriaError = list(
#'     ErrorCode = "string",
#'     Message = "string"
#'   ),
#'   EventSourceMappingArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_event_source_mapping(
#'   UUID = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns details about an event source mapping. To
#' # get a mapping's UUID, use ListEventSourceMappings.
#' svc$get_event_source_mapping(
#'   UUID = "14e0db71-xmpl-4eb5-b481-8945cf9d10c2"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_event_source_mapping
#'
#' @aliases lambda_get_event_source_mapping
lambda_get_event_source_mapping <- function(UUID) {
  op <- new_operation(
    name = "GetEventSourceMapping",
    http_method = "GET",
    http_path = "/2015-03-31/event-source-mappings/{UUID}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_event_source_mapping_input(UUID = UUID)
  output <- .lambda$get_event_source_mapping_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_event_source_mapping <- lambda_get_event_source_mapping

#' Returns information about the function or function version, with a link
#' to download the deployment package that's valid for 10 minutes
#'
#' @description
#' Returns information about the function or function version, with a link
#' to download the deployment package that's valid for 10 minutes. If you
#' specify a function version, only details that are specific to that
#' version are returned.
#'
#' @usage
#' lambda_get_function(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version or alias to get details about a published version of
#' the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Configuration = list(
#'     FunctionName = "string",
#'     FunctionArn = "string",
#'     Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'     Role = "string",
#'     Handler = "string",
#'     CodeSize = 123,
#'     Description = "string",
#'     Timeout = 123,
#'     MemorySize = 123,
#'     LastModified = "string",
#'     CodeSha256 = "string",
#'     Version = "string",
#'     VpcConfig = list(
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       SecurityGroupIds = list(
#'         "string"
#'       ),
#'       VpcId = "string",
#'       Ipv6AllowedForDualStack = TRUE|FALSE
#'     ),
#'     DeadLetterConfig = list(
#'       TargetArn = "string"
#'     ),
#'     Environment = list(
#'       Variables = list(
#'         "string"
#'       ),
#'       Error = list(
#'         ErrorCode = "string",
#'         Message = "string"
#'       )
#'     ),
#'     KMSKeyArn = "string",
#'     TracingConfig = list(
#'       Mode = "Active"|"PassThrough"
#'     ),
#'     MasterArn = "string",
#'     RevisionId = "string",
#'     Layers = list(
#'       list(
#'         Arn = "string",
#'         CodeSize = 123,
#'         SigningProfileVersionArn = "string",
#'         SigningJobArn = "string"
#'       )
#'     ),
#'     State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'     StateReason = "string",
#'     StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'     LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'     LastUpdateStatusReason = "string",
#'     LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'     FileSystemConfigs = list(
#'       list(
#'         Arn = "string",
#'         LocalMountPath = "string"
#'       )
#'     ),
#'     PackageType = "Zip"|"Image",
#'     ImageConfigResponse = list(
#'       ImageConfig = list(
#'         EntryPoint = list(
#'           "string"
#'         ),
#'         Command = list(
#'           "string"
#'         ),
#'         WorkingDirectory = "string"
#'       ),
#'       Error = list(
#'         ErrorCode = "string",
#'         Message = "string"
#'       )
#'     ),
#'     SigningProfileVersionArn = "string",
#'     SigningJobArn = "string",
#'     Architectures = list(
#'       "x86_64"|"arm64"
#'     ),
#'     EphemeralStorage = list(
#'       Size = 123
#'     ),
#'     SnapStart = list(
#'       ApplyOn = "PublishedVersions"|"None",
#'       OptimizationStatus = "On"|"Off"
#'     ),
#'     RuntimeVersionConfig = list(
#'       RuntimeVersionArn = "string",
#'       Error = list(
#'         ErrorCode = "string",
#'         Message = "string"
#'       )
#'     ),
#'     LoggingConfig = list(
#'       LogFormat = "JSON"|"Text",
#'       ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'       SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'       LogGroup = "string"
#'     ),
#'     CapacityProviderConfig = list(
#'       LambdaManagedInstancesCapacityProviderConfig = list(
#'         CapacityProviderArn = "string",
#'         PerExecutionEnvironmentMaxConcurrency = 123,
#'         ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'       )
#'     ),
#'     ConfigSha256 = "string",
#'     DurableConfig = list(
#'       RetentionPeriodInDays = 123,
#'       ExecutionTimeout = 123
#'     ),
#'     TenancyConfig = list(
#'       TenantIsolationMode = "PER_TENANT"
#'     )
#'   ),
#'   Code = list(
#'     RepositoryType = "string",
#'     Location = "string",
#'     ImageUri = "string",
#'     ResolvedImageUri = "string",
#'     SourceKMSKeyArn = "string"
#'   ),
#'   Tags = list(
#'     "string"
#'   ),
#'   TagsError = list(
#'     ErrorCode = "string",
#'     Message = "string"
#'   ),
#'   Concurrency = list(
#'     ReservedConcurrentExecutions = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns code and configuration details for version
#' # 1 of a function named my-function.
#' svc$get_function(
#'   FunctionName = "my-function",
#'   Qualifier = "1"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_function
#'
#' @aliases lambda_get_function
lambda_get_function <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetFunction",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_function_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function <- lambda_get_function

#' Returns the code signing configuration for the specified function
#'
#' @description
#' Returns the code signing configuration for the specified function.
#'
#' @usage
#' lambda_get_function_code_signing_config(FunctionName)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeSigningConfigArn = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_code_signing_config(
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_code_signing_config
#'
#' @aliases lambda_get_function_code_signing_config
lambda_get_function_code_signing_config <- function(FunctionName) {
  op <- new_operation(
    name = "GetFunctionCodeSigningConfig",
    http_method = "GET",
    http_path = "/2020-06-30/functions/{FunctionName}/code-signing-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_code_signing_config_input(FunctionName = FunctionName)
  output <- .lambda$get_function_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_code_signing_config <- lambda_get_function_code_signing_config

#' Returns details about the reserved concurrency configuration for a
#' function
#'
#' @description
#' Returns details about the reserved concurrency configuration for a
#' function. To set a concurrency limit for a function, use
#' [`put_function_concurrency`][lambda_put_function_concurrency].
#'
#' @usage
#' lambda_get_function_concurrency(FunctionName)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ReservedConcurrentExecutions = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_concurrency(
#'   FunctionName = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns the reserved concurrency setting for a
#' # function named my-function.
#' svc$get_function_concurrency(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_concurrency
#'
#' @aliases lambda_get_function_concurrency
lambda_get_function_concurrency <- function(FunctionName) {
  op <- new_operation(
    name = "GetFunctionConcurrency",
    http_method = "GET",
    http_path = "/2019-09-30/functions/{FunctionName}/concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_concurrency_input(FunctionName = FunctionName)
  output <- .lambda$get_function_concurrency_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_concurrency <- lambda_get_function_concurrency

#' Returns the version-specific settings of a Lambda function or version
#'
#' @description
#' Returns the version-specific settings of a Lambda function or version.
#' The output includes only options that can vary between versions of a
#' function. To modify these settings, use
#' [`update_function_configuration`][lambda_update_function_configuration].
#' 
#' To get all of a function's details, including function-level settings,
#' use [`get_function`][lambda_get_function].
#'
#' @usage
#' lambda_get_function_configuration(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version or alias to get details about a published version of
#' the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionName = "string",
#'   FunctionArn = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   CodeSize = 123,
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   LastModified = "string",
#'   CodeSha256 = "string",
#'   Version = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     VpcId = "string",
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   MasterArn = "string",
#'   RevisionId = "string",
#'   Layers = list(
#'     list(
#'       Arn = "string",
#'       CodeSize = 123,
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string"
#'     )
#'   ),
#'   State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'   StateReason = "string",
#'   StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'   LastUpdateStatusReason = "string",
#'   LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   PackageType = "Zip"|"Image",
#'   ImageConfigResponse = list(
#'     ImageConfig = list(
#'       EntryPoint = list(
#'         "string"
#'       ),
#'       Command = list(
#'         "string"
#'       ),
#'       WorkingDirectory = "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   SigningProfileVersionArn = "string",
#'   SigningJobArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None",
#'     OptimizationStatus = "On"|"Off"
#'   ),
#'   RuntimeVersionConfig = list(
#'     RuntimeVersionArn = "string",
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   ConfigSha256 = "string",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_configuration(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns and configuration details for version 1 of
#' # a function named my-function.
#' svc$get_function_configuration(
#'   FunctionName = "my-function",
#'   Qualifier = "1"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_configuration
#'
#' @aliases lambda_get_function_configuration
lambda_get_function_configuration <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetFunctionConfiguration",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}/configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_configuration_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_function_configuration_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_configuration <- lambda_get_function_configuration

#' Retrieves the configuration for asynchronous invocation for a function,
#' version, or alias
#'
#' @description
#' Retrieves the configuration for asynchronous invocation for a function,
#' version, or alias.
#' 
#' To configure options for asynchronous invocation, use
#' [`put_function_event_invoke_config`][lambda_put_function_event_invoke_config].
#'
#' @usage
#' lambda_get_function_event_invoke_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** - `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier A version number or alias name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FunctionArn = "string",
#'   MaximumRetryAttempts = 123,
#'   MaximumEventAgeInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_event_invoke_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns the asynchronous invocation configuration
#' # for the BLUE alias of a function named my-function.
#' svc$get_function_event_invoke_config(
#'   FunctionName = "my-function",
#'   Qualifier = "BLUE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_event_invoke_config
#'
#' @aliases lambda_get_function_event_invoke_config
lambda_get_function_event_invoke_config <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetFunctionEventInvokeConfig",
    http_method = "GET",
    http_path = "/2019-09-25/functions/{FunctionName}/event-invoke-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_event_invoke_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_function_event_invoke_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_event_invoke_config <- lambda_get_function_event_invoke_config

#' Returns your function's recursive loop detection configuration
#'
#' @description
#' Returns your function's [recursive loop
#' detection](https://docs.aws.amazon.com/lambda/latest/dg/invocation-recursion.html)
#' configuration.
#'
#' @usage
#' lambda_get_function_recursion_config(FunctionName)
#'
#' @param FunctionName &#91;required&#93; The name of the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RecursiveLoop = "Allow"|"Terminate"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_recursion_config(
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_recursion_config
#'
#' @aliases lambda_get_function_recursion_config
lambda_get_function_recursion_config <- function(FunctionName) {
  op <- new_operation(
    name = "GetFunctionRecursionConfig",
    http_method = "GET",
    http_path = "/2024-08-31/functions/{FunctionName}/recursion-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_recursion_config_input(FunctionName = FunctionName)
  output <- .lambda$get_function_recursion_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_recursion_config <- lambda_get_function_recursion_config

#' Retrieves the scaling configuration for a Lambda Managed Instances
#' function
#'
#' @description
#' Retrieves the scaling configuration for a Lambda Managed Instances
#' function.
#'
#' @usage
#' lambda_get_function_scaling_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' @param Qualifier &#91;required&#93; Specify a version or alias to get the scaling configuration for a
#' published version of the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionArn = "string",
#'   AppliedFunctionScalingConfig = list(
#'     MinExecutionEnvironments = 123,
#'     MaxExecutionEnvironments = 123
#'   ),
#'   RequestedFunctionScalingConfig = list(
#'     MinExecutionEnvironments = 123,
#'     MaxExecutionEnvironments = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_scaling_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_scaling_config
#'
#' @aliases lambda_get_function_scaling_config
lambda_get_function_scaling_config <- function(FunctionName, Qualifier) {
  op <- new_operation(
    name = "GetFunctionScalingConfig",
    http_method = "GET",
    http_path = "/2025-11-30/functions/{FunctionName}/function-scaling-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_scaling_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_function_scaling_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_scaling_config <- lambda_get_function_scaling_config

#' Returns details about a Lambda function URL
#'
#' @description
#' Returns details about a Lambda function URL.
#'
#' @usage
#' lambda_get_function_url_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier The alias name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionUrl = "string",
#'   FunctionArn = "string",
#'   AuthType = "NONE"|"AWS_IAM",
#'   Cors = list(
#'     AllowCredentials = TRUE|FALSE,
#'     AllowHeaders = list(
#'       "string"
#'     ),
#'     AllowMethods = list(
#'       "string"
#'     ),
#'     AllowOrigins = list(
#'       "string"
#'     ),
#'     ExposeHeaders = list(
#'       "string"
#'     ),
#'     MaxAge = 123
#'   ),
#'   CreationTime = "string",
#'   LastModifiedTime = "string",
#'   InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_function_url_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_function_url_config
#'
#' @aliases lambda_get_function_url_config
lambda_get_function_url_config <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetFunctionUrlConfig",
    http_method = "GET",
    http_path = "/2021-10-31/functions/{FunctionName}/url",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_function_url_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_function_url_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_function_url_config <- lambda_get_function_url_config

#' Returns information about a version of an Lambda layer, with a link to
#' download the layer archive that's valid for 10 minutes
#'
#' @description
#' Returns information about a version of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html),
#' with a link to download the layer archive that's valid for 10 minutes.
#'
#' @usage
#' lambda_get_layer_version(LayerName, VersionNumber)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param VersionNumber &#91;required&#93; The version number.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Content = list(
#'     Location = "string",
#'     CodeSha256 = "string",
#'     CodeSize = 123,
#'     SigningProfileVersionArn = "string",
#'     SigningJobArn = "string"
#'   ),
#'   LayerArn = "string",
#'   LayerVersionArn = "string",
#'   Description = "string",
#'   CreatedDate = "string",
#'   Version = 123,
#'   CompatibleRuntimes = list(
#'     "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'   ),
#'   LicenseInfo = "string",
#'   CompatibleArchitectures = list(
#'     "x86_64"|"arm64"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_layer_version(
#'   LayerName = "string",
#'   VersionNumber = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns information for version 1 of a layer named
#' # my-layer.
#' svc$get_layer_version(
#'   LayerName = "my-layer",
#'   VersionNumber = 1L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_layer_version
#'
#' @aliases lambda_get_layer_version
lambda_get_layer_version <- function(LayerName, VersionNumber) {
  op <- new_operation(
    name = "GetLayerVersion",
    http_method = "GET",
    http_path = "/2018-10-31/layers/{LayerName}/versions/{VersionNumber}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_layer_version_input(LayerName = LayerName, VersionNumber = VersionNumber)
  output <- .lambda$get_layer_version_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_layer_version <- lambda_get_layer_version

#' Returns information about a version of an Lambda layer, with a link to
#' download the layer archive that's valid for 10 minutes
#'
#' @description
#' Returns information about a version of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html),
#' with a link to download the layer archive that's valid for 10 minutes.
#'
#' @usage
#' lambda_get_layer_version_by_arn(Arn)
#'
#' @param Arn &#91;required&#93; The ARN of the layer version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Content = list(
#'     Location = "string",
#'     CodeSha256 = "string",
#'     CodeSize = 123,
#'     SigningProfileVersionArn = "string",
#'     SigningJobArn = "string"
#'   ),
#'   LayerArn = "string",
#'   LayerVersionArn = "string",
#'   Description = "string",
#'   CreatedDate = "string",
#'   Version = 123,
#'   CompatibleRuntimes = list(
#'     "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'   ),
#'   LicenseInfo = "string",
#'   CompatibleArchitectures = list(
#'     "x86_64"|"arm64"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_layer_version_by_arn(
#'   Arn = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns information about the layer version with
#' # the specified Amazon Resource Name (ARN).
#' svc$get_layer_version_by_arn(
#'   Arn = "arn:aws:lambda:ca-central-1:123456789012:layer:blank-python-lib:3"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_layer_version_by_arn
#'
#' @aliases lambda_get_layer_version_by_arn
lambda_get_layer_version_by_arn <- function(Arn) {
  op <- new_operation(
    name = "GetLayerVersionByArn",
    http_method = "GET",
    http_path = "/2018-10-31/layers?find=LayerVersion",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_layer_version_by_arn_input(Arn = Arn)
  output <- .lambda$get_layer_version_by_arn_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_layer_version_by_arn <- lambda_get_layer_version_by_arn

#' Returns the permission policy for a version of an Lambda layer
#'
#' @description
#' Returns the permission policy for a version of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html).
#' For more information, see
#' [`add_layer_version_permission`][lambda_add_layer_version_permission].
#'
#' @usage
#' lambda_get_layer_version_policy(LayerName, VersionNumber)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param VersionNumber &#91;required&#93; The version number.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Policy = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_layer_version_policy(
#'   LayerName = "string",
#'   VersionNumber = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_layer_version_policy
#'
#' @aliases lambda_get_layer_version_policy
lambda_get_layer_version_policy <- function(LayerName, VersionNumber) {
  op <- new_operation(
    name = "GetLayerVersionPolicy",
    http_method = "GET",
    http_path = "/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_layer_version_policy_input(LayerName = LayerName, VersionNumber = VersionNumber)
  output <- .lambda$get_layer_version_policy_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_layer_version_policy <- lambda_get_layer_version_policy

#' Returns the resource-based IAM policy for a function, version, or alias
#'
#' @description
#' Returns the [resource-based IAM
#' policy](https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html)
#' for a function, version, or alias.
#'
#' @usage
#' lambda_get_policy(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version or alias to get the policy for that resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Policy = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_policy(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns the resource-based policy for version 1 of
#' # a Lambda function named my-function.
#' svc$get_policy(
#'   FunctionName = "my-function",
#'   Qualifier = "1"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_policy
#'
#' @aliases lambda_get_policy
lambda_get_policy <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetPolicy",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}/policy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_policy_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_policy_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_policy <- lambda_get_policy

#' Retrieves the provisioned concurrency configuration for a function's
#' alias or version
#'
#' @description
#' Retrieves the provisioned concurrency configuration for a function's
#' alias or version.
#'
#' @usage
#' lambda_get_provisioned_concurrency_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier &#91;required&#93; The version number or alias name.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RequestedProvisionedConcurrentExecutions = 123,
#'   AvailableProvisionedConcurrentExecutions = 123,
#'   AllocatedProvisionedConcurrentExecutions = 123,
#'   Status = "IN_PROGRESS"|"READY"|"FAILED",
#'   StatusReason = "string",
#'   LastModified = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_provisioned_concurrency_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns details for the provisioned concurrency
#' # configuration for the BLUE alias of the specified function.
#' svc$get_provisioned_concurrency_config(
#'   FunctionName = "my-function",
#'   Qualifier = "BLUE"
#' )
#' 
#' # The following example displays details for the provisioned concurrency
#' # configuration for the BLUE alias of the specified function.
#' svc$get_provisioned_concurrency_config(
#'   FunctionName = "my-function",
#'   Qualifier = "BLUE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_get_provisioned_concurrency_config
#'
#' @aliases lambda_get_provisioned_concurrency_config
lambda_get_provisioned_concurrency_config <- function(FunctionName, Qualifier) {
  op <- new_operation(
    name = "GetProvisionedConcurrencyConfig",
    http_method = "GET",
    http_path = "/2019-09-30/functions/{FunctionName}/provisioned-concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_provisioned_concurrency_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_provisioned_concurrency_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_provisioned_concurrency_config <- lambda_get_provisioned_concurrency_config

#' Retrieves the runtime management configuration for a function's version
#'
#' @description
#' Retrieves the runtime management configuration for a function's version.
#' If the runtime update mode is **Manual**, this includes the ARN of the
#' runtime version and the runtime update mode. If the runtime update mode
#' is **Auto** or **Function update**, this includes the runtime update
#' mode and `null` is returned for the ARN. For more information, see
#' [Runtime
#' updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
#'
#' @usage
#' lambda_get_runtime_management_config(FunctionName, Qualifier)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version of the function. This can be `$LATEST` or a published
#' version number. If no value is specified, the configuration for the
#' `$LATEST` version is returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateRuntimeOn = "Auto"|"Manual"|"FunctionUpdate",
#'   RuntimeVersionArn = "string",
#'   FunctionArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_runtime_management_config(
#'   FunctionName = "string",
#'   Qualifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_get_runtime_management_config
#'
#' @aliases lambda_get_runtime_management_config
lambda_get_runtime_management_config <- function(FunctionName, Qualifier = NULL) {
  op <- new_operation(
    name = "GetRuntimeManagementConfig",
    http_method = "GET",
    http_path = "/2021-07-20/functions/{FunctionName}/runtime-management-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$get_runtime_management_config_input(FunctionName = FunctionName, Qualifier = Qualifier)
  output <- .lambda$get_runtime_management_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$get_runtime_management_config <- lambda_get_runtime_management_config

#' Invokes a Lambda function
#'
#' @description
#' Invokes a Lambda function. You can invoke a function synchronously (and
#' wait for the response), or asynchronously. By default, Lambda invokes
#' your function synchronously (i.e. the`InvocationType` is
#' `RequestResponse`). To invoke a function asynchronously, set
#' `InvocationType` to `Event`. Lambda passes the `ClientContext` object to
#' your function for synchronous invocations only.
#' 
#' For synchronous invocations, the maximum payload size is 6 MB. For
#' asynchronous invocations, the maximum payload size is 1 MB.
#' 
#' For [synchronous
#' invocation](https://docs.aws.amazon.com/lambda/latest/dg/invocation-sync.html),
#' details about the function response, including errors, are included in
#' the response body and headers. For either invocation type, you can find
#' more information in the [execution
#' log](https://docs.aws.amazon.com/lambda/latest/dg/lambda-monitoring.html)
#' and
#' [trace](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
#' 
#' When an error occurs, your function may be invoked multiple times. Retry
#' behavior varies by error type, client, event source, and invocation
#' type. For example, if you invoke a function asynchronously and it
#' returns an error, Lambda executes the function up to two more times. For
#' more information, see [Error handling and automatic retries in
#' Lambda](https://docs.aws.amazon.com/lambda/latest/dg/invocation-retries.html).
#' 
#' For [asynchronous
#' invocation](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html),
#' Lambda adds events to a queue before sending them to your function. If
#' your function does not have enough capacity to keep up with the queue,
#' events may be lost. Occasionally, your function may receive the same
#' event multiple times, even if no error occurs. To retain events that
#' were not processed, configure your function with a [dead-letter
#' queue](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
#' 
#' The status code in the API response doesn't reflect function errors.
#' Error codes are reserved for errors that prevent your function from
#' executing, such as permissions errors,
#' [quota](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html)
#' errors, or issues with your function's code and configuration. For
#' example, Lambda returns `TooManyRequestsException` if running the
#' function would cause you to exceed a concurrency limit at either the
#' account level (`ConcurrentInvocationLimitExceeded`) or function level
#' (`ReservedFunctionConcurrentInvocationLimitExceeded`).
#' 
#' For functions with a long timeout, your client might disconnect during
#' synchronous invocation while it waits for a response. Configure your
#' HTTP client, SDK, firewall, proxy, or operating system to allow for long
#' connections with timeout or keep-alive settings.
#' 
#' This operation requires permission for the
#' [lambda:InvokeFunction](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awslambda.html)
#' action. For details on how to set up permissions for cross-account
#' invocations, see [Granting function access to other
#' accounts](https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html#permissions-resource-xaccountinvoke).
#'
#' @usage
#' lambda_invoke(FunctionName, InvocationType, LogType, ClientContext,
#'   DurableExecutionName, Payload, Qualifier, TenantId)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param InvocationType Choose from the following options.
#' 
#' -   `RequestResponse` (default) – Invoke the function synchronously.
#'     Keep the connection open until the function returns a response or
#'     times out. The API response includes the function response and
#'     additional data.
#' 
#' -   `Event` – Invoke the function asynchronously. Send events that fail
#'     multiple times to the function's dead-letter queue (if one is
#'     configured). The API response only includes a status code.
#' 
#' -   `DryRun` – Validate parameter values and verify that the user or
#'     role has permission to invoke the function.
#' @param LogType Set to `Tail` to include the execution log in the response. Applies to
#' synchronously invoked functions only.
#' @param ClientContext Up to 3,583 bytes of base64-encoded data about the invoking client to
#' pass to the function in the context object. Lambda passes the
#' `ClientContext` object to your function for synchronous invocations
#' only.
#' @param DurableExecutionName Optional unique name for the durable execution. When you start your
#' special function, you can give it a unique name to identify this
#' specific execution. It's like giving a nickname to a task.
#' @param Payload The JSON that you want to provide to your Lambda function as input. The
#' maximum payload size is 6 MB for synchronous invocations and 1 MB for
#' asynchronous invocations.
#' 
#' You can enter the JSON directly. For example,
#' `--payload '{ "key": "value" }'`. You can also specify a file path. For
#' example, `--payload file://payload.json`.
#' @param Qualifier Specify a version or alias to invoke a published version of the
#' function.
#' @param TenantId The identifier of the tenant in a multi-tenant Lambda function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   StatusCode = 123,
#'   FunctionError = "string",
#'   LogResult = "string",
#'   Payload = raw,
#'   ExecutedVersion = "string",
#'   DurableExecutionArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke(
#'   FunctionName = "string",
#'   InvocationType = "Event"|"RequestResponse"|"DryRun",
#'   LogType = "None"|"Tail",
#'   ClientContext = "string",
#'   DurableExecutionName = "string",
#'   Payload = raw,
#'   Qualifier = "string",
#'   TenantId = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example invokes version 1 of a function named my-function
#' # with an empty event payload.
#' svc$invoke(
#'   FunctionName = "my-function",
#'   Payload = "{}",
#'   Qualifier = "1"
#' )
#' 
#' # The following example invokes version 1 of a function named my-function
#' # asynchronously.
#' svc$invoke(
#'   FunctionName = "my-function",
#'   InvocationType = "Event",
#'   Payload = "{}",
#'   Qualifier = "1"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_invoke
#'
#' @aliases lambda_invoke
lambda_invoke <- function(FunctionName, InvocationType = NULL, LogType = NULL, ClientContext = NULL, DurableExecutionName = NULL, Payload = NULL, Qualifier = NULL, TenantId = NULL) {
  op <- new_operation(
    name = "Invoke",
    http_method = "POST",
    http_path = "/2015-03-31/functions/{FunctionName}/invocations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$invoke_input(FunctionName = FunctionName, InvocationType = InvocationType, LogType = LogType, ClientContext = ClientContext, DurableExecutionName = DurableExecutionName, Payload = Payload, Qualifier = Qualifier, TenantId = TenantId)
  output <- .lambda$invoke_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$invoke <- lambda_invoke

#' For asynchronous function invocation, use Invoke
#'
#' @description
#' For asynchronous function invocation, use [`invoke`][lambda_invoke].
#' 
#' Invokes a function asynchronously.
#' 
#' The payload limit is 256KB. For larger payloads, for up to 1MB, use
#' [`invoke`][lambda_invoke].
#' 
#' If you do use the InvokeAsync action, note that it doesn't support the
#' use of X-Ray active tracing. Trace ID is not propagated to the function,
#' even if X-Ray active tracing is turned on.
#'
#' @usage
#' lambda_invoke_async(FunctionName, InvokeArgs)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param InvokeArgs &#91;required&#93; The JSON that you want to provide to your Lambda function as input.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke_async(
#'   FunctionName = "string",
#'   InvokeArgs = raw
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example invokes a Lambda function asynchronously
#' svc$invoke_async(
#'   FunctionName = "my-function",
#'   InvokeArgs = "{}"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_invoke_async
#'
#' @aliases lambda_invoke_async
lambda_invoke_async <- function(FunctionName, InvokeArgs) {
  op <- new_operation(
    name = "InvokeAsync",
    http_method = "POST",
    http_path = "/2014-11-13/functions/{FunctionName}/invoke-async",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$invoke_async_input(FunctionName = FunctionName, InvokeArgs = InvokeArgs)
  output <- .lambda$invoke_async_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$invoke_async <- lambda_invoke_async

#' Configure your Lambda functions to stream response payloads back to
#' clients
#'
#' @description
#' Configure your Lambda functions to stream response payloads back to
#' clients. For more information, see [Configuring a Lambda function to
#' stream
#' responses](https://docs.aws.amazon.com/lambda/latest/dg/configuration-response-streaming.html).
#' 
#' This operation requires permission for the
#' [lambda:InvokeFunction](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awslambda.html)
#' action. For details on how to set up permissions for cross-account
#' invocations, see [Granting function access to other
#' accounts](https://docs.aws.amazon.com/lambda/latest/dg/access-control-resource-based.html#permissions-resource-xaccountinvoke).
#'
#' @usage
#' lambda_invoke_with_response_stream(FunctionName, InvocationType,
#'   LogType, ClientContext, Qualifier, Payload, TenantId)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param InvocationType Use one of the following options:
#' 
#' -   `RequestResponse` (default) – Invoke the function synchronously.
#'     Keep the connection open until the function returns a response or
#'     times out. The API operation response includes the function response
#'     and additional data.
#' 
#' -   `DryRun` – Validate parameter values and verify that the IAM user or
#'     role has permission to invoke the function.
#' @param LogType Set to `Tail` to include the execution log in the response. Applies to
#' synchronously invoked functions only.
#' @param ClientContext Up to 3,583 bytes of base64-encoded data about the invoking client to
#' pass to the function in the context object.
#' @param Qualifier The alias name.
#' @param Payload The JSON that you want to provide to your Lambda function as input.
#' 
#' You can enter the JSON directly. For example,
#' `--payload '{ "key": "value" }'`. You can also specify a file path. For
#' example, `--payload file://payload.json`.
#' @param TenantId The identifier of the tenant in a multi-tenant Lambda function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   StatusCode = 123,
#'   ExecutedVersion = "string",
#'   EventStream = list(
#'     PayloadChunk = list(
#'       Payload = raw
#'     ),
#'     InvokeComplete = list(
#'       ErrorCode = "string",
#'       ErrorDetails = "string",
#'       LogResult = "string"
#'     )
#'   ),
#'   ResponseStreamContentType = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke_with_response_stream(
#'   FunctionName = "string",
#'   InvocationType = "RequestResponse"|"DryRun",
#'   LogType = "None"|"Tail",
#'   ClientContext = "string",
#'   Qualifier = "string",
#'   Payload = raw,
#'   TenantId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_invoke_with_response_stream
#'
#' @aliases lambda_invoke_with_response_stream
lambda_invoke_with_response_stream <- function(FunctionName, InvocationType = NULL, LogType = NULL, ClientContext = NULL, Qualifier = NULL, Payload = NULL, TenantId = NULL) {
  op <- new_operation(
    name = "InvokeWithResponseStream",
    http_method = "POST",
    http_path = "/2021-11-15/functions/{FunctionName}/response-streaming-invocations",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .lambda$invoke_with_response_stream_input(FunctionName = FunctionName, InvocationType = InvocationType, LogType = LogType, ClientContext = ClientContext, Qualifier = Qualifier, Payload = Payload, TenantId = TenantId)
  output <- .lambda$invoke_with_response_stream_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$invoke_with_response_stream <- lambda_invoke_with_response_stream

#' Returns a list of aliases for a Lambda function
#'
#' @description
#' Returns a list of
#' [aliases](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html)
#' for a Lambda function.
#'
#' @usage
#' lambda_list_aliases(FunctionName, FunctionVersion, Marker, MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param FunctionVersion Specify a function version to only list aliases that invoke that
#' version.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems Limit the number of aliases returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   Aliases = list(
#'     list(
#'       AliasArn = "string",
#'       Name = "string",
#'       FunctionVersion = "string",
#'       Description = "string",
#'       RoutingConfig = list(
#'         AdditionalVersionWeights = list(
#'           123.0
#'         )
#'       ),
#'       RevisionId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_aliases(
#'   FunctionName = "string",
#'   FunctionVersion = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns a list of aliases for a function named
#' # my-function.
#' svc$list_aliases(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_aliases
#'
#' @aliases lambda_list_aliases
lambda_list_aliases <- function(FunctionName, FunctionVersion = NULL, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListAliases",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}/aliases",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "Aliases"),
    stream_api = FALSE
  )
  input <- .lambda$list_aliases_input(FunctionName = FunctionName, FunctionVersion = FunctionVersion, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_aliases_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_aliases <- lambda_list_aliases

#' Returns a list of capacity providers in your account
#'
#' @description
#' Returns a list of capacity providers in your account.
#'
#' @usage
#' lambda_list_capacity_providers(State, Marker, MaxItems)
#'
#' @param State Filter capacity providers by their current state.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of capacity providers to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProviders = list(
#'     list(
#'       CapacityProviderArn = "string",
#'       State = "Pending"|"Active"|"Failed"|"Deleting",
#'       VpcConfig = list(
#'         SubnetIds = list(
#'           "string"
#'         ),
#'         SecurityGroupIds = list(
#'           "string"
#'         )
#'       ),
#'       PermissionsConfig = list(
#'         CapacityProviderOperatorRoleArn = "string"
#'       ),
#'       InstanceRequirements = list(
#'         Architectures = list(
#'           "x86_64"|"arm64"
#'         ),
#'         AllowedInstanceTypes = list(
#'           "string"
#'         ),
#'         ExcludedInstanceTypes = list(
#'           "string"
#'         )
#'       ),
#'       CapacityProviderScalingConfig = list(
#'         MaxVCpuCount = 123,
#'         ScalingMode = "Auto"|"Manual",
#'         ScalingPolicies = list(
#'           list(
#'             PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'             TargetValue = 123.0
#'           )
#'         )
#'       ),
#'       KmsKeyArn = "string",
#'       LastModified = "string"
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_capacity_providers(
#'   State = "Pending"|"Active"|"Failed"|"Deleting",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_capacity_providers
#'
#' @aliases lambda_list_capacity_providers
lambda_list_capacity_providers <- function(State = NULL, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListCapacityProviders",
    http_method = "GET",
    http_path = "/2025-11-30/capacity-providers",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "CapacityProviders"),
    stream_api = FALSE
  )
  input <- .lambda$list_capacity_providers_input(State = State, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_capacity_providers_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_capacity_providers <- lambda_list_capacity_providers

#' Returns a list of code signing configurations
#'
#' @description
#' Returns a list of [code signing
#' configurations](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
#' A request returns up to 10,000 configurations per call. You can use the
#' `MaxItems` parameter to return fewer configurations per call.
#'
#' @usage
#' lambda_list_code_signing_configs(Marker, MaxItems)
#'
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems Maximum number of items to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   CodeSigningConfigs = list(
#'     list(
#'       CodeSigningConfigId = "string",
#'       CodeSigningConfigArn = "string",
#'       Description = "string",
#'       AllowedPublishers = list(
#'         SigningProfileVersionArns = list(
#'           "string"
#'         )
#'       ),
#'       CodeSigningPolicies = list(
#'         UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'       ),
#'       LastModified = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_code_signing_configs(
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_code_signing_configs
#'
#' @aliases lambda_list_code_signing_configs
lambda_list_code_signing_configs <- function(Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListCodeSigningConfigs",
    http_method = "GET",
    http_path = "/2020-04-22/code-signing-configs",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "CodeSigningConfigs"),
    stream_api = FALSE
  )
  input <- .lambda$list_code_signing_configs_input(Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_code_signing_configs_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_code_signing_configs <- lambda_list_code_signing_configs

#' Returns a list of durable executions for a specified Lambda function
#'
#' @description
#' Returns a list of [durable
#' executions](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html)
#' for a specified Lambda function. You can filter the results by execution
#' name, status, and start time range. This API supports pagination for
#' large result sets.
#'
#' @usage
#' lambda_list_durable_executions_by_function(FunctionName, Qualifier,
#'   DurableExecutionName, Statuses, StartedAfter, StartedBefore,
#'   ReverseOrder, Marker, MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function. You can specify a function name,
#' a partial ARN, or a full ARN.
#' @param Qualifier The function version or alias. If not specified, lists executions for
#' the $LATEST version.
#' @param DurableExecutionName Filter executions by name. Only executions with names that contain this
#' string are returned.
#' @param Statuses Filter executions by status. Valid values: RUNNING, SUCCEEDED, FAILED,
#' TIMED_OUT, STOPPED.
#' @param StartedAfter Filter executions that started after this timestamp (ISO 8601 format).
#' @param StartedBefore Filter executions that started before this timestamp (ISO 8601 format).
#' @param ReverseOrder Set to true to return results in reverse chronological order (newest
#' first). Default is false.
#' @param Marker Pagination token from a previous request to continue retrieving results.
#' @param MaxItems Maximum number of executions to return (1-1000). Default is 100.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   DurableExecutions = list(
#'     list(
#'       DurableExecutionArn = "string",
#'       DurableExecutionName = "string",
#'       FunctionArn = "string",
#'       Status = "RUNNING"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"STOPPED",
#'       StartTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_durable_executions_by_function(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   DurableExecutionName = "string",
#'   Statuses = list(
#'     "RUNNING"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"STOPPED"
#'   ),
#'   StartedAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   StartedBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ReverseOrder = TRUE|FALSE,
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_durable_executions_by_function
#'
#' @aliases lambda_list_durable_executions_by_function
lambda_list_durable_executions_by_function <- function(FunctionName, Qualifier = NULL, DurableExecutionName = NULL, Statuses = NULL, StartedAfter = NULL, StartedBefore = NULL, ReverseOrder = NULL, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListDurableExecutionsByFunction",
    http_method = "GET",
    http_path = "/2025-12-01/functions/{FunctionName}/durable-executions",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "DurableExecutions"),
    stream_api = FALSE
  )
  input <- .lambda$list_durable_executions_by_function_input(FunctionName = FunctionName, Qualifier = Qualifier, DurableExecutionName = DurableExecutionName, Statuses = Statuses, StartedAfter = StartedAfter, StartedBefore = StartedBefore, ReverseOrder = ReverseOrder, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_durable_executions_by_function_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_durable_executions_by_function <- lambda_list_durable_executions_by_function

#' Lists event source mappings
#'
#' @description
#' Lists event source mappings. Specify an `EventSourceArn` to show only
#' event source mappings for a single event source.
#'
#' @usage
#' lambda_list_event_source_mappings(EventSourceArn, FunctionName, Marker,
#'   MaxItems)
#'
#' @param EventSourceArn The Amazon Resource Name (ARN) of the event source.
#' 
#' -   **Amazon Kinesis** – The ARN of the data stream or a stream
#'     consumer.
#' 
#' -   **Amazon DynamoDB Streams** – The ARN of the stream.
#' 
#' -   **Amazon Simple Queue Service** – The ARN of the queue.
#' 
#' -   **Amazon Managed Streaming for Apache Kafka** – The ARN of the
#'     cluster or the ARN of the VPC connection (for [cross-account event
#'     source
#'     mappings](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#msk-multi-vpc)).
#' 
#' -   **Amazon MQ** – The ARN of the broker.
#' 
#' -   **Amazon DocumentDB** – The ARN of the DocumentDB change stream.
#' @param FunctionName The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `MyFunction`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Version or Alias ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD`.
#' 
#' -   **Partial ARN** – `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it's limited to 64 characters in length.
#' @param Marker A pagination token returned by a previous call.
#' @param MaxItems The maximum number of event source mappings to return. Note that
#' ListEventSourceMappings returns a maximum of 100 items in each response,
#' even if you set the number higher.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   EventSourceMappings = list(
#'     list(
#'       UUID = "string",
#'       StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'       StartingPositionTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       BatchSize = 123,
#'       MaximumBatchingWindowInSeconds = 123,
#'       ParallelizationFactor = 123,
#'       EventSourceArn = "string",
#'       FilterCriteria = list(
#'         Filters = list(
#'           list(
#'             Pattern = "string"
#'           )
#'         )
#'       ),
#'       FunctionArn = "string",
#'       LastModified = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastProcessingResult = "string",
#'       State = "string",
#'       StateTransitionReason = "string",
#'       DestinationConfig = list(
#'         OnSuccess = list(
#'           Destination = "string"
#'         ),
#'         OnFailure = list(
#'           Destination = "string"
#'         )
#'       ),
#'       Topics = list(
#'         "string"
#'       ),
#'       Queues = list(
#'         "string"
#'       ),
#'       SourceAccessConfigurations = list(
#'         list(
#'           Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SelfManagedEventSource = list(
#'         Endpoints = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       MaximumRecordAgeInSeconds = 123,
#'       BisectBatchOnFunctionError = TRUE|FALSE,
#'       MaximumRetryAttempts = 123,
#'       TumblingWindowInSeconds = 123,
#'       FunctionResponseTypes = list(
#'         "ReportBatchItemFailures"
#'       ),
#'       AmazonManagedKafkaEventSourceConfig = list(
#'         ConsumerGroupId = "string",
#'         SchemaRegistryConfig = list(
#'           SchemaRegistryURI = "string",
#'           EventRecordFormat = "JSON"|"SOURCE",
#'           AccessConfigs = list(
#'             list(
#'               Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'               URI = "string"
#'             )
#'           ),
#'           SchemaValidationConfigs = list(
#'             list(
#'               Attribute = "KEY"|"VALUE"
#'             )
#'           )
#'         )
#'       ),
#'       SelfManagedKafkaEventSourceConfig = list(
#'         ConsumerGroupId = "string",
#'         SchemaRegistryConfig = list(
#'           SchemaRegistryURI = "string",
#'           EventRecordFormat = "JSON"|"SOURCE",
#'           AccessConfigs = list(
#'             list(
#'               Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'               URI = "string"
#'             )
#'           ),
#'           SchemaValidationConfigs = list(
#'             list(
#'               Attribute = "KEY"|"VALUE"
#'             )
#'           )
#'         )
#'       ),
#'       ScalingConfig = list(
#'         MaximumConcurrency = 123
#'       ),
#'       DocumentDBEventSourceConfig = list(
#'         DatabaseName = "string",
#'         CollectionName = "string",
#'         FullDocument = "UpdateLookup"|"Default"
#'       ),
#'       KMSKeyArn = "string",
#'       FilterCriteriaError = list(
#'         ErrorCode = "string",
#'         Message = "string"
#'       ),
#'       EventSourceMappingArn = "string",
#'       MetricsConfig = list(
#'         Metrics = list(
#'           "EventCount"
#'         )
#'       ),
#'       ProvisionedPollerConfig = list(
#'         MinimumPollers = 123,
#'         MaximumPollers = 123,
#'         PollerGroupName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_event_source_mappings(
#'   EventSourceArn = "string",
#'   FunctionName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns a list of the event source mappings for a
#' # function named my-function.
#' svc$list_event_source_mappings(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_event_source_mappings
#'
#' @aliases lambda_list_event_source_mappings
lambda_list_event_source_mappings <- function(EventSourceArn = NULL, FunctionName = NULL, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListEventSourceMappings",
    http_method = "GET",
    http_path = "/2015-03-31/event-source-mappings",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "EventSourceMappings"),
    stream_api = FALSE
  )
  input <- .lambda$list_event_source_mappings_input(EventSourceArn = EventSourceArn, FunctionName = FunctionName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_event_source_mappings_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_event_source_mappings <- lambda_list_event_source_mappings

#' Retrieves a list of configurations for asynchronous invocation for a
#' function
#'
#' @description
#' Retrieves a list of configurations for asynchronous invocation for a
#' function.
#' 
#' To configure options for asynchronous invocation, use
#' [`put_function_event_invoke_config`][lambda_put_function_event_invoke_config].
#'
#' @usage
#' lambda_list_function_event_invoke_configs(FunctionName, Marker,
#'   MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `my-function`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** - `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of configurations to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionEventInvokeConfigs = list(
#'     list(
#'       LastModified = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       FunctionArn = "string",
#'       MaximumRetryAttempts = 123,
#'       MaximumEventAgeInSeconds = 123,
#'       DestinationConfig = list(
#'         OnSuccess = list(
#'           Destination = "string"
#'         ),
#'         OnFailure = list(
#'           Destination = "string"
#'         )
#'       )
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_function_event_invoke_configs(
#'   FunctionName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns a list of asynchronous invocation
#' # configurations for a function named my-function.
#' svc$list_function_event_invoke_configs(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_function_event_invoke_configs
#'
#' @aliases lambda_list_function_event_invoke_configs
lambda_list_function_event_invoke_configs <- function(FunctionName, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListFunctionEventInvokeConfigs",
    http_method = "GET",
    http_path = "/2019-09-25/functions/{FunctionName}/event-invoke-config/list",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "FunctionEventInvokeConfigs"),
    stream_api = FALSE
  )
  input <- .lambda$list_function_event_invoke_configs_input(FunctionName = FunctionName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_function_event_invoke_configs_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_function_event_invoke_configs <- lambda_list_function_event_invoke_configs

#' Returns a list of Lambda function URLs for the specified function
#'
#' @description
#' Returns a list of Lambda function URLs for the specified function.
#'
#' @usage
#' lambda_list_function_url_configs(FunctionName, Marker, MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of function URLs to return in the response. Note that
#' [`list_function_url_configs`][lambda_list_function_url_configs] returns
#' a maximum of 50 items in each response, even if you set the number
#' higher.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionUrlConfigs = list(
#'     list(
#'       FunctionUrl = "string",
#'       FunctionArn = "string",
#'       CreationTime = "string",
#'       LastModifiedTime = "string",
#'       Cors = list(
#'         AllowCredentials = TRUE|FALSE,
#'         AllowHeaders = list(
#'           "string"
#'         ),
#'         AllowMethods = list(
#'           "string"
#'         ),
#'         AllowOrigins = list(
#'           "string"
#'         ),
#'         ExposeHeaders = list(
#'           "string"
#'         ),
#'         MaxAge = 123
#'       ),
#'       AuthType = "NONE"|"AWS_IAM",
#'       InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_function_url_configs(
#'   FunctionName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_function_url_configs
#'
#' @aliases lambda_list_function_url_configs
lambda_list_function_url_configs <- function(FunctionName, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListFunctionUrlConfigs",
    http_method = "GET",
    http_path = "/2021-10-31/functions/{FunctionName}/urls",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "FunctionUrlConfigs"),
    stream_api = FALSE
  )
  input <- .lambda$list_function_url_configs_input(FunctionName = FunctionName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_function_url_configs_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_function_url_configs <- lambda_list_function_url_configs

#' Returns a list of function versions that are configured to use a
#' specific capacity provider
#'
#' @description
#' Returns a list of function versions that are configured to use a
#' specific capacity provider.
#'
#' @usage
#' lambda_list_function_versions_by_capacity_provider(CapacityProviderName,
#'   Marker, MaxItems)
#'
#' @param CapacityProviderName &#91;required&#93; The name of the capacity provider to list function versions for.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of function versions to return in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProviderArn = "string",
#'   FunctionVersions = list(
#'     list(
#'       FunctionArn = "string",
#'       State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting"
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_function_versions_by_capacity_provider(
#'   CapacityProviderName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_function_versions_by_capacity_provider
#'
#' @aliases lambda_list_function_versions_by_capacity_provider
lambda_list_function_versions_by_capacity_provider <- function(CapacityProviderName, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListFunctionVersionsByCapacityProvider",
    http_method = "GET",
    http_path = "/2025-11-30/capacity-providers/{CapacityProviderName}/function-versions",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "FunctionVersions"),
    stream_api = FALSE
  )
  input <- .lambda$list_function_versions_by_capacity_provider_input(CapacityProviderName = CapacityProviderName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_function_versions_by_capacity_provider_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_function_versions_by_capacity_provider <- lambda_list_function_versions_by_capacity_provider

#' Returns a list of Lambda functions, with the version-specific
#' configuration of each
#'
#' @description
#' Returns a list of Lambda functions, with the version-specific
#' configuration of each. Lambda returns up to 50 functions per call.
#' 
#' Set `FunctionVersion` to `ALL` to include all published versions of each
#' function in addition to the unpublished version.
#' 
#' The [`list_functions`][lambda_list_functions] operation returns a subset
#' of the FunctionConfiguration fields. To get the additional fields
#' (State, StateReasonCode, StateReason, LastUpdateStatus,
#' LastUpdateStatusReason, LastUpdateStatusReasonCode,
#' RuntimeVersionConfig) for a function or version, use
#' [`get_function`][lambda_get_function].
#'
#' @usage
#' lambda_list_functions(MasterRegion, FunctionVersion, Marker, MaxItems)
#'
#' @param MasterRegion For Lambda@@Edge functions, the Amazon Web Services Region of the master
#' function. For example, `us-east-1` filters the list of functions to
#' include only Lambda@@Edge functions replicated from a master function in
#' US East (N. Virginia). If specified, you must set `FunctionVersion` to
#' `ALL`.
#' @param FunctionVersion Set to `ALL` to include entries for all published versions of each
#' function.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of functions to return in the response. Note that
#' [`list_functions`][lambda_list_functions] returns a maximum of 50 items
#' in each response, even if you set the number higher.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   Functions = list(
#'     list(
#'       FunctionName = "string",
#'       FunctionArn = "string",
#'       Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'       Role = "string",
#'       Handler = "string",
#'       CodeSize = 123,
#'       Description = "string",
#'       Timeout = 123,
#'       MemorySize = 123,
#'       LastModified = "string",
#'       CodeSha256 = "string",
#'       Version = "string",
#'       VpcConfig = list(
#'         SubnetIds = list(
#'           "string"
#'         ),
#'         SecurityGroupIds = list(
#'           "string"
#'         ),
#'         VpcId = "string",
#'         Ipv6AllowedForDualStack = TRUE|FALSE
#'       ),
#'       DeadLetterConfig = list(
#'         TargetArn = "string"
#'       ),
#'       Environment = list(
#'         Variables = list(
#'           "string"
#'         ),
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       KMSKeyArn = "string",
#'       TracingConfig = list(
#'         Mode = "Active"|"PassThrough"
#'       ),
#'       MasterArn = "string",
#'       RevisionId = "string",
#'       Layers = list(
#'         list(
#'           Arn = "string",
#'           CodeSize = 123,
#'           SigningProfileVersionArn = "string",
#'           SigningJobArn = "string"
#'         )
#'       ),
#'       State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'       StateReason = "string",
#'       StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'       LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'       LastUpdateStatusReason = "string",
#'       LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'       FileSystemConfigs = list(
#'         list(
#'           Arn = "string",
#'           LocalMountPath = "string"
#'         )
#'       ),
#'       PackageType = "Zip"|"Image",
#'       ImageConfigResponse = list(
#'         ImageConfig = list(
#'           EntryPoint = list(
#'             "string"
#'           ),
#'           Command = list(
#'             "string"
#'           ),
#'           WorkingDirectory = "string"
#'         ),
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string",
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       EphemeralStorage = list(
#'         Size = 123
#'       ),
#'       SnapStart = list(
#'         ApplyOn = "PublishedVersions"|"None",
#'         OptimizationStatus = "On"|"Off"
#'       ),
#'       RuntimeVersionConfig = list(
#'         RuntimeVersionArn = "string",
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       LoggingConfig = list(
#'         LogFormat = "JSON"|"Text",
#'         ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'         SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'         LogGroup = "string"
#'       ),
#'       CapacityProviderConfig = list(
#'         LambdaManagedInstancesCapacityProviderConfig = list(
#'           CapacityProviderArn = "string",
#'           PerExecutionEnvironmentMaxConcurrency = 123,
#'           ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'         )
#'       ),
#'       ConfigSha256 = "string",
#'       DurableConfig = list(
#'         RetentionPeriodInDays = 123,
#'         ExecutionTimeout = 123
#'       ),
#'       TenancyConfig = list(
#'         TenantIsolationMode = "PER_TENANT"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_functions(
#'   MasterRegion = "string",
#'   FunctionVersion = "ALL",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This operation returns a list of Lambda functions.
#' svc$list_functions()
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_functions
#'
#' @aliases lambda_list_functions
lambda_list_functions <- function(MasterRegion = NULL, FunctionVersion = NULL, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListFunctions",
    http_method = "GET",
    http_path = "/2015-03-31/functions",
    host_prefix = "",
    paginator = list(input_token = "Marker", output_token = "NextMarker", limit_key = "MaxItems", result_key = "Functions"),
    stream_api = FALSE
  )
  input <- .lambda$list_functions_input(MasterRegion = MasterRegion, FunctionVersion = FunctionVersion, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_functions_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_functions <- lambda_list_functions

#' List the functions that use the specified code signing configuration
#'
#' @description
#' List the functions that use the specified code signing configuration.
#' You can use this method prior to deleting a code signing configuration,
#' to verify that no functions are using it.
#'
#' @usage
#' lambda_list_functions_by_code_signing_config(CodeSigningConfigArn,
#'   Marker, MaxItems)
#'
#' @param CodeSigningConfigArn &#91;required&#93; The The Amazon Resource Name (ARN) of the code signing configuration.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems Maximum number of items to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   FunctionArns = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_functions_by_code_signing_config(
#'   CodeSigningConfigArn = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_list_functions_by_code_signing_config
#'
#' @aliases lambda_list_functions_by_code_signing_config
lambda_list_functions_by_code_signing_config <- function(CodeSigningConfigArn, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListFunctionsByCodeSigningConfig",
    http_method = "GET",
    http_path = "/2020-04-22/code-signing-configs/{CodeSigningConfigArn}/functions",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "FunctionArns"),
    stream_api = FALSE
  )
  input <- .lambda$list_functions_by_code_signing_config_input(CodeSigningConfigArn = CodeSigningConfigArn, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_functions_by_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_functions_by_code_signing_config <- lambda_list_functions_by_code_signing_config

#' Lists the versions of an Lambda layer
#'
#' @description
#' Lists the versions of an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html).
#' Versions that have been deleted aren't listed. Specify a [runtime
#' identifier](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html)
#' to list only versions that indicate that they're compatible with that
#' runtime. Specify a compatible architecture to include only layer
#' versions that are compatible with that architecture.
#'
#' @usage
#' lambda_list_layer_versions(CompatibleRuntime, LayerName, Marker,
#'   MaxItems, CompatibleArchitecture)
#'
#' @param CompatibleRuntime A runtime identifier.
#' 
#' The following list includes deprecated runtimes. For more information,
#' see [Runtime use after
#' deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels).
#' 
#' For a list of all currently supported runtimes, see [Supported
#' runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param Marker A pagination token returned by a previous call.
#' @param MaxItems The maximum number of versions to return.
#' @param CompatibleArchitecture The compatible [instruction set
#' architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   LayerVersions = list(
#'     list(
#'       LayerVersionArn = "string",
#'       Version = 123,
#'       Description = "string",
#'       CreatedDate = "string",
#'       CompatibleRuntimes = list(
#'         "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'       ),
#'       LicenseInfo = "string",
#'       CompatibleArchitectures = list(
#'         "x86_64"|"arm64"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_layer_versions(
#'   CompatibleRuntime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   LayerName = "string",
#'   Marker = "string",
#'   MaxItems = 123,
#'   CompatibleArchitecture = "x86_64"|"arm64"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example displays information about the versions for the
#' # layer named blank-java-lib
#' svc$list_layer_versions(
#'   LayerName = "blank-java-lib"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_layer_versions
#'
#' @aliases lambda_list_layer_versions
lambda_list_layer_versions <- function(CompatibleRuntime = NULL, LayerName, Marker = NULL, MaxItems = NULL, CompatibleArchitecture = NULL) {
  op <- new_operation(
    name = "ListLayerVersions",
    http_method = "GET",
    http_path = "/2018-10-31/layers/{LayerName}/versions",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "LayerVersions"),
    stream_api = FALSE
  )
  input <- .lambda$list_layer_versions_input(CompatibleRuntime = CompatibleRuntime, LayerName = LayerName, Marker = Marker, MaxItems = MaxItems, CompatibleArchitecture = CompatibleArchitecture)
  output <- .lambda$list_layer_versions_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_layer_versions <- lambda_list_layer_versions

#' Lists Lambda layers and shows information about the latest version of
#' each
#'
#' @description
#' Lists [Lambda
#' layers](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)
#' and shows information about the latest version of each. Specify a
#' [runtime
#' identifier](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html)
#' to list only layers that indicate that they're compatible with that
#' runtime. Specify a compatible architecture to include only layers that
#' are compatible with that [instruction set
#' architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
#'
#' @usage
#' lambda_list_layers(CompatibleRuntime, Marker, MaxItems,
#'   CompatibleArchitecture)
#'
#' @param CompatibleRuntime A runtime identifier.
#' 
#' The following list includes deprecated runtimes. For more information,
#' see [Runtime use after
#' deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels).
#' 
#' For a list of all currently supported runtimes, see [Supported
#' runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
#' @param Marker A pagination token returned by a previous call.
#' @param MaxItems The maximum number of layers to return.
#' @param CompatibleArchitecture The compatible [instruction set
#' architecture](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   Layers = list(
#'     list(
#'       LayerName = "string",
#'       LayerArn = "string",
#'       LatestMatchingVersion = list(
#'         LayerVersionArn = "string",
#'         Version = 123,
#'         Description = "string",
#'         CreatedDate = "string",
#'         CompatibleRuntimes = list(
#'           "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'         ),
#'         LicenseInfo = "string",
#'         CompatibleArchitectures = list(
#'           "x86_64"|"arm64"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_layers(
#'   CompatibleRuntime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Marker = "string",
#'   MaxItems = 123,
#'   CompatibleArchitecture = "x86_64"|"arm64"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns information about layers that are
#' # compatible with the Python 3.7 runtime.
#' svc$list_layers(
#'   CompatibleRuntime = "python3.7"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_layers
#'
#' @aliases lambda_list_layers
lambda_list_layers <- function(CompatibleRuntime = NULL, Marker = NULL, MaxItems = NULL, CompatibleArchitecture = NULL) {
  op <- new_operation(
    name = "ListLayers",
    http_method = "GET",
    http_path = "/2018-10-31/layers",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "Layers"),
    stream_api = FALSE
  )
  input <- .lambda$list_layers_input(CompatibleRuntime = CompatibleRuntime, Marker = Marker, MaxItems = MaxItems, CompatibleArchitecture = CompatibleArchitecture)
  output <- .lambda$list_layers_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_layers <- lambda_list_layers

#' Retrieves a list of provisioned concurrency configurations for a
#' function
#'
#' @description
#' Retrieves a list of provisioned concurrency configurations for a
#' function.
#'
#' @usage
#' lambda_list_provisioned_concurrency_configs(FunctionName, Marker,
#'   MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems Specify a number to limit the number of configurations returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProvisionedConcurrencyConfigs = list(
#'     list(
#'       FunctionArn = "string",
#'       RequestedProvisionedConcurrentExecutions = 123,
#'       AvailableProvisionedConcurrentExecutions = 123,
#'       AllocatedProvisionedConcurrentExecutions = 123,
#'       Status = "IN_PROGRESS"|"READY"|"FAILED",
#'       StatusReason = "string",
#'       LastModified = "string"
#'     )
#'   ),
#'   NextMarker = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_provisioned_concurrency_configs(
#'   FunctionName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns a list of provisioned concurrency
#' # configurations for a function named my-function.
#' svc$list_provisioned_concurrency_configs(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_provisioned_concurrency_configs
#'
#' @aliases lambda_list_provisioned_concurrency_configs
lambda_list_provisioned_concurrency_configs <- function(FunctionName, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListProvisionedConcurrencyConfigs",
    http_method = "GET",
    http_path = "/2019-09-30/functions/{FunctionName}/provisioned-concurrency?List=ALL",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "ProvisionedConcurrencyConfigs"),
    stream_api = FALSE
  )
  input <- .lambda$list_provisioned_concurrency_configs_input(FunctionName = FunctionName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_provisioned_concurrency_configs_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_provisioned_concurrency_configs <- lambda_list_provisioned_concurrency_configs

#' Returns a function, event source mapping, or code signing
#' configuration's tags
#'
#' @description
#' Returns a function, event source mapping, or code signing
#' configuration's
#' [tags](https://docs.aws.amazon.com/lambda/latest/dg/configuration-tags.html).
#' You can also view function tags with
#' [`get_function`][lambda_get_function].
#'
#' @usage
#' lambda_list_tags(Resource)
#'
#' @param Resource &#91;required&#93; The resource's Amazon Resource Name (ARN). Note: Lambda does not support
#' adding tags to function aliases or versions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags(
#'   Resource = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example displays the tags attached to the my-function
#' # Lambda function.
#' svc$list_tags(
#'   Resource = "arn:aws:lambda:us-west-2:123456789012:function:my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_tags
#'
#' @aliases lambda_list_tags
lambda_list_tags <- function(Resource) {
  op <- new_operation(
    name = "ListTags",
    http_method = "GET",
    http_path = "/2017-03-31/tags/{Resource}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$list_tags_input(Resource = Resource)
  output <- .lambda$list_tags_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_tags <- lambda_list_tags

#' Returns a list of versions, with the version-specific configuration of
#' each
#'
#' @description
#' Returns a list of
#' [versions](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html),
#' with the version-specific configuration of each. Lambda returns up to 50
#' versions per call.
#'
#' @usage
#' lambda_list_versions_by_function(FunctionName, Marker, MaxItems)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Marker Specify the pagination token that's returned by a previous request to
#' retrieve the next page of results.
#' @param MaxItems The maximum number of versions to return. Note that
#' [`list_versions_by_function`][lambda_list_versions_by_function] returns
#' a maximum of 50 items in each response, even if you set the number
#' higher.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextMarker = "string",
#'   Versions = list(
#'     list(
#'       FunctionName = "string",
#'       FunctionArn = "string",
#'       Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'       Role = "string",
#'       Handler = "string",
#'       CodeSize = 123,
#'       Description = "string",
#'       Timeout = 123,
#'       MemorySize = 123,
#'       LastModified = "string",
#'       CodeSha256 = "string",
#'       Version = "string",
#'       VpcConfig = list(
#'         SubnetIds = list(
#'           "string"
#'         ),
#'         SecurityGroupIds = list(
#'           "string"
#'         ),
#'         VpcId = "string",
#'         Ipv6AllowedForDualStack = TRUE|FALSE
#'       ),
#'       DeadLetterConfig = list(
#'         TargetArn = "string"
#'       ),
#'       Environment = list(
#'         Variables = list(
#'           "string"
#'         ),
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       KMSKeyArn = "string",
#'       TracingConfig = list(
#'         Mode = "Active"|"PassThrough"
#'       ),
#'       MasterArn = "string",
#'       RevisionId = "string",
#'       Layers = list(
#'         list(
#'           Arn = "string",
#'           CodeSize = 123,
#'           SigningProfileVersionArn = "string",
#'           SigningJobArn = "string"
#'         )
#'       ),
#'       State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'       StateReason = "string",
#'       StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'       LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'       LastUpdateStatusReason = "string",
#'       LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'       FileSystemConfigs = list(
#'         list(
#'           Arn = "string",
#'           LocalMountPath = "string"
#'         )
#'       ),
#'       PackageType = "Zip"|"Image",
#'       ImageConfigResponse = list(
#'         ImageConfig = list(
#'           EntryPoint = list(
#'             "string"
#'           ),
#'           Command = list(
#'             "string"
#'           ),
#'           WorkingDirectory = "string"
#'         ),
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string",
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       EphemeralStorage = list(
#'         Size = 123
#'       ),
#'       SnapStart = list(
#'         ApplyOn = "PublishedVersions"|"None",
#'         OptimizationStatus = "On"|"Off"
#'       ),
#'       RuntimeVersionConfig = list(
#'         RuntimeVersionArn = "string",
#'         Error = list(
#'           ErrorCode = "string",
#'           Message = "string"
#'         )
#'       ),
#'       LoggingConfig = list(
#'         LogFormat = "JSON"|"Text",
#'         ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'         SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'         LogGroup = "string"
#'       ),
#'       CapacityProviderConfig = list(
#'         LambdaManagedInstancesCapacityProviderConfig = list(
#'           CapacityProviderArn = "string",
#'           PerExecutionEnvironmentMaxConcurrency = 123,
#'           ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'         )
#'       ),
#'       ConfigSha256 = "string",
#'       DurableConfig = list(
#'         RetentionPeriodInDays = 123,
#'         ExecutionTimeout = 123
#'       ),
#'       TenancyConfig = list(
#'         TenantIsolationMode = "PER_TENANT"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_versions_by_function(
#'   FunctionName = "string",
#'   Marker = "string",
#'   MaxItems = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns a list of versions of a function named
#' # my-function
#' svc$list_versions_by_function(
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_list_versions_by_function
#'
#' @aliases lambda_list_versions_by_function
lambda_list_versions_by_function <- function(FunctionName, Marker = NULL, MaxItems = NULL) {
  op <- new_operation(
    name = "ListVersionsByFunction",
    http_method = "GET",
    http_path = "/2015-03-31/functions/{FunctionName}/versions",
    host_prefix = "",
    paginator = list(input_token = "Marker", limit_key = "MaxItems", output_token = "NextMarker", result_key = "Versions"),
    stream_api = FALSE
  )
  input <- .lambda$list_versions_by_function_input(FunctionName = FunctionName, Marker = Marker, MaxItems = MaxItems)
  output <- .lambda$list_versions_by_function_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$list_versions_by_function <- lambda_list_versions_by_function

#' Creates an Lambda layer from a ZIP archive
#'
#' @description
#' Creates an [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)
#' from a ZIP archive. Each time you call
#' [`publish_layer_version`][lambda_publish_layer_version] with the same
#' layer name, a new version is created.
#' 
#' Add layers to your function with
#' [`create_function`][lambda_create_function] or
#' [`update_function_configuration`][lambda_update_function_configuration].
#'
#' @usage
#' lambda_publish_layer_version(LayerName, Description, Content,
#'   CompatibleRuntimes, LicenseInfo, CompatibleArchitectures)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param Description The description of the version.
#' @param Content &#91;required&#93; The function layer archive.
#' @param CompatibleRuntimes A list of compatible [function
#' runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).
#' Used for filtering with [`list_layers`][lambda_list_layers] and
#' [`list_layer_versions`][lambda_list_layer_versions].
#' 
#' The following list includes deprecated runtimes. For more information,
#' see [Runtime deprecation
#' policy](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-support-policy).
#' @param LicenseInfo The layer's software license. It can be any of the following:
#' 
#' -   An [SPDX license identifier](https://spdx.org/licenses/). For
#'     example, `MIT`.
#' 
#' -   The URL of a license hosted on the internet. For example,
#'     `https://opensource.org/licenses/MIT`.
#' 
#' -   The full text of the license.
#' @param CompatibleArchitectures A list of compatible [instruction set
#' architectures](https://docs.aws.amazon.com/lambda/latest/dg/foundation-arch.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Content = list(
#'     Location = "string",
#'     CodeSha256 = "string",
#'     CodeSize = 123,
#'     SigningProfileVersionArn = "string",
#'     SigningJobArn = "string"
#'   ),
#'   LayerArn = "string",
#'   LayerVersionArn = "string",
#'   Description = "string",
#'   CreatedDate = "string",
#'   Version = 123,
#'   CompatibleRuntimes = list(
#'     "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'   ),
#'   LicenseInfo = "string",
#'   CompatibleArchitectures = list(
#'     "x86_64"|"arm64"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$publish_layer_version(
#'   LayerName = "string",
#'   Description = "string",
#'   Content = list(
#'     S3Bucket = "string",
#'     S3Key = "string",
#'     S3ObjectVersion = "string",
#'     ZipFile = raw
#'   ),
#'   CompatibleRuntimes = list(
#'     "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10"
#'   ),
#'   LicenseInfo = "string",
#'   CompatibleArchitectures = list(
#'     "x86_64"|"arm64"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example creates a new Python library layer version. The
#' # command retrieves the layer content a file named layer.zip in the
#' # specified S3 bucket.
#' svc$publish_layer_version(
#'   CompatibleRuntimes = list(
#'     "python3.6",
#'     "python3.7"
#'   ),
#'   Content = list(
#'     S3Bucket = "lambda-layers-us-west-2-123456789012",
#'     S3Key = "layer.zip"
#'   ),
#'   Description = "My Python layer",
#'   LayerName = "my-layer",
#'   LicenseInfo = "MIT"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_publish_layer_version
#'
#' @aliases lambda_publish_layer_version
lambda_publish_layer_version <- function(LayerName, Description = NULL, Content, CompatibleRuntimes = NULL, LicenseInfo = NULL, CompatibleArchitectures = NULL) {
  op <- new_operation(
    name = "PublishLayerVersion",
    http_method = "POST",
    http_path = "/2018-10-31/layers/{LayerName}/versions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$publish_layer_version_input(LayerName = LayerName, Description = Description, Content = Content, CompatibleRuntimes = CompatibleRuntimes, LicenseInfo = LicenseInfo, CompatibleArchitectures = CompatibleArchitectures)
  output <- .lambda$publish_layer_version_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$publish_layer_version <- lambda_publish_layer_version

#' Creates a version from the current code and configuration of a function
#'
#' @description
#' Creates a
#' [version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
#' from the current code and configuration of a function. Use versions to
#' create a snapshot of your function code and configuration that doesn't
#' change.
#' 
#' Lambda doesn't publish a version if the function's configuration and
#' code haven't changed since the last version. Use
#' [`update_function_code`][lambda_update_function_code] or
#' [`update_function_configuration`][lambda_update_function_configuration]
#' to update the function before publishing a version.
#' 
#' Clients can invoke versions directly or with an alias. To create an
#' alias, use [`create_alias`][lambda_create_alias].
#'
#' @usage
#' lambda_publish_version(FunctionName, CodeSha256, Description,
#'   RevisionId, PublishTo)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param CodeSha256 Only publish a version if the hash value matches the value that's
#' specified. Use this option to avoid publishing a version if the function
#' code has changed since you last updated it. You can get the hash for the
#' version that you uploaded from the output of
#' [`update_function_code`][lambda_update_function_code].
#' @param Description A description for the version to override the description in the
#' function configuration.
#' @param RevisionId Only update the function if the revision ID matches the ID that's
#' specified. Use this option to avoid publishing a version if the function
#' configuration has changed since you last updated it.
#' @param PublishTo Specifies where to publish the function version or configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionName = "string",
#'   FunctionArn = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   CodeSize = 123,
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   LastModified = "string",
#'   CodeSha256 = "string",
#'   Version = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     VpcId = "string",
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   MasterArn = "string",
#'   RevisionId = "string",
#'   Layers = list(
#'     list(
#'       Arn = "string",
#'       CodeSize = 123,
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string"
#'     )
#'   ),
#'   State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'   StateReason = "string",
#'   StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'   LastUpdateStatusReason = "string",
#'   LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   PackageType = "Zip"|"Image",
#'   ImageConfigResponse = list(
#'     ImageConfig = list(
#'       EntryPoint = list(
#'         "string"
#'       ),
#'       Command = list(
#'         "string"
#'       ),
#'       WorkingDirectory = "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   SigningProfileVersionArn = "string",
#'   SigningJobArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None",
#'     OptimizationStatus = "On"|"Off"
#'   ),
#'   RuntimeVersionConfig = list(
#'     RuntimeVersionArn = "string",
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   ConfigSha256 = "string",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$publish_version(
#'   FunctionName = "string",
#'   CodeSha256 = "string",
#'   Description = "string",
#'   RevisionId = "string",
#'   PublishTo = "LATEST_PUBLISHED"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This operation publishes a version of a Lambda function
#' svc$publish_version(
#'   CodeSha256 = "",
#'   Description = "",
#'   FunctionName = "myFunction"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_publish_version
#'
#' @aliases lambda_publish_version
lambda_publish_version <- function(FunctionName, CodeSha256 = NULL, Description = NULL, RevisionId = NULL, PublishTo = NULL) {
  op <- new_operation(
    name = "PublishVersion",
    http_method = "POST",
    http_path = "/2015-03-31/functions/{FunctionName}/versions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$publish_version_input(FunctionName = FunctionName, CodeSha256 = CodeSha256, Description = Description, RevisionId = RevisionId, PublishTo = PublishTo)
  output <- .lambda$publish_version_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$publish_version <- lambda_publish_version

#' Update the code signing configuration for the function
#'
#' @description
#' Update the code signing configuration for the function. Changes to the
#' code signing configuration take effect the next time a user tries to
#' deploy a code package to the function.
#'
#' @usage
#' lambda_put_function_code_signing_config(CodeSigningConfigArn,
#'   FunctionName)
#'
#' @param CodeSigningConfigArn &#91;required&#93; The The Amazon Resource Name (ARN) of the code signing configuration.
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeSigningConfigArn = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_function_code_signing_config(
#'   CodeSigningConfigArn = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_put_function_code_signing_config
#'
#' @aliases lambda_put_function_code_signing_config
lambda_put_function_code_signing_config <- function(CodeSigningConfigArn, FunctionName) {
  op <- new_operation(
    name = "PutFunctionCodeSigningConfig",
    http_method = "PUT",
    http_path = "/2020-06-30/functions/{FunctionName}/code-signing-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_function_code_signing_config_input(CodeSigningConfigArn = CodeSigningConfigArn, FunctionName = FunctionName)
  output <- .lambda$put_function_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_function_code_signing_config <- lambda_put_function_code_signing_config

#' Sets the maximum number of simultaneous executions for a function, and
#' reserves capacity for that concurrency level
#'
#' @description
#' Sets the maximum number of simultaneous executions for a function, and
#' reserves capacity for that concurrency level.
#' 
#' Concurrency settings apply to the function as a whole, including all
#' published versions and the unpublished version. Reserving concurrency
#' both ensures that your function has capacity to process the specified
#' number of events simultaneously, and prevents it from scaling beyond
#' that level. Use [`get_function`][lambda_get_function] to see the current
#' setting for a function.
#' 
#' Use [`get_account_settings`][lambda_get_account_settings] to see your
#' Regional concurrency limit. You can reserve concurrency for as many
#' functions as you like, as long as you leave at least 100 simultaneous
#' executions unreserved for functions that aren't configured with a
#' per-function limit. For more information, see [Lambda function
#' scaling](https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html).
#'
#' @usage
#' lambda_put_function_concurrency(FunctionName,
#'   ReservedConcurrentExecutions)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param ReservedConcurrentExecutions &#91;required&#93; The number of simultaneous executions to reserve for the function.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ReservedConcurrentExecutions = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_function_concurrency(
#'   FunctionName = "string",
#'   ReservedConcurrentExecutions = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example configures 100 reserved concurrent executions for
#' # the my-function function.
#' svc$put_function_concurrency(
#'   FunctionName = "my-function",
#'   ReservedConcurrentExecutions = 100L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_put_function_concurrency
#'
#' @aliases lambda_put_function_concurrency
lambda_put_function_concurrency <- function(FunctionName, ReservedConcurrentExecutions) {
  op <- new_operation(
    name = "PutFunctionConcurrency",
    http_method = "PUT",
    http_path = "/2017-10-31/functions/{FunctionName}/concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_function_concurrency_input(FunctionName = FunctionName, ReservedConcurrentExecutions = ReservedConcurrentExecutions)
  output <- .lambda$put_function_concurrency_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_function_concurrency <- lambda_put_function_concurrency

#' Configures options for asynchronous invocation on a function, version,
#' or alias
#'
#' @description
#' Configures options for [asynchronous
#' invocation](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html)
#' on a function, version, or alias. If a configuration already exists for
#' a function, version, or alias, this operation overwrites it. If you
#' exclude any settings, they are removed. To set one option without
#' affecting existing settings for other options, use
#' [`update_function_event_invoke_config`][lambda_update_function_event_invoke_config].
#' 
#' By default, Lambda retries an asynchronous invocation twice if the
#' function returns an error. It retains events in a queue for up to six
#' hours. When an event fails all processing attempts or stays in the
#' asynchronous invocation queue for too long, Lambda discards it. To
#' retain discarded events, configure a dead-letter queue with
#' [`update_function_configuration`][lambda_update_function_configuration].
#' 
#' To send an invocation record to a queue, topic, S3 bucket, function, or
#' event bus, specify a
#' [destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-async-destinations).
#' You can configure separate destinations for successful invocations
#' (on-success) and events that fail all processing attempts (on-failure).
#' You can configure destinations in addition to or instead of a
#' dead-letter queue.
#' 
#' S3 buckets are supported only for on-failure destinations. To retain
#' records of successful invocations, use another destination type.
#'
#' @usage
#' lambda_put_function_event_invoke_config(FunctionName, Qualifier,
#'   MaximumRetryAttempts, MaximumEventAgeInSeconds, DestinationConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** - `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier A version number or alias name.
#' @param MaximumRetryAttempts The maximum number of times to retry when the function returns an error.
#' @param MaximumEventAgeInSeconds The maximum age of a request that Lambda sends to a function for
#' processing.
#' @param DestinationConfig A destination for events after they have been sent to a function for
#' processing.
#' 
#' **Destinations**
#' 
#' -   **Function** - The Amazon Resource Name (ARN) of a Lambda function.
#' 
#' -   **Queue** - The ARN of a standard SQS queue.
#' 
#' -   **Bucket** - The ARN of an Amazon S3 bucket.
#' 
#' -   **Topic** - The ARN of a standard SNS topic.
#' 
#' -   **Event Bus** - The ARN of an Amazon EventBridge event bus.
#' 
#' S3 buckets are supported only for on-failure destinations. To retain
#' records of successful invocations, use another destination type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FunctionArn = "string",
#'   MaximumRetryAttempts = 123,
#'   MaximumEventAgeInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_function_event_invoke_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   MaximumRetryAttempts = 123,
#'   MaximumEventAgeInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example sets a maximum event age of one hour and disables
#' # retries for the specified function.
#' svc$put_function_event_invoke_config(
#'   FunctionName = "my-function",
#'   MaximumEventAgeInSeconds = 3600L,
#'   MaximumRetryAttempts = 0L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_put_function_event_invoke_config
#'
#' @aliases lambda_put_function_event_invoke_config
lambda_put_function_event_invoke_config <- function(FunctionName, Qualifier = NULL, MaximumRetryAttempts = NULL, MaximumEventAgeInSeconds = NULL, DestinationConfig = NULL) {
  op <- new_operation(
    name = "PutFunctionEventInvokeConfig",
    http_method = "PUT",
    http_path = "/2019-09-25/functions/{FunctionName}/event-invoke-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_function_event_invoke_config_input(FunctionName = FunctionName, Qualifier = Qualifier, MaximumRetryAttempts = MaximumRetryAttempts, MaximumEventAgeInSeconds = MaximumEventAgeInSeconds, DestinationConfig = DestinationConfig)
  output <- .lambda$put_function_event_invoke_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_function_event_invoke_config <- lambda_put_function_event_invoke_config

#' Sets your function's recursive loop detection configuration
#'
#' @description
#' Sets your function's [recursive loop
#' detection](https://docs.aws.amazon.com/lambda/latest/dg/invocation-recursion.html)
#' configuration.
#' 
#' When you configure a Lambda function to output to the same service or
#' resource that invokes the function, it's possible to create an infinite
#' recursive loop. For example, a Lambda function might write a message to
#' an Amazon Simple Queue Service (Amazon SQS) queue, which then invokes
#' the same function. This invocation causes the function to write another
#' message to the queue, which in turn invokes the function again.
#' 
#' Lambda can detect certain types of recursive loops shortly after they
#' occur. When Lambda detects a recursive loop and your function's
#' recursive loop detection configuration is set to `Terminate`, it stops
#' your function being invoked and notifies you.
#'
#' @usage
#' lambda_put_function_recursion_config(FunctionName, RecursiveLoop)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param RecursiveLoop &#91;required&#93; If you set your function's recursive loop detection configuration to
#' `Allow`, Lambda doesn't take any action when it detects your function
#' being invoked as part of a recursive loop. We recommend that you only
#' use this setting if your design intentionally uses a Lambda function to
#' write data back to the same Amazon Web Services resource that invokes
#' it.
#' 
#' If you set your function's recursive loop detection configuration to
#' `Terminate`, Lambda stops your function being invoked and notifies you
#' when it detects your function being invoked as part of a recursive loop.
#' 
#' By default, Lambda sets your function's configuration to `Terminate`.
#' 
#' If your design intentionally uses a Lambda function to write data back
#' to the same Amazon Web Services resource that invokes the function, then
#' use caution and implement suitable guard rails to prevent unexpected
#' charges being billed to your Amazon Web Services account. To learn more
#' about best practices for using recursive invocation patterns, see
#' [Recursive patterns that cause run-away Lambda
#' functions](https://serverlessland.com/content/service/lambda/guides/aws-lambda-operator-guide/recursive-runaway)
#' in Serverless Land.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RecursiveLoop = "Allow"|"Terminate"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_function_recursion_config(
#'   FunctionName = "string",
#'   RecursiveLoop = "Allow"|"Terminate"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_put_function_recursion_config
#'
#' @aliases lambda_put_function_recursion_config
lambda_put_function_recursion_config <- function(FunctionName, RecursiveLoop) {
  op <- new_operation(
    name = "PutFunctionRecursionConfig",
    http_method = "PUT",
    http_path = "/2024-08-31/functions/{FunctionName}/recursion-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_function_recursion_config_input(FunctionName = FunctionName, RecursiveLoop = RecursiveLoop)
  output <- .lambda$put_function_recursion_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_function_recursion_config <- lambda_put_function_recursion_config

#' Sets the scaling configuration for a Lambda Managed Instances function
#'
#' @description
#' Sets the scaling configuration for a Lambda Managed Instances function.
#' The scaling configuration defines the minimum and maximum number of
#' execution environments that can be provisioned for the function,
#' allowing you to control scaling behavior and resource allocation.
#'
#' @usage
#' lambda_put_function_scaling_config(FunctionName, Qualifier,
#'   FunctionScalingConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' @param Qualifier &#91;required&#93; Specify a version or alias to set the scaling configuration for a
#' published version of the function.
#' @param FunctionScalingConfig The scaling configuration to apply to the function, including minimum
#' and maximum execution environment limits.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionState = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_function_scaling_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   FunctionScalingConfig = list(
#'     MinExecutionEnvironments = 123,
#'     MaxExecutionEnvironments = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_put_function_scaling_config
#'
#' @aliases lambda_put_function_scaling_config
lambda_put_function_scaling_config <- function(FunctionName, Qualifier, FunctionScalingConfig = NULL) {
  op <- new_operation(
    name = "PutFunctionScalingConfig",
    http_method = "PUT",
    http_path = "/2025-11-30/functions/{FunctionName}/function-scaling-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_function_scaling_config_input(FunctionName = FunctionName, Qualifier = Qualifier, FunctionScalingConfig = FunctionScalingConfig)
  output <- .lambda$put_function_scaling_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_function_scaling_config <- lambda_put_function_scaling_config

#' Adds a provisioned concurrency configuration to a function's alias or
#' version
#'
#' @description
#' Adds a provisioned concurrency configuration to a function's alias or
#' version.
#'
#' @usage
#' lambda_put_provisioned_concurrency_config(FunctionName, Qualifier,
#'   ProvisionedConcurrentExecutions)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier &#91;required&#93; The version number or alias name.
#' @param ProvisionedConcurrentExecutions &#91;required&#93; The amount of provisioned concurrency to allocate for the version or
#' alias.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RequestedProvisionedConcurrentExecutions = 123,
#'   AvailableProvisionedConcurrentExecutions = 123,
#'   AllocatedProvisionedConcurrentExecutions = 123,
#'   Status = "IN_PROGRESS"|"READY"|"FAILED",
#'   StatusReason = "string",
#'   LastModified = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_provisioned_concurrency_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   ProvisionedConcurrentExecutions = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example allocates 100 provisioned concurrency for the BLUE
#' # alias of the specified function.
#' svc$put_provisioned_concurrency_config(
#'   FunctionName = "my-function",
#'   ProvisionedConcurrentExecutions = 100L,
#'   Qualifier = "BLUE"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_put_provisioned_concurrency_config
#'
#' @aliases lambda_put_provisioned_concurrency_config
lambda_put_provisioned_concurrency_config <- function(FunctionName, Qualifier, ProvisionedConcurrentExecutions) {
  op <- new_operation(
    name = "PutProvisionedConcurrencyConfig",
    http_method = "PUT",
    http_path = "/2019-09-30/functions/{FunctionName}/provisioned-concurrency",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_provisioned_concurrency_config_input(FunctionName = FunctionName, Qualifier = Qualifier, ProvisionedConcurrentExecutions = ProvisionedConcurrentExecutions)
  output <- .lambda$put_provisioned_concurrency_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_provisioned_concurrency_config <- lambda_put_provisioned_concurrency_config

#' Sets the runtime management configuration for a function's version
#'
#' @description
#' Sets the runtime management configuration for a function's version. For
#' more information, see [Runtime
#' updates](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html).
#'
#' @usage
#' lambda_put_runtime_management_config(FunctionName, Qualifier,
#'   UpdateRuntimeOn, RuntimeVersionArn)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier Specify a version of the function. This can be `$LATEST` or a published
#' version number. If no value is specified, the configuration for the
#' `$LATEST` version is returned.
#' @param UpdateRuntimeOn &#91;required&#93; Specify the runtime update mode.
#' 
#' -   **Auto (default)** - Automatically update to the most recent and
#'     secure runtime version using a [Two-phase runtime version
#'     rollout](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-two-phase).
#'     This is the best choice for most customers to ensure they always
#'     benefit from runtime updates.
#' 
#' -   **Function update** - Lambda updates the runtime of your function to
#'     the most recent and secure runtime version when you update your
#'     function. This approach synchronizes runtime updates with function
#'     deployments, giving you control over when runtime updates are
#'     applied and allowing you to detect and mitigate rare runtime update
#'     incompatibilities early. When using this setting, you need to
#'     regularly update your functions to keep their runtime up-to-date.
#' 
#' -   **Manual** - You specify a runtime version in your function
#'     configuration. The function will use this runtime version
#'     indefinitely. In the rare case where a new runtime version is
#'     incompatible with an existing function, this allows you to roll back
#'     your function to an earlier runtime version. For more information,
#'     see [Roll back a runtime
#'     version](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html#runtime-management-rollback).
#' @param RuntimeVersionArn The ARN of the runtime version you want the function to use.
#' 
#' This is only required if you're using the **Manual** runtime update
#' mode.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateRuntimeOn = "Auto"|"Manual"|"FunctionUpdate",
#'   FunctionArn = "string",
#'   RuntimeVersionArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_runtime_management_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   UpdateRuntimeOn = "Auto"|"Manual"|"FunctionUpdate",
#'   RuntimeVersionArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_put_runtime_management_config
#'
#' @aliases lambda_put_runtime_management_config
lambda_put_runtime_management_config <- function(FunctionName, Qualifier = NULL, UpdateRuntimeOn, RuntimeVersionArn = NULL) {
  op <- new_operation(
    name = "PutRuntimeManagementConfig",
    http_method = "PUT",
    http_path = "/2021-07-20/functions/{FunctionName}/runtime-management-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$put_runtime_management_config_input(FunctionName = FunctionName, Qualifier = Qualifier, UpdateRuntimeOn = UpdateRuntimeOn, RuntimeVersionArn = RuntimeVersionArn)
  output <- .lambda$put_runtime_management_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$put_runtime_management_config <- lambda_put_runtime_management_config

#' Removes a statement from the permissions policy for a version of an
#' Lambda layer
#'
#' @description
#' Removes a statement from the permissions policy for a version of an
#' [Lambda
#' layer](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html).
#' For more information, see
#' [`add_layer_version_permission`][lambda_add_layer_version_permission].
#'
#' @usage
#' lambda_remove_layer_version_permission(LayerName, VersionNumber,
#'   StatementId, RevisionId)
#'
#' @param LayerName &#91;required&#93; The name or Amazon Resource Name (ARN) of the layer.
#' @param VersionNumber &#91;required&#93; The version number.
#' @param StatementId &#91;required&#93; The identifier that was specified when the statement was added.
#' @param RevisionId Only update the policy if the revision ID matches the ID specified. Use
#' this option to avoid modifying a policy that has changed since you last
#' read it.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$remove_layer_version_permission(
#'   LayerName = "string",
#'   VersionNumber = 123,
#'   StatementId = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example deletes permission for an account to configure a
#' # layer version.
#' svc$remove_layer_version_permission(
#'   LayerName = "my-layer",
#'   StatementId = "xaccount",
#'   VersionNumber = 1L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_remove_layer_version_permission
#'
#' @aliases lambda_remove_layer_version_permission
lambda_remove_layer_version_permission <- function(LayerName, VersionNumber, StatementId, RevisionId = NULL) {
  op <- new_operation(
    name = "RemoveLayerVersionPermission",
    http_method = "DELETE",
    http_path = "/2018-10-31/layers/{LayerName}/versions/{VersionNumber}/policy/{StatementId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$remove_layer_version_permission_input(LayerName = LayerName, VersionNumber = VersionNumber, StatementId = StatementId, RevisionId = RevisionId)
  output <- .lambda$remove_layer_version_permission_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$remove_layer_version_permission <- lambda_remove_layer_version_permission

#' Revokes function-use permission from an Amazon Web Services service or
#' another Amazon Web Services account
#'
#' @description
#' Revokes function-use permission from an Amazon Web Services service or
#' another Amazon Web Services account. You can get the ID of the statement
#' from the output of [`get_policy`][lambda_get_policy].
#'
#' @usage
#' lambda_remove_permission(FunctionName, StatementId, Qualifier,
#'   RevisionId)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param StatementId &#91;required&#93; Statement ID of the permission to remove.
#' @param Qualifier Specify a version or alias to remove permissions from a published
#' version of the function.
#' @param RevisionId Update the policy only if the revision ID matches the ID that's
#' specified. Use this option to avoid modifying a policy that has changed
#' since you last read it.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$remove_permission(
#'   FunctionName = "string",
#'   StatementId = "string",
#'   Qualifier = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example removes a permissions statement named xaccount
#' # from the PROD alias of a function named my-function.
#' svc$remove_permission(
#'   FunctionName = "my-function",
#'   Qualifier = "PROD",
#'   StatementId = "xaccount"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_remove_permission
#'
#' @aliases lambda_remove_permission
lambda_remove_permission <- function(FunctionName, StatementId, Qualifier = NULL, RevisionId = NULL) {
  op <- new_operation(
    name = "RemovePermission",
    http_method = "DELETE",
    http_path = "/2015-03-31/functions/{FunctionName}/policy/{StatementId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$remove_permission_input(FunctionName = FunctionName, StatementId = StatementId, Qualifier = Qualifier, RevisionId = RevisionId)
  output <- .lambda$remove_permission_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$remove_permission <- lambda_remove_permission

#' Sends a failure response for a callback operation in a durable execution
#'
#' @description
#' Sends a failure response for a callback operation in a durable
#' execution. Use this API when an external system cannot complete a
#' callback operation successfully.
#'
#' @usage
#' lambda_send_durable_execution_callback_failure(CallbackId, Error)
#'
#' @param CallbackId &#91;required&#93; The unique identifier for the callback operation.
#' @param Error Error details describing why the callback operation failed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$send_durable_execution_callback_failure(
#'   CallbackId = "string",
#'   Error = list(
#'     ErrorMessage = "string",
#'     ErrorType = "string",
#'     ErrorData = "string",
#'     StackTrace = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_send_durable_execution_callback_failure
#'
#' @aliases lambda_send_durable_execution_callback_failure
lambda_send_durable_execution_callback_failure <- function(CallbackId, Error = NULL) {
  op <- new_operation(
    name = "SendDurableExecutionCallbackFailure",
    http_method = "POST",
    http_path = "/2025-12-01/durable-execution-callbacks/{CallbackId}/fail",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$send_durable_execution_callback_failure_input(CallbackId = CallbackId, Error = Error)
  output <- .lambda$send_durable_execution_callback_failure_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$send_durable_execution_callback_failure <- lambda_send_durable_execution_callback_failure

#' Sends a heartbeat signal for a long-running callback operation to
#' prevent timeout
#'
#' @description
#' Sends a heartbeat signal for a long-running callback operation to
#' prevent timeout. Use this API to extend the callback timeout period
#' while the external operation is still in progress.
#'
#' @usage
#' lambda_send_durable_execution_callback_heartbeat(CallbackId)
#'
#' @param CallbackId &#91;required&#93; The unique identifier for the callback operation.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$send_durable_execution_callback_heartbeat(
#'   CallbackId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_send_durable_execution_callback_heartbeat
#'
#' @aliases lambda_send_durable_execution_callback_heartbeat
lambda_send_durable_execution_callback_heartbeat <- function(CallbackId) {
  op <- new_operation(
    name = "SendDurableExecutionCallbackHeartbeat",
    http_method = "POST",
    http_path = "/2025-12-01/durable-execution-callbacks/{CallbackId}/heartbeat",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$send_durable_execution_callback_heartbeat_input(CallbackId = CallbackId)
  output <- .lambda$send_durable_execution_callback_heartbeat_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$send_durable_execution_callback_heartbeat <- lambda_send_durable_execution_callback_heartbeat

#' Sends a successful completion response for a callback operation in a
#' durable execution
#'
#' @description
#' Sends a successful completion response for a callback operation in a
#' durable execution. Use this API when an external system has successfully
#' completed a callback operation.
#'
#' @usage
#' lambda_send_durable_execution_callback_success(CallbackId, Result)
#'
#' @param CallbackId &#91;required&#93; The unique identifier for the callback operation.
#' @param Result The result data from the successful callback operation. Maximum size is
#' 256 KB.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$send_durable_execution_callback_success(
#'   CallbackId = "string",
#'   Result = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_send_durable_execution_callback_success
#'
#' @aliases lambda_send_durable_execution_callback_success
lambda_send_durable_execution_callback_success <- function(CallbackId, Result = NULL) {
  op <- new_operation(
    name = "SendDurableExecutionCallbackSuccess",
    http_method = "POST",
    http_path = "/2025-12-01/durable-execution-callbacks/{CallbackId}/succeed",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$send_durable_execution_callback_success_input(CallbackId = CallbackId, Result = Result)
  output <- .lambda$send_durable_execution_callback_success_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$send_durable_execution_callback_success <- lambda_send_durable_execution_callback_success

#' Stops a running durable execution
#'
#' @description
#' Stops a running [durable
#' execution](https://docs.aws.amazon.com/lambda/latest/dg/durable-functions.html).
#' The execution transitions to STOPPED status and cannot be resumed. Any
#' in-progress operations are terminated.
#'
#' @usage
#' lambda_stop_durable_execution(DurableExecutionArn, Error)
#'
#' @param DurableExecutionArn &#91;required&#93; The Amazon Resource Name (ARN) of the durable execution.
#' @param Error Optional error details explaining why the execution is being stopped.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   StopTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_durable_execution(
#'   DurableExecutionArn = "string",
#'   Error = list(
#'     ErrorMessage = "string",
#'     ErrorType = "string",
#'     ErrorData = "string",
#'     StackTrace = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_stop_durable_execution
#'
#' @aliases lambda_stop_durable_execution
lambda_stop_durable_execution <- function(DurableExecutionArn, Error = NULL) {
  op <- new_operation(
    name = "StopDurableExecution",
    http_method = "POST",
    http_path = "/2025-12-01/durable-executions/{DurableExecutionArn}/stop",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$stop_durable_execution_input(DurableExecutionArn = DurableExecutionArn, Error = Error)
  output <- .lambda$stop_durable_execution_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$stop_durable_execution <- lambda_stop_durable_execution

#' Adds tags to a function, event source mapping, or code signing
#' configuration
#'
#' @description
#' Adds
#' [tags](https://docs.aws.amazon.com/lambda/latest/dg/configuration-tags.html)
#' to a function, event source mapping, or code signing configuration.
#'
#' @usage
#' lambda_tag_resource(Resource, Tags)
#'
#' @param Resource &#91;required&#93; The resource's Amazon Resource Name (ARN).
#' @param Tags &#91;required&#93; A list of tags to apply to the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   Resource = "string",
#'   Tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example adds a tag with the key name DEPARTMENT and a
#' # value of 'Department A' to the specified Lambda function.
#' svc$tag_resource(
#'   Resource = "arn:aws:lambda:us-west-2:123456789012:function:my-function",
#'   Tags = list(
#'     DEPARTMENT = "Department A"
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_tag_resource
#'
#' @aliases lambda_tag_resource
lambda_tag_resource <- function(Resource, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/2017-03-31/tags/{Resource}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$tag_resource_input(Resource = Resource, Tags = Tags)
  output <- .lambda$tag_resource_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$tag_resource <- lambda_tag_resource

#' Removes tags from a function, event source mapping, or code signing
#' configuration
#'
#' @description
#' Removes
#' [tags](https://docs.aws.amazon.com/lambda/latest/dg/configuration-tags.html)
#' from a function, event source mapping, or code signing configuration.
#'
#' @usage
#' lambda_untag_resource(Resource, TagKeys)
#'
#' @param Resource &#91;required&#93; The resource's Amazon Resource Name (ARN).
#' @param TagKeys &#91;required&#93; A list of tag keys to remove from the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   Resource = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example removes the tag with the key name DEPARTMENT tag
#' # from the my-function Lambda function.
#' svc$untag_resource(
#'   Resource = "arn:aws:lambda:us-west-2:123456789012:function:my-function",
#'   TagKeys = list(
#'     "DEPARTMENT"
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_untag_resource
#'
#' @aliases lambda_untag_resource
lambda_untag_resource <- function(Resource, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/2017-03-31/tags/{Resource}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$untag_resource_input(Resource = Resource, TagKeys = TagKeys)
  output <- .lambda$untag_resource_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$untag_resource <- lambda_untag_resource

#' Updates the configuration of a Lambda function alias
#'
#' @description
#' Updates the configuration of a Lambda function
#' [alias](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html).
#'
#' @usage
#' lambda_update_alias(FunctionName, Name, FunctionVersion, Description,
#'   RoutingConfig, RevisionId)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `MyFunction`.
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Partial ARN** - `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Name &#91;required&#93; The name of the alias.
#' @param FunctionVersion The function version that the alias invokes.
#' @param Description A description of the alias.
#' @param RoutingConfig The [routing
#' configuration](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing)
#' of the alias.
#' @param RevisionId Only update the alias if the revision ID matches the ID that's
#' specified. Use this option to avoid modifying an alias that has changed
#' since you last read it.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AliasArn = "string",
#'   Name = "string",
#'   FunctionVersion = "string",
#'   Description = "string",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       123.0
#'     )
#'   ),
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_alias(
#'   FunctionName = "string",
#'   Name = "string",
#'   FunctionVersion = "string",
#'   Description = "string",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       123.0
#'     )
#'   ),
#'   RevisionId = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example updates the alias named BLUE to send 30% of
#' # traffic to version 2 and 70% to version 1.
#' svc$update_alias(
#'   FunctionName = "my-function",
#'   FunctionVersion = "2",
#'   Name = "BLUE",
#'   RoutingConfig = list(
#'     AdditionalVersionWeights = list(
#'       `1` = 0.7
#'     )
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_update_alias
#'
#' @aliases lambda_update_alias
lambda_update_alias <- function(FunctionName, Name, FunctionVersion = NULL, Description = NULL, RoutingConfig = NULL, RevisionId = NULL) {
  op <- new_operation(
    name = "UpdateAlias",
    http_method = "PUT",
    http_path = "/2015-03-31/functions/{FunctionName}/aliases/{Name}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_alias_input(FunctionName = FunctionName, Name = Name, FunctionVersion = FunctionVersion, Description = Description, RoutingConfig = RoutingConfig, RevisionId = RevisionId)
  output <- .lambda$update_alias_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_alias <- lambda_update_alias

#' Updates the configuration of an existing capacity provider
#'
#' @description
#' Updates the configuration of an existing capacity provider.
#'
#' @usage
#' lambda_update_capacity_provider(CapacityProviderName,
#'   CapacityProviderScalingConfig)
#'
#' @param CapacityProviderName &#91;required&#93; The name of the capacity provider to update.
#' @param CapacityProviderScalingConfig The updated scaling configuration for the capacity provider.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CapacityProvider = list(
#'     CapacityProviderArn = "string",
#'     State = "Pending"|"Active"|"Failed"|"Deleting",
#'     VpcConfig = list(
#'       SubnetIds = list(
#'         "string"
#'       ),
#'       SecurityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     PermissionsConfig = list(
#'       CapacityProviderOperatorRoleArn = "string"
#'     ),
#'     InstanceRequirements = list(
#'       Architectures = list(
#'         "x86_64"|"arm64"
#'       ),
#'       AllowedInstanceTypes = list(
#'         "string"
#'       ),
#'       ExcludedInstanceTypes = list(
#'         "string"
#'       )
#'     ),
#'     CapacityProviderScalingConfig = list(
#'       MaxVCpuCount = 123,
#'       ScalingMode = "Auto"|"Manual",
#'       ScalingPolicies = list(
#'         list(
#'           PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'           TargetValue = 123.0
#'         )
#'       )
#'     ),
#'     KmsKeyArn = "string",
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_capacity_provider(
#'   CapacityProviderName = "string",
#'   CapacityProviderScalingConfig = list(
#'     MaxVCpuCount = 123,
#'     ScalingMode = "Auto"|"Manual",
#'     ScalingPolicies = list(
#'       list(
#'         PredefinedMetricType = "LambdaCapacityProviderAverageCPUUtilization",
#'         TargetValue = 123.0
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_update_capacity_provider
#'
#' @aliases lambda_update_capacity_provider
lambda_update_capacity_provider <- function(CapacityProviderName, CapacityProviderScalingConfig = NULL) {
  op <- new_operation(
    name = "UpdateCapacityProvider",
    http_method = "PUT",
    http_path = "/2025-11-30/capacity-providers/{CapacityProviderName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_capacity_provider_input(CapacityProviderName = CapacityProviderName, CapacityProviderScalingConfig = CapacityProviderScalingConfig)
  output <- .lambda$update_capacity_provider_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_capacity_provider <- lambda_update_capacity_provider

#' Update the code signing configuration
#'
#' @description
#' Update the code signing configuration. Changes to the code signing
#' configuration take effect the next time a user tries to deploy a code
#' package to the function.
#'
#' @usage
#' lambda_update_code_signing_config(CodeSigningConfigArn, Description,
#'   AllowedPublishers, CodeSigningPolicies)
#'
#' @param CodeSigningConfigArn &#91;required&#93; The The Amazon Resource Name (ARN) of the code signing configuration.
#' @param Description Descriptive name for this code signing configuration.
#' @param AllowedPublishers Signing profiles for this code signing configuration.
#' @param CodeSigningPolicies The code signing policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   CodeSigningConfig = list(
#'     CodeSigningConfigId = "string",
#'     CodeSigningConfigArn = "string",
#'     Description = "string",
#'     AllowedPublishers = list(
#'       SigningProfileVersionArns = list(
#'         "string"
#'       )
#'     ),
#'     CodeSigningPolicies = list(
#'       UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'     ),
#'     LastModified = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_code_signing_config(
#'   CodeSigningConfigArn = "string",
#'   Description = "string",
#'   AllowedPublishers = list(
#'     SigningProfileVersionArns = list(
#'       "string"
#'     )
#'   ),
#'   CodeSigningPolicies = list(
#'     UntrustedArtifactOnDeployment = "Warn"|"Enforce"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_update_code_signing_config
#'
#' @aliases lambda_update_code_signing_config
lambda_update_code_signing_config <- function(CodeSigningConfigArn, Description = NULL, AllowedPublishers = NULL, CodeSigningPolicies = NULL) {
  op <- new_operation(
    name = "UpdateCodeSigningConfig",
    http_method = "PUT",
    http_path = "/2020-04-22/code-signing-configs/{CodeSigningConfigArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_code_signing_config_input(CodeSigningConfigArn = CodeSigningConfigArn, Description = Description, AllowedPublishers = AllowedPublishers, CodeSigningPolicies = CodeSigningPolicies)
  output <- .lambda$update_code_signing_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_code_signing_config <- lambda_update_code_signing_config

#' Updates an event source mapping
#'
#' @description
#' Updates an event source mapping. You can change the function that Lambda
#' invokes, or pause invocation and resume later from the same location.
#' 
#' For details about how to configure different event sources, see the
#' following topics.
#' 
#' -   [Amazon DynamoDB
#'     Streams](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-dynamodb-eventsourcemapping)
#' 
#' -   [Amazon
#'     Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-eventsourcemapping)
#' 
#' -   [Amazon
#'     SQS](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-eventsource)
#' 
#' -   [Amazon MQ and
#'     RabbitMQ](https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html#services-mq-eventsourcemapping)
#' 
#' -   [Amazon
#'     MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html)
#' 
#' -   [Apache
#'     Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html)
#' 
#' -   [Amazon
#'     DocumentDB](https://docs.aws.amazon.com/lambda/latest/dg/with-documentdb.html)
#' 
#' The following error handling options are available for stream sources
#' (DynamoDB, Kinesis, Amazon MSK, and self-managed Apache Kafka):
#' 
#' -   `BisectBatchOnFunctionError` – If the function returns an error,
#'     split the batch in two and retry.
#' 
#' -   `MaximumRecordAgeInSeconds` – Discard records older than the
#'     specified age. The default value is infinite (-1). When set to
#'     infinite (-1), failed records are retried until the record expires
#' 
#' -   `MaximumRetryAttempts` – Discard records after the specified number
#'     of retries. The default value is infinite (-1). When set to infinite
#'     (-1), failed records are retried until the record expires.
#' 
#' -   `OnFailure` – Send discarded records to an Amazon SQS queue, Amazon
#'     SNS topic, Kafka topic, or Amazon S3 bucket. For more information,
#'     see [Adding a
#'     destination](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async-retain-records.html#invocation-async-destinations).
#' 
#' The following option is available only for DynamoDB and Kinesis event
#' sources:
#' 
#' -   `ParallelizationFactor` – Process multiple batches from each shard
#'     concurrently.
#' 
#' For information about which configuration parameters apply to each event
#' source, see the following topics.
#' 
#' -   [Amazon DynamoDB
#'     Streams](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-params)
#' 
#' -   [Amazon
#'     Kinesis](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-params)
#' 
#' -   [Amazon
#'     SQS](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#services-sqs-params)
#' 
#' -   [Amazon MQ and
#'     RabbitMQ](https://docs.aws.amazon.com/lambda/latest/dg/with-mq.html#services-mq-params)
#' 
#' -   [Amazon
#'     MSK](https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html#services-msk-parms)
#' 
#' -   [Apache
#'     Kafka](https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html#services-kafka-parms)
#' 
#' -   [Amazon
#'     DocumentDB](https://docs.aws.amazon.com/lambda/latest/dg/with-documentdb.html#docdb-configuration)
#'
#' @usage
#' lambda_update_event_source_mapping(UUID, FunctionName, Enabled,
#'   BatchSize, FilterCriteria, MaximumBatchingWindowInSeconds,
#'   DestinationConfig, MaximumRecordAgeInSeconds,
#'   BisectBatchOnFunctionError, MaximumRetryAttempts, ParallelizationFactor,
#'   SourceAccessConfigurations, TumblingWindowInSeconds,
#'   FunctionResponseTypes, ScalingConfig,
#'   AmazonManagedKafkaEventSourceConfig, SelfManagedKafkaEventSourceConfig,
#'   DocumentDBEventSourceConfig, KMSKeyArn, MetricsConfig,
#'   ProvisionedPollerConfig)
#'
#' @param UUID &#91;required&#93; The identifier of the event source mapping.
#' @param FunctionName The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `MyFunction`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction`.
#' 
#' -   **Version or Alias ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD`.
#' 
#' -   **Partial ARN** – `123456789012:function:MyFunction`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it's limited to 64 characters in length.
#' @param Enabled When true, the event source mapping is active. When false, Lambda pauses
#' polling and invocation.
#' 
#' Default: True
#' @param BatchSize The maximum number of records in each batch that Lambda pulls from your
#' stream or queue and sends to your function. Lambda passes all of the
#' records in the batch to the function in a single call, up to the payload
#' limit for synchronous invocation (6 MB).
#' 
#' -   **Amazon Kinesis** – Default 100. Max 10,000.
#' 
#' -   **Amazon DynamoDB Streams** – Default 100. Max 10,000.
#' 
#' -   **Amazon Simple Queue Service** – Default 10. For standard queues
#'     the max is 10,000. For FIFO queues the max is 10.
#' 
#' -   **Amazon Managed Streaming for Apache Kafka** – Default 100. Max
#'     10,000.
#' 
#' -   **Self-managed Apache Kafka** – Default 100. Max 10,000.
#' 
#' -   **Amazon MQ (ActiveMQ and RabbitMQ)** – Default 100. Max 10,000.
#' 
#' -   **DocumentDB** – Default 100. Max 10,000.
#' @param FilterCriteria An object that defines the filter criteria that determine whether Lambda
#' should process an event. For more information, see [Lambda event
#' filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html).
#' @param MaximumBatchingWindowInSeconds The maximum amount of time, in seconds, that Lambda spends gathering
#' records before invoking the function. You can configure
#' `MaximumBatchingWindowInSeconds` to any value from 0 seconds to 300
#' seconds in increments of seconds.
#' 
#' For Kinesis, DynamoDB, and Amazon SQS event sources, the default
#' batching window is 0 seconds. For Amazon MSK, Self-managed Apache Kafka,
#' Amazon MQ, and DocumentDB event sources, the default batching window is
#' 500 ms. Note that because you can only change
#' `MaximumBatchingWindowInSeconds` in increments of seconds, you cannot
#' revert back to the 500 ms default batching window after you have changed
#' it. To restore the default batching window, you must create a new event
#' source mapping.
#' 
#' Related setting: For Kinesis, DynamoDB, and Amazon SQS event sources,
#' when you set `BatchSize` to a value greater than 10, you must set
#' `MaximumBatchingWindowInSeconds` to at least 1.
#' @param DestinationConfig (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka) A
#' configuration object that specifies the destination of an event after
#' Lambda processes it.
#' @param MaximumRecordAgeInSeconds (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' Discard records older than the specified age. The default value is
#' infinite (-1).
#' @param BisectBatchOnFunctionError (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' If the function returns an error, split the batch in two and retry.
#' @param MaximumRetryAttempts (Kinesis, DynamoDB Streams, Amazon MSK, and self-managed Apache Kafka)
#' Discard records after the specified number of retries. The default value
#' is infinite (-1). When set to infinite (-1), failed records are retried
#' until the record expires.
#' @param ParallelizationFactor (Kinesis and DynamoDB Streams only) The number of batches to process
#' from each shard concurrently.
#' @param SourceAccessConfigurations An array of authentication protocols or VPC components required to
#' secure your event source.
#' @param TumblingWindowInSeconds (Kinesis and DynamoDB Streams only) The duration in seconds of a
#' processing window for DynamoDB and Kinesis Streams event sources. A
#' value of 0 seconds indicates no tumbling window.
#' @param FunctionResponseTypes (Kinesis, DynamoDB Streams, Amazon MSK, self-managed Apache Kafka, and
#' Amazon SQS) A list of current response type enums applied to the event
#' source mapping.
#' @param ScalingConfig (Amazon SQS only) The scaling configuration for the event source. For
#' more information, see [Configuring maximum concurrency for Amazon SQS
#' event
#' sources](https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#events-sqs-max-concurrency).
#' @param AmazonManagedKafkaEventSourceConfig 
#' @param SelfManagedKafkaEventSourceConfig 
#' @param DocumentDBEventSourceConfig Specific configuration settings for a DocumentDB event source.
#' @param KMSKeyArn The ARN of the Key Management Service (KMS) customer managed key that
#' Lambda uses to encrypt your function's [filter
#' criteria](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html#filtering-basics).
#' By default, Lambda does not encrypt your filter criteria object. Specify
#' this property to encrypt data using your own customer managed key.
#' @param MetricsConfig The metrics configuration for your event source. For more information,
#' see [Event source mapping
#' metrics](https://docs.aws.amazon.com/lambda/latest/dg/monitoring-metrics-types.html#event-source-mapping-metrics).
#' @param ProvisionedPollerConfig (Amazon SQS, Amazon MSK, and self-managed Apache Kafka only) The
#' provisioned mode configuration for the event source. For more
#' information, see [provisioned
#' mode](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventsourcemapping.html#invocation-eventsourcemapping-provisioned-mode).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UUID = "string",
#'   StartingPosition = "TRIM_HORIZON"|"LATEST"|"AT_TIMESTAMP",
#'   StartingPositionTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BatchSize = 123,
#'   MaximumBatchingWindowInSeconds = 123,
#'   ParallelizationFactor = 123,
#'   EventSourceArn = "string",
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   FunctionArn = "string",
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   LastProcessingResult = "string",
#'   State = "string",
#'   StateTransitionReason = "string",
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   Topics = list(
#'     "string"
#'   ),
#'   Queues = list(
#'     "string"
#'   ),
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   SelfManagedEventSource = list(
#'     Endpoints = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   TumblingWindowInSeconds = 123,
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   FilterCriteriaError = list(
#'     ErrorCode = "string",
#'     Message = "string"
#'   ),
#'   EventSourceMappingArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_event_source_mapping(
#'   UUID = "string",
#'   FunctionName = "string",
#'   Enabled = TRUE|FALSE,
#'   BatchSize = 123,
#'   FilterCriteria = list(
#'     Filters = list(
#'       list(
#'         Pattern = "string"
#'       )
#'     )
#'   ),
#'   MaximumBatchingWindowInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   ),
#'   MaximumRecordAgeInSeconds = 123,
#'   BisectBatchOnFunctionError = TRUE|FALSE,
#'   MaximumRetryAttempts = 123,
#'   ParallelizationFactor = 123,
#'   SourceAccessConfigurations = list(
#'     list(
#'       Type = "BASIC_AUTH"|"VPC_SUBNET"|"VPC_SECURITY_GROUP"|"SASL_SCRAM_512_AUTH"|"SASL_SCRAM_256_AUTH"|"VIRTUAL_HOST"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'       URI = "string"
#'     )
#'   ),
#'   TumblingWindowInSeconds = 123,
#'   FunctionResponseTypes = list(
#'     "ReportBatchItemFailures"
#'   ),
#'   ScalingConfig = list(
#'     MaximumConcurrency = 123
#'   ),
#'   AmazonManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   SelfManagedKafkaEventSourceConfig = list(
#'     ConsumerGroupId = "string",
#'     SchemaRegistryConfig = list(
#'       SchemaRegistryURI = "string",
#'       EventRecordFormat = "JSON"|"SOURCE",
#'       AccessConfigs = list(
#'         list(
#'           Type = "BASIC_AUTH"|"CLIENT_CERTIFICATE_TLS_AUTH"|"SERVER_ROOT_CA_CERTIFICATE",
#'           URI = "string"
#'         )
#'       ),
#'       SchemaValidationConfigs = list(
#'         list(
#'           Attribute = "KEY"|"VALUE"
#'         )
#'       )
#'     )
#'   ),
#'   DocumentDBEventSourceConfig = list(
#'     DatabaseName = "string",
#'     CollectionName = "string",
#'     FullDocument = "UpdateLookup"|"Default"
#'   ),
#'   KMSKeyArn = "string",
#'   MetricsConfig = list(
#'     Metrics = list(
#'       "EventCount"
#'     )
#'   ),
#'   ProvisionedPollerConfig = list(
#'     MinimumPollers = 123,
#'     MaximumPollers = 123,
#'     PollerGroupName = "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This operation updates a Lambda function event source mapping
#' svc$update_event_source_mapping(
#'   BatchSize = 123L,
#'   Enabled = TRUE,
#'   FunctionName = "myFunction",
#'   UUID = "1234xCy789012"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_update_event_source_mapping
#'
#' @aliases lambda_update_event_source_mapping
lambda_update_event_source_mapping <- function(UUID, FunctionName = NULL, Enabled = NULL, BatchSize = NULL, FilterCriteria = NULL, MaximumBatchingWindowInSeconds = NULL, DestinationConfig = NULL, MaximumRecordAgeInSeconds = NULL, BisectBatchOnFunctionError = NULL, MaximumRetryAttempts = NULL, ParallelizationFactor = NULL, SourceAccessConfigurations = NULL, TumblingWindowInSeconds = NULL, FunctionResponseTypes = NULL, ScalingConfig = NULL, AmazonManagedKafkaEventSourceConfig = NULL, SelfManagedKafkaEventSourceConfig = NULL, DocumentDBEventSourceConfig = NULL, KMSKeyArn = NULL, MetricsConfig = NULL, ProvisionedPollerConfig = NULL) {
  op <- new_operation(
    name = "UpdateEventSourceMapping",
    http_method = "PUT",
    http_path = "/2015-03-31/event-source-mappings/{UUID}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_event_source_mapping_input(UUID = UUID, FunctionName = FunctionName, Enabled = Enabled, BatchSize = BatchSize, FilterCriteria = FilterCriteria, MaximumBatchingWindowInSeconds = MaximumBatchingWindowInSeconds, DestinationConfig = DestinationConfig, MaximumRecordAgeInSeconds = MaximumRecordAgeInSeconds, BisectBatchOnFunctionError = BisectBatchOnFunctionError, MaximumRetryAttempts = MaximumRetryAttempts, ParallelizationFactor = ParallelizationFactor, SourceAccessConfigurations = SourceAccessConfigurations, TumblingWindowInSeconds = TumblingWindowInSeconds, FunctionResponseTypes = FunctionResponseTypes, ScalingConfig = ScalingConfig, AmazonManagedKafkaEventSourceConfig = AmazonManagedKafkaEventSourceConfig, SelfManagedKafkaEventSourceConfig = SelfManagedKafkaEventSourceConfig, DocumentDBEventSourceConfig = DocumentDBEventSourceConfig, KMSKeyArn = KMSKeyArn, MetricsConfig = MetricsConfig, ProvisionedPollerConfig = ProvisionedPollerConfig)
  output <- .lambda$update_event_source_mapping_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_event_source_mapping <- lambda_update_event_source_mapping

#' Updates a Lambda function's code
#'
#' @description
#' Updates a Lambda function's code. If code signing is enabled for the
#' function, the code package must be signed by a trusted publisher. For
#' more information, see [Configuring code signing for
#' Lambda](https://docs.aws.amazon.com/lambda/latest/dg/configuration-codesigning.html).
#' 
#' If the function's package type is `Image`, then you must specify the
#' code package in `ImageUri` as the URI of a [container
#' image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html)
#' in the Amazon ECR registry.
#' 
#' If the function's package type is `Zip`, then you must specify the
#' deployment package as a [.zip file
#' archive](https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-zip.html#gettingstarted-package-zip).
#' Enter the Amazon S3 bucket and key of the code .zip file location. You
#' can also provide the function code inline using the `ZipFile` field.
#' 
#' The code in the deployment package must be compatible with the target
#' instruction set architecture of the function (`x86-64` or `arm64`).
#' 
#' The function's code is locked when you publish a version. You can't
#' modify the code of a published version, only the unpublished version.
#' 
#' For a function defined as a container image, Lambda resolves the image
#' tag to an image digest. In Amazon ECR, if you update the image tag to a
#' new image, Lambda does not automatically update the function.
#'
#' @usage
#' lambda_update_function_code(FunctionName, ZipFile, S3Bucket, S3Key,
#'   S3ObjectVersion, ImageUri, Publish, DryRun, RevisionId, Architectures,
#'   SourceKMSKeyArn, PublishTo)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param ZipFile The base64-encoded contents of the deployment package. Amazon Web
#' Services SDK and CLI clients handle the encoding for you. Use only with
#' a function defined with a .zip file archive deployment package.
#' @param S3Bucket An Amazon S3 bucket in the same Amazon Web Services Region as your
#' function. The bucket can be in a different Amazon Web Services account.
#' Use only with a function defined with a .zip file archive deployment
#' package.
#' @param S3Key The Amazon S3 key of the deployment package. Use only with a function
#' defined with a .zip file archive deployment package.
#' @param S3ObjectVersion For versioned objects, the version of the deployment package object to
#' use.
#' @param ImageUri URI of a container image in the Amazon ECR registry. Do not use for a
#' function defined with a .zip file archive.
#' @param Publish Set to true to publish a new version of the function after updating the
#' code. This has the same effect as calling
#' [`publish_version`][lambda_publish_version] separately.
#' @param DryRun Set to true to validate the request parameters and access permissions
#' without modifying the function code.
#' @param RevisionId Update the function only if the revision ID matches the ID that's
#' specified. Use this option to avoid modifying a function that has
#' changed since you last read it.
#' @param Architectures The instruction set architecture that the function supports. Enter a
#' string array with one of the valid values (arm64 or x86_64). The default
#' value is `x86_64`.
#' @param SourceKMSKeyArn The ARN of the Key Management Service (KMS) customer managed key that's
#' used to encrypt your function's .zip deployment package. If you don't
#' provide a customer managed key, Lambda uses an Amazon Web Services
#' managed key.
#' @param PublishTo Specifies where to publish the function version or configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionName = "string",
#'   FunctionArn = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   CodeSize = 123,
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   LastModified = "string",
#'   CodeSha256 = "string",
#'   Version = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     VpcId = "string",
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   MasterArn = "string",
#'   RevisionId = "string",
#'   Layers = list(
#'     list(
#'       Arn = "string",
#'       CodeSize = 123,
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string"
#'     )
#'   ),
#'   State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'   StateReason = "string",
#'   StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'   LastUpdateStatusReason = "string",
#'   LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   PackageType = "Zip"|"Image",
#'   ImageConfigResponse = list(
#'     ImageConfig = list(
#'       EntryPoint = list(
#'         "string"
#'       ),
#'       Command = list(
#'         "string"
#'       ),
#'       WorkingDirectory = "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   SigningProfileVersionArn = "string",
#'   SigningJobArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None",
#'     OptimizationStatus = "On"|"Off"
#'   ),
#'   RuntimeVersionConfig = list(
#'     RuntimeVersionArn = "string",
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   ConfigSha256 = "string",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_function_code(
#'   FunctionName = "string",
#'   ZipFile = raw,
#'   S3Bucket = "string",
#'   S3Key = "string",
#'   S3ObjectVersion = "string",
#'   ImageUri = "string",
#'   Publish = TRUE|FALSE,
#'   DryRun = TRUE|FALSE,
#'   RevisionId = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   SourceKMSKeyArn = "string",
#'   PublishTo = "LATEST_PUBLISHED"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example replaces the code of the unpublished ($LATEST)
#' # version of a function named my-function with the contents of the
#' # specified zip file in Amazon S3.
#' svc$update_function_code(
#'   FunctionName = "my-function",
#'   S3Bucket = "my-bucket-1xpuxmplzrlbh",
#'   S3Key = "function.zip"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_update_function_code
#'
#' @aliases lambda_update_function_code
lambda_update_function_code <- function(FunctionName, ZipFile = NULL, S3Bucket = NULL, S3Key = NULL, S3ObjectVersion = NULL, ImageUri = NULL, Publish = NULL, DryRun = NULL, RevisionId = NULL, Architectures = NULL, SourceKMSKeyArn = NULL, PublishTo = NULL) {
  op <- new_operation(
    name = "UpdateFunctionCode",
    http_method = "PUT",
    http_path = "/2015-03-31/functions/{FunctionName}/code",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_function_code_input(FunctionName = FunctionName, ZipFile = ZipFile, S3Bucket = S3Bucket, S3Key = S3Key, S3ObjectVersion = S3ObjectVersion, ImageUri = ImageUri, Publish = Publish, DryRun = DryRun, RevisionId = RevisionId, Architectures = Architectures, SourceKMSKeyArn = SourceKMSKeyArn, PublishTo = PublishTo)
  output <- .lambda$update_function_code_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_function_code <- lambda_update_function_code

#' Modify the version-specific settings of a Lambda function
#'
#' @description
#' Modify the version-specific settings of a Lambda function.
#' 
#' When you update a function, Lambda provisions an instance of the
#' function and its supporting resources. If your function connects to a
#' VPC, this process can take a minute. During this time, you can't modify
#' the function, but you can still invoke it. The `LastUpdateStatus`,
#' `LastUpdateStatusReason`, and `LastUpdateStatusReasonCode` fields in the
#' response from
#' [`get_function_configuration`][lambda_get_function_configuration]
#' indicate when the update is complete and the function is processing
#' events with the new configuration. For more information, see [Lambda
#' function
#' states](https://docs.aws.amazon.com/lambda/latest/dg/functions-states.html).
#' 
#' These settings can vary between versions of a function and are locked
#' when you publish a version. You can't modify the configuration of a
#' published version, only the unpublished version.
#' 
#' To configure function concurrency, use
#' [`put_function_concurrency`][lambda_put_function_concurrency]. To grant
#' invoke permissions to an Amazon Web Services account or Amazon Web
#' Services service, use [`add_permission`][lambda_add_permission].
#'
#' @usage
#' lambda_update_function_configuration(FunctionName, Role, Handler,
#'   Description, Timeout, MemorySize, VpcConfig, Environment, Runtime,
#'   DeadLetterConfig, KMSKeyArn, TracingConfig, RevisionId, Layers,
#'   FileSystemConfigs, ImageConfig, EphemeralStorage, SnapStart,
#'   LoggingConfig, CapacityProviderConfig, DurableConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Role The Amazon Resource Name (ARN) of the function's execution role.
#' @param Handler The name of the method within your code that Lambda calls to run your
#' function. Handler is required if the deployment package is a .zip file
#' archive. The format includes the file name. It can also include
#' namespaces and other qualifiers, depending on the runtime. For more
#' information, see [Lambda programming
#' model](https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html).
#' @param Description A description of the function.
#' @param Timeout The amount of time (in seconds) that Lambda allows a function to run
#' before stopping it. The default is 3 seconds. The maximum allowed value
#' is 900 seconds. For more information, see [Lambda execution
#' environment](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html).
#' @param MemorySize The amount of [memory available to the
#' function](https://docs.aws.amazon.com/lambda/latest/dg/lambda-functions.html#configuration-memory-console)
#' at runtime. Increasing the function memory also increases its CPU
#' allocation. The default value is 128 MB. The value can be any multiple
#' of 1 MB.
#' @param VpcConfig For network connectivity to Amazon Web Services resources in a VPC,
#' specify a list of security groups and subnets in the VPC. When you
#' connect a function to a VPC, it can access resources and the internet
#' only through that VPC. For more information, see [Configuring a Lambda
#' function to access resources in a
#' VPC](https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html).
#' @param Environment Environment variables that are accessible from function code during
#' execution.
#' @param Runtime The identifier of the function's
#' [runtime](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).
#' Runtime is required if the deployment package is a .zip file archive.
#' Specifying a runtime results in an error if you're deploying a function
#' using a container image.
#' 
#' The following list includes deprecated runtimes. Lambda blocks creating
#' new functions and updating existing functions shortly after each runtime
#' is deprecated. For more information, see [Runtime use after
#' deprecation](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtime-deprecation-levels).
#' 
#' For a list of all currently supported runtimes, see [Supported
#' runtimes](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html#runtimes-supported).
#' @param DeadLetterConfig A dead-letter queue configuration that specifies the queue or topic
#' where Lambda sends asynchronous events when they fail processing. For
#' more information, see [Dead-letter
#' queues](https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#invocation-dlq).
#' @param KMSKeyArn The ARN of the Key Management Service (KMS) customer managed key that's
#' used to encrypt the following resources:
#' 
#' -   The function's [environment
#'     variables](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-encryption).
#' 
#' -   The function's [Lambda
#'     SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart-security.html)
#'     snapshots.
#' 
#' -   When used with `SourceKMSKeyArn`, the unzipped version of the .zip
#'     deployment package that's used for function invocations. For more
#'     information, see [Specifying a customer managed key for
#'     Lambda](https://docs.aws.amazon.com/lambda/latest/dg/encrypt-zip-package.html#enable-zip-custom-encryption).
#' 
#' -   The optimized version of the container image that's used for
#'     function invocations. Note that this is not the same key that's used
#'     to protect your container image in the Amazon Elastic Container
#'     Registry (Amazon ECR). For more information, see [Function
#'     lifecycle](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-lifecycle).
#' 
#' If you don't provide a customer managed key, Lambda uses an [Amazon Web
#' Services owned
#' key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-owned-cmk)
#' or an [Amazon Web Services managed
#' key](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk).
#' @param TracingConfig Set `Mode` to `Active` to sample and trace a subset of incoming requests
#' with
#' [X-Ray](https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html).
#' @param RevisionId Update the function only if the revision ID matches the ID that's
#' specified. Use this option to avoid modifying a function that has
#' changed since you last read it.
#' @param Layers A list of [function
#' layers](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)
#' to add to the function's execution environment. Specify each layer by
#' its ARN, including the version.
#' @param FileSystemConfigs Connection settings for an Amazon EFS file system.
#' @param ImageConfig [Container image configuration
#' values](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms)
#' that override the values in the container image Docker file.
#' @param EphemeralStorage The size of the function's `/tmp` directory in MB. The default value is
#' 512, but can be any whole number between 512 and 10,240 MB. For more
#' information, see [Configuring ephemeral storage
#' (console)](https://docs.aws.amazon.com/lambda/latest/dg/lambda-functions.html#configuration-ephemeral-storage).
#' @param SnapStart The function's
#' [SnapStart](https://docs.aws.amazon.com/lambda/latest/dg/snapstart.html)
#' setting.
#' @param LoggingConfig The function's Amazon CloudWatch Logs configuration settings.
#' @param CapacityProviderConfig Configuration for the capacity provider that manages compute resources
#' for Lambda functions.
#' @param DurableConfig Configuration settings for durable functions. Allows updating execution
#' timeout and retention period for functions with durability enabled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionName = "string",
#'   FunctionArn = "string",
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   Role = "string",
#'   Handler = "string",
#'   CodeSize = 123,
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   LastModified = "string",
#'   CodeSha256 = "string",
#'   Version = "string",
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     VpcId = "string",
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   MasterArn = "string",
#'   RevisionId = "string",
#'   Layers = list(
#'     list(
#'       Arn = "string",
#'       CodeSize = 123,
#'       SigningProfileVersionArn = "string",
#'       SigningJobArn = "string"
#'     )
#'   ),
#'   State = "Pending"|"Active"|"Inactive"|"Failed"|"Deactivating"|"Deactivated"|"ActiveNonInvocable"|"Deleting",
#'   StateReason = "string",
#'   StateReasonCode = "Idle"|"Creating"|"Restoring"|"EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"DrainingDurableExecutions"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   LastUpdateStatus = "Successful"|"Failed"|"InProgress",
#'   LastUpdateStatusReason = "string",
#'   LastUpdateStatusReasonCode = "EniLimitExceeded"|"InsufficientRolePermissions"|"InvalidConfiguration"|"InternalError"|"SubnetOutOfIPAddresses"|"InvalidSubnet"|"InvalidSecurityGroup"|"ImageDeleted"|"ImageAccessDenied"|"InvalidImage"|"KMSKeyAccessDenied"|"KMSKeyNotFound"|"InvalidStateKMSKey"|"DisabledKMSKey"|"EFSIOError"|"EFSMountConnectivityError"|"EFSMountFailure"|"EFSMountTimeout"|"InvalidRuntime"|"InvalidZipFileException"|"FunctionError"|"VcpuLimitExceeded"|"CapacityProviderScalingLimitExceeded"|"InsufficientCapacity"|"EC2RequestLimitExceeded"|"FunctionError.InitTimeout"|"FunctionError.RuntimeInitError"|"FunctionError.ExtensionInitError"|"FunctionError.InvalidEntryPoint"|"FunctionError.InvalidWorkingDirectory"|"FunctionError.PermissionDenied"|"FunctionError.TooManyExtensions"|"FunctionError.InitResourceExhausted"|"DisallowedByVpcEncryptionControl",
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   PackageType = "Zip"|"Image",
#'   ImageConfigResponse = list(
#'     ImageConfig = list(
#'       EntryPoint = list(
#'         "string"
#'       ),
#'       Command = list(
#'         "string"
#'       ),
#'       WorkingDirectory = "string"
#'     ),
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   SigningProfileVersionArn = "string",
#'   SigningJobArn = "string",
#'   Architectures = list(
#'     "x86_64"|"arm64"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None",
#'     OptimizationStatus = "On"|"Off"
#'   ),
#'   RuntimeVersionConfig = list(
#'     RuntimeVersionArn = "string",
#'     Error = list(
#'       ErrorCode = "string",
#'       Message = "string"
#'     )
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   ConfigSha256 = "string",
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   ),
#'   TenancyConfig = list(
#'     TenantIsolationMode = "PER_TENANT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_function_configuration(
#'   FunctionName = "string",
#'   Role = "string",
#'   Handler = "string",
#'   Description = "string",
#'   Timeout = 123,
#'   MemorySize = 123,
#'   VpcConfig = list(
#'     SubnetIds = list(
#'       "string"
#'     ),
#'     SecurityGroupIds = list(
#'       "string"
#'     ),
#'     Ipv6AllowedForDualStack = TRUE|FALSE
#'   ),
#'   Environment = list(
#'     Variables = list(
#'       "string"
#'     )
#'   ),
#'   Runtime = "nodejs"|"nodejs4.3"|"nodejs6.10"|"nodejs8.10"|"nodejs10.x"|"nodejs12.x"|"nodejs14.x"|"nodejs16.x"|"java8"|"java8.al2"|"java11"|"python2.7"|"python3.6"|"python3.7"|"python3.8"|"python3.9"|"dotnetcore1.0"|"dotnetcore2.0"|"dotnetcore2.1"|"dotnetcore3.1"|"dotnet6"|"dotnet8"|"nodejs4.3-edge"|"go1.x"|"ruby2.5"|"ruby2.7"|"provided"|"provided.al2"|"nodejs18.x"|"python3.10"|"java17"|"ruby3.2"|"ruby3.3"|"ruby3.4"|"python3.11"|"nodejs20.x"|"provided.al2023"|"python3.12"|"java21"|"python3.13"|"nodejs22.x"|"nodejs24.x"|"python3.14"|"java25"|"dotnet10",
#'   DeadLetterConfig = list(
#'     TargetArn = "string"
#'   ),
#'   KMSKeyArn = "string",
#'   TracingConfig = list(
#'     Mode = "Active"|"PassThrough"
#'   ),
#'   RevisionId = "string",
#'   Layers = list(
#'     "string"
#'   ),
#'   FileSystemConfigs = list(
#'     list(
#'       Arn = "string",
#'       LocalMountPath = "string"
#'     )
#'   ),
#'   ImageConfig = list(
#'     EntryPoint = list(
#'       "string"
#'     ),
#'     Command = list(
#'       "string"
#'     ),
#'     WorkingDirectory = "string"
#'   ),
#'   EphemeralStorage = list(
#'     Size = 123
#'   ),
#'   SnapStart = list(
#'     ApplyOn = "PublishedVersions"|"None"
#'   ),
#'   LoggingConfig = list(
#'     LogFormat = "JSON"|"Text",
#'     ApplicationLogLevel = "TRACE"|"DEBUG"|"INFO"|"WARN"|"ERROR"|"FATAL",
#'     SystemLogLevel = "DEBUG"|"INFO"|"WARN",
#'     LogGroup = "string"
#'   ),
#'   CapacityProviderConfig = list(
#'     LambdaManagedInstancesCapacityProviderConfig = list(
#'       CapacityProviderArn = "string",
#'       PerExecutionEnvironmentMaxConcurrency = 123,
#'       ExecutionEnvironmentMemoryGiBPerVCpu = 123.0
#'     )
#'   ),
#'   DurableConfig = list(
#'     RetentionPeriodInDays = 123,
#'     ExecutionTimeout = 123
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example modifies the memory size to be 256 MB for the
#' # unpublished ($LATEST) version of a function named my-function.
#' svc$update_function_configuration(
#'   FunctionName = "my-function",
#'   MemorySize = 256L
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_update_function_configuration
#'
#' @aliases lambda_update_function_configuration
lambda_update_function_configuration <- function(FunctionName, Role = NULL, Handler = NULL, Description = NULL, Timeout = NULL, MemorySize = NULL, VpcConfig = NULL, Environment = NULL, Runtime = NULL, DeadLetterConfig = NULL, KMSKeyArn = NULL, TracingConfig = NULL, RevisionId = NULL, Layers = NULL, FileSystemConfigs = NULL, ImageConfig = NULL, EphemeralStorage = NULL, SnapStart = NULL, LoggingConfig = NULL, CapacityProviderConfig = NULL, DurableConfig = NULL) {
  op <- new_operation(
    name = "UpdateFunctionConfiguration",
    http_method = "PUT",
    http_path = "/2015-03-31/functions/{FunctionName}/configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_function_configuration_input(FunctionName = FunctionName, Role = Role, Handler = Handler, Description = Description, Timeout = Timeout, MemorySize = MemorySize, VpcConfig = VpcConfig, Environment = Environment, Runtime = Runtime, DeadLetterConfig = DeadLetterConfig, KMSKeyArn = KMSKeyArn, TracingConfig = TracingConfig, RevisionId = RevisionId, Layers = Layers, FileSystemConfigs = FileSystemConfigs, ImageConfig = ImageConfig, EphemeralStorage = EphemeralStorage, SnapStart = SnapStart, LoggingConfig = LoggingConfig, CapacityProviderConfig = CapacityProviderConfig, DurableConfig = DurableConfig)
  output <- .lambda$update_function_configuration_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_function_configuration <- lambda_update_function_configuration

#' Updates the configuration for asynchronous invocation for a function,
#' version, or alias
#'
#' @description
#' Updates the configuration for asynchronous invocation for a function,
#' version, or alias.
#' 
#' To configure options for asynchronous invocation, use
#' [`put_function_event_invoke_config`][lambda_put_function_event_invoke_config].
#'
#' @usage
#' lambda_update_function_event_invoke_config(FunctionName, Qualifier,
#'   MaximumRetryAttempts, MaximumEventAgeInSeconds, DestinationConfig)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function, version, or alias.
#' 
#' **Name formats**
#' 
#' -   **Function name** - `my-function` (name-only), `my-function:v1`
#'     (with alias).
#' 
#' -   **Function ARN** -
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** - `123456789012:function:my-function`.
#' 
#' You can append a version number or alias to any of the formats. The
#' length constraint applies only to the full ARN. If you specify only the
#' function name, it is limited to 64 characters in length.
#' @param Qualifier A version number or alias name.
#' @param MaximumRetryAttempts The maximum number of times to retry when the function returns an error.
#' @param MaximumEventAgeInSeconds The maximum age of a request that Lambda sends to a function for
#' processing.
#' @param DestinationConfig A destination for events after they have been sent to a function for
#' processing.
#' 
#' **Destinations**
#' 
#' -   **Function** - The Amazon Resource Name (ARN) of a Lambda function.
#' 
#' -   **Queue** - The ARN of a standard SQS queue.
#' 
#' -   **Bucket** - The ARN of an Amazon S3 bucket.
#' 
#' -   **Topic** - The ARN of a standard SNS topic.
#' 
#' -   **Event Bus** - The ARN of an Amazon EventBridge event bus.
#' 
#' S3 buckets are supported only for on-failure destinations. To retain
#' records of successful invocations, use another destination type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   LastModified = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FunctionArn = "string",
#'   MaximumRetryAttempts = 123,
#'   MaximumEventAgeInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_function_event_invoke_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   MaximumRetryAttempts = 123,
#'   MaximumEventAgeInSeconds = 123,
#'   DestinationConfig = list(
#'     OnSuccess = list(
#'       Destination = "string"
#'     ),
#'     OnFailure = list(
#'       Destination = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example adds an on-failure destination to the existing
#' # asynchronous invocation configuration for a function named my-function.
#' svc$update_function_event_invoke_config(
#'   DestinationConfig = list(
#'     OnFailure = list(
#'       Destination = "arn:aws:sqs:us-east-2:123456789012:destination"
#'     )
#'   ),
#'   FunctionName = "my-function"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname lambda_update_function_event_invoke_config
#'
#' @aliases lambda_update_function_event_invoke_config
lambda_update_function_event_invoke_config <- function(FunctionName, Qualifier = NULL, MaximumRetryAttempts = NULL, MaximumEventAgeInSeconds = NULL, DestinationConfig = NULL) {
  op <- new_operation(
    name = "UpdateFunctionEventInvokeConfig",
    http_method = "POST",
    http_path = "/2019-09-25/functions/{FunctionName}/event-invoke-config",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_function_event_invoke_config_input(FunctionName = FunctionName, Qualifier = Qualifier, MaximumRetryAttempts = MaximumRetryAttempts, MaximumEventAgeInSeconds = MaximumEventAgeInSeconds, DestinationConfig = DestinationConfig)
  output <- .lambda$update_function_event_invoke_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_function_event_invoke_config <- lambda_update_function_event_invoke_config

#' Updates the configuration for a Lambda function URL
#'
#' @description
#' Updates the configuration for a Lambda function URL.
#'
#' @usage
#' lambda_update_function_url_config(FunctionName, Qualifier, AuthType,
#'   Cors, InvokeMode)
#'
#' @param FunctionName &#91;required&#93; The name or ARN of the Lambda function.
#' 
#' **Name formats**
#' 
#' -   **Function name** – `my-function`.
#' 
#' -   **Function ARN** –
#'     `arn:aws:lambda:us-west-2:123456789012:function:my-function`.
#' 
#' -   **Partial ARN** – `123456789012:function:my-function`.
#' 
#' The length constraint applies only to the full ARN. If you specify only
#' the function name, it is limited to 64 characters in length.
#' @param Qualifier The alias name.
#' @param AuthType The type of authentication that your function URL uses. Set to `AWS_IAM`
#' if you want to restrict access to authenticated users only. Set to
#' `NONE` if you want to bypass IAM authentication to create a public
#' endpoint. For more information, see [Control access to Lambda function
#' URLs](https://docs.aws.amazon.com/lambda/latest/dg/urls-auth.html).
#' @param Cors The [cross-origin resource sharing
#' (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS)
#' settings for your function URL.
#' @param InvokeMode Use one of the following options:
#' 
#' -   `BUFFERED` – This is the default option. Lambda invokes your
#'     function using the [`invoke`][lambda_invoke] API operation.
#'     Invocation results are available when the payload is complete. The
#'     maximum payload size is 6 MB.
#' 
#' -   `RESPONSE_STREAM` – Your function streams payload results as they
#'     become available. Lambda invokes your function using the
#'     [`invoke_with_response_stream`][lambda_invoke_with_response_stream]
#'     API operation. The maximum response payload size is 200 MB.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FunctionUrl = "string",
#'   FunctionArn = "string",
#'   AuthType = "NONE"|"AWS_IAM",
#'   Cors = list(
#'     AllowCredentials = TRUE|FALSE,
#'     AllowHeaders = list(
#'       "string"
#'     ),
#'     AllowMethods = list(
#'       "string"
#'     ),
#'     AllowOrigins = list(
#'       "string"
#'     ),
#'     ExposeHeaders = list(
#'       "string"
#'     ),
#'     MaxAge = 123
#'   ),
#'   CreationTime = "string",
#'   LastModifiedTime = "string",
#'   InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_function_url_config(
#'   FunctionName = "string",
#'   Qualifier = "string",
#'   AuthType = "NONE"|"AWS_IAM",
#'   Cors = list(
#'     AllowCredentials = TRUE|FALSE,
#'     AllowHeaders = list(
#'       "string"
#'     ),
#'     AllowMethods = list(
#'       "string"
#'     ),
#'     AllowOrigins = list(
#'       "string"
#'     ),
#'     ExposeHeaders = list(
#'       "string"
#'     ),
#'     MaxAge = 123
#'   ),
#'   InvokeMode = "BUFFERED"|"RESPONSE_STREAM"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lambda_update_function_url_config
#'
#' @aliases lambda_update_function_url_config
lambda_update_function_url_config <- function(FunctionName, Qualifier = NULL, AuthType = NULL, Cors = NULL, InvokeMode = NULL) {
  op <- new_operation(
    name = "UpdateFunctionUrlConfig",
    http_method = "PUT",
    http_path = "/2021-10-31/functions/{FunctionName}/url",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lambda$update_function_url_config_input(FunctionName = FunctionName, Qualifier = Qualifier, AuthType = AuthType, Cors = Cors, InvokeMode = InvokeMode)
  output <- .lambda$update_function_url_config_output()
  config <- get_config()
  svc <- .lambda$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lambda$operations$update_function_url_config <- lambda_update_function_url_config

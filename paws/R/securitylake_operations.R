# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include securitylake_service.R
NULL

#' Adds a natively supported Amazon Web Service as an Amazon Security Lake
#' source
#'
#' @description
#' Adds a natively supported Amazon Web Service as an Amazon Security Lake
#' source. Enables source types for member accounts in required Amazon Web
#' Services Regions, based on the parameters you specify. You can choose
#' any source type in any Region for either accounts that are part of a
#' trusted organization or standalone accounts. Once you add an Amazon Web
#' Service as a source, Security Lake starts collecting logs and events
#' from it.
#' 
#' You can use this API only to enable natively supported Amazon Web
#' Services as a source. Use
#' [`create_custom_log_source`][securitylake_create_custom_log_source] to
#' enable data collection from a custom source.
#'
#' @usage
#' securitylake_create_aws_log_source(sources)
#'
#' @param sources &#91;required&#93; Specify the natively-supported Amazon Web Services service to add as a
#' source in Security Lake.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   failed = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_aws_log_source(
#'   sources = list(
#'     list(
#'       accounts = list(
#'         "string"
#'       ),
#'       regions = list(
#'         "string"
#'       ),
#'       sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'       sourceVersion = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_aws_log_source
#'
#' @aliases securitylake_create_aws_log_source
securitylake_create_aws_log_source <- function(sources) {
  op <- new_operation(
    name = "CreateAwsLogSource",
    http_method = "POST",
    http_path = "/v1/datalake/logsources/aws",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_aws_log_source_input(sources = sources)
  output <- .securitylake$create_aws_log_source_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_aws_log_source <- securitylake_create_aws_log_source

#' Adds a third-party custom source in Amazon Security Lake, from the
#' Amazon Web Services Region where you want to create a custom source
#'
#' @description
#' Adds a third-party custom source in Amazon Security Lake, from the
#' Amazon Web Services Region where you want to create a custom source.
#' Security Lake can collect logs and events from third-party custom
#' sources. After creating the appropriate IAM role to invoke Glue crawler,
#' use this API to add a custom source name in Security Lake. This
#' operation creates a partition in the Amazon S3 bucket for Security Lake
#' as the target location for log files from the custom source. In
#' addition, this operation also creates an associated Glue table and an
#' Glue crawler.
#'
#' @usage
#' securitylake_create_custom_log_source(configuration, eventClasses,
#'   sourceName, sourceVersion)
#'
#' @param configuration &#91;required&#93; The configuration for the third-party custom source.
#' @param eventClasses The Open Cybersecurity Schema Framework (OCSF) event classes which
#' describes the type of data that the custom source will send to Security
#' Lake. The supported event classes are:
#' 
#' -   `ACCESS_ACTIVITY`
#' 
#' -   `FILE_ACTIVITY`
#' 
#' -   `KERNEL_ACTIVITY`
#' 
#' -   `KERNEL_EXTENSION`
#' 
#' -   `MEMORY_ACTIVITY`
#' 
#' -   `MODULE_ACTIVITY`
#' 
#' -   `PROCESS_ACTIVITY`
#' 
#' -   `REGISTRY_KEY_ACTIVITY`
#' 
#' -   `REGISTRY_VALUE_ACTIVITY`
#' 
#' -   `RESOURCE_ACTIVITY`
#' 
#' -   `SCHEDULED_JOB_ACTIVITY`
#' 
#' -   `SECURITY_FINDING`
#' 
#' -   `ACCOUNT_CHANGE`
#' 
#' -   `AUTHENTICATION`
#' 
#' -   `AUTHORIZATION`
#' 
#' -   `ENTITY_MANAGEMENT_AUDIT`
#' 
#' -   `DHCP_ACTIVITY`
#' 
#' -   `NETWORK_ACTIVITY`
#' 
#' -   `DNS_ACTIVITY`
#' 
#' -   `FTP_ACTIVITY`
#' 
#' -   `HTTP_ACTIVITY`
#' 
#' -   `RDP_ACTIVITY`
#' 
#' -   `SMB_ACTIVITY`
#' 
#' -   `SSH_ACTIVITY`
#' 
#' -   `CONFIG_STATE`
#' 
#' -   `INVENTORY_INFO`
#' 
#' -   `EMAIL_ACTIVITY`
#' 
#' -   `API_ACTIVITY`
#' 
#' -   `CLOUD_API`
#' @param sourceName &#91;required&#93; Specify the name for a third-party custom source. This must be a
#' Regionally unique value.
#' @param sourceVersion Specify the source version for the third-party custom source, to limit
#' log collection to a specific version of custom data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   source = list(
#'     attributes = list(
#'       crawlerArn = "string",
#'       databaseArn = "string",
#'       tableArn = "string"
#'     ),
#'     provider = list(
#'       location = "string",
#'       roleArn = "string"
#'     ),
#'     sourceName = "string",
#'     sourceVersion = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_custom_log_source(
#'   configuration = list(
#'     crawlerConfiguration = list(
#'       roleArn = "string"
#'     ),
#'     providerIdentity = list(
#'       externalId = "string",
#'       principal = "string"
#'     )
#'   ),
#'   eventClasses = list(
#'     "string"
#'   ),
#'   sourceName = "string",
#'   sourceVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_custom_log_source
#'
#' @aliases securitylake_create_custom_log_source
securitylake_create_custom_log_source <- function(configuration, eventClasses = NULL, sourceName, sourceVersion = NULL) {
  op <- new_operation(
    name = "CreateCustomLogSource",
    http_method = "POST",
    http_path = "/v1/datalake/logsources/custom",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_custom_log_source_input(configuration = configuration, eventClasses = eventClasses, sourceName = sourceName, sourceVersion = sourceVersion)
  output <- .securitylake$create_custom_log_source_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_custom_log_source <- securitylake_create_custom_log_source

#' Initializes an Amazon Security Lake instance with the provided (or
#' default) configuration
#'
#' @description
#' Initializes an Amazon Security Lake instance with the provided (or
#' default) configuration. You can enable Security Lake in Amazon Web
#' Services Regions with customized settings before enabling log collection
#' in Regions. To specify particular Regions, configure these Regions using
#' the `configurations` parameter. If you have already enabled Security
#' Lake in a Region when you call this command, the command will update the
#' Region if you provide new configuration parameters. If you have not
#' already enabled Security Lake in the Region when you call this API, it
#' will set up the data lake in the Region with the specified
#' configurations.
#' 
#' When you enable Security Lake, it starts ingesting security data after
#' the [`create_aws_log_source`][securitylake_create_aws_log_source] call.
#' This includes ingesting security data from sources, storing data, and
#' making data accessible to subscribers. Security Lake also enables all
#' the existing settings and resources that it stores or maintains for your
#' Amazon Web Services account in the current Region, including security
#' log and event data. For more information, see the [Amazon Security Lake
#' User
#' Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html).
#'
#' @usage
#' securitylake_create_data_lake(configurations, metaStoreManagerRoleArn,
#'   tags)
#'
#' @param configurations &#91;required&#93; Specify the Region or Regions that will contribute data to the rollup
#' region.
#' @param metaStoreManagerRoleArn &#91;required&#93; The Amazon Resource Name (ARN) used to create and update the Glue table.
#' This table contains partitions generated by the ingestion and
#' normalization of Amazon Web Services log sources and custom sources.
#' @param tags An array of objects, one for each tag to associate with the data lake
#' configuration. For each tag, you must specify both a tag key and a tag
#' value. A tag value cannot be null, but it can be an empty string.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   dataLakes = list(
#'     list(
#'       createStatus = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED",
#'       dataLakeArn = "string",
#'       encryptionConfiguration = list(
#'         kmsKeyId = "string"
#'       ),
#'       lifecycleConfiguration = list(
#'         expiration = list(
#'           days = 123
#'         ),
#'         transitions = list(
#'           list(
#'             days = 123,
#'             storageClass = "string"
#'           )
#'         )
#'       ),
#'       region = "string",
#'       replicationConfiguration = list(
#'         regions = list(
#'           "string"
#'         ),
#'         roleArn = "string"
#'       ),
#'       s3BucketArn = "string",
#'       updateStatus = list(
#'         exception = list(
#'           code = "string",
#'           reason = "string"
#'         ),
#'         requestId = "string",
#'         status = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_lake(
#'   configurations = list(
#'     list(
#'       encryptionConfiguration = list(
#'         kmsKeyId = "string"
#'       ),
#'       lifecycleConfiguration = list(
#'         expiration = list(
#'           days = 123
#'         ),
#'         transitions = list(
#'           list(
#'             days = 123,
#'             storageClass = "string"
#'           )
#'         )
#'       ),
#'       region = "string",
#'       replicationConfiguration = list(
#'         regions = list(
#'           "string"
#'         ),
#'         roleArn = "string"
#'       )
#'     )
#'   ),
#'   metaStoreManagerRoleArn = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_data_lake
#'
#' @aliases securitylake_create_data_lake
securitylake_create_data_lake <- function(configurations, metaStoreManagerRoleArn, tags = NULL) {
  op <- new_operation(
    name = "CreateDataLake",
    http_method = "POST",
    http_path = "/v1/datalake",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_data_lake_input(configurations = configurations, metaStoreManagerRoleArn = metaStoreManagerRoleArn, tags = tags)
  output <- .securitylake$create_data_lake_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_data_lake <- securitylake_create_data_lake

#' Creates the specified notification subscription in Amazon Security Lake
#' for the organization you specify
#'
#' @description
#' Creates the specified notification subscription in Amazon Security Lake
#' for the organization you specify.
#'
#' @usage
#' securitylake_create_data_lake_exception_subscription(
#'   exceptionTimeToLive, notificationEndpoint, subscriptionProtocol)
#'
#' @param exceptionTimeToLive The expiration period and time-to-live (TTL).
#' @param notificationEndpoint &#91;required&#93; The Amazon Web Services account where you want to receive exception
#' notifications.
#' @param subscriptionProtocol &#91;required&#93; The subscription protocol to which exception notifications are posted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_data_lake_exception_subscription(
#'   exceptionTimeToLive = 123,
#'   notificationEndpoint = "string",
#'   subscriptionProtocol = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_data_lake_exception_subscription
#'
#' @aliases securitylake_create_data_lake_exception_subscription
securitylake_create_data_lake_exception_subscription <- function(exceptionTimeToLive = NULL, notificationEndpoint, subscriptionProtocol) {
  op <- new_operation(
    name = "CreateDataLakeExceptionSubscription",
    http_method = "POST",
    http_path = "/v1/datalake/exceptions/subscription",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_data_lake_exception_subscription_input(exceptionTimeToLive = exceptionTimeToLive, notificationEndpoint = notificationEndpoint, subscriptionProtocol = subscriptionProtocol)
  output <- .securitylake$create_data_lake_exception_subscription_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_data_lake_exception_subscription <- securitylake_create_data_lake_exception_subscription

#' Automatically enables Amazon Security Lake for new member accounts in
#' your organization
#'
#' @description
#' Automatically enables Amazon Security Lake for new member accounts in
#' your organization. Security Lake is not automatically enabled for any
#' existing member accounts in your organization.
#'
#' @usage
#' securitylake_create_data_lake_organization_configuration(
#'   autoEnableNewAccount)
#'
#' @param autoEnableNewAccount Enable Security Lake with the specified configuration settings, to begin
#' collecting security data for new accounts in your organization.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_data_lake_organization_configuration(
#'   autoEnableNewAccount = list(
#'     list(
#'       region = "string",
#'       sources = list(
#'         list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_data_lake_organization_configuration
#'
#' @aliases securitylake_create_data_lake_organization_configuration
securitylake_create_data_lake_organization_configuration <- function(autoEnableNewAccount = NULL) {
  op <- new_operation(
    name = "CreateDataLakeOrganizationConfiguration",
    http_method = "POST",
    http_path = "/v1/datalake/organization/configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_data_lake_organization_configuration_input(autoEnableNewAccount = autoEnableNewAccount)
  output <- .securitylake$create_data_lake_organization_configuration_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_data_lake_organization_configuration <- securitylake_create_data_lake_organization_configuration

#' Creates a subscription permission for accounts that are already enabled
#' in Amazon Security Lake
#'
#' @description
#' Creates a subscription permission for accounts that are already enabled
#' in Amazon Security Lake. You can create a subscriber with access to data
#' in the current Amazon Web Services Region.
#'
#' @usage
#' securitylake_create_subscriber(accessTypes, sources,
#'   subscriberDescription, subscriberIdentity, subscriberName, tags)
#'
#' @param accessTypes The Amazon S3 or Lake Formation access type.
#' @param sources &#91;required&#93; The supported Amazon Web Services from which logs and events are
#' collected. Security Lake supports log and event collection for natively
#' supported Amazon Web Services.
#' @param subscriberDescription The description for your subscriber account in Security Lake.
#' @param subscriberIdentity &#91;required&#93; The Amazon Web Services identity used to access your data.
#' @param subscriberName &#91;required&#93; The name of your Security Lake subscriber account.
#' @param tags An array of objects, one for each tag to associate with the subscriber.
#' For each tag, you must specify both a tag key and a tag value. A tag
#' value cannot be null, but it can be an empty string.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriber = list(
#'     accessTypes = list(
#'       "LAKEFORMATION"|"S3"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     resourceShareArn = "string",
#'     resourceShareName = "string",
#'     roleArn = "string",
#'     s3BucketArn = "string",
#'     sources = list(
#'       list(
#'         awsLogSource = list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         ),
#'         customLogSource = list(
#'           attributes = list(
#'             crawlerArn = "string",
#'             databaseArn = "string",
#'             tableArn = "string"
#'           ),
#'           provider = list(
#'             location = "string",
#'             roleArn = "string"
#'           ),
#'           sourceName = "string",
#'           sourceVersion = "string"
#'         )
#'       )
#'     ),
#'     subscriberArn = "string",
#'     subscriberDescription = "string",
#'     subscriberEndpoint = "string",
#'     subscriberId = "string",
#'     subscriberIdentity = list(
#'       externalId = "string",
#'       principal = "string"
#'     ),
#'     subscriberName = "string",
#'     subscriberStatus = "ACTIVE"|"DEACTIVATED"|"PENDING"|"READY",
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_subscriber(
#'   accessTypes = list(
#'     "LAKEFORMATION"|"S3"
#'   ),
#'   sources = list(
#'     list(
#'       awsLogSource = list(
#'         sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'         sourceVersion = "string"
#'       ),
#'       customLogSource = list(
#'         attributes = list(
#'           crawlerArn = "string",
#'           databaseArn = "string",
#'           tableArn = "string"
#'         ),
#'         provider = list(
#'           location = "string",
#'           roleArn = "string"
#'         ),
#'         sourceName = "string",
#'         sourceVersion = "string"
#'       )
#'     )
#'   ),
#'   subscriberDescription = "string",
#'   subscriberIdentity = list(
#'     externalId = "string",
#'     principal = "string"
#'   ),
#'   subscriberName = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_subscriber
#'
#' @aliases securitylake_create_subscriber
securitylake_create_subscriber <- function(accessTypes = NULL, sources, subscriberDescription = NULL, subscriberIdentity, subscriberName, tags = NULL) {
  op <- new_operation(
    name = "CreateSubscriber",
    http_method = "POST",
    http_path = "/v1/subscribers",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_subscriber_input(accessTypes = accessTypes, sources = sources, subscriberDescription = subscriberDescription, subscriberIdentity = subscriberIdentity, subscriberName = subscriberName, tags = tags)
  output <- .securitylake$create_subscriber_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_subscriber <- securitylake_create_subscriber

#' Notifies the subscriber when new data is written to the data lake for
#' the sources that the subscriber consumes in Security Lake
#'
#' @description
#' Notifies the subscriber when new data is written to the data lake for
#' the sources that the subscriber consumes in Security Lake. You can
#' create only one subscriber notification per subscriber.
#'
#' @usage
#' securitylake_create_subscriber_notification(configuration, subscriberId)
#'
#' @param configuration &#91;required&#93; Specify the configuration using which you want to create the subscriber
#' notification.
#' @param subscriberId &#91;required&#93; The subscriber ID for the notification subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriberEndpoint = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_subscriber_notification(
#'   configuration = list(
#'     httpsNotificationConfiguration = list(
#'       authorizationApiKeyName = "string",
#'       authorizationApiKeyValue = "string",
#'       endpoint = "string",
#'       httpMethod = "POST"|"PUT",
#'       targetRoleArn = "string"
#'     ),
#'     sqsNotificationConfiguration = list()
#'   ),
#'   subscriberId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_create_subscriber_notification
#'
#' @aliases securitylake_create_subscriber_notification
securitylake_create_subscriber_notification <- function(configuration, subscriberId) {
  op <- new_operation(
    name = "CreateSubscriberNotification",
    http_method = "POST",
    http_path = "/v1/subscribers/{subscriberId}/notification",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$create_subscriber_notification_input(configuration = configuration, subscriberId = subscriberId)
  output <- .securitylake$create_subscriber_notification_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$create_subscriber_notification <- securitylake_create_subscriber_notification

#' Removes a natively supported Amazon Web Service as an Amazon Security
#' Lake source
#'
#' @description
#' Removes a natively supported Amazon Web Service as an Amazon Security
#' Lake source. You can remove a source for one or more Regions. When you
#' remove the source, Security Lake stops collecting data from that source
#' in the specified Regions and accounts, and subscribers can no longer
#' consume new data from the source. However, subscribers can still consume
#' data that Security Lake collected from the source before removal.
#' 
#' You can choose any source type in any Amazon Web Services Region for
#' either accounts that are part of a trusted organization or standalone
#' accounts.
#'
#' @usage
#' securitylake_delete_aws_log_source(sources)
#'
#' @param sources &#91;required&#93; Specify the natively-supported Amazon Web Services service to remove as
#' a source in Security Lake.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   failed = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_aws_log_source(
#'   sources = list(
#'     list(
#'       accounts = list(
#'         "string"
#'       ),
#'       regions = list(
#'         "string"
#'       ),
#'       sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'       sourceVersion = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_aws_log_source
#'
#' @aliases securitylake_delete_aws_log_source
securitylake_delete_aws_log_source <- function(sources) {
  op <- new_operation(
    name = "DeleteAwsLogSource",
    http_method = "POST",
    http_path = "/v1/datalake/logsources/aws/delete",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_aws_log_source_input(sources = sources)
  output <- .securitylake$delete_aws_log_source_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_aws_log_source <- securitylake_delete_aws_log_source

#' Removes a custom log source from Amazon Security Lake, to stop sending
#' data from the custom source to Security Lake
#'
#' @description
#' Removes a custom log source from Amazon Security Lake, to stop sending
#' data from the custom source to Security Lake.
#'
#' @usage
#' securitylake_delete_custom_log_source(sourceName, sourceVersion)
#'
#' @param sourceName &#91;required&#93; The source name of custom log source that you want to delete.
#' @param sourceVersion The source version for the third-party custom source. You can limit the
#' custom source removal to the specified source version.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_custom_log_source(
#'   sourceName = "string",
#'   sourceVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_custom_log_source
#'
#' @aliases securitylake_delete_custom_log_source
securitylake_delete_custom_log_source <- function(sourceName, sourceVersion = NULL) {
  op <- new_operation(
    name = "DeleteCustomLogSource",
    http_method = "DELETE",
    http_path = "/v1/datalake/logsources/custom/{sourceName}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_custom_log_source_input(sourceName = sourceName, sourceVersion = sourceVersion)
  output <- .securitylake$delete_custom_log_source_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_custom_log_source <- securitylake_delete_custom_log_source

#' When you disable Amazon Security Lake from your account, Security Lake
#' is disabled in all Amazon Web Services Regions and it stops collecting
#' data from your sources
#'
#' @description
#' When you disable Amazon Security Lake from your account, Security Lake
#' is disabled in all Amazon Web Services Regions and it stops collecting
#' data from your sources. Also, this API automatically takes steps to
#' remove the account from Security Lake. However, Security Lake retains
#' all of your existing settings and the resources that it created in your
#' Amazon Web Services account in the current Amazon Web Services Region.
#' 
#' The [`delete_data_lake`][securitylake_delete_data_lake] operation does
#' not delete the data that is stored in your Amazon S3 bucket, which is
#' owned by your Amazon Web Services account. For more information, see the
#' [Amazon Security Lake User
#' Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/disable-security-lake.html).
#'
#' @usage
#' securitylake_delete_data_lake(regions)
#'
#' @param regions &#91;required&#93; The list of Regions where Security Lake is enabled.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_lake(
#'   regions = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_data_lake
#'
#' @aliases securitylake_delete_data_lake
securitylake_delete_data_lake <- function(regions) {
  op <- new_operation(
    name = "DeleteDataLake",
    http_method = "POST",
    http_path = "/v1/datalake/delete",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_data_lake_input(regions = regions)
  output <- .securitylake$delete_data_lake_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_data_lake <- securitylake_delete_data_lake

#' Deletes the specified notification subscription in Amazon Security Lake
#' for the organization you specify
#'
#' @description
#' Deletes the specified notification subscription in Amazon Security Lake
#' for the organization you specify.
#'
#' @usage
#' securitylake_delete_data_lake_exception_subscription()
#'

#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_lake_exception_subscription()
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_data_lake_exception_subscription
#'
#' @aliases securitylake_delete_data_lake_exception_subscription
securitylake_delete_data_lake_exception_subscription <- function() {
  op <- new_operation(
    name = "DeleteDataLakeExceptionSubscription",
    http_method = "DELETE",
    http_path = "/v1/datalake/exceptions/subscription",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_data_lake_exception_subscription_input()
  output <- .securitylake$delete_data_lake_exception_subscription_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_data_lake_exception_subscription <- securitylake_delete_data_lake_exception_subscription

#' Turns off automatic enablement of Amazon Security Lake for member
#' accounts that are added to an organization in Organizations
#'
#' @description
#' Turns off automatic enablement of Amazon Security Lake for member
#' accounts that are added to an organization in Organizations. Only the
#' delegated Security Lake administrator for an organization can perform
#' this operation. If the delegated Security Lake administrator performs
#' this operation, new member accounts won't automatically contribute data
#' to the data lake.
#'
#' @usage
#' securitylake_delete_data_lake_organization_configuration(
#'   autoEnableNewAccount)
#'
#' @param autoEnableNewAccount Turns off automatic enablement of Security Lake for member accounts that
#' are added to an organization.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_lake_organization_configuration(
#'   autoEnableNewAccount = list(
#'     list(
#'       region = "string",
#'       sources = list(
#'         list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_data_lake_organization_configuration
#'
#' @aliases securitylake_delete_data_lake_organization_configuration
securitylake_delete_data_lake_organization_configuration <- function(autoEnableNewAccount = NULL) {
  op <- new_operation(
    name = "DeleteDataLakeOrganizationConfiguration",
    http_method = "POST",
    http_path = "/v1/datalake/organization/configuration/delete",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_data_lake_organization_configuration_input(autoEnableNewAccount = autoEnableNewAccount)
  output <- .securitylake$delete_data_lake_organization_configuration_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_data_lake_organization_configuration <- securitylake_delete_data_lake_organization_configuration

#' Deletes the subscription permission and all notification settings for
#' accounts that are already enabled in Amazon Security Lake
#'
#' @description
#' Deletes the subscription permission and all notification settings for
#' accounts that are already enabled in Amazon Security Lake. When you run
#' [`delete_subscriber`][securitylake_delete_subscriber], the subscriber
#' will no longer consume data from Security Lake and the subscriber is
#' removed. This operation deletes the subscriber and removes access to
#' data in the current Amazon Web Services Region.
#'
#' @usage
#' securitylake_delete_subscriber(subscriberId)
#'
#' @param subscriberId &#91;required&#93; A value created by Security Lake that uniquely identifies your
#' [`delete_subscriber`][securitylake_delete_subscriber] API request.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_subscriber(
#'   subscriberId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_subscriber
#'
#' @aliases securitylake_delete_subscriber
securitylake_delete_subscriber <- function(subscriberId) {
  op <- new_operation(
    name = "DeleteSubscriber",
    http_method = "DELETE",
    http_path = "/v1/subscribers/{subscriberId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_subscriber_input(subscriberId = subscriberId)
  output <- .securitylake$delete_subscriber_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_subscriber <- securitylake_delete_subscriber

#' Deletes the specified notification subscription in Amazon Security Lake
#' for the organization you specify
#'
#' @description
#' Deletes the specified notification subscription in Amazon Security Lake
#' for the organization you specify.
#'
#' @usage
#' securitylake_delete_subscriber_notification(subscriberId)
#'
#' @param subscriberId &#91;required&#93; The ID of the Security Lake subscriber account.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_subscriber_notification(
#'   subscriberId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_delete_subscriber_notification
#'
#' @aliases securitylake_delete_subscriber_notification
securitylake_delete_subscriber_notification <- function(subscriberId) {
  op <- new_operation(
    name = "DeleteSubscriberNotification",
    http_method = "DELETE",
    http_path = "/v1/subscribers/{subscriberId}/notification",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$delete_subscriber_notification_input(subscriberId = subscriberId)
  output <- .securitylake$delete_subscriber_notification_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$delete_subscriber_notification <- securitylake_delete_subscriber_notification

#' Deletes the Amazon Security Lake delegated administrator account for the
#' organization
#'
#' @description
#' Deletes the Amazon Security Lake delegated administrator account for the
#' organization. This API can only be called by the organization management
#' account. The organization management account cannot be the delegated
#' administrator account.
#'
#' @usage
#' securitylake_deregister_data_lake_delegated_administrator()
#'

#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$deregister_data_lake_delegated_administrator()
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_deregister_data_lake_delegated_administrator
#'
#' @aliases securitylake_deregister_data_lake_delegated_administrator
securitylake_deregister_data_lake_delegated_administrator <- function() {
  op <- new_operation(
    name = "DeregisterDataLakeDelegatedAdministrator",
    http_method = "DELETE",
    http_path = "/v1/datalake/delegate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$deregister_data_lake_delegated_administrator_input()
  output <- .securitylake$deregister_data_lake_delegated_administrator_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$deregister_data_lake_delegated_administrator <- securitylake_deregister_data_lake_delegated_administrator

#' Retrieves the details of exception notifications for the account in
#' Amazon Security Lake
#'
#' @description
#' Retrieves the details of exception notifications for the account in
#' Amazon Security Lake.
#'
#' @usage
#' securitylake_get_data_lake_exception_subscription()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   exceptionTimeToLive = 123,
#'   notificationEndpoint = "string",
#'   subscriptionProtocol = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_lake_exception_subscription()
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_get_data_lake_exception_subscription
#'
#' @aliases securitylake_get_data_lake_exception_subscription
securitylake_get_data_lake_exception_subscription <- function() {
  op <- new_operation(
    name = "GetDataLakeExceptionSubscription",
    http_method = "GET",
    http_path = "/v1/datalake/exceptions/subscription",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$get_data_lake_exception_subscription_input()
  output <- .securitylake$get_data_lake_exception_subscription_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$get_data_lake_exception_subscription <- securitylake_get_data_lake_exception_subscription

#' Retrieves the configuration that will be automatically set up for
#' accounts added to the organization after the organization has onboarded
#' to Amazon Security Lake
#'
#' @description
#' Retrieves the configuration that will be automatically set up for
#' accounts added to the organization after the organization has onboarded
#' to Amazon Security Lake. This API does not take input parameters.
#'
#' @usage
#' securitylake_get_data_lake_organization_configuration()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   autoEnableNewAccount = list(
#'     list(
#'       region = "string",
#'       sources = list(
#'         list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_lake_organization_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_get_data_lake_organization_configuration
#'
#' @aliases securitylake_get_data_lake_organization_configuration
securitylake_get_data_lake_organization_configuration <- function() {
  op <- new_operation(
    name = "GetDataLakeOrganizationConfiguration",
    http_method = "GET",
    http_path = "/v1/datalake/organization/configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$get_data_lake_organization_configuration_input()
  output <- .securitylake$get_data_lake_organization_configuration_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$get_data_lake_organization_configuration <- securitylake_get_data_lake_organization_configuration

#' Retrieves a snapshot of the current Region, including whether Amazon
#' Security Lake is enabled for those accounts and which sources Security
#' Lake is collecting data from
#'
#' @description
#' Retrieves a snapshot of the current Region, including whether Amazon
#' Security Lake is enabled for those accounts and which sources Security
#' Lake is collecting data from.
#'
#' @usage
#' securitylake_get_data_lake_sources(accounts, maxResults, nextToken)
#'
#' @param accounts The Amazon Web Services account ID for which a static snapshot of the
#' current Amazon Web Services Region, including enabled accounts and log
#' sources, is retrieved.
#' @param maxResults The maximum limit of accounts for which the static snapshot of the
#' current Region, including enabled accounts and log sources, is
#' retrieved.
#' @param nextToken Lists if there are more results available. The value of nextToken is a
#' unique pagination token for each page. Repeat the call using the
#' returned token to retrieve the next page. Keep all other arguments
#' unchanged.
#' 
#' Each pagination token expires after 24 hours. Using an expired
#' pagination token will return an HTTP 400 InvalidToken error.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   dataLakeArn = "string",
#'   dataLakeSources = list(
#'     list(
#'       account = "string",
#'       eventClasses = list(
#'         "string"
#'       ),
#'       sourceName = "string",
#'       sourceStatuses = list(
#'         list(
#'           resource = "string",
#'           status = "COLLECTING"|"MISCONFIGURED"|"NOT_COLLECTING"
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_lake_sources(
#'   accounts = list(
#'     "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_get_data_lake_sources
#'
#' @aliases securitylake_get_data_lake_sources
securitylake_get_data_lake_sources <- function(accounts = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "GetDataLakeSources",
    http_method = "POST",
    http_path = "/v1/datalake/sources",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "dataLakeSources"),
    stream_api = FALSE
  )
  input <- .securitylake$get_data_lake_sources_input(accounts = accounts, maxResults = maxResults, nextToken = nextToken)
  output <- .securitylake$get_data_lake_sources_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$get_data_lake_sources <- securitylake_get_data_lake_sources

#' Retrieves the subscription information for the specified subscription ID
#'
#' @description
#' Retrieves the subscription information for the specified subscription
#' ID. You can get information about a specific subscriber.
#'
#' @usage
#' securitylake_get_subscriber(subscriberId)
#'
#' @param subscriberId &#91;required&#93; A value created by Amazon Security Lake that uniquely identifies your
#' [`get_subscriber`][securitylake_get_subscriber] API request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriber = list(
#'     accessTypes = list(
#'       "LAKEFORMATION"|"S3"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     resourceShareArn = "string",
#'     resourceShareName = "string",
#'     roleArn = "string",
#'     s3BucketArn = "string",
#'     sources = list(
#'       list(
#'         awsLogSource = list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         ),
#'         customLogSource = list(
#'           attributes = list(
#'             crawlerArn = "string",
#'             databaseArn = "string",
#'             tableArn = "string"
#'           ),
#'           provider = list(
#'             location = "string",
#'             roleArn = "string"
#'           ),
#'           sourceName = "string",
#'           sourceVersion = "string"
#'         )
#'       )
#'     ),
#'     subscriberArn = "string",
#'     subscriberDescription = "string",
#'     subscriberEndpoint = "string",
#'     subscriberId = "string",
#'     subscriberIdentity = list(
#'       externalId = "string",
#'       principal = "string"
#'     ),
#'     subscriberName = "string",
#'     subscriberStatus = "ACTIVE"|"DEACTIVATED"|"PENDING"|"READY",
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_subscriber(
#'   subscriberId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_get_subscriber
#'
#' @aliases securitylake_get_subscriber
securitylake_get_subscriber <- function(subscriberId) {
  op <- new_operation(
    name = "GetSubscriber",
    http_method = "GET",
    http_path = "/v1/subscribers/{subscriberId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$get_subscriber_input(subscriberId = subscriberId)
  output <- .securitylake$get_subscriber_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$get_subscriber <- securitylake_get_subscriber

#' Lists the Amazon Security Lake exceptions that you can use to find the
#' source of problems and fix them
#'
#' @description
#' Lists the Amazon Security Lake exceptions that you can use to find the
#' source of problems and fix them.
#'
#' @usage
#' securitylake_list_data_lake_exceptions(maxResults, nextToken, regions)
#'
#' @param maxResults List the maximum number of failures in Security Lake.
#' @param nextToken List if there are more results available. The value of nextToken is a
#' unique pagination token for each page. Repeat the call using the
#' returned token to retrieve the next page. Keep all other arguments
#' unchanged.
#' 
#' Each pagination token expires after 24 hours. Using an expired
#' pagination token will return an HTTP 400 InvalidToken error.
#' @param regions The Amazon Web Services Regions from which exceptions are retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   exceptions = list(
#'     list(
#'       exception = "string",
#'       region = "string",
#'       remediation = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_lake_exceptions(
#'   maxResults = 123,
#'   nextToken = "string",
#'   regions = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_list_data_lake_exceptions
#'
#' @aliases securitylake_list_data_lake_exceptions
securitylake_list_data_lake_exceptions <- function(maxResults = NULL, nextToken = NULL, regions = NULL) {
  op <- new_operation(
    name = "ListDataLakeExceptions",
    http_method = "POST",
    http_path = "/v1/datalake/exceptions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "exceptions"),
    stream_api = FALSE
  )
  input <- .securitylake$list_data_lake_exceptions_input(maxResults = maxResults, nextToken = nextToken, regions = regions)
  output <- .securitylake$list_data_lake_exceptions_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$list_data_lake_exceptions <- securitylake_list_data_lake_exceptions

#' Retrieves the Amazon Security Lake configuration object for the
#' specified Amazon Web Services Regions
#'
#' @description
#' Retrieves the Amazon Security Lake configuration object for the
#' specified Amazon Web Services Regions. You can use this operation to
#' determine whether Security Lake is enabled for a Region.
#'
#' @usage
#' securitylake_list_data_lakes(regions)
#'
#' @param regions The list of Regions where Security Lake is enabled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   dataLakes = list(
#'     list(
#'       createStatus = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED",
#'       dataLakeArn = "string",
#'       encryptionConfiguration = list(
#'         kmsKeyId = "string"
#'       ),
#'       lifecycleConfiguration = list(
#'         expiration = list(
#'           days = 123
#'         ),
#'         transitions = list(
#'           list(
#'             days = 123,
#'             storageClass = "string"
#'           )
#'         )
#'       ),
#'       region = "string",
#'       replicationConfiguration = list(
#'         regions = list(
#'           "string"
#'         ),
#'         roleArn = "string"
#'       ),
#'       s3BucketArn = "string",
#'       updateStatus = list(
#'         exception = list(
#'           code = "string",
#'           reason = "string"
#'         ),
#'         requestId = "string",
#'         status = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_lakes(
#'   regions = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_list_data_lakes
#'
#' @aliases securitylake_list_data_lakes
securitylake_list_data_lakes <- function(regions = NULL) {
  op <- new_operation(
    name = "ListDataLakes",
    http_method = "GET",
    http_path = "/v1/datalakes",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$list_data_lakes_input(regions = regions)
  output <- .securitylake$list_data_lakes_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$list_data_lakes <- securitylake_list_data_lakes

#' Retrieves the log sources in the current Amazon Web Services Region
#'
#' @description
#' Retrieves the log sources in the current Amazon Web Services Region.
#'
#' @usage
#' securitylake_list_log_sources(accounts, maxResults, nextToken, regions,
#'   sources)
#'
#' @param accounts The list of Amazon Web Services accounts for which log sources are
#' displayed.
#' @param maxResults The maximum number of accounts for which the log sources are displayed.
#' @param nextToken If nextToken is returned, there are more results available. You can
#' repeat the call using the returned token to retrieve the next page.
#' @param regions The list of Regions for which log sources are displayed.
#' @param sources The list of sources for which log sources are displayed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   sources = list(
#'     list(
#'       account = "string",
#'       region = "string",
#'       sources = list(
#'         list(
#'           awsLogSource = list(
#'             sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'             sourceVersion = "string"
#'           ),
#'           customLogSource = list(
#'             attributes = list(
#'               crawlerArn = "string",
#'               databaseArn = "string",
#'               tableArn = "string"
#'             ),
#'             provider = list(
#'               location = "string",
#'               roleArn = "string"
#'             ),
#'             sourceName = "string",
#'             sourceVersion = "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_log_sources(
#'   accounts = list(
#'     "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   regions = list(
#'     "string"
#'   ),
#'   sources = list(
#'     list(
#'       awsLogSource = list(
#'         sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'         sourceVersion = "string"
#'       ),
#'       customLogSource = list(
#'         attributes = list(
#'           crawlerArn = "string",
#'           databaseArn = "string",
#'           tableArn = "string"
#'         ),
#'         provider = list(
#'           location = "string",
#'           roleArn = "string"
#'         ),
#'         sourceName = "string",
#'         sourceVersion = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_list_log_sources
#'
#' @aliases securitylake_list_log_sources
securitylake_list_log_sources <- function(accounts = NULL, maxResults = NULL, nextToken = NULL, regions = NULL, sources = NULL) {
  op <- new_operation(
    name = "ListLogSources",
    http_method = "POST",
    http_path = "/v1/datalake/logsources/list",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "sources"),
    stream_api = FALSE
  )
  input <- .securitylake$list_log_sources_input(accounts = accounts, maxResults = maxResults, nextToken = nextToken, regions = regions, sources = sources)
  output <- .securitylake$list_log_sources_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$list_log_sources <- securitylake_list_log_sources

#' List all subscribers for the specific Amazon Security Lake account ID
#'
#' @description
#' List all subscribers for the specific Amazon Security Lake account ID.
#' You can retrieve a list of subscriptions associated with a specific
#' organization or Amazon Web Services account.
#'
#' @usage
#' securitylake_list_subscribers(maxResults, nextToken)
#'
#' @param maxResults The maximum number of accounts for which the configuration is displayed.
#' @param nextToken If nextToken is returned, there are more results available. You can
#' repeat the call using the returned token to retrieve the next page.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   subscribers = list(
#'     list(
#'       accessTypes = list(
#'         "LAKEFORMATION"|"S3"
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       resourceShareArn = "string",
#'       resourceShareName = "string",
#'       roleArn = "string",
#'       s3BucketArn = "string",
#'       sources = list(
#'         list(
#'           awsLogSource = list(
#'             sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'             sourceVersion = "string"
#'           ),
#'           customLogSource = list(
#'             attributes = list(
#'               crawlerArn = "string",
#'               databaseArn = "string",
#'               tableArn = "string"
#'             ),
#'             provider = list(
#'               location = "string",
#'               roleArn = "string"
#'             ),
#'             sourceName = "string",
#'             sourceVersion = "string"
#'           )
#'         )
#'       ),
#'       subscriberArn = "string",
#'       subscriberDescription = "string",
#'       subscriberEndpoint = "string",
#'       subscriberId = "string",
#'       subscriberIdentity = list(
#'         externalId = "string",
#'         principal = "string"
#'       ),
#'       subscriberName = "string",
#'       subscriberStatus = "ACTIVE"|"DEACTIVATED"|"PENDING"|"READY",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_subscribers(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_list_subscribers
#'
#' @aliases securitylake_list_subscribers
securitylake_list_subscribers <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListSubscribers",
    http_method = "GET",
    http_path = "/v1/subscribers",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "subscribers"),
    stream_api = FALSE
  )
  input <- .securitylake$list_subscribers_input(maxResults = maxResults, nextToken = nextToken)
  output <- .securitylake$list_subscribers_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$list_subscribers <- securitylake_list_subscribers

#' Retrieves the tags (keys and values) that are associated with an Amazon
#' Security Lake resource: a subscriber, or the data lake configuration for
#' your Amazon Web Services account in a particular Amazon Web Services
#' Region
#'
#' @description
#' Retrieves the tags (keys and values) that are associated with an Amazon
#' Security Lake resource: a subscriber, or the data lake configuration for
#' your Amazon Web Services account in a particular Amazon Web Services
#' Region.
#'
#' @usage
#' securitylake_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the Amazon Security Lake resource for
#' which you want to retrieve the tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_list_tags_for_resource
#'
#' @aliases securitylake_list_tags_for_resource
securitylake_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .securitylake$list_tags_for_resource_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$list_tags_for_resource <- securitylake_list_tags_for_resource

#' Designates the Amazon Security Lake delegated administrator account for
#' the organization
#'
#' @description
#' Designates the Amazon Security Lake delegated administrator account for
#' the organization. This API can only be called by the organization
#' management account. The organization management account cannot be the
#' delegated administrator account.
#'
#' @usage
#' securitylake_register_data_lake_delegated_administrator(accountId)
#'
#' @param accountId &#91;required&#93; The Amazon Web Services account ID of the Security Lake delegated
#' administrator.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$register_data_lake_delegated_administrator(
#'   accountId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_register_data_lake_delegated_administrator
#'
#' @aliases securitylake_register_data_lake_delegated_administrator
securitylake_register_data_lake_delegated_administrator <- function(accountId) {
  op <- new_operation(
    name = "RegisterDataLakeDelegatedAdministrator",
    http_method = "POST",
    http_path = "/v1/datalake/delegate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$register_data_lake_delegated_administrator_input(accountId = accountId)
  output <- .securitylake$register_data_lake_delegated_administrator_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$register_data_lake_delegated_administrator <- securitylake_register_data_lake_delegated_administrator

#' Adds or updates one or more tags that are associated with an Amazon
#' Security Lake resource: a subscriber, or the data lake configuration for
#' your Amazon Web Services account in a particular Amazon Web Services
#' Region
#'
#' @description
#' Adds or updates one or more tags that are associated with an Amazon
#' Security Lake resource: a subscriber, or the data lake configuration for
#' your Amazon Web Services account in a particular Amazon Web Services
#' Region. A *tag* is a label that you can define and associate with Amazon
#' Web Services resources. Each tag consists of a required *tag key* and an
#' associated *tag value*. A *tag key* is a general label that acts as a
#' category for a more specific tag value. A *tag value* acts as a
#' descriptor for a tag key. Tags can help you identify, categorize, and
#' manage resources in different ways, such as by owner, environment, or
#' other criteria. For more information, see [Tagging Amazon Security Lake
#' resources](https://docs.aws.amazon.com/security-lake/latest/userguide/tagging-resources.html)
#' in the *Amazon Security Lake User Guide*.
#'
#' @usage
#' securitylake_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the Amazon Security Lake resource to
#' add or update the tags for.
#' @param tags &#91;required&#93; An array of objects, one for each tag (key and value) to associate with
#' the Amazon Security Lake resource. For each tag, you must specify both a
#' tag key and a tag value. A tag value cannot be null, but it can be an
#' empty string.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_tag_resource
#'
#' @aliases securitylake_tag_resource
securitylake_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .securitylake$tag_resource_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$tag_resource <- securitylake_tag_resource

#' Removes one or more tags (keys and values) from an Amazon Security Lake
#' resource: a subscriber, or the data lake configuration for your Amazon
#' Web Services account in a particular Amazon Web Services Region
#'
#' @description
#' Removes one or more tags (keys and values) from an Amazon Security Lake
#' resource: a subscriber, or the data lake configuration for your Amazon
#' Web Services account in a particular Amazon Web Services Region.
#'
#' @usage
#' securitylake_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the Amazon Security Lake resource to
#' remove one or more tags from.
#' @param tagKeys &#91;required&#93; A list of one or more tag keys. For each value in the list, specify the
#' tag key for a tag to remove from the Amazon Security Lake resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_untag_resource
#'
#' @aliases securitylake_untag_resource
securitylake_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/v1/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .securitylake$untag_resource_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$untag_resource <- securitylake_untag_resource

#' Specifies where to store your security data and for how long
#'
#' @description
#' Specifies where to store your security data and for how long. You can
#' add a rollup Region to consolidate data from multiple Amazon Web
#' Services Regions.
#'
#' @usage
#' securitylake_update_data_lake(configurations, metaStoreManagerRoleArn)
#'
#' @param configurations &#91;required&#93; Specify the Region or Regions that will contribute data to the rollup
#' region.
#' @param metaStoreManagerRoleArn The Amazon Resource Name (ARN) used to create and update the Glue table.
#' This table contains partitions generated by the ingestion and
#' normalization of Amazon Web Services log sources and custom sources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   dataLakes = list(
#'     list(
#'       createStatus = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED",
#'       dataLakeArn = "string",
#'       encryptionConfiguration = list(
#'         kmsKeyId = "string"
#'       ),
#'       lifecycleConfiguration = list(
#'         expiration = list(
#'           days = 123
#'         ),
#'         transitions = list(
#'           list(
#'             days = 123,
#'             storageClass = "string"
#'           )
#'         )
#'       ),
#'       region = "string",
#'       replicationConfiguration = list(
#'         regions = list(
#'           "string"
#'         ),
#'         roleArn = "string"
#'       ),
#'       s3BucketArn = "string",
#'       updateStatus = list(
#'         exception = list(
#'           code = "string",
#'           reason = "string"
#'         ),
#'         requestId = "string",
#'         status = "INITIALIZED"|"PENDING"|"COMPLETED"|"FAILED"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_data_lake(
#'   configurations = list(
#'     list(
#'       encryptionConfiguration = list(
#'         kmsKeyId = "string"
#'       ),
#'       lifecycleConfiguration = list(
#'         expiration = list(
#'           days = 123
#'         ),
#'         transitions = list(
#'           list(
#'             days = 123,
#'             storageClass = "string"
#'           )
#'         )
#'       ),
#'       region = "string",
#'       replicationConfiguration = list(
#'         regions = list(
#'           "string"
#'         ),
#'         roleArn = "string"
#'       )
#'     )
#'   ),
#'   metaStoreManagerRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_update_data_lake
#'
#' @aliases securitylake_update_data_lake
securitylake_update_data_lake <- function(configurations, metaStoreManagerRoleArn = NULL) {
  op <- new_operation(
    name = "UpdateDataLake",
    http_method = "PUT",
    http_path = "/v1/datalake",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$update_data_lake_input(configurations = configurations, metaStoreManagerRoleArn = metaStoreManagerRoleArn)
  output <- .securitylake$update_data_lake_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$update_data_lake <- securitylake_update_data_lake

#' Updates the specified notification subscription in Amazon Security Lake
#' for the organization you specify
#'
#' @description
#' Updates the specified notification subscription in Amazon Security Lake
#' for the organization you specify.
#'
#' @usage
#' securitylake_update_data_lake_exception_subscription(
#'   exceptionTimeToLive, notificationEndpoint, subscriptionProtocol)
#'
#' @param exceptionTimeToLive The time-to-live (TTL) for the exception message to remain.
#' @param notificationEndpoint &#91;required&#93; The account that is subscribed to receive exception notifications.
#' @param subscriptionProtocol &#91;required&#93; The subscription protocol to which exception messages are posted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_data_lake_exception_subscription(
#'   exceptionTimeToLive = 123,
#'   notificationEndpoint = "string",
#'   subscriptionProtocol = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_update_data_lake_exception_subscription
#'
#' @aliases securitylake_update_data_lake_exception_subscription
securitylake_update_data_lake_exception_subscription <- function(exceptionTimeToLive = NULL, notificationEndpoint, subscriptionProtocol) {
  op <- new_operation(
    name = "UpdateDataLakeExceptionSubscription",
    http_method = "PUT",
    http_path = "/v1/datalake/exceptions/subscription",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$update_data_lake_exception_subscription_input(exceptionTimeToLive = exceptionTimeToLive, notificationEndpoint = notificationEndpoint, subscriptionProtocol = subscriptionProtocol)
  output <- .securitylake$update_data_lake_exception_subscription_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$update_data_lake_exception_subscription <- securitylake_update_data_lake_exception_subscription

#' Updates an existing subscription for the given Amazon Security Lake
#' account ID
#'
#' @description
#' Updates an existing subscription for the given Amazon Security Lake
#' account ID. You can update a subscriber by changing the sources that the
#' subscriber consumes data from.
#'
#' @usage
#' securitylake_update_subscriber(sources, subscriberDescription,
#'   subscriberId, subscriberIdentity, subscriberName)
#'
#' @param sources The supported Amazon Web Services from which logs and events are
#' collected. For the list of supported Amazon Web Services, see the
#' [Amazon Security Lake User
#' Guide](https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html).
#' @param subscriberDescription The description of the Security Lake account subscriber.
#' @param subscriberId &#91;required&#93; A value created by Security Lake that uniquely identifies your
#' subscription.
#' @param subscriberIdentity The AWS identity used to access your data.
#' @param subscriberName The name of the Security Lake account subscriber.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriber = list(
#'     accessTypes = list(
#'       "LAKEFORMATION"|"S3"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     resourceShareArn = "string",
#'     resourceShareName = "string",
#'     roleArn = "string",
#'     s3BucketArn = "string",
#'     sources = list(
#'       list(
#'         awsLogSource = list(
#'           sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'           sourceVersion = "string"
#'         ),
#'         customLogSource = list(
#'           attributes = list(
#'             crawlerArn = "string",
#'             databaseArn = "string",
#'             tableArn = "string"
#'           ),
#'           provider = list(
#'             location = "string",
#'             roleArn = "string"
#'           ),
#'           sourceName = "string",
#'           sourceVersion = "string"
#'         )
#'       )
#'     ),
#'     subscriberArn = "string",
#'     subscriberDescription = "string",
#'     subscriberEndpoint = "string",
#'     subscriberId = "string",
#'     subscriberIdentity = list(
#'       externalId = "string",
#'       principal = "string"
#'     ),
#'     subscriberName = "string",
#'     subscriberStatus = "ACTIVE"|"DEACTIVATED"|"PENDING"|"READY",
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subscriber(
#'   sources = list(
#'     list(
#'       awsLogSource = list(
#'         sourceName = "ROUTE53"|"VPC_FLOW"|"SH_FINDINGS"|"CLOUD_TRAIL_MGMT"|"LAMBDA_EXECUTION"|"S3_DATA"|"EKS_AUDIT"|"WAF",
#'         sourceVersion = "string"
#'       ),
#'       customLogSource = list(
#'         attributes = list(
#'           crawlerArn = "string",
#'           databaseArn = "string",
#'           tableArn = "string"
#'         ),
#'         provider = list(
#'           location = "string",
#'           roleArn = "string"
#'         ),
#'         sourceName = "string",
#'         sourceVersion = "string"
#'       )
#'     )
#'   ),
#'   subscriberDescription = "string",
#'   subscriberId = "string",
#'   subscriberIdentity = list(
#'     externalId = "string",
#'     principal = "string"
#'   ),
#'   subscriberName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_update_subscriber
#'
#' @aliases securitylake_update_subscriber
securitylake_update_subscriber <- function(sources = NULL, subscriberDescription = NULL, subscriberId, subscriberIdentity = NULL, subscriberName = NULL) {
  op <- new_operation(
    name = "UpdateSubscriber",
    http_method = "PUT",
    http_path = "/v1/subscribers/{subscriberId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$update_subscriber_input(sources = sources, subscriberDescription = subscriberDescription, subscriberId = subscriberId, subscriberIdentity = subscriberIdentity, subscriberName = subscriberName)
  output <- .securitylake$update_subscriber_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$update_subscriber <- securitylake_update_subscriber

#' Updates an existing notification method for the subscription (SQS or
#' HTTPs endpoint) or switches the notification subscription endpoint for a
#' subscriber
#'
#' @description
#' Updates an existing notification method for the subscription (SQS or
#' HTTPs endpoint) or switches the notification subscription endpoint for a
#' subscriber.
#'
#' @usage
#' securitylake_update_subscriber_notification(configuration, subscriberId)
#'
#' @param configuration &#91;required&#93; The configuration for subscriber notification.
#' @param subscriberId &#91;required&#93; The subscription ID for which the subscription notification is
#' specified.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   subscriberEndpoint = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subscriber_notification(
#'   configuration = list(
#'     httpsNotificationConfiguration = list(
#'       authorizationApiKeyName = "string",
#'       authorizationApiKeyValue = "string",
#'       endpoint = "string",
#'       httpMethod = "POST"|"PUT",
#'       targetRoleArn = "string"
#'     ),
#'     sqsNotificationConfiguration = list()
#'   ),
#'   subscriberId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname securitylake_update_subscriber_notification
#'
#' @aliases securitylake_update_subscriber_notification
securitylake_update_subscriber_notification <- function(configuration, subscriberId) {
  op <- new_operation(
    name = "UpdateSubscriberNotification",
    http_method = "PUT",
    http_path = "/v1/subscribers/{subscriberId}/notification",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .securitylake$update_subscriber_notification_input(configuration = configuration, subscriberId = subscriberId)
  output <- .securitylake$update_subscriber_notification_output()
  config <- get_config()
  svc <- .securitylake$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.securitylake$operations$update_subscriber_notification <- securitylake_update_subscriber_notification

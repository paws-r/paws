# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include drs_service.R
NULL

#' Create an extended source server in the target Account based on the
#' source server in staging account
#'
#' @description
#' Create an extended source server in the target Account based on the
#' source server in staging account.
#'
#' @usage
#' drs_create_extended_source_server(sourceServerArn, tags)
#'
#' @param sourceServerArn &#91;required&#93; This defines the ARN of the source server in staging Account based on
#' which you want to create an extended source server.
#' @param tags A list of tags associated with the extended source server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceServer = list(
#'     arn = "string",
#'     dataReplicationInfo = list(
#'       dataReplicationError = list(
#'         error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'         rawError = "string"
#'       ),
#'       dataReplicationInitiation = list(
#'         nextAttemptDateTime = "string",
#'         startDateTime = "string",
#'         steps = list(
#'           list(
#'             name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'             status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'           )
#'         )
#'       ),
#'       dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'       etaDateTime = "string",
#'       lagDuration = "string",
#'       replicatedDisks = list(
#'         list(
#'           backloggedStorageBytes = 123,
#'           deviceName = "string",
#'           replicatedStorageBytes = 123,
#'           rescannedStorageBytes = 123,
#'           totalStorageBytes = 123
#'         )
#'       )
#'     ),
#'     lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'     lifeCycle = list(
#'       addedToServiceDateTime = "string",
#'       elapsedReplicationDuration = "string",
#'       firstByteDateTime = "string",
#'       lastLaunch = list(
#'         initiated = list(
#'           apiCallDateTime = "string",
#'           jobID = "string",
#'           type = "RECOVERY"|"DRILL"
#'         )
#'       ),
#'       lastSeenByServiceDateTime = "string"
#'     ),
#'     recoveryInstanceId = "string",
#'     sourceProperties = list(
#'       cpus = list(
#'         list(
#'           cores = 123,
#'           modelName = "string"
#'         )
#'       ),
#'       disks = list(
#'         list(
#'           bytes = 123,
#'           deviceName = "string"
#'         )
#'       ),
#'       identificationHints = list(
#'         awsInstanceID = "string",
#'         fqdn = "string",
#'         hostname = "string",
#'         vmWareUuid = "string"
#'       ),
#'       lastUpdatedDateTime = "string",
#'       networkInterfaces = list(
#'         list(
#'           ips = list(
#'             "string"
#'           ),
#'           isPrimary = TRUE|FALSE,
#'           macAddress = "string"
#'         )
#'       ),
#'       os = list(
#'         fullString = "string"
#'       ),
#'       ramBytes = 123,
#'       recommendedInstanceType = "string"
#'     ),
#'     sourceServerID = "string",
#'     stagingArea = list(
#'       errorMessage = "string",
#'       stagingAccountID = "string",
#'       stagingSourceServerArn = "string",
#'       status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_extended_source_server(
#'   sourceServerArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_extended_source_server
drs_create_extended_source_server <- function(sourceServerArn, tags = NULL) {
  op <- new_operation(
    name = "CreateExtendedSourceServer",
    http_method = "POST",
    http_path = "/CreateExtendedSourceServer",
    paginator = list()
  )
  input <- .drs$create_extended_source_server_input(sourceServerArn = sourceServerArn, tags = tags)
  output <- .drs$create_extended_source_server_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_extended_source_server <- drs_create_extended_source_server

#' Creates a new ReplicationConfigurationTemplate
#'
#' @description
#' Creates a new ReplicationConfigurationTemplate.
#'
#' @usage
#' drs_create_replication_configuration_template(
#'   associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP,
#'   dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption,
#'   ebsEncryptionKeyArn, pitPolicy, replicationServerInstanceType,
#'   replicationServersSecurityGroupsIDs, stagingAreaSubnetId,
#'   stagingAreaTags, tags, useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup &#91;required&#93; Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration Template.
#' @param bandwidthThrottling &#91;required&#93; Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP &#91;required&#93; Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting &#91;required&#93; The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType &#91;required&#93; The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption &#91;required&#93; The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param pitPolicy &#91;required&#93; The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicationServerInstanceType &#91;required&#93; The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs &#91;required&#93; The security group IDs that will be used by the replication server.
#' @param stagingAreaSubnetId &#91;required&#93; The subnet to be used by the replication staging area.
#' @param stagingAreaTags &#91;required&#93; A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param tags A set of tags to be associated with the Replication Configuration
#' Template resource.
#' @param useDedicatedReplicationServer &#91;required&#93; Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_replication_configuration_template(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_replication_configuration_template
drs_create_replication_configuration_template <- function(associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP, dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn = NULL, pitPolicy, replicationServerInstanceType, replicationServersSecurityGroupsIDs, stagingAreaSubnetId, stagingAreaTags, tags = NULL, useDedicatedReplicationServer) {
  op <- new_operation(
    name = "CreateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/CreateReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .drs$create_replication_configuration_template_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, pitPolicy = pitPolicy, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, tags = tags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$create_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_replication_configuration_template <- drs_create_replication_configuration_template

#' Deletes a single Job by ID
#'
#' @description
#' Deletes a single Job by ID.
#'
#' @usage
#' drs_delete_job(jobID)
#'
#' @param jobID &#91;required&#93; The ID of the Job to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   jobID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_job
drs_delete_job <- function(jobID) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "POST",
    http_path = "/DeleteJob",
    paginator = list()
  )
  input <- .drs$delete_job_input(jobID = jobID)
  output <- .drs$delete_job_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_job <- drs_delete_job

#' Deletes a single Recovery Instance by ID
#'
#' @description
#' Deletes a single Recovery Instance by ID. This deletes the Recovery
#' Instance resource from Elastic Disaster Recovery. The Recovery Instance
#' must be disconnected first in order to delete it.
#'
#' @usage
#' drs_delete_recovery_instance(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_recovery_instance(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_recovery_instance
drs_delete_recovery_instance <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "DeleteRecoveryInstance",
    http_method = "POST",
    http_path = "/DeleteRecoveryInstance",
    paginator = list()
  )
  input <- .drs$delete_recovery_instance_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$delete_recovery_instance_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_recovery_instance <- drs_delete_recovery_instance

#' Deletes a single Replication Configuration Template by ID
#'
#' @description
#' Deletes a single Replication Configuration Template by ID
#'
#' @usage
#' drs_delete_replication_configuration_template(
#'   replicationConfigurationTemplateID)
#'
#' @param replicationConfigurationTemplateID &#91;required&#93; The ID of the Replication Configuration Template to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_replication_configuration_template(
#'   replicationConfigurationTemplateID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_replication_configuration_template
drs_delete_replication_configuration_template <- function(replicationConfigurationTemplateID) {
  op <- new_operation(
    name = "DeleteReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/DeleteReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .drs$delete_replication_configuration_template_input(replicationConfigurationTemplateID = replicationConfigurationTemplateID)
  output <- .drs$delete_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_replication_configuration_template <- drs_delete_replication_configuration_template

#' Deletes a single Source Server by ID
#'
#' @description
#' Deletes a single Source Server by ID. The Source Server must be
#' disconnected first.
#'
#' @usage
#' drs_delete_source_server(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_source_server(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_source_server
drs_delete_source_server <- function(sourceServerID) {
  op <- new_operation(
    name = "DeleteSourceServer",
    http_method = "POST",
    http_path = "/DeleteSourceServer",
    paginator = list()
  )
  input <- .drs$delete_source_server_input(sourceServerID = sourceServerID)
  output <- .drs$delete_source_server_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_source_server <- drs_delete_source_server

#' Retrieves a detailed Job log with pagination
#'
#' @description
#' Retrieves a detailed Job log with pagination.
#'
#' @usage
#' drs_describe_job_log_items(jobID, maxResults, nextToken)
#'
#' @param jobID &#91;required&#93; The ID of the Job for which Job log items will be retrieved.
#' @param maxResults Maximum number of Job log items to retrieve.
#' @param nextToken The token of the next Job log items to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       event = "JOB_START"|"SERVER_SKIPPED"|"CLEANUP_START"|"CLEANUP_END"|"CLEANUP_FAIL"|"SNAPSHOT_START"|"SNAPSHOT_END"|"SNAPSHOT_FAIL"|"USING_PREVIOUS_SNAPSHOT"|"USING_PREVIOUS_SNAPSHOT_FAILED"|"CONVERSION_START"|"CONVERSION_END"|"CONVERSION_FAIL"|"LAUNCH_START"|"LAUNCH_FAILED"|"JOB_CANCEL"|"JOB_END",
#'       eventData = list(
#'         conversionProperties = list(
#'           dataTimestamp = "string",
#'           forceUefi = TRUE|FALSE,
#'           rootVolumeName = "string",
#'           volumeToConversionMap = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           volumeToVolumeSize = list(
#'             123
#'           )
#'         ),
#'         conversionServerID = "string",
#'         rawError = "string",
#'         sourceServerID = "string",
#'         targetInstanceID = "string"
#'       ),
#'       logDateTime = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_log_items(
#'   jobID = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_job_log_items
drs_describe_job_log_items <- function(jobID, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobLogItems",
    http_method = "POST",
    http_path = "/DescribeJobLogItems",
    paginator = list()
  )
  input <- .drs$describe_job_log_items_input(jobID = jobID, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_job_log_items_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_job_log_items <- drs_describe_job_log_items

#' Returns a list of Jobs
#'
#' @description
#' Returns a list of Jobs. Use the JobsID and fromDate and toDate filters
#' to limit which jobs are returned. The response is sorted by
#' creationDataTime - latest date first. Jobs are created by the
#' StartRecovery, TerminateRecoveryInstances and StartFailbackLaunch APIs.
#' Jobs are also created by DiagnosticLaunch and
#' TerminateDiagnosticInstances, which are APIs available only to
#' *Support* and only used in response to relevant support tickets.
#'
#' @usage
#' drs_describe_jobs(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Jobs.
#' @param maxResults Maximum number of Jobs to retrieve.
#' @param nextToken The token of the next Job to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       creationDateTime = "string",
#'       endDateTime = "string",
#'       initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT",
#'       jobID = "string",
#'       participatingServers = list(
#'         list(
#'           launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'           recoveryInstanceID = "string",
#'           sourceServerID = "string"
#'         )
#'       ),
#'       status = "PENDING"|"STARTED"|"COMPLETED",
#'       tags = list(
#'         "string"
#'       ),
#'       type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_jobs(
#'   filters = list(
#'     fromDate = "string",
#'     jobIDs = list(
#'       "string"
#'     ),
#'     toDate = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_jobs
drs_describe_jobs <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobs",
    http_method = "POST",
    http_path = "/DescribeJobs",
    paginator = list()
  )
  input <- .drs$describe_jobs_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_jobs_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_jobs <- drs_describe_jobs

#' Lists all Recovery Instances or multiple Recovery Instances by ID
#'
#' @description
#' Lists all Recovery Instances or multiple Recovery Instances by ID.
#'
#' @usage
#' drs_describe_recovery_instances(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Recovery Instances.
#' @param maxResults Maximum number of Recovery Instances to retrieve.
#' @param nextToken The token of the next Recovery Instance to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       dataReplicationInfo = list(
#'         dataReplicationError = list(
#'           error = "AGENT_NOT_SEEN"|"FAILBACK_CLIENT_NOT_SEEN"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"|"FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"|"FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"|"FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION",
#'           rawError = "string"
#'         ),
#'         dataReplicationInitiation = list(
#'           startDateTime = "string",
#'           steps = list(
#'             list(
#'               name = "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE"|"COMPLETE_VOLUME_MAPPING"|"ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"|"DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"|"CONFIGURE_REPLICATION_SOFTWARE"|"PAIR_AGENT_WITH_REPLICATION_SOFTWARE"|"ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION",
#'               status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'             )
#'           )
#'         ),
#'         dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'         etaDateTime = "string",
#'         lagDuration = "string",
#'         replicatedDisks = list(
#'           list(
#'             backloggedStorageBytes = 123,
#'             deviceName = "string",
#'             replicatedStorageBytes = 123,
#'             rescannedStorageBytes = 123,
#'             totalStorageBytes = 123
#'           )
#'         )
#'       ),
#'       ec2InstanceID = "string",
#'       ec2InstanceState = "PENDING"|"RUNNING"|"STOPPING"|"STOPPED"|"SHUTTING-DOWN"|"TERMINATED"|"NOT_FOUND",
#'       failback = list(
#'         agentLastSeenByServiceDateTime = "string",
#'         elapsedReplicationDuration = "string",
#'         failbackClientID = "string",
#'         failbackClientLastSeenByServiceDateTime = "string",
#'         failbackInitiationTime = "string",
#'         failbackJobID = "string",
#'         failbackToOriginalServer = TRUE|FALSE,
#'         firstByteDateTime = "string",
#'         state = "FAILBACK_NOT_STARTED"|"FAILBACK_IN_PROGRESS"|"FAILBACK_READY_FOR_LAUNCH"|"FAILBACK_COMPLETED"|"FAILBACK_ERROR"
#'       ),
#'       isDrill = TRUE|FALSE,
#'       jobID = "string",
#'       pointInTimeSnapshotDateTime = "string",
#'       recoveryInstanceID = "string",
#'       recoveryInstanceProperties = list(
#'         cpus = list(
#'           list(
#'             cores = 123,
#'             modelName = "string"
#'           )
#'         ),
#'         disks = list(
#'           list(
#'             bytes = 123,
#'             ebsVolumeID = "string",
#'             internalDeviceName = "string"
#'           )
#'         ),
#'         identificationHints = list(
#'           awsInstanceID = "string",
#'           fqdn = "string",
#'           hostname = "string",
#'           vmWareUuid = "string"
#'         ),
#'         lastUpdatedDateTime = "string",
#'         networkInterfaces = list(
#'           list(
#'             ips = list(
#'               "string"
#'             ),
#'             isPrimary = TRUE|FALSE,
#'             macAddress = "string"
#'           )
#'         ),
#'         os = list(
#'           fullString = "string"
#'         ),
#'         ramBytes = 123
#'       ),
#'       sourceServerID = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_recovery_instances(
#'   filters = list(
#'     recoveryInstanceIDs = list(
#'       "string"
#'     ),
#'     sourceServerIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_recovery_instances
drs_describe_recovery_instances <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeRecoveryInstances",
    http_method = "POST",
    http_path = "/DescribeRecoveryInstances",
    paginator = list()
  )
  input <- .drs$describe_recovery_instances_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_recovery_instances_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_recovery_instances <- drs_describe_recovery_instances

#' Lists all Recovery Snapshots for a single Source Server
#'
#' @description
#' Lists all Recovery Snapshots for a single Source Server.
#'
#' @usage
#' drs_describe_recovery_snapshots(filters, maxResults, nextToken, order,
#'   sourceServerID)
#'
#' @param filters A set of filters by which to return Recovery Snapshots.
#' @param maxResults Maximum number of Recovery Snapshots to retrieve.
#' @param nextToken The token of the next Recovery Snapshot to retrieve.
#' @param order The sorted ordering by which to return Recovery Snapshots.
#' @param sourceServerID &#91;required&#93; Filter Recovery Snapshots by Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       ebsSnapshots = list(
#'         "string"
#'       ),
#'       expectedTimestamp = "string",
#'       snapshotID = "string",
#'       sourceServerID = "string",
#'       timestamp = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_recovery_snapshots(
#'   filters = list(
#'     fromDateTime = "string",
#'     toDateTime = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   order = "ASC"|"DESC",
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_recovery_snapshots
drs_describe_recovery_snapshots <- function(filters = NULL, maxResults = NULL, nextToken = NULL, order = NULL, sourceServerID) {
  op <- new_operation(
    name = "DescribeRecoverySnapshots",
    http_method = "POST",
    http_path = "/DescribeRecoverySnapshots",
    paginator = list()
  )
  input <- .drs$describe_recovery_snapshots_input(filters = filters, maxResults = maxResults, nextToken = nextToken, order = order, sourceServerID = sourceServerID)
  output <- .drs$describe_recovery_snapshots_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_recovery_snapshots <- drs_describe_recovery_snapshots

#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs
#'
#' @description
#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs.
#'
#' @usage
#' drs_describe_replication_configuration_templates(maxResults, nextToken,
#'   replicationConfigurationTemplateIDs)
#'
#' @param maxResults Maximum number of Replication Configuration Templates to retrieve.
#' @param nextToken The token of the next Replication Configuration Template to retrieve.
#' @param replicationConfigurationTemplateIDs The IDs of the Replication Configuration Templates to retrieve. An empty
#' list means all Replication Configuration Templates.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       associateDefaultSecurityGroup = TRUE|FALSE,
#'       bandwidthThrottling = 123,
#'       createPublicIP = TRUE|FALSE,
#'       dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'       defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'       ebsEncryption = "DEFAULT"|"CUSTOM",
#'       ebsEncryptionKeyArn = "string",
#'       pitPolicy = list(
#'         list(
#'           enabled = TRUE|FALSE,
#'           interval = 123,
#'           retentionDuration = 123,
#'           ruleID = 123,
#'           units = "MINUTE"|"HOUR"|"DAY"
#'         )
#'       ),
#'       replicationConfigurationTemplateID = "string",
#'       replicationServerInstanceType = "string",
#'       replicationServersSecurityGroupsIDs = list(
#'         "string"
#'       ),
#'       stagingAreaSubnetId = "string",
#'       stagingAreaTags = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       useDedicatedReplicationServer = TRUE|FALSE
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_replication_configuration_templates(
#'   maxResults = 123,
#'   nextToken = "string",
#'   replicationConfigurationTemplateIDs = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_replication_configuration_templates
drs_describe_replication_configuration_templates <- function(maxResults = NULL, nextToken = NULL, replicationConfigurationTemplateIDs = NULL) {
  op <- new_operation(
    name = "DescribeReplicationConfigurationTemplates",
    http_method = "POST",
    http_path = "/DescribeReplicationConfigurationTemplates",
    paginator = list()
  )
  input <- .drs$describe_replication_configuration_templates_input(maxResults = maxResults, nextToken = nextToken, replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs)
  output <- .drs$describe_replication_configuration_templates_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_replication_configuration_templates <- drs_describe_replication_configuration_templates

#' Lists all Source Servers or multiple Source Servers filtered by ID
#'
#' @description
#' Lists all Source Servers or multiple Source Servers filtered by ID.
#'
#' @usage
#' drs_describe_source_servers(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Source Servers.
#' @param maxResults Maximum number of Source Servers to retrieve.
#' @param nextToken The token of the next Source Server to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       dataReplicationInfo = list(
#'         dataReplicationError = list(
#'           error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'           rawError = "string"
#'         ),
#'         dataReplicationInitiation = list(
#'           nextAttemptDateTime = "string",
#'           startDateTime = "string",
#'           steps = list(
#'             list(
#'               name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'               status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'             )
#'           )
#'         ),
#'         dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'         etaDateTime = "string",
#'         lagDuration = "string",
#'         replicatedDisks = list(
#'           list(
#'             backloggedStorageBytes = 123,
#'             deviceName = "string",
#'             replicatedStorageBytes = 123,
#'             rescannedStorageBytes = 123,
#'             totalStorageBytes = 123
#'           )
#'         )
#'       ),
#'       lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'       lifeCycle = list(
#'         addedToServiceDateTime = "string",
#'         elapsedReplicationDuration = "string",
#'         firstByteDateTime = "string",
#'         lastLaunch = list(
#'           initiated = list(
#'             apiCallDateTime = "string",
#'             jobID = "string",
#'             type = "RECOVERY"|"DRILL"
#'           )
#'         ),
#'         lastSeenByServiceDateTime = "string"
#'       ),
#'       recoveryInstanceId = "string",
#'       sourceProperties = list(
#'         cpus = list(
#'           list(
#'             cores = 123,
#'             modelName = "string"
#'           )
#'         ),
#'         disks = list(
#'           list(
#'             bytes = 123,
#'             deviceName = "string"
#'           )
#'         ),
#'         identificationHints = list(
#'           awsInstanceID = "string",
#'           fqdn = "string",
#'           hostname = "string",
#'           vmWareUuid = "string"
#'         ),
#'         lastUpdatedDateTime = "string",
#'         networkInterfaces = list(
#'           list(
#'             ips = list(
#'               "string"
#'             ),
#'             isPrimary = TRUE|FALSE,
#'             macAddress = "string"
#'           )
#'         ),
#'         os = list(
#'           fullString = "string"
#'         ),
#'         ramBytes = 123,
#'         recommendedInstanceType = "string"
#'       ),
#'       sourceServerID = "string",
#'       stagingArea = list(
#'         errorMessage = "string",
#'         stagingAccountID = "string",
#'         stagingSourceServerArn = "string",
#'         status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_source_servers(
#'   filters = list(
#'     hardwareId = "string",
#'     sourceServerIDs = list(
#'       "string"
#'     ),
#'     stagingAccountIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_source_servers
drs_describe_source_servers <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeSourceServers",
    http_method = "POST",
    http_path = "/DescribeSourceServers",
    paginator = list()
  )
  input <- .drs$describe_source_servers_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_source_servers_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_source_servers <- drs_describe_source_servers

#' Disconnect a Recovery Instance from Elastic Disaster Recovery
#'
#' @description
#' Disconnect a Recovery Instance from Elastic Disaster Recovery. Data
#' replication is stopped immediately. All AWS resources created by Elastic
#' Disaster Recovery for enabling the replication of the Recovery Instance
#' will be terminated / deleted within 90 minutes. If the agent on the
#' Recovery Instance has not been prevented from communicating with the
#' Elastic Disaster Recovery service, then it will receive a command to
#' uninstall itself (within approximately 10 minutes). The following
#' properties of the Recovery Instance will be changed immediately:
#' dataReplicationInfo.dataReplicationState will be set to DISCONNECTED;
#' The totalStorageBytes property for each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will
#' be nullified.
#'
#' @usage
#' drs_disconnect_recovery_instance(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance to disconnect.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disconnect_recovery_instance(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_disconnect_recovery_instance
drs_disconnect_recovery_instance <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "DisconnectRecoveryInstance",
    http_method = "POST",
    http_path = "/DisconnectRecoveryInstance",
    paginator = list()
  )
  input <- .drs$disconnect_recovery_instance_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$disconnect_recovery_instance_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$disconnect_recovery_instance <- drs_disconnect_recovery_instance

#' Disconnects a specific Source Server from Elastic Disaster Recovery
#'
#' @description
#' Disconnects a specific Source Server from Elastic Disaster Recovery.
#' Data replication is stopped immediately. All AWS resources created by
#' Elastic Disaster Recovery for enabling the replication of the Source
#' Server will be terminated / deleted within 90 minutes. You cannot
#' disconnect a Source Server if it has a Recovery Instance. If the agent
#' on the Source Server has not been prevented from communicating with the
#' Elastic Disaster Recovery service, then it will receive a command to
#' uninstall itself (within approximately 10 minutes). The following
#' properties of the SourceServer will be changed immediately:
#' dataReplicationInfo.dataReplicationState will be set to DISCONNECTED;
#' The totalStorageBytes property for each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will
#' be nullified.
#'
#' @usage
#' drs_disconnect_source_server(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to disconnect.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastLaunch = list(
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string",
#'         type = "RECOVERY"|"DRILL"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string"
#'   ),
#'   recoveryInstanceId = "string",
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingArea = list(
#'     errorMessage = "string",
#'     stagingAccountID = "string",
#'     stagingSourceServerArn = "string",
#'     status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disconnect_source_server(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_disconnect_source_server
drs_disconnect_source_server <- function(sourceServerID) {
  op <- new_operation(
    name = "DisconnectSourceServer",
    http_method = "POST",
    http_path = "/DisconnectSourceServer",
    paginator = list()
  )
  input <- .drs$disconnect_source_server_input(sourceServerID = sourceServerID)
  output <- .drs$disconnect_source_server_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$disconnect_source_server <- drs_disconnect_source_server

#' Lists all Failback ReplicationConfigurations, filtered by Recovery
#' Instance ID
#'
#' @description
#' Lists all Failback ReplicationConfigurations, filtered by Recovery
#' Instance ID.
#'
#' @usage
#' drs_get_failback_replication_configuration(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance whose failback replication configuration
#' should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   bandwidthThrottling = 123,
#'   name = "string",
#'   recoveryInstanceID = "string",
#'   usePrivateIP = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_failback_replication_configuration(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_failback_replication_configuration
drs_get_failback_replication_configuration <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "GetFailbackReplicationConfiguration",
    http_method = "POST",
    http_path = "/GetFailbackReplicationConfiguration",
    paginator = list()
  )
  input <- .drs$get_failback_replication_configuration_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$get_failback_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_failback_replication_configuration <- drs_get_failback_replication_configuration

#' Gets a LaunchConfiguration, filtered by Source Server IDs
#'
#' @description
#' Gets a LaunchConfiguration, filtered by Source Server IDs.
#'
#' @usage
#' drs_get_launch_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server that we want to retrieve a Launch
#' Configuration for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_launch_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_launch_configuration
drs_get_launch_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetLaunchConfiguration",
    http_method = "POST",
    http_path = "/GetLaunchConfiguration",
    paginator = list()
  )
  input <- .drs$get_launch_configuration_input(sourceServerID = sourceServerID)
  output <- .drs$get_launch_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_launch_configuration <- drs_get_launch_configuration

#' Gets a ReplicationConfiguration, filtered by Source Server ID
#'
#' @description
#' Gets a ReplicationConfiguration, filtered by Source Server ID.
#'
#' @usage
#' drs_get_replication_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Serve for this Replication Configuration.r
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_replication_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_replication_configuration
drs_get_replication_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetReplicationConfiguration",
    http_method = "POST",
    http_path = "/GetReplicationConfiguration",
    paginator = list()
  )
  input <- .drs$get_replication_configuration_input(sourceServerID = sourceServerID)
  output <- .drs$get_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_replication_configuration <- drs_get_replication_configuration

#' Initialize Elastic Disaster Recovery
#'
#' @description
#' Initialize Elastic Disaster Recovery.
#'
#' @usage
#' drs_initialize_service()
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$initialize_service()
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_initialize_service
drs_initialize_service <- function() {
  op <- new_operation(
    name = "InitializeService",
    http_method = "POST",
    http_path = "/InitializeService",
    paginator = list()
  )
  input <- .drs$initialize_service_input()
  output <- .drs$initialize_service_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$initialize_service <- drs_initialize_service

#' Returns a list of source servers on a staging account that are
#' extensible, which means that: a
#'
#' @description
#' Returns a list of source servers on a staging account that are
#' extensible, which means that: a. The source server is not already
#' extended into this Account. b. The source server on the Account weâ€™re
#' reading from is not an extension of another source server.
#'
#' @usage
#' drs_list_extensible_source_servers(maxResults, nextToken,
#'   stagingAccountID)
#'
#' @param maxResults The maximum number of extensible source servers to retrieve.
#' @param nextToken The token of the next extensible source server to retrieve.
#' @param stagingAccountID &#91;required&#93; The Id of the staging Account to retrieve extensible source servers
#' from.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       hostname = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_extensible_source_servers(
#'   maxResults = 123,
#'   nextToken = "string",
#'   stagingAccountID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_extensible_source_servers
drs_list_extensible_source_servers <- function(maxResults = NULL, nextToken = NULL, stagingAccountID) {
  op <- new_operation(
    name = "ListExtensibleSourceServers",
    http_method = "POST",
    http_path = "/ListExtensibleSourceServers",
    paginator = list()
  )
  input <- .drs$list_extensible_source_servers_input(maxResults = maxResults, nextToken = nextToken, stagingAccountID = stagingAccountID)
  output <- .drs$list_extensible_source_servers_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_extensible_source_servers <- drs_list_extensible_source_servers

#' Returns an array of staging accounts for existing extended source
#' servers
#'
#' @description
#' Returns an array of staging accounts for existing extended source
#' servers.
#'
#' @usage
#' drs_list_staging_accounts(maxResults, nextToken)
#'
#' @param maxResults The maximum number of staging Accounts to retrieve.
#' @param nextToken The token of the next staging Account to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accounts = list(
#'     list(
#'       accountID = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_staging_accounts(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_staging_accounts
drs_list_staging_accounts <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListStagingAccounts",
    http_method = "GET",
    http_path = "/ListStagingAccounts",
    paginator = list()
  )
  input <- .drs$list_staging_accounts_input(maxResults = maxResults, nextToken = nextToken)
  output <- .drs$list_staging_accounts_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_staging_accounts <- drs_list_staging_accounts

#' List all tags for your Elastic Disaster Recovery resources
#'
#' @description
#' List all tags for your Elastic Disaster Recovery resources.
#'
#' @usage
#' drs_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource whose tags should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_tags_for_resource
drs_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .drs$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .drs$list_tags_for_resource_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_tags_for_resource <- drs_list_tags_for_resource

#' Causes the data replication initiation sequence to begin immediately
#' upon next Handshake for the specified Source Server ID, regardless of
#' when the previous initiation started
#'
#' @description
#' Causes the data replication initiation sequence to begin immediately
#' upon next Handshake for the specified Source Server ID, regardless of
#' when the previous initiation started. This command will work only if the
#' Source Server is stalled or is in a DISCONNECTED or STOPPED state.
#'
#' @usage
#' drs_retry_data_replication(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server whose data replication should be retried.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastLaunch = list(
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string",
#'         type = "RECOVERY"|"DRILL"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string"
#'   ),
#'   recoveryInstanceId = "string",
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingArea = list(
#'     errorMessage = "string",
#'     stagingAccountID = "string",
#'     stagingSourceServerArn = "string",
#'     status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retry_data_replication(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_retry_data_replication
drs_retry_data_replication <- function(sourceServerID) {
  op <- new_operation(
    name = "RetryDataReplication",
    http_method = "POST",
    http_path = "/RetryDataReplication",
    paginator = list()
  )
  input <- .drs$retry_data_replication_input(sourceServerID = sourceServerID)
  output <- .drs$retry_data_replication_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$retry_data_replication <- drs_retry_data_replication

#' Initiates a Job for launching the machine that is being failed back to
#' from the specified Recovery Instance
#'
#' @description
#' Initiates a Job for launching the machine that is being failed back to
#' from the specified Recovery Instance. This will run conversion on the
#' failback client and will reboot your machine, thus completing the
#' failback process.
#'
#' @usage
#' drs_start_failback_launch(recoveryInstanceIDs, tags)
#'
#' @param recoveryInstanceIDs &#91;required&#93; The IDs of the Recovery Instance whose failback launch we want to
#' request.
#' @param tags The tags to be associated with the failback launch Job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_failback_launch(
#'   recoveryInstanceIDs = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_failback_launch
drs_start_failback_launch <- function(recoveryInstanceIDs, tags = NULL) {
  op <- new_operation(
    name = "StartFailbackLaunch",
    http_method = "POST",
    http_path = "/StartFailbackLaunch",
    paginator = list()
  )
  input <- .drs$start_failback_launch_input(recoveryInstanceIDs = recoveryInstanceIDs, tags = tags)
  output <- .drs$start_failback_launch_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_failback_launch <- drs_start_failback_launch

#' Launches Recovery Instances for the specified Source Servers
#'
#' @description
#' Launches Recovery Instances for the specified Source Servers. For each
#' Source Server you may choose a point in time snapshot to launch from, or
#' use an on demand snapshot.
#'
#' @usage
#' drs_start_recovery(isDrill, sourceServers, tags)
#'
#' @param isDrill Whether this Source Server Recovery operation is a drill or not.
#' @param sourceServers &#91;required&#93; The Source Servers that we want to start a Recovery Job for.
#' @param tags The tags to be associated with the Recovery Job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_recovery(
#'   isDrill = TRUE|FALSE,
#'   sourceServers = list(
#'     list(
#'       recoverySnapshotID = "string",
#'       sourceServerID = "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_recovery
drs_start_recovery <- function(isDrill = NULL, sourceServers, tags = NULL) {
  op <- new_operation(
    name = "StartRecovery",
    http_method = "POST",
    http_path = "/StartRecovery",
    paginator = list()
  )
  input <- .drs$start_recovery_input(isDrill = isDrill, sourceServers = sourceServers, tags = tags)
  output <- .drs$start_recovery_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_recovery <- drs_start_recovery

#' Stops the failback process for a specified Recovery Instance
#'
#' @description
#' Stops the failback process for a specified Recovery Instance. This
#' changes the Failback State of the Recovery Instance back to
#' FAILBACK_NOT_STARTED.
#'
#' @usage
#' drs_stop_failback(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance we want to stop failback for.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_failback(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_stop_failback
drs_stop_failback <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "StopFailback",
    http_method = "POST",
    http_path = "/StopFailback",
    paginator = list()
  )
  input <- .drs$stop_failback_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$stop_failback_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$stop_failback <- drs_stop_failback

#' Adds or overwrites only the specified tags for the specified Elastic
#' Disaster Recovery resource or resources
#'
#' @description
#' Adds or overwrites only the specified tags for the specified Elastic
#' Disaster Recovery resource or resources. When you specify an existing
#' tag key, the value is overwritten with the new value. Each resource can
#' have a maximum of 50 tags. Each tag consists of a key and optional
#' value.
#'
#' @usage
#' drs_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be added or updated.
#' @param tags &#91;required&#93; Array of tags to be added or updated.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_tag_resource
drs_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .drs$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .drs$tag_resource_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$tag_resource <- drs_tag_resource

#' Initiates a Job for terminating the EC2 resources associated with the
#' specified Recovery Instances, and then will delete the Recovery
#' Instances from the Elastic Disaster Recovery service
#'
#' @description
#' Initiates a Job for terminating the EC2 resources associated with the
#' specified Recovery Instances, and then will delete the Recovery
#' Instances from the Elastic Disaster Recovery service.
#'
#' @usage
#' drs_terminate_recovery_instances(recoveryInstanceIDs)
#'
#' @param recoveryInstanceIDs &#91;required&#93; The IDs of the Recovery Instances that should be terminated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$terminate_recovery_instances(
#'   recoveryInstanceIDs = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_terminate_recovery_instances
drs_terminate_recovery_instances <- function(recoveryInstanceIDs) {
  op <- new_operation(
    name = "TerminateRecoveryInstances",
    http_method = "POST",
    http_path = "/TerminateRecoveryInstances",
    paginator = list()
  )
  input <- .drs$terminate_recovery_instances_input(recoveryInstanceIDs = recoveryInstanceIDs)
  output <- .drs$terminate_recovery_instances_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$terminate_recovery_instances <- drs_terminate_recovery_instances

#' Deletes the specified set of tags from the specified set of Elastic
#' Disaster Recovery resources
#'
#' @description
#' Deletes the specified set of tags from the specified set of Elastic
#' Disaster Recovery resources.
#'
#' @usage
#' drs_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be removed.
#' @param tagKeys &#91;required&#93; Array of tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_untag_resource
drs_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .drs$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .drs$untag_resource_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$untag_resource <- drs_untag_resource

#' Allows you to update the failback replication configuration of a
#' Recovery Instance by ID
#'
#' @description
#' Allows you to update the failback replication configuration of a
#' Recovery Instance by ID.
#'
#' @usage
#' drs_update_failback_replication_configuration(bandwidthThrottling, name,
#'   recoveryInstanceID, usePrivateIP)
#'
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Recovery Instance in Mbps.
#' @param name The name of the Failback Replication Configuration.
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance.
#' @param usePrivateIP Whether to use Private IP for the failback replication of the Recovery
#' Instance.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_failback_replication_configuration(
#'   bandwidthThrottling = 123,
#'   name = "string",
#'   recoveryInstanceID = "string",
#'   usePrivateIP = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_failback_replication_configuration
drs_update_failback_replication_configuration <- function(bandwidthThrottling = NULL, name = NULL, recoveryInstanceID, usePrivateIP = NULL) {
  op <- new_operation(
    name = "UpdateFailbackReplicationConfiguration",
    http_method = "POST",
    http_path = "/UpdateFailbackReplicationConfiguration",
    paginator = list()
  )
  input <- .drs$update_failback_replication_configuration_input(bandwidthThrottling = bandwidthThrottling, name = name, recoveryInstanceID = recoveryInstanceID, usePrivateIP = usePrivateIP)
  output <- .drs$update_failback_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_failback_replication_configuration <- drs_update_failback_replication_configuration

#' Updates a LaunchConfiguration by Source Server ID
#'
#' @description
#' Updates a LaunchConfiguration by Source Server ID.
#'
#' @usage
#' drs_update_launch_configuration(copyPrivateIp, copyTags,
#'   launchDisposition, licensing, name, sourceServerID,
#'   targetInstanceTypeRightSizingMethod)
#'
#' @param copyPrivateIp Whether we should copy the Private IP of the Source Server to the
#' Recovery Instance.
#' @param copyTags Whether we want to copy the tags of the Source Server to the EC2 machine
#' of the Recovery Instance.
#' @param launchDisposition The state of the Recovery Instance in EC2 after the recovery operation.
#' @param licensing The licensing configuration to be used for this launch configuration.
#' @param name The name of the launch configuration.
#' @param sourceServerID &#91;required&#93; The ID of the Source Server that we want to retrieve a Launch
#' Configuration for.
#' @param targetInstanceTypeRightSizingMethod Whether Elastic Disaster Recovery should try to automatically choose the
#' instance type that best matches the OS, CPU, and RAM of your Source
#' Server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_launch_configuration(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_launch_configuration
drs_update_launch_configuration <- function(copyPrivateIp = NULL, copyTags = NULL, launchDisposition = NULL, licensing = NULL, name = NULL, sourceServerID, targetInstanceTypeRightSizingMethod = NULL) {
  op <- new_operation(
    name = "UpdateLaunchConfiguration",
    http_method = "POST",
    http_path = "/UpdateLaunchConfiguration",
    paginator = list()
  )
  input <- .drs$update_launch_configuration_input(copyPrivateIp = copyPrivateIp, copyTags = copyTags, launchDisposition = launchDisposition, licensing = licensing, name = name, sourceServerID = sourceServerID, targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod)
  output <- .drs$update_launch_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_launch_configuration <- drs_update_launch_configuration

#' Allows you to update a ReplicationConfiguration by Source Server ID
#'
#' @description
#' Allows you to update a ReplicationConfiguration by Source Server ID.
#'
#' @usage
#' drs_update_replication_configuration(associateDefaultSecurityGroup,
#'   bandwidthThrottling, createPublicIP, dataPlaneRouting,
#'   defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn, name,
#'   pitPolicy, replicatedDisks, replicationServerInstanceType,
#'   replicationServersSecurityGroupsIDs, sourceServerID,
#'   stagingAreaSubnetId, stagingAreaTags, useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration.
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param name The name of the Replication Configuration.
#' @param pitPolicy The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicatedDisks The configuration of the disks of the Source Server to be replicated.
#' @param replicationServerInstanceType The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs The security group IDs that will be used by the replication server.
#' @param sourceServerID &#91;required&#93; The ID of the Source Server for this Replication Configuration.
#' @param stagingAreaSubnetId The subnet to be used by the replication staging area.
#' @param stagingAreaTags A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param useDedicatedReplicationServer Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_replication_configuration
drs_update_replication_configuration <- function(associateDefaultSecurityGroup = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, name = NULL, pitPolicy = NULL, replicatedDisks = NULL, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, sourceServerID, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfiguration",
    http_method = "POST",
    http_path = "/UpdateReplicationConfiguration",
    paginator = list()
  )
  input <- .drs$update_replication_configuration_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, name = name, pitPolicy = pitPolicy, replicatedDisks = replicatedDisks, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, sourceServerID = sourceServerID, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$update_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_replication_configuration <- drs_update_replication_configuration

#' Updates a ReplicationConfigurationTemplate by ID
#'
#' @description
#' Updates a ReplicationConfigurationTemplate by ID.
#'
#' @usage
#' drs_update_replication_configuration_template(arn,
#'   associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP,
#'   dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption,
#'   ebsEncryptionKeyArn, pitPolicy, replicationConfigurationTemplateID,
#'   replicationServerInstanceType, replicationServersSecurityGroupsIDs,
#'   stagingAreaSubnetId, stagingAreaTags, useDedicatedReplicationServer)
#'
#' @param arn The Replication Configuration Template ARN.
#' @param associateDefaultSecurityGroup Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration Template.
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param pitPolicy The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicationConfigurationTemplateID &#91;required&#93; The Replication Configuration Template ID.
#' @param replicationServerInstanceType The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs The security group IDs that will be used by the replication server.
#' @param stagingAreaSubnetId The subnet to be used by the replication staging area.
#' @param stagingAreaTags A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param useDedicatedReplicationServer Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration_template(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_replication_configuration_template
drs_update_replication_configuration_template <- function(arn = NULL, associateDefaultSecurityGroup = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, pitPolicy = NULL, replicationConfigurationTemplateID, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/UpdateReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .drs$update_replication_configuration_template_input(arn = arn, associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, pitPolicy = pitPolicy, replicationConfigurationTemplateID = replicationConfigurationTemplateID, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$update_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_replication_configuration_template <- drs_update_replication_configuration_template

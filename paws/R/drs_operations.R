# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include drs_service.R
NULL

#' Associate a Source Network to an existing CloudFormation Stack and
#' modify launch templates to use this network
#'
#' @description
#' Associate a Source Network to an existing CloudFormation Stack and
#' modify launch templates to use this network. Can be used for reverting
#' to previously deployed CloudFormation stacks.
#'
#' @usage
#' drs_associate_source_network_stack(cfnStackName, sourceNetworkID)
#'
#' @param cfnStackName &#91;required&#93; CloudFormation template to associate with a Source Network.
#' @param sourceNetworkID &#91;required&#93; The Source Network ID to associate with CloudFormation template.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'     jobID = "string",
#'     participatingResources = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         participatingResourceID = list(
#'           sourceNetworkID = "string"
#'         )
#'       )
#'     ),
#'     participatingServers = list(
#'       list(
#'         launchActionsStatus = list(
#'           runs = list(
#'             list(
#'               action = list(
#'                 actionCode = "string",
#'                 actionId = "string",
#'                 actionVersion = "string",
#'                 active = TRUE|FALSE,
#'                 category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                 description = "string",
#'                 name = "string",
#'                 optional = TRUE|FALSE,
#'                 order = 123,
#'                 parameters = list(
#'                   list(
#'                     type = "SSM_STORE"|"DYNAMIC",
#'                     value = "string"
#'                   )
#'                 ),
#'                 type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'               ),
#'               failureReason = "string",
#'               runId = "string",
#'               status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'             )
#'           ),
#'           ssmAgentDiscoveryDatetime = "string"
#'         ),
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_source_network_stack(
#'   cfnStackName = "string",
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_associate_source_network_stack
#'
#' @aliases drs_associate_source_network_stack
drs_associate_source_network_stack <- function(cfnStackName, sourceNetworkID) {
  op <- new_operation(
    name = "AssociateSourceNetworkStack",
    http_method = "POST",
    http_path = "/AssociateSourceNetworkStack",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$associate_source_network_stack_input(cfnStackName = cfnStackName, sourceNetworkID = sourceNetworkID)
  output <- .drs$associate_source_network_stack_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$associate_source_network_stack <- drs_associate_source_network_stack

#' Create an extended source server in the target Account based on the
#' source server in staging account
#'
#' @description
#' Create an extended source server in the target Account based on the
#' source server in staging account.
#'
#' @usage
#' drs_create_extended_source_server(sourceServerArn, tags)
#'
#' @param sourceServerArn &#91;required&#93; This defines the ARN of the source server in staging Account based on
#' which you want to create an extended source server.
#' @param tags A list of tags associated with the extended source server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceServer = list(
#'     agentVersion = "string",
#'     arn = "string",
#'     dataReplicationInfo = list(
#'       dataReplicationError = list(
#'         error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'         rawError = "string"
#'       ),
#'       dataReplicationInitiation = list(
#'         nextAttemptDateTime = "string",
#'         startDateTime = "string",
#'         steps = list(
#'           list(
#'             name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'             status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'           )
#'         )
#'       ),
#'       dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'       etaDateTime = "string",
#'       lagDuration = "string",
#'       replicatedDisks = list(
#'         list(
#'           backloggedStorageBytes = 123,
#'           deviceName = "string",
#'           replicatedStorageBytes = 123,
#'           rescannedStorageBytes = 123,
#'           totalStorageBytes = 123,
#'           volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'         )
#'       ),
#'       stagingAvailabilityZone = "string",
#'       stagingOutpostArn = "string"
#'     ),
#'     lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'     lifeCycle = list(
#'       addedToServiceDateTime = "string",
#'       elapsedReplicationDuration = "string",
#'       firstByteDateTime = "string",
#'       lastLaunch = list(
#'         initiated = list(
#'           apiCallDateTime = "string",
#'           jobID = "string",
#'           type = "RECOVERY"|"DRILL"
#'         ),
#'         status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'       ),
#'       lastSeenByServiceDateTime = "string"
#'     ),
#'     recoveryInstanceId = "string",
#'     replicationDirection = "FAILOVER"|"FAILBACK",
#'     reversedDirectionSourceServerArn = "string",
#'     sourceCloudProperties = list(
#'       originAccountID = "string",
#'       originAvailabilityZone = "string",
#'       originRegion = "string",
#'       sourceOutpostArn = "string"
#'     ),
#'     sourceNetworkID = "string",
#'     sourceProperties = list(
#'       cpus = list(
#'         list(
#'           cores = 123,
#'           modelName = "string"
#'         )
#'       ),
#'       disks = list(
#'         list(
#'           bytes = 123,
#'           deviceName = "string"
#'         )
#'       ),
#'       identificationHints = list(
#'         awsInstanceID = "string",
#'         fqdn = "string",
#'         hostname = "string",
#'         vmWareUuid = "string"
#'       ),
#'       lastUpdatedDateTime = "string",
#'       networkInterfaces = list(
#'         list(
#'           ips = list(
#'             "string"
#'           ),
#'           isPrimary = TRUE|FALSE,
#'           macAddress = "string"
#'         )
#'       ),
#'       os = list(
#'         fullString = "string"
#'       ),
#'       ramBytes = 123,
#'       recommendedInstanceType = "string",
#'       supportsNitroInstances = TRUE|FALSE
#'     ),
#'     sourceServerID = "string",
#'     stagingArea = list(
#'       errorMessage = "string",
#'       stagingAccountID = "string",
#'       stagingSourceServerArn = "string",
#'       status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_extended_source_server(
#'   sourceServerArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_extended_source_server
#'
#' @aliases drs_create_extended_source_server
drs_create_extended_source_server <- function(sourceServerArn, tags = NULL) {
  op <- new_operation(
    name = "CreateExtendedSourceServer",
    http_method = "POST",
    http_path = "/CreateExtendedSourceServer",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$create_extended_source_server_input(sourceServerArn = sourceServerArn, tags = tags)
  output <- .drs$create_extended_source_server_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_extended_source_server <- drs_create_extended_source_server

#' Creates a new Launch Configuration Template
#'
#' @description
#' Creates a new Launch Configuration Template.
#'
#' @usage
#' drs_create_launch_configuration_template(copyPrivateIp, copyTags,
#'   exportBucketArn, launchDisposition, launchIntoSourceInstance, licensing,
#'   postLaunchEnabled, tags, targetInstanceTypeRightSizingMethod)
#'
#' @param copyPrivateIp Copy private IP.
#' @param copyTags Copy tags.
#' @param exportBucketArn S3 bucket ARN to export Source Network templates.
#' @param launchDisposition Launch disposition.
#' @param launchIntoSourceInstance DRS will set the 'launch into instance ID' of any source server when
#' performing a drill, recovery or failback to the previous region or
#' availability zone, using the instance ID of the source instance.
#' @param licensing Licensing.
#' @param postLaunchEnabled Whether we want to activate post-launch actions.
#' @param tags Request to associate tags during creation of a Launch Configuration
#' Template.
#' @param targetInstanceTypeRightSizingMethod Target instance type right-sizing method.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   launchConfigurationTemplate = list(
#'     arn = "string",
#'     copyPrivateIp = TRUE|FALSE,
#'     copyTags = TRUE|FALSE,
#'     exportBucketArn = "string",
#'     launchConfigurationTemplateID = "string",
#'     launchDisposition = "STOPPED"|"STARTED",
#'     launchIntoSourceInstance = TRUE|FALSE,
#'     licensing = list(
#'       osByol = TRUE|FALSE
#'     ),
#'     postLaunchEnabled = TRUE|FALSE,
#'     tags = list(
#'       "string"
#'     ),
#'     targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_launch_configuration_template(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   exportBucketArn = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   launchIntoSourceInstance = TRUE|FALSE,
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   postLaunchEnabled = TRUE|FALSE,
#'   tags = list(
#'     "string"
#'   ),
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_launch_configuration_template
#'
#' @aliases drs_create_launch_configuration_template
drs_create_launch_configuration_template <- function(copyPrivateIp = NULL, copyTags = NULL, exportBucketArn = NULL, launchDisposition = NULL, launchIntoSourceInstance = NULL, licensing = NULL, postLaunchEnabled = NULL, tags = NULL, targetInstanceTypeRightSizingMethod = NULL) {
  op <- new_operation(
    name = "CreateLaunchConfigurationTemplate",
    http_method = "POST",
    http_path = "/CreateLaunchConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$create_launch_configuration_template_input(copyPrivateIp = copyPrivateIp, copyTags = copyTags, exportBucketArn = exportBucketArn, launchDisposition = launchDisposition, launchIntoSourceInstance = launchIntoSourceInstance, licensing = licensing, postLaunchEnabled = postLaunchEnabled, tags = tags, targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod)
  output <- .drs$create_launch_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_launch_configuration_template <- drs_create_launch_configuration_template

#' Creates a new ReplicationConfigurationTemplate
#'
#' @description
#' Creates a new ReplicationConfigurationTemplate.
#'
#' @usage
#' drs_create_replication_configuration_template(
#'   associateDefaultSecurityGroup, autoReplicateNewDisks,
#'   bandwidthThrottling, createPublicIP, dataPlaneRouting,
#'   defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn,
#'   pitPolicy, replicationServerInstanceType,
#'   replicationServersSecurityGroupsIDs, stagingAreaSubnetId,
#'   stagingAreaTags, tags, useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup &#91;required&#93; Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration Template.
#' @param autoReplicateNewDisks Whether to allow the AWS replication agent to automatically replicate
#' newly added disks.
#' @param bandwidthThrottling &#91;required&#93; Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP &#91;required&#93; Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting &#91;required&#93; The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType &#91;required&#93; The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption &#91;required&#93; The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param pitPolicy &#91;required&#93; The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicationServerInstanceType &#91;required&#93; The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs &#91;required&#93; The security group IDs that will be used by the replication server.
#' @param stagingAreaSubnetId &#91;required&#93; The subnet to be used by the replication staging area.
#' @param stagingAreaTags &#91;required&#93; A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param tags A set of tags to be associated with the Replication Configuration
#' Template resource.
#' @param useDedicatedReplicationServer &#91;required&#93; Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_replication_configuration_template(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_replication_configuration_template
#'
#' @aliases drs_create_replication_configuration_template
drs_create_replication_configuration_template <- function(associateDefaultSecurityGroup, autoReplicateNewDisks = NULL, bandwidthThrottling, createPublicIP, dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn = NULL, pitPolicy, replicationServerInstanceType, replicationServersSecurityGroupsIDs, stagingAreaSubnetId, stagingAreaTags, tags = NULL, useDedicatedReplicationServer) {
  op <- new_operation(
    name = "CreateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/CreateReplicationConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$create_replication_configuration_template_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, autoReplicateNewDisks = autoReplicateNewDisks, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, pitPolicy = pitPolicy, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, tags = tags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$create_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_replication_configuration_template <- drs_create_replication_configuration_template

#' Create a new Source Network resource for a provided VPC ID
#'
#' @description
#' Create a new Source Network resource for a provided VPC ID.
#'
#' @usage
#' drs_create_source_network(originAccountID, originRegion, tags, vpcID)
#'
#' @param originAccountID &#91;required&#93; Account containing the VPC to protect.
#' @param originRegion &#91;required&#93; Region containing the VPC to protect.
#' @param tags A set of tags to be associated with the Source Network resource.
#' @param vpcID &#91;required&#93; Which VPC ID to protect.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_source_network(
#'   originAccountID = "string",
#'   originRegion = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   vpcID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_create_source_network
#'
#' @aliases drs_create_source_network
drs_create_source_network <- function(originAccountID, originRegion, tags = NULL, vpcID) {
  op <- new_operation(
    name = "CreateSourceNetwork",
    http_method = "POST",
    http_path = "/CreateSourceNetwork",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$create_source_network_input(originAccountID = originAccountID, originRegion = originRegion, tags = tags, vpcID = vpcID)
  output <- .drs$create_source_network_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$create_source_network <- drs_create_source_network

#' Deletes a single Job by ID
#'
#' @description
#' Deletes a single Job by ID.
#'
#' @usage
#' drs_delete_job(jobID)
#'
#' @param jobID &#91;required&#93; The ID of the Job to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   jobID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_job
#'
#' @aliases drs_delete_job
drs_delete_job <- function(jobID) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "POST",
    http_path = "/DeleteJob",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_job_input(jobID = jobID)
  output <- .drs$delete_job_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_job <- drs_delete_job

#' Deletes a resource launch action
#'
#' @description
#' Deletes a resource launch action.
#'
#' @usage
#' drs_delete_launch_action(actionId, resourceId)
#'
#' @param actionId &#91;required&#93; 
#' @param resourceId &#91;required&#93; 
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_launch_action(
#'   actionId = "string",
#'   resourceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_launch_action
#'
#' @aliases drs_delete_launch_action
drs_delete_launch_action <- function(actionId, resourceId) {
  op <- new_operation(
    name = "DeleteLaunchAction",
    http_method = "POST",
    http_path = "/DeleteLaunchAction",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_launch_action_input(actionId = actionId, resourceId = resourceId)
  output <- .drs$delete_launch_action_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_launch_action <- drs_delete_launch_action

#' Deletes a single Launch Configuration Template by ID
#'
#' @description
#' Deletes a single Launch Configuration Template by ID.
#'
#' @usage
#' drs_delete_launch_configuration_template(launchConfigurationTemplateID)
#'
#' @param launchConfigurationTemplateID &#91;required&#93; The ID of the Launch Configuration Template to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_launch_configuration_template(
#'   launchConfigurationTemplateID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_launch_configuration_template
#'
#' @aliases drs_delete_launch_configuration_template
drs_delete_launch_configuration_template <- function(launchConfigurationTemplateID) {
  op <- new_operation(
    name = "DeleteLaunchConfigurationTemplate",
    http_method = "POST",
    http_path = "/DeleteLaunchConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_launch_configuration_template_input(launchConfigurationTemplateID = launchConfigurationTemplateID)
  output <- .drs$delete_launch_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_launch_configuration_template <- drs_delete_launch_configuration_template

#' Deletes a single Recovery Instance by ID
#'
#' @description
#' Deletes a single Recovery Instance by ID. This deletes the Recovery
#' Instance resource from Elastic Disaster Recovery. The Recovery Instance
#' must be disconnected first in order to delete it.
#'
#' @usage
#' drs_delete_recovery_instance(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_recovery_instance(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_recovery_instance
#'
#' @aliases drs_delete_recovery_instance
drs_delete_recovery_instance <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "DeleteRecoveryInstance",
    http_method = "POST",
    http_path = "/DeleteRecoveryInstance",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_recovery_instance_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$delete_recovery_instance_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_recovery_instance <- drs_delete_recovery_instance

#' Deletes a single Replication Configuration Template by ID
#'
#' @description
#' Deletes a single Replication Configuration Template by ID
#'
#' @usage
#' drs_delete_replication_configuration_template(
#'   replicationConfigurationTemplateID)
#'
#' @param replicationConfigurationTemplateID &#91;required&#93; The ID of the Replication Configuration Template to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_replication_configuration_template(
#'   replicationConfigurationTemplateID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_replication_configuration_template
#'
#' @aliases drs_delete_replication_configuration_template
drs_delete_replication_configuration_template <- function(replicationConfigurationTemplateID) {
  op <- new_operation(
    name = "DeleteReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/DeleteReplicationConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_replication_configuration_template_input(replicationConfigurationTemplateID = replicationConfigurationTemplateID)
  output <- .drs$delete_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_replication_configuration_template <- drs_delete_replication_configuration_template

#' Delete Source Network resource
#'
#' @description
#' Delete Source Network resource.
#'
#' @usage
#' drs_delete_source_network(sourceNetworkID)
#'
#' @param sourceNetworkID &#91;required&#93; ID of the Source Network to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_source_network(
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_source_network
#'
#' @aliases drs_delete_source_network
drs_delete_source_network <- function(sourceNetworkID) {
  op <- new_operation(
    name = "DeleteSourceNetwork",
    http_method = "POST",
    http_path = "/DeleteSourceNetwork",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_source_network_input(sourceNetworkID = sourceNetworkID)
  output <- .drs$delete_source_network_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_source_network <- drs_delete_source_network

#' Deletes a single Source Server by ID
#'
#' @description
#' Deletes a single Source Server by ID. The Source Server must be
#' disconnected first.
#'
#' @usage
#' drs_delete_source_server(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_source_server(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_delete_source_server
#'
#' @aliases drs_delete_source_server
drs_delete_source_server <- function(sourceServerID) {
  op <- new_operation(
    name = "DeleteSourceServer",
    http_method = "POST",
    http_path = "/DeleteSourceServer",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$delete_source_server_input(sourceServerID = sourceServerID)
  output <- .drs$delete_source_server_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$delete_source_server <- drs_delete_source_server

#' Retrieves a detailed Job log with pagination
#'
#' @description
#' Retrieves a detailed Job log with pagination.
#'
#' @usage
#' drs_describe_job_log_items(jobID, maxResults, nextToken)
#'
#' @param jobID &#91;required&#93; The ID of the Job for which Job log items will be retrieved.
#' @param maxResults Maximum number of Job log items to retrieve.
#' @param nextToken The token of the next Job log items to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       event = "JOB_START"|"SERVER_SKIPPED"|"CLEANUP_START"|"CLEANUP_END"|"CLEANUP_FAIL"|"SNAPSHOT_START"|"SNAPSHOT_END"|"SNAPSHOT_FAIL"|"USING_PREVIOUS_SNAPSHOT"|"USING_PREVIOUS_SNAPSHOT_FAILED"|"CONVERSION_START"|"CONVERSION_END"|"CONVERSION_FAIL"|"LAUNCH_START"|"LAUNCH_FAILED"|"JOB_CANCEL"|"JOB_END"|"DEPLOY_NETWORK_CONFIGURATION_START"|"DEPLOY_NETWORK_CONFIGURATION_END"|"DEPLOY_NETWORK_CONFIGURATION_FAILED"|"UPDATE_NETWORK_CONFIGURATION_START"|"UPDATE_NETWORK_CONFIGURATION_END"|"UPDATE_NETWORK_CONFIGURATION_FAILED"|"UPDATE_LAUNCH_TEMPLATE_START"|"UPDATE_LAUNCH_TEMPLATE_END"|"UPDATE_LAUNCH_TEMPLATE_FAILED"|"NETWORK_RECOVERY_FAIL",
#'       eventData = list(
#'         conversionProperties = list(
#'           dataTimestamp = "string",
#'           forceUefi = TRUE|FALSE,
#'           rootVolumeName = "string",
#'           volumeToConversionMap = list(
#'             list(
#'               "string"
#'             )
#'           ),
#'           volumeToProductCodes = list(
#'             list(
#'               list(
#'                 productCodeId = "string",
#'                 productCodeMode = "ENABLED"|"DISABLED"
#'               )
#'             )
#'           ),
#'           volumeToVolumeSize = list(
#'             123
#'           )
#'         ),
#'         conversionServerID = "string",
#'         eventResourceData = list(
#'           sourceNetworkData = list(
#'             sourceNetworkID = "string",
#'             sourceVpc = "string",
#'             stackName = "string",
#'             targetVpc = "string"
#'           )
#'         ),
#'         rawError = "string",
#'         sourceServerID = "string",
#'         targetInstanceID = "string"
#'       ),
#'       logDateTime = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_log_items(
#'   jobID = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_job_log_items
#'
#' @aliases drs_describe_job_log_items
drs_describe_job_log_items <- function(jobID, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobLogItems",
    http_method = "POST",
    http_path = "/DescribeJobLogItems",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_job_log_items_input(jobID = jobID, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_job_log_items_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_job_log_items <- drs_describe_job_log_items

#' Returns a list of Jobs
#'
#' @description
#' Returns a list of Jobs. Use the JobsID and fromDate and toDate filters
#' to limit which jobs are returned. The response is sorted by
#' creationDataTime - latest date first. Jobs are created by the
#' StartRecovery, TerminateRecoveryInstances and StartFailbackLaunch APIs.
#' Jobs are also created by DiagnosticLaunch and
#' TerminateDiagnosticInstances, which are APIs available only to
#' *Support* and only used in response to relevant support tickets.
#'
#' @usage
#' drs_describe_jobs(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Jobs.
#' @param maxResults Maximum number of Jobs to retrieve.
#' @param nextToken The token of the next Job to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       creationDateTime = "string",
#'       endDateTime = "string",
#'       initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'       jobID = "string",
#'       participatingResources = list(
#'         list(
#'           launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'           participatingResourceID = list(
#'             sourceNetworkID = "string"
#'           )
#'         )
#'       ),
#'       participatingServers = list(
#'         list(
#'           launchActionsStatus = list(
#'             runs = list(
#'               list(
#'                 action = list(
#'                   actionCode = "string",
#'                   actionId = "string",
#'                   actionVersion = "string",
#'                   active = TRUE|FALSE,
#'                   category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                   description = "string",
#'                   name = "string",
#'                   optional = TRUE|FALSE,
#'                   order = 123,
#'                   parameters = list(
#'                     list(
#'                       type = "SSM_STORE"|"DYNAMIC",
#'                       value = "string"
#'                     )
#'                   ),
#'                   type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'                 ),
#'                 failureReason = "string",
#'                 runId = "string",
#'                 status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'               )
#'             ),
#'             ssmAgentDiscoveryDatetime = "string"
#'           ),
#'           launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'           recoveryInstanceID = "string",
#'           sourceServerID = "string"
#'         )
#'       ),
#'       status = "PENDING"|"STARTED"|"COMPLETED",
#'       tags = list(
#'         "string"
#'       ),
#'       type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_jobs(
#'   filters = list(
#'     fromDate = "string",
#'     jobIDs = list(
#'       "string"
#'     ),
#'     toDate = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_jobs
#'
#' @aliases drs_describe_jobs
drs_describe_jobs <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobs",
    http_method = "POST",
    http_path = "/DescribeJobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_jobs_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_jobs_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_jobs <- drs_describe_jobs

#' Lists all Launch Configuration Templates, filtered by Launch
#' Configuration Template IDs
#'
#' @description
#' Lists all Launch Configuration Templates, filtered by Launch
#' Configuration Template IDs
#'
#' @usage
#' drs_describe_launch_configuration_templates(
#'   launchConfigurationTemplateIDs, maxResults, nextToken)
#'
#' @param launchConfigurationTemplateIDs Request to filter Launch Configuration Templates list by Launch
#' Configuration Template ID.
#' @param maxResults Maximum results to be returned in DescribeLaunchConfigurationTemplates.
#' @param nextToken The token of the next Launch Configuration Template to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       copyPrivateIp = TRUE|FALSE,
#'       copyTags = TRUE|FALSE,
#'       exportBucketArn = "string",
#'       launchConfigurationTemplateID = "string",
#'       launchDisposition = "STOPPED"|"STARTED",
#'       launchIntoSourceInstance = TRUE|FALSE,
#'       licensing = list(
#'         osByol = TRUE|FALSE
#'       ),
#'       postLaunchEnabled = TRUE|FALSE,
#'       tags = list(
#'         "string"
#'       ),
#'       targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_launch_configuration_templates(
#'   launchConfigurationTemplateIDs = list(
#'     "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_launch_configuration_templates
#'
#' @aliases drs_describe_launch_configuration_templates
drs_describe_launch_configuration_templates <- function(launchConfigurationTemplateIDs = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeLaunchConfigurationTemplates",
    http_method = "POST",
    http_path = "/DescribeLaunchConfigurationTemplates",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_launch_configuration_templates_input(launchConfigurationTemplateIDs = launchConfigurationTemplateIDs, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_launch_configuration_templates_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_launch_configuration_templates <- drs_describe_launch_configuration_templates

#' Lists all Recovery Instances or multiple Recovery Instances by ID
#'
#' @description
#' Lists all Recovery Instances or multiple Recovery Instances by ID.
#'
#' @usage
#' drs_describe_recovery_instances(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Recovery Instances.
#' @param maxResults Maximum number of Recovery Instances to retrieve.
#' @param nextToken The token of the next Recovery Instance to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       agentVersion = "string",
#'       arn = "string",
#'       dataReplicationInfo = list(
#'         dataReplicationError = list(
#'           error = "AGENT_NOT_SEEN"|"FAILBACK_CLIENT_NOT_SEEN"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"|"FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"|"FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"|"FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"|"FAILED_GETTING_REPLICATION_STATE"|"SNAPSHOTS_FAILURE"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'           rawError = "string"
#'         ),
#'         dataReplicationInitiation = list(
#'           startDateTime = "string",
#'           steps = list(
#'             list(
#'               name = "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE"|"COMPLETE_VOLUME_MAPPING"|"ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"|"DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"|"CONFIGURE_REPLICATION_SOFTWARE"|"PAIR_AGENT_WITH_REPLICATION_SOFTWARE"|"ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"|"WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'               status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'             )
#'           )
#'         ),
#'         dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED"|"REPLICATION_STATE_NOT_AVAILABLE"|"NOT_STARTED",
#'         etaDateTime = "string",
#'         lagDuration = "string",
#'         replicatedDisks = list(
#'           list(
#'             backloggedStorageBytes = 123,
#'             deviceName = "string",
#'             replicatedStorageBytes = 123,
#'             rescannedStorageBytes = 123,
#'             totalStorageBytes = 123
#'           )
#'         ),
#'         stagingAvailabilityZone = "string",
#'         stagingOutpostArn = "string"
#'       ),
#'       ec2InstanceID = "string",
#'       ec2InstanceState = "PENDING"|"RUNNING"|"STOPPING"|"STOPPED"|"SHUTTING-DOWN"|"TERMINATED"|"NOT_FOUND",
#'       failback = list(
#'         agentLastSeenByServiceDateTime = "string",
#'         elapsedReplicationDuration = "string",
#'         failbackClientID = "string",
#'         failbackClientLastSeenByServiceDateTime = "string",
#'         failbackInitiationTime = "string",
#'         failbackJobID = "string",
#'         failbackLaunchType = "RECOVERY"|"DRILL",
#'         failbackToOriginalServer = TRUE|FALSE,
#'         firstByteDateTime = "string",
#'         state = "FAILBACK_NOT_STARTED"|"FAILBACK_IN_PROGRESS"|"FAILBACK_READY_FOR_LAUNCH"|"FAILBACK_COMPLETED"|"FAILBACK_ERROR"|"FAILBACK_NOT_READY_FOR_LAUNCH"|"FAILBACK_LAUNCH_STATE_NOT_AVAILABLE"
#'       ),
#'       isDrill = TRUE|FALSE,
#'       jobID = "string",
#'       originAvailabilityZone = "string",
#'       originEnvironment = "ON_PREMISES"|"AWS",
#'       pointInTimeSnapshotDateTime = "string",
#'       recoveryInstanceID = "string",
#'       recoveryInstanceProperties = list(
#'         cpus = list(
#'           list(
#'             cores = 123,
#'             modelName = "string"
#'           )
#'         ),
#'         disks = list(
#'           list(
#'             bytes = 123,
#'             ebsVolumeID = "string",
#'             internalDeviceName = "string"
#'           )
#'         ),
#'         identificationHints = list(
#'           awsInstanceID = "string",
#'           fqdn = "string",
#'           hostname = "string",
#'           vmWareUuid = "string"
#'         ),
#'         lastUpdatedDateTime = "string",
#'         networkInterfaces = list(
#'           list(
#'             ips = list(
#'               "string"
#'             ),
#'             isPrimary = TRUE|FALSE,
#'             macAddress = "string"
#'           )
#'         ),
#'         os = list(
#'           fullString = "string"
#'         ),
#'         ramBytes = 123
#'       ),
#'       sourceOutpostArn = "string",
#'       sourceServerID = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_recovery_instances(
#'   filters = list(
#'     recoveryInstanceIDs = list(
#'       "string"
#'     ),
#'     sourceServerIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_recovery_instances
#'
#' @aliases drs_describe_recovery_instances
drs_describe_recovery_instances <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeRecoveryInstances",
    http_method = "POST",
    http_path = "/DescribeRecoveryInstances",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_recovery_instances_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_recovery_instances_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_recovery_instances <- drs_describe_recovery_instances

#' Lists all Recovery Snapshots for a single Source Server
#'
#' @description
#' Lists all Recovery Snapshots for a single Source Server.
#'
#' @usage
#' drs_describe_recovery_snapshots(filters, maxResults, nextToken, order,
#'   sourceServerID)
#'
#' @param filters A set of filters by which to return Recovery Snapshots.
#' @param maxResults Maximum number of Recovery Snapshots to retrieve.
#' @param nextToken The token of the next Recovery Snapshot to retrieve.
#' @param order The sorted ordering by which to return Recovery Snapshots.
#' @param sourceServerID &#91;required&#93; Filter Recovery Snapshots by Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       ebsSnapshots = list(
#'         "string"
#'       ),
#'       expectedTimestamp = "string",
#'       snapshotID = "string",
#'       sourceServerID = "string",
#'       timestamp = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_recovery_snapshots(
#'   filters = list(
#'     fromDateTime = "string",
#'     toDateTime = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   order = "ASC"|"DESC",
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_recovery_snapshots
#'
#' @aliases drs_describe_recovery_snapshots
drs_describe_recovery_snapshots <- function(filters = NULL, maxResults = NULL, nextToken = NULL, order = NULL, sourceServerID) {
  op <- new_operation(
    name = "DescribeRecoverySnapshots",
    http_method = "POST",
    http_path = "/DescribeRecoverySnapshots",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_recovery_snapshots_input(filters = filters, maxResults = maxResults, nextToken = nextToken, order = order, sourceServerID = sourceServerID)
  output <- .drs$describe_recovery_snapshots_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_recovery_snapshots <- drs_describe_recovery_snapshots

#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs
#'
#' @description
#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs.
#'
#' @usage
#' drs_describe_replication_configuration_templates(maxResults, nextToken,
#'   replicationConfigurationTemplateIDs)
#'
#' @param maxResults Maximum number of Replication Configuration Templates to retrieve.
#' @param nextToken The token of the next Replication Configuration Template to retrieve.
#' @param replicationConfigurationTemplateIDs The IDs of the Replication Configuration Templates to retrieve. An empty
#' list means all Replication Configuration Templates.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       associateDefaultSecurityGroup = TRUE|FALSE,
#'       autoReplicateNewDisks = TRUE|FALSE,
#'       bandwidthThrottling = 123,
#'       createPublicIP = TRUE|FALSE,
#'       dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'       defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'       ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'       ebsEncryptionKeyArn = "string",
#'       pitPolicy = list(
#'         list(
#'           enabled = TRUE|FALSE,
#'           interval = 123,
#'           retentionDuration = 123,
#'           ruleID = 123,
#'           units = "MINUTE"|"HOUR"|"DAY"
#'         )
#'       ),
#'       replicationConfigurationTemplateID = "string",
#'       replicationServerInstanceType = "string",
#'       replicationServersSecurityGroupsIDs = list(
#'         "string"
#'       ),
#'       stagingAreaSubnetId = "string",
#'       stagingAreaTags = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       useDedicatedReplicationServer = TRUE|FALSE
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_replication_configuration_templates(
#'   maxResults = 123,
#'   nextToken = "string",
#'   replicationConfigurationTemplateIDs = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_replication_configuration_templates
#'
#' @aliases drs_describe_replication_configuration_templates
drs_describe_replication_configuration_templates <- function(maxResults = NULL, nextToken = NULL, replicationConfigurationTemplateIDs = NULL) {
  op <- new_operation(
    name = "DescribeReplicationConfigurationTemplates",
    http_method = "POST",
    http_path = "/DescribeReplicationConfigurationTemplates",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_replication_configuration_templates_input(maxResults = maxResults, nextToken = nextToken, replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs)
  output <- .drs$describe_replication_configuration_templates_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_replication_configuration_templates <- drs_describe_replication_configuration_templates

#' Lists all Source Networks or multiple Source Networks filtered by ID
#'
#' @description
#' Lists all Source Networks or multiple Source Networks filtered by ID.
#'
#' @usage
#' drs_describe_source_networks(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Source Networks.
#' @param maxResults Maximum number of Source Networks to retrieve.
#' @param nextToken The token of the next Source Networks to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       cfnStackName = "string",
#'       lastRecovery = list(
#'         apiCallDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         jobID = "string",
#'         lastRecoveryResult = "NOT_STARTED"|"IN_PROGRESS"|"SUCCESS"|"FAIL"|"PARTIAL_SUCCESS"|"ASSOCIATE_SUCCESS"|"ASSOCIATE_FAIL"
#'       ),
#'       launchedVpcID = "string",
#'       replicationStatus = "STOPPED"|"IN_PROGRESS"|"PROTECTED"|"ERROR",
#'       replicationStatusDetails = "string",
#'       sourceAccountID = "string",
#'       sourceNetworkID = "string",
#'       sourceRegion = "string",
#'       sourceVpcID = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_source_networks(
#'   filters = list(
#'     originAccountID = "string",
#'     originRegion = "string",
#'     sourceNetworkIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_source_networks
#'
#' @aliases drs_describe_source_networks
drs_describe_source_networks <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeSourceNetworks",
    http_method = "POST",
    http_path = "/DescribeSourceNetworks",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_source_networks_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_source_networks_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_source_networks <- drs_describe_source_networks

#' Lists all Source Servers or multiple Source Servers filtered by ID
#'
#' @description
#' Lists all Source Servers or multiple Source Servers filtered by ID.
#'
#' @usage
#' drs_describe_source_servers(filters, maxResults, nextToken)
#'
#' @param filters A set of filters by which to return Source Servers.
#' @param maxResults Maximum number of Source Servers to retrieve.
#' @param nextToken The token of the next Source Server to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       agentVersion = "string",
#'       arn = "string",
#'       dataReplicationInfo = list(
#'         dataReplicationError = list(
#'           error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'           rawError = "string"
#'         ),
#'         dataReplicationInitiation = list(
#'           nextAttemptDateTime = "string",
#'           startDateTime = "string",
#'           steps = list(
#'             list(
#'               name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'               status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'             )
#'           )
#'         ),
#'         dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'         etaDateTime = "string",
#'         lagDuration = "string",
#'         replicatedDisks = list(
#'           list(
#'             backloggedStorageBytes = 123,
#'             deviceName = "string",
#'             replicatedStorageBytes = 123,
#'             rescannedStorageBytes = 123,
#'             totalStorageBytes = 123,
#'             volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'           )
#'         ),
#'         stagingAvailabilityZone = "string",
#'         stagingOutpostArn = "string"
#'       ),
#'       lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'       lifeCycle = list(
#'         addedToServiceDateTime = "string",
#'         elapsedReplicationDuration = "string",
#'         firstByteDateTime = "string",
#'         lastLaunch = list(
#'           initiated = list(
#'             apiCallDateTime = "string",
#'             jobID = "string",
#'             type = "RECOVERY"|"DRILL"
#'           ),
#'           status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'         ),
#'         lastSeenByServiceDateTime = "string"
#'       ),
#'       recoveryInstanceId = "string",
#'       replicationDirection = "FAILOVER"|"FAILBACK",
#'       reversedDirectionSourceServerArn = "string",
#'       sourceCloudProperties = list(
#'         originAccountID = "string",
#'         originAvailabilityZone = "string",
#'         originRegion = "string",
#'         sourceOutpostArn = "string"
#'       ),
#'       sourceNetworkID = "string",
#'       sourceProperties = list(
#'         cpus = list(
#'           list(
#'             cores = 123,
#'             modelName = "string"
#'           )
#'         ),
#'         disks = list(
#'           list(
#'             bytes = 123,
#'             deviceName = "string"
#'           )
#'         ),
#'         identificationHints = list(
#'           awsInstanceID = "string",
#'           fqdn = "string",
#'           hostname = "string",
#'           vmWareUuid = "string"
#'         ),
#'         lastUpdatedDateTime = "string",
#'         networkInterfaces = list(
#'           list(
#'             ips = list(
#'               "string"
#'             ),
#'             isPrimary = TRUE|FALSE,
#'             macAddress = "string"
#'           )
#'         ),
#'         os = list(
#'           fullString = "string"
#'         ),
#'         ramBytes = 123,
#'         recommendedInstanceType = "string",
#'         supportsNitroInstances = TRUE|FALSE
#'       ),
#'       sourceServerID = "string",
#'       stagingArea = list(
#'         errorMessage = "string",
#'         stagingAccountID = "string",
#'         stagingSourceServerArn = "string",
#'         status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_source_servers(
#'   filters = list(
#'     hardwareId = "string",
#'     sourceServerIDs = list(
#'       "string"
#'     ),
#'     stagingAccountIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_describe_source_servers
#'
#' @aliases drs_describe_source_servers
drs_describe_source_servers <- function(filters = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeSourceServers",
    http_method = "POST",
    http_path = "/DescribeSourceServers",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$describe_source_servers_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .drs$describe_source_servers_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$describe_source_servers <- drs_describe_source_servers

#' Disconnect a Recovery Instance from Elastic Disaster Recovery
#'
#' @description
#' Disconnect a Recovery Instance from Elastic Disaster Recovery. Data
#' replication is stopped immediately. All AWS resources created by Elastic
#' Disaster Recovery for enabling the replication of the Recovery Instance
#' will be terminated / deleted within 90 minutes. If the agent on the
#' Recovery Instance has not been prevented from communicating with the
#' Elastic Disaster Recovery service, then it will receive a command to
#' uninstall itself (within approximately 10 minutes). The following
#' properties of the Recovery Instance will be changed immediately:
#' dataReplicationInfo.dataReplicationState will be set to DISCONNECTED;
#' The totalStorageBytes property for each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will
#' be nullified.
#'
#' @usage
#' drs_disconnect_recovery_instance(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance to disconnect.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disconnect_recovery_instance(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_disconnect_recovery_instance
#'
#' @aliases drs_disconnect_recovery_instance
drs_disconnect_recovery_instance <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "DisconnectRecoveryInstance",
    http_method = "POST",
    http_path = "/DisconnectRecoveryInstance",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$disconnect_recovery_instance_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$disconnect_recovery_instance_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$disconnect_recovery_instance <- drs_disconnect_recovery_instance

#' Disconnects a specific Source Server from Elastic Disaster Recovery
#'
#' @description
#' Disconnects a specific Source Server from Elastic Disaster Recovery.
#' Data replication is stopped immediately. All AWS resources created by
#' Elastic Disaster Recovery for enabling the replication of the Source
#' Server will be terminated / deleted within 90 minutes. You cannot
#' disconnect a Source Server if it has a Recovery Instance. If the agent
#' on the Source Server has not been prevented from communicating with the
#' Elastic Disaster Recovery service, then it will receive a command to
#' uninstall itself (within approximately 10 minutes). The following
#' properties of the SourceServer will be changed immediately:
#' dataReplicationInfo.dataReplicationState will be set to DISCONNECTED;
#' The totalStorageBytes property for each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDuration will
#' be nullified.
#'
#' @usage
#' drs_disconnect_source_server(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to disconnect.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   agentVersion = "string",
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123,
#'         volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'       )
#'     ),
#'     stagingAvailabilityZone = "string",
#'     stagingOutpostArn = "string"
#'   ),
#'   lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastLaunch = list(
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string",
#'         type = "RECOVERY"|"DRILL"
#'       ),
#'       status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'     ),
#'     lastSeenByServiceDateTime = "string"
#'   ),
#'   recoveryInstanceId = "string",
#'   replicationDirection = "FAILOVER"|"FAILBACK",
#'   reversedDirectionSourceServerArn = "string",
#'   sourceCloudProperties = list(
#'     originAccountID = "string",
#'     originAvailabilityZone = "string",
#'     originRegion = "string",
#'     sourceOutpostArn = "string"
#'   ),
#'   sourceNetworkID = "string",
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string",
#'     supportsNitroInstances = TRUE|FALSE
#'   ),
#'   sourceServerID = "string",
#'   stagingArea = list(
#'     errorMessage = "string",
#'     stagingAccountID = "string",
#'     stagingSourceServerArn = "string",
#'     status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disconnect_source_server(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_disconnect_source_server
#'
#' @aliases drs_disconnect_source_server
drs_disconnect_source_server <- function(sourceServerID) {
  op <- new_operation(
    name = "DisconnectSourceServer",
    http_method = "POST",
    http_path = "/DisconnectSourceServer",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$disconnect_source_server_input(sourceServerID = sourceServerID)
  output <- .drs$disconnect_source_server_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$disconnect_source_server <- drs_disconnect_source_server

#' Export the Source Network CloudFormation template to an S3 bucket
#'
#' @description
#' Export the Source Network CloudFormation template to an S3 bucket.
#'
#' @usage
#' drs_export_source_network_cfn_template(sourceNetworkID)
#'
#' @param sourceNetworkID &#91;required&#93; The Source Network ID to export its CloudFormation template to an S3
#' bucket.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   s3DestinationUrl = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$export_source_network_cfn_template(
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_export_source_network_cfn_template
#'
#' @aliases drs_export_source_network_cfn_template
drs_export_source_network_cfn_template <- function(sourceNetworkID) {
  op <- new_operation(
    name = "ExportSourceNetworkCfnTemplate",
    http_method = "POST",
    http_path = "/ExportSourceNetworkCfnTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$export_source_network_cfn_template_input(sourceNetworkID = sourceNetworkID)
  output <- .drs$export_source_network_cfn_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$export_source_network_cfn_template <- drs_export_source_network_cfn_template

#' Lists all Failback ReplicationConfigurations, filtered by Recovery
#' Instance ID
#'
#' @description
#' Lists all Failback ReplicationConfigurations, filtered by Recovery
#' Instance ID.
#'
#' @usage
#' drs_get_failback_replication_configuration(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance whose failback replication configuration
#' should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   bandwidthThrottling = 123,
#'   name = "string",
#'   recoveryInstanceID = "string",
#'   usePrivateIP = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_failback_replication_configuration(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_failback_replication_configuration
#'
#' @aliases drs_get_failback_replication_configuration
drs_get_failback_replication_configuration <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "GetFailbackReplicationConfiguration",
    http_method = "POST",
    http_path = "/GetFailbackReplicationConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$get_failback_replication_configuration_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$get_failback_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_failback_replication_configuration <- drs_get_failback_replication_configuration

#' Gets a LaunchConfiguration, filtered by Source Server IDs
#'
#' @description
#' Gets a LaunchConfiguration, filtered by Source Server IDs.
#'
#' @usage
#' drs_get_launch_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server that we want to retrieve a Launch
#' Configuration for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   launchIntoInstanceProperties = list(
#'     launchIntoEC2InstanceID = "string"
#'   ),
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   postLaunchEnabled = TRUE|FALSE,
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_launch_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_launch_configuration
#'
#' @aliases drs_get_launch_configuration
drs_get_launch_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetLaunchConfiguration",
    http_method = "POST",
    http_path = "/GetLaunchConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$get_launch_configuration_input(sourceServerID = sourceServerID)
  output <- .drs$get_launch_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_launch_configuration <- drs_get_launch_configuration

#' Gets a ReplicationConfiguration, filtered by Source Server ID
#'
#' @description
#' Gets a ReplicationConfiguration, filtered by Source Server ID.
#'
#' @usage
#' drs_get_replication_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Serve for this Replication Configuration.r
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_replication_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_get_replication_configuration
#'
#' @aliases drs_get_replication_configuration
drs_get_replication_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetReplicationConfiguration",
    http_method = "POST",
    http_path = "/GetReplicationConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$get_replication_configuration_input(sourceServerID = sourceServerID)
  output <- .drs$get_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$get_replication_configuration <- drs_get_replication_configuration

#' Initialize Elastic Disaster Recovery
#'
#' @description
#' Initialize Elastic Disaster Recovery.
#'
#' @usage
#' drs_initialize_service()
#'

#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$initialize_service()
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_initialize_service
#'
#' @aliases drs_initialize_service
drs_initialize_service <- function() {
  op <- new_operation(
    name = "InitializeService",
    http_method = "POST",
    http_path = "/InitializeService",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$initialize_service_input()
  output <- .drs$initialize_service_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$initialize_service <- drs_initialize_service

#' Returns a list of source servers on a staging account that are
#' extensible, which means that: a
#'
#' @description
#' Returns a list of source servers on a staging account that are
#' extensible, which means that: a. The source server is not already
#' extended into this Account. b. The source server on the Account we’re
#' reading from is not an extension of another source server.
#'
#' @usage
#' drs_list_extensible_source_servers(maxResults, nextToken,
#'   stagingAccountID)
#'
#' @param maxResults The maximum number of extensible source servers to retrieve.
#' @param nextToken The token of the next extensible source server to retrieve.
#' @param stagingAccountID &#91;required&#93; The Id of the staging Account to retrieve extensible source servers
#' from.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       hostname = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_extensible_source_servers(
#'   maxResults = 123,
#'   nextToken = "string",
#'   stagingAccountID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_extensible_source_servers
#'
#' @aliases drs_list_extensible_source_servers
drs_list_extensible_source_servers <- function(maxResults = NULL, nextToken = NULL, stagingAccountID) {
  op <- new_operation(
    name = "ListExtensibleSourceServers",
    http_method = "POST",
    http_path = "/ListExtensibleSourceServers",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$list_extensible_source_servers_input(maxResults = maxResults, nextToken = nextToken, stagingAccountID = stagingAccountID)
  output <- .drs$list_extensible_source_servers_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_extensible_source_servers <- drs_list_extensible_source_servers

#' Lists resource launch actions
#'
#' @description
#' Lists resource launch actions.
#'
#' @usage
#' drs_list_launch_actions(filters, maxResults, nextToken, resourceId)
#'
#' @param filters Filters to apply when listing resource launch actions.
#' @param maxResults Maximum amount of items to return when listing resource launch actions.
#' @param nextToken Next token to use when listing resource launch actions.
#' @param resourceId &#91;required&#93; 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       actionCode = "string",
#'       actionId = "string",
#'       actionVersion = "string",
#'       active = TRUE|FALSE,
#'       category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'       description = "string",
#'       name = "string",
#'       optional = TRUE|FALSE,
#'       order = 123,
#'       parameters = list(
#'         list(
#'           type = "SSM_STORE"|"DYNAMIC",
#'           value = "string"
#'         )
#'       ),
#'       type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_launch_actions(
#'   filters = list(
#'     actionIds = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   resourceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_launch_actions
#'
#' @aliases drs_list_launch_actions
drs_list_launch_actions <- function(filters = NULL, maxResults = NULL, nextToken = NULL, resourceId) {
  op <- new_operation(
    name = "ListLaunchActions",
    http_method = "POST",
    http_path = "/ListLaunchActions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .drs$list_launch_actions_input(filters = filters, maxResults = maxResults, nextToken = nextToken, resourceId = resourceId)
  output <- .drs$list_launch_actions_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_launch_actions <- drs_list_launch_actions

#' Returns an array of staging accounts for existing extended source
#' servers
#'
#' @description
#' Returns an array of staging accounts for existing extended source
#' servers.
#'
#' @usage
#' drs_list_staging_accounts(maxResults, nextToken)
#'
#' @param maxResults The maximum number of staging Accounts to retrieve.
#' @param nextToken The token of the next staging Account to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accounts = list(
#'     list(
#'       accountID = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_staging_accounts(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_staging_accounts
#'
#' @aliases drs_list_staging_accounts
drs_list_staging_accounts <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListStagingAccounts",
    http_method = "GET",
    http_path = "/ListStagingAccounts",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "accounts"),
    stream_api = FALSE
  )
  input <- .drs$list_staging_accounts_input(maxResults = maxResults, nextToken = nextToken)
  output <- .drs$list_staging_accounts_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_staging_accounts <- drs_list_staging_accounts

#' List all tags for your Elastic Disaster Recovery resources
#'
#' @description
#' List all tags for your Elastic Disaster Recovery resources.
#'
#' @usage
#' drs_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource whose tags should be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_list_tags_for_resource
#'
#' @aliases drs_list_tags_for_resource
drs_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .drs$list_tags_for_resource_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$list_tags_for_resource <- drs_list_tags_for_resource

#' Puts a resource launch action
#'
#' @description
#' Puts a resource launch action.
#'
#' @usage
#' drs_put_launch_action(actionCode, actionId, actionVersion, active,
#'   category, description, name, optional, order, parameters, resourceId)
#'
#' @param actionCode &#91;required&#93; Launch action code.
#' @param actionId &#91;required&#93; 
#' @param actionVersion &#91;required&#93; 
#' @param active &#91;required&#93; Whether the launch action is active.
#' @param category &#91;required&#93; 
#' @param description &#91;required&#93; 
#' @param name &#91;required&#93; 
#' @param optional &#91;required&#93; Whether the launch will not be marked as failed if this action fails.
#' @param order &#91;required&#93; 
#' @param parameters 
#' @param resourceId &#91;required&#93; 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   actionCode = "string",
#'   actionId = "string",
#'   actionVersion = "string",
#'   active = TRUE|FALSE,
#'   category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'   description = "string",
#'   name = "string",
#'   optional = TRUE|FALSE,
#'   order = 123,
#'   parameters = list(
#'     list(
#'       type = "SSM_STORE"|"DYNAMIC",
#'       value = "string"
#'     )
#'   ),
#'   resourceId = "string",
#'   type = "SSM_AUTOMATION"|"SSM_COMMAND"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_launch_action(
#'   actionCode = "string",
#'   actionId = "string",
#'   actionVersion = "string",
#'   active = TRUE|FALSE,
#'   category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'   description = "string",
#'   name = "string",
#'   optional = TRUE|FALSE,
#'   order = 123,
#'   parameters = list(
#'     list(
#'       type = "SSM_STORE"|"DYNAMIC",
#'       value = "string"
#'     )
#'   ),
#'   resourceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_put_launch_action
#'
#' @aliases drs_put_launch_action
drs_put_launch_action <- function(actionCode, actionId, actionVersion, active, category, description, name, optional, order, parameters = NULL, resourceId) {
  op <- new_operation(
    name = "PutLaunchAction",
    http_method = "POST",
    http_path = "/PutLaunchAction",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$put_launch_action_input(actionCode = actionCode, actionId = actionId, actionVersion = actionVersion, active = active, category = category, description = description, name = name, optional = optional, order = order, parameters = parameters, resourceId = resourceId)
  output <- .drs$put_launch_action_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$put_launch_action <- drs_put_launch_action

#' WARNING: RetryDataReplication is deprecated
#'
#' @description
#' WARNING: RetryDataReplication is deprecated. Causes the data replication
#' initiation sequence to begin immediately upon next Handshake for the
#' specified Source Server ID, regardless of when the previous initiation
#' started. This command will work only if the Source Server is stalled or
#' is in a DISCONNECTED or STOPPED state.
#'
#' @usage
#' drs_retry_data_replication(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server whose data replication should be retried.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   agentVersion = "string",
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123,
#'         volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'       )
#'     ),
#'     stagingAvailabilityZone = "string",
#'     stagingOutpostArn = "string"
#'   ),
#'   lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastLaunch = list(
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string",
#'         type = "RECOVERY"|"DRILL"
#'       ),
#'       status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'     ),
#'     lastSeenByServiceDateTime = "string"
#'   ),
#'   recoveryInstanceId = "string",
#'   replicationDirection = "FAILOVER"|"FAILBACK",
#'   reversedDirectionSourceServerArn = "string",
#'   sourceCloudProperties = list(
#'     originAccountID = "string",
#'     originAvailabilityZone = "string",
#'     originRegion = "string",
#'     sourceOutpostArn = "string"
#'   ),
#'   sourceNetworkID = "string",
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string",
#'     supportsNitroInstances = TRUE|FALSE
#'   ),
#'   sourceServerID = "string",
#'   stagingArea = list(
#'     errorMessage = "string",
#'     stagingAccountID = "string",
#'     stagingSourceServerArn = "string",
#'     status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retry_data_replication(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_retry_data_replication
#'
#' @aliases drs_retry_data_replication
drs_retry_data_replication <- function(sourceServerID) {
  op <- new_operation(
    name = "RetryDataReplication",
    http_method = "POST",
    http_path = "/RetryDataReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$retry_data_replication_input(sourceServerID = sourceServerID)
  output <- .drs$retry_data_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$retry_data_replication <- drs_retry_data_replication

#' Start replication to origin / target region - applies only to protected
#' instances that originated in EC2
#'
#' @description
#' Start replication to origin / target region - applies only to protected
#' instances that originated in EC2. For recovery instances on target
#' region - starts replication back to origin region. For failback
#' instances on origin region - starts replication to target region to
#' re-protect them.
#'
#' @usage
#' drs_reverse_replication(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance that we want to reverse the replication
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   reversedDirectionSourceServerArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reverse_replication(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_reverse_replication
#'
#' @aliases drs_reverse_replication
drs_reverse_replication <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "ReverseReplication",
    http_method = "POST",
    http_path = "/ReverseReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$reverse_replication_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$reverse_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$reverse_replication <- drs_reverse_replication

#' Initiates a Job for launching the machine that is being failed back to
#' from the specified Recovery Instance
#'
#' @description
#' Initiates a Job for launching the machine that is being failed back to
#' from the specified Recovery Instance. This will run conversion on the
#' failback client and will reboot your machine, thus completing the
#' failback process.
#'
#' @usage
#' drs_start_failback_launch(recoveryInstanceIDs, tags)
#'
#' @param recoveryInstanceIDs &#91;required&#93; The IDs of the Recovery Instance whose failback launch we want to
#' request.
#' @param tags The tags to be associated with the failback launch Job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'     jobID = "string",
#'     participatingResources = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         participatingResourceID = list(
#'           sourceNetworkID = "string"
#'         )
#'       )
#'     ),
#'     participatingServers = list(
#'       list(
#'         launchActionsStatus = list(
#'           runs = list(
#'             list(
#'               action = list(
#'                 actionCode = "string",
#'                 actionId = "string",
#'                 actionVersion = "string",
#'                 active = TRUE|FALSE,
#'                 category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                 description = "string",
#'                 name = "string",
#'                 optional = TRUE|FALSE,
#'                 order = 123,
#'                 parameters = list(
#'                   list(
#'                     type = "SSM_STORE"|"DYNAMIC",
#'                     value = "string"
#'                   )
#'                 ),
#'                 type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'               ),
#'               failureReason = "string",
#'               runId = "string",
#'               status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'             )
#'           ),
#'           ssmAgentDiscoveryDatetime = "string"
#'         ),
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_failback_launch(
#'   recoveryInstanceIDs = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_failback_launch
#'
#' @aliases drs_start_failback_launch
drs_start_failback_launch <- function(recoveryInstanceIDs, tags = NULL) {
  op <- new_operation(
    name = "StartFailbackLaunch",
    http_method = "POST",
    http_path = "/StartFailbackLaunch",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$start_failback_launch_input(recoveryInstanceIDs = recoveryInstanceIDs, tags = tags)
  output <- .drs$start_failback_launch_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_failback_launch <- drs_start_failback_launch

#' Launches Recovery Instances for the specified Source Servers
#'
#' @description
#' Launches Recovery Instances for the specified Source Servers. For each
#' Source Server you may choose a point in time snapshot to launch from, or
#' use an on demand snapshot.
#'
#' @usage
#' drs_start_recovery(isDrill, sourceServers, tags)
#'
#' @param isDrill Whether this Source Server Recovery operation is a drill or not.
#' @param sourceServers &#91;required&#93; The Source Servers that we want to start a Recovery Job for.
#' @param tags The tags to be associated with the Recovery Job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'     jobID = "string",
#'     participatingResources = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         participatingResourceID = list(
#'           sourceNetworkID = "string"
#'         )
#'       )
#'     ),
#'     participatingServers = list(
#'       list(
#'         launchActionsStatus = list(
#'           runs = list(
#'             list(
#'               action = list(
#'                 actionCode = "string",
#'                 actionId = "string",
#'                 actionVersion = "string",
#'                 active = TRUE|FALSE,
#'                 category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                 description = "string",
#'                 name = "string",
#'                 optional = TRUE|FALSE,
#'                 order = 123,
#'                 parameters = list(
#'                   list(
#'                     type = "SSM_STORE"|"DYNAMIC",
#'                     value = "string"
#'                   )
#'                 ),
#'                 type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'               ),
#'               failureReason = "string",
#'               runId = "string",
#'               status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'             )
#'           ),
#'           ssmAgentDiscoveryDatetime = "string"
#'         ),
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_recovery(
#'   isDrill = TRUE|FALSE,
#'   sourceServers = list(
#'     list(
#'       recoverySnapshotID = "string",
#'       sourceServerID = "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_recovery
#'
#' @aliases drs_start_recovery
drs_start_recovery <- function(isDrill = NULL, sourceServers, tags = NULL) {
  op <- new_operation(
    name = "StartRecovery",
    http_method = "POST",
    http_path = "/StartRecovery",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$start_recovery_input(isDrill = isDrill, sourceServers = sourceServers, tags = tags)
  output <- .drs$start_recovery_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_recovery <- drs_start_recovery

#' Starts replication for a stopped Source Server
#'
#' @description
#' Starts replication for a stopped Source Server. This action would make
#' the Source Server protected again and restart billing for it.
#'
#' @usage
#' drs_start_replication(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to start replication for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceServer = list(
#'     agentVersion = "string",
#'     arn = "string",
#'     dataReplicationInfo = list(
#'       dataReplicationError = list(
#'         error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'         rawError = "string"
#'       ),
#'       dataReplicationInitiation = list(
#'         nextAttemptDateTime = "string",
#'         startDateTime = "string",
#'         steps = list(
#'           list(
#'             name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'             status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'           )
#'         )
#'       ),
#'       dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'       etaDateTime = "string",
#'       lagDuration = "string",
#'       replicatedDisks = list(
#'         list(
#'           backloggedStorageBytes = 123,
#'           deviceName = "string",
#'           replicatedStorageBytes = 123,
#'           rescannedStorageBytes = 123,
#'           totalStorageBytes = 123,
#'           volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'         )
#'       ),
#'       stagingAvailabilityZone = "string",
#'       stagingOutpostArn = "string"
#'     ),
#'     lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'     lifeCycle = list(
#'       addedToServiceDateTime = "string",
#'       elapsedReplicationDuration = "string",
#'       firstByteDateTime = "string",
#'       lastLaunch = list(
#'         initiated = list(
#'           apiCallDateTime = "string",
#'           jobID = "string",
#'           type = "RECOVERY"|"DRILL"
#'         ),
#'         status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'       ),
#'       lastSeenByServiceDateTime = "string"
#'     ),
#'     recoveryInstanceId = "string",
#'     replicationDirection = "FAILOVER"|"FAILBACK",
#'     reversedDirectionSourceServerArn = "string",
#'     sourceCloudProperties = list(
#'       originAccountID = "string",
#'       originAvailabilityZone = "string",
#'       originRegion = "string",
#'       sourceOutpostArn = "string"
#'     ),
#'     sourceNetworkID = "string",
#'     sourceProperties = list(
#'       cpus = list(
#'         list(
#'           cores = 123,
#'           modelName = "string"
#'         )
#'       ),
#'       disks = list(
#'         list(
#'           bytes = 123,
#'           deviceName = "string"
#'         )
#'       ),
#'       identificationHints = list(
#'         awsInstanceID = "string",
#'         fqdn = "string",
#'         hostname = "string",
#'         vmWareUuid = "string"
#'       ),
#'       lastUpdatedDateTime = "string",
#'       networkInterfaces = list(
#'         list(
#'           ips = list(
#'             "string"
#'           ),
#'           isPrimary = TRUE|FALSE,
#'           macAddress = "string"
#'         )
#'       ),
#'       os = list(
#'         fullString = "string"
#'       ),
#'       ramBytes = 123,
#'       recommendedInstanceType = "string",
#'       supportsNitroInstances = TRUE|FALSE
#'     ),
#'     sourceServerID = "string",
#'     stagingArea = list(
#'       errorMessage = "string",
#'       stagingAccountID = "string",
#'       stagingSourceServerArn = "string",
#'       status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_replication(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_replication
#'
#' @aliases drs_start_replication
drs_start_replication <- function(sourceServerID) {
  op <- new_operation(
    name = "StartReplication",
    http_method = "POST",
    http_path = "/StartReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$start_replication_input(sourceServerID = sourceServerID)
  output <- .drs$start_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_replication <- drs_start_replication

#' Deploy VPC for the specified Source Network and modify launch templates
#' to use this network
#'
#' @description
#' Deploy VPC for the specified Source Network and modify launch templates
#' to use this network. The VPC will be deployed using a dedicated
#' CloudFormation stack.
#'
#' @usage
#' drs_start_source_network_recovery(deployAsNew, sourceNetworks, tags)
#'
#' @param deployAsNew Don't update existing CloudFormation Stack, recover the network using a
#' new stack.
#' @param sourceNetworks &#91;required&#93; The Source Networks that we want to start a Recovery Job for.
#' @param tags The tags to be associated with the Source Network recovery Job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'     jobID = "string",
#'     participatingResources = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         participatingResourceID = list(
#'           sourceNetworkID = "string"
#'         )
#'       )
#'     ),
#'     participatingServers = list(
#'       list(
#'         launchActionsStatus = list(
#'           runs = list(
#'             list(
#'               action = list(
#'                 actionCode = "string",
#'                 actionId = "string",
#'                 actionVersion = "string",
#'                 active = TRUE|FALSE,
#'                 category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                 description = "string",
#'                 name = "string",
#'                 optional = TRUE|FALSE,
#'                 order = 123,
#'                 parameters = list(
#'                   list(
#'                     type = "SSM_STORE"|"DYNAMIC",
#'                     value = "string"
#'                   )
#'                 ),
#'                 type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'               ),
#'               failureReason = "string",
#'               runId = "string",
#'               status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'             )
#'           ),
#'           ssmAgentDiscoveryDatetime = "string"
#'         ),
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_source_network_recovery(
#'   deployAsNew = TRUE|FALSE,
#'   sourceNetworks = list(
#'     list(
#'       cfnStackName = "string",
#'       sourceNetworkID = "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_source_network_recovery
#'
#' @aliases drs_start_source_network_recovery
drs_start_source_network_recovery <- function(deployAsNew = NULL, sourceNetworks, tags = NULL) {
  op <- new_operation(
    name = "StartSourceNetworkRecovery",
    http_method = "POST",
    http_path = "/StartSourceNetworkRecovery",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$start_source_network_recovery_input(deployAsNew = deployAsNew, sourceNetworks = sourceNetworks, tags = tags)
  output <- .drs$start_source_network_recovery_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_source_network_recovery <- drs_start_source_network_recovery

#' Starts replication for a Source Network
#'
#' @description
#' Starts replication for a Source Network. This action would make the
#' Source Network protected.
#'
#' @usage
#' drs_start_source_network_replication(sourceNetworkID)
#'
#' @param sourceNetworkID &#91;required&#93; ID of the Source Network to replicate.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceNetwork = list(
#'     arn = "string",
#'     cfnStackName = "string",
#'     lastRecovery = list(
#'       apiCallDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       jobID = "string",
#'       lastRecoveryResult = "NOT_STARTED"|"IN_PROGRESS"|"SUCCESS"|"FAIL"|"PARTIAL_SUCCESS"|"ASSOCIATE_SUCCESS"|"ASSOCIATE_FAIL"
#'     ),
#'     launchedVpcID = "string",
#'     replicationStatus = "STOPPED"|"IN_PROGRESS"|"PROTECTED"|"ERROR",
#'     replicationStatusDetails = "string",
#'     sourceAccountID = "string",
#'     sourceNetworkID = "string",
#'     sourceRegion = "string",
#'     sourceVpcID = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_source_network_replication(
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_start_source_network_replication
#'
#' @aliases drs_start_source_network_replication
drs_start_source_network_replication <- function(sourceNetworkID) {
  op <- new_operation(
    name = "StartSourceNetworkReplication",
    http_method = "POST",
    http_path = "/StartSourceNetworkReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$start_source_network_replication_input(sourceNetworkID = sourceNetworkID)
  output <- .drs$start_source_network_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$start_source_network_replication <- drs_start_source_network_replication

#' Stops the failback process for a specified Recovery Instance
#'
#' @description
#' Stops the failback process for a specified Recovery Instance. This
#' changes the Failback State of the Recovery Instance back to
#' FAILBACK_NOT_STARTED.
#'
#' @usage
#' drs_stop_failback(recoveryInstanceID)
#'
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance we want to stop failback for.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_failback(
#'   recoveryInstanceID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_stop_failback
#'
#' @aliases drs_stop_failback
drs_stop_failback <- function(recoveryInstanceID) {
  op <- new_operation(
    name = "StopFailback",
    http_method = "POST",
    http_path = "/StopFailback",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$stop_failback_input(recoveryInstanceID = recoveryInstanceID)
  output <- .drs$stop_failback_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$stop_failback <- drs_stop_failback

#' Stops replication for a Source Server
#'
#' @description
#' Stops replication for a Source Server. This action would make the Source
#' Server unprotected, delete its existing snapshots and stop billing for
#' it.
#'
#' @usage
#' drs_stop_replication(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; The ID of the Source Server to stop replication for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceServer = list(
#'     agentVersion = "string",
#'     arn = "string",
#'     dataReplicationInfo = list(
#'       dataReplicationError = list(
#'         error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'         rawError = "string"
#'       ),
#'       dataReplicationInitiation = list(
#'         nextAttemptDateTime = "string",
#'         startDateTime = "string",
#'         steps = list(
#'           list(
#'             name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'             status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'           )
#'         )
#'       ),
#'       dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'       etaDateTime = "string",
#'       lagDuration = "string",
#'       replicatedDisks = list(
#'         list(
#'           backloggedStorageBytes = 123,
#'           deviceName = "string",
#'           replicatedStorageBytes = 123,
#'           rescannedStorageBytes = 123,
#'           totalStorageBytes = 123,
#'           volumeStatus = "REGULAR"|"CONTAINS_MARKETPLACE_PRODUCT_CODES"|"MISSING_VOLUME_ATTRIBUTES"|"MISSING_VOLUME_ATTRIBUTES_AND_PRECHECK_UNAVAILABLE"|"PENDING"
#'         )
#'       ),
#'       stagingAvailabilityZone = "string",
#'       stagingOutpostArn = "string"
#'     ),
#'     lastLaunchResult = "NOT_STARTED"|"PENDING"|"SUCCEEDED"|"FAILED",
#'     lifeCycle = list(
#'       addedToServiceDateTime = "string",
#'       elapsedReplicationDuration = "string",
#'       firstByteDateTime = "string",
#'       lastLaunch = list(
#'         initiated = list(
#'           apiCallDateTime = "string",
#'           jobID = "string",
#'           type = "RECOVERY"|"DRILL"
#'         ),
#'         status = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED"
#'       ),
#'       lastSeenByServiceDateTime = "string"
#'     ),
#'     recoveryInstanceId = "string",
#'     replicationDirection = "FAILOVER"|"FAILBACK",
#'     reversedDirectionSourceServerArn = "string",
#'     sourceCloudProperties = list(
#'       originAccountID = "string",
#'       originAvailabilityZone = "string",
#'       originRegion = "string",
#'       sourceOutpostArn = "string"
#'     ),
#'     sourceNetworkID = "string",
#'     sourceProperties = list(
#'       cpus = list(
#'         list(
#'           cores = 123,
#'           modelName = "string"
#'         )
#'       ),
#'       disks = list(
#'         list(
#'           bytes = 123,
#'           deviceName = "string"
#'         )
#'       ),
#'       identificationHints = list(
#'         awsInstanceID = "string",
#'         fqdn = "string",
#'         hostname = "string",
#'         vmWareUuid = "string"
#'       ),
#'       lastUpdatedDateTime = "string",
#'       networkInterfaces = list(
#'         list(
#'           ips = list(
#'             "string"
#'           ),
#'           isPrimary = TRUE|FALSE,
#'           macAddress = "string"
#'         )
#'       ),
#'       os = list(
#'         fullString = "string"
#'       ),
#'       ramBytes = 123,
#'       recommendedInstanceType = "string",
#'       supportsNitroInstances = TRUE|FALSE
#'     ),
#'     sourceServerID = "string",
#'     stagingArea = list(
#'       errorMessage = "string",
#'       stagingAccountID = "string",
#'       stagingSourceServerArn = "string",
#'       status = "EXTENDED"|"EXTENSION_ERROR"|"NOT_EXTENDED"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_replication(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_stop_replication
#'
#' @aliases drs_stop_replication
drs_stop_replication <- function(sourceServerID) {
  op <- new_operation(
    name = "StopReplication",
    http_method = "POST",
    http_path = "/StopReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$stop_replication_input(sourceServerID = sourceServerID)
  output <- .drs$stop_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$stop_replication <- drs_stop_replication

#' Stops replication for a Source Network
#'
#' @description
#' Stops replication for a Source Network. This action would make the
#' Source Network unprotected.
#'
#' @usage
#' drs_stop_source_network_replication(sourceNetworkID)
#'
#' @param sourceNetworkID &#91;required&#93; ID of the Source Network to stop replication.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sourceNetwork = list(
#'     arn = "string",
#'     cfnStackName = "string",
#'     lastRecovery = list(
#'       apiCallDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       jobID = "string",
#'       lastRecoveryResult = "NOT_STARTED"|"IN_PROGRESS"|"SUCCESS"|"FAIL"|"PARTIAL_SUCCESS"|"ASSOCIATE_SUCCESS"|"ASSOCIATE_FAIL"
#'     ),
#'     launchedVpcID = "string",
#'     replicationStatus = "STOPPED"|"IN_PROGRESS"|"PROTECTED"|"ERROR",
#'     replicationStatusDetails = "string",
#'     sourceAccountID = "string",
#'     sourceNetworkID = "string",
#'     sourceRegion = "string",
#'     sourceVpcID = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$stop_source_network_replication(
#'   sourceNetworkID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_stop_source_network_replication
#'
#' @aliases drs_stop_source_network_replication
drs_stop_source_network_replication <- function(sourceNetworkID) {
  op <- new_operation(
    name = "StopSourceNetworkReplication",
    http_method = "POST",
    http_path = "/StopSourceNetworkReplication",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$stop_source_network_replication_input(sourceNetworkID = sourceNetworkID)
  output <- .drs$stop_source_network_replication_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$stop_source_network_replication <- drs_stop_source_network_replication

#' Adds or overwrites only the specified tags for the specified Elastic
#' Disaster Recovery resource or resources
#'
#' @description
#' Adds or overwrites only the specified tags for the specified Elastic
#' Disaster Recovery resource or resources. When you specify an existing
#' tag key, the value is overwritten with the new value. Each resource can
#' have a maximum of 50 tags. Each tag consists of a key and optional
#' value.
#'
#' @usage
#' drs_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be added or updated.
#' @param tags &#91;required&#93; Array of tags to be added or updated.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_tag_resource
#'
#' @aliases drs_tag_resource
drs_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .drs$tag_resource_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$tag_resource <- drs_tag_resource

#' Initiates a Job for terminating the EC2 resources associated with the
#' specified Recovery Instances, and then will delete the Recovery
#' Instances from the Elastic Disaster Recovery service
#'
#' @description
#' Initiates a Job for terminating the EC2 resources associated with the
#' specified Recovery Instances, and then will delete the Recovery
#' Instances from the Elastic Disaster Recovery service.
#'
#' @usage
#' drs_terminate_recovery_instances(recoveryInstanceIDs)
#'
#' @param recoveryInstanceIDs &#91;required&#93; The IDs of the Recovery Instances that should be terminated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_RECOVERY"|"START_DRILL"|"FAILBACK"|"DIAGNOSTIC"|"TERMINATE_RECOVERY_INSTANCES"|"TARGET_ACCOUNT"|"CREATE_NETWORK_RECOVERY"|"UPDATE_NETWORK_RECOVERY"|"ASSOCIATE_NETWORK_RECOVERY",
#'     jobID = "string",
#'     participatingResources = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         participatingResourceID = list(
#'           sourceNetworkID = "string"
#'         )
#'       )
#'     ),
#'     participatingServers = list(
#'       list(
#'         launchActionsStatus = list(
#'           runs = list(
#'             list(
#'               action = list(
#'                 actionCode = "string",
#'                 actionId = "string",
#'                 actionVersion = "string",
#'                 active = TRUE|FALSE,
#'                 category = "MONITORING"|"VALIDATION"|"CONFIGURATION"|"SECURITY"|"OTHER",
#'                 description = "string",
#'                 name = "string",
#'                 optional = TRUE|FALSE,
#'                 order = 123,
#'                 parameters = list(
#'                   list(
#'                     type = "SSM_STORE"|"DYNAMIC",
#'                     value = "string"
#'                   )
#'                 ),
#'                 type = "SSM_AUTOMATION"|"SSM_COMMAND"
#'               ),
#'               failureReason = "string",
#'               runId = "string",
#'               status = "IN_PROGRESS"|"SUCCEEDED"|"FAILED"
#'             )
#'           ),
#'           ssmAgentDiscoveryDatetime = "string"
#'         ),
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         recoveryInstanceID = "string",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"|"CREATE_CONVERTED_SNAPSHOT"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$terminate_recovery_instances(
#'   recoveryInstanceIDs = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_terminate_recovery_instances
#'
#' @aliases drs_terminate_recovery_instances
drs_terminate_recovery_instances <- function(recoveryInstanceIDs) {
  op <- new_operation(
    name = "TerminateRecoveryInstances",
    http_method = "POST",
    http_path = "/TerminateRecoveryInstances",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$terminate_recovery_instances_input(recoveryInstanceIDs = recoveryInstanceIDs)
  output <- .drs$terminate_recovery_instances_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$terminate_recovery_instances <- drs_terminate_recovery_instances

#' Deletes the specified set of tags from the specified set of Elastic
#' Disaster Recovery resources
#'
#' @description
#' Deletes the specified set of tags from the specified set of Elastic
#' Disaster Recovery resources.
#'
#' @usage
#' drs_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be removed.
#' @param tagKeys &#91;required&#93; Array of tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_untag_resource
#'
#' @aliases drs_untag_resource
drs_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .drs$untag_resource_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$untag_resource <- drs_untag_resource

#' Allows you to update the failback replication configuration of a
#' Recovery Instance by ID
#'
#' @description
#' Allows you to update the failback replication configuration of a
#' Recovery Instance by ID.
#'
#' @usage
#' drs_update_failback_replication_configuration(bandwidthThrottling, name,
#'   recoveryInstanceID, usePrivateIP)
#'
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Recovery Instance in Mbps.
#' @param name The name of the Failback Replication Configuration.
#' @param recoveryInstanceID &#91;required&#93; The ID of the Recovery Instance.
#' @param usePrivateIP Whether to use Private IP for the failback replication of the Recovery
#' Instance.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_failback_replication_configuration(
#'   bandwidthThrottling = 123,
#'   name = "string",
#'   recoveryInstanceID = "string",
#'   usePrivateIP = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_failback_replication_configuration
#'
#' @aliases drs_update_failback_replication_configuration
drs_update_failback_replication_configuration <- function(bandwidthThrottling = NULL, name = NULL, recoveryInstanceID, usePrivateIP = NULL) {
  op <- new_operation(
    name = "UpdateFailbackReplicationConfiguration",
    http_method = "POST",
    http_path = "/UpdateFailbackReplicationConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$update_failback_replication_configuration_input(bandwidthThrottling = bandwidthThrottling, name = name, recoveryInstanceID = recoveryInstanceID, usePrivateIP = usePrivateIP)
  output <- .drs$update_failback_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_failback_replication_configuration <- drs_update_failback_replication_configuration

#' Updates a LaunchConfiguration by Source Server ID
#'
#' @description
#' Updates a LaunchConfiguration by Source Server ID.
#'
#' @usage
#' drs_update_launch_configuration(copyPrivateIp, copyTags,
#'   launchDisposition, launchIntoInstanceProperties, licensing, name,
#'   postLaunchEnabled, sourceServerID, targetInstanceTypeRightSizingMethod)
#'
#' @param copyPrivateIp Whether we should copy the Private IP of the Source Server to the
#' Recovery Instance.
#' @param copyTags Whether we want to copy the tags of the Source Server to the EC2 machine
#' of the Recovery Instance.
#' @param launchDisposition The state of the Recovery Instance in EC2 after the recovery operation.
#' @param launchIntoInstanceProperties Launch into existing instance properties.
#' @param licensing The licensing configuration to be used for this launch configuration.
#' @param name The name of the launch configuration.
#' @param postLaunchEnabled Whether we want to enable post-launch actions for the Source Server.
#' @param sourceServerID &#91;required&#93; The ID of the Source Server that we want to retrieve a Launch
#' Configuration for.
#' @param targetInstanceTypeRightSizingMethod Whether Elastic Disaster Recovery should try to automatically choose the
#' instance type that best matches the OS, CPU, and RAM of your Source
#' Server.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   launchIntoInstanceProperties = list(
#'     launchIntoEC2InstanceID = "string"
#'   ),
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   postLaunchEnabled = TRUE|FALSE,
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_launch_configuration(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   launchDisposition = "STOPPED"|"STARTED",
#'   launchIntoInstanceProperties = list(
#'     launchIntoEC2InstanceID = "string"
#'   ),
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   postLaunchEnabled = TRUE|FALSE,
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_launch_configuration
#'
#' @aliases drs_update_launch_configuration
drs_update_launch_configuration <- function(copyPrivateIp = NULL, copyTags = NULL, launchDisposition = NULL, launchIntoInstanceProperties = NULL, licensing = NULL, name = NULL, postLaunchEnabled = NULL, sourceServerID, targetInstanceTypeRightSizingMethod = NULL) {
  op <- new_operation(
    name = "UpdateLaunchConfiguration",
    http_method = "POST",
    http_path = "/UpdateLaunchConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$update_launch_configuration_input(copyPrivateIp = copyPrivateIp, copyTags = copyTags, launchDisposition = launchDisposition, launchIntoInstanceProperties = launchIntoInstanceProperties, licensing = licensing, name = name, postLaunchEnabled = postLaunchEnabled, sourceServerID = sourceServerID, targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod)
  output <- .drs$update_launch_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_launch_configuration <- drs_update_launch_configuration

#' Updates an existing Launch Configuration Template by ID
#'
#' @description
#' Updates an existing Launch Configuration Template by ID.
#'
#' @usage
#' drs_update_launch_configuration_template(copyPrivateIp, copyTags,
#'   exportBucketArn, launchConfigurationTemplateID, launchDisposition,
#'   launchIntoSourceInstance, licensing, postLaunchEnabled,
#'   targetInstanceTypeRightSizingMethod)
#'
#' @param copyPrivateIp Copy private IP.
#' @param copyTags Copy tags.
#' @param exportBucketArn S3 bucket ARN to export Source Network templates.
#' @param launchConfigurationTemplateID &#91;required&#93; Launch Configuration Template ID.
#' @param launchDisposition Launch disposition.
#' @param launchIntoSourceInstance DRS will set the 'launch into instance ID' of any source server when
#' performing a drill, recovery or failback to the previous region or
#' availability zone, using the instance ID of the source instance.
#' @param licensing Licensing.
#' @param postLaunchEnabled Whether we want to activate post-launch actions.
#' @param targetInstanceTypeRightSizingMethod Target instance type right-sizing method.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   launchConfigurationTemplate = list(
#'     arn = "string",
#'     copyPrivateIp = TRUE|FALSE,
#'     copyTags = TRUE|FALSE,
#'     exportBucketArn = "string",
#'     launchConfigurationTemplateID = "string",
#'     launchDisposition = "STOPPED"|"STARTED",
#'     launchIntoSourceInstance = TRUE|FALSE,
#'     licensing = list(
#'       osByol = TRUE|FALSE
#'     ),
#'     postLaunchEnabled = TRUE|FALSE,
#'     tags = list(
#'       "string"
#'     ),
#'     targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_launch_configuration_template(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   exportBucketArn = "string",
#'   launchConfigurationTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   launchIntoSourceInstance = TRUE|FALSE,
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   postLaunchEnabled = TRUE|FALSE,
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"|"IN_AWS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_launch_configuration_template
#'
#' @aliases drs_update_launch_configuration_template
drs_update_launch_configuration_template <- function(copyPrivateIp = NULL, copyTags = NULL, exportBucketArn = NULL, launchConfigurationTemplateID, launchDisposition = NULL, launchIntoSourceInstance = NULL, licensing = NULL, postLaunchEnabled = NULL, targetInstanceTypeRightSizingMethod = NULL) {
  op <- new_operation(
    name = "UpdateLaunchConfigurationTemplate",
    http_method = "POST",
    http_path = "/UpdateLaunchConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$update_launch_configuration_template_input(copyPrivateIp = copyPrivateIp, copyTags = copyTags, exportBucketArn = exportBucketArn, launchConfigurationTemplateID = launchConfigurationTemplateID, launchDisposition = launchDisposition, launchIntoSourceInstance = launchIntoSourceInstance, licensing = licensing, postLaunchEnabled = postLaunchEnabled, targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod)
  output <- .drs$update_launch_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_launch_configuration_template <- drs_update_launch_configuration_template

#' Allows you to update a ReplicationConfiguration by Source Server ID
#'
#' @description
#' Allows you to update a ReplicationConfiguration by Source Server ID.
#'
#' @usage
#' drs_update_replication_configuration(associateDefaultSecurityGroup,
#'   autoReplicateNewDisks, bandwidthThrottling, createPublicIP,
#'   dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption,
#'   ebsEncryptionKeyArn, name, pitPolicy, replicatedDisks,
#'   replicationServerInstanceType, replicationServersSecurityGroupsIDs,
#'   sourceServerID, stagingAreaSubnetId, stagingAreaTags,
#'   useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration.
#' @param autoReplicateNewDisks Whether to allow the AWS replication agent to automatically replicate
#' newly added disks.
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param name The name of the Replication Configuration.
#' @param pitPolicy The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicatedDisks The configuration of the disks of the Source Server to be replicated.
#' @param replicationServerInstanceType The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs The security group IDs that will be used by the replication server.
#' @param sourceServerID &#91;required&#93; The ID of the Source Server for this Replication Configuration.
#' @param stagingAreaSubnetId The subnet to be used by the replication staging area.
#' @param stagingAreaTags A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param useDedicatedReplicationServer Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       optimizedStagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       stagingDiskType = "AUTO"|"GP2"|"GP3"|"IO1"|"SC1"|"ST1"|"STANDARD",
#'       throughput = 123
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_replication_configuration
#'
#' @aliases drs_update_replication_configuration
drs_update_replication_configuration <- function(associateDefaultSecurityGroup = NULL, autoReplicateNewDisks = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, name = NULL, pitPolicy = NULL, replicatedDisks = NULL, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, sourceServerID, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfiguration",
    http_method = "POST",
    http_path = "/UpdateReplicationConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$update_replication_configuration_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, autoReplicateNewDisks = autoReplicateNewDisks, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, name = name, pitPolicy = pitPolicy, replicatedDisks = replicatedDisks, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, sourceServerID = sourceServerID, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$update_replication_configuration_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_replication_configuration <- drs_update_replication_configuration

#' Updates a ReplicationConfigurationTemplate by ID
#'
#' @description
#' Updates a ReplicationConfigurationTemplate by ID.
#'
#' @usage
#' drs_update_replication_configuration_template(arn,
#'   associateDefaultSecurityGroup, autoReplicateNewDisks,
#'   bandwidthThrottling, createPublicIP, dataPlaneRouting,
#'   defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn,
#'   pitPolicy, replicationConfigurationTemplateID,
#'   replicationServerInstanceType, replicationServersSecurityGroupsIDs,
#'   stagingAreaSubnetId, stagingAreaTags, useDedicatedReplicationServer)
#'
#' @param arn The Replication Configuration Template ARN.
#' @param associateDefaultSecurityGroup Whether to associate the default Elastic Disaster Recovery Security
#' group with the Replication Configuration Template.
#' @param autoReplicateNewDisks Whether to allow the AWS replication agent to automatically replicate
#' newly added disks.
#' @param bandwidthThrottling Configure bandwidth throttling for the outbound data transfer rate of
#' the Source Server in Mbps.
#' @param createPublicIP Whether to create a Public IP for the Recovery Instance by default.
#' @param dataPlaneRouting The data plane routing mechanism that will be used for replication.
#' @param defaultLargeStagingDiskType The Staging Disk EBS volume type to be used during replication.
#' @param ebsEncryption The type of EBS encryption to be used during replication.
#' @param ebsEncryptionKeyArn The ARN of the EBS encryption key to be used during replication.
#' @param pitPolicy The Point in time (PIT) policy to manage snapshots taken during
#' replication.
#' @param replicationConfigurationTemplateID &#91;required&#93; The Replication Configuration Template ID.
#' @param replicationServerInstanceType The instance type to be used for the replication server.
#' @param replicationServersSecurityGroupsIDs The security group IDs that will be used by the replication server.
#' @param stagingAreaSubnetId The subnet to be used by the replication staging area.
#' @param stagingAreaTags A set of tags to be associated with all resources created in the
#' replication staging area: EC2 replication server, EBS volumes, EBS
#' snapshots, etc.
#' @param useDedicatedReplicationServer Whether to use a dedicated Replication Server in the replication staging
#' area.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration_template(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   autoReplicateNewDisks = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"GP3"|"ST1"|"AUTO",
#'   ebsEncryption = "DEFAULT"|"CUSTOM"|"NONE",
#'   ebsEncryptionKeyArn = "string",
#'   pitPolicy = list(
#'     list(
#'       enabled = TRUE|FALSE,
#'       interval = 123,
#'       retentionDuration = 123,
#'       ruleID = 123,
#'       units = "MINUTE"|"HOUR"|"DAY"
#'     )
#'   ),
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname drs_update_replication_configuration_template
#'
#' @aliases drs_update_replication_configuration_template
drs_update_replication_configuration_template <- function(arn = NULL, associateDefaultSecurityGroup = NULL, autoReplicateNewDisks = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, pitPolicy = NULL, replicationConfigurationTemplateID, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/UpdateReplicationConfigurationTemplate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .drs$update_replication_configuration_template_input(arn = arn, associateDefaultSecurityGroup = associateDefaultSecurityGroup, autoReplicateNewDisks = autoReplicateNewDisks, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, pitPolicy = pitPolicy, replicationConfigurationTemplateID = replicationConfigurationTemplateID, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .drs$update_replication_configuration_template_output()
  config <- get_config()
  svc <- .drs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.drs$operations$update_replication_configuration_template <- drs_update_replication_configuration_template

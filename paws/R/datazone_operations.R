# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include datazone_service.R
NULL

#' Accepts automatically generated business-friendly metadata for your
#' Amazon DataZone assets
#'
#' @description
#' Accepts automatically generated business-friendly metadata for your
#' Amazon DataZone assets.
#'
#' @usage
#' datazone_accept_predictions(acceptChoices, acceptRule, clientToken,
#'   domainIdentifier, identifier, revision)
#'
#' @param acceptChoices Specifies the prediction (aka, the automatically generated piece of
#' metadata) and the target (for example, a column name) that can be
#' accepted.
#' @param acceptRule Specifies the rule (or the conditions) under which a prediction can be
#' accepted.
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param identifier &#91;required&#93; The identifier of the asset.
#' @param revision The revision that is to be made to the asset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetId = "string",
#'   domainId = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$accept_predictions(
#'   acceptChoices = list(
#'     list(
#'       editedValue = "string",
#'       predictionChoice = 123,
#'       predictionTarget = "string"
#'     )
#'   ),
#'   acceptRule = list(
#'     rule = "ALL"|"NONE",
#'     threshold = 123.0
#'   ),
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_accept_predictions
#'
#' @aliases datazone_accept_predictions
datazone_accept_predictions <- function(acceptChoices = NULL, acceptRule = NULL, clientToken = NULL, domainIdentifier, identifier, revision = NULL) {
  op <- new_operation(
    name = "AcceptPredictions",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}/accept-predictions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$accept_predictions_input(acceptChoices = acceptChoices, acceptRule = acceptRule, clientToken = clientToken, domainIdentifier = domainIdentifier, identifier = identifier, revision = revision)
  output <- .datazone$accept_predictions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$accept_predictions <- datazone_accept_predictions

#' Accepts a subscription request to a specific asset
#'
#' @description
#' Accepts a subscription request to a specific asset.
#'
#' @usage
#' datazone_accept_subscription_request(assetPermissions, assetScopes,
#'   decisionComment, domainIdentifier, identifier)
#'
#' @param assetPermissions The asset permissions of the accept subscription request.
#' @param assetScopes The asset scopes of the accept subscription request.
#' @param decisionComment A description that specifies the reason for accepting the specified
#' subscription request.
#' @param domainIdentifier &#91;required&#93; The Amazon DataZone domain where the specified subscription request is
#' being accepted.
#' @param identifier &#91;required&#93; The unique identifier of the subscription request that is to be
#' accepted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   decisionComment = "string",
#'   domainId = "string",
#'   existingSubscriptionId = "string",
#'   id = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   reviewerId = "string",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListings = list(
#'     list(
#'       description = "string",
#'       id = "string",
#'       item = list(
#'         assetListing = list(
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           entityId = "string",
#'           entityRevision = "string",
#'           entityType = "string",
#'           forms = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           )
#'         ),
#'         productListing = list(
#'           assetListings = list(
#'             list(
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string"
#'             )
#'           ),
#'           description = "string",
#'           entityId = "string",
#'           entityRevision = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           name = "string"
#'         )
#'       ),
#'       name = "string",
#'       ownerProjectId = "string",
#'       ownerProjectName = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       project = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       user = list(
#'         details = list(
#'           iam = list(
#'             arn = "string",
#'             principalId = "string"
#'           ),
#'           sso = list(
#'             firstName = "string",
#'             lastName = "string",
#'             username = "string"
#'           )
#'         ),
#'         id = "string"
#'       )
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$accept_subscription_request(
#'   assetPermissions = list(
#'     list(
#'       assetId = "string",
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       )
#'     )
#'   ),
#'   assetScopes = list(
#'     list(
#'       assetId = "string",
#'       filterIds = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   decisionComment = "string",
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_accept_subscription_request
#'
#' @aliases datazone_accept_subscription_request
datazone_accept_subscription_request <- function(assetPermissions = NULL, assetScopes = NULL, decisionComment = NULL, domainIdentifier, identifier) {
  op <- new_operation(
    name = "AcceptSubscriptionRequest",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/accept",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$accept_subscription_request_input(assetPermissions = assetPermissions, assetScopes = assetScopes, decisionComment = decisionComment, domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$accept_subscription_request_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$accept_subscription_request <- datazone_accept_subscription_request

#' Adds the owner of an entity (a domain unit)
#'
#' @description
#' Adds the owner of an entity (a domain unit).
#'
#' @usage
#' datazone_add_entity_owner(clientToken, domainIdentifier,
#'   entityIdentifier, entityType, owner)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which you want to add the entity owner.
#' @param entityIdentifier &#91;required&#93; The ID of the entity to which you want to add an owner.
#' @param entityType &#91;required&#93; The type of an entity.
#' @param owner &#91;required&#93; The owner that you want to add to the entity.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$add_entity_owner(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT",
#'   owner = list(
#'     group = list(
#'       groupIdentifier = "string"
#'     ),
#'     user = list(
#'       userIdentifier = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_add_entity_owner
#'
#' @aliases datazone_add_entity_owner
datazone_add_entity_owner <- function(clientToken = NULL, domainIdentifier, entityIdentifier, entityType, owner) {
  op <- new_operation(
    name = "AddEntityOwner",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/addOwner",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$add_entity_owner_input(clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, owner = owner)
  output <- .datazone$add_entity_owner_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$add_entity_owner <- datazone_add_entity_owner

#' Adds a policy grant (an authorization policy) to a specified entity,
#' including domain units, environment blueprint configurations, or
#' environment profiles
#'
#' @description
#' Adds a policy grant (an authorization policy) to a specified entity,
#' including domain units, environment blueprint configurations, or
#' environment profiles.
#'
#' @usage
#' datazone_add_policy_grant(clientToken, detail, domainIdentifier,
#'   entityIdentifier, entityType, policyType, principal)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param detail &#91;required&#93; The details of the policy grant.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to add a policy grant.
#' @param entityIdentifier &#91;required&#93; The ID of the entity (resource) to which you want to add a policy grant.
#' @param entityType &#91;required&#93; The type of entity (resource) to which the grant is added.
#' @param policyType &#91;required&#93; The type of policy that you want to grant.
#' @param principal &#91;required&#93; The principal to whom the permissions are granted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   grantId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$add_policy_grant(
#'   clientToken = "string",
#'   detail = list(
#'     addToProjectMemberPool = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createAssetType = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createDomainUnit = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createEnvironment = list(),
#'     createEnvironmentFromBlueprint = list(),
#'     createEnvironmentProfile = list(
#'       domainUnitId = "string"
#'     ),
#'     createFormType = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createGlossary = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createProject = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     createProjectFromProjectProfile = list(
#'       includeChildDomainUnits = TRUE|FALSE,
#'       projectProfiles = list(
#'         "string"
#'       )
#'     ),
#'     delegateCreateEnvironmentProfile = list(),
#'     overrideDomainUnitOwners = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     overrideProjectOwners = list(
#'       includeChildDomainUnits = TRUE|FALSE
#'     ),
#'     useAssetType = list(
#'       domainUnitId = "string"
#'     )
#'   ),
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT"|"ENVIRONMENT_BLUEPRINT_CONFIGURATION"|"ENVIRONMENT_PROFILE"|"ASSET_TYPE",
#'   policyType = "CREATE_DOMAIN_UNIT"|"OVERRIDE_DOMAIN_UNIT_OWNERS"|"ADD_TO_PROJECT_MEMBER_POOL"|"OVERRIDE_PROJECT_OWNERS"|"CREATE_GLOSSARY"|"CREATE_FORM_TYPE"|"CREATE_ASSET_TYPE"|"CREATE_PROJECT"|"CREATE_ENVIRONMENT_PROFILE"|"DELEGATE_CREATE_ENVIRONMENT_PROFILE"|"CREATE_ENVIRONMENT"|"CREATE_ENVIRONMENT_FROM_BLUEPRINT"|"CREATE_PROJECT_FROM_PROJECT_PROFILE"|"USE_ASSET_TYPE",
#'   principal = list(
#'     domainUnit = list(
#'       domainUnitDesignation = "OWNER",
#'       domainUnitGrantFilter = list(
#'         allDomainUnitsGrantFilter = list()
#'       ),
#'       domainUnitIdentifier = "string"
#'     ),
#'     group = list(
#'       groupIdentifier = "string"
#'     ),
#'     project = list(
#'       projectDesignation = "OWNER"|"CONTRIBUTOR"|"PROJECT_CATALOG_STEWARD",
#'       projectGrantFilter = list(
#'         domainUnitFilter = list(
#'           domainUnit = "string",
#'           includeChildDomainUnits = TRUE|FALSE
#'         )
#'       ),
#'       projectIdentifier = "string"
#'     ),
#'     user = list(
#'       allUsersGrantFilter = list(),
#'       userIdentifier = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_add_policy_grant
#'
#' @aliases datazone_add_policy_grant
datazone_add_policy_grant <- function(clientToken = NULL, detail, domainIdentifier, entityIdentifier, entityType, policyType, principal) {
  op <- new_operation(
    name = "AddPolicyGrant",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/addGrant",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$add_policy_grant_input(clientToken = clientToken, detail = detail, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, policyType = policyType, principal = principal)
  output <- .datazone$add_policy_grant_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$add_policy_grant <- datazone_add_policy_grant

#' Associates the environment role in Amazon DataZone
#'
#' @description
#' Associates the environment role in Amazon DataZone.
#'
#' @usage
#' datazone_associate_environment_role(domainIdentifier,
#'   environmentIdentifier, environmentRoleArn)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the environment role is
#' associated.
#' @param environmentIdentifier &#91;required&#93; The ID of the Amazon DataZone environment.
#' @param environmentRoleArn &#91;required&#93; The ARN of the environment role.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$associate_environment_role(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   environmentRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_associate_environment_role
#'
#' @aliases datazone_associate_environment_role
datazone_associate_environment_role <- function(domainIdentifier, environmentIdentifier, environmentRoleArn) {
  op <- new_operation(
    name = "AssociateEnvironmentRole",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/roles/{environmentRoleArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$associate_environment_role_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, environmentRoleArn = environmentRoleArn)
  output <- .datazone$associate_environment_role_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$associate_environment_role <- datazone_associate_environment_role

#' Associates governed terms with an asset
#'
#' @description
#' Associates governed terms with an asset.
#'
#' @usage
#' datazone_associate_governed_terms(domainIdentifier, entityIdentifier,
#'   entityType, governedGlossaryTerms)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where governed terms are to be associated with an
#' asset.
#' @param entityIdentifier &#91;required&#93; The ID of the asset with which you want to associate a governed term.
#' @param entityType &#91;required&#93; The type of the asset with which you want to associate a governed term.
#' @param governedGlossaryTerms &#91;required&#93; The glossary terms in a restricted glossary.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$associate_governed_terms(
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET",
#'   governedGlossaryTerms = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_associate_governed_terms
#'
#' @aliases datazone_associate_governed_terms
datazone_associate_governed_terms <- function(domainIdentifier, entityIdentifier, entityType, governedGlossaryTerms) {
  op <- new_operation(
    name = "AssociateGovernedTerms",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/associate-governed-terms",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$associate_governed_terms_input(domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, governedGlossaryTerms = governedGlossaryTerms)
  output <- .datazone$associate_governed_terms_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$associate_governed_terms <- datazone_associate_governed_terms

#' Gets the attribute metadata
#'
#' @description
#' Gets the attribute metadata.
#'
#' @usage
#' datazone_batch_get_attributes_metadata(attributeIdentifiers,
#'   domainIdentifier, entityIdentifier, entityRevision, entityType)
#'
#' @param attributeIdentifiers &#91;required&#93; The attribute identifier.
#' @param domainIdentifier &#91;required&#93; The domain ID where you want to get the attribute metadata.
#' @param entityIdentifier &#91;required&#93; The entity ID for which you want to get attribute metadata.
#' @param entityRevision The entity revision for which you want to get attribute metadata.
#' @param entityType &#91;required&#93; The entity type for which you want to get attribute metadata.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   attributes = list(
#'     list(
#'       attributeIdentifier = "string",
#'       forms = list(
#'         list(
#'           content = "string",
#'           formName = "string",
#'           typeName = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       attributeIdentifier = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_attributes_metadata(
#'   attributeIdentifiers = list(
#'     "string"
#'   ),
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityRevision = "string",
#'   entityType = "ASSET"|"LISTING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_batch_get_attributes_metadata
#'
#' @aliases datazone_batch_get_attributes_metadata
datazone_batch_get_attributes_metadata <- function(attributeIdentifiers, domainIdentifier, entityIdentifier, entityRevision = NULL, entityType) {
  op <- new_operation(
    name = "BatchGetAttributesMetadata",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/attributes-metadata",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$batch_get_attributes_metadata_input(attributeIdentifiers = attributeIdentifiers, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityRevision = entityRevision, entityType = entityType)
  output <- .datazone$batch_get_attributes_metadata_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$batch_get_attributes_metadata <- datazone_batch_get_attributes_metadata

#' Writes the attribute metadata
#'
#' @description
#' Writes the attribute metadata.
#'
#' @usage
#' datazone_batch_put_attributes_metadata(attributes, clientToken,
#'   domainIdentifier, entityIdentifier, entityType)
#'
#' @param attributes &#91;required&#93; The attributes of the metadata.
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param domainIdentifier &#91;required&#93; The domain ID where you want to write the attribute metadata.
#' @param entityIdentifier &#91;required&#93; The entity ID for which you want to write the attribute metadata.
#' @param entityType &#91;required&#93; The entity type for which you want to write the attribute metadata.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   attributes = list(
#'     list(
#'       attributeIdentifier = "string"
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       attributeIdentifier = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_put_attributes_metadata(
#'   attributes = list(
#'     list(
#'       attributeIdentifier = "string",
#'       forms = list(
#'         list(
#'           content = "string",
#'           formName = "string",
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET"|"LISTING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_batch_put_attributes_metadata
#'
#' @aliases datazone_batch_put_attributes_metadata
datazone_batch_put_attributes_metadata <- function(attributes, clientToken = NULL, domainIdentifier, entityIdentifier, entityType) {
  op <- new_operation(
    name = "BatchPutAttributesMetadata",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/attributes-metadata",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$batch_put_attributes_metadata_input(attributes = attributes, clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType)
  output <- .datazone$batch_put_attributes_metadata_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$batch_put_attributes_metadata <- datazone_batch_put_attributes_metadata

#' Cancels the metadata generation run
#'
#' @description
#' Cancels the metadata generation run.
#' 
#' Prerequisites:
#' 
#' -   The run must exist and be in a cancelable status (e.g., SUBMITTED,
#'     IN_PROGRESS).
#' 
#' -   Runs in SUCCEEDED status cannot be cancelled.
#' 
#' -   User must have access to the run and cancel permissions.
#'
#' @usage
#' datazone_cancel_metadata_generation_run(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the metadata generation
#' run is to be cancelled.
#' @param identifier &#91;required&#93; The ID of the metadata generation run.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_metadata_generation_run(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_cancel_metadata_generation_run
#'
#' @aliases datazone_cancel_metadata_generation_run
datazone_cancel_metadata_generation_run <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "CancelMetadataGenerationRun",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/metadata-generation-runs/{identifier}/cancel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$cancel_metadata_generation_run_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$cancel_metadata_generation_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$cancel_metadata_generation_run <- datazone_cancel_metadata_generation_run

#' Cancels the subscription to the specified asset
#'
#' @description
#' Cancels the subscription to the specified asset.
#'
#' @usage
#' datazone_cancel_subscription(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The unique identifier of the Amazon DataZone domain where the
#' subscription request is being cancelled.
#' @param identifier &#91;required&#93; The unique identifier of the subscription that is being cancelled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   id = "string",
#'   retainPermissions = TRUE|FALSE,
#'   status = "APPROVED"|"REVOKED"|"CANCELLED",
#'   subscribedListing = list(
#'     description = "string",
#'     id = "string",
#'     item = list(
#'       assetListing = list(
#'         assetScope = list(
#'           assetId = "string",
#'           errorMessage = "string",
#'           filterIds = list(
#'             "string"
#'           ),
#'           status = "string"
#'         ),
#'         entityId = "string",
#'         entityRevision = "string",
#'         entityType = "string",
#'         forms = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         permissions = list(
#'           s3 = list(
#'             "READ"|"WRITE"
#'           )
#'         )
#'       ),
#'       productListing = list(
#'         assetListings = list(
#'           list(
#'             entityId = "string",
#'             entityRevision = "string",
#'             entityType = "string"
#'           )
#'         ),
#'         description = "string",
#'         entityId = "string",
#'         entityRevision = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         name = "string"
#'       )
#'     ),
#'     name = "string",
#'     ownerProjectId = "string",
#'     ownerProjectName = "string",
#'     revision = "string"
#'   ),
#'   subscribedPrincipal = list(
#'     group = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     project = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     user = list(
#'       details = list(
#'         iam = list(
#'           arn = "string",
#'           principalId = "string"
#'         ),
#'         sso = list(
#'           firstName = "string",
#'           lastName = "string",
#'           username = "string"
#'         )
#'       ),
#'       id = "string"
#'     )
#'   ),
#'   subscriptionRequestId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_subscription(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_cancel_subscription
#'
#' @aliases datazone_cancel_subscription
datazone_cancel_subscription <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "CancelSubscription",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/cancel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$cancel_subscription_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$cancel_subscription_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$cancel_subscription <- datazone_cancel_subscription

#' Creates an account pool
#'
#' @description
#' Creates an account pool.
#'
#' @usage
#' datazone_create_account_pool(accountSource, description,
#'   domainIdentifier, name, resolutionStrategy)
#'
#' @param accountSource &#91;required&#93; The source of accounts for the account pool. In the current release,
#' it's either a static list of accounts provided by the customer or a
#' custom Amazon Web Services Lambda handler.
#' @param description The description of the account pool.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the account pool is created.
#' @param name &#91;required&#93; The name of the account pool.
#' @param resolutionStrategy &#91;required&#93; The mechanism used to resolve the account selection from the account
#' pool.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accountSource = list(
#'     accounts = list(
#'       list(
#'         awsAccountId = "string",
#'         awsAccountName = "string",
#'         supportedRegions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     customAccountPoolHandler = list(
#'       lambdaExecutionRoleArn = "string",
#'       lambdaFunctionArn = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   resolutionStrategy = "MANUAL",
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_account_pool(
#'   accountSource = list(
#'     accounts = list(
#'       list(
#'         awsAccountId = "string",
#'         awsAccountName = "string",
#'         supportedRegions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     customAccountPoolHandler = list(
#'       lambdaExecutionRoleArn = "string",
#'       lambdaFunctionArn = "string"
#'     )
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   name = "string",
#'   resolutionStrategy = "MANUAL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_account_pool
#'
#' @aliases datazone_create_account_pool
datazone_create_account_pool <- function(accountSource, description = NULL, domainIdentifier, name, resolutionStrategy) {
  op <- new_operation(
    name = "CreateAccountPool",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/account-pools",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_account_pool_input(accountSource = accountSource, description = description, domainIdentifier = domainIdentifier, name = name, resolutionStrategy = resolutionStrategy)
  output <- .datazone$create_account_pool_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_account_pool <- datazone_create_account_pool

#' Creates an asset in Amazon DataZone catalog
#'
#' @description
#' Creates an asset in Amazon DataZone catalog.
#' 
#' Before creating assets, make sure that the following requirements are
#' met:
#' 
#' -   `--domain-identifier` must refer to an existing domain.
#' 
#' -   `--owning-project-identifier` must be a valid project within the
#'     domain.
#' 
#' -   Asset type must be created beforehand using `create-asset-type`, or
#'     be a supported system-defined type. For more information, see
#'     [create-asset-type](https://docs.aws.amazon.com/cli/latest/reference/datazone/create-asset-type.html).
#' 
#' -   `--type-revision` (if used) must match a valid revision of the asset
#'     type.
#' 
#' -   `formsInput` is required when it is associated as required in the
#'     `asset-type`. For more information, see
#'     [create-form-type](https://docs.aws.amazon.com/cli/latest/reference/datazone/create-form-type.html).
#' 
#' -   Form content must include all required fields as per the form schema
#'     (e.g., `bucketArn`).
#' 
#' You must invoke the following pre-requisite commands before invoking
#' this API:
#' 
#' -   [`create_form_type`][datazone_create_form_type]
#' 
#' -   [`create_asset_type`][datazone_create_asset_type]
#'
#' @usage
#' datazone_create_asset(clientToken, description, domainIdentifier,
#'   externalIdentifier, formsInput, glossaryTerms, name,
#'   owningProjectIdentifier, predictionConfiguration, typeIdentifier,
#'   typeRevision)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description Asset description.
#' @param domainIdentifier &#91;required&#93; Amazon DataZone domain where the asset is created.
#' @param externalIdentifier The external identifier of the asset.
#' 
#' If the value for the `externalIdentifier` parameter is specified, it
#' must be a unique value.
#' @param formsInput Metadata forms attached to the asset.
#' @param glossaryTerms Glossary terms attached to the asset.
#' @param name &#91;required&#93; Asset name.
#' @param owningProjectIdentifier &#91;required&#93; The unique identifier of the project that owns this asset.
#' @param predictionConfiguration The configuration of the automatically generated business-friendly
#' metadata for the asset.
#' @param typeIdentifier &#91;required&#93; The unique identifier of this asset's type.
#' @param typeRevision The revision of this asset's type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   externalIdentifier = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   governedGlossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   latestTimeSeriesDataPointFormsOutput = list(
#'     list(
#'       contentSummary = "string",
#'       formName = "string",
#'       id = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   listing = list(
#'     listingId = "string",
#'     listingStatus = "CREATING"|"ACTIVE"|"INACTIVE"
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   predictionConfiguration = list(
#'     businessNameGeneration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   readOnlyFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   revision = "string",
#'   typeIdentifier = "string",
#'   typeRevision = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_asset(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   externalIdentifier = "string",
#'   formsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   name = "string",
#'   owningProjectIdentifier = "string",
#'   predictionConfiguration = list(
#'     businessNameGeneration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   typeIdentifier = "string",
#'   typeRevision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_asset
#'
#' @aliases datazone_create_asset
datazone_create_asset <- function(clientToken = NULL, description = NULL, domainIdentifier, externalIdentifier = NULL, formsInput = NULL, glossaryTerms = NULL, name, owningProjectIdentifier, predictionConfiguration = NULL, typeIdentifier, typeRevision = NULL) {
  op <- new_operation(
    name = "CreateAsset",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/assets",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_asset_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, externalIdentifier = externalIdentifier, formsInput = formsInput, glossaryTerms = glossaryTerms, name = name, owningProjectIdentifier = owningProjectIdentifier, predictionConfiguration = predictionConfiguration, typeIdentifier = typeIdentifier, typeRevision = typeRevision)
  output <- .datazone$create_asset_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_asset <- datazone_create_asset

#' Creates a data asset filter
#'
#' @description
#' Creates a data asset filter.
#' 
#' Asset filters provide a sophisticated way to create controlled views of
#' data assets by selecting specific columns or applying row-level filters.
#' This capability is crucial for organizations that need to share data
#' while maintaining security and privacy controls. For example, your
#' database might be filtered to show only non-PII fields to certain users,
#' or sales data might be filtered by region for different regional teams.
#' Asset filters enable fine-grained access control while maintaining a
#' single source of truth.
#' 
#' Prerequisites:
#' 
#' -   A valid domain (`--domain-identifier`) must exist.
#' 
#' -   A data asset (`--asset-identifier`) must already be created under
#'     that domain.
#' 
#' -   The asset must have the referenced columns available in its schema
#'     for column-based filtering.
#' 
#' -   You cannot specify both (`columnConfiguration`,
#'     `rowConfiguration`)at the same time.
#'
#' @usage
#' datazone_create_asset_filter(assetIdentifier, clientToken,
#'   configuration, description, domainIdentifier, name)
#'
#' @param assetIdentifier &#91;required&#93; The ID of the data asset.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param configuration &#91;required&#93; The configuration of the asset filter.
#' @param description The description of the asset filter.
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which you want to create an asset filter.
#' @param name &#91;required&#93; The name of the asset filter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetId = "string",
#'   configuration = list(
#'     columnConfiguration = list(
#'       includedColumnNames = list(
#'         "string"
#'       )
#'     ),
#'     rowConfiguration = list(
#'       rowFilter = list(
#'         and = list(
#'           list()
#'         ),
#'         expression = list(
#'           equalTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           in = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           isNotNull = list(
#'             columnName = "string"
#'           ),
#'           isNull = list(
#'             columnName = "string"
#'           ),
#'           lessThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           lessThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           like = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notIn = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           notLike = list(
#'             columnName = "string",
#'             value = "string"
#'           )
#'         ),
#'         or = list(
#'           list()
#'         )
#'       ),
#'       sensitive = TRUE|FALSE
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   effectiveColumnNames = list(
#'     "string"
#'   ),
#'   effectiveRowFilter = "string",
#'   errorMessage = "string",
#'   id = "string",
#'   name = "string",
#'   status = "VALID"|"INVALID"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_asset_filter(
#'   assetIdentifier = "string",
#'   clientToken = "string",
#'   configuration = list(
#'     columnConfiguration = list(
#'       includedColumnNames = list(
#'         "string"
#'       )
#'     ),
#'     rowConfiguration = list(
#'       rowFilter = list(
#'         and = list(
#'           list()
#'         ),
#'         expression = list(
#'           equalTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           in = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           isNotNull = list(
#'             columnName = "string"
#'           ),
#'           isNull = list(
#'             columnName = "string"
#'           ),
#'           lessThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           lessThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           like = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notIn = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           notLike = list(
#'             columnName = "string",
#'             value = "string"
#'           )
#'         ),
#'         or = list(
#'           list()
#'         )
#'       ),
#'       sensitive = TRUE|FALSE
#'     )
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_asset_filter
#'
#' @aliases datazone_create_asset_filter
datazone_create_asset_filter <- function(assetIdentifier, clientToken = NULL, configuration, description = NULL, domainIdentifier, name) {
  op <- new_operation(
    name = "CreateAssetFilter",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_asset_filter_input(assetIdentifier = assetIdentifier, clientToken = clientToken, configuration = configuration, description = description, domainIdentifier = domainIdentifier, name = name)
  output <- .datazone$create_asset_filter_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_asset_filter <- datazone_create_asset_filter

#' Creates a revision of the asset
#'
#' @description
#' Creates a revision of the asset.
#' 
#' Asset revisions represent new versions of existing assets, capturing
#' changes to either the underlying data or its metadata. They maintain a
#' historical record of how assets evolve over time, who made changes, and
#' when those changes occurred. This versioning capability is crucial for
#' governance and compliance, allowing organizations to track changes,
#' understand their impact, and roll back if necessary.
#' 
#' Prerequisites:
#' 
#' -   Asset must already exist in the domain with identifier.
#' 
#' -   `formsInput` is required when asset has the form type.
#'     `typeRevision` should be the latest version of form type.
#' 
#' -   The form content must include all required fields (e.g., `bucketArn`
#'     for `S3ObjectCollectionForm`).
#' 
#' -   The owning project of the original asset must still exist and be
#'     active.
#' 
#' -   User must have write access to the project and domain.
#'
#' @usage
#' datazone_create_asset_revision(clientToken, description,
#'   domainIdentifier, formsInput, glossaryTerms, identifier, name,
#'   predictionConfiguration, typeRevision)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The revised description of the asset.
#' @param domainIdentifier &#91;required&#93; The unique identifier of the domain where the asset is being revised.
#' @param formsInput The metadata forms to be attached to the asset as part of asset
#' revision.
#' @param glossaryTerms The glossary terms to be attached to the asset as part of asset
#' revision.
#' @param identifier &#91;required&#93; The identifier of the asset.
#' @param name &#91;required&#93; Te revised name of the asset.
#' @param predictionConfiguration The configuration of the automatically generated business-friendly
#' metadata for the asset.
#' @param typeRevision The revision type of the asset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   externalIdentifier = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   governedGlossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   latestTimeSeriesDataPointFormsOutput = list(
#'     list(
#'       contentSummary = "string",
#'       formName = "string",
#'       id = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   listing = list(
#'     listingId = "string",
#'     listingStatus = "CREATING"|"ACTIVE"|"INACTIVE"
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   predictionConfiguration = list(
#'     businessNameGeneration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   readOnlyFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   revision = "string",
#'   typeIdentifier = "string",
#'   typeRevision = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_asset_revision(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   formsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   identifier = "string",
#'   name = "string",
#'   predictionConfiguration = list(
#'     businessNameGeneration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   typeRevision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_asset_revision
#'
#' @aliases datazone_create_asset_revision
datazone_create_asset_revision <- function(clientToken = NULL, description = NULL, domainIdentifier, formsInput = NULL, glossaryTerms = NULL, identifier, name, predictionConfiguration = NULL, typeRevision = NULL) {
  op <- new_operation(
    name = "CreateAssetRevision",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}/revisions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_asset_revision_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, formsInput = formsInput, glossaryTerms = glossaryTerms, identifier = identifier, name = name, predictionConfiguration = predictionConfiguration, typeRevision = typeRevision)
  output <- .datazone$create_asset_revision_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_asset_revision <- datazone_create_asset_revision

#' Creates a custom asset type
#'
#' @description
#' Creates a custom asset type.
#' 
#' Prerequisites:
#' 
#' -   The `formsInput` field is required, however, can be passed as empty
#'     (e.g. `-forms-input {})`.
#' 
#' -   You must have [`create_asset_type`][datazone_create_asset_type]
#'     permissions.
#' 
#' -   The domain-identifier and owning-project-identifier must be valid
#'     and active.
#' 
#' -   The name of the asset type must be unique within the domain 
#'     duplicate names will cause failure.
#' 
#' -   JSON input must be valid  incorrect formatting causes Invalid JSON
#'     errors.
#'
#' @usage
#' datazone_create_asset_type(description, domainIdentifier, formsInput,
#'   name, owningProjectIdentifier)
#'
#' @param description The descripton of the custom asset type.
#' @param domainIdentifier &#91;required&#93; The unique identifier of the Amazon DataZone domain where the custom
#' asset type is being created.
#' @param formsInput &#91;required&#93; The metadata forms that are to be attached to the custom asset type.
#' @param name &#91;required&#93; The name of the custom asset type.
#' @param owningProjectIdentifier &#91;required&#93; The identifier of the Amazon DataZone project that is to own the custom
#' asset type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   formsOutput = list(
#'     list(
#'       required = TRUE|FALSE,
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   name = "string",
#'   originDomainId = "string",
#'   originProjectId = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_asset_type(
#'   description = "string",
#'   domainIdentifier = "string",
#'   formsInput = list(
#'     list(
#'       required = TRUE|FALSE,
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   name = "string",
#'   owningProjectIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_asset_type
#'
#' @aliases datazone_create_asset_type
datazone_create_asset_type <- function(description = NULL, domainIdentifier, formsInput, name, owningProjectIdentifier) {
  op <- new_operation(
    name = "CreateAssetType",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/asset-types",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_asset_type_input(description = description, domainIdentifier = domainIdentifier, formsInput = formsInput, name = name, owningProjectIdentifier = owningProjectIdentifier)
  output <- .datazone$create_asset_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_asset_type <- datazone_create_asset_type

#' Creates a new connection
#'
#' @description
#' Creates a new connection. In Amazon DataZone, a connection enables you
#' to connect your resources (domains, projects, and environments) to
#' external resources and services.
#'
#' @usage
#' datazone_create_connection(awsLocation, clientToken, description,
#'   domainIdentifier, enableTrustedIdentityPropagation,
#'   environmentIdentifier, name, props, scope)
#'
#' @param awsLocation The location where the connection is created.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description A connection description.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the connection is created.
#' @param enableTrustedIdentityPropagation Specifies whether the trusted identity propagation is enabled.
#' @param environmentIdentifier The ID of the environment where the connection is created.
#' @param name &#91;required&#93; The connection name.
#' @param props The connection props.
#' @param scope The scope of the connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   connectionId = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentId = "string",
#'   name = "string",
#'   physicalEndpoints = list(
#'     list(
#'       awsLocation = list(
#'         accessRole = "string",
#'         awsAccountId = "string",
#'         awsRegion = "string",
#'         iamConnectionId = "string"
#'       ),
#'       enableTrustedIdentityPropagation = TRUE|FALSE,
#'       glueConnection = list(
#'         athenaProperties = list(
#'           "string"
#'         ),
#'         authenticationConfiguration = list(
#'           authenticationType = "BASIC"|"OAUTH2"|"CUSTOM",
#'           oAuth2Properties = list(
#'             authorizationCodeProperties = list(
#'               authorizationCode = "string",
#'               redirectUri = "string"
#'             ),
#'             oAuth2ClientApplication = list(
#'               aWSManagedClientApplicationReference = "string",
#'               userManagedClientApplicationClientId = "string"
#'             ),
#'             oAuth2Credentials = list(
#'               accessToken = "string",
#'               jwtToken = "string",
#'               refreshToken = "string",
#'               userManagedClientApplicationClientSecret = "string"
#'             ),
#'             oAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'             tokenUrl = "string",
#'             tokenUrlParametersMap = list(
#'               "string"
#'             )
#'           ),
#'           secretArn = "string"
#'         ),
#'         compatibleComputeEnvironments = list(
#'           "SPARK"|"ATHENA"|"PYTHON"
#'         ),
#'         connectionProperties = list(
#'           "string"
#'         ),
#'         connectionSchemaVersion = 123,
#'         connectionType = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW",
#'         creationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         description = "string",
#'         lastConnectionValidationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         lastUpdatedBy = "string",
#'         lastUpdatedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         matchCriteria = list(
#'           "string"
#'         ),
#'         name = "string",
#'         physicalConnectionRequirements = list(
#'           availabilityZone = "string",
#'           securityGroupIdList = list(
#'             "string"
#'           ),
#'           subnetId = "string",
#'           subnetIdList = list(
#'             "string"
#'           )
#'         ),
#'         pythonProperties = list(
#'           "string"
#'         ),
#'         sparkProperties = list(
#'           "string"
#'         ),
#'         status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'         statusReason = "string"
#'       ),
#'       glueConnectionName = "string",
#'       host = "string",
#'       port = 123,
#'       protocol = "ATHENA"|"GLUE_INTERACTIVE_SESSION"|"HTTPS"|"JDBC"|"LIVY"|"ODBC"|"PRISM",
#'       stage = "string"
#'     )
#'   ),
#'   projectId = "string",
#'   props = list(
#'     amazonQProperties = list(
#'       authMode = "string",
#'       isEnabled = TRUE|FALSE,
#'       profileArn = "string"
#'     ),
#'     athenaProperties = list(
#'       workgroupName = "string"
#'     ),
#'     glueProperties = list(
#'       errorMessage = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     hyperPodProperties = list(
#'       clusterArn = "string",
#'       clusterName = "string",
#'       orchestrator = "EKS"|"SLURM"
#'     ),
#'     iamProperties = list(
#'       environmentId = "string",
#'       glueLineageSyncEnabled = TRUE|FALSE
#'     ),
#'     mlflowProperties = list(
#'       trackingServerArn = "string"
#'     ),
#'     redshiftProperties = list(
#'       credentials = list(
#'         secretArn = "string",
#'         usernamePassword = list(
#'           password = "string",
#'           username = "string"
#'         )
#'       ),
#'       databaseName = "string",
#'       isProvisionedSecret = TRUE|FALSE,
#'       jdbcIamUrl = "string",
#'       jdbcUrl = "string",
#'       lineageSync = list(
#'         enabled = TRUE|FALSE,
#'         lineageJobId = "string",
#'         schedule = list(
#'           schedule = "string"
#'         )
#'       ),
#'       redshiftTempDir = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'       storage = list(
#'         clusterName = "string",
#'         workgroupName = "string"
#'       )
#'     ),
#'     s3Properties = list(
#'       errorMessage = "string",
#'       s3AccessGrantLocationId = "string",
#'       s3Uri = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     sparkEmrProperties = list(
#'       certificateData = "string",
#'       computeArn = "string",
#'       credentials = list(
#'         password = "string",
#'         username = "string"
#'       ),
#'       credentialsExpiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       governanceType = "AWS_MANAGED"|"USER_MANAGED",
#'       instanceProfileArn = "string",
#'       javaVirtualEnv = "string",
#'       livyEndpoint = "string",
#'       logUri = "string",
#'       managedEndpointArn = "string",
#'       managedEndpointCredentials = list(
#'         id = "string",
#'         token = "string"
#'       ),
#'       pythonVirtualEnv = "string",
#'       runtimeRole = "string",
#'       trustedCertificatesS3Uri = "string"
#'     ),
#'     sparkGlueProperties = list(
#'       additionalArgs = list(
#'         connection = "string"
#'       ),
#'       glueConnectionName = "string",
#'       glueVersion = "string",
#'       idleTimeout = 123,
#'       javaVirtualEnv = "string",
#'       numberOfWorkers = 123,
#'       pythonVirtualEnv = "string",
#'       workerType = "string"
#'     )
#'   ),
#'   scope = "DOMAIN"|"PROJECT",
#'   type = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_connection(
#'   awsLocation = list(
#'     accessRole = "string",
#'     awsAccountId = "string",
#'     awsRegion = "string",
#'     iamConnectionId = "string"
#'   ),
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   enableTrustedIdentityPropagation = TRUE|FALSE,
#'   environmentIdentifier = "string",
#'   name = "string",
#'   props = list(
#'     amazonQProperties = list(
#'       authMode = "string",
#'       isEnabled = TRUE|FALSE,
#'       profileArn = "string"
#'     ),
#'     athenaProperties = list(
#'       workgroupName = "string"
#'     ),
#'     glueProperties = list(
#'       glueConnectionInput = list(
#'         athenaProperties = list(
#'           "string"
#'         ),
#'         authenticationConfiguration = list(
#'           authenticationType = "BASIC"|"OAUTH2"|"CUSTOM",
#'           basicAuthenticationCredentials = list(
#'             password = "string",
#'             userName = "string"
#'           ),
#'           customAuthenticationCredentials = list(
#'             "string"
#'           ),
#'           kmsKeyArn = "string",
#'           oAuth2Properties = list(
#'             authorizationCodeProperties = list(
#'               authorizationCode = "string",
#'               redirectUri = "string"
#'             ),
#'             oAuth2ClientApplication = list(
#'               aWSManagedClientApplicationReference = "string",
#'               userManagedClientApplicationClientId = "string"
#'             ),
#'             oAuth2Credentials = list(
#'               accessToken = "string",
#'               jwtToken = "string",
#'               refreshToken = "string",
#'               userManagedClientApplicationClientSecret = "string"
#'             ),
#'             oAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'             tokenUrl = "string",
#'             tokenUrlParametersMap = list(
#'               "string"
#'             )
#'           ),
#'           secretArn = "string"
#'         ),
#'         connectionProperties = list(
#'           "string"
#'         ),
#'         connectionType = "SNOWFLAKE"|"BIGQUERY"|"DOCUMENTDB"|"DYNAMODB"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"SAPHANA"|"SQLSERVER"|"TERADATA"|"VERTICA",
#'         description = "string",
#'         matchCriteria = "string",
#'         name = "string",
#'         physicalConnectionRequirements = list(
#'           availabilityZone = "string",
#'           securityGroupIdList = list(
#'             "string"
#'           ),
#'           subnetId = "string",
#'           subnetIdList = list(
#'             "string"
#'           )
#'         ),
#'         pythonProperties = list(
#'           "string"
#'         ),
#'         sparkProperties = list(
#'           "string"
#'         ),
#'         validateCredentials = TRUE|FALSE,
#'         validateForComputeEnvironments = list(
#'           "SPARK"|"ATHENA"|"PYTHON"
#'         )
#'       )
#'     ),
#'     hyperPodProperties = list(
#'       clusterName = "string"
#'     ),
#'     iamProperties = list(
#'       glueLineageSyncEnabled = TRUE|FALSE
#'     ),
#'     mlflowProperties = list(
#'       trackingServerArn = "string"
#'     ),
#'     redshiftProperties = list(
#'       credentials = list(
#'         secretArn = "string",
#'         usernamePassword = list(
#'           password = "string",
#'           username = "string"
#'         )
#'       ),
#'       databaseName = "string",
#'       host = "string",
#'       lineageSync = list(
#'         enabled = TRUE|FALSE,
#'         schedule = list(
#'           schedule = "string"
#'         )
#'       ),
#'       port = 123,
#'       storage = list(
#'         clusterName = "string",
#'         workgroupName = "string"
#'       )
#'     ),
#'     s3Properties = list(
#'       s3AccessGrantLocationId = "string",
#'       s3Uri = "string"
#'     ),
#'     sparkEmrProperties = list(
#'       computeArn = "string",
#'       instanceProfileArn = "string",
#'       javaVirtualEnv = "string",
#'       logUri = "string",
#'       managedEndpointArn = "string",
#'       pythonVirtualEnv = "string",
#'       runtimeRole = "string",
#'       trustedCertificatesS3Uri = "string"
#'     ),
#'     sparkGlueProperties = list(
#'       additionalArgs = list(
#'         connection = "string"
#'       ),
#'       glueConnectionName = "string",
#'       glueVersion = "string",
#'       idleTimeout = 123,
#'       javaVirtualEnv = "string",
#'       numberOfWorkers = 123,
#'       pythonVirtualEnv = "string",
#'       workerType = "string"
#'     )
#'   ),
#'   scope = "DOMAIN"|"PROJECT"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_connection
#'
#' @aliases datazone_create_connection
datazone_create_connection <- function(awsLocation = NULL, clientToken = NULL, description = NULL, domainIdentifier, enableTrustedIdentityPropagation = NULL, environmentIdentifier = NULL, name, props = NULL, scope = NULL) {
  op <- new_operation(
    name = "CreateConnection",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/connections",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_connection_input(awsLocation = awsLocation, clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, enableTrustedIdentityPropagation = enableTrustedIdentityPropagation, environmentIdentifier = environmentIdentifier, name = name, props = props, scope = scope)
  output <- .datazone$create_connection_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_connection <- datazone_create_connection

#' Creates a data product
#'
#' @description
#' Creates a data product.
#' 
#' A data product is a comprehensive package that combines data assets with
#' their associated metadata, documentation, and access controls. It's
#' designed to serve specific business needs or use cases, making it easier
#' for users to find and consume data appropriately. Data products include
#' important information about data quality, freshness, and usage
#' guidelines, effectively bridging the gap between data producers and
#' consumers while ensuring proper governance.
#' 
#' Prerequisites:
#' 
#' -   The domain must exist and be accessible.
#' 
#' -   The owning project must be valid and active.
#' 
#' -   The name must be unique within the domain (no existing data product
#'     with the same name).
#' 
#' -   User must have create permissions for data products in the project.
#'
#' @usage
#' datazone_create_data_product(clientToken, description, domainIdentifier,
#'   formsInput, glossaryTerms, items, name, owningProjectIdentifier)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of the data product.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the data product is created.
#' @param formsInput The metadata forms of the data product.
#' @param glossaryTerms The glossary terms of the data product.
#' @param items The data assets of the data product.
#' @param name &#91;required&#93; The name of the data product.
#' @param owningProjectIdentifier &#91;required&#93; The ID of the owning project of the data product.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   items = list(
#'     list(
#'       glossaryTerms = list(
#'         "string"
#'       ),
#'       identifier = "string",
#'       itemType = "ASSET",
#'       revision = "string"
#'     )
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   status = "CREATED"|"CREATING"|"CREATE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_product(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   formsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   items = list(
#'     list(
#'       glossaryTerms = list(
#'         "string"
#'       ),
#'       identifier = "string",
#'       itemType = "ASSET",
#'       revision = "string"
#'     )
#'   ),
#'   name = "string",
#'   owningProjectIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_data_product
#'
#' @aliases datazone_create_data_product
datazone_create_data_product <- function(clientToken = NULL, description = NULL, domainIdentifier, formsInput = NULL, glossaryTerms = NULL, items = NULL, name, owningProjectIdentifier) {
  op <- new_operation(
    name = "CreateDataProduct",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/data-products",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_data_product_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, formsInput = formsInput, glossaryTerms = glossaryTerms, items = items, name = name, owningProjectIdentifier = owningProjectIdentifier)
  output <- .datazone$create_data_product_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_data_product <- datazone_create_data_product

#' Creates a data product revision
#'
#' @description
#' Creates a data product revision.
#' 
#' Prerequisites:
#' 
#' -   The original data product must exist in the given domain.
#' 
#' -   User must have permissions on the data product.
#' 
#' -   The domain must be valid and accessible.
#' 
#' -   The new revision name must comply with naming constraints (if
#'     required).
#'
#' @usage
#' datazone_create_data_product_revision(clientToken, description,
#'   domainIdentifier, formsInput, glossaryTerms, identifier, items, name)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of the data product revision.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the data product revision is created.
#' @param formsInput The metadata forms of the data product revision.
#' @param glossaryTerms The glossary terms of the data product revision.
#' @param identifier &#91;required&#93; The ID of the data product revision.
#' @param items The data assets of the data product revision.
#' @param name &#91;required&#93; The name of the data product revision.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   items = list(
#'     list(
#'       glossaryTerms = list(
#'         "string"
#'       ),
#'       identifier = "string",
#'       itemType = "ASSET",
#'       revision = "string"
#'     )
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   status = "CREATED"|"CREATING"|"CREATE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_product_revision(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   formsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   identifier = "string",
#'   items = list(
#'     list(
#'       glossaryTerms = list(
#'         "string"
#'       ),
#'       identifier = "string",
#'       itemType = "ASSET",
#'       revision = "string"
#'     )
#'   ),
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_data_product_revision
#'
#' @aliases datazone_create_data_product_revision
datazone_create_data_product_revision <- function(clientToken = NULL, description = NULL, domainIdentifier, formsInput = NULL, glossaryTerms = NULL, identifier, items = NULL, name) {
  op <- new_operation(
    name = "CreateDataProductRevision",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/data-products/{identifier}/revisions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_data_product_revision_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, formsInput = formsInput, glossaryTerms = glossaryTerms, identifier = identifier, items = items, name = name)
  output <- .datazone$create_data_product_revision_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_data_product_revision <- datazone_create_data_product_revision

#' Creates an Amazon DataZone data source
#'
#' @description
#' Creates an Amazon DataZone data source.
#'
#' @usage
#' datazone_create_data_source(assetFormsInput, clientToken, configuration,
#'   connectionIdentifier, description, domainIdentifier, enableSetting,
#'   environmentIdentifier, name, projectIdentifier, publishOnImport,
#'   recommendation, schedule, type)
#'
#' @param assetFormsInput The metadata forms that are to be attached to the assets that this data
#' source works with.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param configuration Specifies the configuration of the data source. It can be set to either
#' `glueRunConfiguration` or `redshiftRunConfiguration`.
#' @param connectionIdentifier The ID of the connection.
#' @param description The description of the data source.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where the data source is created.
#' @param enableSetting Specifies whether the data source is enabled.
#' @param environmentIdentifier The unique identifier of the Amazon DataZone environment to which the
#' data source publishes assets.
#' @param name &#91;required&#93; The name of the data source.
#' @param projectIdentifier &#91;required&#93; The identifier of the Amazon DataZone project in which you want to add
#' this data source.
#' @param publishOnImport Specifies whether the assets that this data source creates in the
#' inventory are to be also automatically published to the catalog.
#' @param recommendation Specifies whether the business name generation is to be enabled for this
#' data source.
#' @param schedule The schedule of the data source runs.
#' @param type &#91;required&#93; The type of the data source. In Amazon DataZone, you can use data
#' sources to import technical metadata of assets (data) from the source
#' databases or data warehouses into Amazon DataZone. In the current
#' release of Amazon DataZone, you can create and run data sources for
#' Amazon Web Services Glue and Amazon Redshift.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       accountId = "string",
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       accountId = "string",
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       accountId = "string",
#'       region = "string",
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   connectionId = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   environmentId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   lastRunAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastRunErrorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   lastRunStatus = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   name = "string",
#'   projectId = "string",
#'   publishOnImport = TRUE|FALSE,
#'   recommendation = list(
#'     enableBusinessNameGeneration = TRUE|FALSE
#'   ),
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   ),
#'   status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_data_source(
#'   assetFormsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   clientToken = "string",
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   connectionIdentifier = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   environmentIdentifier = "string",
#'   name = "string",
#'   projectIdentifier = "string",
#'   publishOnImport = TRUE|FALSE,
#'   recommendation = list(
#'     enableBusinessNameGeneration = TRUE|FALSE
#'   ),
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   ),
#'   type = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_data_source
#'
#' @aliases datazone_create_data_source
datazone_create_data_source <- function(assetFormsInput = NULL, clientToken = NULL, configuration = NULL, connectionIdentifier = NULL, description = NULL, domainIdentifier, enableSetting = NULL, environmentIdentifier = NULL, name, projectIdentifier, publishOnImport = NULL, recommendation = NULL, schedule = NULL, type) {
  op <- new_operation(
    name = "CreateDataSource",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/data-sources",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_data_source_input(assetFormsInput = assetFormsInput, clientToken = clientToken, configuration = configuration, connectionIdentifier = connectionIdentifier, description = description, domainIdentifier = domainIdentifier, enableSetting = enableSetting, environmentIdentifier = environmentIdentifier, name = name, projectIdentifier = projectIdentifier, publishOnImport = publishOnImport, recommendation = recommendation, schedule = schedule, type = type)
  output <- .datazone$create_data_source_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_data_source <- datazone_create_data_source

#' Creates an Amazon DataZone domain
#'
#' @description
#' Creates an Amazon DataZone domain.
#'
#' @usage
#' datazone_create_domain(clientToken, description, domainExecutionRole,
#'   domainVersion, kmsKeyIdentifier, name, serviceRole, singleSignOn, tags)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of the Amazon DataZone domain.
#' @param domainExecutionRole &#91;required&#93; The domain execution role that is created when an Amazon DataZone domain
#' is created. The domain execution role is created in the Amazon Web
#' Services account that houses the Amazon DataZone domain.
#' @param domainVersion The version of the domain that is created.
#' @param kmsKeyIdentifier The identifier of the Amazon Web Services Key Management Service (KMS)
#' key that is used to encrypt the Amazon DataZone domain, metadata, and
#' reporting data.
#' @param name &#91;required&#93; The name of the Amazon DataZone domain.
#' @param serviceRole The service role of the domain that is created.
#' @param singleSignOn The single-sign on configuration of the Amazon DataZone domain.
#' @param tags The tags specified for the Amazon DataZone domain.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   description = "string",
#'   domainExecutionRole = "string",
#'   domainVersion = "V1"|"V2",
#'   id = "string",
#'   kmsKeyIdentifier = "string",
#'   name = "string",
#'   portalUrl = "string",
#'   rootDomainUnitId = "string",
#'   serviceRole = "string",
#'   singleSignOn = list(
#'     idcInstanceArn = "string",
#'     type = "IAM_IDC"|"DISABLED",
#'     userAssignment = "AUTOMATIC"|"MANUAL"
#'   ),
#'   status = "CREATING"|"AVAILABLE"|"CREATION_FAILED"|"DELETING"|"DELETED"|"DELETION_FAILED",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_domain(
#'   clientToken = "string",
#'   description = "string",
#'   domainExecutionRole = "string",
#'   domainVersion = "V1"|"V2",
#'   kmsKeyIdentifier = "string",
#'   name = "string",
#'   serviceRole = "string",
#'   singleSignOn = list(
#'     idcInstanceArn = "string",
#'     type = "IAM_IDC"|"DISABLED",
#'     userAssignment = "AUTOMATIC"|"MANUAL"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_domain
#'
#' @aliases datazone_create_domain
datazone_create_domain <- function(clientToken = NULL, description = NULL, domainExecutionRole, domainVersion = NULL, kmsKeyIdentifier = NULL, name, serviceRole = NULL, singleSignOn = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateDomain",
    http_method = "POST",
    http_path = "/v2/domains",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_domain_input(clientToken = clientToken, description = description, domainExecutionRole = domainExecutionRole, domainVersion = domainVersion, kmsKeyIdentifier = kmsKeyIdentifier, name = name, serviceRole = serviceRole, singleSignOn = singleSignOn, tags = tags)
  output <- .datazone$create_domain_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_domain <- datazone_create_domain

#' Creates a domain unit in Amazon DataZone
#'
#' @description
#' Creates a domain unit in Amazon DataZone.
#'
#' @usage
#' datazone_create_domain_unit(clientToken, description, domainIdentifier,
#'   name, parentDomainUnitIdentifier)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of the domain unit.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to crate a domain unit.
#' @param name &#91;required&#93; The name of the domain unit.
#' @param parentDomainUnitIdentifier &#91;required&#93; The ID of the parent domain unit.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ancestorDomainUnitIds = list(
#'     "string"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   name = "string",
#'   owners = list(
#'     list(
#'       group = list(
#'         groupId = "string"
#'       ),
#'       user = list(
#'         userId = "string"
#'       )
#'     )
#'   ),
#'   parentDomainUnitId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_domain_unit(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   name = "string",
#'   parentDomainUnitIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_domain_unit
#'
#' @aliases datazone_create_domain_unit
datazone_create_domain_unit <- function(clientToken = NULL, description = NULL, domainIdentifier, name, parentDomainUnitIdentifier) {
  op <- new_operation(
    name = "CreateDomainUnit",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/domain-units",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_domain_unit_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, name = name, parentDomainUnitIdentifier = parentDomainUnitIdentifier)
  output <- .datazone$create_domain_unit_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_domain_unit <- datazone_create_domain_unit

#' Create an Amazon DataZone environment
#'
#' @description
#' Create an Amazon DataZone environment.
#'
#' @usage
#' datazone_create_environment(deploymentOrder, description,
#'   domainIdentifier, environmentAccountIdentifier,
#'   environmentAccountRegion, environmentBlueprintIdentifier,
#'   environmentConfigurationId, environmentProfileIdentifier, glossaryTerms,
#'   name, projectIdentifier, userParameters)
#'
#' @param deploymentOrder The deployment order of the environment.
#' @param description The description of the Amazon DataZone environment.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which the environment is
#' created.
#' @param environmentAccountIdentifier The ID of the account in which the environment is being created.
#' @param environmentAccountRegion The region of the account in which the environment is being created.
#' @param environmentBlueprintIdentifier The ID of the blueprint with which the environment is being created.
#' @param environmentConfigurationId The configuration ID of the environment.
#' @param environmentProfileIdentifier The identifier of the environment profile that is used to create this
#' Amazon DataZone environment.
#' @param glossaryTerms The glossary terms that can be used in this Amazon DataZone environment.
#' @param name &#91;required&#93; The name of the Amazon DataZone environment.
#' @param projectIdentifier &#91;required&#93; The identifier of the Amazon DataZone project in which this environment
#' is created.
#' @param userParameters The user parameters of this Amazon DataZone environment.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   environmentActions = list(
#'     list(
#'       auth = "IAM"|"HTTPS",
#'       parameters = list(
#'         list(
#'           key = "string",
#'           value = "string"
#'         )
#'       ),
#'       type = "string"
#'     )
#'   ),
#'   environmentBlueprintId = "string",
#'   environmentConfigurationId = "string",
#'   environmentProfileId = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastDeployment = list(
#'     deploymentId = "string",
#'     deploymentStatus = "IN_PROGRESS"|"SUCCESSFUL"|"FAILED"|"PENDING_DEPLOYMENT",
#'     deploymentType = "CREATE"|"UPDATE"|"DELETE",
#'     failureReason = list(
#'       code = "string",
#'       message = "string"
#'     ),
#'     isDeploymentComplete = TRUE|FALSE,
#'     messages = list(
#'       "string"
#'     )
#'   ),
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   provisionedResources = list(
#'     list(
#'       name = "string",
#'       provider = "string",
#'       type = "string",
#'       value = "string"
#'     )
#'   ),
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   status = "ACTIVE"|"CREATING"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|"VALIDATION_FAILED"|"SUSPENDED"|"DISABLED"|"EXPIRED"|"DELETED"|"INACCESSIBLE",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_environment(
#'   deploymentOrder = 123,
#'   description = "string",
#'   domainIdentifier = "string",
#'   environmentAccountIdentifier = "string",
#'   environmentAccountRegion = "string",
#'   environmentBlueprintIdentifier = "string",
#'   environmentConfigurationId = "string",
#'   environmentProfileIdentifier = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   name = "string",
#'   projectIdentifier = "string",
#'   userParameters = list(
#'     list(
#'       name = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_environment
#'
#' @aliases datazone_create_environment
datazone_create_environment <- function(deploymentOrder = NULL, description = NULL, domainIdentifier, environmentAccountIdentifier = NULL, environmentAccountRegion = NULL, environmentBlueprintIdentifier = NULL, environmentConfigurationId = NULL, environmentProfileIdentifier = NULL, glossaryTerms = NULL, name, projectIdentifier, userParameters = NULL) {
  op <- new_operation(
    name = "CreateEnvironment",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/environments",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_environment_input(deploymentOrder = deploymentOrder, description = description, domainIdentifier = domainIdentifier, environmentAccountIdentifier = environmentAccountIdentifier, environmentAccountRegion = environmentAccountRegion, environmentBlueprintIdentifier = environmentBlueprintIdentifier, environmentConfigurationId = environmentConfigurationId, environmentProfileIdentifier = environmentProfileIdentifier, glossaryTerms = glossaryTerms, name = name, projectIdentifier = projectIdentifier, userParameters = userParameters)
  output <- .datazone$create_environment_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_environment <- datazone_create_environment

#' Creates an action for the environment, for example, creates a console
#' link for an analytics tool that is available in this environment
#'
#' @description
#' Creates an action for the environment, for example, creates a console
#' link for an analytics tool that is available in this environment.
#'
#' @usage
#' datazone_create_environment_action(description, domainIdentifier,
#'   environmentIdentifier, name, parameters)
#'
#' @param description The description of the environment action that is being created in the
#' environment.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the environment action is
#' created.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment in which the environment action is created.
#' @param name &#91;required&#93; The name of the environment action.
#' @param parameters &#91;required&#93; The parameters of the environment action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   name = "string",
#'   parameters = list(
#'     awsConsoleLink = list(
#'       uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_environment_action(
#'   description = "string",
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   name = "string",
#'   parameters = list(
#'     awsConsoleLink = list(
#'       uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_environment_action
#'
#' @aliases datazone_create_environment_action
datazone_create_environment_action <- function(description = NULL, domainIdentifier, environmentIdentifier, name, parameters) {
  op <- new_operation(
    name = "CreateEnvironmentAction",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_environment_action_input(description = description, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, name = name, parameters = parameters)
  output <- .datazone$create_environment_action_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_environment_action <- datazone_create_environment_action

#' Creates a Amazon DataZone blueprint
#'
#' @description
#' Creates a Amazon DataZone blueprint.
#'
#' @usage
#' datazone_create_environment_blueprint(description, domainIdentifier,
#'   name, provisioningProperties, userParameters)
#'
#' @param description The description of the Amazon DataZone blueprint.
#' @param domainIdentifier &#91;required&#93; The identifier of the domain in which this blueprint is created.
#' @param name &#91;required&#93; The name of this Amazon DataZone blueprint.
#' @param provisioningProperties &#91;required&#93; The provisioning properties of this Amazon DataZone blueprint.
#' @param userParameters The user parameters of this Amazon DataZone blueprint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   name = "string",
#'   provider = "string",
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_environment_blueprint(
#'   description = "string",
#'   domainIdentifier = "string",
#'   name = "string",
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_environment_blueprint
#'
#' @aliases datazone_create_environment_blueprint
datazone_create_environment_blueprint <- function(description = NULL, domainIdentifier, name, provisioningProperties, userParameters = NULL) {
  op <- new_operation(
    name = "CreateEnvironmentBlueprint",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprints",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_environment_blueprint_input(description = description, domainIdentifier = domainIdentifier, name = name, provisioningProperties = provisioningProperties, userParameters = userParameters)
  output <- .datazone$create_environment_blueprint_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_environment_blueprint <- datazone_create_environment_blueprint

#' Creates an Amazon DataZone environment profile
#'
#' @description
#' Creates an Amazon DataZone environment profile.
#'
#' @usage
#' datazone_create_environment_profile(awsAccountId, awsAccountRegion,
#'   description, domainIdentifier, environmentBlueprintIdentifier, name,
#'   projectIdentifier, userParameters)
#'
#' @param awsAccountId The Amazon Web Services account in which the Amazon DataZone environment
#' is created.
#' @param awsAccountRegion The Amazon Web Services region in which this environment profile is
#' created.
#' @param description The description of this Amazon DataZone environment profile.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this environment profile
#' is created.
#' @param environmentBlueprintIdentifier &#91;required&#93; The ID of the blueprint with which this environment profile is created.
#' @param name &#91;required&#93; The name of this Amazon DataZone environment profile.
#' @param projectIdentifier &#91;required&#93; The identifier of the project in which to create the environment
#' profile.
#' @param userParameters The user parameters of this Amazon DataZone environment profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   environmentBlueprintId = "string",
#'   id = "string",
#'   name = "string",
#'   projectId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_environment_profile(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   environmentBlueprintIdentifier = "string",
#'   name = "string",
#'   projectIdentifier = "string",
#'   userParameters = list(
#'     list(
#'       name = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_environment_profile
#'
#' @aliases datazone_create_environment_profile
datazone_create_environment_profile <- function(awsAccountId = NULL, awsAccountRegion = NULL, description = NULL, domainIdentifier, environmentBlueprintIdentifier, name, projectIdentifier, userParameters = NULL) {
  op <- new_operation(
    name = "CreateEnvironmentProfile",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/environment-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_environment_profile_input(awsAccountId = awsAccountId, awsAccountRegion = awsAccountRegion, description = description, domainIdentifier = domainIdentifier, environmentBlueprintIdentifier = environmentBlueprintIdentifier, name = name, projectIdentifier = projectIdentifier, userParameters = userParameters)
  output <- .datazone$create_environment_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_environment_profile <- datazone_create_environment_profile

#' Creates a metadata form type
#'
#' @description
#' Creates a metadata form type.
#' 
#' Prerequisites:
#' 
#' -   The domain must exist and be in an `ENABLED` state.
#' 
#' -   The owning project must exist and be accessible.
#' 
#' -   The name must be unique within the domain.
#' 
#' For custom form types, to indicate that a field should be searchable,
#' annotate it with `@@amazon.datazone#searchable`. By default, searchable
#' fields are indexed for semantic search, where related query terms will
#' match the attribute value even if they are not stemmed or keyword
#' matches. To indicate that a field should be indexed for lexical search
#' (which disables semantic search but supports stemmed and partial
#' matches), annotate it with
#' `@@amazon.datazone#searchable(modes:["LEXICAL"])`. To indicate that a
#' field should be indexed for technical identifier search (for more
#' information on technical identifier search, see:
#' <https://aws.amazon.com/blogs/big-data/streamline-data-discovery-with-precise-technical-identifier-search-in-amazon-sagemaker-unified-studio/>),
#' annotate it with `@@amazon.datazone#searchable(modes:["TECHNICAL"])`.
#' 
#' To denote that a field will store glossary term ids (which are
#' filterable via the Search/SearchListings APIs), annotate it with
#' `@@amazon.datazone#glossaryterm("${GLOSSARY_ID}")`, where
#' `${GLOSSARY_ID}` is the id of the glossary that the glossary terms
#' stored in the field belong to.
#'
#' @usage
#' datazone_create_form_type(description, domainIdentifier, model, name,
#'   owningProjectIdentifier, status)
#'
#' @param description The description of this Amazon DataZone metadata form type.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this metadata form type is
#' created.
#' @param model &#91;required&#93; The model of this Amazon DataZone metadata form type.
#' @param name &#91;required&#93; The name of this Amazon DataZone metadata form type.
#' @param owningProjectIdentifier &#91;required&#93; The ID of the Amazon DataZone project that owns this metadata form type.
#' @param status The status of this Amazon DataZone metadata form type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   name = "string",
#'   originDomainId = "string",
#'   originProjectId = "string",
#'   owningProjectId = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_form_type(
#'   description = "string",
#'   domainIdentifier = "string",
#'   model = list(
#'     smithy = "string"
#'   ),
#'   name = "string",
#'   owningProjectIdentifier = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_form_type
#'
#' @aliases datazone_create_form_type
datazone_create_form_type <- function(description = NULL, domainIdentifier, model, name, owningProjectIdentifier, status = NULL) {
  op <- new_operation(
    name = "CreateFormType",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/form-types",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_form_type_input(description = description, domainIdentifier = domainIdentifier, model = model, name = name, owningProjectIdentifier = owningProjectIdentifier, status = status)
  output <- .datazone$create_form_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_form_type <- datazone_create_form_type

#' Creates an Amazon DataZone business glossary
#'
#' @description
#' Creates an Amazon DataZone business glossary.
#' 
#' Specifies that this is a create glossary policy.
#' 
#' A glossary serves as the central repository for business terminology and
#' definitions within an organization. It helps establish and maintain a
#' common language across different departments and teams, reducing
#' miscommunication and ensuring consistent interpretation of business
#' concepts. Glossaries can include hierarchical relationships between
#' terms, cross-references, and links to actual data assets, making them
#' invaluable for both business users and technical teams trying to
#' understand and use data correctly.
#' 
#' Prerequisites:
#' 
#' -   Domain must exist and be in an active state.
#' 
#' -   Owning project must exist and be accessible by the caller.
#' 
#' -   The glossary name must be unique within the domain.
#'
#' @usage
#' datazone_create_glossary(clientToken, description, domainIdentifier,
#'   name, owningProjectIdentifier, status, usageRestrictions)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of this business glossary.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this business glossary is
#' created.
#' @param name &#91;required&#93; The name of this business glossary.
#' @param owningProjectIdentifier &#91;required&#93; The ID of the project that currently owns business glossary.
#' @param status The status of this business glossary.
#' @param usageRestrictions The usage restriction of the restricted glossary.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   name = "string",
#'   owningProjectId = "string",
#'   status = "DISABLED"|"ENABLED",
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_glossary(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   name = "string",
#'   owningProjectIdentifier = "string",
#'   status = "DISABLED"|"ENABLED",
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_glossary
#'
#' @aliases datazone_create_glossary
datazone_create_glossary <- function(clientToken = NULL, description = NULL, domainIdentifier, name, owningProjectIdentifier, status = NULL, usageRestrictions = NULL) {
  op <- new_operation(
    name = "CreateGlossary",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/glossaries",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_glossary_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, name = name, owningProjectIdentifier = owningProjectIdentifier, status = status, usageRestrictions = usageRestrictions)
  output <- .datazone$create_glossary_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_glossary <- datazone_create_glossary

#' Creates a business glossary term
#'
#' @description
#' Creates a business glossary term.
#' 
#' A glossary term represents an individual entry within the Amazon
#' DataZone glossary, serving as a standardized definition for a specific
#' business concept or data element. Each term can include rich metadata
#' such as detailed definitions, synonyms, related terms, and usage
#' examples. Glossary terms can be linked directly to data assets,
#' providing business context to technical data elements. This linking
#' capability helps users understand the business meaning of data fields
#' and ensures consistent interpretation across different systems and
#' teams. Terms can also have relationships with other terms, creating a
#' semantic network that reflects the complexity of business concepts.
#' 
#' Prerequisites:
#' 
#' -   Domain must exist.
#' 
#' -   Glossary must exist.
#' 
#' -   The term name must be unique within the glossary.
#' 
#' -   Ensure term does not conflict with existing terms in hierarchy.
#'
#' @usage
#' datazone_create_glossary_term(clientToken, domainIdentifier,
#'   glossaryIdentifier, longDescription, name, shortDescription, status,
#'   termRelations)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this business glossary
#' term is created.
#' @param glossaryIdentifier &#91;required&#93; The ID of the business glossary in which this term is created.
#' @param longDescription The long description of this business glossary term.
#' @param name &#91;required&#93; The name of this business glossary term.
#' @param shortDescription The short description of this business glossary term.
#' @param status The status of this business glossary term.
#' @param termRelations The term relations of this business glossary term.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   glossaryId = "string",
#'   id = "string",
#'   longDescription = "string",
#'   name = "string",
#'   shortDescription = "string",
#'   status = "ENABLED"|"DISABLED",
#'   termRelations = list(
#'     classifies = list(
#'       "string"
#'     ),
#'     isA = list(
#'       "string"
#'     )
#'   ),
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_glossary_term(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   glossaryIdentifier = "string",
#'   longDescription = "string",
#'   name = "string",
#'   shortDescription = "string",
#'   status = "ENABLED"|"DISABLED",
#'   termRelations = list(
#'     classifies = list(
#'       "string"
#'     ),
#'     isA = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_glossary_term
#'
#' @aliases datazone_create_glossary_term
datazone_create_glossary_term <- function(clientToken = NULL, domainIdentifier, glossaryIdentifier, longDescription = NULL, name, shortDescription = NULL, status = NULL, termRelations = NULL) {
  op <- new_operation(
    name = "CreateGlossaryTerm",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/glossary-terms",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_glossary_term_input(clientToken = clientToken, domainIdentifier = domainIdentifier, glossaryIdentifier = glossaryIdentifier, longDescription = longDescription, name = name, shortDescription = shortDescription, status = status, termRelations = termRelations)
  output <- .datazone$create_glossary_term_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_glossary_term <- datazone_create_glossary_term

#' Creates a group profile in Amazon DataZone
#'
#' @description
#' Creates a group profile in Amazon DataZone.
#'
#' @usage
#' datazone_create_group_profile(clientToken, domainIdentifier,
#'   groupIdentifier)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which the group profile
#' is created.
#' @param groupIdentifier &#91;required&#93; The identifier of the group for which the group profile is created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   groupName = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_group_profile(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   groupIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_group_profile
#'
#' @aliases datazone_create_group_profile
datazone_create_group_profile <- function(clientToken = NULL, domainIdentifier, groupIdentifier) {
  op <- new_operation(
    name = "CreateGroupProfile",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/group-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_group_profile_input(clientToken = clientToken, domainIdentifier = domainIdentifier, groupIdentifier = groupIdentifier)
  output <- .datazone$create_group_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_group_profile <- datazone_create_group_profile

#' Publishes a listing (a record of an asset at a given time) or removes a
#' listing from the catalog
#'
#' @description
#' Publishes a listing (a record of an asset at a given time) or removes a
#' listing from the catalog.
#'
#' @usage
#' datazone_create_listing_change_set(action, clientToken,
#'   domainIdentifier, entityIdentifier, entityRevision, entityType)
#'
#' @param action &#91;required&#93; Specifies whether to publish or unpublish a listing.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain.
#' @param entityIdentifier &#91;required&#93; The ID of the asset.
#' @param entityRevision The revision of an asset.
#' @param entityType &#91;required&#93; The type of an entity.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   listingId = "string",
#'   listingRevision = "string",
#'   status = "CREATING"|"ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_listing_change_set(
#'   action = "PUBLISH"|"UNPUBLISH",
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityRevision = "string",
#'   entityType = "ASSET"|"DATA_PRODUCT"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_listing_change_set
#'
#' @aliases datazone_create_listing_change_set
datazone_create_listing_change_set <- function(action, clientToken = NULL, domainIdentifier, entityIdentifier, entityRevision = NULL, entityType) {
  op <- new_operation(
    name = "CreateListingChangeSet",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/listings/change-set",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_listing_change_set_input(action = action, clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityRevision = entityRevision, entityType = entityType)
  output <- .datazone$create_listing_change_set_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_listing_change_set <- datazone_create_listing_change_set

#' Creates an Amazon DataZone project
#'
#' @description
#' Creates an Amazon DataZone project.
#'
#' @usage
#' datazone_create_project(description, domainIdentifier, domainUnitId,
#'   glossaryTerms, name, projectProfileId, resourceTags, userParameters)
#'
#' @param description The description of the Amazon DataZone project.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this project is created.
#' @param domainUnitId The ID of the domain unit. This parameter is not required and if it is
#' not specified, then the project is created at the root domain unit
#' level.
#' @param glossaryTerms The glossary terms that can be used in this Amazon DataZone project.
#' @param name &#91;required&#93; The name of the Amazon DataZone project.
#' @param projectProfileId The ID of the project profile.
#' @param resourceTags The resource tags of the project.
#' @param userParameters The user parameters of the project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentDeploymentDetails = list(
#'     environmentFailureReasons = list(
#'       list(
#'         list(
#'           code = "string",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     overallDeploymentStatus = "PENDING_DEPLOYMENT"|"IN_PROGRESS"|"SUCCESSFUL"|"FAILED_VALIDATION"|"FAILED_DEPLOYMENT"
#'   ),
#'   failureReasons = list(
#'     list(
#'       code = "string",
#'       message = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectProfileId = "string",
#'   projectStatus = "ACTIVE"|"DELETING"|"DELETE_FAILED"|"UPDATING"|"UPDATE_FAILED"|"MOVING",
#'   resourceTags = list(
#'     list(
#'       key = "string",
#'       source = "PROJECT"|"PROJECT_PROFILE",
#'       value = "string"
#'     )
#'   ),
#'   userParameters = list(
#'     list(
#'       environmentConfigurationName = "string",
#'       environmentId = "string",
#'       environmentParameters = list(
#'         list(
#'           name = "string",
#'           value = "string"
#'         )
#'       ),
#'       environmentResolvedAccount = list(
#'         awsAccountId = "string",
#'         regionName = "string",
#'         sourceAccountPoolId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_project(
#'   description = "string",
#'   domainIdentifier = "string",
#'   domainUnitId = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   name = "string",
#'   projectProfileId = "string",
#'   resourceTags = list(
#'     "string"
#'   ),
#'   userParameters = list(
#'     list(
#'       environmentConfigurationName = "string",
#'       environmentId = "string",
#'       environmentParameters = list(
#'         list(
#'           name = "string",
#'           value = "string"
#'         )
#'       ),
#'       environmentResolvedAccount = list(
#'         awsAccountId = "string",
#'         regionName = "string",
#'         sourceAccountPoolId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_project
#'
#' @aliases datazone_create_project
datazone_create_project <- function(description = NULL, domainIdentifier, domainUnitId = NULL, glossaryTerms = NULL, name, projectProfileId = NULL, resourceTags = NULL, userParameters = NULL) {
  op <- new_operation(
    name = "CreateProject",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/projects",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_project_input(description = description, domainIdentifier = domainIdentifier, domainUnitId = domainUnitId, glossaryTerms = glossaryTerms, name = name, projectProfileId = projectProfileId, resourceTags = resourceTags, userParameters = userParameters)
  output <- .datazone$create_project_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_project <- datazone_create_project

#' Creates a project membership in Amazon DataZone
#'
#' @description
#' Creates a project membership in Amazon DataZone.
#'
#' @usage
#' datazone_create_project_membership(designation, domainIdentifier,
#'   member, projectIdentifier)
#'
#' @param designation &#91;required&#93; The designation of the project membership.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which project membership is
#' created.
#' @param member &#91;required&#93; The project member whose project membership was created.
#' @param projectIdentifier &#91;required&#93; The ID of the project for which this project membership was created.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_project_membership(
#'   designation = "PROJECT_OWNER"|"PROJECT_CONTRIBUTOR"|"PROJECT_CATALOG_VIEWER"|"PROJECT_CATALOG_CONSUMER"|"PROJECT_CATALOG_STEWARD",
#'   domainIdentifier = "string",
#'   member = list(
#'     groupIdentifier = "string",
#'     userIdentifier = "string"
#'   ),
#'   projectIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_project_membership
#'
#' @aliases datazone_create_project_membership
datazone_create_project_membership <- function(designation, domainIdentifier, member, projectIdentifier) {
  op <- new_operation(
    name = "CreateProjectMembership",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/createMembership",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_project_membership_input(designation = designation, domainIdentifier = domainIdentifier, member = member, projectIdentifier = projectIdentifier)
  output <- .datazone$create_project_membership_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_project_membership <- datazone_create_project_membership

#' Creates a project profile
#'
#' @description
#' Creates a project profile.
#'
#' @usage
#' datazone_create_project_profile(allowCustomProjectResourceTags,
#'   description, domainIdentifier, domainUnitIdentifier,
#'   environmentConfigurations, name, projectResourceTags,
#'   projectResourceTagsDescription, status)
#'
#' @param allowCustomProjectResourceTags Specifies whether custom project resource tags are supported.
#' @param description A description of a project profile.
#' @param domainIdentifier &#91;required&#93; A domain ID of the project profile.
#' @param domainUnitIdentifier A domain unit ID of the project profile.
#' @param environmentConfigurations Environment configurations of the project profile.
#' @param name &#91;required&#93; Project profile name.
#' @param projectResourceTags The resource tags of the project profile.
#' @param projectResourceTagsDescription Field viewable through the UI that provides a project user with the
#' allowed resource tag specifications.
#' @param status Project profile status.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   allowCustomProjectResourceTags = TRUE|FALSE,
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentConfigurations = list(
#'     list(
#'       accountPools = list(
#'         "string"
#'       ),
#'       awsAccount = list(
#'         awsAccountId = "string",
#'         awsAccountIdPath = "string"
#'       ),
#'       awsRegion = list(
#'         regionName = "string",
#'         regionNamePath = "string"
#'       ),
#'       configurationParameters = list(
#'         parameterOverrides = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         resolvedParameters = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         ssmPath = "string"
#'       ),
#'       deploymentMode = "ON_CREATE"|"ON_DEMAND",
#'       deploymentOrder = 123,
#'       description = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectResourceTags = list(
#'     list(
#'       isValueEditable = TRUE|FALSE,
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   projectResourceTagsDescription = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_project_profile(
#'   allowCustomProjectResourceTags = TRUE|FALSE,
#'   description = "string",
#'   domainIdentifier = "string",
#'   domainUnitIdentifier = "string",
#'   environmentConfigurations = list(
#'     list(
#'       accountPools = list(
#'         "string"
#'       ),
#'       awsAccount = list(
#'         awsAccountId = "string",
#'         awsAccountIdPath = "string"
#'       ),
#'       awsRegion = list(
#'         regionName = "string",
#'         regionNamePath = "string"
#'       ),
#'       configurationParameters = list(
#'         parameterOverrides = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         resolvedParameters = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         ssmPath = "string"
#'       ),
#'       deploymentMode = "ON_CREATE"|"ON_DEMAND",
#'       deploymentOrder = 123,
#'       description = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   name = "string",
#'   projectResourceTags = list(
#'     list(
#'       isValueEditable = TRUE|FALSE,
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   projectResourceTagsDescription = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_project_profile
#'
#' @aliases datazone_create_project_profile
datazone_create_project_profile <- function(allowCustomProjectResourceTags = NULL, description = NULL, domainIdentifier, domainUnitIdentifier = NULL, environmentConfigurations = NULL, name, projectResourceTags = NULL, projectResourceTagsDescription = NULL, status = NULL) {
  op <- new_operation(
    name = "CreateProjectProfile",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/project-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_project_profile_input(allowCustomProjectResourceTags = allowCustomProjectResourceTags, description = description, domainIdentifier = domainIdentifier, domainUnitIdentifier = domainUnitIdentifier, environmentConfigurations = environmentConfigurations, name = name, projectResourceTags = projectResourceTags, projectResourceTagsDescription = projectResourceTagsDescription, status = status)
  output <- .datazone$create_project_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_project_profile <- datazone_create_project_profile

#' Creates a rule in Amazon DataZone
#'
#' @description
#' Creates a rule in Amazon DataZone. A rule is a formal agreement that
#' enforces specific requirements across user workflows (e.g., publishing
#' assets to the catalog, requesting subscriptions, creating projects)
#' within the Amazon DataZone data portal. These rules help maintain
#' consistency, ensure compliance, and uphold governance standards in data
#' management processes. For instance, a metadata enforcement rule can
#' specify the required information for creating a subscription request or
#' publishing a data asset to the catalog, ensuring alignment with
#' organizational standards.
#'
#' @usage
#' datazone_create_rule(action, clientToken, description, detail,
#'   domainIdentifier, name, scope, target)
#'
#' @param action &#91;required&#93; The action of the rule.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description of the rule.
#' @param detail &#91;required&#93; The detail of the rule.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the rule is created.
#' @param name &#91;required&#93; The name of the rule.
#' @param scope &#91;required&#93; The scope of the rule.
#' @param target &#91;required&#93; The target of the rule.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   detail = list(
#'     glossaryTermEnforcementDetail = list(
#'       requiredGlossaryTermIds = list(
#'         "string"
#'       )
#'     ),
#'     metadataFormEnforcementDetail = list(
#'       requiredMetadataForms = list(
#'         list(
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   identifier = "string",
#'   name = "string",
#'   ruleType = "METADATA_FORM_ENFORCEMENT"|"GLOSSARY_TERM_ENFORCEMENT",
#'   scope = list(
#'     assetType = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificAssetTypes = list(
#'         "string"
#'       )
#'     ),
#'     dataProduct = TRUE|FALSE,
#'     project = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificProjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   target = list(
#'     domainUnitTarget = list(
#'       domainUnitId = "string",
#'       includeChildDomainUnits = TRUE|FALSE
#'     )
#'   ),
#'   targetType = "DOMAIN_UNIT"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_rule(
#'   action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'   clientToken = "string",
#'   description = "string",
#'   detail = list(
#'     glossaryTermEnforcementDetail = list(
#'       requiredGlossaryTermIds = list(
#'         "string"
#'       )
#'     ),
#'     metadataFormEnforcementDetail = list(
#'       requiredMetadataForms = list(
#'         list(
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   domainIdentifier = "string",
#'   name = "string",
#'   scope = list(
#'     assetType = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificAssetTypes = list(
#'         "string"
#'       )
#'     ),
#'     dataProduct = TRUE|FALSE,
#'     project = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificProjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   target = list(
#'     domainUnitTarget = list(
#'       domainUnitId = "string",
#'       includeChildDomainUnits = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_rule
#'
#' @aliases datazone_create_rule
datazone_create_rule <- function(action, clientToken = NULL, description = NULL, detail, domainIdentifier, name, scope, target) {
  op <- new_operation(
    name = "CreateRule",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/rules",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_rule_input(action = action, clientToken = clientToken, description = description, detail = detail, domainIdentifier = domainIdentifier, name = name, scope = scope, target = target)
  output <- .datazone$create_rule_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_rule <- datazone_create_rule

#' Creates a subsscription grant in Amazon DataZone
#'
#' @description
#' Creates a subsscription grant in Amazon DataZone.
#'
#' @usage
#' datazone_create_subscription_grant(assetTargetNames, clientToken,
#'   domainIdentifier, environmentIdentifier, grantedEntity,
#'   subscriptionTargetIdentifier)
#'
#' @param assetTargetNames The names of the assets for which the subscription grant is created.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription grant is
#' created.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment in which the subscription grant is created.
#' @param grantedEntity &#91;required&#93; The entity to which the subscription is to be granted.
#' @param subscriptionTargetIdentifier The ID of the subscription target for which the subscription grant is
#' created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assets = list(
#'     list(
#'       assetId = "string",
#'       assetRevision = "string",
#'       assetScope = list(
#'         assetId = "string",
#'         errorMessage = "string",
#'         filterIds = list(
#'           "string"
#'         ),
#'         status = "string"
#'       ),
#'       failureCause = list(
#'         message = "string"
#'       ),
#'       failureTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       grantedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       ),
#'       status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'       targetName = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   grantedEntity = list(
#'     listing = list(
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   id = "string",
#'   status = "PENDING"|"IN_PROGRESS"|"GRANT_FAILED"|"REVOKE_FAILED"|"GRANT_AND_REVOKE_FAILED"|"COMPLETED"|"INACCESSIBLE",
#'   subscriptionId = "string",
#'   subscriptionTargetId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_subscription_grant(
#'   assetTargetNames = list(
#'     list(
#'       assetId = "string",
#'       targetName = "string"
#'     )
#'   ),
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   grantedEntity = list(
#'     listing = list(
#'       identifier = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscriptionTargetIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_subscription_grant
#'
#' @aliases datazone_create_subscription_grant
datazone_create_subscription_grant <- function(assetTargetNames = NULL, clientToken = NULL, domainIdentifier, environmentIdentifier, grantedEntity, subscriptionTargetIdentifier = NULL) {
  op <- new_operation(
    name = "CreateSubscriptionGrant",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/subscription-grants",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_subscription_grant_input(assetTargetNames = assetTargetNames, clientToken = clientToken, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, grantedEntity = grantedEntity, subscriptionTargetIdentifier = subscriptionTargetIdentifier)
  output <- .datazone$create_subscription_grant_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_subscription_grant <- datazone_create_subscription_grant

#' Creates a subscription request in Amazon DataZone
#'
#' @description
#' Creates a subscription request in Amazon DataZone.
#'
#' @usage
#' datazone_create_subscription_request(assetPermissions, assetScopes,
#'   clientToken, domainIdentifier, metadataForms, requestReason,
#'   subscribedListings, subscribedPrincipals)
#'
#' @param assetPermissions The asset permissions of the subscription request.
#' @param assetScopes The asset scopes of the subscription request.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription request
#' is created.
#' @param metadataForms The metadata form included in the subscription request.
#' @param requestReason &#91;required&#93; The reason for the subscription request.
#' @param subscribedListings &#91;required&#93; The published asset for which the subscription grant is to be created.
#' @param subscribedPrincipals &#91;required&#93; The Amazon DataZone principals for whom the subscription request is
#' created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   decisionComment = "string",
#'   domainId = "string",
#'   existingSubscriptionId = "string",
#'   id = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   reviewerId = "string",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListings = list(
#'     list(
#'       description = "string",
#'       id = "string",
#'       item = list(
#'         assetListing = list(
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           entityId = "string",
#'           entityRevision = "string",
#'           entityType = "string",
#'           forms = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           )
#'         ),
#'         productListing = list(
#'           assetListings = list(
#'             list(
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string"
#'             )
#'           ),
#'           description = "string",
#'           entityId = "string",
#'           entityRevision = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           name = "string"
#'         )
#'       ),
#'       name = "string",
#'       ownerProjectId = "string",
#'       ownerProjectName = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       project = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       user = list(
#'         details = list(
#'           iam = list(
#'             arn = "string",
#'             principalId = "string"
#'           ),
#'           sso = list(
#'             firstName = "string",
#'             lastName = "string",
#'             username = "string"
#'           )
#'         ),
#'         id = "string"
#'       )
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_subscription_request(
#'   assetPermissions = list(
#'     list(
#'       assetId = "string",
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       )
#'     )
#'   ),
#'   assetScopes = list(
#'     list(
#'       assetId = "string",
#'       filterIds = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   subscribedListings = list(
#'     list(
#'       identifier = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         identifier = "string"
#'       ),
#'       project = list(
#'         identifier = "string"
#'       ),
#'       user = list(
#'         identifier = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_subscription_request
#'
#' @aliases datazone_create_subscription_request
datazone_create_subscription_request <- function(assetPermissions = NULL, assetScopes = NULL, clientToken = NULL, domainIdentifier, metadataForms = NULL, requestReason, subscribedListings, subscribedPrincipals) {
  op <- new_operation(
    name = "CreateSubscriptionRequest",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_subscription_request_input(assetPermissions = assetPermissions, assetScopes = assetScopes, clientToken = clientToken, domainIdentifier = domainIdentifier, metadataForms = metadataForms, requestReason = requestReason, subscribedListings = subscribedListings, subscribedPrincipals = subscribedPrincipals)
  output <- .datazone$create_subscription_request_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_subscription_request <- datazone_create_subscription_request

#' Creates a subscription target in Amazon DataZone
#'
#' @description
#' Creates a subscription target in Amazon DataZone.
#'
#' @usage
#' datazone_create_subscription_target(applicableAssetTypes,
#'   authorizedPrincipals, clientToken, domainIdentifier,
#'   environmentIdentifier, manageAccessRole, name, provider,
#'   subscriptionTargetConfig, type)
#'
#' @param applicableAssetTypes &#91;required&#93; The asset types that can be included in the subscription target.
#' @param authorizedPrincipals &#91;required&#93; The authorized principals of the subscription target.
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which subscription target is
#' created.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment in which subscription target is created.
#' @param manageAccessRole &#91;required&#93; The manage access role that is used to create the subscription target.
#' @param name &#91;required&#93; The name of the subscription target.
#' @param provider The provider of the subscription target.
#' @param subscriptionTargetConfig &#91;required&#93; The configuration of the subscription target.
#' @param type &#91;required&#93; The type of the subscription target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicableAssetTypes = list(
#'     "string"
#'   ),
#'   authorizedPrincipals = list(
#'     "string"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   manageAccessRole = "string",
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   subscriptionTargetConfig = list(
#'     list(
#'       content = "string",
#'       formName = "string"
#'     )
#'   ),
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_subscription_target(
#'   applicableAssetTypes = list(
#'     "string"
#'   ),
#'   authorizedPrincipals = list(
#'     "string"
#'   ),
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   manageAccessRole = "string",
#'   name = "string",
#'   provider = "string",
#'   subscriptionTargetConfig = list(
#'     list(
#'       content = "string",
#'       formName = "string"
#'     )
#'   ),
#'   type = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_subscription_target
#'
#' @aliases datazone_create_subscription_target
datazone_create_subscription_target <- function(applicableAssetTypes, authorizedPrincipals, clientToken = NULL, domainIdentifier, environmentIdentifier, manageAccessRole, name, provider = NULL, subscriptionTargetConfig, type) {
  op <- new_operation(
    name = "CreateSubscriptionTarget",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_subscription_target_input(applicableAssetTypes = applicableAssetTypes, authorizedPrincipals = authorizedPrincipals, clientToken = clientToken, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, manageAccessRole = manageAccessRole, name = name, provider = provider, subscriptionTargetConfig = subscriptionTargetConfig, type = type)
  output <- .datazone$create_subscription_target_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_subscription_target <- datazone_create_subscription_target

#' Creates a user profile in Amazon DataZone
#'
#' @description
#' Creates a user profile in Amazon DataZone.
#'
#' @usage
#' datazone_create_user_profile(clientToken, domainIdentifier,
#'   userIdentifier, userType)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a user profile is
#' created.
#' @param userIdentifier &#91;required&#93; The identifier of the user for which the user profile is created.
#' @param userType The user type of the user for which the user profile is created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   details = list(
#'     iam = list(
#'       arn = "string",
#'       principalId = "string"
#'     ),
#'     sso = list(
#'       firstName = "string",
#'       lastName = "string",
#'       username = "string"
#'     )
#'   ),
#'   domainId = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"|"ACTIVATED"|"DEACTIVATED",
#'   type = "IAM"|"SSO"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_user_profile(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   userIdentifier = "string",
#'   userType = "IAM_USER"|"IAM_ROLE"|"SSO_USER"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_create_user_profile
#'
#' @aliases datazone_create_user_profile
datazone_create_user_profile <- function(clientToken = NULL, domainIdentifier, userIdentifier, userType = NULL) {
  op <- new_operation(
    name = "CreateUserProfile",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/user-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$create_user_profile_input(clientToken = clientToken, domainIdentifier = domainIdentifier, userIdentifier = userIdentifier, userType = userType)
  output <- .datazone$create_user_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$create_user_profile <- datazone_create_user_profile

#' Deletes an account pool
#'
#' @description
#' Deletes an account pool.
#'
#' @usage
#' datazone_delete_account_pool(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the account pool is deleted.
#' @param identifier &#91;required&#93; The ID of the account pool to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_account_pool(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_account_pool
#'
#' @aliases datazone_delete_account_pool
datazone_delete_account_pool <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteAccountPool",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/account-pools/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_account_pool_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_account_pool_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_account_pool <- datazone_delete_account_pool

#' Deletes an asset in Amazon DataZone
#'
#' @description
#' Deletes an asset in Amazon DataZone.
#' 
#' -   --domain-identifier must refer to a valid and existing domain.
#' 
#' -   --identifier must refer to an existing asset in the specified
#'     domain.
#' 
#' -   Asset must not be referenced in any existing asset filters.
#' 
#' -   Asset must not be linked to any draft or published data product.
#' 
#' -   User must have delete permissions for the domain and project.
#'
#' @usage
#' datazone_delete_asset(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the asset is deleted.
#' @param identifier &#91;required&#93; The identifier of the asset that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_asset(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_asset
#'
#' @aliases datazone_delete_asset
datazone_delete_asset <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteAsset",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_asset_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_asset_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_asset <- datazone_delete_asset

#' Deletes an asset filter
#'
#' @description
#' Deletes an asset filter.
#' 
#' Prerequisites:
#' 
#' -   The asset filter must exist.
#' 
#' -   The domain and asset must not have been deleted.
#' 
#' -   Ensure the --identifier refers to a valid filter ID.
#'
#' @usage
#' datazone_delete_asset_filter(assetIdentifier, domainIdentifier,
#'   identifier)
#'
#' @param assetIdentifier &#91;required&#93; The ID of the data asset.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to delete an asset filter.
#' @param identifier &#91;required&#93; The ID of the asset filter that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_asset_filter(
#'   assetIdentifier = "string",
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_asset_filter
#'
#' @aliases datazone_delete_asset_filter
datazone_delete_asset_filter <- function(assetIdentifier, domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteAssetFilter",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_asset_filter_input(assetIdentifier = assetIdentifier, domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_asset_filter_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_asset_filter <- datazone_delete_asset_filter

#' Deletes an asset type in Amazon DataZone
#'
#' @description
#' Deletes an asset type in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The asset type must exist in the domain.
#' 
#' -   You must have DeleteAssetType permission.
#' 
#' -   The asset type must not be in use (e.g., assigned to any asset). If
#'     used, deletion will fail.
#' 
#' -   You should retrieve the asset type using get-asset-type to confirm
#'     its presence before deletion.
#'
#' @usage
#' datazone_delete_asset_type(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the asset type is deleted.
#' @param identifier &#91;required&#93; The identifier of the asset type that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_asset_type(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_asset_type
#'
#' @aliases datazone_delete_asset_type
datazone_delete_asset_type <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteAssetType",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/asset-types/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_asset_type_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_asset_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_asset_type <- datazone_delete_asset_type

#' Deletes and connection
#'
#' @description
#' Deletes and connection. In Amazon DataZone, a connection enables you to
#' connect your resources (domains, projects, and environments) to external
#' resources and services.
#'
#' @usage
#' datazone_delete_connection(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the connection is deleted.
#' @param identifier &#91;required&#93; The ID of the connection that is deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_connection(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_connection
#'
#' @aliases datazone_delete_connection
datazone_delete_connection <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteConnection",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/connections/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_connection_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_connection_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_connection <- datazone_delete_connection

#' Deletes a data product in Amazon DataZone
#'
#' @description
#' Deletes a data product in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The data product must exist and not be deleted or archived.
#' 
#' -   The user must have delete permissions for the data product.
#' 
#' -   Domain and project must be active.
#'
#' @usage
#' datazone_delete_data_product(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the data product is
#' deleted.
#' @param identifier &#91;required&#93; The identifier of the data product that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_product(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_data_product
#'
#' @aliases datazone_delete_data_product
datazone_delete_data_product <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteDataProduct",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/data-products/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_data_product_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_data_product_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_data_product <- datazone_delete_data_product

#' Deletes a data source in Amazon DataZone
#'
#' @description
#' Deletes a data source in Amazon DataZone.
#'
#' @usage
#' datazone_delete_data_source(clientToken, domainIdentifier, identifier,
#'   retainPermissionsOnRevokeFailure)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the data source is
#' deleted.
#' @param identifier &#91;required&#93; The identifier of the data source that is deleted.
#' @param retainPermissionsOnRevokeFailure Specifies that the granted permissions are retained in case of a
#' self-subscribe functionality failure for a data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       accountId = "string",
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       accountId = "string",
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       accountId = "string",
#'       region = "string",
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   connectionId = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   environmentId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   lastRunAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastRunErrorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   lastRunStatus = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   name = "string",
#'   projectId = "string",
#'   publishOnImport = TRUE|FALSE,
#'   retainPermissionsOnRevokeFailure = TRUE|FALSE,
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   ),
#'   selfGrantStatus = list(
#'     glueSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     ),
#'     redshiftSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     )
#'   ),
#'   status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_data_source(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   retainPermissionsOnRevokeFailure = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_data_source
#'
#' @aliases datazone_delete_data_source
datazone_delete_data_source <- function(clientToken = NULL, domainIdentifier, identifier, retainPermissionsOnRevokeFailure = NULL) {
  op <- new_operation(
    name = "DeleteDataSource",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/data-sources/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_data_source_input(clientToken = clientToken, domainIdentifier = domainIdentifier, identifier = identifier, retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure)
  output <- .datazone$delete_data_source_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_data_source <- datazone_delete_data_source

#' Deletes a Amazon DataZone domain
#'
#' @description
#' Deletes a Amazon DataZone domain.
#'
#' @usage
#' datazone_delete_domain(clientToken, identifier, skipDeletionCheck)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param identifier &#91;required&#93; The identifier of the Amazon Web Services domain that is to be deleted.
#' @param skipDeletionCheck Specifies the optional flag to delete all child entities within the
#' domain.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   status = "CREATING"|"AVAILABLE"|"CREATION_FAILED"|"DELETING"|"DELETED"|"DELETION_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_domain(
#'   clientToken = "string",
#'   identifier = "string",
#'   skipDeletionCheck = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_domain
#'
#' @aliases datazone_delete_domain
datazone_delete_domain <- function(clientToken = NULL, identifier, skipDeletionCheck = NULL) {
  op <- new_operation(
    name = "DeleteDomain",
    http_method = "DELETE",
    http_path = "/v2/domains/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_domain_input(clientToken = clientToken, identifier = identifier, skipDeletionCheck = skipDeletionCheck)
  output <- .datazone$delete_domain_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_domain <- datazone_delete_domain

#' Deletes a domain unit
#'
#' @description
#' Deletes a domain unit.
#'
#' @usage
#' datazone_delete_domain_unit(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to delete a domain unit.
#' @param identifier &#91;required&#93; The ID of the domain unit that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_domain_unit(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_domain_unit
#'
#' @aliases datazone_delete_domain_unit
datazone_delete_domain_unit <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteDomainUnit",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/domain-units/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_domain_unit_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_domain_unit_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_domain_unit <- datazone_delete_domain_unit

#' Deletes an environment in Amazon DataZone
#'
#' @description
#' Deletes an environment in Amazon DataZone.
#'
#' @usage
#' datazone_delete_environment(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the environment is
#' deleted.
#' @param identifier &#91;required&#93; The identifier of the environment that is to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_environment(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_environment
#'
#' @aliases datazone_delete_environment
datazone_delete_environment <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteEnvironment",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environments/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_environment_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_environment_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_environment <- datazone_delete_environment

#' Deletes an action for the environment, for example, deletes a console
#' link for an analytics tool that is available in this environment
#'
#' @description
#' Deletes an action for the environment, for example, deletes a console
#' link for an analytics tool that is available in this environment.
#'
#' @usage
#' datazone_delete_environment_action(domainIdentifier,
#'   environmentIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which an environment action is
#' deleted.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment where an environment action is deleted.
#' @param identifier &#91;required&#93; The ID of the environment action that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_environment_action(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_environment_action
#'
#' @aliases datazone_delete_environment_action
datazone_delete_environment_action <- function(domainIdentifier, environmentIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteEnvironmentAction",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_environment_action_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier)
  output <- .datazone$delete_environment_action_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_environment_action <- datazone_delete_environment_action

#' Deletes a blueprint in Amazon DataZone
#'
#' @description
#' Deletes a blueprint in Amazon DataZone.
#'
#' @usage
#' datazone_delete_environment_blueprint(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the blueprint is deleted.
#' @param identifier &#91;required&#93; The ID of the blueprint that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_environment_blueprint(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_environment_blueprint
#'
#' @aliases datazone_delete_environment_blueprint
datazone_delete_environment_blueprint <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteEnvironmentBlueprint",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_environment_blueprint_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_environment_blueprint_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_environment_blueprint <- datazone_delete_environment_blueprint

#' Deletes the blueprint configuration in Amazon DataZone
#'
#' @description
#' Deletes the blueprint configuration in Amazon DataZone.
#'
#' @usage
#' datazone_delete_environment_blueprint_configuration(domainIdentifier,
#'   environmentBlueprintIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the blueprint
#' configuration is deleted.
#' @param environmentBlueprintIdentifier &#91;required&#93; The ID of the blueprint the configuration of which is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_environment_blueprint_configuration(
#'   domainIdentifier = "string",
#'   environmentBlueprintIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_environment_blueprint_configuration
#'
#' @aliases datazone_delete_environment_blueprint_configuration
datazone_delete_environment_blueprint_configuration <- function(domainIdentifier, environmentBlueprintIdentifier) {
  op <- new_operation(
    name = "DeleteEnvironmentBlueprintConfiguration",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_environment_blueprint_configuration_input(domainIdentifier = domainIdentifier, environmentBlueprintIdentifier = environmentBlueprintIdentifier)
  output <- .datazone$delete_environment_blueprint_configuration_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_environment_blueprint_configuration <- datazone_delete_environment_blueprint_configuration

#' Deletes an environment profile in Amazon DataZone
#'
#' @description
#' Deletes an environment profile in Amazon DataZone.
#'
#' @usage
#' datazone_delete_environment_profile(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the environment profile is
#' deleted.
#' @param identifier &#91;required&#93; The ID of the environment profile that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_environment_profile(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_environment_profile
#'
#' @aliases datazone_delete_environment_profile
datazone_delete_environment_profile <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteEnvironmentProfile",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_environment_profile_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_environment_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_environment_profile <- datazone_delete_environment_profile

#' Deletes and metadata form type in Amazon DataZone
#'
#' @description
#' Deletes and metadata form type in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The form type must exist in the domain.
#' 
#' -   The form type must not be in use by any asset types or assets.
#' 
#' -   The domain must be valid and accessible.
#' 
#' -   User must have delete permissions on the form type.
#' 
#' -   Any dependencies (such as linked asset types) must be removed first.
#'
#' @usage
#' datazone_delete_form_type(domainIdentifier, formTypeIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the metadata form type is
#' deleted.
#' @param formTypeIdentifier &#91;required&#93; The ID of the metadata form type that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_form_type(
#'   domainIdentifier = "string",
#'   formTypeIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_form_type
#'
#' @aliases datazone_delete_form_type
datazone_delete_form_type <- function(domainIdentifier, formTypeIdentifier) {
  op <- new_operation(
    name = "DeleteFormType",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/form-types/{formTypeIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_form_type_input(domainIdentifier = domainIdentifier, formTypeIdentifier = formTypeIdentifier)
  output <- .datazone$delete_form_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_form_type <- datazone_delete_form_type

#' Deletes a business glossary in Amazon DataZone
#'
#' @description
#' Deletes a business glossary in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The glossary must be in DISABLED state.
#' 
#' -   The glossary must not have any glossary terms associated with it.
#' 
#' -   The glossary must exist in the specified domain.
#' 
#' -   The caller must have the `datazone:DeleteGlossary` permission in the
#'     domain and glossary.
#' 
#' -   Glossary should not be linked to any active metadata forms.
#'
#' @usage
#' datazone_delete_glossary(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the business glossary is
#' deleted.
#' @param identifier &#91;required&#93; The ID of the business glossary that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_glossary(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_glossary
#'
#' @aliases datazone_delete_glossary
datazone_delete_glossary <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteGlossary",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/glossaries/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_glossary_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_glossary_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_glossary <- datazone_delete_glossary

#' Deletes a business glossary term in Amazon DataZone
#'
#' @description
#' Deletes a business glossary term in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   Glossary term must exist and be active.
#' 
#' -   The term must not be linked to other assets or child terms.
#' 
#' -   Caller must have delete permissions in the domain/glossary.
#' 
#' -   Ensure all associations (such as to assets or parent terms) are
#'     removed before deletion.
#'
#' @usage
#' datazone_delete_glossary_term(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the business glossary term
#' is deleted.
#' @param identifier &#91;required&#93; The ID of the business glossary term that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_glossary_term(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_glossary_term
#'
#' @aliases datazone_delete_glossary_term
datazone_delete_glossary_term <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteGlossaryTerm",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_glossary_term_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_glossary_term_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_glossary_term <- datazone_delete_glossary_term

#' Deletes a listing (a record of an asset at a given time)
#'
#' @description
#' Deletes a listing (a record of an asset at a given time).
#'
#' @usage
#' datazone_delete_listing(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain.
#' @param identifier &#91;required&#93; The ID of the listing to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_listing(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_listing
#'
#' @aliases datazone_delete_listing
datazone_delete_listing <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteListing",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/listings/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_listing_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_listing_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_listing <- datazone_delete_listing

#' Deletes a project in Amazon DataZone
#'
#' @description
#' Deletes a project in Amazon DataZone.
#'
#' @usage
#' datazone_delete_project(domainIdentifier, identifier, skipDeletionCheck)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the project is deleted.
#' @param identifier &#91;required&#93; The identifier of the project that is to be deleted.
#' @param skipDeletionCheck Specifies the optional flag to delete all child entities within the
#' project.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_project(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   skipDeletionCheck = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_project
#'
#' @aliases datazone_delete_project
datazone_delete_project <- function(domainIdentifier, identifier, skipDeletionCheck = NULL) {
  op <- new_operation(
    name = "DeleteProject",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/projects/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_project_input(domainIdentifier = domainIdentifier, identifier = identifier, skipDeletionCheck = skipDeletionCheck)
  output <- .datazone$delete_project_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_project <- datazone_delete_project

#' Deletes project membership in Amazon DataZone
#'
#' @description
#' Deletes project membership in Amazon DataZone.
#'
#' @usage
#' datazone_delete_project_membership(domainIdentifier, member,
#'   projectIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where project membership is
#' deleted.
#' @param member &#91;required&#93; The project member whose project membership is deleted.
#' @param projectIdentifier &#91;required&#93; The ID of the Amazon DataZone project the membership to which is
#' deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_project_membership(
#'   domainIdentifier = "string",
#'   member = list(
#'     groupIdentifier = "string",
#'     userIdentifier = "string"
#'   ),
#'   projectIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_project_membership
#'
#' @aliases datazone_delete_project_membership
datazone_delete_project_membership <- function(domainIdentifier, member, projectIdentifier) {
  op <- new_operation(
    name = "DeleteProjectMembership",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/deleteMembership",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_project_membership_input(domainIdentifier = domainIdentifier, member = member, projectIdentifier = projectIdentifier)
  output <- .datazone$delete_project_membership_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_project_membership <- datazone_delete_project_membership

#' Deletes a project profile
#'
#' @description
#' Deletes a project profile.
#'
#' @usage
#' datazone_delete_project_profile(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where a project profile is deleted.
#' @param identifier &#91;required&#93; The ID of the project profile that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_project_profile(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_project_profile
#'
#' @aliases datazone_delete_project_profile
datazone_delete_project_profile <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteProjectProfile",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/project-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_project_profile_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_project_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_project_profile <- datazone_delete_project_profile

#' Deletes a rule in Amazon DataZone
#'
#' @description
#' Deletes a rule in Amazon DataZone. A rule is a formal agreement that
#' enforces specific requirements across user workflows (e.g., publishing
#' assets to the catalog, requesting subscriptions, creating projects)
#' within the Amazon DataZone data portal. These rules help maintain
#' consistency, ensure compliance, and uphold governance standards in data
#' management processes. For instance, a metadata enforcement rule can
#' specify the required information for creating a subscription request or
#' publishing a data asset to the catalog, ensuring alignment with
#' organizational standards.
#'
#' @usage
#' datazone_delete_rule(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain that where the rule is to be deleted.
#' @param identifier &#91;required&#93; The ID of the rule that is to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_rule(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_rule
#'
#' @aliases datazone_delete_rule
datazone_delete_rule <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteRule",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/rules/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_rule_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_rule_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_rule <- datazone_delete_rule

#' Deletes and subscription grant in Amazon DataZone
#'
#' @description
#' Deletes and subscription grant in Amazon DataZone.
#'
#' @usage
#' datazone_delete_subscription_grant(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where the subscription grant is
#' deleted.
#' @param identifier &#91;required&#93; The ID of the subscription grant that is deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assets = list(
#'     list(
#'       assetId = "string",
#'       assetRevision = "string",
#'       assetScope = list(
#'         assetId = "string",
#'         errorMessage = "string",
#'         filterIds = list(
#'           "string"
#'         ),
#'         status = "string"
#'       ),
#'       failureCause = list(
#'         message = "string"
#'       ),
#'       failureTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       grantedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       ),
#'       status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'       targetName = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   grantedEntity = list(
#'     listing = list(
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   id = "string",
#'   status = "PENDING"|"IN_PROGRESS"|"GRANT_FAILED"|"REVOKE_FAILED"|"GRANT_AND_REVOKE_FAILED"|"COMPLETED"|"INACCESSIBLE",
#'   subscriptionId = "string",
#'   subscriptionTargetId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_subscription_grant(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_subscription_grant
#'
#' @aliases datazone_delete_subscription_grant
datazone_delete_subscription_grant <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteSubscriptionGrant",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_subscription_grant_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_subscription_grant_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_subscription_grant <- datazone_delete_subscription_grant

#' Deletes a subscription request in Amazon DataZone
#'
#' @description
#' Deletes a subscription request in Amazon DataZone.
#'
#' @usage
#' datazone_delete_subscription_request(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription request
#' is deleted.
#' @param identifier &#91;required&#93; The ID of the subscription request that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_subscription_request(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_subscription_request
#'
#' @aliases datazone_delete_subscription_request
datazone_delete_subscription_request <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteSubscriptionRequest",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_subscription_request_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$delete_subscription_request_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_subscription_request <- datazone_delete_subscription_request

#' Deletes a subscription target in Amazon DataZone
#'
#' @description
#' Deletes a subscription target in Amazon DataZone.
#'
#' @usage
#' datazone_delete_subscription_target(domainIdentifier,
#'   environmentIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription target is
#' deleted.
#' @param environmentIdentifier &#91;required&#93; The ID of the Amazon DataZone environment in which the subscription
#' target is deleted.
#' @param identifier &#91;required&#93; The ID of the subscription target that is deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_subscription_target(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_subscription_target
#'
#' @aliases datazone_delete_subscription_target
datazone_delete_subscription_target <- function(domainIdentifier, environmentIdentifier, identifier) {
  op <- new_operation(
    name = "DeleteSubscriptionTarget",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_subscription_target_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier)
  output <- .datazone$delete_subscription_target_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_subscription_target <- datazone_delete_subscription_target

#' Deletes the specified time series form for the specified asset
#'
#' @description
#' Deletes the specified time series form for the specified asset.
#'
#' @usage
#' datazone_delete_time_series_data_points(clientToken, domainIdentifier,
#'   entityIdentifier, entityType, formName)
#'
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain that houses the asset for which you
#' want to delete a time series form.
#' @param entityIdentifier &#91;required&#93; The ID of the asset for which you want to delete a time series form.
#' @param entityType &#91;required&#93; The type of the asset for which you want to delete a time series form.
#' @param formName &#91;required&#93; The name of the time series form that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_time_series_data_points(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET"|"LISTING",
#'   formName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_delete_time_series_data_points
#'
#' @aliases datazone_delete_time_series_data_points
datazone_delete_time_series_data_points <- function(clientToken = NULL, domainIdentifier, entityIdentifier, entityType, formName) {
  op <- new_operation(
    name = "DeleteTimeSeriesDataPoints",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$delete_time_series_data_points_input(clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, formName = formName)
  output <- .datazone$delete_time_series_data_points_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$delete_time_series_data_points <- datazone_delete_time_series_data_points

#' Disassociates the environment role in Amazon DataZone
#'
#' @description
#' Disassociates the environment role in Amazon DataZone.
#'
#' @usage
#' datazone_disassociate_environment_role(domainIdentifier,
#'   environmentIdentifier, environmentRoleArn)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which an environment role is
#' disassociated.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment.
#' @param environmentRoleArn &#91;required&#93; The ARN of the environment role.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_environment_role(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   environmentRoleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_disassociate_environment_role
#'
#' @aliases datazone_disassociate_environment_role
datazone_disassociate_environment_role <- function(domainIdentifier, environmentIdentifier, environmentRoleArn) {
  op <- new_operation(
    name = "DisassociateEnvironmentRole",
    http_method = "DELETE",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/roles/{environmentRoleArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$disassociate_environment_role_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, environmentRoleArn = environmentRoleArn)
  output <- .datazone$disassociate_environment_role_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$disassociate_environment_role <- datazone_disassociate_environment_role

#' Disassociates restricted terms from an asset
#'
#' @description
#' Disassociates restricted terms from an asset.
#'
#' @usage
#' datazone_disassociate_governed_terms(domainIdentifier, entityIdentifier,
#'   entityType, governedGlossaryTerms)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to disassociate restricted terms
#' from an asset.
#' @param entityIdentifier &#91;required&#93; The ID of an asset from which you want to disassociate restricted terms.
#' @param entityType &#91;required&#93; The type of the asset from which you want to disassociate restricted
#' terms.
#' @param governedGlossaryTerms &#91;required&#93; The restricted glossary terms that you want to disassociate from an
#' asset.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_governed_terms(
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET",
#'   governedGlossaryTerms = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_disassociate_governed_terms
#'
#' @aliases datazone_disassociate_governed_terms
datazone_disassociate_governed_terms <- function(domainIdentifier, entityIdentifier, entityType, governedGlossaryTerms) {
  op <- new_operation(
    name = "DisassociateGovernedTerms",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/disassociate-governed-terms",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$disassociate_governed_terms_input(domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, governedGlossaryTerms = governedGlossaryTerms)
  output <- .datazone$disassociate_governed_terms_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$disassociate_governed_terms <- datazone_disassociate_governed_terms

#' Gets the details of the account pool
#'
#' @description
#' Gets the details of the account pool.
#'
#' @usage
#' datazone_get_account_pool(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which the account pool lives whose details are
#' to be displayed.
#' @param identifier &#91;required&#93; The ID of the account pool whose details are to be displayed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accountSource = list(
#'     accounts = list(
#'       list(
#'         awsAccountId = "string",
#'         awsAccountName = "string",
#'         supportedRegions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     customAccountPoolHandler = list(
#'       lambdaExecutionRoleArn = "string",
#'       lambdaFunctionArn = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   resolutionStrategy = "MANUAL",
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_account_pool(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_account_pool
#'
#' @aliases datazone_get_account_pool
datazone_get_account_pool <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetAccountPool",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/account-pools/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_account_pool_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_account_pool_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_account_pool <- datazone_get_account_pool

#' Gets an Amazon DataZone asset
#'
#' @description
#' Gets an Amazon DataZone asset.
#' 
#' An asset is the fundamental building block in Amazon DataZone,
#' representing any data resource that needs to be cataloged and managed.
#' It can take many forms, from Amazon S3 buckets and database tables to
#' dashboards and machine learning models. Each asset contains
#' comprehensive metadata about the resource, including its location,
#' schema, ownership, and lineage information. Assets are essential for
#' organizing and managing data resources across an organization, making
#' them discoverable and usable while maintaining proper governance.
#' 
#' Before using the Amazon DataZone GetAsset command, ensure the following
#' prerequisites are met:
#' 
#' -   Domain identifier must exist and be valid
#' 
#' -   Asset identifier must exist
#' 
#' -   User must have the required permissions to perform the action
#'
#' @usage
#' datazone_get_asset(domainIdentifier, identifier, revision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain to which the asset belongs.
#' @param identifier &#91;required&#93; The ID of the Amazon DataZone asset.
#' 
#' This parameter supports either the value of `assetId` or
#' `externalIdentifier` as input. If you are passing the value of
#' `externalIdentifier`, you must prefix this value with
#' `externalIdentifer%2F`.
#' @param revision The revision of the Amazon DataZone asset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   externalIdentifier = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   governedGlossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   latestTimeSeriesDataPointFormsOutput = list(
#'     list(
#'       contentSummary = "string",
#'       formName = "string",
#'       id = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   listing = list(
#'     listingId = "string",
#'     listingStatus = "CREATING"|"ACTIVE"|"INACTIVE"
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   readOnlyFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   revision = "string",
#'   typeIdentifier = "string",
#'   typeRevision = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_asset(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_asset
#'
#' @aliases datazone_get_asset
datazone_get_asset <- function(domainIdentifier, identifier, revision = NULL) {
  op <- new_operation(
    name = "GetAsset",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_asset_input(domainIdentifier = domainIdentifier, identifier = identifier, revision = revision)
  output <- .datazone$get_asset_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_asset <- datazone_get_asset

#' Gets an asset filter
#'
#' @description
#' Gets an asset filter.
#' 
#' Prerequisites:
#' 
#' -   Domain (`--domain-identifier`), asset (`--asset-identifier`), and
#'     filter (`--identifier`) must all exist.
#' 
#' -   The asset filter should not have been deleted.
#' 
#' -   The asset must still exist (since the filter is linked to it).
#'
#' @usage
#' datazone_get_asset_filter(assetIdentifier, domainIdentifier, identifier)
#'
#' @param assetIdentifier &#91;required&#93; The ID of the data asset.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to get an asset filter.
#' @param identifier &#91;required&#93; The ID of the asset filter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetId = "string",
#'   configuration = list(
#'     columnConfiguration = list(
#'       includedColumnNames = list(
#'         "string"
#'       )
#'     ),
#'     rowConfiguration = list(
#'       rowFilter = list(
#'         and = list(
#'           list()
#'         ),
#'         expression = list(
#'           equalTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           in = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           isNotNull = list(
#'             columnName = "string"
#'           ),
#'           isNull = list(
#'             columnName = "string"
#'           ),
#'           lessThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           lessThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           like = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notIn = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           notLike = list(
#'             columnName = "string",
#'             value = "string"
#'           )
#'         ),
#'         or = list(
#'           list()
#'         )
#'       ),
#'       sensitive = TRUE|FALSE
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   effectiveColumnNames = list(
#'     "string"
#'   ),
#'   effectiveRowFilter = "string",
#'   errorMessage = "string",
#'   id = "string",
#'   name = "string",
#'   status = "VALID"|"INVALID"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_asset_filter(
#'   assetIdentifier = "string",
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_asset_filter
#'
#' @aliases datazone_get_asset_filter
datazone_get_asset_filter <- function(assetIdentifier, domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetAssetFilter",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_asset_filter_input(assetIdentifier = assetIdentifier, domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_asset_filter_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_asset_filter <- datazone_get_asset_filter

#' Gets an Amazon DataZone asset type
#'
#' @description
#' Gets an Amazon DataZone asset type.
#' 
#' Asset types define the categories and characteristics of different kinds
#' of data assets within Amazon DataZone.. They determine what metadata
#' fields are required, what operations are possible, and how the asset
#' integrates with other Amazon Web Services services. Asset types can
#' range from built-in types like Amazon S3 buckets and Amazon Web Services
#' Glue tables to custom types defined for specific organizational needs.
#' Understanding asset types is crucial for properly organizing and
#' managing different kinds of data resources.
#' 
#' Prerequisites:
#' 
#' -   The asset type with identifier must exist in the domain.
#'     ResourceNotFoundException.
#' 
#' -   You must have the GetAssetType permission.
#' 
#' -   Ensure the domain-identifier value is correct and accessible.
#'
#' @usage
#' datazone_get_asset_type(domainIdentifier, identifier, revision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the asset type exists.
#' @param identifier &#91;required&#93; The ID of the asset type.
#' @param revision The revision of the asset type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   formsOutput = list(
#'     list(
#'       required = TRUE|FALSE,
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   name = "string",
#'   originDomainId = "string",
#'   originProjectId = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_asset_type(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_asset_type
#'
#' @aliases datazone_get_asset_type
datazone_get_asset_type <- function(domainIdentifier, identifier, revision = NULL) {
  op <- new_operation(
    name = "GetAssetType",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/asset-types/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_asset_type_input(domainIdentifier = domainIdentifier, identifier = identifier, revision = revision)
  output <- .datazone$get_asset_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_asset_type <- datazone_get_asset_type

#' Gets a connection
#'
#' @description
#' Gets a connection. In Amazon DataZone, a connection enables you to
#' connect your resources (domains, projects, and environments) to external
#' resources and services.
#'
#' @usage
#' datazone_get_connection(domainIdentifier, identifier, withSecret)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where we get the connection.
#' @param identifier &#91;required&#93; The connection ID.
#' @param withSecret Specifies whether a connection has a secret.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   connectionCredentials = list(
#'     accessKeyId = "string",
#'     expiration = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     secretAccessKey = "string",
#'     sessionToken = "string"
#'   ),
#'   connectionId = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentId = "string",
#'   environmentUserRole = "string",
#'   name = "string",
#'   physicalEndpoints = list(
#'     list(
#'       awsLocation = list(
#'         accessRole = "string",
#'         awsAccountId = "string",
#'         awsRegion = "string",
#'         iamConnectionId = "string"
#'       ),
#'       enableTrustedIdentityPropagation = TRUE|FALSE,
#'       glueConnection = list(
#'         athenaProperties = list(
#'           "string"
#'         ),
#'         authenticationConfiguration = list(
#'           authenticationType = "BASIC"|"OAUTH2"|"CUSTOM",
#'           oAuth2Properties = list(
#'             authorizationCodeProperties = list(
#'               authorizationCode = "string",
#'               redirectUri = "string"
#'             ),
#'             oAuth2ClientApplication = list(
#'               aWSManagedClientApplicationReference = "string",
#'               userManagedClientApplicationClientId = "string"
#'             ),
#'             oAuth2Credentials = list(
#'               accessToken = "string",
#'               jwtToken = "string",
#'               refreshToken = "string",
#'               userManagedClientApplicationClientSecret = "string"
#'             ),
#'             oAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'             tokenUrl = "string",
#'             tokenUrlParametersMap = list(
#'               "string"
#'             )
#'           ),
#'           secretArn = "string"
#'         ),
#'         compatibleComputeEnvironments = list(
#'           "SPARK"|"ATHENA"|"PYTHON"
#'         ),
#'         connectionProperties = list(
#'           "string"
#'         ),
#'         connectionSchemaVersion = 123,
#'         connectionType = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW",
#'         creationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         description = "string",
#'         lastConnectionValidationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         lastUpdatedBy = "string",
#'         lastUpdatedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         matchCriteria = list(
#'           "string"
#'         ),
#'         name = "string",
#'         physicalConnectionRequirements = list(
#'           availabilityZone = "string",
#'           securityGroupIdList = list(
#'             "string"
#'           ),
#'           subnetId = "string",
#'           subnetIdList = list(
#'             "string"
#'           )
#'         ),
#'         pythonProperties = list(
#'           "string"
#'         ),
#'         sparkProperties = list(
#'           "string"
#'         ),
#'         status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'         statusReason = "string"
#'       ),
#'       glueConnectionName = "string",
#'       host = "string",
#'       port = 123,
#'       protocol = "ATHENA"|"GLUE_INTERACTIVE_SESSION"|"HTTPS"|"JDBC"|"LIVY"|"ODBC"|"PRISM",
#'       stage = "string"
#'     )
#'   ),
#'   projectId = "string",
#'   props = list(
#'     amazonQProperties = list(
#'       authMode = "string",
#'       isEnabled = TRUE|FALSE,
#'       profileArn = "string"
#'     ),
#'     athenaProperties = list(
#'       workgroupName = "string"
#'     ),
#'     glueProperties = list(
#'       errorMessage = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     hyperPodProperties = list(
#'       clusterArn = "string",
#'       clusterName = "string",
#'       orchestrator = "EKS"|"SLURM"
#'     ),
#'     iamProperties = list(
#'       environmentId = "string",
#'       glueLineageSyncEnabled = TRUE|FALSE
#'     ),
#'     mlflowProperties = list(
#'       trackingServerArn = "string"
#'     ),
#'     redshiftProperties = list(
#'       credentials = list(
#'         secretArn = "string",
#'         usernamePassword = list(
#'           password = "string",
#'           username = "string"
#'         )
#'       ),
#'       databaseName = "string",
#'       isProvisionedSecret = TRUE|FALSE,
#'       jdbcIamUrl = "string",
#'       jdbcUrl = "string",
#'       lineageSync = list(
#'         enabled = TRUE|FALSE,
#'         lineageJobId = "string",
#'         schedule = list(
#'           schedule = "string"
#'         )
#'       ),
#'       redshiftTempDir = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'       storage = list(
#'         clusterName = "string",
#'         workgroupName = "string"
#'       )
#'     ),
#'     s3Properties = list(
#'       errorMessage = "string",
#'       s3AccessGrantLocationId = "string",
#'       s3Uri = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     sparkEmrProperties = list(
#'       certificateData = "string",
#'       computeArn = "string",
#'       credentials = list(
#'         password = "string",
#'         username = "string"
#'       ),
#'       credentialsExpiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       governanceType = "AWS_MANAGED"|"USER_MANAGED",
#'       instanceProfileArn = "string",
#'       javaVirtualEnv = "string",
#'       livyEndpoint = "string",
#'       logUri = "string",
#'       managedEndpointArn = "string",
#'       managedEndpointCredentials = list(
#'         id = "string",
#'         token = "string"
#'       ),
#'       pythonVirtualEnv = "string",
#'       runtimeRole = "string",
#'       trustedCertificatesS3Uri = "string"
#'     ),
#'     sparkGlueProperties = list(
#'       additionalArgs = list(
#'         connection = "string"
#'       ),
#'       glueConnectionName = "string",
#'       glueVersion = "string",
#'       idleTimeout = 123,
#'       javaVirtualEnv = "string",
#'       numberOfWorkers = 123,
#'       pythonVirtualEnv = "string",
#'       workerType = "string"
#'     )
#'   ),
#'   scope = "DOMAIN"|"PROJECT",
#'   type = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_connection(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   withSecret = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_connection
#'
#' @aliases datazone_get_connection
datazone_get_connection <- function(domainIdentifier, identifier, withSecret = NULL) {
  op <- new_operation(
    name = "GetConnection",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/connections/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_connection_input(domainIdentifier = domainIdentifier, identifier = identifier, withSecret = withSecret)
  output <- .datazone$get_connection_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_connection <- datazone_get_connection

#' Gets data export configuration details
#'
#' @description
#' Gets data export configuration details.
#'
#' @usage
#' datazone_get_data_export_configuration(domainIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to get the data export configuration
#' details.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   encryptionConfiguration = list(
#'     kmsKeyArn = "string",
#'     sseAlgorithm = "string"
#'   ),
#'   isExportEnabled = TRUE|FALSE,
#'   s3TableBucketArn = "string",
#'   status = "COMPLETED"|"FAILED",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_export_configuration(
#'   domainIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_data_export_configuration
#'
#' @aliases datazone_get_data_export_configuration
datazone_get_data_export_configuration <- function(domainIdentifier) {
  op <- new_operation(
    name = "GetDataExportConfiguration",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-export-configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_data_export_configuration_input(domainIdentifier = domainIdentifier)
  output <- .datazone$get_data_export_configuration_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_data_export_configuration <- datazone_get_data_export_configuration

#' Gets the data product
#'
#' @description
#' Gets the data product.
#' 
#' Prerequisites:
#' 
#' -   The data product ID must exist.
#' 
#' -   The domain must be valid and accessible.
#' 
#' -   User must have read or discovery permissions for the data product.
#'
#' @usage
#' datazone_get_data_product(domainIdentifier, identifier, revision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the data product lives.
#' @param identifier &#91;required&#93; The ID of the data product.
#' @param revision The revision of the data product.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   firstRevisionCreatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   firstRevisionCreatedBy = "string",
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   items = list(
#'     list(
#'       glossaryTerms = list(
#'         "string"
#'       ),
#'       identifier = "string",
#'       itemType = "ASSET",
#'       revision = "string"
#'     )
#'   ),
#'   name = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   status = "CREATED"|"CREATING"|"CREATE_FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_product(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_data_product
#'
#' @aliases datazone_get_data_product
datazone_get_data_product <- function(domainIdentifier, identifier, revision = NULL) {
  op <- new_operation(
    name = "GetDataProduct",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-products/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_data_product_input(domainIdentifier = domainIdentifier, identifier = identifier, revision = revision)
  output <- .datazone$get_data_product_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_data_product <- datazone_get_data_product

#' Gets an Amazon DataZone data source
#'
#' @description
#' Gets an Amazon DataZone data source.
#'
#' @usage
#' datazone_get_data_source(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the data source exists.
#' @param identifier &#91;required&#93; The ID of the Amazon DataZone data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       accountId = "string",
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       accountId = "string",
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       accountId = "string",
#'       region = "string",
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   connectionId = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   environmentId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   lastRunAssetCount = 123,
#'   lastRunAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastRunErrorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   lastRunStatus = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   name = "string",
#'   projectId = "string",
#'   publishOnImport = TRUE|FALSE,
#'   recommendation = list(
#'     enableBusinessNameGeneration = TRUE|FALSE
#'   ),
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   ),
#'   selfGrantStatus = list(
#'     glueSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     ),
#'     redshiftSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     )
#'   ),
#'   status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_source(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_data_source
#'
#' @aliases datazone_get_data_source
datazone_get_data_source <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetDataSource",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-sources/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_data_source_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_data_source_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_data_source <- datazone_get_data_source

#' Gets an Amazon DataZone data source run
#'
#' @description
#' Gets an Amazon DataZone data source run.
#'
#' @usage
#' datazone_get_data_source_run(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which this data source run was performed.
#' @param identifier &#91;required&#93; The ID of the data source run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   dataSourceConfigurationSnapshot = "string",
#'   dataSourceId = "string",
#'   domainId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   lineageSummary = list(
#'     importStatus = "IN_PROGRESS"|"SUCCESS"|"FAILED"|"PARTIALLY_SUCCEEDED"
#'   ),
#'   projectId = "string",
#'   runStatisticsForAssets = list(
#'     added = 123,
#'     failed = 123,
#'     skipped = 123,
#'     unchanged = 123,
#'     updated = 123
#'   ),
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   status = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   stoppedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   type = "PRIORITIZED"|"SCHEDULED",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_data_source_run(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_data_source_run
#'
#' @aliases datazone_get_data_source_run
datazone_get_data_source_run <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetDataSourceRun",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-source-runs/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_data_source_run_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_data_source_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_data_source_run <- datazone_get_data_source_run

#' Gets an Amazon DataZone domain
#'
#' @description
#' Gets an Amazon DataZone domain.
#'
#' @usage
#' datazone_get_domain(identifier)
#'
#' @param identifier &#91;required&#93; The identifier of the specified Amazon DataZone domain.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainExecutionRole = "string",
#'   domainVersion = "V1"|"V2",
#'   id = "string",
#'   kmsKeyIdentifier = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   portalUrl = "string",
#'   rootDomainUnitId = "string",
#'   serviceRole = "string",
#'   singleSignOn = list(
#'     idcInstanceArn = "string",
#'     type = "IAM_IDC"|"DISABLED",
#'     userAssignment = "AUTOMATIC"|"MANUAL"
#'   ),
#'   status = "CREATING"|"AVAILABLE"|"CREATION_FAILED"|"DELETING"|"DELETED"|"DELETION_FAILED",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_domain(
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_domain
#'
#' @aliases datazone_get_domain
datazone_get_domain <- function(identifier) {
  op <- new_operation(
    name = "GetDomain",
    http_method = "GET",
    http_path = "/v2/domains/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_domain_input(identifier = identifier)
  output <- .datazone$get_domain_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_domain <- datazone_get_domain

#' Gets the details of the specified domain unit
#'
#' @description
#' Gets the details of the specified domain unit.
#'
#' @usage
#' datazone_get_domain_unit(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to get a domain unit.
#' @param identifier &#91;required&#93; The identifier of the domain unit that you want to get.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedBy = "string",
#'   name = "string",
#'   owners = list(
#'     list(
#'       group = list(
#'         groupId = "string"
#'       ),
#'       user = list(
#'         userId = "string"
#'       )
#'     )
#'   ),
#'   parentDomainUnitId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_domain_unit(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_domain_unit
#'
#' @aliases datazone_get_domain_unit
datazone_get_domain_unit <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetDomainUnit",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/domain-units/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_domain_unit_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_domain_unit_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_domain_unit <- datazone_get_domain_unit

#' Gets an Amazon DataZone environment
#'
#' @description
#' Gets an Amazon DataZone environment.
#'
#' @usage
#' datazone_get_environment(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where the environment exists.
#' @param identifier &#91;required&#93; The ID of the Amazon DataZone environment.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   environmentActions = list(
#'     list(
#'       auth = "IAM"|"HTTPS",
#'       parameters = list(
#'         list(
#'           key = "string",
#'           value = "string"
#'         )
#'       ),
#'       type = "string"
#'     )
#'   ),
#'   environmentBlueprintId = "string",
#'   environmentConfigurationId = "string",
#'   environmentProfileId = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastDeployment = list(
#'     deploymentId = "string",
#'     deploymentStatus = "IN_PROGRESS"|"SUCCESSFUL"|"FAILED"|"PENDING_DEPLOYMENT",
#'     deploymentType = "CREATE"|"UPDATE"|"DELETE",
#'     failureReason = list(
#'       code = "string",
#'       message = "string"
#'     ),
#'     isDeploymentComplete = TRUE|FALSE,
#'     messages = list(
#'       "string"
#'     )
#'   ),
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   provisionedResources = list(
#'     list(
#'       name = "string",
#'       provider = "string",
#'       type = "string",
#'       value = "string"
#'     )
#'   ),
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   status = "ACTIVE"|"CREATING"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|"VALIDATION_FAILED"|"SUSPENDED"|"DISABLED"|"EXPIRED"|"DELETED"|"INACCESSIBLE",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment
#'
#' @aliases datazone_get_environment
datazone_get_environment <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetEnvironment",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_environment_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment <- datazone_get_environment

#' Gets the specified environment action
#'
#' @description
#' Gets the specified environment action.
#'
#' @usage
#' datazone_get_environment_action(domainIdentifier, environmentIdentifier,
#'   identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the
#' [`get_environment_action`][datazone_get_environment_action] API is
#' invoked.
#' @param environmentIdentifier &#91;required&#93; The environment ID of the environment action.
#' @param identifier &#91;required&#93; The ID of the environment action
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   name = "string",
#'   parameters = list(
#'     awsConsoleLink = list(
#'       uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment_action(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment_action
#'
#' @aliases datazone_get_environment_action
datazone_get_environment_action <- function(domainIdentifier, environmentIdentifier, identifier) {
  op <- new_operation(
    name = "GetEnvironmentAction",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_action_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier)
  output <- .datazone$get_environment_action_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment_action <- datazone_get_environment_action

#' Gets an Amazon DataZone blueprint
#'
#' @description
#' Gets an Amazon DataZone blueprint.
#'
#' @usage
#' datazone_get_environment_blueprint(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the domain in which this blueprint exists.
#' @param identifier &#91;required&#93; The ID of this Amazon DataZone blueprint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   name = "string",
#'   provider = "string",
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment_blueprint(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment_blueprint
#'
#' @aliases datazone_get_environment_blueprint
datazone_get_environment_blueprint <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetEnvironmentBlueprint",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_blueprint_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_environment_blueprint_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment_blueprint <- datazone_get_environment_blueprint

#' Gets the blueprint configuration in Amazon DataZone
#'
#' @description
#' Gets the blueprint configuration in Amazon DataZone.
#'
#' @usage
#' datazone_get_environment_blueprint_configuration(domainIdentifier,
#'   environmentBlueprintIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where this blueprint exists.
#' @param environmentBlueprintIdentifier &#91;required&#93; He ID of the blueprint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   domainId = "string",
#'   enabledRegions = list(
#'     "string"
#'   ),
#'   environmentBlueprintId = "string",
#'   environmentRolePermissionBoundary = "string",
#'   manageAccessRoleArn = "string",
#'   provisioningConfigurations = list(
#'     list(
#'       lakeFormationConfiguration = list(
#'         locationRegistrationExcludeS3Locations = list(
#'           "string"
#'         ),
#'         locationRegistrationRole = "string"
#'       )
#'     )
#'   ),
#'   provisioningRoleArn = "string",
#'   regionalParameters = list(
#'     list(
#'       "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment_blueprint_configuration(
#'   domainIdentifier = "string",
#'   environmentBlueprintIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment_blueprint_configuration
#'
#' @aliases datazone_get_environment_blueprint_configuration
datazone_get_environment_blueprint_configuration <- function(domainIdentifier, environmentBlueprintIdentifier) {
  op <- new_operation(
    name = "GetEnvironmentBlueprintConfiguration",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_blueprint_configuration_input(domainIdentifier = domainIdentifier, environmentBlueprintIdentifier = environmentBlueprintIdentifier)
  output <- .datazone$get_environment_blueprint_configuration_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment_blueprint_configuration <- datazone_get_environment_blueprint_configuration

#' Gets the credentials of an environment in Amazon DataZone
#'
#' @description
#' Gets the credentials of an environment in Amazon DataZone.
#'
#' @usage
#' datazone_get_environment_credentials(domainIdentifier,
#'   environmentIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this environment and its
#' credentials exist.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment whose credentials this operation gets.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accessKeyId = "string",
#'   expiration = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   secretAccessKey = "string",
#'   sessionToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment_credentials(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment_credentials
#'
#' @aliases datazone_get_environment_credentials
datazone_get_environment_credentials <- function(domainIdentifier, environmentIdentifier) {
  op <- new_operation(
    name = "GetEnvironmentCredentials",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/credentials",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_credentials_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier)
  output <- .datazone$get_environment_credentials_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment_credentials <- datazone_get_environment_credentials

#' Gets an evinronment profile in Amazon DataZone
#'
#' @description
#' Gets an evinronment profile in Amazon DataZone.
#'
#' @usage
#' datazone_get_environment_profile(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this environment profile
#' exists.
#' @param identifier &#91;required&#93; The ID of the environment profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   environmentBlueprintId = "string",
#'   id = "string",
#'   name = "string",
#'   projectId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_environment_profile(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_environment_profile
#'
#' @aliases datazone_get_environment_profile
datazone_get_environment_profile <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetEnvironmentProfile",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_environment_profile_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_environment_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_environment_profile <- datazone_get_environment_profile

#' Gets a metadata form type in Amazon DataZone
#'
#' @description
#' Gets a metadata form type in Amazon DataZone.
#' 
#' Form types define the structure and validation rules for collecting
#' metadata about assets in Amazon DataZone. They act as templates that
#' ensure consistent metadata capture across similar types of assets, while
#' allowing for customization to meet specific organizational needs. Form
#' types can include required fields, validation rules, and dependencies,
#' helping maintain high-quality metadata that makes data assets more
#' discoverable and usable.
#' 
#' -   The form type with the specified identifier must exist in the given
#'     domain.
#' 
#' -   The domain must be valid and active.
#' 
#' -   User must have permission on the form type.
#' 
#' -   The form type should not be deleted or in an invalid state.
#' 
#' One use case for this API is to determine whether a form field is
#' indexed for search.
#' 
#' A searchable field will be annotated with `@@amazon.datazone#searchable`.
#' By default, searchable fields are indexed for semantic search, where
#' related query terms will match the attribute value even if they are not
#' stemmed or keyword matches. If a field is indexed technical identifier
#' search, it will be annotated with
#' `@@amazon.datazone#searchable(modes:["TECHNICAL"])`. If a field is
#' indexed for lexical search (supports stemmed and prefix matches but not
#' semantic matches), it will be annotated with
#' `@@amazon.datazone#searchable(modes:["LEXICAL"])`.
#' 
#' A field storing glossary term IDs (which is filterable) will be
#' annotated with `@@amazon.datazone#glossaryterm("${glossaryId}")`.
#'
#' @usage
#' datazone_get_form_type(domainIdentifier, formTypeIdentifier, revision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this metadata form type
#' exists.
#' @param formTypeIdentifier &#91;required&#93; The ID of the metadata form type.
#' @param revision The revision of this metadata form type.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   imports = list(
#'     list(
#'       name = "string",
#'       revision = "string"
#'     )
#'   ),
#'   model = list(
#'     smithy = "string"
#'   ),
#'   name = "string",
#'   originDomainId = "string",
#'   originProjectId = "string",
#'   owningProjectId = "string",
#'   revision = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_form_type(
#'   domainIdentifier = "string",
#'   formTypeIdentifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_form_type
#'
#' @aliases datazone_get_form_type
datazone_get_form_type <- function(domainIdentifier, formTypeIdentifier, revision = NULL) {
  op <- new_operation(
    name = "GetFormType",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/form-types/{formTypeIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_form_type_input(domainIdentifier = domainIdentifier, formTypeIdentifier = formTypeIdentifier, revision = revision)
  output <- .datazone$get_form_type_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_form_type <- datazone_get_form_type

#' Gets a business glossary in Amazon DataZone
#'
#' @description
#' Gets a business glossary in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The specified glossary ID must exist and be associated with the
#'     given domain.
#' 
#' -   The caller must have the `datazone:GetGlossary` permission on the
#'     domain.
#'
#' @usage
#' datazone_get_glossary(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this business glossary
#' exists.
#' @param identifier &#91;required&#93; The ID of the business glossary.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   name = "string",
#'   owningProjectId = "string",
#'   status = "DISABLED"|"ENABLED",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string",
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_glossary(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_glossary
#'
#' @aliases datazone_get_glossary
datazone_get_glossary <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetGlossary",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/glossaries/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_glossary_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_glossary_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_glossary <- datazone_get_glossary

#' Gets a business glossary term in Amazon DataZone
#'
#' @description
#' Gets a business glossary term in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   Glossary term with identifier must exist in the domain.
#' 
#' -   User must have permission on the glossary term.
#' 
#' -   Domain must be accessible and active.
#'
#' @usage
#' datazone_get_glossary_term(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which this business glossary
#' term exists.
#' @param identifier &#91;required&#93; The ID of the business glossary term.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   glossaryId = "string",
#'   id = "string",
#'   longDescription = "string",
#'   name = "string",
#'   shortDescription = "string",
#'   status = "ENABLED"|"DISABLED",
#'   termRelations = list(
#'     classifies = list(
#'       "string"
#'     ),
#'     isA = list(
#'       "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string",
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_glossary_term(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_glossary_term
#'
#' @aliases datazone_get_glossary_term
datazone_get_glossary_term <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetGlossaryTerm",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_glossary_term_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_glossary_term_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_glossary_term <- datazone_get_glossary_term

#' Gets a group profile in Amazon DataZone
#'
#' @description
#' Gets a group profile in Amazon DataZone.
#'
#' @usage
#' datazone_get_group_profile(domainIdentifier, groupIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which the group profile
#' exists.
#' @param groupIdentifier &#91;required&#93; The identifier of the group profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   groupName = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_group_profile(
#'   domainIdentifier = "string",
#'   groupIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_group_profile
#'
#' @aliases datazone_get_group_profile
datazone_get_group_profile <- function(domainIdentifier, groupIdentifier) {
  op <- new_operation(
    name = "GetGroupProfile",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_group_profile_input(domainIdentifier = domainIdentifier, groupIdentifier = groupIdentifier)
  output <- .datazone$get_group_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_group_profile <- datazone_get_group_profile

#' Gets the data portal URL for the specified Amazon DataZone domain
#'
#' @description
#' Gets the data portal URL for the specified Amazon DataZone domain.
#'
#' @usage
#' datazone_get_iam_portal_login_url(domainIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; the ID of the Amazon DataZone domain the data portal of which you want
#' to get.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   authCodeUrl = "string",
#'   userProfileId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_iam_portal_login_url(
#'   domainIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_iam_portal_login_url
#'
#' @aliases datazone_get_iam_portal_login_url
datazone_get_iam_portal_login_url <- function(domainIdentifier) {
  op <- new_operation(
    name = "GetIamPortalLoginUrl",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/get-portal-login-url",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_iam_portal_login_url_input(domainIdentifier = domainIdentifier)
  output <- .datazone$get_iam_portal_login_url_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_iam_portal_login_url <- datazone_get_iam_portal_login_url

#' The details of the job run
#'
#' @description
#' The details of the job run.
#'
#' @usage
#' datazone_get_job_run(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain.
#' @param identifier &#91;required&#93; The ID of the job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   details = list(
#'     lineageRunDetails = list(
#'       sqlQueryRunDetails = list(
#'         errorMessages = list(
#'           "string"
#'         ),
#'         numQueriesFailed = 123,
#'         queryEndTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         queryStartTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         totalQueriesProcessed = 123
#'       )
#'     )
#'   ),
#'   domainId = "string",
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   error = list(
#'     message = "string"
#'   ),
#'   id = "string",
#'   jobId = "string",
#'   jobType = "LINEAGE",
#'   runMode = "SCHEDULED"|"ON_DEMAND",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   status = "SCHEDULED"|"IN_PROGRESS"|"SUCCESS"|"PARTIALLY_SUCCEEDED"|"FAILED"|"ABORTED"|"TIMED_OUT"|"CANCELED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_run(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_job_run
#'
#' @aliases datazone_get_job_run
datazone_get_job_run <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetJobRun",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/jobRuns/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_job_run_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_job_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_job_run <- datazone_get_job_run

#' Describes the lineage event
#'
#' @description
#' Describes the lineage event.
#'
#' @usage
#' datazone_get_lineage_event(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain.
#' @param identifier &#91;required&#93; The ID of the lineage event.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   event = raw,
#'   eventTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   id = "string",
#'   processingStatus = "REQUESTED"|"PROCESSING"|"SUCCESS"|"FAILED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lineage_event(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_lineage_event
#'
#' @aliases datazone_get_lineage_event
datazone_get_lineage_event <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetLineageEvent",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/lineage/events/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_lineage_event_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_lineage_event_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_lineage_event <- datazone_get_lineage_event

#' Gets the data lineage node
#'
#' @description
#' Gets the data lineage node.
#'
#' @usage
#' datazone_get_lineage_node(domainIdentifier, eventTimestamp, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which you want to get the data lineage node.
#' @param eventTimestamp The event time stamp for which you want to get the data lineage node.
#' @param identifier &#91;required&#93; The ID of the data lineage node that you want to get.
#' 
#' Both, a lineage node identifier generated by Amazon DataZone and a
#' `sourceIdentifier` of the lineage node are supported. If
#' `sourceIdentifier` is greater than 1800 characters, you can use lineage
#' node identifier generated by Amazon DataZone to get the node details.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   downstreamNodes = list(
#'     list(
#'       eventTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       id = "string"
#'     )
#'   ),
#'   eventTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   formsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   id = "string",
#'   name = "string",
#'   sourceIdentifier = "string",
#'   typeName = "string",
#'   typeRevision = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string",
#'   upstreamNodes = list(
#'     list(
#'       eventTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       id = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_lineage_node(
#'   domainIdentifier = "string",
#'   eventTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_lineage_node
#'
#' @aliases datazone_get_lineage_node
datazone_get_lineage_node <- function(domainIdentifier, eventTimestamp = NULL, identifier) {
  op <- new_operation(
    name = "GetLineageNode",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/lineage/nodes/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_lineage_node_input(domainIdentifier = domainIdentifier, eventTimestamp = eventTimestamp, identifier = identifier)
  output <- .datazone$get_lineage_node_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_lineage_node <- datazone_get_lineage_node

#' Gets a listing (a record of an asset at a given time)
#'
#' @description
#' Gets a listing (a record of an asset at a given time). If you specify a
#' listing version, only details that are specific to that version are
#' returned.
#'
#' @usage
#' datazone_get_listing(domainIdentifier, identifier, listingRevision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain.
#' @param identifier &#91;required&#93; The ID of the listing.
#' @param listingRevision The revision of the listing.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   item = list(
#'     assetListing = list(
#'       assetId = "string",
#'       assetRevision = "string",
#'       assetType = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       forms = "string",
#'       glossaryTerms = list(
#'         list(
#'           name = "string",
#'           shortDescription = "string"
#'         )
#'       ),
#'       governedGlossaryTerms = list(
#'         list(
#'           name = "string",
#'           shortDescription = "string"
#'         )
#'       ),
#'       latestTimeSeriesDataPointForms = list(
#'         list(
#'           contentSummary = "string",
#'           formName = "string",
#'           id = "string",
#'           timestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       ),
#'       owningProjectId = "string"
#'     ),
#'     dataProductListing = list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       dataProductId = "string",
#'       dataProductRevision = "string",
#'       forms = "string",
#'       glossaryTerms = list(
#'         list(
#'           name = "string",
#'           shortDescription = "string"
#'         )
#'       ),
#'       items = list(
#'         list(
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           listingId = "string",
#'           listingRevision = "string"
#'         )
#'       ),
#'       owningProjectId = "string"
#'     )
#'   ),
#'   listingRevision = "string",
#'   name = "string",
#'   status = "CREATING"|"ACTIVE"|"INACTIVE",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_listing(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   listingRevision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_listing
#'
#' @aliases datazone_get_listing
datazone_get_listing <- function(domainIdentifier, identifier, listingRevision = NULL) {
  op <- new_operation(
    name = "GetListing",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/listings/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_listing_input(domainIdentifier = domainIdentifier, identifier = identifier, listingRevision = listingRevision)
  output <- .datazone$get_listing_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_listing <- datazone_get_listing

#' Gets a metadata generation run in Amazon DataZone
#'
#' @description
#' Gets a metadata generation run in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   Valid domain and run identifier.
#' 
#' -   The metadata generation run must exist.
#' 
#' -   User must have read access to the metadata run.
#'
#' @usage
#' datazone_get_metadata_generation_run(domainIdentifier, identifier, type)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain the metadata generation run of
#' which you want to get.
#' @param identifier &#91;required&#93; The identifier of the metadata generation run.
#' @param type The type of the metadata generation run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   id = "string",
#'   owningProjectId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELED"|"SUCCEEDED"|"FAILED"|"PARTIALLY_SUCCEEDED",
#'   target = list(
#'     identifier = "string",
#'     revision = "string",
#'     type = "ASSET"
#'   ),
#'   type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS",
#'   typeStats = list(
#'     list(
#'       errorMessage = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELED"|"SUCCEEDED"|"FAILED"|"PARTIALLY_SUCCEEDED",
#'       type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#'     )
#'   ),
#'   types = list(
#'     "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_metadata_generation_run(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_metadata_generation_run
#'
#' @aliases datazone_get_metadata_generation_run
datazone_get_metadata_generation_run <- function(domainIdentifier, identifier, type = NULL) {
  op <- new_operation(
    name = "GetMetadataGenerationRun",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/metadata-generation-runs/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_metadata_generation_run_input(domainIdentifier = domainIdentifier, identifier = identifier, type = type)
  output <- .datazone$get_metadata_generation_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_metadata_generation_run <- datazone_get_metadata_generation_run

#' Gets a project in Amazon DataZone
#'
#' @description
#' Gets a project in Amazon DataZone.
#'
#' @usage
#' datazone_get_project(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the project exists.
#' @param identifier &#91;required&#93; The ID of the project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentDeploymentDetails = list(
#'     environmentFailureReasons = list(
#'       list(
#'         list(
#'           code = "string",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     overallDeploymentStatus = "PENDING_DEPLOYMENT"|"IN_PROGRESS"|"SUCCESSFUL"|"FAILED_VALIDATION"|"FAILED_DEPLOYMENT"
#'   ),
#'   failureReasons = list(
#'     list(
#'       code = "string",
#'       message = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectProfileId = "string",
#'   projectStatus = "ACTIVE"|"DELETING"|"DELETE_FAILED"|"UPDATING"|"UPDATE_FAILED"|"MOVING",
#'   resourceTags = list(
#'     list(
#'       key = "string",
#'       source = "PROJECT"|"PROJECT_PROFILE",
#'       value = "string"
#'     )
#'   ),
#'   userParameters = list(
#'     list(
#'       environmentConfigurationName = "string",
#'       environmentId = "string",
#'       environmentParameters = list(
#'         list(
#'           name = "string",
#'           value = "string"
#'         )
#'       ),
#'       environmentResolvedAccount = list(
#'         awsAccountId = "string",
#'         regionName = "string",
#'         sourceAccountPoolId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_project(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_project
#'
#' @aliases datazone_get_project
datazone_get_project <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetProject",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/projects/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_project_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_project_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_project <- datazone_get_project

#' The details of the project profile
#'
#' @description
#' The details of the project profile.
#'
#' @usage
#' datazone_get_project_profile(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain.
#' @param identifier &#91;required&#93; The ID of the project profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   allowCustomProjectResourceTags = TRUE|FALSE,
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentConfigurations = list(
#'     list(
#'       accountPools = list(
#'         "string"
#'       ),
#'       awsAccount = list(
#'         awsAccountId = "string",
#'         awsAccountIdPath = "string"
#'       ),
#'       awsRegion = list(
#'         regionName = "string",
#'         regionNamePath = "string"
#'       ),
#'       configurationParameters = list(
#'         parameterOverrides = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         resolvedParameters = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         ssmPath = "string"
#'       ),
#'       deploymentMode = "ON_CREATE"|"ON_DEMAND",
#'       deploymentOrder = 123,
#'       description = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectResourceTags = list(
#'     list(
#'       isValueEditable = TRUE|FALSE,
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   projectResourceTagsDescription = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_project_profile(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_project_profile
#'
#' @aliases datazone_get_project_profile
datazone_get_project_profile <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetProjectProfile",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/project-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_project_profile_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_project_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_project_profile <- datazone_get_project_profile

#' Gets the details of a rule in Amazon DataZone
#'
#' @description
#' Gets the details of a rule in Amazon DataZone. A rule is a formal
#' agreement that enforces specific requirements across user workflows
#' (e.g., publishing assets to the catalog, requesting subscriptions,
#' creating projects) within the Amazon DataZone data portal. These rules
#' help maintain consistency, ensure compliance, and uphold governance
#' standards in data management processes. For instance, a metadata
#' enforcement rule can specify the required information for creating a
#' subscription request or publishing a data asset to the catalog, ensuring
#' alignment with organizational standards.
#'
#' @usage
#' datazone_get_rule(domainIdentifier, identifier, revision)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the [`get_rule`][datazone_get_rule] action is
#' to be invoked.
#' @param identifier &#91;required&#93; The ID of the rule.
#' @param revision The revision of the rule.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   detail = list(
#'     glossaryTermEnforcementDetail = list(
#'       requiredGlossaryTermIds = list(
#'         "string"
#'       )
#'     ),
#'     metadataFormEnforcementDetail = list(
#'       requiredMetadataForms = list(
#'         list(
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   identifier = "string",
#'   lastUpdatedBy = "string",
#'   name = "string",
#'   revision = "string",
#'   ruleType = "METADATA_FORM_ENFORCEMENT"|"GLOSSARY_TERM_ENFORCEMENT",
#'   scope = list(
#'     assetType = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificAssetTypes = list(
#'         "string"
#'       )
#'     ),
#'     dataProduct = TRUE|FALSE,
#'     project = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificProjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   target = list(
#'     domainUnitTarget = list(
#'       domainUnitId = "string",
#'       includeChildDomainUnits = TRUE|FALSE
#'     )
#'   ),
#'   targetType = "DOMAIN_UNIT",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_rule(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_rule
#'
#' @aliases datazone_get_rule
datazone_get_rule <- function(domainIdentifier, identifier, revision = NULL) {
  op <- new_operation(
    name = "GetRule",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/rules/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_rule_input(domainIdentifier = domainIdentifier, identifier = identifier, revision = revision)
  output <- .datazone$get_rule_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_rule <- datazone_get_rule

#' Gets a subscription in Amazon DataZone
#'
#' @description
#' Gets a subscription in Amazon DataZone.
#'
#' @usage
#' datazone_get_subscription(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription exists.
#' @param identifier &#91;required&#93; The ID of the subscription.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   id = "string",
#'   retainPermissions = TRUE|FALSE,
#'   status = "APPROVED"|"REVOKED"|"CANCELLED",
#'   subscribedListing = list(
#'     description = "string",
#'     id = "string",
#'     item = list(
#'       assetListing = list(
#'         assetScope = list(
#'           assetId = "string",
#'           errorMessage = "string",
#'           filterIds = list(
#'             "string"
#'           ),
#'           status = "string"
#'         ),
#'         entityId = "string",
#'         entityRevision = "string",
#'         entityType = "string",
#'         forms = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         permissions = list(
#'           s3 = list(
#'             "READ"|"WRITE"
#'           )
#'         )
#'       ),
#'       productListing = list(
#'         assetListings = list(
#'           list(
#'             entityId = "string",
#'             entityRevision = "string",
#'             entityType = "string"
#'           )
#'         ),
#'         description = "string",
#'         entityId = "string",
#'         entityRevision = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         name = "string"
#'       )
#'     ),
#'     name = "string",
#'     ownerProjectId = "string",
#'     ownerProjectName = "string",
#'     revision = "string"
#'   ),
#'   subscribedPrincipal = list(
#'     group = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     project = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     user = list(
#'       details = list(
#'         iam = list(
#'           arn = "string",
#'           principalId = "string"
#'         ),
#'         sso = list(
#'           firstName = "string",
#'           lastName = "string",
#'           username = "string"
#'         )
#'       ),
#'       id = "string"
#'     )
#'   ),
#'   subscriptionRequestId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_subscription(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_subscription
#'
#' @aliases datazone_get_subscription
datazone_get_subscription <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetSubscription",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscriptions/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_subscription_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_subscription_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_subscription <- datazone_get_subscription

#' Gets the subscription grant in Amazon DataZone
#'
#' @description
#' Gets the subscription grant in Amazon DataZone.
#'
#' @usage
#' datazone_get_subscription_grant(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription grant
#' exists.
#' @param identifier &#91;required&#93; The ID of the subscription grant.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assets = list(
#'     list(
#'       assetId = "string",
#'       assetRevision = "string",
#'       assetScope = list(
#'         assetId = "string",
#'         errorMessage = "string",
#'         filterIds = list(
#'           "string"
#'         ),
#'         status = "string"
#'       ),
#'       failureCause = list(
#'         message = "string"
#'       ),
#'       failureTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       grantedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       ),
#'       status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'       targetName = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   grantedEntity = list(
#'     listing = list(
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   id = "string",
#'   status = "PENDING"|"IN_PROGRESS"|"GRANT_FAILED"|"REVOKE_FAILED"|"GRANT_AND_REVOKE_FAILED"|"COMPLETED"|"INACCESSIBLE",
#'   subscriptionId = "string",
#'   subscriptionTargetId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_subscription_grant(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_subscription_grant
#'
#' @aliases datazone_get_subscription_grant
datazone_get_subscription_grant <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetSubscriptionGrant",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_subscription_grant_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_subscription_grant_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_subscription_grant <- datazone_get_subscription_grant

#' Gets the details of the specified subscription request
#'
#' @description
#' Gets the details of the specified subscription request.
#'
#' @usage
#' datazone_get_subscription_request_details(domainIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to get the
#' subscription request details.
#' @param identifier &#91;required&#93; The identifier of the subscription request the details of which to get.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   decisionComment = "string",
#'   domainId = "string",
#'   existingSubscriptionId = "string",
#'   id = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   reviewerId = "string",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListings = list(
#'     list(
#'       description = "string",
#'       id = "string",
#'       item = list(
#'         assetListing = list(
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           entityId = "string",
#'           entityRevision = "string",
#'           entityType = "string",
#'           forms = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           )
#'         ),
#'         productListing = list(
#'           assetListings = list(
#'             list(
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string"
#'             )
#'           ),
#'           description = "string",
#'           entityId = "string",
#'           entityRevision = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           name = "string"
#'         )
#'       ),
#'       name = "string",
#'       ownerProjectId = "string",
#'       ownerProjectName = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       project = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       user = list(
#'         details = list(
#'           iam = list(
#'             arn = "string",
#'             principalId = "string"
#'           ),
#'           sso = list(
#'             firstName = "string",
#'             lastName = "string",
#'             username = "string"
#'           )
#'         ),
#'         id = "string"
#'       )
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_subscription_request_details(
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_subscription_request_details
#'
#' @aliases datazone_get_subscription_request_details
datazone_get_subscription_request_details <- function(domainIdentifier, identifier) {
  op <- new_operation(
    name = "GetSubscriptionRequestDetails",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_subscription_request_details_input(domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$get_subscription_request_details_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_subscription_request_details <- datazone_get_subscription_request_details

#' Gets the subscription target in Amazon DataZone
#'
#' @description
#' Gets the subscription target in Amazon DataZone.
#'
#' @usage
#' datazone_get_subscription_target(domainIdentifier,
#'   environmentIdentifier, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the subscription target
#' exists.
#' @param environmentIdentifier &#91;required&#93; The ID of the environment associated with the subscription target.
#' @param identifier &#91;required&#93; The ID of the subscription target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicableAssetTypes = list(
#'     "string"
#'   ),
#'   authorizedPrincipals = list(
#'     "string"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   manageAccessRole = "string",
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   subscriptionTargetConfig = list(
#'     list(
#'       content = "string",
#'       formName = "string"
#'     )
#'   ),
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_subscription_target(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_subscription_target
#'
#' @aliases datazone_get_subscription_target
datazone_get_subscription_target <- function(domainIdentifier, environmentIdentifier, identifier) {
  op <- new_operation(
    name = "GetSubscriptionTarget",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_subscription_target_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier)
  output <- .datazone$get_subscription_target_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_subscription_target <- datazone_get_subscription_target

#' Gets the existing data point for the asset
#'
#' @description
#' Gets the existing data point for the asset.
#'
#' @usage
#' datazone_get_time_series_data_point(domainIdentifier, entityIdentifier,
#'   entityType, formName, identifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain that houses the asset for which you
#' want to get the data point.
#' @param entityIdentifier &#91;required&#93; The ID of the asset for which you want to get the data point.
#' @param entityType &#91;required&#93; The type of the asset for which you want to get the data point.
#' @param formName &#91;required&#93; The name of the time series form that houses the data point that you
#' want to get.
#' @param identifier &#91;required&#93; The ID of the data point that you want to get.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   entityId = "string",
#'   entityType = "ASSET"|"LISTING",
#'   form = list(
#'     content = "string",
#'     formName = "string",
#'     id = "string",
#'     timestamp = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     typeIdentifier = "string",
#'     typeRevision = "string"
#'   ),
#'   formName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_time_series_data_point(
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET"|"LISTING",
#'   formName = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_time_series_data_point
#'
#' @aliases datazone_get_time_series_data_point
datazone_get_time_series_data_point <- function(domainIdentifier, entityIdentifier, entityType, formName, identifier) {
  op <- new_operation(
    name = "GetTimeSeriesDataPoint",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_time_series_data_point_input(domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, formName = formName, identifier = identifier)
  output <- .datazone$get_time_series_data_point_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_time_series_data_point <- datazone_get_time_series_data_point

#' Gets a user profile in Amazon DataZone
#'
#' @description
#' Gets a user profile in Amazon DataZone.
#'
#' @usage
#' datazone_get_user_profile(domainIdentifier, type, userIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; the ID of the Amazon DataZone domain the data portal of which you want
#' to get.
#' @param type The type of the user profile.
#' @param userIdentifier &#91;required&#93; The identifier of the user for which you want to get the user profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   details = list(
#'     iam = list(
#'       arn = "string",
#'       principalId = "string"
#'     ),
#'     sso = list(
#'       firstName = "string",
#'       lastName = "string",
#'       username = "string"
#'     )
#'   ),
#'   domainId = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"|"ACTIVATED"|"DEACTIVATED",
#'   type = "IAM"|"SSO"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_user_profile(
#'   domainIdentifier = "string",
#'   type = "IAM"|"SSO",
#'   userIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_get_user_profile
#'
#' @aliases datazone_get_user_profile
datazone_get_user_profile <- function(domainIdentifier, type = NULL, userIdentifier) {
  op <- new_operation(
    name = "GetUserProfile",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$get_user_profile_input(domainIdentifier = domainIdentifier, type = type, userIdentifier = userIdentifier)
  output <- .datazone$get_user_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$get_user_profile <- datazone_get_user_profile

#' Lists existing account pools
#'
#' @description
#' Lists existing account pools.
#'
#' @usage
#' datazone_list_account_pools(domainIdentifier, maxResults, name,
#'   nextToken, sortBy, sortOrder)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where exsting account pools are to be listed.
#' @param maxResults The maximum number of account pools to return in a single call to
#' ListAccountPools. When the number of account pools to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListAccountPools to list
#' the next set of account pools.
#' @param name The name of the account pool to be listed.
#' @param nextToken When the number of account pools is greater than the default value for
#' the MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of account pools, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListAccountPools to list the
#' next set of account pools.
#' @param sortBy The sort by mechanism in which the existing account pools are to be
#' listed.
#' @param sortOrder The sort order in which the existing account pools are to be listed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdBy = "string",
#'       domainId = "string",
#'       domainUnitId = "string",
#'       id = "string",
#'       name = "string",
#'       resolutionStrategy = "MANUAL",
#'       updatedBy = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_account_pools(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   sortBy = "NAME",
#'   sortOrder = "ASCENDING"|"DESCENDING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_account_pools
#'
#' @aliases datazone_list_account_pools
datazone_list_account_pools <- function(domainIdentifier, maxResults = NULL, name = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListAccountPools",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/account-pools",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_account_pools_input(domainIdentifier = domainIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .datazone$list_account_pools_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_account_pools <- datazone_list_account_pools

#' Lists the accounts in the specified account pool
#'
#' @description
#' Lists the accounts in the specified account pool.
#'
#' @usage
#' datazone_list_accounts_in_account_pool(domainIdentifier, identifier,
#'   maxResults, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which the accounts in the specified account pool
#' are to be listed.
#' @param identifier &#91;required&#93; The ID of the account pool whose accounts are to be listed.
#' @param maxResults The maximum number of accounts to return in a single call to
#' ListAccountsInAccountPool. When the number of accounts to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListAccountsInAccountPool
#' to list the next set of accounts.
#' @param nextToken When the number of accounts is greater than the default value for the
#' MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of accounts, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListAccountsInAccountPool to
#' list the next set of accounts.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       awsAccountId = "string",
#'       awsAccountName = "string",
#'       supportedRegions = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_accounts_in_account_pool(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_accounts_in_account_pool
#'
#' @aliases datazone_list_accounts_in_account_pool
datazone_list_accounts_in_account_pool <- function(domainIdentifier, identifier, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAccountsInAccountPool",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/account-pools/{identifier}/accounts",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_accounts_in_account_pool_input(domainIdentifier = domainIdentifier, identifier = identifier, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_accounts_in_account_pool_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_accounts_in_account_pool <- datazone_list_accounts_in_account_pool

#' Lists asset filters
#'
#' @description
#' Lists asset filters.
#' 
#' Prerequisites:
#' 
#' -   A valid domain and asset must exist.
#' 
#' -   The asset must have at least one filter created to return results.
#'
#' @usage
#' datazone_list_asset_filters(assetIdentifier, domainIdentifier,
#'   maxResults, nextToken, status)
#'
#' @param assetIdentifier &#91;required&#93; The ID of the data asset.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list asset filters.
#' @param maxResults The maximum number of asset filters to return in a single call to
#' [`list_asset_filters`][datazone_list_asset_filters]. When the number of
#' asset filters to be listed is greater than the value of `MaxResults`,
#' the response contains a `NextToken` value that you can use in a
#' subsequent call to [`list_asset_filters`][datazone_list_asset_filters]
#' to list the next set of asset filters.
#' @param nextToken When the number of asset filters is greater than the default value for
#' the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of asset filters, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_asset_filters`][datazone_list_asset_filters] to list the next set
#' of asset filters.
#' @param status The status of the asset filter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       assetId = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       description = "string",
#'       domainId = "string",
#'       effectiveColumnNames = list(
#'         "string"
#'       ),
#'       effectiveRowFilter = "string",
#'       errorMessage = "string",
#'       id = "string",
#'       name = "string",
#'       status = "VALID"|"INVALID"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_asset_filters(
#'   assetIdentifier = "string",
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   status = "VALID"|"INVALID"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_asset_filters
#'
#' @aliases datazone_list_asset_filters
datazone_list_asset_filters <- function(assetIdentifier, domainIdentifier, maxResults = NULL, nextToken = NULL, status = NULL) {
  op <- new_operation(
    name = "ListAssetFilters",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_asset_filters_input(assetIdentifier = assetIdentifier, domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, status = status)
  output <- .datazone$list_asset_filters_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_asset_filters <- datazone_list_asset_filters

#' Lists the revisions for the asset
#'
#' @description
#' Lists the revisions for the asset.
#' 
#' Prerequisites:
#' 
#' -   The asset must exist in the domain.
#' 
#' -   There must be at least one revision of the asset (which happens
#'     automatically after creation).
#' 
#' -   The domain must be valid and active.
#' 
#' -   User must have permissions on the asset and domain.
#'
#' @usage
#' datazone_list_asset_revisions(domainIdentifier, identifier, maxResults,
#'   nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the domain.
#' @param identifier &#91;required&#93; The identifier of the asset.
#' @param maxResults The maximum number of revisions to return in a single call to
#' [`list_asset_revisions`][datazone_list_asset_revisions]. When the number
#' of revisions to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`list_asset_revisions`][datazone_list_asset_revisions] to list
#' the next set of revisions.
#' @param nextToken When the number of revisions is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of revisions, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_asset_revisions`][datazone_list_asset_revisions] to list the next
#' set of revisions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_asset_revisions(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_asset_revisions
#'
#' @aliases datazone_list_asset_revisions
datazone_list_asset_revisions <- function(domainIdentifier, identifier, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAssetRevisions",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}/revisions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_asset_revisions_input(domainIdentifier = domainIdentifier, identifier = identifier, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_asset_revisions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_asset_revisions <- datazone_list_asset_revisions

#' Lists connections
#'
#' @description
#' Lists connections. In Amazon DataZone, a connection enables you to
#' connect your resources (domains, projects, and environments) to external
#' resources and services.
#'
#' @usage
#' datazone_list_connections(domainIdentifier, environmentIdentifier,
#'   maxResults, name, nextToken, projectIdentifier, scope, sortBy,
#'   sortOrder, type)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list connections.
#' @param environmentIdentifier The ID of the environment where you want to list connections.
#' @param maxResults The maximum number of connections to return in a single call to
#' ListConnections. When the number of connections to be listed is greater
#' than the value of MaxResults, the response contains a NextToken value
#' that you can use in a subsequent call to ListConnections to list the
#' next set of connections.
#' @param name The name of the connection.
#' @param nextToken When the number of connections is greater than the default value for the
#' MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of connections, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListConnections to list the next
#' set of connections.
#' @param projectIdentifier The ID of the project where you want to list connections.
#' @param scope The scope of the connection.
#' @param sortBy Specifies how you want to sort the listed connections.
#' @param sortOrder Specifies the sort order for the listed connections.
#' @param type The type of connection.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       connectionId = "string",
#'       domainId = "string",
#'       domainUnitId = "string",
#'       environmentId = "string",
#'       name = "string",
#'       physicalEndpoints = list(
#'         list(
#'           awsLocation = list(
#'             accessRole = "string",
#'             awsAccountId = "string",
#'             awsRegion = "string",
#'             iamConnectionId = "string"
#'           ),
#'           enableTrustedIdentityPropagation = TRUE|FALSE,
#'           glueConnection = list(
#'             athenaProperties = list(
#'               "string"
#'             ),
#'             authenticationConfiguration = list(
#'               authenticationType = "BASIC"|"OAUTH2"|"CUSTOM",
#'               oAuth2Properties = list(
#'                 authorizationCodeProperties = list(
#'                   authorizationCode = "string",
#'                   redirectUri = "string"
#'                 ),
#'                 oAuth2ClientApplication = list(
#'                   aWSManagedClientApplicationReference = "string",
#'                   userManagedClientApplicationClientId = "string"
#'                 ),
#'                 oAuth2Credentials = list(
#'                   accessToken = "string",
#'                   jwtToken = "string",
#'                   refreshToken = "string",
#'                   userManagedClientApplicationClientSecret = "string"
#'                 ),
#'                 oAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'                 tokenUrl = "string",
#'                 tokenUrlParametersMap = list(
#'                   "string"
#'                 )
#'               ),
#'               secretArn = "string"
#'             ),
#'             compatibleComputeEnvironments = list(
#'               "SPARK"|"ATHENA"|"PYTHON"
#'             ),
#'             connectionProperties = list(
#'               "string"
#'             ),
#'             connectionSchemaVersion = 123,
#'             connectionType = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW",
#'             creationTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             description = "string",
#'             lastConnectionValidationTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             lastUpdatedBy = "string",
#'             lastUpdatedTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             matchCriteria = list(
#'               "string"
#'             ),
#'             name = "string",
#'             physicalConnectionRequirements = list(
#'               availabilityZone = "string",
#'               securityGroupIdList = list(
#'                 "string"
#'               ),
#'               subnetId = "string",
#'               subnetIdList = list(
#'                 "string"
#'               )
#'             ),
#'             pythonProperties = list(
#'               "string"
#'             ),
#'             sparkProperties = list(
#'               "string"
#'             ),
#'             status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'             statusReason = "string"
#'           ),
#'           glueConnectionName = "string",
#'           host = "string",
#'           port = 123,
#'           protocol = "ATHENA"|"GLUE_INTERACTIVE_SESSION"|"HTTPS"|"JDBC"|"LIVY"|"ODBC"|"PRISM",
#'           stage = "string"
#'         )
#'       ),
#'       projectId = "string",
#'       props = list(
#'         amazonQProperties = list(
#'           authMode = "string",
#'           isEnabled = TRUE|FALSE,
#'           profileArn = "string"
#'         ),
#'         athenaProperties = list(
#'           workgroupName = "string"
#'         ),
#'         glueProperties = list(
#'           errorMessage = "string",
#'           status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'         ),
#'         hyperPodProperties = list(
#'           clusterArn = "string",
#'           clusterName = "string",
#'           orchestrator = "EKS"|"SLURM"
#'         ),
#'         iamProperties = list(
#'           environmentId = "string",
#'           glueLineageSyncEnabled = TRUE|FALSE
#'         ),
#'         mlflowProperties = list(
#'           trackingServerArn = "string"
#'         ),
#'         redshiftProperties = list(
#'           credentials = list(
#'             secretArn = "string",
#'             usernamePassword = list(
#'               password = "string",
#'               username = "string"
#'             )
#'           ),
#'           databaseName = "string",
#'           isProvisionedSecret = TRUE|FALSE,
#'           jdbcIamUrl = "string",
#'           jdbcUrl = "string",
#'           lineageSync = list(
#'             enabled = TRUE|FALSE,
#'             lineageJobId = "string",
#'             schedule = list(
#'               schedule = "string"
#'             )
#'           ),
#'           redshiftTempDir = "string",
#'           status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'           storage = list(
#'             clusterName = "string",
#'             workgroupName = "string"
#'           )
#'         ),
#'         s3Properties = list(
#'           errorMessage = "string",
#'           s3AccessGrantLocationId = "string",
#'           s3Uri = "string",
#'           status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'         ),
#'         sparkEmrProperties = list(
#'           certificateData = "string",
#'           computeArn = "string",
#'           credentials = list(
#'             password = "string",
#'             username = "string"
#'           ),
#'           credentialsExpiration = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           governanceType = "AWS_MANAGED"|"USER_MANAGED",
#'           instanceProfileArn = "string",
#'           javaVirtualEnv = "string",
#'           livyEndpoint = "string",
#'           logUri = "string",
#'           managedEndpointArn = "string",
#'           managedEndpointCredentials = list(
#'             id = "string",
#'             token = "string"
#'           ),
#'           pythonVirtualEnv = "string",
#'           runtimeRole = "string",
#'           trustedCertificatesS3Uri = "string"
#'         ),
#'         sparkGlueProperties = list(
#'           additionalArgs = list(
#'             connection = "string"
#'           ),
#'           glueConnectionName = "string",
#'           glueVersion = "string",
#'           idleTimeout = 123,
#'           javaVirtualEnv = "string",
#'           numberOfWorkers = 123,
#'           pythonVirtualEnv = "string",
#'           workerType = "string"
#'         )
#'       ),
#'       scope = "DOMAIN"|"PROJECT",
#'       type = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_connections(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   projectIdentifier = "string",
#'   scope = "DOMAIN"|"PROJECT",
#'   sortBy = "NAME",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   type = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_connections
#'
#' @aliases datazone_list_connections
datazone_list_connections <- function(domainIdentifier, environmentIdentifier = NULL, maxResults = NULL, name = NULL, nextToken = NULL, projectIdentifier = NULL, scope = NULL, sortBy = NULL, sortOrder = NULL, type = NULL) {
  op <- new_operation(
    name = "ListConnections",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/connections",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_connections_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, projectIdentifier = projectIdentifier, scope = scope, sortBy = sortBy, sortOrder = sortOrder, type = type)
  output <- .datazone$list_connections_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_connections <- datazone_list_connections

#' Lists data product revisions
#'
#' @description
#' Lists data product revisions.
#' 
#' Prerequisites:
#' 
#' -   The data product ID must exist within the domain.
#' 
#' -   User must have view permissions on the data product.
#' 
#' -   The domain must be in a valid and accessible state.
#'
#' @usage
#' datazone_list_data_product_revisions(domainIdentifier, identifier,
#'   maxResults, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain of the data product revisions that you want to
#' list.
#' @param identifier &#91;required&#93; The ID of the data product revision.
#' @param maxResults The maximum number of asset filters to return in a single call to
#' [`list_data_product_revisions`][datazone_list_data_product_revisions].
#' When the number of data product revisions to be listed is greater than
#' the value of `MaxResults`, the response contains a `NextToken` value
#' that you can use in a subsequent call to
#' [`list_data_product_revisions`][datazone_list_data_product_revisions] to
#' list the next set of data product revisions.
#' @param nextToken When the number of data product revisions is greater than the default
#' value for the `MaxResults` parameter, or if you explicitly specify a
#' value for `MaxResults` that is less than the number of data product
#' revisions, the response includes a pagination token named `NextToken`.
#' You can specify this `NextToken` value in a subsequent call to
#' [`list_data_product_revisions`][datazone_list_data_product_revisions] to
#' list the next set of data product revisions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_product_revisions(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_data_product_revisions
#'
#' @aliases datazone_list_data_product_revisions
datazone_list_data_product_revisions <- function(domainIdentifier, identifier, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListDataProductRevisions",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-products/{identifier}/revisions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_data_product_revisions_input(domainIdentifier = domainIdentifier, identifier = identifier, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_data_product_revisions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_data_product_revisions <- datazone_list_data_product_revisions

#' Lists data source run activities
#'
#' @description
#' Lists data source run activities.
#'
#' @usage
#' datazone_list_data_source_run_activities(domainIdentifier, identifier,
#'   maxResults, nextToken, status)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to list data
#' source run activities.
#' @param identifier &#91;required&#93; The identifier of the data source run.
#' @param maxResults The maximum number of activities to return in a single call to
#' [`list_data_source_run_activities`][datazone_list_data_source_run_activities].
#' When the number of activities to be listed is greater than the value of
#' `MaxResults`, the response contains a `NextToken` value that you can use
#' in a subsequent call to
#' [`list_data_source_run_activities`][datazone_list_data_source_run_activities]
#' to list the next set of activities.
#' @param nextToken When the number of activities is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of activities, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_data_source_run_activities`][datazone_list_data_source_run_activities]
#' to list the next set of activities.
#' @param status The status of the data source run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       dataAssetId = "string",
#'       dataAssetStatus = "FAILED"|"PUBLISHING_FAILED"|"SUCCEEDED_CREATED"|"SUCCEEDED_UPDATED"|"SKIPPED_ALREADY_IMPORTED"|"SKIPPED_ARCHIVED"|"SKIPPED_NO_ACCESS"|"UNCHANGED",
#'       dataSourceRunId = "string",
#'       database = "string",
#'       errorMessage = list(
#'         errorDetail = "string",
#'         errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'       ),
#'       lineageSummary = list(
#'         errorMessage = "string",
#'         eventId = "string",
#'         eventStatus = "REQUESTED"|"PROCESSING"|"SUCCESS"|"FAILED"
#'       ),
#'       projectId = "string",
#'       technicalDescription = "string",
#'       technicalName = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_source_run_activities(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   status = "FAILED"|"PUBLISHING_FAILED"|"SUCCEEDED_CREATED"|"SUCCEEDED_UPDATED"|"SKIPPED_ALREADY_IMPORTED"|"SKIPPED_ARCHIVED"|"SKIPPED_NO_ACCESS"|"UNCHANGED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_data_source_run_activities
#'
#' @aliases datazone_list_data_source_run_activities
datazone_list_data_source_run_activities <- function(domainIdentifier, identifier, maxResults = NULL, nextToken = NULL, status = NULL) {
  op <- new_operation(
    name = "ListDataSourceRunActivities",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-source-runs/{identifier}/activities",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_data_source_run_activities_input(domainIdentifier = domainIdentifier, identifier = identifier, maxResults = maxResults, nextToken = nextToken, status = status)
  output <- .datazone$list_data_source_run_activities_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_data_source_run_activities <- datazone_list_data_source_run_activities

#' Lists data source runs in Amazon DataZone
#'
#' @description
#' Lists data source runs in Amazon DataZone.
#'
#' @usage
#' datazone_list_data_source_runs(dataSourceIdentifier, domainIdentifier,
#'   maxResults, nextToken, status)
#'
#' @param dataSourceIdentifier &#91;required&#93; The identifier of the data source.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to invoke the
#' [`list_data_source_runs`][datazone_list_data_source_runs] action.
#' @param maxResults The maximum number of runs to return in a single call to
#' [`list_data_source_runs`][datazone_list_data_source_runs]. When the
#' number of runs to be listed is greater than the value of `MaxResults`,
#' the response contains a `NextToken` value that you can use in a
#' subsequent call to
#' [`list_data_source_runs`][datazone_list_data_source_runs] to list the
#' next set of runs.
#' @param nextToken When the number of runs is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of runs, the response includes
#' a pagination token named `NextToken`. You can specify this `NextToken`
#' value in a subsequent call to
#' [`list_data_source_runs`][datazone_list_data_source_runs] to list the
#' next set of runs.
#' @param status The status of the data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       dataSourceId = "string",
#'       errorMessage = list(
#'         errorDetail = "string",
#'         errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'       ),
#'       id = "string",
#'       lineageSummary = list(
#'         importStatus = "IN_PROGRESS"|"SUCCESS"|"FAILED"|"PARTIALLY_SUCCEEDED"
#'       ),
#'       projectId = "string",
#'       runStatisticsForAssets = list(
#'         added = 123,
#'         failed = 123,
#'         skipped = 123,
#'         unchanged = 123,
#'         updated = 123
#'       ),
#'       startedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'       stoppedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       type = "PRIORITIZED"|"SCHEDULED",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_source_runs(
#'   dataSourceIdentifier = "string",
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   status = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_data_source_runs
#'
#' @aliases datazone_list_data_source_runs
datazone_list_data_source_runs <- function(dataSourceIdentifier, domainIdentifier, maxResults = NULL, nextToken = NULL, status = NULL) {
  op <- new_operation(
    name = "ListDataSourceRuns",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-sources/{dataSourceIdentifier}/runs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_data_source_runs_input(dataSourceIdentifier = dataSourceIdentifier, domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, status = status)
  output <- .datazone$list_data_source_runs_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_data_source_runs <- datazone_list_data_source_runs

#' Lists data sources in Amazon DataZone
#'
#' @description
#' Lists data sources in Amazon DataZone.
#'
#' @usage
#' datazone_list_data_sources(connectionIdentifier, domainIdentifier,
#'   environmentIdentifier, maxResults, name, nextToken, projectIdentifier,
#'   status, type)
#'
#' @param connectionIdentifier The ID of the connection.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to list the data
#' sources.
#' @param environmentIdentifier The identifier of the environment in which to list the data sources.
#' @param maxResults The maximum number of data sources to return in a single call to
#' [`list_data_sources`][datazone_list_data_sources]. When the number of
#' data sources to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`list_data_sources`][datazone_list_data_sources] to list the
#' next set of data sources.
#' @param name The name of the data source.
#' @param nextToken When the number of data sources is greater than the default value for
#' the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of data sources, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_data_sources`][datazone_list_data_sources] to list the next set
#' of data sources.
#' @param projectIdentifier &#91;required&#93; The identifier of the project in which to list data sources.
#' @param status The status of the data source.
#' @param type The type of the data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       connectionId = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       dataSourceId = "string",
#'       description = "string",
#'       domainId = "string",
#'       enableSetting = "ENABLED"|"DISABLED",
#'       environmentId = "string",
#'       lastRunAssetCount = 123,
#'       lastRunAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastRunErrorMessage = list(
#'         errorDetail = "string",
#'         errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'       ),
#'       lastRunStatus = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'       name = "string",
#'       schedule = list(
#'         schedule = "string",
#'         timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'       ),
#'       status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'       type = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_data_sources(
#'   connectionIdentifier = "string",
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   projectIdentifier = "string",
#'   status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'   type = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_data_sources
#'
#' @aliases datazone_list_data_sources
datazone_list_data_sources <- function(connectionIdentifier = NULL, domainIdentifier, environmentIdentifier = NULL, maxResults = NULL, name = NULL, nextToken = NULL, projectIdentifier, status = NULL, type = NULL) {
  op <- new_operation(
    name = "ListDataSources",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/data-sources",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_data_sources_input(connectionIdentifier = connectionIdentifier, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, projectIdentifier = projectIdentifier, status = status, type = type)
  output <- .datazone$list_data_sources_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_data_sources <- datazone_list_data_sources

#' Lists child domain units for the specified parent domain unit
#'
#' @description
#' Lists child domain units for the specified parent domain unit.
#'
#' @usage
#' datazone_list_domain_units_for_parent(domainIdentifier, maxResults,
#'   nextToken, parentDomainUnitIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which you want to list domain units for a parent
#' domain unit.
#' @param maxResults The maximum number of domain units to return in a single call to
#' ListDomainUnitsForParent. When the number of domain units to be listed
#' is greater than the value of MaxResults, the response contains a
#' NextToken value that you can use in a subsequent call to
#' ListDomainUnitsForParent to list the next set of domain units.
#' @param nextToken When the number of domain units is greater than the default value for
#' the MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of domain units, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListDomainUnitsForParent to list
#' the next set of domain units.
#' @param parentDomainUnitIdentifier &#91;required&#93; The ID of the parent domain unit.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_domain_units_for_parent(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   parentDomainUnitIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_domain_units_for_parent
#'
#' @aliases datazone_list_domain_units_for_parent
datazone_list_domain_units_for_parent <- function(domainIdentifier, maxResults = NULL, nextToken = NULL, parentDomainUnitIdentifier) {
  op <- new_operation(
    name = "ListDomainUnitsForParent",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/domain-units",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_domain_units_for_parent_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, parentDomainUnitIdentifier = parentDomainUnitIdentifier)
  output <- .datazone$list_domain_units_for_parent_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_domain_units_for_parent <- datazone_list_domain_units_for_parent

#' Lists Amazon DataZone domains
#'
#' @description
#' Lists Amazon DataZone domains.
#'
#' @usage
#' datazone_list_domains(maxResults, nextToken, status)
#'
#' @param maxResults The maximum number of domains to return in a single call to
#' [`list_domains`][datazone_list_domains]. When the number of domains to
#' be listed is greater than the value of `MaxResults`, the response
#' contains a `NextToken` value that you can use in a subsequent call to
#' [`list_domains`][datazone_list_domains] to list the next set of domains.
#' @param nextToken When the number of domains is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of domains, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_domains`][datazone_list_domains] to list the next set of domains.
#' @param status The status of the data source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       description = "string",
#'       domainVersion = "V1"|"V2",
#'       id = "string",
#'       lastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       managedAccountId = "string",
#'       name = "string",
#'       portalUrl = "string",
#'       status = "CREATING"|"AVAILABLE"|"CREATION_FAILED"|"DELETING"|"DELETED"|"DELETION_FAILED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_domains(
#'   maxResults = 123,
#'   nextToken = "string",
#'   status = "CREATING"|"AVAILABLE"|"CREATION_FAILED"|"DELETING"|"DELETED"|"DELETION_FAILED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_domains
#'
#' @aliases datazone_list_domains
datazone_list_domains <- function(maxResults = NULL, nextToken = NULL, status = NULL) {
  op <- new_operation(
    name = "ListDomains",
    http_method = "GET",
    http_path = "/v2/domains",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_domains_input(maxResults = maxResults, nextToken = nextToken, status = status)
  output <- .datazone$list_domains_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_domains <- datazone_list_domains

#' Lists the entity (domain units) owners
#'
#' @description
#' Lists the entity (domain units) owners.
#'
#' @usage
#' datazone_list_entity_owners(domainIdentifier, entityIdentifier,
#'   entityType, maxResults, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list entity owners.
#' @param entityIdentifier &#91;required&#93; The ID of the entity that you want to list.
#' @param entityType &#91;required&#93; The type of the entity that you want to list.
#' @param maxResults The maximum number of entities to return in a single call to
#' [`list_entity_owners`][datazone_list_entity_owners]. When the number of
#' entities to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`list_entity_owners`][datazone_list_entity_owners] to list the
#' next set of entities.
#' @param nextToken When the number of entities is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of entities, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_entity_owners`][datazone_list_entity_owners] to list the next set
#' of entities.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   owners = list(
#'     list(
#'       group = list(
#'         groupId = "string"
#'       ),
#'       user = list(
#'         userId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_entity_owners(
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_entity_owners
#'
#' @aliases datazone_list_entity_owners
datazone_list_entity_owners <- function(domainIdentifier, entityIdentifier, entityType, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListEntityOwners",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/owners",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "owners"),
    stream_api = FALSE
  )
  input <- .datazone$list_entity_owners_input(domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_entity_owners_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_entity_owners <- datazone_list_entity_owners

#' Lists existing environment actions
#'
#' @description
#' Lists existing environment actions.
#'
#' @usage
#' datazone_list_environment_actions(domainIdentifier,
#'   environmentIdentifier, maxResults, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which the environment actions
#' are listed.
#' @param environmentIdentifier &#91;required&#93; The ID of the envrironment whose environment actions are listed.
#' @param maxResults The maximum number of environment actions to return in a single call to
#' [`list_environment_actions`][datazone_list_environment_actions]. When
#' the number of environment actions to be listed is greater than the value
#' of `MaxResults`, the response contains a `NextToken` value that you can
#' use in a subsequent call to
#' [`list_environment_actions`][datazone_list_environment_actions] to list
#' the next set of environment actions.
#' @param nextToken When the number of environment actions is greater than the default value
#' for the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of environment actions, the
#' response includes a pagination token named `NextToken`. You can specify
#' this `NextToken` value in a subsequent call to
#' [`list_environment_actions`][datazone_list_environment_actions] to list
#' the next set of environment actions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       description = "string",
#'       domainId = "string",
#'       environmentId = "string",
#'       id = "string",
#'       name = "string",
#'       parameters = list(
#'         awsConsoleLink = list(
#'           uri = "string"
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_environment_actions(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_environment_actions
#'
#' @aliases datazone_list_environment_actions
datazone_list_environment_actions <- function(domainIdentifier, environmentIdentifier, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListEnvironmentActions",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_environment_actions_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_environment_actions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_environment_actions <- datazone_list_environment_actions

#' Lists blueprint configurations for a Amazon DataZone environment
#'
#' @description
#' Lists blueprint configurations for a Amazon DataZone environment.
#'
#' @usage
#' datazone_list_environment_blueprint_configurations(domainIdentifier,
#'   maxResults, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param maxResults The maximum number of blueprint configurations to return in a single
#' call to
#' [`list_environment_blueprint_configurations`][datazone_list_environment_blueprint_configurations].
#' When the number of configurations to be listed is greater than the value
#' of `MaxResults`, the response contains a `NextToken` value that you can
#' use in a subsequent call to
#' [`list_environment_blueprint_configurations`][datazone_list_environment_blueprint_configurations]
#' to list the next set of configurations.
#' @param nextToken When the number of blueprint configurations is greater than the default
#' value for the `MaxResults` parameter, or if you explicitly specify a
#' value for `MaxResults` that is less than the number of configurations,
#' the response includes a pagination token named `NextToken`. You can
#' specify this `NextToken` value in a subsequent call to
#' [`list_environment_blueprint_configurations`][datazone_list_environment_blueprint_configurations]
#' to list the next set of configurations.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       domainId = "string",
#'       enabledRegions = list(
#'         "string"
#'       ),
#'       environmentBlueprintId = "string",
#'       environmentRolePermissionBoundary = "string",
#'       manageAccessRoleArn = "string",
#'       provisioningConfigurations = list(
#'         list(
#'           lakeFormationConfiguration = list(
#'             locationRegistrationExcludeS3Locations = list(
#'               "string"
#'             ),
#'             locationRegistrationRole = "string"
#'           )
#'         )
#'       ),
#'       provisioningRoleArn = "string",
#'       regionalParameters = list(
#'         list(
#'           "string"
#'         )
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_environment_blueprint_configurations(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_environment_blueprint_configurations
#'
#' @aliases datazone_list_environment_blueprint_configurations
datazone_list_environment_blueprint_configurations <- function(domainIdentifier, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListEnvironmentBlueprintConfigurations",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprint-configurations",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_environment_blueprint_configurations_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken)
  output <- .datazone$list_environment_blueprint_configurations_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_environment_blueprint_configurations <- datazone_list_environment_blueprint_configurations

#' Lists blueprints in an Amazon DataZone environment
#'
#' @description
#' Lists blueprints in an Amazon DataZone environment.
#'
#' @usage
#' datazone_list_environment_blueprints(domainIdentifier, managed,
#'   maxResults, name, nextToken)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param managed Specifies whether the environment blueprint is managed by Amazon
#' DataZone.
#' @param maxResults The maximum number of blueprints to return in a single call to
#' [`list_environment_blueprints`][datazone_list_environment_blueprints].
#' When the number of blueprints to be listed is greater than the value of
#' `MaxResults`, the response contains a `NextToken` value that you can use
#' in a subsequent call to
#' [`list_environment_blueprints`][datazone_list_environment_blueprints] to
#' list the next set of blueprints.
#' @param name The name of the Amazon DataZone environment.
#' @param nextToken When the number of blueprints in the environment is greater than the
#' default value for the `MaxResults` parameter, or if you explicitly
#' specify a value for `MaxResults` that is less than the number of
#' blueprints in the environment, the response includes a pagination token
#' named `NextToken`. You can specify this `NextToken` value in a
#' subsequent call to
#' [`list_environment_blueprints`][datazone_list_environment_blueprints]to
#' list the next set of blueprints.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       description = "string",
#'       id = "string",
#'       name = "string",
#'       provider = "string",
#'       provisioningProperties = list(
#'         cloudFormation = list(
#'           templateUrl = "string"
#'         )
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_environment_blueprints(
#'   domainIdentifier = "string",
#'   managed = TRUE|FALSE,
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_environment_blueprints
#'
#' @aliases datazone_list_environment_blueprints
datazone_list_environment_blueprints <- function(domainIdentifier, managed = NULL, maxResults = NULL, name = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListEnvironmentBlueprints",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprints",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_environment_blueprints_input(domainIdentifier = domainIdentifier, managed = managed, maxResults = maxResults, name = name, nextToken = nextToken)
  output <- .datazone$list_environment_blueprints_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_environment_blueprints <- datazone_list_environment_blueprints

#' Lists Amazon DataZone environment profiles
#'
#' @description
#' Lists Amazon DataZone environment profiles.
#'
#' @usage
#' datazone_list_environment_profiles(awsAccountId, awsAccountRegion,
#'   domainIdentifier, environmentBlueprintIdentifier, maxResults, name,
#'   nextToken, projectIdentifier)
#'
#' @param awsAccountId The identifier of the Amazon Web Services account where you want to list
#' environment profiles.
#' @param awsAccountRegion The Amazon Web Services region where you want to list environment
#' profiles.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param environmentBlueprintIdentifier The identifier of the blueprint that was used to create the environment
#' profiles that you want to list.
#' @param maxResults The maximum number of environment profiles to return in a single call to
#' [`list_environment_profiles`][datazone_list_environment_profiles]. When
#' the number of environment profiles to be listed is greater than the
#' value of `MaxResults`, the response contains a `NextToken` value that
#' you can use in a subsequent call to
#' [`list_environment_profiles`][datazone_list_environment_profiles] to
#' list the next set of environment profiles.
#' @param name 
#' @param nextToken When the number of environment profiles is greater than the default
#' value for the `MaxResults` parameter, or if you explicitly specify a
#' value for `MaxResults` that is less than the number of environment
#' profiles, the response includes a pagination token named `NextToken`.
#' You can specify this `NextToken` value in a subsequent call to
#' [`list_environment_profiles`][datazone_list_environment_profiles] to
#' list the next set of environment profiles.
#' @param projectIdentifier The identifier of the Amazon DataZone project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       awsAccountId = "string",
#'       awsAccountRegion = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       description = "string",
#'       domainId = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string",
#'       projectId = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_environment_profiles(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   domainIdentifier = "string",
#'   environmentBlueprintIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   projectIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_environment_profiles
#'
#' @aliases datazone_list_environment_profiles
datazone_list_environment_profiles <- function(awsAccountId = NULL, awsAccountRegion = NULL, domainIdentifier, environmentBlueprintIdentifier = NULL, maxResults = NULL, name = NULL, nextToken = NULL, projectIdentifier = NULL) {
  op <- new_operation(
    name = "ListEnvironmentProfiles",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environment-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_environment_profiles_input(awsAccountId = awsAccountId, awsAccountRegion = awsAccountRegion, domainIdentifier = domainIdentifier, environmentBlueprintIdentifier = environmentBlueprintIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, projectIdentifier = projectIdentifier)
  output <- .datazone$list_environment_profiles_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_environment_profiles <- datazone_list_environment_profiles

#' Lists Amazon DataZone environments
#'
#' @description
#' Lists Amazon DataZone environments.
#'
#' @usage
#' datazone_list_environments(awsAccountId, awsAccountRegion,
#'   domainIdentifier, environmentBlueprintIdentifier,
#'   environmentProfileIdentifier, maxResults, name, nextToken,
#'   projectIdentifier, provider, status)
#'
#' @param awsAccountId The identifier of the Amazon Web Services account where you want to list
#' environments.
#' @param awsAccountRegion The Amazon Web Services region where you want to list environments.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param environmentBlueprintIdentifier The identifier of the Amazon DataZone blueprint.
#' @param environmentProfileIdentifier The identifier of the environment profile.
#' @param maxResults The maximum number of environments to return in a single call to
#' [`list_environments`][datazone_list_environments]. When the number of
#' environments to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`list_environments`][datazone_list_environments] to list the
#' next set of environments.
#' @param name The name of the environment.
#' @param nextToken When the number of environments is greater than the default value for
#' the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of environments, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_environments`][datazone_list_environments] to list the next set
#' of environments.
#' @param projectIdentifier &#91;required&#93; The identifier of the Amazon DataZone project.
#' @param provider The provider of the environment.
#' @param status The status of the environments that you want to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       awsAccountId = "string",
#'       awsAccountRegion = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       description = "string",
#'       domainId = "string",
#'       environmentConfigurationId = "string",
#'       environmentProfileId = "string",
#'       id = "string",
#'       name = "string",
#'       projectId = "string",
#'       provider = "string",
#'       status = "ACTIVE"|"CREATING"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|"VALIDATION_FAILED"|"SUSPENDED"|"DISABLED"|"EXPIRED"|"DELETED"|"INACCESSIBLE",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_environments(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   domainIdentifier = "string",
#'   environmentBlueprintIdentifier = "string",
#'   environmentProfileIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   projectIdentifier = "string",
#'   provider = "string",
#'   status = "ACTIVE"|"CREATING"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|"VALIDATION_FAILED"|"SUSPENDED"|"DISABLED"|"EXPIRED"|"DELETED"|"INACCESSIBLE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_environments
#'
#' @aliases datazone_list_environments
datazone_list_environments <- function(awsAccountId = NULL, awsAccountRegion = NULL, domainIdentifier, environmentBlueprintIdentifier = NULL, environmentProfileIdentifier = NULL, maxResults = NULL, name = NULL, nextToken = NULL, projectIdentifier, provider = NULL, status = NULL) {
  op <- new_operation(
    name = "ListEnvironments",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_environments_input(awsAccountId = awsAccountId, awsAccountRegion = awsAccountRegion, domainIdentifier = domainIdentifier, environmentBlueprintIdentifier = environmentBlueprintIdentifier, environmentProfileIdentifier = environmentProfileIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, projectIdentifier = projectIdentifier, provider = provider, status = status)
  output <- .datazone$list_environments_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_environments <- datazone_list_environments

#' Lists job runs
#'
#' @description
#' Lists job runs.
#'
#' @usage
#' datazone_list_job_runs(domainIdentifier, jobIdentifier, maxResults,
#'   nextToken, sortOrder, status)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list job runs.
#' @param jobIdentifier &#91;required&#93; The ID of the job run.
#' @param maxResults The maximum number of job runs to return in a single call to
#' ListJobRuns. When the number of job runs to be listed is greater than
#' the value of MaxResults, the response contains a NextToken value that
#' you can use in a subsequent call to ListJobRuns to list the next set of
#' job runs.
#' @param nextToken When the number of job runs is greater than the default value for the
#' MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of job runs, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListJobRuns to list the next set
#' of job runs.
#' @param sortOrder Specifies the order in which job runs are to be sorted.
#' @param status The status of a job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       endTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       error = list(
#'         message = "string"
#'       ),
#'       jobId = "string",
#'       jobType = "LINEAGE",
#'       runId = "string",
#'       runMode = "SCHEDULED"|"ON_DEMAND",
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "SCHEDULED"|"IN_PROGRESS"|"SUCCESS"|"PARTIALLY_SUCCEEDED"|"FAILED"|"ABORTED"|"TIMED_OUT"|"CANCELED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   domainIdentifier = "string",
#'   jobIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   status = "SCHEDULED"|"IN_PROGRESS"|"SUCCESS"|"PARTIALLY_SUCCEEDED"|"FAILED"|"ABORTED"|"TIMED_OUT"|"CANCELED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_job_runs
#'
#' @aliases datazone_list_job_runs
datazone_list_job_runs <- function(domainIdentifier, jobIdentifier, maxResults = NULL, nextToken = NULL, sortOrder = NULL, status = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/jobs/{jobIdentifier}/runs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_job_runs_input(domainIdentifier = domainIdentifier, jobIdentifier = jobIdentifier, maxResults = maxResults, nextToken = nextToken, sortOrder = sortOrder, status = status)
  output <- .datazone$list_job_runs_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_job_runs <- datazone_list_job_runs

#' Lists lineage events
#'
#' @description
#' Lists lineage events.
#'
#' @usage
#' datazone_list_lineage_events(domainIdentifier, maxResults, nextToken,
#'   processingStatus, sortOrder, timestampAfter, timestampBefore)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list lineage events.
#' @param maxResults The maximum number of lineage events to return in a single call to
#' ListLineageEvents. When the number of lineage events to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListLineageEvents to list
#' the next set of lineage events.
#' @param nextToken When the number of lineage events is greater than the default value for
#' the MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of lineage events, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListLineageEvents to list the
#' next set of lineage events.
#' @param processingStatus The processing status of a lineage event.
#' @param sortOrder The sort order of the lineage events.
#' @param timestampAfter The after timestamp of a lineage event.
#' @param timestampBefore The before timestamp of a lineage event.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       eventSummary = list(
#'         openLineageRunEventSummary = list(
#'           eventType = "START"|"RUNNING"|"COMPLETE"|"ABORT"|"FAIL"|"OTHER",
#'           inputs = list(
#'             list(
#'               name = "string",
#'               namespace = "string"
#'             )
#'           ),
#'           job = list(
#'             name = "string",
#'             namespace = "string"
#'           ),
#'           outputs = list(
#'             list(
#'               name = "string",
#'               namespace = "string"
#'             )
#'           ),
#'           runId = "string"
#'         )
#'       ),
#'       eventTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       id = "string",
#'       processingStatus = "REQUESTED"|"PROCESSING"|"SUCCESS"|"FAILED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_lineage_events(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   processingStatus = "REQUESTED"|"PROCESSING"|"SUCCESS"|"FAILED",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   timestampAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   timestampBefore = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_lineage_events
#'
#' @aliases datazone_list_lineage_events
datazone_list_lineage_events <- function(domainIdentifier, maxResults = NULL, nextToken = NULL, processingStatus = NULL, sortOrder = NULL, timestampAfter = NULL, timestampBefore = NULL) {
  op <- new_operation(
    name = "ListLineageEvents",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/lineage/events",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_lineage_events_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, processingStatus = processingStatus, sortOrder = sortOrder, timestampAfter = timestampAfter, timestampBefore = timestampBefore)
  output <- .datazone$list_lineage_events_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_lineage_events <- datazone_list_lineage_events

#' Lists the history of the specified data lineage node
#'
#' @description
#' Lists the history of the specified data lineage node.
#'
#' @usage
#' datazone_list_lineage_node_history(direction, domainIdentifier,
#'   eventTimestampGTE, eventTimestampLTE, identifier, maxResults, nextToken,
#'   sortOrder)
#'
#' @param direction The direction of the data lineage node refers to the lineage node having
#' neighbors in that direction. For example, if direction is `UPSTREAM`,
#' the [`list_lineage_node_history`][datazone_list_lineage_node_history]
#' API responds with historical versions with upstream neighbors only.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list the history of the specified
#' data lineage node.
#' @param eventTimestampGTE Specifies whether the action is to return data lineage node history from
#' the time after the event timestamp.
#' @param eventTimestampLTE Specifies whether the action is to return data lineage node history from
#' the time prior of the event timestamp.
#' @param identifier &#91;required&#93; The ID of the data lineage node whose history you want to list.
#' @param maxResults The maximum number of history items to return in a single call to
#' ListLineageNodeHistory. When the number of memberships to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListLineageNodeHistory to
#' list the next set of items.
#' @param nextToken When the number of history items is greater than the default value for
#' the MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of items, the response includes
#' a pagination token named NextToken. You can specify this NextToken value
#' in a subsequent call to ListLineageNodeHistory to list the next set of
#' items.
#' @param sortOrder The order by which you want data lineage node history to be sorted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   nodes = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       description = "string",
#'       domainId = "string",
#'       eventTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       id = "string",
#'       name = "string",
#'       sourceIdentifier = "string",
#'       typeName = "string",
#'       typeRevision = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_lineage_node_history(
#'   direction = "UPSTREAM"|"DOWNSTREAM",
#'   domainIdentifier = "string",
#'   eventTimestampGTE = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   eventTimestampLTE = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   identifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortOrder = "ASCENDING"|"DESCENDING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_lineage_node_history
#'
#' @aliases datazone_list_lineage_node_history
datazone_list_lineage_node_history <- function(direction = NULL, domainIdentifier, eventTimestampGTE = NULL, eventTimestampLTE = NULL, identifier, maxResults = NULL, nextToken = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListLineageNodeHistory",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/lineage/nodes/{identifier}/history",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "nodes"),
    stream_api = FALSE
  )
  input <- .datazone$list_lineage_node_history_input(direction = direction, domainIdentifier = domainIdentifier, eventTimestampGTE = eventTimestampGTE, eventTimestampLTE = eventTimestampLTE, identifier = identifier, maxResults = maxResults, nextToken = nextToken, sortOrder = sortOrder)
  output <- .datazone$list_lineage_node_history_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_lineage_node_history <- datazone_list_lineage_node_history

#' Lists all metadata generation runs
#'
#' @description
#' Lists all metadata generation runs.
#' 
#' Metadata generation runs represent automated processes that leverage
#' AI/ML capabilities to create or enhance asset metadata at scale. This
#' feature helps organizations maintain comprehensive and consistent
#' metadata across large numbers of assets without manual intervention. It
#' can automatically generate business descriptions, tags, and other
#' metadata elements, significantly reducing the time and effort required
#' for metadata management while improving consistency and completeness.
#' 
#' Prerequisites:
#' 
#' -   Valid domain identifier.
#' 
#' -   User must have access to metadata generation runs in the domain.
#'
#' @usage
#' datazone_list_metadata_generation_runs(domainIdentifier, maxResults,
#'   nextToken, status, targetIdentifier, type)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where you want to list metadata
#' generation runs.
#' @param maxResults The maximum number of metadata generation runs to return in a single
#' call to ListMetadataGenerationRuns. When the number of metadata
#' generation runs to be listed is greater than the value of MaxResults,
#' the response contains a NextToken value that you can use in a subsequent
#' call to ListMetadataGenerationRuns to list the next set of revisions.
#' @param nextToken When the number of metadata generation runs is greater than the default
#' value for the MaxResults parameter, or if you explicitly specify a value
#' for MaxResults that is less than the number of metadata generation runs,
#' the response includes a pagination token named NextToken. You can
#' specify this NextToken value in a subsequent call to
#' ListMetadataGenerationRuns to list the next set of revisions.
#' @param status The status of the metadata generation runs.
#' @param targetIdentifier The target ID for which you want to list metadata generation runs.
#' @param type The type of the metadata generation runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       id = "string",
#'       owningProjectId = "string",
#'       status = "SUBMITTED"|"IN_PROGRESS"|"CANCELED"|"SUCCEEDED"|"FAILED"|"PARTIALLY_SUCCEEDED",
#'       target = list(
#'         identifier = "string",
#'         revision = "string",
#'         type = "ASSET"
#'       ),
#'       type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS",
#'       types = list(
#'         "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_metadata_generation_runs(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELED"|"SUCCEEDED"|"FAILED"|"PARTIALLY_SUCCEEDED",
#'   targetIdentifier = "string",
#'   type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_metadata_generation_runs
#'
#' @aliases datazone_list_metadata_generation_runs
datazone_list_metadata_generation_runs <- function(domainIdentifier, maxResults = NULL, nextToken = NULL, status = NULL, targetIdentifier = NULL, type = NULL) {
  op <- new_operation(
    name = "ListMetadataGenerationRuns",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/metadata-generation-runs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_metadata_generation_runs_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, status = status, targetIdentifier = targetIdentifier, type = type)
  output <- .datazone$list_metadata_generation_runs_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_metadata_generation_runs <- datazone_list_metadata_generation_runs

#' Lists all Amazon DataZone notifications
#'
#' @description
#' Lists all Amazon DataZone notifications.
#'
#' @usage
#' datazone_list_notifications(afterTimestamp, beforeTimestamp,
#'   domainIdentifier, maxResults, nextToken, subjects, taskStatus, type)
#'
#' @param afterTimestamp The time after which you want to list notifications.
#' @param beforeTimestamp The time before which you want to list notifications.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param maxResults The maximum number of notifications to return in a single call to
#' [`list_notifications`][datazone_list_notifications]. When the number of
#' notifications to be listed is greater than the value of `MaxResults`,
#' the response contains a `NextToken` value that you can use in a
#' subsequent call to [`list_notifications`][datazone_list_notifications]
#' to list the next set of notifications.
#' @param nextToken When the number of notifications is greater than the default value for
#' the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of notifications, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_notifications`][datazone_list_notifications] to list the next set
#' of notifications.
#' @param subjects The subjects of notifications.
#' @param taskStatus The task status of notifications.
#' @param type &#91;required&#93; The type of notifications.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   notifications = list(
#'     list(
#'       actionLink = "string",
#'       creationTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       domainIdentifier = "string",
#'       identifier = "string",
#'       lastUpdatedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       message = "string",
#'       metadata = list(
#'         "string"
#'       ),
#'       status = "ACTIVE"|"INACTIVE",
#'       title = "string",
#'       topic = list(
#'         resource = list(
#'           id = "string",
#'           name = "string",
#'           type = "PROJECT"
#'         ),
#'         role = "PROJECT_OWNER"|"PROJECT_CONTRIBUTOR"|"PROJECT_VIEWER"|"DOMAIN_OWNER"|"PROJECT_SUBSCRIBER",
#'         subject = "string"
#'       ),
#'       type = "TASK"|"EVENT"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_notifications(
#'   afterTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   beforeTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   subjects = list(
#'     "string"
#'   ),
#'   taskStatus = "ACTIVE"|"INACTIVE",
#'   type = "TASK"|"EVENT"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_notifications
#'
#' @aliases datazone_list_notifications
datazone_list_notifications <- function(afterTimestamp = NULL, beforeTimestamp = NULL, domainIdentifier, maxResults = NULL, nextToken = NULL, subjects = NULL, taskStatus = NULL, type) {
  op <- new_operation(
    name = "ListNotifications",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/notifications",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "notifications"),
    stream_api = FALSE
  )
  input <- .datazone$list_notifications_input(afterTimestamp = afterTimestamp, beforeTimestamp = beforeTimestamp, domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, subjects = subjects, taskStatus = taskStatus, type = type)
  output <- .datazone$list_notifications_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_notifications <- datazone_list_notifications

#' Lists policy grants
#'
#' @description
#' Lists policy grants.
#'
#' @usage
#' datazone_list_policy_grants(domainIdentifier, entityIdentifier,
#'   entityType, maxResults, nextToken, policyType)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list policy grants.
#' @param entityIdentifier &#91;required&#93; The ID of the entity for which you want to list policy grants.
#' @param entityType &#91;required&#93; The type of entity for which you want to list policy grants.
#' @param maxResults The maximum number of grants to return in a single call to
#' [`list_policy_grants`][datazone_list_policy_grants]. When the number of
#' grants to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`list_policy_grants`][datazone_list_policy_grants] to list the
#' next set of grants.
#' @param nextToken When the number of grants is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of grants, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_policy_grants`][datazone_list_policy_grants] to list the next set
#' of grants.
#' @param policyType &#91;required&#93; The type of policy that you want to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   grantList = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       detail = list(
#'         addToProjectMemberPool = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createAssetType = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createDomainUnit = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createEnvironment = list(),
#'         createEnvironmentFromBlueprint = list(),
#'         createEnvironmentProfile = list(
#'           domainUnitId = "string"
#'         ),
#'         createFormType = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createGlossary = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createProject = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         createProjectFromProjectProfile = list(
#'           includeChildDomainUnits = TRUE|FALSE,
#'           projectProfiles = list(
#'             "string"
#'           )
#'         ),
#'         delegateCreateEnvironmentProfile = list(),
#'         overrideDomainUnitOwners = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         overrideProjectOwners = list(
#'           includeChildDomainUnits = TRUE|FALSE
#'         ),
#'         useAssetType = list(
#'           domainUnitId = "string"
#'         )
#'       ),
#'       grantId = "string",
#'       principal = list(
#'         domainUnit = list(
#'           domainUnitDesignation = "OWNER",
#'           domainUnitGrantFilter = list(
#'             allDomainUnitsGrantFilter = list()
#'           ),
#'           domainUnitIdentifier = "string"
#'         ),
#'         group = list(
#'           groupIdentifier = "string"
#'         ),
#'         project = list(
#'           projectDesignation = "OWNER"|"CONTRIBUTOR"|"PROJECT_CATALOG_STEWARD",
#'           projectGrantFilter = list(
#'             domainUnitFilter = list(
#'               domainUnit = "string",
#'               includeChildDomainUnits = TRUE|FALSE
#'             )
#'           ),
#'           projectIdentifier = "string"
#'         ),
#'         user = list(
#'           allUsersGrantFilter = list(),
#'           userIdentifier = "string"
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_grants(
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT"|"ENVIRONMENT_BLUEPRINT_CONFIGURATION"|"ENVIRONMENT_PROFILE"|"ASSET_TYPE",
#'   maxResults = 123,
#'   nextToken = "string",
#'   policyType = "CREATE_DOMAIN_UNIT"|"OVERRIDE_DOMAIN_UNIT_OWNERS"|"ADD_TO_PROJECT_MEMBER_POOL"|"OVERRIDE_PROJECT_OWNERS"|"CREATE_GLOSSARY"|"CREATE_FORM_TYPE"|"CREATE_ASSET_TYPE"|"CREATE_PROJECT"|"CREATE_ENVIRONMENT_PROFILE"|"DELEGATE_CREATE_ENVIRONMENT_PROFILE"|"CREATE_ENVIRONMENT"|"CREATE_ENVIRONMENT_FROM_BLUEPRINT"|"CREATE_PROJECT_FROM_PROJECT_PROFILE"|"USE_ASSET_TYPE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_policy_grants
#'
#' @aliases datazone_list_policy_grants
datazone_list_policy_grants <- function(domainIdentifier, entityIdentifier, entityType, maxResults = NULL, nextToken = NULL, policyType) {
  op <- new_operation(
    name = "ListPolicyGrants",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/grants",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "grantList"),
    stream_api = FALSE
  )
  input <- .datazone$list_policy_grants_input(domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, maxResults = maxResults, nextToken = nextToken, policyType = policyType)
  output <- .datazone$list_policy_grants_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_policy_grants <- datazone_list_policy_grants

#' Lists all members of the specified project
#'
#' @description
#' Lists all members of the specified project.
#'
#' @usage
#' datazone_list_project_memberships(domainIdentifier, maxResults,
#'   nextToken, projectIdentifier, sortBy, sortOrder)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which you want to list
#' project memberships.
#' @param maxResults The maximum number of memberships to return in a single call to
#' [`list_project_memberships`][datazone_list_project_memberships]. When
#' the number of memberships to be listed is greater than the value of
#' `MaxResults`, the response contains a `NextToken` value that you can use
#' in a subsequent call to
#' [`list_project_memberships`][datazone_list_project_memberships] to list
#' the next set of memberships.
#' @param nextToken When the number of memberships is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of memberships, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_project_memberships`][datazone_list_project_memberships] to list
#' the next set of memberships.
#' @param projectIdentifier &#91;required&#93; The identifier of the project whose memberships you want to list.
#' @param sortBy The method by which you want to sort the project memberships.
#' @param sortOrder The sort order of the project memberships.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   members = list(
#'     list(
#'       designation = "PROJECT_OWNER"|"PROJECT_CONTRIBUTOR"|"PROJECT_CATALOG_VIEWER"|"PROJECT_CATALOG_CONSUMER"|"PROJECT_CATALOG_STEWARD",
#'       memberDetails = list(
#'         group = list(
#'           groupId = "string"
#'         ),
#'         user = list(
#'           userId = "string"
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_project_memberships(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   projectIdentifier = "string",
#'   sortBy = "NAME",
#'   sortOrder = "ASCENDING"|"DESCENDING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_project_memberships
#'
#' @aliases datazone_list_project_memberships
datazone_list_project_memberships <- function(domainIdentifier, maxResults = NULL, nextToken = NULL, projectIdentifier, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListProjectMemberships",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/projects/{projectIdentifier}/memberships",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "members"),
    stream_api = FALSE
  )
  input <- .datazone$list_project_memberships_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, projectIdentifier = projectIdentifier, sortBy = sortBy, sortOrder = sortOrder)
  output <- .datazone$list_project_memberships_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_project_memberships <- datazone_list_project_memberships

#' Lists project profiles
#'
#' @description
#' Lists project profiles.
#'
#' @usage
#' datazone_list_project_profiles(domainIdentifier, maxResults, name,
#'   nextToken, sortBy, sortOrder)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to list project profiles.
#' @param maxResults The maximum number of project profiles to return in a single call to
#' ListProjectProfiles. When the number of project profiles to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListProjectProfiles to
#' list the next set of project profiles.
#' @param name The name of a project profile.
#' @param nextToken When the number of project profiles is greater than the default value
#' for the MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of project profiles, the
#' response includes a pagination token named NextToken. You can specify
#' this NextToken value in a subsequent call to ListProjectProfiles to list
#' the next set of project profiles.
#' @param sortBy Specifies by what to sort project profiles.
#' @param sortOrder Specifies the sort order of the project profiles.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       description = "string",
#'       domainId = "string",
#'       domainUnitId = "string",
#'       id = "string",
#'       lastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       name = "string",
#'       status = "ENABLED"|"DISABLED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_project_profiles(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   sortBy = "NAME",
#'   sortOrder = "ASCENDING"|"DESCENDING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_project_profiles
#'
#' @aliases datazone_list_project_profiles
datazone_list_project_profiles <- function(domainIdentifier, maxResults = NULL, name = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListProjectProfiles",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/project-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_project_profiles_input(domainIdentifier = domainIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .datazone$list_project_profiles_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_project_profiles <- datazone_list_project_profiles

#' Lists Amazon DataZone projects
#'
#' @description
#' Lists Amazon DataZone projects.
#'
#' @usage
#' datazone_list_projects(domainIdentifier, groupIdentifier, maxResults,
#'   name, nextToken, userIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param groupIdentifier The identifier of a group.
#' @param maxResults The maximum number of projects to return in a single call to
#' [`list_projects`][datazone_list_projects]. When the number of projects
#' to be listed is greater than the value of `MaxResults`, the response
#' contains a `NextToken` value that you can use in a subsequent call to
#' [`list_projects`][datazone_list_projects] to list the next set of
#' projects.
#' @param name The name of the project.
#' @param nextToken When the number of projects is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of projects, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_projects`][datazone_list_projects] to list the next set of
#' projects.
#' @param userIdentifier The identifier of the Amazon DataZone user.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       description = "string",
#'       domainId = "string",
#'       domainUnitId = "string",
#'       failureReasons = list(
#'         list(
#'           code = "string",
#'           message = "string"
#'         )
#'       ),
#'       id = "string",
#'       name = "string",
#'       projectStatus = "ACTIVE"|"DELETING"|"DELETE_FAILED"|"UPDATING"|"UPDATE_FAILED"|"MOVING",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_projects(
#'   domainIdentifier = "string",
#'   groupIdentifier = "string",
#'   maxResults = 123,
#'   name = "string",
#'   nextToken = "string",
#'   userIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_projects
#'
#' @aliases datazone_list_projects
datazone_list_projects <- function(domainIdentifier, groupIdentifier = NULL, maxResults = NULL, name = NULL, nextToken = NULL, userIdentifier = NULL) {
  op <- new_operation(
    name = "ListProjects",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/projects",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_projects_input(domainIdentifier = domainIdentifier, groupIdentifier = groupIdentifier, maxResults = maxResults, name = name, nextToken = nextToken, userIdentifier = userIdentifier)
  output <- .datazone$list_projects_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_projects <- datazone_list_projects

#' Lists existing rules
#'
#' @description
#' Lists existing rules. In Amazon DataZone, a rule is a formal agreement
#' that enforces specific requirements across user workflows (e.g.,
#' publishing assets to the catalog, requesting subscriptions, creating
#' projects) within the Amazon DataZone data portal. These rules help
#' maintain consistency, ensure compliance, and uphold governance standards
#' in data management processes. For instance, a metadata enforcement rule
#' can specify the required information for creating a subscription request
#' or publishing a data asset to the catalog, ensuring alignment with
#' organizational standards.
#'
#' @usage
#' datazone_list_rules(action, assetTypes, dataProduct, domainIdentifier,
#'   includeCascaded, maxResults, nextToken, projectIds, ruleType,
#'   targetIdentifier, targetType)
#'
#' @param action The action of the rule.
#' @param assetTypes The asset types of the rule.
#' @param dataProduct The data product of the rule.
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which the rules are to be listed.
#' @param includeCascaded Specifies whether to include cascading rules in the results.
#' @param maxResults The maximum number of rules to return in a single call to
#' [`list_rules`][datazone_list_rules]. When the number of rules to be
#' listed is greater than the value of `MaxResults`, the response contains
#' a `NextToken` value that you can use in a subsequent call to
#' [`list_rules`][datazone_list_rules] to list the next set of rules.
#' @param nextToken When the number of rules is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of rules, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_rules`][datazone_list_rules] to list the next set of rules.
#' @param projectIds The IDs of projects in which rules are to be listed.
#' @param ruleType The type of the rule.
#' @param targetIdentifier &#91;required&#93; The target ID of the rule.
#' @param targetType &#91;required&#93; The target type of the rule.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'       identifier = "string",
#'       lastUpdatedBy = "string",
#'       name = "string",
#'       revision = "string",
#'       ruleType = "METADATA_FORM_ENFORCEMENT"|"GLOSSARY_TERM_ENFORCEMENT",
#'       scope = list(
#'         assetType = list(
#'           selectionMode = "ALL"|"SPECIFIC",
#'           specificAssetTypes = list(
#'             "string"
#'           )
#'         ),
#'         dataProduct = TRUE|FALSE,
#'         project = list(
#'           selectionMode = "ALL"|"SPECIFIC",
#'           specificProjects = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       target = list(
#'         domainUnitTarget = list(
#'           domainUnitId = "string",
#'           includeChildDomainUnits = TRUE|FALSE
#'         )
#'       ),
#'       targetType = "DOMAIN_UNIT",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_rules(
#'   action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'   assetTypes = list(
#'     "string"
#'   ),
#'   dataProduct = TRUE|FALSE,
#'   domainIdentifier = "string",
#'   includeCascaded = TRUE|FALSE,
#'   maxResults = 123,
#'   nextToken = "string",
#'   projectIds = list(
#'     "string"
#'   ),
#'   ruleType = "METADATA_FORM_ENFORCEMENT"|"GLOSSARY_TERM_ENFORCEMENT",
#'   targetIdentifier = "string",
#'   targetType = "DOMAIN_UNIT"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_rules
#'
#' @aliases datazone_list_rules
datazone_list_rules <- function(action = NULL, assetTypes = NULL, dataProduct = NULL, domainIdentifier, includeCascaded = NULL, maxResults = NULL, nextToken = NULL, projectIds = NULL, ruleType = NULL, targetIdentifier, targetType) {
  op <- new_operation(
    name = "ListRules",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/list-rules/{targetType}/{targetIdentifier}",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_rules_input(action = action, assetTypes = assetTypes, dataProduct = dataProduct, domainIdentifier = domainIdentifier, includeCascaded = includeCascaded, maxResults = maxResults, nextToken = nextToken, projectIds = projectIds, ruleType = ruleType, targetIdentifier = targetIdentifier, targetType = targetType)
  output <- .datazone$list_rules_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_rules <- datazone_list_rules

#' Lists subscription grants
#'
#' @description
#' Lists subscription grants.
#'
#' @usage
#' datazone_list_subscription_grants(domainIdentifier, environmentId,
#'   maxResults, nextToken, owningGroupId, owningProjectId, owningUserId,
#'   sortBy, sortOrder, subscribedListingId, subscriptionId,
#'   subscriptionTargetId)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param environmentId The identifier of the Amazon DataZone environment.
#' @param maxResults The maximum number of subscription grants to return in a single call to
#' [`list_subscription_grants`][datazone_list_subscription_grants]. When
#' the number of subscription grants to be listed is greater than the value
#' of `MaxResults`, the response contains a `NextToken` value that you can
#' use in a subsequent call to
#' [`list_subscription_grants`][datazone_list_subscription_grants] to list
#' the next set of subscription grants.
#' @param nextToken When the number of subscription grants is greater than the default value
#' for the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of subscription grants, the
#' response includes a pagination token named `NextToken`. You can specify
#' this `NextToken` value in a subsequent call to
#' [`list_subscription_grants`][datazone_list_subscription_grants] to list
#' the next set of subscription grants.
#' @param owningGroupId The ID of the owning group.
#' @param owningProjectId The ID of the owning project of the subscription grants.
#' @param owningUserId The ID of the owning user.
#' @param sortBy Specifies the way of sorting the results of this action.
#' @param sortOrder Specifies the sort order of this action.
#' @param subscribedListingId The identifier of the subscribed listing.
#' @param subscriptionId The identifier of the subscription.
#' @param subscriptionTargetId The identifier of the subscription target.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       assets = list(
#'         list(
#'           assetId = "string",
#'           assetRevision = "string",
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           failureCause = list(
#'             message = "string"
#'           ),
#'           failureTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           grantedTimestamp = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           ),
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'           targetName = "string"
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       environmentId = "string",
#'       grantedEntity = list(
#'         listing = list(
#'           id = "string",
#'           revision = "string"
#'         )
#'       ),
#'       id = "string",
#'       status = "PENDING"|"IN_PROGRESS"|"GRANT_FAILED"|"REVOKE_FAILED"|"GRANT_AND_REVOKE_FAILED"|"COMPLETED"|"INACCESSIBLE",
#'       subscriptionId = "string",
#'       subscriptionTargetId = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_subscription_grants(
#'   domainIdentifier = "string",
#'   environmentId = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   owningGroupId = "string",
#'   owningProjectId = "string",
#'   owningUserId = "string",
#'   sortBy = "CREATED_AT"|"UPDATED_AT",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   subscribedListingId = "string",
#'   subscriptionId = "string",
#'   subscriptionTargetId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_subscription_grants
#'
#' @aliases datazone_list_subscription_grants
datazone_list_subscription_grants <- function(domainIdentifier, environmentId = NULL, maxResults = NULL, nextToken = NULL, owningGroupId = NULL, owningProjectId = NULL, owningUserId = NULL, sortBy = NULL, sortOrder = NULL, subscribedListingId = NULL, subscriptionId = NULL, subscriptionTargetId = NULL) {
  op <- new_operation(
    name = "ListSubscriptionGrants",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscription-grants",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_subscription_grants_input(domainIdentifier = domainIdentifier, environmentId = environmentId, maxResults = maxResults, nextToken = nextToken, owningGroupId = owningGroupId, owningProjectId = owningProjectId, owningUserId = owningUserId, sortBy = sortBy, sortOrder = sortOrder, subscribedListingId = subscribedListingId, subscriptionId = subscriptionId, subscriptionTargetId = subscriptionTargetId)
  output <- .datazone$list_subscription_grants_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_subscription_grants <- datazone_list_subscription_grants

#' Lists Amazon DataZone subscription requests
#'
#' @description
#' Lists Amazon DataZone subscription requests.
#'
#' @usage
#' datazone_list_subscription_requests(approverProjectId, domainIdentifier,
#'   maxResults, nextToken, owningGroupId, owningProjectId, owningUserId,
#'   sortBy, sortOrder, status, subscribedListingId)
#'
#' @param approverProjectId The identifier of the subscription request approver's project.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param maxResults The maximum number of subscription requests to return in a single call
#' to [`list_subscription_requests`][datazone_list_subscription_requests].
#' When the number of subscription requests to be listed is greater than
#' the value of `MaxResults`, the response contains a `NextToken` value
#' that you can use in a subsequent call to
#' [`list_subscription_requests`][datazone_list_subscription_requests] to
#' list the next set of subscription requests.
#' @param nextToken When the number of subscription requests is greater than the default
#' value for the `MaxResults` parameter, or if you explicitly specify a
#' value for `MaxResults` that is less than the number of subscription
#' requests, the response includes a pagination token named `NextToken`.
#' You can specify this `NextToken` value in a subsequent call to
#' [`list_subscription_requests`][datazone_list_subscription_requests] to
#' list the next set of subscription requests.
#' @param owningGroupId The ID of the owning group.
#' @param owningProjectId The identifier of the project for the subscription requests.
#' @param owningUserId The ID of the owning user.
#' @param sortBy Specifies the way to sort the results of this action.
#' @param sortOrder Specifies the sort order for the results of this action.
#' @param status Specifies the status of the subscription requests.
#' 
#' This is not a required parameter, but if not specified, by default,
#' Amazon DataZone returns only `PENDING` subscription requests.
#' @param subscribedListingId The identifier of the subscribed listing.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       decisionComment = "string",
#'       domainId = "string",
#'       existingSubscriptionId = "string",
#'       id = "string",
#'       metadataFormsSummary = list(
#'         list(
#'           formName = "string",
#'           typeName = "string",
#'           typeRevision = "string"
#'         )
#'       ),
#'       requestReason = "string",
#'       reviewerId = "string",
#'       status = "PENDING"|"ACCEPTED"|"REJECTED",
#'       subscribedListings = list(
#'         list(
#'           description = "string",
#'           id = "string",
#'           item = list(
#'             assetListing = list(
#'               assetScope = list(
#'                 assetId = "string",
#'                 errorMessage = "string",
#'                 filterIds = list(
#'                   "string"
#'                 ),
#'                 status = "string"
#'               ),
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string",
#'               forms = "string",
#'               glossaryTerms = list(
#'                 list(
#'                   name = "string",
#'                   shortDescription = "string"
#'                 )
#'               ),
#'               permissions = list(
#'                 s3 = list(
#'                   "READ"|"WRITE"
#'                 )
#'               )
#'             ),
#'             productListing = list(
#'               assetListings = list(
#'                 list(
#'                   entityId = "string",
#'                   entityRevision = "string",
#'                   entityType = "string"
#'                 )
#'               ),
#'               description = "string",
#'               entityId = "string",
#'               entityRevision = "string",
#'               glossaryTerms = list(
#'                 list(
#'                   name = "string",
#'                   shortDescription = "string"
#'                 )
#'               ),
#'               name = "string"
#'             )
#'           ),
#'           name = "string",
#'           ownerProjectId = "string",
#'           ownerProjectName = "string",
#'           revision = "string"
#'         )
#'       ),
#'       subscribedPrincipals = list(
#'         list(
#'           group = list(
#'             id = "string",
#'             name = "string"
#'           ),
#'           project = list(
#'             id = "string",
#'             name = "string"
#'           ),
#'           user = list(
#'             details = list(
#'               iam = list(
#'                 arn = "string",
#'                 principalId = "string"
#'               ),
#'               sso = list(
#'                 firstName = "string",
#'                 lastName = "string",
#'                 username = "string"
#'               )
#'             ),
#'             id = "string"
#'           )
#'         )
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_subscription_requests(
#'   approverProjectId = "string",
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   owningGroupId = "string",
#'   owningProjectId = "string",
#'   owningUserId = "string",
#'   sortBy = "CREATED_AT"|"UPDATED_AT",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListingId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_subscription_requests
#'
#' @aliases datazone_list_subscription_requests
datazone_list_subscription_requests <- function(approverProjectId = NULL, domainIdentifier, maxResults = NULL, nextToken = NULL, owningGroupId = NULL, owningProjectId = NULL, owningUserId = NULL, sortBy = NULL, sortOrder = NULL, status = NULL, subscribedListingId = NULL) {
  op <- new_operation(
    name = "ListSubscriptionRequests",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_subscription_requests_input(approverProjectId = approverProjectId, domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, owningGroupId = owningGroupId, owningProjectId = owningProjectId, owningUserId = owningUserId, sortBy = sortBy, sortOrder = sortOrder, status = status, subscribedListingId = subscribedListingId)
  output <- .datazone$list_subscription_requests_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_subscription_requests <- datazone_list_subscription_requests

#' Lists subscription targets in Amazon DataZone
#'
#' @description
#' Lists subscription targets in Amazon DataZone.
#'
#' @usage
#' datazone_list_subscription_targets(domainIdentifier,
#'   environmentIdentifier, maxResults, nextToken, sortBy, sortOrder)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain where you want to list
#' subscription targets.
#' @param environmentIdentifier &#91;required&#93; The identifier of the environment where you want to list subscription
#' targets.
#' @param maxResults The maximum number of subscription targets to return in a single call to
#' [`list_subscription_targets`][datazone_list_subscription_targets]. When
#' the number of subscription targets to be listed is greater than the
#' value of `MaxResults`, the response contains a `NextToken` value that
#' you can use in a subsequent call to
#' [`list_subscription_targets`][datazone_list_subscription_targets] to
#' list the next set of subscription targets.
#' @param nextToken When the number of subscription targets is greater than the default
#' value for the `MaxResults` parameter, or if you explicitly specify a
#' value for `MaxResults` that is less than the number of subscription
#' targets, the response includes a pagination token named `NextToken`. You
#' can specify this `NextToken` value in a subsequent call to
#' [`list_subscription_targets`][datazone_list_subscription_targets] to
#' list the next set of subscription targets.
#' @param sortBy Specifies the way in which the results of this action are to be sorted.
#' @param sortOrder Specifies the sort order for the results of this action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       applicableAssetTypes = list(
#'         "string"
#'       ),
#'       authorizedPrincipals = list(
#'         "string"
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       environmentId = "string",
#'       id = "string",
#'       manageAccessRole = "string",
#'       name = "string",
#'       projectId = "string",
#'       provider = "string",
#'       subscriptionTargetConfig = list(
#'         list(
#'           content = "string",
#'           formName = "string"
#'         )
#'       ),
#'       type = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_subscription_targets(
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CREATED_AT"|"UPDATED_AT",
#'   sortOrder = "ASCENDING"|"DESCENDING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_subscription_targets
#'
#' @aliases datazone_list_subscription_targets
datazone_list_subscription_targets <- function(domainIdentifier, environmentIdentifier, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListSubscriptionTargets",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_subscription_targets_input(domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .datazone$list_subscription_targets_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_subscription_targets <- datazone_list_subscription_targets

#' Lists subscriptions in Amazon DataZone
#'
#' @description
#' Lists subscriptions in Amazon DataZone.
#'
#' @usage
#' datazone_list_subscriptions(approverProjectId, domainIdentifier,
#'   maxResults, nextToken, owningGroupId, owningProjectId, owningUserId,
#'   sortBy, sortOrder, status, subscribedListingId,
#'   subscriptionRequestIdentifier)
#'
#' @param approverProjectId The identifier of the project for the subscription's approver.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param maxResults The maximum number of subscriptions to return in a single call to
#' [`list_subscriptions`][datazone_list_subscriptions]. When the number of
#' subscriptions to be listed is greater than the value of `MaxResults`,
#' the response contains a `NextToken` value that you can use in a
#' subsequent call to [`list_subscriptions`][datazone_list_subscriptions]
#' to list the next set of Subscriptions.
#' @param nextToken When the number of subscriptions is greater than the default value for
#' the `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of subscriptions, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`list_subscriptions`][datazone_list_subscriptions] to list the next set
#' of subscriptions.
#' @param owningGroupId The ID of the owning group.
#' @param owningProjectId The identifier of the owning project.
#' @param owningUserId The ID of the owning user.
#' @param sortBy Specifies the way in which the results of this action are to be sorted.
#' @param sortOrder Specifies the sort order for the results of this action.
#' @param status The status of the subscriptions that you want to list.
#' 
#' This is not a required parameter, but if not provided, by default,
#' Amazon DataZone returns only `APPROVED` subscriptions.
#' @param subscribedListingId The identifier of the subscribed listing for the subscriptions that you
#' want to list.
#' @param subscriptionRequestIdentifier The identifier of the subscription request for the subscriptions that
#' you want to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       domainId = "string",
#'       id = "string",
#'       retainPermissions = TRUE|FALSE,
#'       status = "APPROVED"|"REVOKED"|"CANCELLED",
#'       subscribedListing = list(
#'         description = "string",
#'         id = "string",
#'         item = list(
#'           assetListing = list(
#'             assetScope = list(
#'               assetId = "string",
#'               errorMessage = "string",
#'               filterIds = list(
#'                 "string"
#'               ),
#'               status = "string"
#'             ),
#'             entityId = "string",
#'             entityRevision = "string",
#'             entityType = "string",
#'             forms = "string",
#'             glossaryTerms = list(
#'               list(
#'                 name = "string",
#'                 shortDescription = "string"
#'               )
#'             ),
#'             permissions = list(
#'               s3 = list(
#'                 "READ"|"WRITE"
#'               )
#'             )
#'           ),
#'           productListing = list(
#'             assetListings = list(
#'               list(
#'                 entityId = "string",
#'                 entityRevision = "string",
#'                 entityType = "string"
#'               )
#'             ),
#'             description = "string",
#'             entityId = "string",
#'             entityRevision = "string",
#'             glossaryTerms = list(
#'               list(
#'                 name = "string",
#'                 shortDescription = "string"
#'               )
#'             ),
#'             name = "string"
#'           )
#'         ),
#'         name = "string",
#'         ownerProjectId = "string",
#'         ownerProjectName = "string",
#'         revision = "string"
#'       ),
#'       subscribedPrincipal = list(
#'         group = list(
#'           id = "string",
#'           name = "string"
#'         ),
#'         project = list(
#'           id = "string",
#'           name = "string"
#'         ),
#'         user = list(
#'           details = list(
#'             iam = list(
#'               arn = "string",
#'               principalId = "string"
#'             ),
#'             sso = list(
#'               firstName = "string",
#'               lastName = "string",
#'               username = "string"
#'             )
#'           ),
#'           id = "string"
#'         )
#'       ),
#'       subscriptionRequestId = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_subscriptions(
#'   approverProjectId = "string",
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   owningGroupId = "string",
#'   owningProjectId = "string",
#'   owningUserId = "string",
#'   sortBy = "CREATED_AT"|"UPDATED_AT",
#'   sortOrder = "ASCENDING"|"DESCENDING",
#'   status = "APPROVED"|"REVOKED"|"CANCELLED",
#'   subscribedListingId = "string",
#'   subscriptionRequestIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_subscriptions
#'
#' @aliases datazone_list_subscriptions
datazone_list_subscriptions <- function(approverProjectId = NULL, domainIdentifier, maxResults = NULL, nextToken = NULL, owningGroupId = NULL, owningProjectId = NULL, owningUserId = NULL, sortBy = NULL, sortOrder = NULL, status = NULL, subscribedListingId = NULL, subscriptionRequestIdentifier = NULL) {
  op <- new_operation(
    name = "ListSubscriptions",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/subscriptions",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_subscriptions_input(approverProjectId = approverProjectId, domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, owningGroupId = owningGroupId, owningProjectId = owningProjectId, owningUserId = owningUserId, sortBy = sortBy, sortOrder = sortOrder, status = status, subscribedListingId = subscribedListingId, subscriptionRequestIdentifier = subscriptionRequestIdentifier)
  output <- .datazone$list_subscriptions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_subscriptions <- datazone_list_subscriptions

#' Lists tags for the specified resource in Amazon DataZone
#'
#' @description
#' Lists tags for the specified resource in Amazon DataZone.
#'
#' @usage
#' datazone_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource whose tags you want to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_tags_for_resource
#'
#' @aliases datazone_list_tags_for_resource
datazone_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .datazone$list_tags_for_resource_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_tags_for_resource <- datazone_list_tags_for_resource

#' Lists time series data points
#'
#' @description
#' Lists time series data points.
#'
#' @usage
#' datazone_list_time_series_data_points(domainIdentifier, endedAt,
#'   entityIdentifier, entityType, formName, maxResults, nextToken,
#'   startedAt)
#'
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain that houses the assets for which
#' you want to list time series data points.
#' @param endedAt The timestamp at which the data points that you wanted to list ended.
#' @param entityIdentifier &#91;required&#93; The ID of the asset for which you want to list data points.
#' @param entityType &#91;required&#93; The type of the asset for which you want to list data points.
#' @param formName &#91;required&#93; The name of the time series data points form.
#' @param maxResults The maximum number of data points to return in a single call to
#' ListTimeSeriesDataPoints. When the number of data points to be listed is
#' greater than the value of MaxResults, the response contains a NextToken
#' value that you can use in a subsequent call to ListTimeSeriesDataPoints
#' to list the next set of data points.
#' @param nextToken When the number of data points is greater than the default value for the
#' MaxResults parameter, or if you explicitly specify a value for
#' MaxResults that is less than the number of data points, the response
#' includes a pagination token named NextToken. You can specify this
#' NextToken value in a subsequent call to ListTimeSeriesDataPoints to list
#' the next set of data points.
#' @param startedAt The timestamp at which the data points that you want to list started.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       contentSummary = "string",
#'       formName = "string",
#'       id = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_time_series_data_points(
#'   domainIdentifier = "string",
#'   endedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   entityIdentifier = "string",
#'   entityType = "ASSET"|"LISTING",
#'   formName = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_list_time_series_data_points
#'
#' @aliases datazone_list_time_series_data_points
datazone_list_time_series_data_points <- function(domainIdentifier, endedAt = NULL, entityIdentifier, entityType, formName, maxResults = NULL, nextToken = NULL, startedAt = NULL) {
  op <- new_operation(
    name = "ListTimeSeriesDataPoints",
    http_method = "GET",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$list_time_series_data_points_input(domainIdentifier = domainIdentifier, endedAt = endedAt, entityIdentifier = entityIdentifier, entityType = entityType, formName = formName, maxResults = maxResults, nextToken = nextToken, startedAt = startedAt)
  output <- .datazone$list_time_series_data_points_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$list_time_series_data_points <- datazone_list_time_series_data_points

#' Posts a data lineage event
#'
#' @description
#' Posts a data lineage event.
#'
#' @usage
#' datazone_post_lineage_event(clientToken, domainIdentifier, event)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to post a data lineage event.
#' @param event &#91;required&#93; The data lineage event that you want to post. Only open-lineage run
#' event are supported as events.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$post_lineage_event(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   event = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_post_lineage_event
#'
#' @aliases datazone_post_lineage_event
datazone_post_lineage_event <- function(clientToken = NULL, domainIdentifier, event) {
  op <- new_operation(
    name = "PostLineageEvent",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/lineage/events",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$post_lineage_event_input(clientToken = clientToken, domainIdentifier = domainIdentifier, event = event)
  output <- .datazone$post_lineage_event_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$post_lineage_event <- datazone_post_lineage_event

#' Posts time series data points to Amazon DataZone for the specified asset
#'
#' @description
#' Posts time series data points to Amazon DataZone for the specified
#' asset.
#'
#' @usage
#' datazone_post_time_series_data_points(clientToken, domainIdentifier,
#'   entityIdentifier, entityType, forms)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain in which you want to post time
#' series data points.
#' @param entityIdentifier &#91;required&#93; The ID of the asset for which you want to post time series data points.
#' @param entityType &#91;required&#93; The type of the asset for which you want to post data points.
#' @param forms &#91;required&#93; The forms that contain the data points that you want to post.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   entityId = "string",
#'   entityType = "ASSET"|"LISTING",
#'   forms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       id = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$post_time_series_data_points(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "ASSET"|"LISTING",
#'   forms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       timestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_post_time_series_data_points
#'
#' @aliases datazone_post_time_series_data_points
datazone_post_time_series_data_points <- function(clientToken = NULL, domainIdentifier, entityIdentifier, entityType, forms) {
  op <- new_operation(
    name = "PostTimeSeriesDataPoints",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/time-series-data-points",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$post_time_series_data_points_input(clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, forms = forms)
  output <- .datazone$post_time_series_data_points_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$post_time_series_data_points <- datazone_post_time_series_data_points

#' Creates data export configuration details
#'
#' @description
#' Creates data export configuration details.
#' 
#' In the current release, you can enable exporting asset metadata only for
#' one domain per Amazon Web Services account per region. If you disable
#' exporting asset metadata feature for a domain where it's already
#' enabled, you cannot enable this feature for another domain in the same
#' Amazon Web Services account and region.
#'
#' @usage
#' datazone_put_data_export_configuration(clientToken, domainIdentifier,
#'   enableExport, encryptionConfiguration)
#'
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param domainIdentifier &#91;required&#93; The domain ID where you want to create data export configuration
#' details.
#' @param enableExport &#91;required&#93; Specifies that the export is to be enabled as part of creating data
#' export configuration details.
#' @param encryptionConfiguration The encryption configuration as part of creating data export
#' configuration details.
#' 
#' The KMS key provided here as part of encryptionConfiguration must have
#' the required permissions as described in [KMS permissions for exporting
#' asset metadata in Amazon SageMaker Unified
#' Studio](https://docs.aws.amazon.com/sagemaker-unified-studio/latest/adminguide/sagemaker-unified-studio-export-asset-metadata-kms-permissions.html).
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_data_export_configuration(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   enableExport = TRUE|FALSE,
#'   encryptionConfiguration = list(
#'     kmsKeyArn = "string",
#'     sseAlgorithm = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_put_data_export_configuration
#'
#' @aliases datazone_put_data_export_configuration
datazone_put_data_export_configuration <- function(clientToken = NULL, domainIdentifier, enableExport, encryptionConfiguration = NULL) {
  op <- new_operation(
    name = "PutDataExportConfiguration",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/data-export-configuration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$put_data_export_configuration_input(clientToken = clientToken, domainIdentifier = domainIdentifier, enableExport = enableExport, encryptionConfiguration = encryptionConfiguration)
  output <- .datazone$put_data_export_configuration_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$put_data_export_configuration <- datazone_put_data_export_configuration

#' Writes the configuration for the specified environment blueprint in
#' Amazon DataZone
#'
#' @description
#' Writes the configuration for the specified environment blueprint in
#' Amazon DataZone.
#'
#' @usage
#' datazone_put_environment_blueprint_configuration(domainIdentifier,
#'   enabledRegions, environmentBlueprintIdentifier,
#'   environmentRolePermissionBoundary, globalParameters,
#'   manageAccessRoleArn, provisioningConfigurations, provisioningRoleArn,
#'   regionalParameters)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param enabledRegions &#91;required&#93; Specifies the enabled Amazon Web Services Regions.
#' @param environmentBlueprintIdentifier &#91;required&#93; The identifier of the environment blueprint.
#' @param environmentRolePermissionBoundary The environment role permissions boundary.
#' @param globalParameters Region-agnostic environment blueprint parameters.
#' @param manageAccessRoleArn The ARN of the manage access role.
#' @param provisioningConfigurations The provisioning configuration of a blueprint.
#' @param provisioningRoleArn The ARN of the provisioning role.
#' @param regionalParameters The regional parameters in the environment blueprint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   domainId = "string",
#'   enabledRegions = list(
#'     "string"
#'   ),
#'   environmentBlueprintId = "string",
#'   environmentRolePermissionBoundary = "string",
#'   manageAccessRoleArn = "string",
#'   provisioningConfigurations = list(
#'     list(
#'       lakeFormationConfiguration = list(
#'         locationRegistrationExcludeS3Locations = list(
#'           "string"
#'         ),
#'         locationRegistrationRole = "string"
#'       )
#'     )
#'   ),
#'   provisioningRoleArn = "string",
#'   regionalParameters = list(
#'     list(
#'       "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_environment_blueprint_configuration(
#'   domainIdentifier = "string",
#'   enabledRegions = list(
#'     "string"
#'   ),
#'   environmentBlueprintIdentifier = "string",
#'   environmentRolePermissionBoundary = "string",
#'   globalParameters = list(
#'     "string"
#'   ),
#'   manageAccessRoleArn = "string",
#'   provisioningConfigurations = list(
#'     list(
#'       lakeFormationConfiguration = list(
#'         locationRegistrationExcludeS3Locations = list(
#'           "string"
#'         ),
#'         locationRegistrationRole = "string"
#'       )
#'     )
#'   ),
#'   provisioningRoleArn = "string",
#'   regionalParameters = list(
#'     list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_put_environment_blueprint_configuration
#'
#' @aliases datazone_put_environment_blueprint_configuration
datazone_put_environment_blueprint_configuration <- function(domainIdentifier, enabledRegions, environmentBlueprintIdentifier, environmentRolePermissionBoundary = NULL, globalParameters = NULL, manageAccessRoleArn = NULL, provisioningConfigurations = NULL, provisioningRoleArn = NULL, regionalParameters = NULL) {
  op <- new_operation(
    name = "PutEnvironmentBlueprintConfiguration",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprint-configurations/{environmentBlueprintIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$put_environment_blueprint_configuration_input(domainIdentifier = domainIdentifier, enabledRegions = enabledRegions, environmentBlueprintIdentifier = environmentBlueprintIdentifier, environmentRolePermissionBoundary = environmentRolePermissionBoundary, globalParameters = globalParameters, manageAccessRoleArn = manageAccessRoleArn, provisioningConfigurations = provisioningConfigurations, provisioningRoleArn = provisioningRoleArn, regionalParameters = regionalParameters)
  output <- .datazone$put_environment_blueprint_configuration_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$put_environment_blueprint_configuration <- datazone_put_environment_blueprint_configuration

#' Rejects automatically generated business-friendly metadata for your
#' Amazon DataZone assets
#'
#' @description
#' Rejects automatically generated business-friendly metadata for your
#' Amazon DataZone assets.
#'
#' @usage
#' datazone_reject_predictions(clientToken, domainIdentifier, identifier,
#'   rejectChoices, rejectRule, revision)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param identifier &#91;required&#93; The identifier of the prediction.
#' @param rejectChoices Specifies the prediction (aka, the automatically generated piece of
#' metadata) and the target (for example, a column name) that can be
#' rejected.
#' @param rejectRule Specifies the rule (or the conditions) under which a prediction can be
#' rejected.
#' @param revision The revision that is to be made to the asset.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetId = "string",
#'   assetRevision = "string",
#'   domainId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reject_predictions(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   rejectChoices = list(
#'     list(
#'       predictionChoices = list(
#'         123
#'       ),
#'       predictionTarget = "string"
#'     )
#'   ),
#'   rejectRule = list(
#'     rule = "ALL"|"NONE",
#'     threshold = 123.0
#'   ),
#'   revision = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_reject_predictions
#'
#' @aliases datazone_reject_predictions
datazone_reject_predictions <- function(clientToken = NULL, domainIdentifier, identifier, rejectChoices = NULL, rejectRule = NULL, revision = NULL) {
  op <- new_operation(
    name = "RejectPredictions",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/assets/{identifier}/reject-predictions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$reject_predictions_input(clientToken = clientToken, domainIdentifier = domainIdentifier, identifier = identifier, rejectChoices = rejectChoices, rejectRule = rejectRule, revision = revision)
  output <- .datazone$reject_predictions_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$reject_predictions <- datazone_reject_predictions

#' Rejects the specified subscription request
#'
#' @description
#' Rejects the specified subscription request.
#'
#' @usage
#' datazone_reject_subscription_request(decisionComment, domainIdentifier,
#'   identifier)
#'
#' @param decisionComment The decision comment of the rejected subscription request.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which the subscription
#' request was rejected.
#' @param identifier &#91;required&#93; The identifier of the subscription request that was rejected.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   decisionComment = "string",
#'   domainId = "string",
#'   existingSubscriptionId = "string",
#'   id = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   reviewerId = "string",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListings = list(
#'     list(
#'       description = "string",
#'       id = "string",
#'       item = list(
#'         assetListing = list(
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           entityId = "string",
#'           entityRevision = "string",
#'           entityType = "string",
#'           forms = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           )
#'         ),
#'         productListing = list(
#'           assetListings = list(
#'             list(
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string"
#'             )
#'           ),
#'           description = "string",
#'           entityId = "string",
#'           entityRevision = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           name = "string"
#'         )
#'       ),
#'       name = "string",
#'       ownerProjectId = "string",
#'       ownerProjectName = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       project = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       user = list(
#'         details = list(
#'           iam = list(
#'             arn = "string",
#'             principalId = "string"
#'           ),
#'           sso = list(
#'             firstName = "string",
#'             lastName = "string",
#'             username = "string"
#'           )
#'         ),
#'         id = "string"
#'       )
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reject_subscription_request(
#'   decisionComment = "string",
#'   domainIdentifier = "string",
#'   identifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_reject_subscription_request
#'
#' @aliases datazone_reject_subscription_request
datazone_reject_subscription_request <- function(decisionComment = NULL, domainIdentifier, identifier) {
  op <- new_operation(
    name = "RejectSubscriptionRequest",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}/reject",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$reject_subscription_request_input(decisionComment = decisionComment, domainIdentifier = domainIdentifier, identifier = identifier)
  output <- .datazone$reject_subscription_request_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$reject_subscription_request <- datazone_reject_subscription_request

#' Removes an owner from an entity
#'
#' @description
#' Removes an owner from an entity.
#'
#' @usage
#' datazone_remove_entity_owner(clientToken, domainIdentifier,
#'   entityIdentifier, entityType, owner)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to remove an owner from an entity.
#' @param entityIdentifier &#91;required&#93; The ID of the entity from which you want to remove an owner.
#' @param entityType &#91;required&#93; The type of the entity from which you want to remove an owner.
#' @param owner &#91;required&#93; The owner that you want to remove from an entity.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$remove_entity_owner(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT",
#'   owner = list(
#'     group = list(
#'       groupIdentifier = "string"
#'     ),
#'     user = list(
#'       userIdentifier = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_remove_entity_owner
#'
#' @aliases datazone_remove_entity_owner
datazone_remove_entity_owner <- function(clientToken = NULL, domainIdentifier, entityIdentifier, entityType, owner) {
  op <- new_operation(
    name = "RemoveEntityOwner",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/entities/{entityType}/{entityIdentifier}/removeOwner",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$remove_entity_owner_input(clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, owner = owner)
  output <- .datazone$remove_entity_owner_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$remove_entity_owner <- datazone_remove_entity_owner

#' Removes a policy grant
#'
#' @description
#' Removes a policy grant.
#'
#' @usage
#' datazone_remove_policy_grant(clientToken, domainIdentifier,
#'   entityIdentifier, entityType, grantIdentifier, policyType, principal)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to remove a policy grant.
#' @param entityIdentifier &#91;required&#93; The ID of the entity from which you want to remove a policy grant.
#' @param entityType &#91;required&#93; The type of the entity from which you want to remove a policy grant.
#' @param grantIdentifier The ID of the policy grant that is to be removed from a specified
#' entity.
#' @param policyType &#91;required&#93; The type of the policy that you want to remove.
#' @param principal &#91;required&#93; The principal from which you want to remove a policy grant.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$remove_policy_grant(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   entityIdentifier = "string",
#'   entityType = "DOMAIN_UNIT"|"ENVIRONMENT_BLUEPRINT_CONFIGURATION"|"ENVIRONMENT_PROFILE"|"ASSET_TYPE",
#'   grantIdentifier = "string",
#'   policyType = "CREATE_DOMAIN_UNIT"|"OVERRIDE_DOMAIN_UNIT_OWNERS"|"ADD_TO_PROJECT_MEMBER_POOL"|"OVERRIDE_PROJECT_OWNERS"|"CREATE_GLOSSARY"|"CREATE_FORM_TYPE"|"CREATE_ASSET_TYPE"|"CREATE_PROJECT"|"CREATE_ENVIRONMENT_PROFILE"|"DELEGATE_CREATE_ENVIRONMENT_PROFILE"|"CREATE_ENVIRONMENT"|"CREATE_ENVIRONMENT_FROM_BLUEPRINT"|"CREATE_PROJECT_FROM_PROJECT_PROFILE"|"USE_ASSET_TYPE",
#'   principal = list(
#'     domainUnit = list(
#'       domainUnitDesignation = "OWNER",
#'       domainUnitGrantFilter = list(
#'         allDomainUnitsGrantFilter = list()
#'       ),
#'       domainUnitIdentifier = "string"
#'     ),
#'     group = list(
#'       groupIdentifier = "string"
#'     ),
#'     project = list(
#'       projectDesignation = "OWNER"|"CONTRIBUTOR"|"PROJECT_CATALOG_STEWARD",
#'       projectGrantFilter = list(
#'         domainUnitFilter = list(
#'           domainUnit = "string",
#'           includeChildDomainUnits = TRUE|FALSE
#'         )
#'       ),
#'       projectIdentifier = "string"
#'     ),
#'     user = list(
#'       allUsersGrantFilter = list(),
#'       userIdentifier = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_remove_policy_grant
#'
#' @aliases datazone_remove_policy_grant
datazone_remove_policy_grant <- function(clientToken = NULL, domainIdentifier, entityIdentifier, entityType, grantIdentifier = NULL, policyType, principal) {
  op <- new_operation(
    name = "RemovePolicyGrant",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/policies/managed/{entityType}/{entityIdentifier}/removeGrant",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$remove_policy_grant_input(clientToken = clientToken, domainIdentifier = domainIdentifier, entityIdentifier = entityIdentifier, entityType = entityType, grantIdentifier = grantIdentifier, policyType = policyType, principal = principal)
  output <- .datazone$remove_policy_grant_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$remove_policy_grant <- datazone_remove_policy_grant

#' Revokes a specified subscription in Amazon DataZone
#'
#' @description
#' Revokes a specified subscription in Amazon DataZone.
#'
#' @usage
#' datazone_revoke_subscription(domainIdentifier, identifier,
#'   retainPermissions)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain where you want to revoke a
#' subscription.
#' @param identifier &#91;required&#93; The identifier of the revoked subscription.
#' @param retainPermissions Specifies whether permissions are retained when the subscription is
#' revoked.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   id = "string",
#'   retainPermissions = TRUE|FALSE,
#'   status = "APPROVED"|"REVOKED"|"CANCELLED",
#'   subscribedListing = list(
#'     description = "string",
#'     id = "string",
#'     item = list(
#'       assetListing = list(
#'         assetScope = list(
#'           assetId = "string",
#'           errorMessage = "string",
#'           filterIds = list(
#'             "string"
#'           ),
#'           status = "string"
#'         ),
#'         entityId = "string",
#'         entityRevision = "string",
#'         entityType = "string",
#'         forms = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         permissions = list(
#'           s3 = list(
#'             "READ"|"WRITE"
#'           )
#'         )
#'       ),
#'       productListing = list(
#'         assetListings = list(
#'           list(
#'             entityId = "string",
#'             entityRevision = "string",
#'             entityType = "string"
#'           )
#'         ),
#'         description = "string",
#'         entityId = "string",
#'         entityRevision = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         name = "string"
#'       )
#'     ),
#'     name = "string",
#'     ownerProjectId = "string",
#'     ownerProjectName = "string",
#'     revision = "string"
#'   ),
#'   subscribedPrincipal = list(
#'     group = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     project = list(
#'       id = "string",
#'       name = "string"
#'     ),
#'     user = list(
#'       details = list(
#'         iam = list(
#'           arn = "string",
#'           principalId = "string"
#'         ),
#'         sso = list(
#'           firstName = "string",
#'           lastName = "string",
#'           username = "string"
#'         )
#'       ),
#'       id = "string"
#'     )
#'   ),
#'   subscriptionRequestId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$revoke_subscription(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   retainPermissions = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_revoke_subscription
#'
#' @aliases datazone_revoke_subscription
datazone_revoke_subscription <- function(domainIdentifier, identifier, retainPermissions = NULL) {
  op <- new_operation(
    name = "RevokeSubscription",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/subscriptions/{identifier}/revoke",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$revoke_subscription_input(domainIdentifier = domainIdentifier, identifier = identifier, retainPermissions = retainPermissions)
  output <- .datazone$revoke_subscription_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$revoke_subscription <- datazone_revoke_subscription

#' Searches for assets in Amazon DataZone
#'
#' @description
#' Searches for assets in Amazon DataZone.
#' 
#' Search in Amazon DataZone is a powerful capability that enables users to
#' discover and explore data assets, glossary terms, and data products
#' across their organization. It provides both basic and advanced search
#' functionality, allowing users to find resources based on names,
#' descriptions, metadata, and other attributes. Search can be scoped to
#' specific types of resources (like assets, glossary terms, or data
#' products) and can be filtered using various criteria such as creation
#' date, owner, or status. The search functionality is essential for making
#' the wealth of data resources in an organization discoverable and usable,
#' helping users find the right data for their needs quickly and
#' efficiently.
#' 
#' Many search commands in Amazon DataZone are paginated, including
#' `search` and `search-types`. When the result set is large, Amazon
#' DataZone returns a `nextToken` in the response. This token can be used
#' to retrieve the next page of results.
#' 
#' Prerequisites:
#' 
#' -   The --domain-identifier must refer to an existing Amazon DataZone
#'     domain.
#' 
#' -   --search-scope must be one of: ASSET, GLOSSARY_TERM, DATA_PRODUCT,
#'     or GLOSSARY.
#' 
#' -   The user must have search permissions in the specified domain.
#' 
#' -   If using --filters, ensure that the JSON is well-formed and that
#'     each filter includes valid attribute and value keys.
#' 
#' -   For paginated results, be prepared to use --next-token to fetch
#'     additional pages.
#'
#' @usage
#' datazone_search(additionalAttributes, domainIdentifier, filters,
#'   maxResults, nextToken, owningProjectIdentifier, searchIn, searchScope,
#'   searchText, sort)
#'
#' @param additionalAttributes Specifies additional attributes for the [`search`][datazone_search]
#' action.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain.
#' @param filters Specifies the search filters.
#' @param maxResults The maximum number of results to return in a single call to
#' [`search`][datazone_search]. When the number of results to be listed is
#' greater than the value of `MaxResults`, the response contains a
#' `NextToken` value that you can use in a subsequent call to
#' [`search`][datazone_search] to list the next set of results.
#' @param nextToken When the number of results is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of results, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to [`search`][datazone_search] to
#' list the next set of results.
#' @param owningProjectIdentifier The identifier of the owning project specified for the search.
#' @param searchIn The details of the search.
#' @param searchScope &#91;required&#93; The scope of the search.
#' @param searchText Specifies the text for which to search.
#' @param sort Specifies the way in which the search results are to be sorted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       assetItem = list(
#'         additionalAttributes = list(
#'           formsOutput = list(
#'             list(
#'               content = "string",
#'               formName = "string",
#'               typeName = "string",
#'               typeRevision = "string"
#'             )
#'           ),
#'           latestTimeSeriesDataPointFormsOutput = list(
#'             list(
#'               contentSummary = "string",
#'               formName = "string",
#'               id = "string",
#'               timestamp = as.POSIXct(
#'                 "2015-01-01"
#'               ),
#'               typeIdentifier = "string",
#'               typeRevision = "string"
#'             )
#'           ),
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           readOnlyFormsOutput = list(
#'             list(
#'               content = "string",
#'               formName = "string",
#'               typeName = "string",
#'               typeRevision = "string"
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         externalIdentifier = "string",
#'         firstRevisionCreatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         firstRevisionCreatedBy = "string",
#'         glossaryTerms = list(
#'           "string"
#'         ),
#'         governedGlossaryTerms = list(
#'           "string"
#'         ),
#'         identifier = "string",
#'         name = "string",
#'         owningProjectId = "string",
#'         typeIdentifier = "string",
#'         typeRevision = "string"
#'       ),
#'       dataProductItem = list(
#'         additionalAttributes = list(
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         firstRevisionCreatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         firstRevisionCreatedBy = "string",
#'         glossaryTerms = list(
#'           "string"
#'         ),
#'         id = "string",
#'         name = "string",
#'         owningProjectId = "string"
#'       ),
#'       glossaryItem = list(
#'         additionalAttributes = list(
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         id = "string",
#'         name = "string",
#'         owningProjectId = "string",
#'         status = "DISABLED"|"ENABLED",
#'         updatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         updatedBy = "string",
#'         usageRestrictions = list(
#'           "ASSET_GOVERNED_TERMS"
#'         )
#'       ),
#'       glossaryTermItem = list(
#'         additionalAttributes = list(
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         domainId = "string",
#'         glossaryId = "string",
#'         id = "string",
#'         longDescription = "string",
#'         name = "string",
#'         shortDescription = "string",
#'         status = "ENABLED"|"DISABLED",
#'         termRelations = list(
#'           classifies = list(
#'             "string"
#'           ),
#'           isA = list(
#'             "string"
#'           )
#'         ),
#'         updatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         updatedBy = "string",
#'         usageRestrictions = list(
#'           "ASSET_GOVERNED_TERMS"
#'         )
#'       )
#'     )
#'   ),
#'   nextToken = "string",
#'   totalMatchCount = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search(
#'   additionalAttributes = list(
#'     "FORMS"|"TIME_SERIES_DATA_POINT_FORMS"|"TEXT_MATCH_RATIONALE"
#'   ),
#'   domainIdentifier = "string",
#'   filters = list(
#'     and = list(
#'       list()
#'     ),
#'     filter = list(
#'       attribute = "string",
#'       value = "string"
#'     ),
#'     or = list(
#'       list()
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   owningProjectIdentifier = "string",
#'   searchIn = list(
#'     list(
#'       attribute = "string"
#'     )
#'   ),
#'   searchScope = "ASSET"|"GLOSSARY"|"GLOSSARY_TERM"|"DATA_PRODUCT",
#'   searchText = "string",
#'   sort = list(
#'     attribute = "string",
#'     order = "ASCENDING"|"DESCENDING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_search
#'
#' @aliases datazone_search
datazone_search <- function(additionalAttributes = NULL, domainIdentifier, filters = NULL, maxResults = NULL, nextToken = NULL, owningProjectIdentifier = NULL, searchIn = NULL, searchScope, searchText = NULL, sort = NULL) {
  op <- new_operation(
    name = "Search",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/search",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$search_input(additionalAttributes = additionalAttributes, domainIdentifier = domainIdentifier, filters = filters, maxResults = maxResults, nextToken = nextToken, owningProjectIdentifier = owningProjectIdentifier, searchIn = searchIn, searchScope = searchScope, searchText = searchText, sort = sort)
  output <- .datazone$search_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$search <- datazone_search

#' Searches group profiles in Amazon DataZone
#'
#' @description
#' Searches group profiles in Amazon DataZone.
#'
#' @usage
#' datazone_search_group_profiles(domainIdentifier, groupType, maxResults,
#'   nextToken, searchText)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which you want to search
#' group profiles.
#' @param groupType &#91;required&#93; The group type for which to search.
#' @param maxResults The maximum number of results to return in a single call to
#' [`search_group_profiles`][datazone_search_group_profiles]. When the
#' number of results to be listed is greater than the value of
#' `MaxResults`, the response contains a `NextToken` value that you can use
#' in a subsequent call to
#' [`search_group_profiles`][datazone_search_group_profiles] to list the
#' next set of results.
#' @param nextToken When the number of results is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of results, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`search_group_profiles`][datazone_search_group_profiles] to list the
#' next set of results.
#' @param searchText Specifies the text for which to search.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       domainId = "string",
#'       groupName = "string",
#'       id = "string",
#'       status = "ASSIGNED"|"NOT_ASSIGNED"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_group_profiles(
#'   domainIdentifier = "string",
#'   groupType = "SSO_GROUP"|"DATAZONE_SSO_GROUP",
#'   maxResults = 123,
#'   nextToken = "string",
#'   searchText = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_search_group_profiles
#'
#' @aliases datazone_search_group_profiles
datazone_search_group_profiles <- function(domainIdentifier, groupType, maxResults = NULL, nextToken = NULL, searchText = NULL) {
  op <- new_operation(
    name = "SearchGroupProfiles",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/search-group-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$search_group_profiles_input(domainIdentifier = domainIdentifier, groupType = groupType, maxResults = maxResults, nextToken = nextToken, searchText = searchText)
  output <- .datazone$search_group_profiles_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$search_group_profiles <- datazone_search_group_profiles

#' Searches listings in Amazon DataZone
#'
#' @description
#' Searches listings in Amazon DataZone.
#' 
#' SearchListings is a powerful capability that enables users to discover
#' and explore published assets and data products across their
#' organization. It provides both basic and advanced search functionality,
#' allowing users to find resources based on names, descriptions, metadata,
#' and other attributes. SearchListings also supports filtering using
#' various criteria such as creation date, owner, or status. This API is
#' essential for making the wealth of data resources in an organization
#' discoverable and usable, helping users find the right data for their
#' needs quickly and efficiently.
#' 
#' SearchListings returns results in a paginated format. When the result
#' set is large, the response will include a nextToken, which can be used
#' to retrieve the next page of results.
#' 
#' The SearchListings API gives users flexibility in specifying what kind
#' of search is run.
#' 
#' To run a free-text search, the `searchText` parameter must be supplied.
#' By default, all searchable fields are indexed for semantic search and
#' will return semantic matches for SearchListings queries. To prevent
#' semantic search indexing for a custom form attribute, see the
#' [CreateFormType API
#' documentation](https://docs.aws.amazon.com/datazone/latest/APIReference/API_CreateFormType.html).
#' To run a lexical search query, enclose the query with double quotes
#' (""). This will disable semantic search even for fields that have
#' semantic search enabled and will only return results that contain the
#' keywords wrapped by double quotes (order of tokens in the query is not
#' enforced). Free-text search is supported for all attributes annotated
#' with @@amazon.datazone#searchable.
#' 
#' To run a filtered search, provide filter clause using the filters
#' parameter. To filter on glossary terms, use the special attribute
#' `__DataZoneGlossaryTerms`.
#' 
#' To find out whether an attribute has been annotated and indexed for a
#' given search type, use the GetFormType API to retrieve the form
#' containing the attribute.
#'
#' @usage
#' datazone_search_listings(additionalAttributes, aggregations,
#'   domainIdentifier, filters, maxResults, nextToken, searchIn, searchText,
#'   sort)
#'
#' @param additionalAttributes Specifies additional attributes for the search.
#' @param aggregations Enables you to specify one or more attributes to compute and return
#' counts grouped by field values.
#' @param domainIdentifier &#91;required&#93; The identifier of the domain in which to search listings.
#' @param filters Specifies the filters for the search of listings.
#' @param maxResults The maximum number of results to return in a single call to
#' [`search_listings`][datazone_search_listings]. When the number of
#' results to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`search_listings`][datazone_search_listings] to list the next
#' set of results.
#' @param nextToken When the number of results is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of results, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`search_listings`][datazone_search_listings] to list the next set of
#' results.
#' @param searchIn The details of the search.
#' @param searchText Specifies the text for which to search.
#' @param sort Specifies the way for sorting the search results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   aggregates = list(
#'     list(
#'       attribute = "string",
#'       displayValue = "string",
#'       items = list(
#'         list(
#'           count = 123,
#'           displayValue = "string",
#'           value = "string"
#'         )
#'       )
#'     )
#'   ),
#'   items = list(
#'     list(
#'       assetListing = list(
#'         additionalAttributes = list(
#'           forms = "string",
#'           latestTimeSeriesDataPointForms = list(
#'             list(
#'               contentSummary = "string",
#'               formName = "string",
#'               id = "string",
#'               timestamp = as.POSIXct(
#'                 "2015-01-01"
#'               ),
#'               typeIdentifier = "string",
#'               typeRevision = "string"
#'             )
#'           ),
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         description = "string",
#'         entityId = "string",
#'         entityRevision = "string",
#'         entityType = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         governedGlossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         listingCreatedBy = "string",
#'         listingId = "string",
#'         listingRevision = "string",
#'         listingUpdatedBy = "string",
#'         name = "string",
#'         owningProjectId = "string"
#'       ),
#'       dataProductListing = list(
#'         additionalAttributes = list(
#'           forms = "string",
#'           matchRationale = list(
#'             list(
#'               textMatches = list(
#'                 list(
#'                   attribute = "string",
#'                   matchOffsets = list(
#'                     list(
#'                       endOffset = 123,
#'                       startOffset = 123
#'                     )
#'                   ),
#'                   text = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         description = "string",
#'         entityId = "string",
#'         entityRevision = "string",
#'         glossaryTerms = list(
#'           list(
#'             name = "string",
#'             shortDescription = "string"
#'           )
#'         ),
#'         items = list(
#'           list(
#'             glossaryTerms = list(
#'               list(
#'                 name = "string",
#'                 shortDescription = "string"
#'               )
#'             ),
#'             listingId = "string",
#'             listingRevision = "string"
#'           )
#'         ),
#'         listingCreatedBy = "string",
#'         listingId = "string",
#'         listingRevision = "string",
#'         listingUpdatedBy = "string",
#'         name = "string",
#'         owningProjectId = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string",
#'   totalMatchCount = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_listings(
#'   additionalAttributes = list(
#'     "FORMS"|"TIME_SERIES_DATA_POINT_FORMS"|"TEXT_MATCH_RATIONALE"
#'   ),
#'   aggregations = list(
#'     list(
#'       attribute = "string",
#'       displayValue = "string"
#'     )
#'   ),
#'   domainIdentifier = "string",
#'   filters = list(
#'     and = list(
#'       list()
#'     ),
#'     filter = list(
#'       attribute = "string",
#'       value = "string"
#'     ),
#'     or = list(
#'       list()
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   searchIn = list(
#'     list(
#'       attribute = "string"
#'     )
#'   ),
#'   searchText = "string",
#'   sort = list(
#'     attribute = "string",
#'     order = "ASCENDING"|"DESCENDING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_search_listings
#'
#' @aliases datazone_search_listings
datazone_search_listings <- function(additionalAttributes = NULL, aggregations = NULL, domainIdentifier, filters = NULL, maxResults = NULL, nextToken = NULL, searchIn = NULL, searchText = NULL, sort = NULL) {
  op <- new_operation(
    name = "SearchListings",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/listings/search",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$search_listings_input(additionalAttributes = additionalAttributes, aggregations = aggregations, domainIdentifier = domainIdentifier, filters = filters, maxResults = maxResults, nextToken = nextToken, searchIn = searchIn, searchText = searchText, sort = sort)
  output <- .datazone$search_listings_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$search_listings <- datazone_search_listings

#' Searches for types in Amazon DataZone
#'
#' @description
#' Searches for types in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The --domain-identifier must refer to an existing Amazon DataZone
#'     domain.
#' 
#' -   --search-scope must be one of the valid values including:
#'     ASSET_TYPE, GLOSSARY_TERM_TYPE, DATA_PRODUCT_TYPE.
#' 
#' -   The --managed flag must be present without a value.
#' 
#' -   The user must have permissions for form or asset types in the
#'     domain.
#' 
#' -   If using --filters, ensure that the JSON is valid.
#' 
#' -   Filters contain correct structure (attribute, value, operator).
#'
#' @usage
#' datazone_search_types(domainIdentifier, filters, managed, maxResults,
#'   nextToken, searchIn, searchScope, searchText, sort)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to invoke the
#' [`search_types`][datazone_search_types] action.
#' @param filters The filters for the [`search_types`][datazone_search_types] action.
#' @param managed &#91;required&#93; Specifies whether the search is managed.
#' @param maxResults The maximum number of results to return in a single call to
#' [`search_types`][datazone_search_types]. When the number of results to
#' be listed is greater than the value of `MaxResults`, the response
#' contains a `NextToken` value that you can use in a subsequent call to
#' [`search_types`][datazone_search_types] to list the next set of results.
#' @param nextToken When the number of results is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of results, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`search_types`][datazone_search_types] to list the next set of results.
#' @param searchIn The details of the search.
#' @param searchScope &#91;required&#93; Specifies the scope of the search for types.
#' @param searchText Specifies the text for which to search.
#' @param sort The specifies the way to sort the
#' [`search_types`][datazone_search_types] results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       assetTypeItem = list(
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         formsOutput = list(
#'           list(
#'             required = TRUE|FALSE,
#'             typeName = "string",
#'             typeRevision = "string"
#'           )
#'         ),
#'         name = "string",
#'         originDomainId = "string",
#'         originProjectId = "string",
#'         owningProjectId = "string",
#'         revision = "string",
#'         updatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         updatedBy = "string"
#'       ),
#'       formTypeItem = list(
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         imports = list(
#'           list(
#'             name = "string",
#'             revision = "string"
#'           )
#'         ),
#'         model = list(
#'           smithy = "string"
#'         ),
#'         name = "string",
#'         originDomainId = "string",
#'         originProjectId = "string",
#'         owningProjectId = "string",
#'         revision = "string",
#'         status = "ENABLED"|"DISABLED"
#'       ),
#'       lineageNodeTypeItem = list(
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         createdBy = "string",
#'         description = "string",
#'         domainId = "string",
#'         formsOutput = list(
#'           list(
#'             required = TRUE|FALSE,
#'             typeName = "string",
#'             typeRevision = "string"
#'           )
#'         ),
#'         name = "string",
#'         revision = "string",
#'         updatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         updatedBy = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string",
#'   totalMatchCount = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_types(
#'   domainIdentifier = "string",
#'   filters = list(
#'     and = list(
#'       list()
#'     ),
#'     filter = list(
#'       attribute = "string",
#'       value = "string"
#'     ),
#'     or = list(
#'       list()
#'     )
#'   ),
#'   managed = TRUE|FALSE,
#'   maxResults = 123,
#'   nextToken = "string",
#'   searchIn = list(
#'     list(
#'       attribute = "string"
#'     )
#'   ),
#'   searchScope = "ASSET_TYPE"|"FORM_TYPE"|"LINEAGE_NODE_TYPE",
#'   searchText = "string",
#'   sort = list(
#'     attribute = "string",
#'     order = "ASCENDING"|"DESCENDING"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_search_types
#'
#' @aliases datazone_search_types
datazone_search_types <- function(domainIdentifier, filters = NULL, managed, maxResults = NULL, nextToken = NULL, searchIn = NULL, searchScope, searchText = NULL, sort = NULL) {
  op <- new_operation(
    name = "SearchTypes",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/types-search",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$search_types_input(domainIdentifier = domainIdentifier, filters = filters, managed = managed, maxResults = maxResults, nextToken = nextToken, searchIn = searchIn, searchScope = searchScope, searchText = searchText, sort = sort)
  output <- .datazone$search_types_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$search_types <- datazone_search_types

#' Searches user profiles in Amazon DataZone
#'
#' @description
#' Searches user profiles in Amazon DataZone.
#'
#' @usage
#' datazone_search_user_profiles(domainIdentifier, maxResults, nextToken,
#'   searchText, userType)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which you want to search
#' user profiles.
#' @param maxResults The maximum number of results to return in a single call to
#' [`search_user_profiles`][datazone_search_user_profiles]. When the number
#' of results to be listed is greater than the value of `MaxResults`, the
#' response contains a `NextToken` value that you can use in a subsequent
#' call to [`search_user_profiles`][datazone_search_user_profiles] to list
#' the next set of results.
#' @param nextToken When the number of results is greater than the default value for the
#' `MaxResults` parameter, or if you explicitly specify a value for
#' `MaxResults` that is less than the number of results, the response
#' includes a pagination token named `NextToken`. You can specify this
#' `NextToken` value in a subsequent call to
#' [`search_user_profiles`][datazone_search_user_profiles] to list the next
#' set of results.
#' @param searchText Specifies the text for which to search.
#' @param userType &#91;required&#93; Specifies the user type for the
#' [`search_user_profiles`][datazone_search_user_profiles] action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       details = list(
#'         iam = list(
#'           arn = "string",
#'           principalId = "string"
#'         ),
#'         sso = list(
#'           firstName = "string",
#'           lastName = "string",
#'           username = "string"
#'         )
#'       ),
#'       domainId = "string",
#'       id = "string",
#'       status = "ASSIGNED"|"NOT_ASSIGNED"|"ACTIVATED"|"DEACTIVATED",
#'       type = "IAM"|"SSO"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$search_user_profiles(
#'   domainIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   searchText = "string",
#'   userType = "SSO_USER"|"DATAZONE_USER"|"DATAZONE_SSO_USER"|"DATAZONE_IAM_USER"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_search_user_profiles
#'
#' @aliases datazone_search_user_profiles
datazone_search_user_profiles <- function(domainIdentifier, maxResults = NULL, nextToken = NULL, searchText = NULL, userType) {
  op <- new_operation(
    name = "SearchUserProfiles",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/search-user-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "items"),
    stream_api = FALSE
  )
  input <- .datazone$search_user_profiles_input(domainIdentifier = domainIdentifier, maxResults = maxResults, nextToken = nextToken, searchText = searchText, userType = userType)
  output <- .datazone$search_user_profiles_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$search_user_profiles <- datazone_search_user_profiles

#' Start the run of the specified data source in Amazon DataZone
#'
#' @description
#' Start the run of the specified data source in Amazon DataZone.
#'
#' @usage
#' datazone_start_data_source_run(clientToken, dataSourceIdentifier,
#'   domainIdentifier)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param dataSourceIdentifier &#91;required&#93; The identifier of the data source.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which to start a data
#' source run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   dataSourceConfigurationSnapshot = "string",
#'   dataSourceId = "string",
#'   domainId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   projectId = "string",
#'   runStatisticsForAssets = list(
#'     added = 123,
#'     failed = 123,
#'     skipped = 123,
#'     unchanged = 123,
#'     updated = 123
#'   ),
#'   startedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   status = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   stoppedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   type = "PRIORITIZED"|"SCHEDULED",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_data_source_run(
#'   clientToken = "string",
#'   dataSourceIdentifier = "string",
#'   domainIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_start_data_source_run
#'
#' @aliases datazone_start_data_source_run
datazone_start_data_source_run <- function(clientToken = NULL, dataSourceIdentifier, domainIdentifier) {
  op <- new_operation(
    name = "StartDataSourceRun",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/data-sources/{dataSourceIdentifier}/runs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$start_data_source_run_input(clientToken = clientToken, dataSourceIdentifier = dataSourceIdentifier, domainIdentifier = domainIdentifier)
  output <- .datazone$start_data_source_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$start_data_source_run <- datazone_start_data_source_run

#' Starts the metadata generation run
#'
#' @description
#' Starts the metadata generation run.
#' 
#' Prerequisites:
#' 
#' -   Asset must be created and belong to the specified domain and
#'     project.
#' 
#' -   Asset type must be supported for metadata generation (e.g., Amazon
#'     Web Services Glue table).
#' 
#' -   Asset must have a structured schema with valid rows and columns.
#' 
#' -   Valid values for --type: BUSINESS_DESCRIPTIONS, BUSINESS_NAMES,
#'     BUSINESS_GLOSSARY_ASSOCIATIONS.
#' 
#' -   The user must have permission to run metadata generation in the
#'     domain/project.
#'
#' @usage
#' datazone_start_metadata_generation_run(clientToken, domainIdentifier,
#'   owningProjectIdentifier, target, type, types)
#'
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where you want to start a metadata
#' generation run.
#' @param owningProjectIdentifier &#91;required&#93; The ID of the project that owns the asset for which you want to start a
#' metadata generation run.
#' @param target &#91;required&#93; The asset for which you want to start a metadata generation run.
#' @param type The type of the metadata generation run.
#' @param types The types of the metadata generation run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   id = "string",
#'   owningProjectId = "string",
#'   status = "SUBMITTED"|"IN_PROGRESS"|"CANCELED"|"SUCCEEDED"|"FAILED"|"PARTIALLY_SUCCEEDED",
#'   type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS",
#'   types = list(
#'     "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_metadata_generation_run(
#'   clientToken = "string",
#'   domainIdentifier = "string",
#'   owningProjectIdentifier = "string",
#'   target = list(
#'     identifier = "string",
#'     revision = "string",
#'     type = "ASSET"
#'   ),
#'   type = "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS",
#'   types = list(
#'     "BUSINESS_DESCRIPTIONS"|"BUSINESS_NAMES"|"BUSINESS_GLOSSARY_ASSOCIATIONS"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_start_metadata_generation_run
#'
#' @aliases datazone_start_metadata_generation_run
datazone_start_metadata_generation_run <- function(clientToken = NULL, domainIdentifier, owningProjectIdentifier, target, type = NULL, types = NULL) {
  op <- new_operation(
    name = "StartMetadataGenerationRun",
    http_method = "POST",
    http_path = "/v2/domains/{domainIdentifier}/metadata-generation-runs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$start_metadata_generation_run_input(clientToken = clientToken, domainIdentifier = domainIdentifier, owningProjectIdentifier = owningProjectIdentifier, target = target, type = type, types = types)
  output <- .datazone$start_metadata_generation_run_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$start_metadata_generation_run <- datazone_start_metadata_generation_run

#' Tags a resource in Amazon DataZone
#'
#' @description
#' Tags a resource in Amazon DataZone.
#'
#' @usage
#' datazone_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to be tagged in Amazon DataZone.
#' @param tags &#91;required&#93; Specifies the tags for the [`tag_resource`][datazone_tag_resource]
#' action.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_tag_resource
#'
#' @aliases datazone_tag_resource
datazone_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .datazone$tag_resource_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$tag_resource <- datazone_tag_resource

#' Untags a resource in Amazon DataZone
#'
#' @description
#' Untags a resource in Amazon DataZone.
#'
#' @usage
#' datazone_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to be untagged in Amazon DataZone.
#' @param tagKeys &#91;required&#93; Specifies the tag keys for the
#' [`untag_resource`][datazone_untag_resource] action.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_untag_resource
#'
#' @aliases datazone_untag_resource
datazone_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .datazone$untag_resource_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$untag_resource <- datazone_untag_resource

#' Updates the account pool
#'
#' @description
#' Updates the account pool.
#'
#' @usage
#' datazone_update_account_pool(accountSource, description,
#'   domainIdentifier, identifier, name, resolutionStrategy)
#'
#' @param accountSource The source of accounts for the account pool. In the current release,
#' it's either a static list of accounts provided by the customer or a
#' custom Amazon Web Services Lambda handler.
#' @param description The description of the account pool that is to be udpated.
#' @param domainIdentifier &#91;required&#93; The domain ID where the account pool that is to be updated lives.
#' @param identifier &#91;required&#93; The ID of the account pool that is to be updated.
#' @param name The name of the account pool that is to be updated.
#' @param resolutionStrategy The mechanism used to resolve the account selection from the account
#' pool.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   accountSource = list(
#'     accounts = list(
#'       list(
#'         awsAccountId = "string",
#'         awsAccountName = "string",
#'         supportedRegions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     customAccountPoolHandler = list(
#'       lambdaExecutionRoleArn = "string",
#'       lambdaFunctionArn = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   resolutionStrategy = "MANUAL",
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_account_pool(
#'   accountSource = list(
#'     accounts = list(
#'       list(
#'         awsAccountId = "string",
#'         awsAccountName = "string",
#'         supportedRegions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     customAccountPoolHandler = list(
#'       lambdaExecutionRoleArn = "string",
#'       lambdaFunctionArn = "string"
#'     )
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   name = "string",
#'   resolutionStrategy = "MANUAL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_account_pool
#'
#' @aliases datazone_update_account_pool
datazone_update_account_pool <- function(accountSource = NULL, description = NULL, domainIdentifier, identifier, name = NULL, resolutionStrategy = NULL) {
  op <- new_operation(
    name = "UpdateAccountPool",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/account-pools/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_account_pool_input(accountSource = accountSource, description = description, domainIdentifier = domainIdentifier, identifier = identifier, name = name, resolutionStrategy = resolutionStrategy)
  output <- .datazone$update_account_pool_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_account_pool <- datazone_update_account_pool

#' Updates an asset filter
#'
#' @description
#' Updates an asset filter.
#' 
#' Prerequisites:
#' 
#' -   The domain, asset, and asset filter identifier must all exist.
#' 
#' -   The asset must contain the columns being referenced in the update.
#' 
#' -   If applying a row filter, ensure the column referenced in the
#'     expression exists in the asset schema.
#'
#' @usage
#' datazone_update_asset_filter(assetIdentifier, configuration,
#'   description, domainIdentifier, identifier, name)
#'
#' @param assetIdentifier &#91;required&#93; The ID of the data asset.
#' @param configuration The configuration of the asset filter.
#' @param description The description of the asset filter.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to update an asset filter.
#' @param identifier &#91;required&#93; The ID of the asset filter.
#' @param name The name of the asset filter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetId = "string",
#'   configuration = list(
#'     columnConfiguration = list(
#'       includedColumnNames = list(
#'         "string"
#'       )
#'     ),
#'     rowConfiguration = list(
#'       rowFilter = list(
#'         and = list(
#'           list()
#'         ),
#'         expression = list(
#'           equalTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           in = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           isNotNull = list(
#'             columnName = "string"
#'           ),
#'           isNull = list(
#'             columnName = "string"
#'           ),
#'           lessThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           lessThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           like = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notIn = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           notLike = list(
#'             columnName = "string",
#'             value = "string"
#'           )
#'         ),
#'         or = list(
#'           list()
#'         )
#'       ),
#'       sensitive = TRUE|FALSE
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   effectiveColumnNames = list(
#'     "string"
#'   ),
#'   effectiveRowFilter = "string",
#'   errorMessage = "string",
#'   id = "string",
#'   name = "string",
#'   status = "VALID"|"INVALID"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_asset_filter(
#'   assetIdentifier = "string",
#'   configuration = list(
#'     columnConfiguration = list(
#'       includedColumnNames = list(
#'         "string"
#'       )
#'     ),
#'     rowConfiguration = list(
#'       rowFilter = list(
#'         and = list(
#'           list()
#'         ),
#'         expression = list(
#'           equalTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           greaterThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           in = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           isNotNull = list(
#'             columnName = "string"
#'           ),
#'           isNull = list(
#'             columnName = "string"
#'           ),
#'           lessThan = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           lessThanOrEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           like = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notEqualTo = list(
#'             columnName = "string",
#'             value = "string"
#'           ),
#'           notIn = list(
#'             columnName = "string",
#'             values = list(
#'               "string"
#'             )
#'           ),
#'           notLike = list(
#'             columnName = "string",
#'             value = "string"
#'           )
#'         ),
#'         or = list(
#'           list()
#'         )
#'       ),
#'       sensitive = TRUE|FALSE
#'     )
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_asset_filter
#'
#' @aliases datazone_update_asset_filter
datazone_update_asset_filter <- function(assetIdentifier, configuration = NULL, description = NULL, domainIdentifier, identifier, name = NULL) {
  op <- new_operation(
    name = "UpdateAssetFilter",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/assets/{assetIdentifier}/filters/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_asset_filter_input(assetIdentifier = assetIdentifier, configuration = configuration, description = description, domainIdentifier = domainIdentifier, identifier = identifier, name = name)
  output <- .datazone$update_asset_filter_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_asset_filter <- datazone_update_asset_filter

#' Updates a connection
#'
#' @description
#' Updates a connection. In Amazon DataZone, a connection enables you to
#' connect your resources (domains, projects, and environments) to external
#' resources and services.
#'
#' @usage
#' datazone_update_connection(awsLocation, description, domainIdentifier,
#'   identifier, props)
#'
#' @param awsLocation The location where a connection is to be updated.
#' @param description The description of a connection.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where a connection is to be updated.
#' @param identifier &#91;required&#93; The ID of the connection to be updated.
#' @param props The connection props.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   connectionId = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentId = "string",
#'   name = "string",
#'   physicalEndpoints = list(
#'     list(
#'       awsLocation = list(
#'         accessRole = "string",
#'         awsAccountId = "string",
#'         awsRegion = "string",
#'         iamConnectionId = "string"
#'       ),
#'       enableTrustedIdentityPropagation = TRUE|FALSE,
#'       glueConnection = list(
#'         athenaProperties = list(
#'           "string"
#'         ),
#'         authenticationConfiguration = list(
#'           authenticationType = "BASIC"|"OAUTH2"|"CUSTOM",
#'           oAuth2Properties = list(
#'             authorizationCodeProperties = list(
#'               authorizationCode = "string",
#'               redirectUri = "string"
#'             ),
#'             oAuth2ClientApplication = list(
#'               aWSManagedClientApplicationReference = "string",
#'               userManagedClientApplicationClientId = "string"
#'             ),
#'             oAuth2Credentials = list(
#'               accessToken = "string",
#'               jwtToken = "string",
#'               refreshToken = "string",
#'               userManagedClientApplicationClientSecret = "string"
#'             ),
#'             oAuth2GrantType = "AUTHORIZATION_CODE"|"CLIENT_CREDENTIALS"|"JWT_BEARER",
#'             tokenUrl = "string",
#'             tokenUrlParametersMap = list(
#'               "string"
#'             )
#'           ),
#'           secretArn = "string"
#'         ),
#'         compatibleComputeEnvironments = list(
#'           "SPARK"|"ATHENA"|"PYTHON"
#'         ),
#'         connectionProperties = list(
#'           "string"
#'         ),
#'         connectionSchemaVersion = 123,
#'         connectionType = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW",
#'         creationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         description = "string",
#'         lastConnectionValidationTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         lastUpdatedBy = "string",
#'         lastUpdatedTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         matchCriteria = list(
#'           "string"
#'         ),
#'         name = "string",
#'         physicalConnectionRequirements = list(
#'           availabilityZone = "string",
#'           securityGroupIdList = list(
#'             "string"
#'           ),
#'           subnetId = "string",
#'           subnetIdList = list(
#'             "string"
#'           )
#'         ),
#'         pythonProperties = list(
#'           "string"
#'         ),
#'         sparkProperties = list(
#'           "string"
#'         ),
#'         status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'         statusReason = "string"
#'       ),
#'       glueConnectionName = "string",
#'       host = "string",
#'       port = 123,
#'       protocol = "ATHENA"|"GLUE_INTERACTIVE_SESSION"|"HTTPS"|"JDBC"|"LIVY"|"ODBC"|"PRISM",
#'       stage = "string"
#'     )
#'   ),
#'   projectId = "string",
#'   props = list(
#'     amazonQProperties = list(
#'       authMode = "string",
#'       isEnabled = TRUE|FALSE,
#'       profileArn = "string"
#'     ),
#'     athenaProperties = list(
#'       workgroupName = "string"
#'     ),
#'     glueProperties = list(
#'       errorMessage = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     hyperPodProperties = list(
#'       clusterArn = "string",
#'       clusterName = "string",
#'       orchestrator = "EKS"|"SLURM"
#'     ),
#'     iamProperties = list(
#'       environmentId = "string",
#'       glueLineageSyncEnabled = TRUE|FALSE
#'     ),
#'     mlflowProperties = list(
#'       trackingServerArn = "string"
#'     ),
#'     redshiftProperties = list(
#'       credentials = list(
#'         secretArn = "string",
#'         usernamePassword = list(
#'           password = "string",
#'           username = "string"
#'         )
#'       ),
#'       databaseName = "string",
#'       isProvisionedSecret = TRUE|FALSE,
#'       jdbcIamUrl = "string",
#'       jdbcUrl = "string",
#'       lineageSync = list(
#'         enabled = TRUE|FALSE,
#'         lineageJobId = "string",
#'         schedule = list(
#'           schedule = "string"
#'         )
#'       ),
#'       redshiftTempDir = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED",
#'       storage = list(
#'         clusterName = "string",
#'         workgroupName = "string"
#'       )
#'     ),
#'     s3Properties = list(
#'       errorMessage = "string",
#'       s3AccessGrantLocationId = "string",
#'       s3Uri = "string",
#'       status = "CREATING"|"CREATE_FAILED"|"DELETING"|"DELETE_FAILED"|"READY"|"UPDATING"|"UPDATE_FAILED"|"DELETED"
#'     ),
#'     sparkEmrProperties = list(
#'       certificateData = "string",
#'       computeArn = "string",
#'       credentials = list(
#'         password = "string",
#'         username = "string"
#'       ),
#'       credentialsExpiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       governanceType = "AWS_MANAGED"|"USER_MANAGED",
#'       instanceProfileArn = "string",
#'       javaVirtualEnv = "string",
#'       livyEndpoint = "string",
#'       logUri = "string",
#'       managedEndpointArn = "string",
#'       managedEndpointCredentials = list(
#'         id = "string",
#'         token = "string"
#'       ),
#'       pythonVirtualEnv = "string",
#'       runtimeRole = "string",
#'       trustedCertificatesS3Uri = "string"
#'     ),
#'     sparkGlueProperties = list(
#'       additionalArgs = list(
#'         connection = "string"
#'       ),
#'       glueConnectionName = "string",
#'       glueVersion = "string",
#'       idleTimeout = 123,
#'       javaVirtualEnv = "string",
#'       numberOfWorkers = 123,
#'       pythonVirtualEnv = "string",
#'       workerType = "string"
#'     )
#'   ),
#'   scope = "DOMAIN"|"PROJECT",
#'   type = "ATHENA"|"BIGQUERY"|"DATABRICKS"|"DOCUMENTDB"|"DYNAMODB"|"HYPERPOD"|"IAM"|"MYSQL"|"OPENSEARCH"|"ORACLE"|"POSTGRESQL"|"REDSHIFT"|"S3"|"SAPHANA"|"SNOWFLAKE"|"SPARK"|"SQLSERVER"|"TERADATA"|"VERTICA"|"WORKFLOWS_MWAA"|"AMAZON_Q"|"MLFLOW"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_connection(
#'   awsLocation = list(
#'     accessRole = "string",
#'     awsAccountId = "string",
#'     awsRegion = "string",
#'     iamConnectionId = "string"
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   props = list(
#'     amazonQProperties = list(
#'       authMode = "string",
#'       isEnabled = TRUE|FALSE,
#'       profileArn = "string"
#'     ),
#'     athenaProperties = list(
#'       workgroupName = "string"
#'     ),
#'     glueProperties = list(
#'       glueConnectionInput = list(
#'         authenticationConfiguration = list(
#'           basicAuthenticationCredentials = list(
#'             password = "string",
#'             userName = "string"
#'           ),
#'           secretArn = "string"
#'         ),
#'         connectionProperties = list(
#'           "string"
#'         ),
#'         description = "string"
#'       )
#'     ),
#'     iamProperties = list(
#'       glueLineageSyncEnabled = TRUE|FALSE
#'     ),
#'     mlflowProperties = list(
#'       trackingServerArn = "string"
#'     ),
#'     redshiftProperties = list(
#'       credentials = list(
#'         secretArn = "string",
#'         usernamePassword = list(
#'           password = "string",
#'           username = "string"
#'         )
#'       ),
#'       databaseName = "string",
#'       host = "string",
#'       lineageSync = list(
#'         enabled = TRUE|FALSE,
#'         schedule = list(
#'           schedule = "string"
#'         )
#'       ),
#'       port = 123,
#'       storage = list(
#'         clusterName = "string",
#'         workgroupName = "string"
#'       )
#'     ),
#'     s3Properties = list(
#'       s3AccessGrantLocationId = "string",
#'       s3Uri = "string"
#'     ),
#'     sparkEmrProperties = list(
#'       computeArn = "string",
#'       instanceProfileArn = "string",
#'       javaVirtualEnv = "string",
#'       logUri = "string",
#'       managedEndpointArn = "string",
#'       pythonVirtualEnv = "string",
#'       runtimeRole = "string",
#'       trustedCertificatesS3Uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_connection
#'
#' @aliases datazone_update_connection
datazone_update_connection <- function(awsLocation = NULL, description = NULL, domainIdentifier, identifier, props = NULL) {
  op <- new_operation(
    name = "UpdateConnection",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/connections/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_connection_input(awsLocation = awsLocation, description = description, domainIdentifier = domainIdentifier, identifier = identifier, props = props)
  output <- .datazone$update_connection_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_connection <- datazone_update_connection

#' Updates the specified data source in Amazon DataZone
#'
#' @description
#' Updates the specified data source in Amazon DataZone.
#'
#' @usage
#' datazone_update_data_source(assetFormsInput, configuration, description,
#'   domainIdentifier, enableSetting, identifier, name, publishOnImport,
#'   recommendation, retainPermissionsOnRevokeFailure, schedule)
#'
#' @param assetFormsInput The asset forms to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param configuration The configuration to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param description The description to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param domainIdentifier &#91;required&#93; The identifier of the domain in which to update a data source.
#' @param enableSetting The enable setting to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param identifier &#91;required&#93; The identifier of the data source to be updated.
#' @param name The name to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param publishOnImport The publish on import setting to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param recommendation The recommendation to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#' @param retainPermissionsOnRevokeFailure Specifies that the granted permissions are retained in case of a
#' self-subscribe functionality failure for a data source.
#' @param schedule The schedule to be updated as part of the
#' [`update_data_source`][datazone_update_data_source] action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assetFormsOutput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       accountId = "string",
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       accountId = "string",
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       region = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       accountId = "string",
#'       region = "string",
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   connectionId = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   environmentId = "string",
#'   errorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   id = "string",
#'   lastRunAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastRunErrorMessage = list(
#'     errorDetail = "string",
#'     errorType = "ACCESS_DENIED_EXCEPTION"|"CONFLICT_EXCEPTION"|"INTERNAL_SERVER_EXCEPTION"|"RESOURCE_NOT_FOUND_EXCEPTION"|"SERVICE_QUOTA_EXCEEDED_EXCEPTION"|"THROTTLING_EXCEPTION"|"VALIDATION_EXCEPTION"
#'   ),
#'   lastRunStatus = "REQUESTED"|"RUNNING"|"FAILED"|"PARTIALLY_SUCCEEDED"|"SUCCESS",
#'   name = "string",
#'   projectId = "string",
#'   publishOnImport = TRUE|FALSE,
#'   recommendation = list(
#'     enableBusinessNameGeneration = TRUE|FALSE
#'   ),
#'   retainPermissionsOnRevokeFailure = TRUE|FALSE,
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   ),
#'   selfGrantStatus = list(
#'     glueSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     ),
#'     redshiftSelfGrantStatus = list(
#'       selfGrantStatusDetails = list(
#'         list(
#'           databaseName = "string",
#'           failureCause = "string",
#'           schemaName = "string",
#'           status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"GRANT_FAILED"|"REVOKE_FAILED"
#'         )
#'       )
#'     )
#'   ),
#'   status = "CREATING"|"FAILED_CREATION"|"READY"|"UPDATING"|"FAILED_UPDATE"|"RUNNING"|"DELETING"|"FAILED_DELETION",
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_data_source(
#'   assetFormsInput = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeIdentifier = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   configuration = list(
#'     glueRunConfiguration = list(
#'       autoImportDataQualityResult = TRUE|FALSE,
#'       catalogName = "string",
#'       dataAccessRole = "string",
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     redshiftRunConfiguration = list(
#'       dataAccessRole = "string",
#'       redshiftCredentialConfiguration = list(
#'         secretManagerArn = "string"
#'       ),
#'       redshiftStorage = list(
#'         redshiftClusterSource = list(
#'           clusterName = "string"
#'         ),
#'         redshiftServerlessSource = list(
#'           workgroupName = "string"
#'         )
#'       ),
#'       relationalFilterConfigurations = list(
#'         list(
#'           databaseName = "string",
#'           filterExpressions = list(
#'             list(
#'               expression = "string",
#'               type = "INCLUDE"|"EXCLUDE"
#'             )
#'           ),
#'           schemaName = "string"
#'         )
#'       )
#'     ),
#'     sageMakerRunConfiguration = list(
#'       trackingAssets = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   description = "string",
#'   domainIdentifier = "string",
#'   enableSetting = "ENABLED"|"DISABLED",
#'   identifier = "string",
#'   name = "string",
#'   publishOnImport = TRUE|FALSE,
#'   recommendation = list(
#'     enableBusinessNameGeneration = TRUE|FALSE
#'   ),
#'   retainPermissionsOnRevokeFailure = TRUE|FALSE,
#'   schedule = list(
#'     schedule = "string",
#'     timezone = "UTC"|"AFRICA_JOHANNESBURG"|"AMERICA_MONTREAL"|"AMERICA_SAO_PAULO"|"ASIA_BAHRAIN"|"ASIA_BANGKOK"|"ASIA_CALCUTTA"|"ASIA_DUBAI"|"ASIA_HONG_KONG"|"ASIA_JAKARTA"|"ASIA_KUALA_LUMPUR"|"ASIA_SEOUL"|"ASIA_SHANGHAI"|"ASIA_SINGAPORE"|"ASIA_TAIPEI"|"ASIA_TOKYO"|"AUSTRALIA_MELBOURNE"|"AUSTRALIA_SYDNEY"|"CANADA_CENTRAL"|"CET"|"CST6CDT"|"ETC_GMT"|"ETC_GMT0"|"ETC_GMT_ADD_0"|"ETC_GMT_ADD_1"|"ETC_GMT_ADD_10"|"ETC_GMT_ADD_11"|"ETC_GMT_ADD_12"|"ETC_GMT_ADD_2"|"ETC_GMT_ADD_3"|"ETC_GMT_ADD_4"|"ETC_GMT_ADD_5"|"ETC_GMT_ADD_6"|"ETC_GMT_ADD_7"|"ETC_GMT_ADD_8"|"ETC_GMT_ADD_9"|"ETC_GMT_NEG_0"|"ETC_GMT_NEG_1"|"ETC_GMT_NEG_10"|"ETC_GMT_NEG_11"|"ETC_GMT_NEG_12"|"ETC_GMT_NEG_13"|"ETC_GMT_NEG_14"|"ETC_GMT_NEG_2"|"ETC_GMT_NEG_3"|"ETC_GMT_NEG_4"|"ETC_GMT_NEG_5"|"ETC_GMT_NEG_6"|"ETC_GMT_NEG_7"|"ETC_GMT_NEG_8"|"ETC_GMT_NEG_9"|"EUROPE_DUBLIN"|"EUROPE_LONDON"|"EUROPE_PARIS"|"EUROPE_STOCKHOLM"|"EUROPE_ZURICH"|"ISRAEL"|"MEXICO_GENERAL"|"MST7MDT"|"PACIFIC_AUCKLAND"|"US_CENTRAL"|"US_EASTERN"|"US_MOUNTAIN"|"US_PACIFIC"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_data_source
#'
#' @aliases datazone_update_data_source
datazone_update_data_source <- function(assetFormsInput = NULL, configuration = NULL, description = NULL, domainIdentifier, enableSetting = NULL, identifier, name = NULL, publishOnImport = NULL, recommendation = NULL, retainPermissionsOnRevokeFailure = NULL, schedule = NULL) {
  op <- new_operation(
    name = "UpdateDataSource",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/data-sources/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_data_source_input(assetFormsInput = assetFormsInput, configuration = configuration, description = description, domainIdentifier = domainIdentifier, enableSetting = enableSetting, identifier = identifier, name = name, publishOnImport = publishOnImport, recommendation = recommendation, retainPermissionsOnRevokeFailure = retainPermissionsOnRevokeFailure, schedule = schedule)
  output <- .datazone$update_data_source_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_data_source <- datazone_update_data_source

#' Updates a Amazon DataZone domain
#'
#' @description
#' Updates a Amazon DataZone domain.
#'
#' @usage
#' datazone_update_domain(clientToken, description, domainExecutionRole,
#'   identifier, name, serviceRole, singleSignOn)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description to be updated as part of the
#' [`update_domain`][datazone_update_domain] action.
#' @param domainExecutionRole The domain execution role to be updated as part of the
#' [`update_domain`][datazone_update_domain] action.
#' @param identifier &#91;required&#93; The ID of the Amazon Web Services domain that is to be updated.
#' @param name The name to be updated as part of the
#' [`update_domain`][datazone_update_domain] action.
#' @param serviceRole The service role of the domain.
#' @param singleSignOn The single sign-on option to be updated as part of the
#' [`update_domain`][datazone_update_domain] action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainExecutionRole = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   rootDomainUnitId = "string",
#'   serviceRole = "string",
#'   singleSignOn = list(
#'     idcInstanceArn = "string",
#'     type = "IAM_IDC"|"DISABLED",
#'     userAssignment = "AUTOMATIC"|"MANUAL"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_domain(
#'   clientToken = "string",
#'   description = "string",
#'   domainExecutionRole = "string",
#'   identifier = "string",
#'   name = "string",
#'   serviceRole = "string",
#'   singleSignOn = list(
#'     idcInstanceArn = "string",
#'     type = "IAM_IDC"|"DISABLED",
#'     userAssignment = "AUTOMATIC"|"MANUAL"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_domain
#'
#' @aliases datazone_update_domain
datazone_update_domain <- function(clientToken = NULL, description = NULL, domainExecutionRole = NULL, identifier, name = NULL, serviceRole = NULL, singleSignOn = NULL) {
  op <- new_operation(
    name = "UpdateDomain",
    http_method = "PUT",
    http_path = "/v2/domains/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_domain_input(clientToken = clientToken, description = description, domainExecutionRole = domainExecutionRole, identifier = identifier, name = name, serviceRole = serviceRole, singleSignOn = singleSignOn)
  output <- .datazone$update_domain_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_domain <- datazone_update_domain

#' Updates the domain unit
#'
#' @description
#' Updates the domain unit.
#'
#' @usage
#' datazone_update_domain_unit(description, domainIdentifier, identifier,
#'   name)
#'
#' @param description The description of the domain unit that you want to update.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where you want to update a domain unit.
#' @param identifier &#91;required&#93; The ID of the domain unit that you want to update.
#' @param name The name of the domain unit that you want to update.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedBy = "string",
#'   name = "string",
#'   owners = list(
#'     list(
#'       group = list(
#'         groupId = "string"
#'       ),
#'       user = list(
#'         userId = "string"
#'       )
#'     )
#'   ),
#'   parentDomainUnitId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_domain_unit(
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_domain_unit
#'
#' @aliases datazone_update_domain_unit
datazone_update_domain_unit <- function(description = NULL, domainIdentifier, identifier, name = NULL) {
  op <- new_operation(
    name = "UpdateDomainUnit",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/domain-units/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_domain_unit_input(description = description, domainIdentifier = domainIdentifier, identifier = identifier, name = name)
  output <- .datazone$update_domain_unit_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_domain_unit <- datazone_update_domain_unit

#' Updates the specified environment in Amazon DataZone
#'
#' @description
#' Updates the specified environment in Amazon DataZone.
#'
#' @usage
#' datazone_update_environment(blueprintVersion, description,
#'   domainIdentifier, glossaryTerms, identifier, name, userParameters)
#'
#' @param blueprintVersion The blueprint version to which the environment should be updated. You
#' can only specify the following string for this parameter: `latest`.
#' @param description The description to be updated as part of the
#' [`update_environment`][datazone_update_environment] action.
#' @param domainIdentifier &#91;required&#93; The identifier of the domain in which the environment is to be updated.
#' @param glossaryTerms The glossary terms to be updated as part of the
#' [`update_environment`][datazone_update_environment] action.
#' @param identifier &#91;required&#93; The identifier of the environment that is to be updated.
#' @param name The name to be updated as part of the
#' [`update_environment`][datazone_update_environment] action.
#' @param userParameters The user parameters of the environment.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   domainId = "string",
#'   environmentActions = list(
#'     list(
#'       auth = "IAM"|"HTTPS",
#'       parameters = list(
#'         list(
#'           key = "string",
#'           value = "string"
#'         )
#'       ),
#'       type = "string"
#'     )
#'   ),
#'   environmentBlueprintId = "string",
#'   environmentConfigurationId = "string",
#'   environmentProfileId = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastDeployment = list(
#'     deploymentId = "string",
#'     deploymentStatus = "IN_PROGRESS"|"SUCCESSFUL"|"FAILED"|"PENDING_DEPLOYMENT",
#'     deploymentType = "CREATE"|"UPDATE"|"DELETE",
#'     failureReason = list(
#'       code = "string",
#'       message = "string"
#'     ),
#'     isDeploymentComplete = TRUE|FALSE,
#'     messages = list(
#'       "string"
#'     )
#'   ),
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   provisionedResources = list(
#'     list(
#'       name = "string",
#'       provider = "string",
#'       type = "string",
#'       value = "string"
#'     )
#'   ),
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   status = "ACTIVE"|"CREATING"|"UPDATING"|"DELETING"|"CREATE_FAILED"|"UPDATE_FAILED"|"DELETE_FAILED"|"VALIDATION_FAILED"|"SUSPENDED"|"DISABLED"|"EXPIRED"|"DELETED"|"INACCESSIBLE",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_environment(
#'   blueprintVersion = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   identifier = "string",
#'   name = "string",
#'   userParameters = list(
#'     list(
#'       name = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_environment
#'
#' @aliases datazone_update_environment
datazone_update_environment <- function(blueprintVersion = NULL, description = NULL, domainIdentifier, glossaryTerms = NULL, identifier, name = NULL, userParameters = NULL) {
  op <- new_operation(
    name = "UpdateEnvironment",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/environments/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_environment_input(blueprintVersion = blueprintVersion, description = description, domainIdentifier = domainIdentifier, glossaryTerms = glossaryTerms, identifier = identifier, name = name, userParameters = userParameters)
  output <- .datazone$update_environment_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_environment <- datazone_update_environment

#' Updates an environment action
#'
#' @description
#' Updates an environment action.
#'
#' @usage
#' datazone_update_environment_action(description, domainIdentifier,
#'   environmentIdentifier, identifier, name, parameters)
#'
#' @param description The description of the environment action.
#' @param domainIdentifier &#91;required&#93; The domain ID of the environment action.
#' @param environmentIdentifier &#91;required&#93; The environment ID of the environment action.
#' @param identifier &#91;required&#93; The ID of the environment action.
#' @param name The name of the environment action.
#' @param parameters The parameters of the environment action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   name = "string",
#'   parameters = list(
#'     awsConsoleLink = list(
#'       uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_environment_action(
#'   description = "string",
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string",
#'   name = "string",
#'   parameters = list(
#'     awsConsoleLink = list(
#'       uri = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_environment_action
#'
#' @aliases datazone_update_environment_action
datazone_update_environment_action <- function(description = NULL, domainIdentifier, environmentIdentifier, identifier, name = NULL, parameters = NULL) {
  op <- new_operation(
    name = "UpdateEnvironmentAction",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/actions/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_environment_action_input(description = description, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier, name = name, parameters = parameters)
  output <- .datazone$update_environment_action_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_environment_action <- datazone_update_environment_action

#' Updates an environment blueprint in Amazon DataZone
#'
#' @description
#' Updates an environment blueprint in Amazon DataZone.
#'
#' @usage
#' datazone_update_environment_blueprint(description, domainIdentifier,
#'   identifier, provisioningProperties, userParameters)
#'
#' @param description The description to be updated as part of the
#' [`update_environment_blueprint`][datazone_update_environment_blueprint]
#' action.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which an environment
#' blueprint is to be updated.
#' @param identifier &#91;required&#93; The identifier of the environment blueprint to be updated.
#' @param provisioningProperties The provisioning properties to be updated as part of the
#' [`update_environment_blueprint`][datazone_update_environment_blueprint]
#' action.
#' @param userParameters The user parameters to be updated as part of the
#' [`update_environment_blueprint`][datazone_update_environment_blueprint]
#' action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   deploymentProperties = list(
#'     endTimeoutMinutes = 123,
#'     startTimeoutMinutes = 123
#'   ),
#'   description = "string",
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   name = "string",
#'   provider = "string",
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_environment_blueprint(
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   provisioningProperties = list(
#'     cloudFormation = list(
#'       templateUrl = "string"
#'     )
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_environment_blueprint
#'
#' @aliases datazone_update_environment_blueprint
datazone_update_environment_blueprint <- function(description = NULL, domainIdentifier, identifier, provisioningProperties = NULL, userParameters = NULL) {
  op <- new_operation(
    name = "UpdateEnvironmentBlueprint",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/environment-blueprints/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_environment_blueprint_input(description = description, domainIdentifier = domainIdentifier, identifier = identifier, provisioningProperties = provisioningProperties, userParameters = userParameters)
  output <- .datazone$update_environment_blueprint_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_environment_blueprint <- datazone_update_environment_blueprint

#' Updates the specified environment profile in Amazon DataZone
#'
#' @description
#' Updates the specified environment profile in Amazon DataZone.
#'
#' @usage
#' datazone_update_environment_profile(awsAccountId, awsAccountRegion,
#'   description, domainIdentifier, identifier, name, userParameters)
#'
#' @param awsAccountId The Amazon Web Services account in which a specified environment profile
#' is to be udpated.
#' @param awsAccountRegion The Amazon Web Services Region in which a specified environment profile
#' is to be updated.
#' @param description The description to be updated as part of the
#' [`update_environment_profile`][datazone_update_environment_profile]
#' action.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which an environment
#' profile is to be updated.
#' @param identifier &#91;required&#93; The identifier of the environment profile that is to be updated.
#' @param name The name to be updated as part of the
#' [`update_environment_profile`][datazone_update_environment_profile]
#' action.
#' @param userParameters The user parameters to be updated as part of the
#' [`update_environment_profile`][datazone_update_environment_profile]
#' action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   environmentBlueprintId = "string",
#'   id = "string",
#'   name = "string",
#'   projectId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   userParameters = list(
#'     list(
#'       defaultValue = "string",
#'       description = "string",
#'       fieldType = "string",
#'       isEditable = TRUE|FALSE,
#'       isOptional = TRUE|FALSE,
#'       isUpdateSupported = TRUE|FALSE,
#'       keyName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_environment_profile(
#'   awsAccountId = "string",
#'   awsAccountRegion = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   name = "string",
#'   userParameters = list(
#'     list(
#'       name = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_environment_profile
#'
#' @aliases datazone_update_environment_profile
datazone_update_environment_profile <- function(awsAccountId = NULL, awsAccountRegion = NULL, description = NULL, domainIdentifier, identifier, name = NULL, userParameters = NULL) {
  op <- new_operation(
    name = "UpdateEnvironmentProfile",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/environment-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_environment_profile_input(awsAccountId = awsAccountId, awsAccountRegion = awsAccountRegion, description = description, domainIdentifier = domainIdentifier, identifier = identifier, name = name, userParameters = userParameters)
  output <- .datazone$update_environment_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_environment_profile <- datazone_update_environment_profile

#' Updates the business glossary in Amazon DataZone
#'
#' @description
#' Updates the business glossary in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   The glossary must exist in the given domain.
#' 
#' -   The caller must have the `datazone:UpdateGlossary` permission to
#'     update it.
#' 
#' -   When updating the name, the new name must be unique within the
#'     domain.
#' 
#' -   The glossary must not be deleted or in a terminal state.
#'
#' @usage
#' datazone_update_glossary(clientToken, description, domainIdentifier,
#'   identifier, name, status)
#'
#' @param clientToken A unique, case-sensitive identifier that is provided to ensure the
#' idempotency of the request.
#' @param description The description to be updated as part of the
#' [`update_glossary`][datazone_update_glossary] action.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a business
#' glossary is to be updated.
#' @param identifier &#91;required&#93; The identifier of the business glossary to be updated.
#' @param name The name to be updated as part of the
#' [`update_glossary`][datazone_update_glossary] action.
#' @param status The status to be updated as part of the
#' [`update_glossary`][datazone_update_glossary] action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   description = "string",
#'   domainId = "string",
#'   id = "string",
#'   name = "string",
#'   owningProjectId = "string",
#'   status = "DISABLED"|"ENABLED",
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_glossary(
#'   clientToken = "string",
#'   description = "string",
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   name = "string",
#'   status = "DISABLED"|"ENABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_glossary
#'
#' @aliases datazone_update_glossary
datazone_update_glossary <- function(clientToken = NULL, description = NULL, domainIdentifier, identifier, name = NULL, status = NULL) {
  op <- new_operation(
    name = "UpdateGlossary",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/glossaries/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_glossary_input(clientToken = clientToken, description = description, domainIdentifier = domainIdentifier, identifier = identifier, name = name, status = status)
  output <- .datazone$update_glossary_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_glossary <- datazone_update_glossary

#' Updates a business glossary term in Amazon DataZone
#'
#' @description
#' Updates a business glossary term in Amazon DataZone.
#' 
#' Prerequisites:
#' 
#' -   Glossary term must exist in the specified domain.
#' 
#' -   New name must not conflict with existing terms in the same glossary.
#' 
#' -   User must have permissions on the term.
#' 
#' -   The term must not be in DELETED status.
#'
#' @usage
#' datazone_update_glossary_term(domainIdentifier, glossaryIdentifier,
#'   identifier, longDescription, name, shortDescription, status,
#'   termRelations)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a business
#' glossary term is to be updated.
#' @param glossaryIdentifier The identifier of the business glossary in which a term is to be
#' updated.
#' @param identifier &#91;required&#93; The identifier of the business glossary term that is to be updated.
#' @param longDescription The long description to be updated as part of the
#' [`update_glossary_term`][datazone_update_glossary_term] action.
#' @param name The name to be updated as part of the
#' [`update_glossary_term`][datazone_update_glossary_term] action.
#' @param shortDescription The short description to be updated as part of the
#' [`update_glossary_term`][datazone_update_glossary_term] action.
#' @param status The status to be updated as part of the
#' [`update_glossary_term`][datazone_update_glossary_term] action.
#' @param termRelations The term relations to be updated as part of the
#' [`update_glossary_term`][datazone_update_glossary_term] action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   glossaryId = "string",
#'   id = "string",
#'   longDescription = "string",
#'   name = "string",
#'   shortDescription = "string",
#'   status = "ENABLED"|"DISABLED",
#'   termRelations = list(
#'     classifies = list(
#'       "string"
#'     ),
#'     isA = list(
#'       "string"
#'     )
#'   ),
#'   usageRestrictions = list(
#'     "ASSET_GOVERNED_TERMS"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_glossary_term(
#'   domainIdentifier = "string",
#'   glossaryIdentifier = "string",
#'   identifier = "string",
#'   longDescription = "string",
#'   name = "string",
#'   shortDescription = "string",
#'   status = "ENABLED"|"DISABLED",
#'   termRelations = list(
#'     classifies = list(
#'       "string"
#'     ),
#'     isA = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_glossary_term
#'
#' @aliases datazone_update_glossary_term
datazone_update_glossary_term <- function(domainIdentifier, glossaryIdentifier = NULL, identifier, longDescription = NULL, name = NULL, shortDescription = NULL, status = NULL, termRelations = NULL) {
  op <- new_operation(
    name = "UpdateGlossaryTerm",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/glossary-terms/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_glossary_term_input(domainIdentifier = domainIdentifier, glossaryIdentifier = glossaryIdentifier, identifier = identifier, longDescription = longDescription, name = name, shortDescription = shortDescription, status = status, termRelations = termRelations)
  output <- .datazone$update_glossary_term_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_glossary_term <- datazone_update_glossary_term

#' Updates the specified group profile in Amazon DataZone
#'
#' @description
#' Updates the specified group profile in Amazon DataZone.
#'
#' @usage
#' datazone_update_group_profile(domainIdentifier, groupIdentifier, status)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a group profile is
#' updated.
#' @param groupIdentifier &#91;required&#93; The identifier of the group profile that is updated.
#' @param status &#91;required&#93; The status of the group profile that is updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   domainId = "string",
#'   groupName = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_group_profile(
#'   domainIdentifier = "string",
#'   groupIdentifier = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_group_profile
#'
#' @aliases datazone_update_group_profile
datazone_update_group_profile <- function(domainIdentifier, groupIdentifier, status) {
  op <- new_operation(
    name = "UpdateGroupProfile",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/group-profiles/{groupIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_group_profile_input(domainIdentifier = domainIdentifier, groupIdentifier = groupIdentifier, status = status)
  output <- .datazone$update_group_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_group_profile <- datazone_update_group_profile

#' Updates the specified project in Amazon DataZone
#'
#' @description
#' Updates the specified project in Amazon DataZone.
#'
#' @usage
#' datazone_update_project(description, domainIdentifier, domainUnitId,
#'   environmentDeploymentDetails, glossaryTerms, identifier, name,
#'   projectProfileVersion, resourceTags, userParameters)
#'
#' @param description The description to be updated as part of the
#' [`update_project`][datazone_update_project] action.
#' @param domainIdentifier &#91;required&#93; The ID of the Amazon DataZone domain where a project is being updated.
#' @param domainUnitId The ID of the domain unit.
#' @param environmentDeploymentDetails The environment deployment details of the project.
#' @param glossaryTerms The glossary terms to be updated as part of the
#' [`update_project`][datazone_update_project] action.
#' @param identifier &#91;required&#93; The identifier of the project that is to be updated.
#' @param name The name to be updated as part of the
#' [`update_project`][datazone_update_project] action.
#' @param projectProfileVersion The project profile version to which the project should be updated. You
#' can only specify the following string for this parameter: `latest`.
#' @param resourceTags The resource tags of the project.
#' @param userParameters The user parameters of the project.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentDeploymentDetails = list(
#'     environmentFailureReasons = list(
#'       list(
#'         list(
#'           code = "string",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     overallDeploymentStatus = "PENDING_DEPLOYMENT"|"IN_PROGRESS"|"SUCCESSFUL"|"FAILED_VALIDATION"|"FAILED_DEPLOYMENT"
#'   ),
#'   failureReasons = list(
#'     list(
#'       code = "string",
#'       message = "string"
#'     )
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectProfileId = "string",
#'   projectStatus = "ACTIVE"|"DELETING"|"DELETE_FAILED"|"UPDATING"|"UPDATE_FAILED"|"MOVING",
#'   resourceTags = list(
#'     list(
#'       key = "string",
#'       source = "PROJECT"|"PROJECT_PROFILE",
#'       value = "string"
#'     )
#'   ),
#'   userParameters = list(
#'     list(
#'       environmentConfigurationName = "string",
#'       environmentId = "string",
#'       environmentParameters = list(
#'         list(
#'           name = "string",
#'           value = "string"
#'         )
#'       ),
#'       environmentResolvedAccount = list(
#'         awsAccountId = "string",
#'         regionName = "string",
#'         sourceAccountPoolId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_project(
#'   description = "string",
#'   domainIdentifier = "string",
#'   domainUnitId = "string",
#'   environmentDeploymentDetails = list(
#'     environmentFailureReasons = list(
#'       list(
#'         list(
#'           code = "string",
#'           message = "string"
#'         )
#'       )
#'     ),
#'     overallDeploymentStatus = "PENDING_DEPLOYMENT"|"IN_PROGRESS"|"SUCCESSFUL"|"FAILED_VALIDATION"|"FAILED_DEPLOYMENT"
#'   ),
#'   glossaryTerms = list(
#'     "string"
#'   ),
#'   identifier = "string",
#'   name = "string",
#'   projectProfileVersion = "string",
#'   resourceTags = list(
#'     "string"
#'   ),
#'   userParameters = list(
#'     list(
#'       environmentConfigurationName = "string",
#'       environmentId = "string",
#'       environmentParameters = list(
#'         list(
#'           name = "string",
#'           value = "string"
#'         )
#'       ),
#'       environmentResolvedAccount = list(
#'         awsAccountId = "string",
#'         regionName = "string",
#'         sourceAccountPoolId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_project
#'
#' @aliases datazone_update_project
datazone_update_project <- function(description = NULL, domainIdentifier, domainUnitId = NULL, environmentDeploymentDetails = NULL, glossaryTerms = NULL, identifier, name = NULL, projectProfileVersion = NULL, resourceTags = NULL, userParameters = NULL) {
  op <- new_operation(
    name = "UpdateProject",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/projects/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_project_input(description = description, domainIdentifier = domainIdentifier, domainUnitId = domainUnitId, environmentDeploymentDetails = environmentDeploymentDetails, glossaryTerms = glossaryTerms, identifier = identifier, name = name, projectProfileVersion = projectProfileVersion, resourceTags = resourceTags, userParameters = userParameters)
  output <- .datazone$update_project_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_project <- datazone_update_project

#' Updates a project profile
#'
#' @description
#' Updates a project profile.
#'
#' @usage
#' datazone_update_project_profile(allowCustomProjectResourceTags,
#'   description, domainIdentifier, domainUnitIdentifier,
#'   environmentConfigurations, identifier, name, projectResourceTags,
#'   projectResourceTagsDescription, status)
#'
#' @param allowCustomProjectResourceTags Specifies whether custom project resource tags are supported.
#' @param description The description of a project profile.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where a project profile is to be updated.
#' @param domainUnitIdentifier The ID of the domain unit where a project profile is to be updated.
#' @param environmentConfigurations The environment configurations of a project profile.
#' @param identifier &#91;required&#93; The ID of a project profile that is to be updated.
#' @param name The name of a project profile.
#' @param projectResourceTags The resource tags of the project profile.
#' @param projectResourceTagsDescription Field viewable through the UI that provides a project user with the
#' allowed resource tag specifications.
#' @param status The status of a project profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   allowCustomProjectResourceTags = TRUE|FALSE,
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   domainId = "string",
#'   domainUnitId = "string",
#'   environmentConfigurations = list(
#'     list(
#'       accountPools = list(
#'         "string"
#'       ),
#'       awsAccount = list(
#'         awsAccountId = "string",
#'         awsAccountIdPath = "string"
#'       ),
#'       awsRegion = list(
#'         regionName = "string",
#'         regionNamePath = "string"
#'       ),
#'       configurationParameters = list(
#'         parameterOverrides = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         resolvedParameters = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         ssmPath = "string"
#'       ),
#'       deploymentMode = "ON_CREATE"|"ON_DEMAND",
#'       deploymentOrder = 123,
#'       description = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   id = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   projectResourceTags = list(
#'     list(
#'       isValueEditable = TRUE|FALSE,
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   projectResourceTagsDescription = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_project_profile(
#'   allowCustomProjectResourceTags = TRUE|FALSE,
#'   description = "string",
#'   domainIdentifier = "string",
#'   domainUnitIdentifier = "string",
#'   environmentConfigurations = list(
#'     list(
#'       accountPools = list(
#'         "string"
#'       ),
#'       awsAccount = list(
#'         awsAccountId = "string",
#'         awsAccountIdPath = "string"
#'       ),
#'       awsRegion = list(
#'         regionName = "string",
#'         regionNamePath = "string"
#'       ),
#'       configurationParameters = list(
#'         parameterOverrides = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         resolvedParameters = list(
#'           list(
#'             isEditable = TRUE|FALSE,
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         ssmPath = "string"
#'       ),
#'       deploymentMode = "ON_CREATE"|"ON_DEMAND",
#'       deploymentOrder = 123,
#'       description = "string",
#'       environmentBlueprintId = "string",
#'       id = "string",
#'       name = "string"
#'     )
#'   ),
#'   identifier = "string",
#'   name = "string",
#'   projectResourceTags = list(
#'     list(
#'       isValueEditable = TRUE|FALSE,
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   projectResourceTagsDescription = "string",
#'   status = "ENABLED"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_project_profile
#'
#' @aliases datazone_update_project_profile
datazone_update_project_profile <- function(allowCustomProjectResourceTags = NULL, description = NULL, domainIdentifier, domainUnitIdentifier = NULL, environmentConfigurations = NULL, identifier, name = NULL, projectResourceTags = NULL, projectResourceTagsDescription = NULL, status = NULL) {
  op <- new_operation(
    name = "UpdateProjectProfile",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/project-profiles/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_project_profile_input(allowCustomProjectResourceTags = allowCustomProjectResourceTags, description = description, domainIdentifier = domainIdentifier, domainUnitIdentifier = domainUnitIdentifier, environmentConfigurations = environmentConfigurations, identifier = identifier, name = name, projectResourceTags = projectResourceTags, projectResourceTagsDescription = projectResourceTagsDescription, status = status)
  output <- .datazone$update_project_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_project_profile <- datazone_update_project_profile

#' Updates the owner of the root domain unit
#'
#' @description
#' Updates the owner of the root domain unit.
#'
#' @usage
#' datazone_update_root_domain_unit_owner(clientToken, currentOwner,
#'   domainIdentifier, newOwner)
#'
#' @param clientToken A unique, case-sensitive identifier to ensure idempotency of the
#' request. This field is automatically populated if not provided.
#' @param currentOwner &#91;required&#93; The current owner of the root domain unit.
#' @param domainIdentifier &#91;required&#93; The ID of the domain where the root domain unit owner is to be updated.
#' @param newOwner &#91;required&#93; The new owner of the root domain unit.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_root_domain_unit_owner(
#'   clientToken = "string",
#'   currentOwner = "string",
#'   domainIdentifier = "string",
#'   newOwner = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_root_domain_unit_owner
#'
#' @aliases datazone_update_root_domain_unit_owner
datazone_update_root_domain_unit_owner <- function(clientToken = NULL, currentOwner, domainIdentifier, newOwner) {
  op <- new_operation(
    name = "UpdateRootDomainUnitOwner",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/root-domain-unit-owner",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_root_domain_unit_owner_input(clientToken = clientToken, currentOwner = currentOwner, domainIdentifier = domainIdentifier, newOwner = newOwner)
  output <- .datazone$update_root_domain_unit_owner_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_root_domain_unit_owner <- datazone_update_root_domain_unit_owner

#' Updates a rule
#'
#' @description
#' Updates a rule. In Amazon DataZone, a rule is a formal agreement that
#' enforces specific requirements across user workflows (e.g., publishing
#' assets to the catalog, requesting subscriptions, creating projects)
#' within the Amazon DataZone data portal. These rules help maintain
#' consistency, ensure compliance, and uphold governance standards in data
#' management processes. For instance, a metadata enforcement rule can
#' specify the required information for creating a subscription request or
#' publishing a data asset to the catalog, ensuring alignment with
#' organizational standards.
#'
#' @usage
#' datazone_update_rule(description, detail, domainIdentifier, identifier,
#'   includeChildDomainUnits, name, scope)
#'
#' @param description The description of the rule.
#' @param detail The detail of the rule.
#' @param domainIdentifier &#91;required&#93; The ID of the domain in which a rule is to be updated.
#' @param identifier &#91;required&#93; The ID of the rule that is to be updated
#' @param includeChildDomainUnits Specifies whether to update this rule in the child domain units.
#' @param name The name of the rule.
#' @param scope The scrope of the rule.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   action = "CREATE_LISTING_CHANGE_SET"|"CREATE_SUBSCRIPTION_REQUEST",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   description = "string",
#'   detail = list(
#'     glossaryTermEnforcementDetail = list(
#'       requiredGlossaryTermIds = list(
#'         "string"
#'       )
#'     ),
#'     metadataFormEnforcementDetail = list(
#'       requiredMetadataForms = list(
#'         list(
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   identifier = "string",
#'   lastUpdatedBy = "string",
#'   name = "string",
#'   revision = "string",
#'   ruleType = "METADATA_FORM_ENFORCEMENT"|"GLOSSARY_TERM_ENFORCEMENT",
#'   scope = list(
#'     assetType = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificAssetTypes = list(
#'         "string"
#'       )
#'     ),
#'     dataProduct = TRUE|FALSE,
#'     project = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificProjects = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   target = list(
#'     domainUnitTarget = list(
#'       domainUnitId = "string",
#'       includeChildDomainUnits = TRUE|FALSE
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_rule(
#'   description = "string",
#'   detail = list(
#'     glossaryTermEnforcementDetail = list(
#'       requiredGlossaryTermIds = list(
#'         "string"
#'       )
#'     ),
#'     metadataFormEnforcementDetail = list(
#'       requiredMetadataForms = list(
#'         list(
#'           typeIdentifier = "string",
#'           typeRevision = "string"
#'         )
#'       )
#'     )
#'   ),
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   includeChildDomainUnits = TRUE|FALSE,
#'   name = "string",
#'   scope = list(
#'     assetType = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificAssetTypes = list(
#'         "string"
#'       )
#'     ),
#'     dataProduct = TRUE|FALSE,
#'     project = list(
#'       selectionMode = "ALL"|"SPECIFIC",
#'       specificProjects = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_rule
#'
#' @aliases datazone_update_rule
datazone_update_rule <- function(description = NULL, detail = NULL, domainIdentifier, identifier, includeChildDomainUnits = NULL, name = NULL, scope = NULL) {
  op <- new_operation(
    name = "UpdateRule",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/rules/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_rule_input(description = description, detail = detail, domainIdentifier = domainIdentifier, identifier = identifier, includeChildDomainUnits = includeChildDomainUnits, name = name, scope = scope)
  output <- .datazone$update_rule_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_rule <- datazone_update_rule

#' Updates the status of the specified subscription grant status in Amazon
#' DataZone
#'
#' @description
#' Updates the status of the specified subscription grant status in Amazon
#' DataZone.
#'
#' @usage
#' datazone_update_subscription_grant_status(assetIdentifier,
#'   domainIdentifier, failureCause, identifier, status, targetName)
#'
#' @param assetIdentifier &#91;required&#93; The identifier of the asset the subscription grant status of which is to
#' be updated.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a subscription
#' grant status is to be updated.
#' @param failureCause Specifies the error message that is returned if the operation cannot be
#' successfully completed.
#' @param identifier &#91;required&#93; The identifier of the subscription grant the status of which is to be
#' updated.
#' @param status &#91;required&#93; The status to be updated as part of the
#' [`update_subscription_grant_status`][datazone_update_subscription_grant_status]
#' action.
#' @param targetName The target name to be updated as part of the
#' [`update_subscription_grant_status`][datazone_update_subscription_grant_status]
#' action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   assets = list(
#'     list(
#'       assetId = "string",
#'       assetRevision = "string",
#'       assetScope = list(
#'         assetId = "string",
#'         errorMessage = "string",
#'         filterIds = list(
#'           "string"
#'         ),
#'         status = "string"
#'       ),
#'       failureCause = list(
#'         message = "string"
#'       ),
#'       failureTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       grantedTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       permissions = list(
#'         s3 = list(
#'           "READ"|"WRITE"
#'         )
#'       ),
#'       status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'       targetName = "string"
#'     )
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   grantedEntity = list(
#'     listing = list(
#'       id = "string",
#'       revision = "string"
#'     )
#'   ),
#'   id = "string",
#'   status = "PENDING"|"IN_PROGRESS"|"GRANT_FAILED"|"REVOKE_FAILED"|"GRANT_AND_REVOKE_FAILED"|"COMPLETED"|"INACCESSIBLE",
#'   subscriptionId = "string",
#'   subscriptionTargetId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subscription_grant_status(
#'   assetIdentifier = "string",
#'   domainIdentifier = "string",
#'   failureCause = list(
#'     message = "string"
#'   ),
#'   identifier = "string",
#'   status = "GRANT_PENDING"|"REVOKE_PENDING"|"GRANT_IN_PROGRESS"|"REVOKE_IN_PROGRESS"|"GRANTED"|"REVOKED"|"GRANT_FAILED"|"REVOKE_FAILED",
#'   targetName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_subscription_grant_status
#'
#' @aliases datazone_update_subscription_grant_status
datazone_update_subscription_grant_status <- function(assetIdentifier, domainIdentifier, failureCause = NULL, identifier, status, targetName = NULL) {
  op <- new_operation(
    name = "UpdateSubscriptionGrantStatus",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/subscription-grants/{identifier}/status/{assetIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_subscription_grant_status_input(assetIdentifier = assetIdentifier, domainIdentifier = domainIdentifier, failureCause = failureCause, identifier = identifier, status = status, targetName = targetName)
  output <- .datazone$update_subscription_grant_status_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_subscription_grant_status <- datazone_update_subscription_grant_status

#' Updates a specified subscription request in Amazon DataZone
#'
#' @description
#' Updates a specified subscription request in Amazon DataZone.
#'
#' @usage
#' datazone_update_subscription_request(domainIdentifier, identifier,
#'   requestReason)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a subscription
#' request is to be updated.
#' @param identifier &#91;required&#93; The identifier of the subscription request that is to be updated.
#' @param requestReason &#91;required&#93; The reason for the
#' [`update_subscription_request`][datazone_update_subscription_request]
#' action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   decisionComment = "string",
#'   domainId = "string",
#'   existingSubscriptionId = "string",
#'   id = "string",
#'   metadataForms = list(
#'     list(
#'       content = "string",
#'       formName = "string",
#'       typeName = "string",
#'       typeRevision = "string"
#'     )
#'   ),
#'   requestReason = "string",
#'   reviewerId = "string",
#'   status = "PENDING"|"ACCEPTED"|"REJECTED",
#'   subscribedListings = list(
#'     list(
#'       description = "string",
#'       id = "string",
#'       item = list(
#'         assetListing = list(
#'           assetScope = list(
#'             assetId = "string",
#'             errorMessage = "string",
#'             filterIds = list(
#'               "string"
#'             ),
#'             status = "string"
#'           ),
#'           entityId = "string",
#'           entityRevision = "string",
#'           entityType = "string",
#'           forms = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           permissions = list(
#'             s3 = list(
#'               "READ"|"WRITE"
#'             )
#'           )
#'         ),
#'         productListing = list(
#'           assetListings = list(
#'             list(
#'               entityId = "string",
#'               entityRevision = "string",
#'               entityType = "string"
#'             )
#'           ),
#'           description = "string",
#'           entityId = "string",
#'           entityRevision = "string",
#'           glossaryTerms = list(
#'             list(
#'               name = "string",
#'               shortDescription = "string"
#'             )
#'           ),
#'           name = "string"
#'         )
#'       ),
#'       name = "string",
#'       ownerProjectId = "string",
#'       ownerProjectName = "string",
#'       revision = "string"
#'     )
#'   ),
#'   subscribedPrincipals = list(
#'     list(
#'       group = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       project = list(
#'         id = "string",
#'         name = "string"
#'       ),
#'       user = list(
#'         details = list(
#'           iam = list(
#'             arn = "string",
#'             principalId = "string"
#'           ),
#'           sso = list(
#'             firstName = "string",
#'             lastName = "string",
#'             username = "string"
#'           )
#'         ),
#'         id = "string"
#'       )
#'     )
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subscription_request(
#'   domainIdentifier = "string",
#'   identifier = "string",
#'   requestReason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_subscription_request
#'
#' @aliases datazone_update_subscription_request
datazone_update_subscription_request <- function(domainIdentifier, identifier, requestReason) {
  op <- new_operation(
    name = "UpdateSubscriptionRequest",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/subscription-requests/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_subscription_request_input(domainIdentifier = domainIdentifier, identifier = identifier, requestReason = requestReason)
  output <- .datazone$update_subscription_request_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_subscription_request <- datazone_update_subscription_request

#' Updates the specified subscription target in Amazon DataZone
#'
#' @description
#' Updates the specified subscription target in Amazon DataZone.
#'
#' @usage
#' datazone_update_subscription_target(applicableAssetTypes,
#'   authorizedPrincipals, domainIdentifier, environmentIdentifier,
#'   identifier, manageAccessRole, name, provider, subscriptionTargetConfig)
#'
#' @param applicableAssetTypes The applicable asset types to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#' @param authorizedPrincipals The authorized principals to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a subscription
#' target is to be updated.
#' @param environmentIdentifier &#91;required&#93; The identifier of the environment in which a subscription target is to
#' be updated.
#' @param identifier &#91;required&#93; Identifier of the subscription target that is to be updated.
#' @param manageAccessRole The manage access role to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#' @param name The name to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#' @param provider The provider to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#' @param subscriptionTargetConfig The configuration to be updated as part of the
#' [`update_subscription_target`][datazone_update_subscription_target]
#' action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicableAssetTypes = list(
#'     "string"
#'   ),
#'   authorizedPrincipals = list(
#'     "string"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBy = "string",
#'   domainId = "string",
#'   environmentId = "string",
#'   id = "string",
#'   manageAccessRole = "string",
#'   name = "string",
#'   projectId = "string",
#'   provider = "string",
#'   subscriptionTargetConfig = list(
#'     list(
#'       content = "string",
#'       formName = "string"
#'     )
#'   ),
#'   type = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subscription_target(
#'   applicableAssetTypes = list(
#'     "string"
#'   ),
#'   authorizedPrincipals = list(
#'     "string"
#'   ),
#'   domainIdentifier = "string",
#'   environmentIdentifier = "string",
#'   identifier = "string",
#'   manageAccessRole = "string",
#'   name = "string",
#'   provider = "string",
#'   subscriptionTargetConfig = list(
#'     list(
#'       content = "string",
#'       formName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_subscription_target
#'
#' @aliases datazone_update_subscription_target
datazone_update_subscription_target <- function(applicableAssetTypes = NULL, authorizedPrincipals = NULL, domainIdentifier, environmentIdentifier, identifier, manageAccessRole = NULL, name = NULL, provider = NULL, subscriptionTargetConfig = NULL) {
  op <- new_operation(
    name = "UpdateSubscriptionTarget",
    http_method = "PATCH",
    http_path = "/v2/domains/{domainIdentifier}/environments/{environmentIdentifier}/subscription-targets/{identifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_subscription_target_input(applicableAssetTypes = applicableAssetTypes, authorizedPrincipals = authorizedPrincipals, domainIdentifier = domainIdentifier, environmentIdentifier = environmentIdentifier, identifier = identifier, manageAccessRole = manageAccessRole, name = name, provider = provider, subscriptionTargetConfig = subscriptionTargetConfig)
  output <- .datazone$update_subscription_target_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_subscription_target <- datazone_update_subscription_target

#' Updates the specified user profile in Amazon DataZone
#'
#' @description
#' Updates the specified user profile in Amazon DataZone.
#'
#' @usage
#' datazone_update_user_profile(domainIdentifier, status, type,
#'   userIdentifier)
#'
#' @param domainIdentifier &#91;required&#93; The identifier of the Amazon DataZone domain in which a user profile is
#' updated.
#' @param status &#91;required&#93; The status of the user profile that are to be updated.
#' @param type The type of the user profile that are to be updated.
#' @param userIdentifier &#91;required&#93; The identifier of the user whose user profile is to be updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   details = list(
#'     iam = list(
#'       arn = "string",
#'       principalId = "string"
#'     ),
#'     sso = list(
#'       firstName = "string",
#'       lastName = "string",
#'       username = "string"
#'     )
#'   ),
#'   domainId = "string",
#'   id = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"|"ACTIVATED"|"DEACTIVATED",
#'   type = "IAM"|"SSO"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_user_profile(
#'   domainIdentifier = "string",
#'   status = "ASSIGNED"|"NOT_ASSIGNED"|"ACTIVATED"|"DEACTIVATED",
#'   type = "IAM"|"SSO",
#'   userIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname datazone_update_user_profile
#'
#' @aliases datazone_update_user_profile
datazone_update_user_profile <- function(domainIdentifier, status, type = NULL, userIdentifier) {
  op <- new_operation(
    name = "UpdateUserProfile",
    http_method = "PUT",
    http_path = "/v2/domains/{domainIdentifier}/user-profiles/{userIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .datazone$update_user_profile_input(domainIdentifier = domainIdentifier, status = status, type = type, userIdentifier = userIdentifier)
  output <- .datazone$update_user_profile_output()
  config <- get_config()
  svc <- .datazone$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.datazone$operations$update_user_profile <- datazone_update_user_profile

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include mturk_service.R
NULL

#' The AcceptQualificationRequest operation approves a Worker's request for
#' a Qualification
#'
#' @description
#' The [`accept_qualification_request`][mturk_accept_qualification_request]
#' operation approves a Worker's request for a Qualification.
#' 
#' Only the owner of the Qualification type can grant a Qualification
#' request for that type.
#' 
#' A successful request for the
#' [`accept_qualification_request`][mturk_accept_qualification_request]
#' operation returns with no errors and an empty body.
#'
#' @usage
#' mturk_accept_qualification_request(QualificationRequestId, IntegerValue)
#'
#' @param QualificationRequestId &#91;required&#93; The ID of the Qualification request, as returned by the
#' `GetQualificationRequests` operation.
#' @param IntegerValue The value of the Qualification. You can omit this value if you are using
#' the presence or absence of the Qualification as the basis for a HIT
#' requirement.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$accept_qualification_request(
#'   QualificationRequestId = "string",
#'   IntegerValue = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_accept_qualification_request
#'
#' @aliases mturk_accept_qualification_request
mturk_accept_qualification_request <- function(QualificationRequestId, IntegerValue = NULL) {
  op <- new_operation(
    name = "AcceptQualificationRequest",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$accept_qualification_request_input(QualificationRequestId = QualificationRequestId, IntegerValue = IntegerValue)
  output <- .mturk$accept_qualification_request_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$accept_qualification_request <- mturk_accept_qualification_request

#' The ApproveAssignment operation approves the results of a completed
#' assignment
#'
#' @description
#' The [`approve_assignment`][mturk_approve_assignment] operation approves
#' the results of a completed assignment.
#' 
#' Approving an assignment initiates two payments from the Requester's
#' Amazon.com account
#' 
#' -   The Worker who submitted the results is paid the reward specified in
#'     the HIT.
#' 
#' -   Amazon Mechanical Turk fees are debited.
#' 
#' If the Requester's account does not have adequate funds for these
#' payments, the call to ApproveAssignment returns an exception, and the
#' approval is not processed. You can include an optional feedback message
#' with the approval, which the Worker can see in the Status section of the
#' web site.
#' 
#' You can also call this operation for assignments that were previous
#' rejected and approve them by explicitly overriding the previous
#' rejection. This only works on rejected assignments that were submitted
#' within the previous 30 days and only if the assignment's related HIT has
#' not been deleted.
#'
#' @usage
#' mturk_approve_assignment(AssignmentId, RequesterFeedback,
#'   OverrideRejection)
#'
#' @param AssignmentId &#91;required&#93; The ID of the assignment. The assignment must correspond to a HIT
#' created by the Requester.
#' @param RequesterFeedback A message for the Worker, which the Worker can see in the Status section
#' of the web site.
#' @param OverrideRejection A flag indicating that an assignment should be approved even if it was
#' previously rejected. Defaults to `False`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$approve_assignment(
#'   AssignmentId = "string",
#'   RequesterFeedback = "string",
#'   OverrideRejection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_approve_assignment
#'
#' @aliases mturk_approve_assignment
mturk_approve_assignment <- function(AssignmentId, RequesterFeedback = NULL, OverrideRejection = NULL) {
  op <- new_operation(
    name = "ApproveAssignment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$approve_assignment_input(AssignmentId = AssignmentId, RequesterFeedback = RequesterFeedback, OverrideRejection = OverrideRejection)
  output <- .mturk$approve_assignment_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$approve_assignment <- mturk_approve_assignment

#' The AssociateQualificationWithWorker operation gives a Worker a
#' Qualification
#'
#' @description
#' The
#' [`associate_qualification_with_worker`][mturk_associate_qualification_with_worker]
#' operation gives a Worker a Qualification.
#' [`associate_qualification_with_worker`][mturk_associate_qualification_with_worker]
#' does not require that the Worker submit a Qualification request. It
#' gives the Qualification directly to the Worker.
#' 
#' You can only assign a Qualification of a Qualification type that you
#' created (using the
#' [`create_qualification_type`][mturk_create_qualification_type]
#' operation).
#' 
#' Note:
#' [`associate_qualification_with_worker`][mturk_associate_qualification_with_worker]
#' does not affect any pending Qualification requests for the Qualification
#' by the Worker. If you assign a Qualification to a Worker, then later
#' grant a Qualification request made by the Worker, the granting of the
#' request may modify the Qualification score. To resolve a pending
#' Qualification request without affecting the Qualification the Worker
#' already has, reject the request with the
#' [`reject_qualification_request`][mturk_reject_qualification_request]
#' operation.
#'
#' @usage
#' mturk_associate_qualification_with_worker(QualificationTypeId, WorkerId,
#'   IntegerValue, SendNotification)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the Qualification type to use for the assigned Qualification.
#' @param WorkerId &#91;required&#93; The ID of the Worker to whom the Qualification is being assigned. Worker
#' IDs are included with submitted HIT assignments and Qualification
#' requests.
#' @param IntegerValue The value of the Qualification to assign.
#' @param SendNotification Specifies whether to send a notification email message to the Worker
#' saying that the qualification was assigned to the Worker. Note: this is
#' true by default.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$associate_qualification_with_worker(
#'   QualificationTypeId = "string",
#'   WorkerId = "string",
#'   IntegerValue = 123,
#'   SendNotification = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_associate_qualification_with_worker
#'
#' @aliases mturk_associate_qualification_with_worker
mturk_associate_qualification_with_worker <- function(QualificationTypeId, WorkerId, IntegerValue = NULL, SendNotification = NULL) {
  op <- new_operation(
    name = "AssociateQualificationWithWorker",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$associate_qualification_with_worker_input(QualificationTypeId = QualificationTypeId, WorkerId = WorkerId, IntegerValue = IntegerValue, SendNotification = SendNotification)
  output <- .mturk$associate_qualification_with_worker_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$associate_qualification_with_worker <- mturk_associate_qualification_with_worker

#' The CreateAdditionalAssignmentsForHIT operation increases the maximum
#' number of assignments of an existing HIT
#'
#' @description
#' The
#' [`create_additional_assignments_for_hit`][mturk_create_additional_assignments_for_hit]
#' operation increases the maximum number of assignments of an existing
#' HIT.
#' 
#' To extend the maximum number of assignments, specify the number of
#' additional assignments.
#' 
#' -   HITs created with fewer than 10 assignments cannot be extended to
#'     have 10 or more assignments. Attempting to add assignments in a way
#'     that brings the total number of assignments for a HIT from fewer
#'     than 10 assignments to 10 or more assignments will result in an
#'     `AWS.MechanicalTurk.InvalidMaximumAssignmentsIncrease` exception.
#' 
#' -   HITs that were created before July 22, 2015 cannot be extended.
#'     Attempting to extend HITs that were created before July 22, 2015
#'     will result in an `AWS.MechanicalTurk.HITTooOldForExtension`
#'     exception.
#'
#' @usage
#' mturk_create_additional_assignments_for_hit(HITId,
#'   NumberOfAdditionalAssignments, UniqueRequestToken)
#'
#' @param HITId &#91;required&#93; The ID of the HIT to extend.
#' @param NumberOfAdditionalAssignments &#91;required&#93; The number of additional assignments to request for this HIT.
#' @param UniqueRequestToken A unique identifier for this request, which allows you to retry the call
#' on error without extending the HIT multiple times. This is useful in
#' cases such as network timeouts where it is unclear whether or not the
#' call succeeded on the server. If the extend HIT already exists in the
#' system from a previous call using the same `UniqueRequestToken`,
#' subsequent calls will return an error with a message containing the
#' request ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_additional_assignments_for_hit(
#'   HITId = "string",
#'   NumberOfAdditionalAssignments = 123,
#'   UniqueRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_additional_assignments_for_hit
#'
#' @aliases mturk_create_additional_assignments_for_hit
mturk_create_additional_assignments_for_hit <- function(HITId, NumberOfAdditionalAssignments, UniqueRequestToken = NULL) {
  op <- new_operation(
    name = "CreateAdditionalAssignmentsForHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_additional_assignments_for_hit_input(HITId = HITId, NumberOfAdditionalAssignments = NumberOfAdditionalAssignments, UniqueRequestToken = UniqueRequestToken)
  output <- .mturk$create_additional_assignments_for_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_additional_assignments_for_hit <- mturk_create_additional_assignments_for_hit

#' The CreateHIT operation creates a new Human Intelligence Task (HIT)
#'
#' @description
#' The [`create_hit`][mturk_create_hit] operation creates a new Human
#' Intelligence Task (HIT). The new HIT is made available for Workers to
#' find and accept on the Amazon Mechanical Turk website.
#' 
#' This operation allows you to specify a new HIT by passing in values for
#' the properties of the HIT, such as its title, reward amount and number
#' of assignments. When you pass these values to
#' [`create_hit`][mturk_create_hit], a new HIT is created for you, with a
#' new `HITTypeID`. The HITTypeID can be used to create additional HITs in
#' the future without needing to specify common parameters such as the
#' title, description and reward amount each time.
#' 
#' An alternative way to create HITs is to first generate a HITTypeID using
#' the [`create_hit_type`][mturk_create_hit_type] operation and then call
#' the [`create_hit_with_hit_type`][mturk_create_hit_with_hit_type]
#' operation. This is the recommended best practice for Requesters who are
#' creating large numbers of HITs.
#' 
#' CreateHIT also supports several ways to provide question data: by
#' providing a value for the `Question` parameter that fully specifies the
#' contents of the HIT, or by providing a `HitLayoutId` and associated
#' `HitLayoutParameters`.
#' 
#' If a HIT is created with 10 or more maximum assignments, there is an
#' additional fee. For more information, see [Amazon Mechanical Turk
#' Pricing](https://requester.mturk.com/pricing).
#'
#' @usage
#' mturk_create_hit(MaxAssignments, AutoApprovalDelayInSeconds,
#'   LifetimeInSeconds, AssignmentDurationInSeconds, Reward, Title, Keywords,
#'   Description, Question, RequesterAnnotation, QualificationRequirements,
#'   UniqueRequestToken, AssignmentReviewPolicy, HITReviewPolicy,
#'   HITLayoutId, HITLayoutParameters)
#'
#' @param MaxAssignments The number of times the HIT can be accepted and completed before the HIT
#' becomes unavailable.
#' @param AutoApprovalDelayInSeconds The number of seconds after an assignment for the HIT has been
#' submitted, after which the assignment is considered Approved
#' automatically unless the Requester explicitly rejects it.
#' @param LifetimeInSeconds &#91;required&#93; An amount of time, in seconds, after which the HIT is no longer
#' available for users to accept. After the lifetime of the HIT elapses,
#' the HIT no longer appears in HIT searches, even if not all of the
#' assignments for the HIT have been accepted.
#' @param AssignmentDurationInSeconds &#91;required&#93; The amount of time, in seconds, that a Worker has to complete the HIT
#' after accepting it. If a Worker does not complete the assignment within
#' the specified duration, the assignment is considered abandoned. If the
#' HIT is still active (that is, its lifetime has not elapsed), the
#' assignment becomes available for other users to find and accept.
#' @param Reward &#91;required&#93; The amount of money the Requester will pay a Worker for successfully
#' completing the HIT.
#' @param Title &#91;required&#93; The title of the HIT. A title should be short and descriptive about the
#' kind of task the HIT contains. On the Amazon Mechanical Turk web site,
#' the HIT title appears in search results, and everywhere the HIT is
#' mentioned.
#' @param Keywords One or more words or phrases that describe the HIT, separated by commas.
#' These words are used in searches to find HITs.
#' @param Description &#91;required&#93; A general description of the HIT. A description includes detailed
#' information about the kind of task the HIT contains. On the Amazon
#' Mechanical Turk web site, the HIT description appears in the expanded
#' view of search results, and in the HIT and assignment screens. A good
#' description gives the user enough information to evaluate the HIT before
#' accepting it.
#' @param Question The data the person completing the HIT uses to produce the results.
#' 
#' Constraints: Must be a QuestionForm data structure, an ExternalQuestion
#' data structure, or an HTMLQuestion data structure. The XML question data
#' must not be larger than 64 kilobytes (65,535 bytes) in size, including
#' whitespace.
#' 
#' Either a Question parameter or a HITLayoutId parameter must be provided.
#' @param RequesterAnnotation An arbitrary data field. The RequesterAnnotation parameter lets your
#' application attach arbitrary data to the HIT for tracking purposes. For
#' example, this parameter could be an identifier internal to the
#' Requester's application that corresponds with the HIT.
#' 
#' The RequesterAnnotation parameter for a HIT is only visible to the
#' Requester who created the HIT. It is not shown to the Worker, or any
#' other Requester.
#' 
#' The RequesterAnnotation parameter may be different for each HIT you
#' submit. It does not affect how your HITs are grouped.
#' @param QualificationRequirements Conditions that a Worker's Qualifications must meet in order to accept
#' the HIT. A HIT can have between zero and ten Qualification requirements.
#' All requirements must be met in order for a Worker to accept the HIT.
#' Additionally, other actions can be restricted using the `ActionsGuarded`
#' field on each `QualificationRequirement` structure.
#' @param UniqueRequestToken A unique identifier for this request which allows you to retry the call
#' on error without creating duplicate HITs. This is useful in cases such
#' as network timeouts where it is unclear whether or not the call
#' succeeded on the server. If the HIT already exists in the system from a
#' previous call using the same UniqueRequestToken, subsequent calls will
#' return a AWS.MechanicalTurk.HitAlreadyExists error with a message
#' containing the HITId.
#' 
#' Note: It is your responsibility to ensure uniqueness of the token. The
#' unique token expires after 24 hours. Subsequent calls using the same
#' UniqueRequestToken made after the 24 hour limit could create duplicate
#' HITs.
#' @param AssignmentReviewPolicy The Assignment-level Review Policy applies to the assignments under the
#' HIT. You can specify for Mechanical Turk to take various actions based
#' on the policy.
#' @param HITReviewPolicy The HIT-level Review Policy applies to the HIT. You can specify for
#' Mechanical Turk to take various actions based on the policy.
#' @param HITLayoutId The HITLayoutId allows you to use a pre-existing HIT design with
#' placeholder values and create an additional HIT by providing those
#' values as HITLayoutParameters.
#' 
#' Constraints: Either a Question parameter or a HITLayoutId parameter must
#' be provided.
#' @param HITLayoutParameters If the HITLayoutId is provided, any placeholder values must be filled in
#' with values using the HITLayoutParameter structure. For more
#' information, see HITLayout.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   HIT = list(
#'     HITId = "string",
#'     HITTypeId = "string",
#'     HITGroupId = "string",
#'     HITLayoutId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Title = "string",
#'     Description = "string",
#'     Question = "string",
#'     Keywords = "string",
#'     HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'     MaxAssignments = 123,
#'     Reward = "string",
#'     AutoApprovalDelayInSeconds = 123,
#'     Expiration = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AssignmentDurationInSeconds = 123,
#'     RequesterAnnotation = "string",
#'     QualificationRequirements = list(
#'       list(
#'         QualificationTypeId = "string",
#'         Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'         IntegerValues = list(
#'           123
#'         ),
#'         LocaleValues = list(
#'           list(
#'             Country = "string",
#'             Subdivision = "string"
#'           )
#'         ),
#'         RequiredToPreview = TRUE|FALSE,
#'         ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'       )
#'     ),
#'     HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'     NumberOfAssignmentsPending = 123,
#'     NumberOfAssignmentsAvailable = 123,
#'     NumberOfAssignmentsCompleted = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_hit(
#'   MaxAssignments = 123,
#'   AutoApprovalDelayInSeconds = 123,
#'   LifetimeInSeconds = 123,
#'   AssignmentDurationInSeconds = 123,
#'   Reward = "string",
#'   Title = "string",
#'   Keywords = "string",
#'   Description = "string",
#'   Question = "string",
#'   RequesterAnnotation = "string",
#'   QualificationRequirements = list(
#'     list(
#'       QualificationTypeId = "string",
#'       Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'       IntegerValues = list(
#'         123
#'       ),
#'       LocaleValues = list(
#'         list(
#'           Country = "string",
#'           Subdivision = "string"
#'         )
#'       ),
#'       RequiredToPreview = TRUE|FALSE,
#'       ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'     )
#'   ),
#'   UniqueRequestToken = "string",
#'   AssignmentReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   HITReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   HITLayoutId = "string",
#'   HITLayoutParameters = list(
#'     list(
#'       Name = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_hit
#'
#' @aliases mturk_create_hit
mturk_create_hit <- function(MaxAssignments = NULL, AutoApprovalDelayInSeconds = NULL, LifetimeInSeconds, AssignmentDurationInSeconds, Reward, Title, Keywords = NULL, Description, Question = NULL, RequesterAnnotation = NULL, QualificationRequirements = NULL, UniqueRequestToken = NULL, AssignmentReviewPolicy = NULL, HITReviewPolicy = NULL, HITLayoutId = NULL, HITLayoutParameters = NULL) {
  op <- new_operation(
    name = "CreateHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_hit_input(MaxAssignments = MaxAssignments, AutoApprovalDelayInSeconds = AutoApprovalDelayInSeconds, LifetimeInSeconds = LifetimeInSeconds, AssignmentDurationInSeconds = AssignmentDurationInSeconds, Reward = Reward, Title = Title, Keywords = Keywords, Description = Description, Question = Question, RequesterAnnotation = RequesterAnnotation, QualificationRequirements = QualificationRequirements, UniqueRequestToken = UniqueRequestToken, AssignmentReviewPolicy = AssignmentReviewPolicy, HITReviewPolicy = HITReviewPolicy, HITLayoutId = HITLayoutId, HITLayoutParameters = HITLayoutParameters)
  output <- .mturk$create_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_hit <- mturk_create_hit

#' The CreateHITType operation creates a new HIT type
#'
#' @description
#' The [`create_hit_type`][mturk_create_hit_type] operation creates a new
#' HIT type. This operation allows you to define a standard set of HIT
#' properties to use when creating HITs. If you register a HIT type with
#' values that match an existing HIT type, the HIT type ID of the existing
#' type will be returned.
#'
#' @usage
#' mturk_create_hit_type(AutoApprovalDelayInSeconds,
#'   AssignmentDurationInSeconds, Reward, Title, Keywords, Description,
#'   QualificationRequirements)
#'
#' @param AutoApprovalDelayInSeconds The number of seconds after an assignment for the HIT has been
#' submitted, after which the assignment is considered Approved
#' automatically unless the Requester explicitly rejects it.
#' @param AssignmentDurationInSeconds &#91;required&#93; The amount of time, in seconds, that a Worker has to complete the HIT
#' after accepting it. If a Worker does not complete the assignment within
#' the specified duration, the assignment is considered abandoned. If the
#' HIT is still active (that is, its lifetime has not elapsed), the
#' assignment becomes available for other users to find and accept.
#' @param Reward &#91;required&#93; The amount of money the Requester will pay a Worker for successfully
#' completing the HIT.
#' @param Title &#91;required&#93; The title of the HIT. A title should be short and descriptive about the
#' kind of task the HIT contains. On the Amazon Mechanical Turk web site,
#' the HIT title appears in search results, and everywhere the HIT is
#' mentioned.
#' @param Keywords One or more words or phrases that describe the HIT, separated by commas.
#' These words are used in searches to find HITs.
#' @param Description &#91;required&#93; A general description of the HIT. A description includes detailed
#' information about the kind of task the HIT contains. On the Amazon
#' Mechanical Turk web site, the HIT description appears in the expanded
#' view of search results, and in the HIT and assignment screens. A good
#' description gives the user enough information to evaluate the HIT before
#' accepting it.
#' @param QualificationRequirements Conditions that a Worker's Qualifications must meet in order to accept
#' the HIT. A HIT can have between zero and ten Qualification requirements.
#' All requirements must be met in order for a Worker to accept the HIT.
#' Additionally, other actions can be restricted using the `ActionsGuarded`
#' field on each `QualificationRequirement` structure.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   HITTypeId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_hit_type(
#'   AutoApprovalDelayInSeconds = 123,
#'   AssignmentDurationInSeconds = 123,
#'   Reward = "string",
#'   Title = "string",
#'   Keywords = "string",
#'   Description = "string",
#'   QualificationRequirements = list(
#'     list(
#'       QualificationTypeId = "string",
#'       Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'       IntegerValues = list(
#'         123
#'       ),
#'       LocaleValues = list(
#'         list(
#'           Country = "string",
#'           Subdivision = "string"
#'         )
#'       ),
#'       RequiredToPreview = TRUE|FALSE,
#'       ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_hit_type
#'
#' @aliases mturk_create_hit_type
mturk_create_hit_type <- function(AutoApprovalDelayInSeconds = NULL, AssignmentDurationInSeconds, Reward, Title, Keywords = NULL, Description, QualificationRequirements = NULL) {
  op <- new_operation(
    name = "CreateHITType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_hit_type_input(AutoApprovalDelayInSeconds = AutoApprovalDelayInSeconds, AssignmentDurationInSeconds = AssignmentDurationInSeconds, Reward = Reward, Title = Title, Keywords = Keywords, Description = Description, QualificationRequirements = QualificationRequirements)
  output <- .mturk$create_hit_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_hit_type <- mturk_create_hit_type

#' The CreateHITWithHITType operation creates a new Human Intelligence Task
#' (HIT) using an existing HITTypeID generated by the CreateHITType
#' operation
#'
#' @description
#' The [`create_hit_with_hit_type`][mturk_create_hit_with_hit_type]
#' operation creates a new Human Intelligence Task (HIT) using an existing
#' HITTypeID generated by the [`create_hit_type`][mturk_create_hit_type]
#' operation.
#' 
#' This is an alternative way to create HITs from the
#' [`create_hit`][mturk_create_hit] operation. This is the recommended best
#' practice for Requesters who are creating large numbers of HITs.
#' 
#' CreateHITWithHITType also supports several ways to provide question
#' data: by providing a value for the `Question` parameter that fully
#' specifies the contents of the HIT, or by providing a `HitLayoutId` and
#' associated `HitLayoutParameters`.
#' 
#' If a HIT is created with 10 or more maximum assignments, there is an
#' additional fee. For more information, see [Amazon Mechanical Turk
#' Pricing](https://requester.mturk.com/pricing).
#'
#' @usage
#' mturk_create_hit_with_hit_type(HITTypeId, MaxAssignments,
#'   LifetimeInSeconds, Question, RequesterAnnotation, UniqueRequestToken,
#'   AssignmentReviewPolicy, HITReviewPolicy, HITLayoutId,
#'   HITLayoutParameters)
#'
#' @param HITTypeId &#91;required&#93; The HIT type ID you want to create this HIT with.
#' @param MaxAssignments The number of times the HIT can be accepted and completed before the HIT
#' becomes unavailable.
#' @param LifetimeInSeconds &#91;required&#93; An amount of time, in seconds, after which the HIT is no longer
#' available for users to accept. After the lifetime of the HIT elapses,
#' the HIT no longer appears in HIT searches, even if not all of the
#' assignments for the HIT have been accepted.
#' @param Question The data the person completing the HIT uses to produce the results.
#' 
#' Constraints: Must be a QuestionForm data structure, an ExternalQuestion
#' data structure, or an HTMLQuestion data structure. The XML question data
#' must not be larger than 64 kilobytes (65,535 bytes) in size, including
#' whitespace.
#' 
#' Either a Question parameter or a HITLayoutId parameter must be provided.
#' @param RequesterAnnotation An arbitrary data field. The RequesterAnnotation parameter lets your
#' application attach arbitrary data to the HIT for tracking purposes. For
#' example, this parameter could be an identifier internal to the
#' Requester's application that corresponds with the HIT.
#' 
#' The RequesterAnnotation parameter for a HIT is only visible to the
#' Requester who created the HIT. It is not shown to the Worker, or any
#' other Requester.
#' 
#' The RequesterAnnotation parameter may be different for each HIT you
#' submit. It does not affect how your HITs are grouped.
#' @param UniqueRequestToken A unique identifier for this request which allows you to retry the call
#' on error without creating duplicate HITs. This is useful in cases such
#' as network timeouts where it is unclear whether or not the call
#' succeeded on the server. If the HIT already exists in the system from a
#' previous call using the same UniqueRequestToken, subsequent calls will
#' return a AWS.MechanicalTurk.HitAlreadyExists error with a message
#' containing the HITId.
#' 
#' Note: It is your responsibility to ensure uniqueness of the token. The
#' unique token expires after 24 hours. Subsequent calls using the same
#' UniqueRequestToken made after the 24 hour limit could create duplicate
#' HITs.
#' @param AssignmentReviewPolicy The Assignment-level Review Policy applies to the assignments under the
#' HIT. You can specify for Mechanical Turk to take various actions based
#' on the policy.
#' @param HITReviewPolicy The HIT-level Review Policy applies to the HIT. You can specify for
#' Mechanical Turk to take various actions based on the policy.
#' @param HITLayoutId The HITLayoutId allows you to use a pre-existing HIT design with
#' placeholder values and create an additional HIT by providing those
#' values as HITLayoutParameters.
#' 
#' Constraints: Either a Question parameter or a HITLayoutId parameter must
#' be provided.
#' @param HITLayoutParameters If the HITLayoutId is provided, any placeholder values must be filled in
#' with values using the HITLayoutParameter structure. For more
#' information, see HITLayout.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   HIT = list(
#'     HITId = "string",
#'     HITTypeId = "string",
#'     HITGroupId = "string",
#'     HITLayoutId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Title = "string",
#'     Description = "string",
#'     Question = "string",
#'     Keywords = "string",
#'     HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'     MaxAssignments = 123,
#'     Reward = "string",
#'     AutoApprovalDelayInSeconds = 123,
#'     Expiration = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AssignmentDurationInSeconds = 123,
#'     RequesterAnnotation = "string",
#'     QualificationRequirements = list(
#'       list(
#'         QualificationTypeId = "string",
#'         Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'         IntegerValues = list(
#'           123
#'         ),
#'         LocaleValues = list(
#'           list(
#'             Country = "string",
#'             Subdivision = "string"
#'           )
#'         ),
#'         RequiredToPreview = TRUE|FALSE,
#'         ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'       )
#'     ),
#'     HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'     NumberOfAssignmentsPending = 123,
#'     NumberOfAssignmentsAvailable = 123,
#'     NumberOfAssignmentsCompleted = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_hit_with_hit_type(
#'   HITTypeId = "string",
#'   MaxAssignments = 123,
#'   LifetimeInSeconds = 123,
#'   Question = "string",
#'   RequesterAnnotation = "string",
#'   UniqueRequestToken = "string",
#'   AssignmentReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   HITReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   HITLayoutId = "string",
#'   HITLayoutParameters = list(
#'     list(
#'       Name = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_hit_with_hit_type
#'
#' @aliases mturk_create_hit_with_hit_type
mturk_create_hit_with_hit_type <- function(HITTypeId, MaxAssignments = NULL, LifetimeInSeconds, Question = NULL, RequesterAnnotation = NULL, UniqueRequestToken = NULL, AssignmentReviewPolicy = NULL, HITReviewPolicy = NULL, HITLayoutId = NULL, HITLayoutParameters = NULL) {
  op <- new_operation(
    name = "CreateHITWithHITType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_hit_with_hit_type_input(HITTypeId = HITTypeId, MaxAssignments = MaxAssignments, LifetimeInSeconds = LifetimeInSeconds, Question = Question, RequesterAnnotation = RequesterAnnotation, UniqueRequestToken = UniqueRequestToken, AssignmentReviewPolicy = AssignmentReviewPolicy, HITReviewPolicy = HITReviewPolicy, HITLayoutId = HITLayoutId, HITLayoutParameters = HITLayoutParameters)
  output <- .mturk$create_hit_with_hit_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_hit_with_hit_type <- mturk_create_hit_with_hit_type

#' The CreateQualificationType operation creates a new Qualification type,
#' which is represented by a QualificationType data structure
#'
#' @description
#' The [`create_qualification_type`][mturk_create_qualification_type]
#' operation creates a new Qualification type, which is represented by a
#' `QualificationType` data structure.
#'
#' @usage
#' mturk_create_qualification_type(Name, Keywords, Description,
#'   QualificationTypeStatus, RetryDelayInSeconds, Test, AnswerKey,
#'   TestDurationInSeconds, AutoGranted, AutoGrantedValue)
#'
#' @param Name &#91;required&#93; The name you give to the Qualification type. The type name is used to
#' represent the Qualification to Workers, and to find the type using a
#' Qualification type search. It must be unique across all of your
#' Qualification types.
#' @param Keywords One or more words or phrases that describe the Qualification type,
#' separated by commas. The keywords of a type make the type easier to find
#' during a search.
#' @param Description &#91;required&#93; A long description for the Qualification type. On the Amazon Mechanical
#' Turk website, the long description is displayed when a Worker examines a
#' Qualification type.
#' @param QualificationTypeStatus &#91;required&#93; The initial status of the Qualification type.
#' 
#' Constraints: Valid values are: Active | Inactive
#' @param RetryDelayInSeconds The number of seconds that a Worker must wait after requesting a
#' Qualification of the Qualification type before the worker can retry the
#' Qualification request.
#' 
#' Constraints: None. If not specified, retries are disabled and Workers
#' can request a Qualification of this type only once, even if the Worker
#' has not been granted the Qualification. It is not possible to disable
#' retries for a Qualification type after it has been created with retries
#' enabled. If you want to disable retries, you must delete existing
#' retry-enabled Qualification type and then create a new Qualification
#' type with retries disabled.
#' @param Test The questions for the Qualification test a Worker must answer correctly
#' to obtain a Qualification of this type. If this parameter is specified,
#' `TestDurationInSeconds` must also be specified.
#' 
#' Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm
#' data structure. This parameter cannot be specified if AutoGranted is
#' true.
#' 
#' Constraints: None. If not specified, the Worker may request the
#' Qualification without answering any questions.
#' @param AnswerKey The answers to the Qualification test specified in the Test parameter,
#' in the form of an AnswerKey data structure.
#' 
#' Constraints: Must not be longer than 65535 bytes.
#' 
#' Constraints: None. If not specified, you must process Qualification
#' requests manually.
#' @param TestDurationInSeconds The number of seconds the Worker has to complete the Qualification test,
#' starting from the time the Worker requests the Qualification.
#' @param AutoGranted Specifies whether requests for the Qualification type are granted
#' immediately, without prompting the Worker with a Qualification test.
#' 
#' Constraints: If the Test parameter is specified, this parameter cannot
#' be true.
#' @param AutoGrantedValue The Qualification value to use for automatically granted Qualifications.
#' This parameter is used only if the AutoGranted parameter is true.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QualificationType = list(
#'     QualificationTypeId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Name = "string",
#'     Description = "string",
#'     Keywords = "string",
#'     QualificationTypeStatus = "Active"|"Inactive",
#'     Test = "string",
#'     TestDurationInSeconds = 123,
#'     AnswerKey = "string",
#'     RetryDelayInSeconds = 123,
#'     IsRequestable = TRUE|FALSE,
#'     AutoGranted = TRUE|FALSE,
#'     AutoGrantedValue = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_qualification_type(
#'   Name = "string",
#'   Keywords = "string",
#'   Description = "string",
#'   QualificationTypeStatus = "Active"|"Inactive",
#'   RetryDelayInSeconds = 123,
#'   Test = "string",
#'   AnswerKey = "string",
#'   TestDurationInSeconds = 123,
#'   AutoGranted = TRUE|FALSE,
#'   AutoGrantedValue = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_qualification_type
#'
#' @aliases mturk_create_qualification_type
mturk_create_qualification_type <- function(Name, Keywords = NULL, Description, QualificationTypeStatus, RetryDelayInSeconds = NULL, Test = NULL, AnswerKey = NULL, TestDurationInSeconds = NULL, AutoGranted = NULL, AutoGrantedValue = NULL) {
  op <- new_operation(
    name = "CreateQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_qualification_type_input(Name = Name, Keywords = Keywords, Description = Description, QualificationTypeStatus = QualificationTypeStatus, RetryDelayInSeconds = RetryDelayInSeconds, Test = Test, AnswerKey = AnswerKey, TestDurationInSeconds = TestDurationInSeconds, AutoGranted = AutoGranted, AutoGrantedValue = AutoGrantedValue)
  output <- .mturk$create_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_qualification_type <- mturk_create_qualification_type

#' The CreateWorkerBlock operation allows you to prevent a Worker from
#' working on your HITs
#'
#' @description
#' The [`create_worker_block`][mturk_create_worker_block] operation allows
#' you to prevent a Worker from working on your HITs. For example, you can
#' block a Worker who is producing poor quality work. You can block up to
#' 100,000 Workers.
#'
#' @usage
#' mturk_create_worker_block(WorkerId, Reason)
#'
#' @param WorkerId &#91;required&#93; The ID of the Worker to block.
#' @param Reason &#91;required&#93; A message explaining the reason for blocking the Worker. This parameter
#' enables you to keep track of your Workers. The Worker does not see this
#' message.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$create_worker_block(
#'   WorkerId = "string",
#'   Reason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_create_worker_block
#'
#' @aliases mturk_create_worker_block
mturk_create_worker_block <- function(WorkerId, Reason) {
  op <- new_operation(
    name = "CreateWorkerBlock",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$create_worker_block_input(WorkerId = WorkerId, Reason = Reason)
  output <- .mturk$create_worker_block_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$create_worker_block <- mturk_create_worker_block

#' The DeleteHIT operation is used to delete HIT that is no longer needed
#'
#' @description
#' The [`delete_hit`][mturk_delete_hit] operation is used to delete HIT
#' that is no longer needed. Only the Requester who created the HIT can
#' delete it.
#' 
#' You can only dispose of HITs that are in the `Reviewable` state, with
#' all of their submitted assignments already either approved or rejected.
#' If you call the DeleteHIT operation on a HIT that is not in the
#' `Reviewable` state (for example, that has not expired, or still has
#' active assignments), or on a HIT that is Reviewable but without all of
#' its submitted assignments already approved or rejected, the service will
#' return an error.
#' 
#' -   HITs are automatically disposed of after 120 days.
#' 
#' -   After you dispose of a HIT, you can no longer approve the HIT's
#'     rejected assignments.
#' 
#' -   Disposed HITs are not returned in results for the ListHITs
#'     operation.
#' 
#' -   Disposing HITs can improve the performance of operations such as
#'     ListReviewableHITs and ListHITs.
#'
#' @usage
#' mturk_delete_hit(HITId)
#'
#' @param HITId &#91;required&#93; The ID of the HIT to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_hit(
#'   HITId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_delete_hit
#'
#' @aliases mturk_delete_hit
mturk_delete_hit <- function(HITId) {
  op <- new_operation(
    name = "DeleteHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$delete_hit_input(HITId = HITId)
  output <- .mturk$delete_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$delete_hit <- mturk_delete_hit

#' The DeleteQualificationType deletes a Qualification type and deletes any
#' HIT types that are associated with the Qualification type
#'
#' @description
#' The [`delete_qualification_type`][mturk_delete_qualification_type]
#' deletes a Qualification type and deletes any HIT types that are
#' associated with the Qualification type.
#' 
#' This operation does not revoke Qualifications already assigned to
#' Workers because the Qualifications might be needed for active HITs. If
#' there are any pending requests for the Qualification type, Amazon
#' Mechanical Turk rejects those requests. After you delete a Qualification
#' type, you can no longer use it to create HITs or HIT types.
#' 
#' DeleteQualificationType must wait for all the HITs that use the deleted
#' Qualification type to be deleted before completing. It may take up to 48
#' hours before DeleteQualificationType completes and the unique name of
#' the Qualification type is available for reuse with
#' CreateQualificationType.
#'
#' @usage
#' mturk_delete_qualification_type(QualificationTypeId)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the QualificationType to dispose.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_qualification_type(
#'   QualificationTypeId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_delete_qualification_type
#'
#' @aliases mturk_delete_qualification_type
mturk_delete_qualification_type <- function(QualificationTypeId) {
  op <- new_operation(
    name = "DeleteQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$delete_qualification_type_input(QualificationTypeId = QualificationTypeId)
  output <- .mturk$delete_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$delete_qualification_type <- mturk_delete_qualification_type

#' The DeleteWorkerBlock operation allows you to reinstate a blocked Worker
#' to work on your HITs
#'
#' @description
#' The [`delete_worker_block`][mturk_delete_worker_block] operation allows
#' you to reinstate a blocked Worker to work on your HITs. This operation
#' reverses the effects of the CreateWorkerBlock operation. You need the
#' Worker ID to use this operation. If the Worker ID is missing or invalid,
#' this operation fails and returns the message “WorkerId is invalid.” If
#' the specified Worker is not blocked, this operation returns
#' successfully.
#'
#' @usage
#' mturk_delete_worker_block(WorkerId, Reason)
#'
#' @param WorkerId &#91;required&#93; The ID of the Worker to unblock.
#' @param Reason A message that explains the reason for unblocking the Worker. The Worker
#' does not see this message.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_worker_block(
#'   WorkerId = "string",
#'   Reason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_delete_worker_block
#'
#' @aliases mturk_delete_worker_block
mturk_delete_worker_block <- function(WorkerId, Reason = NULL) {
  op <- new_operation(
    name = "DeleteWorkerBlock",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$delete_worker_block_input(WorkerId = WorkerId, Reason = Reason)
  output <- .mturk$delete_worker_block_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$delete_worker_block <- mturk_delete_worker_block

#' The DisassociateQualificationFromWorker revokes a previously granted
#' Qualification from a user
#'
#' @description
#' The
#' [`disassociate_qualification_from_worker`][mturk_disassociate_qualification_from_worker]
#' revokes a previously granted Qualification from a user.
#' 
#' You can provide a text message explaining why the Qualification was
#' revoked. The user who had the Qualification can see this message.
#'
#' @usage
#' mturk_disassociate_qualification_from_worker(WorkerId,
#'   QualificationTypeId, Reason)
#'
#' @param WorkerId &#91;required&#93; The ID of the Worker who possesses the Qualification to be revoked.
#' @param QualificationTypeId &#91;required&#93; The ID of the Qualification type of the Qualification to be revoked.
#' @param Reason A text message that explains why the Qualification was revoked. The user
#' who had the Qualification sees this message.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_qualification_from_worker(
#'   WorkerId = "string",
#'   QualificationTypeId = "string",
#'   Reason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_disassociate_qualification_from_worker
#'
#' @aliases mturk_disassociate_qualification_from_worker
mturk_disassociate_qualification_from_worker <- function(WorkerId, QualificationTypeId, Reason = NULL) {
  op <- new_operation(
    name = "DisassociateQualificationFromWorker",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$disassociate_qualification_from_worker_input(WorkerId = WorkerId, QualificationTypeId = QualificationTypeId, Reason = Reason)
  output <- .mturk$disassociate_qualification_from_worker_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$disassociate_qualification_from_worker <- mturk_disassociate_qualification_from_worker

#' The GetAccountBalance operation retrieves the Prepaid HITs balance in
#' your Amazon Mechanical Turk account if you are a Prepaid Requester
#'
#' @description
#' The [`get_account_balance`][mturk_get_account_balance] operation
#' retrieves the Prepaid HITs balance in your Amazon Mechanical Turk
#' account if you are a Prepaid Requester. Alternatively, this operation
#' will retrieve the remaining available AWS Billing usage if you have
#' enabled AWS Billing. Note: If you have enabled AWS Billing and still
#' have a remaining Prepaid HITs balance, this balance can be viewed on the
#' My Account page in the Requester console.
#'
#' @usage
#' mturk_get_account_balance()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AvailableBalance = "string",
#'   OnHoldBalance = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_account_balance()
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_account_balance
#'
#' @aliases mturk_get_account_balance
mturk_get_account_balance <- function() {
  op <- new_operation(
    name = "GetAccountBalance",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_account_balance_input()
  output <- .mturk$get_account_balance_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_account_balance <- mturk_get_account_balance

#' The GetAssignment operation retrieves the details of the specified
#' Assignment
#'
#' @description
#' The [`get_assignment`][mturk_get_assignment] operation retrieves the
#' details of the specified Assignment.
#'
#' @usage
#' mturk_get_assignment(AssignmentId)
#'
#' @param AssignmentId &#91;required&#93; The ID of the Assignment to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Assignment = list(
#'     AssignmentId = "string",
#'     WorkerId = "string",
#'     HITId = "string",
#'     AssignmentStatus = "Submitted"|"Approved"|"Rejected",
#'     AutoApprovalTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AcceptTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     SubmitTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ApprovalTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RejectionTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Deadline = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Answer = "string",
#'     RequesterFeedback = "string"
#'   ),
#'   HIT = list(
#'     HITId = "string",
#'     HITTypeId = "string",
#'     HITGroupId = "string",
#'     HITLayoutId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Title = "string",
#'     Description = "string",
#'     Question = "string",
#'     Keywords = "string",
#'     HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'     MaxAssignments = 123,
#'     Reward = "string",
#'     AutoApprovalDelayInSeconds = 123,
#'     Expiration = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AssignmentDurationInSeconds = 123,
#'     RequesterAnnotation = "string",
#'     QualificationRequirements = list(
#'       list(
#'         QualificationTypeId = "string",
#'         Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'         IntegerValues = list(
#'           123
#'         ),
#'         LocaleValues = list(
#'           list(
#'             Country = "string",
#'             Subdivision = "string"
#'           )
#'         ),
#'         RequiredToPreview = TRUE|FALSE,
#'         ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'       )
#'     ),
#'     HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'     NumberOfAssignmentsPending = 123,
#'     NumberOfAssignmentsAvailable = 123,
#'     NumberOfAssignmentsCompleted = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_assignment(
#'   AssignmentId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_assignment
#'
#' @aliases mturk_get_assignment
mturk_get_assignment <- function(AssignmentId) {
  op <- new_operation(
    name = "GetAssignment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_assignment_input(AssignmentId = AssignmentId)
  output <- .mturk$get_assignment_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_assignment <- mturk_get_assignment

#' The GetFileUploadURL operation generates and returns a temporary URL
#'
#' @description
#' The [`get_file_upload_url`][mturk_get_file_upload_url] operation
#' generates and returns a temporary URL. You use the temporary URL to
#' retrieve a file uploaded by a Worker as an answer to a FileUploadAnswer
#' question for a HIT. The temporary URL is generated the instant the
#' GetFileUploadURL operation is called, and is valid for 60 seconds. You
#' can get a temporary file upload URL any time until the HIT is disposed.
#' After the HIT is disposed, any uploaded files are deleted, and cannot be
#' retrieved. Pending Deprecation on December 12, 2017. The Answer
#' Specification structure will no longer support the `FileUploadAnswer`
#' element to be used for the QuestionForm data structure. Instead, we
#' recommend that Requesters who want to create HITs asking Workers to
#' upload files to use Amazon S3.
#'
#' @usage
#' mturk_get_file_upload_url(AssignmentId, QuestionIdentifier)
#'
#' @param AssignmentId &#91;required&#93; The ID of the assignment that contains the question with a
#' FileUploadAnswer.
#' @param QuestionIdentifier &#91;required&#93; The identifier of the question with a FileUploadAnswer, as specified in
#' the QuestionForm of the HIT.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FileUploadURL = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_file_upload_url(
#'   AssignmentId = "string",
#'   QuestionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_file_upload_url
#'
#' @aliases mturk_get_file_upload_url
mturk_get_file_upload_url <- function(AssignmentId, QuestionIdentifier) {
  op <- new_operation(
    name = "GetFileUploadURL",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_file_upload_url_input(AssignmentId = AssignmentId, QuestionIdentifier = QuestionIdentifier)
  output <- .mturk$get_file_upload_url_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_file_upload_url <- mturk_get_file_upload_url

#' The GetHIT operation retrieves the details of the specified HIT
#'
#' @description
#' The [`get_hit`][mturk_get_hit] operation retrieves the details of the
#' specified HIT.
#'
#' @usage
#' mturk_get_hit(HITId)
#'
#' @param HITId &#91;required&#93; The ID of the HIT to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   HIT = list(
#'     HITId = "string",
#'     HITTypeId = "string",
#'     HITGroupId = "string",
#'     HITLayoutId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Title = "string",
#'     Description = "string",
#'     Question = "string",
#'     Keywords = "string",
#'     HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'     MaxAssignments = 123,
#'     Reward = "string",
#'     AutoApprovalDelayInSeconds = 123,
#'     Expiration = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AssignmentDurationInSeconds = 123,
#'     RequesterAnnotation = "string",
#'     QualificationRequirements = list(
#'       list(
#'         QualificationTypeId = "string",
#'         Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'         IntegerValues = list(
#'           123
#'         ),
#'         LocaleValues = list(
#'           list(
#'             Country = "string",
#'             Subdivision = "string"
#'           )
#'         ),
#'         RequiredToPreview = TRUE|FALSE,
#'         ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'       )
#'     ),
#'     HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'     NumberOfAssignmentsPending = 123,
#'     NumberOfAssignmentsAvailable = 123,
#'     NumberOfAssignmentsCompleted = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_hit(
#'   HITId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_hit
#'
#' @aliases mturk_get_hit
mturk_get_hit <- function(HITId) {
  op <- new_operation(
    name = "GetHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_hit_input(HITId = HITId)
  output <- .mturk$get_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_hit <- mturk_get_hit

#' The GetQualificationScore operation returns the value of a Worker's
#' Qualification for a given Qualification type
#'
#' @description
#' The [`get_qualification_score`][mturk_get_qualification_score] operation
#' returns the value of a Worker's Qualification for a given Qualification
#' type.
#' 
#' To get a Worker's Qualification, you must know the Worker's ID. The
#' Worker's ID is included in the assignment data returned by the
#' [`list_assignments_for_hit`][mturk_list_assignments_for_hit] operation.
#' 
#' Only the owner of a Qualification type can query the value of a Worker's
#' Qualification of that type.
#'
#' @usage
#' mturk_get_qualification_score(QualificationTypeId, WorkerId)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the QualificationType.
#' @param WorkerId &#91;required&#93; The ID of the Worker whose Qualification is being updated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Qualification = list(
#'     QualificationTypeId = "string",
#'     WorkerId = "string",
#'     GrantTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     IntegerValue = 123,
#'     LocaleValue = list(
#'       Country = "string",
#'       Subdivision = "string"
#'     ),
#'     Status = "Granted"|"Revoked"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_qualification_score(
#'   QualificationTypeId = "string",
#'   WorkerId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_qualification_score
#'
#' @aliases mturk_get_qualification_score
mturk_get_qualification_score <- function(QualificationTypeId, WorkerId) {
  op <- new_operation(
    name = "GetQualificationScore",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_qualification_score_input(QualificationTypeId = QualificationTypeId, WorkerId = WorkerId)
  output <- .mturk$get_qualification_score_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_qualification_score <- mturk_get_qualification_score

#' The GetQualificationTypeoperation retrieves information about a
#' Qualification type using its ID
#'
#' @description
#' The [`get_qualification_type`][mturk_get_qualification_type]operation
#' retrieves information about a Qualification type using its ID.
#'
#' @usage
#' mturk_get_qualification_type(QualificationTypeId)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the QualificationType.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QualificationType = list(
#'     QualificationTypeId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Name = "string",
#'     Description = "string",
#'     Keywords = "string",
#'     QualificationTypeStatus = "Active"|"Inactive",
#'     Test = "string",
#'     TestDurationInSeconds = 123,
#'     AnswerKey = "string",
#'     RetryDelayInSeconds = 123,
#'     IsRequestable = TRUE|FALSE,
#'     AutoGranted = TRUE|FALSE,
#'     AutoGrantedValue = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_qualification_type(
#'   QualificationTypeId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_get_qualification_type
#'
#' @aliases mturk_get_qualification_type
mturk_get_qualification_type <- function(QualificationTypeId) {
  op <- new_operation(
    name = "GetQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$get_qualification_type_input(QualificationTypeId = QualificationTypeId)
  output <- .mturk$get_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$get_qualification_type <- mturk_get_qualification_type

#' The ListAssignmentsForHIT operation retrieves completed assignments for
#' a HIT
#'
#' @description
#' The [`list_assignments_for_hit`][mturk_list_assignments_for_hit]
#' operation retrieves completed assignments for a HIT. You can use this
#' operation to retrieve the results for a HIT.
#' 
#' You can get assignments for a HIT at any time, even if the HIT is not
#' yet Reviewable. If a HIT requested multiple assignments, and has
#' received some results but has not yet become Reviewable, you can still
#' retrieve the partial results with this operation.
#' 
#' Use the AssignmentStatus parameter to control which set of assignments
#' for a HIT are returned. The ListAssignmentsForHIT operation can return
#' submitted assignments awaiting approval, or it can return assignments
#' that have already been approved or rejected. You can set
#' AssignmentStatus=Approved,Rejected to get assignments that have already
#' been approved and rejected together in one result set.
#' 
#' Only the Requester who created the HIT can retrieve the assignments for
#' that HIT.
#' 
#' Results are sorted and divided into numbered pages and the operation
#' returns a single page of results. You can use the parameters of the
#' operation to control sorting and pagination.
#'
#' @usage
#' mturk_list_assignments_for_hit(HITId, NextToken, MaxResults,
#'   AssignmentStatuses)
#'
#' @param HITId &#91;required&#93; The ID of the HIT.
#' @param NextToken Pagination token
#' @param MaxResults 
#' @param AssignmentStatuses The status of the assignments to return: Submitted | Approved | Rejected
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   Assignments = list(
#'     list(
#'       AssignmentId = "string",
#'       WorkerId = "string",
#'       HITId = "string",
#'       AssignmentStatus = "Submitted"|"Approved"|"Rejected",
#'       AutoApprovalTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AcceptTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       SubmitTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ApprovalTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RejectionTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Deadline = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Answer = "string",
#'       RequesterFeedback = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_assignments_for_hit(
#'   HITId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   AssignmentStatuses = list(
#'     "Submitted"|"Approved"|"Rejected"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_assignments_for_hit
#'
#' @aliases mturk_list_assignments_for_hit
mturk_list_assignments_for_hit <- function(HITId, NextToken = NULL, MaxResults = NULL, AssignmentStatuses = NULL) {
  op <- new_operation(
    name = "ListAssignmentsForHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_assignments_for_hit_input(HITId = HITId, NextToken = NextToken, MaxResults = MaxResults, AssignmentStatuses = AssignmentStatuses)
  output <- .mturk$list_assignments_for_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_assignments_for_hit <- mturk_list_assignments_for_hit

#' The ListBonusPayments operation retrieves the amounts of bonuses you
#' have paid to Workers for a given HIT or assignment
#'
#' @description
#' The [`list_bonus_payments`][mturk_list_bonus_payments] operation
#' retrieves the amounts of bonuses you have paid to Workers for a given
#' HIT or assignment.
#'
#' @usage
#' mturk_list_bonus_payments(HITId, AssignmentId, NextToken, MaxResults)
#'
#' @param HITId The ID of the HIT associated with the bonus payments to retrieve. If not
#' specified, all bonus payments for all assignments for the given HIT are
#' returned. Either the HITId parameter or the AssignmentId parameter must
#' be specified
#' @param AssignmentId The ID of the assignment associated with the bonus payments to retrieve.
#' If specified, only bonus payments for the given assignment are returned.
#' Either the HITId parameter or the AssignmentId parameter must be
#' specified
#' @param NextToken Pagination token
#' @param MaxResults 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NumResults = 123,
#'   NextToken = "string",
#'   BonusPayments = list(
#'     list(
#'       WorkerId = "string",
#'       BonusAmount = "string",
#'       AssignmentId = "string",
#'       Reason = "string",
#'       GrantTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_bonus_payments(
#'   HITId = "string",
#'   AssignmentId = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_bonus_payments
#'
#' @aliases mturk_list_bonus_payments
mturk_list_bonus_payments <- function(HITId = NULL, AssignmentId = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListBonusPayments",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_bonus_payments_input(HITId = HITId, AssignmentId = AssignmentId, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_bonus_payments_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_bonus_payments <- mturk_list_bonus_payments

#' The ListHITs operation returns all of a Requester's HITs
#'
#' @description
#' The [`list_hi_ts`][mturk_list_hi_ts] operation returns all of a
#' Requester's HITs. The operation returns HITs of any status, except for
#' HITs that have been deleted of with the DeleteHIT operation or that have
#' been auto-deleted.
#'
#' @usage
#' mturk_list_hi_ts(NextToken, MaxResults)
#'
#' @param NextToken Pagination token
#' @param MaxResults 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   HITs = list(
#'     list(
#'       HITId = "string",
#'       HITTypeId = "string",
#'       HITGroupId = "string",
#'       HITLayoutId = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Title = "string",
#'       Description = "string",
#'       Question = "string",
#'       Keywords = "string",
#'       HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'       MaxAssignments = 123,
#'       Reward = "string",
#'       AutoApprovalDelayInSeconds = 123,
#'       Expiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AssignmentDurationInSeconds = 123,
#'       RequesterAnnotation = "string",
#'       QualificationRequirements = list(
#'         list(
#'           QualificationTypeId = "string",
#'           Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'           IntegerValues = list(
#'             123
#'           ),
#'           LocaleValues = list(
#'             list(
#'               Country = "string",
#'               Subdivision = "string"
#'             )
#'           ),
#'           RequiredToPreview = TRUE|FALSE,
#'           ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'         )
#'       ),
#'       HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'       NumberOfAssignmentsPending = 123,
#'       NumberOfAssignmentsAvailable = 123,
#'       NumberOfAssignmentsCompleted = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_hi_ts(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_hi_ts
#'
#' @aliases mturk_list_hi_ts
mturk_list_hi_ts <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListHITs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_hi_ts_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_hi_ts_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_hi_ts <- mturk_list_hi_ts

#' The ListHITsForQualificationType operation returns the HITs that use the
#' given Qualification type for a Qualification requirement
#'
#' @description
#' The
#' [`list_hi_ts_for_qualification_type`][mturk_list_hi_ts_for_qualification_type]
#' operation returns the HITs that use the given Qualification type for a
#' Qualification requirement. The operation returns HITs of any status,
#' except for HITs that have been deleted with the
#' [`delete_hit`][mturk_delete_hit] operation or that have been
#' auto-deleted.
#'
#' @usage
#' mturk_list_hi_ts_for_qualification_type(QualificationTypeId, NextToken,
#'   MaxResults)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the Qualification type to use when querying HITs.
#' @param NextToken Pagination Token
#' @param MaxResults Limit the number of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   HITs = list(
#'     list(
#'       HITId = "string",
#'       HITTypeId = "string",
#'       HITGroupId = "string",
#'       HITLayoutId = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Title = "string",
#'       Description = "string",
#'       Question = "string",
#'       Keywords = "string",
#'       HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'       MaxAssignments = 123,
#'       Reward = "string",
#'       AutoApprovalDelayInSeconds = 123,
#'       Expiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AssignmentDurationInSeconds = 123,
#'       RequesterAnnotation = "string",
#'       QualificationRequirements = list(
#'         list(
#'           QualificationTypeId = "string",
#'           Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'           IntegerValues = list(
#'             123
#'           ),
#'           LocaleValues = list(
#'             list(
#'               Country = "string",
#'               Subdivision = "string"
#'             )
#'           ),
#'           RequiredToPreview = TRUE|FALSE,
#'           ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'         )
#'       ),
#'       HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'       NumberOfAssignmentsPending = 123,
#'       NumberOfAssignmentsAvailable = 123,
#'       NumberOfAssignmentsCompleted = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_hi_ts_for_qualification_type(
#'   QualificationTypeId = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_hi_ts_for_qualification_type
#'
#' @aliases mturk_list_hi_ts_for_qualification_type
mturk_list_hi_ts_for_qualification_type <- function(QualificationTypeId, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListHITsForQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_hi_ts_for_qualification_type_input(QualificationTypeId = QualificationTypeId, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_hi_ts_for_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_hi_ts_for_qualification_type <- mturk_list_hi_ts_for_qualification_type

#' The ListQualificationRequests operation retrieves requests for
#' Qualifications of a particular Qualification type
#'
#' @description
#' The [`list_qualification_requests`][mturk_list_qualification_requests]
#' operation retrieves requests for Qualifications of a particular
#' Qualification type. The owner of the Qualification type calls this
#' operation to poll for pending requests, and accepts them using the
#' AcceptQualification operation.
#'
#' @usage
#' mturk_list_qualification_requests(QualificationTypeId, NextToken,
#'   MaxResults)
#'
#' @param QualificationTypeId The ID of the QualificationType.
#' @param NextToken 
#' @param MaxResults The maximum number of results to return in a single call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NumResults = 123,
#'   NextToken = "string",
#'   QualificationRequests = list(
#'     list(
#'       QualificationRequestId = "string",
#'       QualificationTypeId = "string",
#'       WorkerId = "string",
#'       Test = "string",
#'       Answer = "string",
#'       SubmitTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_qualification_requests(
#'   QualificationTypeId = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_qualification_requests
#'
#' @aliases mturk_list_qualification_requests
mturk_list_qualification_requests <- function(QualificationTypeId = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListQualificationRequests",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_qualification_requests_input(QualificationTypeId = QualificationTypeId, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_qualification_requests_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_qualification_requests <- mturk_list_qualification_requests

#' The ListQualificationTypes operation returns a list of Qualification
#' types, filtered by an optional search term
#'
#' @description
#' The [`list_qualification_types`][mturk_list_qualification_types]
#' operation returns a list of Qualification types, filtered by an optional
#' search term.
#'
#' @usage
#' mturk_list_qualification_types(Query, MustBeRequestable,
#'   MustBeOwnedByCaller, NextToken, MaxResults)
#'
#' @param Query A text query against all of the searchable attributes of Qualification
#' types.
#' @param MustBeRequestable &#91;required&#93; Specifies that only Qualification types that a user can request through
#' the Amazon Mechanical Turk web site, such as by taking a Qualification
#' test, are returned as results of the search. Some Qualification types,
#' such as those assigned automatically by the system, cannot be requested
#' directly by users. If false, all Qualification types, including those
#' managed by the system, are considered. Valid values are True | False.
#' @param MustBeOwnedByCaller Specifies that only Qualification types that the Requester created are
#' returned. If false, the operation returns all Qualification types.
#' @param NextToken 
#' @param MaxResults The maximum number of results to return in a single call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NumResults = 123,
#'   NextToken = "string",
#'   QualificationTypes = list(
#'     list(
#'       QualificationTypeId = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Name = "string",
#'       Description = "string",
#'       Keywords = "string",
#'       QualificationTypeStatus = "Active"|"Inactive",
#'       Test = "string",
#'       TestDurationInSeconds = 123,
#'       AnswerKey = "string",
#'       RetryDelayInSeconds = 123,
#'       IsRequestable = TRUE|FALSE,
#'       AutoGranted = TRUE|FALSE,
#'       AutoGrantedValue = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_qualification_types(
#'   Query = "string",
#'   MustBeRequestable = TRUE|FALSE,
#'   MustBeOwnedByCaller = TRUE|FALSE,
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_qualification_types
#'
#' @aliases mturk_list_qualification_types
mturk_list_qualification_types <- function(Query = NULL, MustBeRequestable, MustBeOwnedByCaller = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListQualificationTypes",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_qualification_types_input(Query = Query, MustBeRequestable = MustBeRequestable, MustBeOwnedByCaller = MustBeOwnedByCaller, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_qualification_types_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_qualification_types <- mturk_list_qualification_types

#' The ListReviewPolicyResultsForHIT operation retrieves the computed
#' results and the actions taken in the course of executing your Review
#' Policies for a given HIT
#'
#' @description
#' The
#' [`list_review_policy_results_for_hit`][mturk_list_review_policy_results_for_hit]
#' operation retrieves the computed results and the actions taken in the
#' course of executing your Review Policies for a given HIT. For
#' information about how to specify Review Policies when you call
#' CreateHIT, see Review Policies. The ListReviewPolicyResultsForHIT
#' operation can return results for both Assignment-level and HIT-level
#' review results.
#'
#' @usage
#' mturk_list_review_policy_results_for_hit(HITId, PolicyLevels,
#'   RetrieveActions, RetrieveResults, NextToken, MaxResults)
#'
#' @param HITId &#91;required&#93; The unique identifier of the HIT to retrieve review results for.
#' @param PolicyLevels The Policy Level(s) to retrieve review results for - HIT or Assignment.
#' If omitted, the default behavior is to retrieve all data for both policy
#' levels. For a list of all the described policies, see Review Policies.
#' @param RetrieveActions Specify if the operation should retrieve a list of the actions taken
#' executing the Review Policies and their outcomes.
#' @param RetrieveResults Specify if the operation should retrieve a list of the results computed
#' by the Review Policies.
#' @param NextToken Pagination token
#' @param MaxResults Limit the number of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   HITId = "string",
#'   AssignmentReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   HITReviewPolicy = list(
#'     PolicyName = "string",
#'     Parameters = list(
#'       list(
#'         Key = "string",
#'         Values = list(
#'           "string"
#'         ),
#'         MapEntries = list(
#'           list(
#'             Key = "string",
#'             Values = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   AssignmentReviewReport = list(
#'     ReviewResults = list(
#'       list(
#'         ActionId = "string",
#'         SubjectId = "string",
#'         SubjectType = "string",
#'         QuestionId = "string",
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ReviewActions = list(
#'       list(
#'         ActionId = "string",
#'         ActionName = "string",
#'         TargetId = "string",
#'         TargetType = "string",
#'         Status = "Intended"|"Succeeded"|"Failed"|"Cancelled",
#'         CompleteTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Result = "string",
#'         ErrorCode = "string"
#'       )
#'     )
#'   ),
#'   HITReviewReport = list(
#'     ReviewResults = list(
#'       list(
#'         ActionId = "string",
#'         SubjectId = "string",
#'         SubjectType = "string",
#'         QuestionId = "string",
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ReviewActions = list(
#'       list(
#'         ActionId = "string",
#'         ActionName = "string",
#'         TargetId = "string",
#'         TargetType = "string",
#'         Status = "Intended"|"Succeeded"|"Failed"|"Cancelled",
#'         CompleteTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         Result = "string",
#'         ErrorCode = "string"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_review_policy_results_for_hit(
#'   HITId = "string",
#'   PolicyLevels = list(
#'     "Assignment"|"HIT"
#'   ),
#'   RetrieveActions = TRUE|FALSE,
#'   RetrieveResults = TRUE|FALSE,
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_review_policy_results_for_hit
#'
#' @aliases mturk_list_review_policy_results_for_hit
mturk_list_review_policy_results_for_hit <- function(HITId, PolicyLevels = NULL, RetrieveActions = NULL, RetrieveResults = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListReviewPolicyResultsForHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_review_policy_results_for_hit_input(HITId = HITId, PolicyLevels = PolicyLevels, RetrieveActions = RetrieveActions, RetrieveResults = RetrieveResults, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_review_policy_results_for_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_review_policy_results_for_hit <- mturk_list_review_policy_results_for_hit

#' The ListReviewableHITs operation retrieves the HITs with Status equal to
#' Reviewable or Status equal to Reviewing that belong to the Requester
#' calling the operation
#'
#' @description
#' The [`list_reviewable_hi_ts`][mturk_list_reviewable_hi_ts] operation
#' retrieves the HITs with Status equal to Reviewable or Status equal to
#' Reviewing that belong to the Requester calling the operation.
#'
#' @usage
#' mturk_list_reviewable_hi_ts(HITTypeId, Status, NextToken, MaxResults)
#'
#' @param HITTypeId The ID of the HIT type of the HITs to consider for the query. If not
#' specified, all HITs for the Reviewer are considered
#' @param Status Can be either `Reviewable` or `Reviewing`. Reviewable is the default
#' value.
#' @param NextToken Pagination Token
#' @param MaxResults Limit the number of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   HITs = list(
#'     list(
#'       HITId = "string",
#'       HITTypeId = "string",
#'       HITGroupId = "string",
#'       HITLayoutId = "string",
#'       CreationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Title = "string",
#'       Description = "string",
#'       Question = "string",
#'       Keywords = "string",
#'       HITStatus = "Assignable"|"Unassignable"|"Reviewable"|"Reviewing"|"Disposed",
#'       MaxAssignments = 123,
#'       Reward = "string",
#'       AutoApprovalDelayInSeconds = 123,
#'       Expiration = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       AssignmentDurationInSeconds = 123,
#'       RequesterAnnotation = "string",
#'       QualificationRequirements = list(
#'         list(
#'           QualificationTypeId = "string",
#'           Comparator = "LessThan"|"LessThanOrEqualTo"|"GreaterThan"|"GreaterThanOrEqualTo"|"EqualTo"|"NotEqualTo"|"Exists"|"DoesNotExist"|"In"|"NotIn",
#'           IntegerValues = list(
#'             123
#'           ),
#'           LocaleValues = list(
#'             list(
#'               Country = "string",
#'               Subdivision = "string"
#'             )
#'           ),
#'           RequiredToPreview = TRUE|FALSE,
#'           ActionsGuarded = "Accept"|"PreviewAndAccept"|"DiscoverPreviewAndAccept"
#'         )
#'       ),
#'       HITReviewStatus = "NotReviewed"|"MarkedForReview"|"ReviewedAppropriate"|"ReviewedInappropriate",
#'       NumberOfAssignmentsPending = 123,
#'       NumberOfAssignmentsAvailable = 123,
#'       NumberOfAssignmentsCompleted = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_reviewable_hi_ts(
#'   HITTypeId = "string",
#'   Status = "Reviewable"|"Reviewing",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_reviewable_hi_ts
#'
#' @aliases mturk_list_reviewable_hi_ts
mturk_list_reviewable_hi_ts <- function(HITTypeId = NULL, Status = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListReviewableHITs",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_reviewable_hi_ts_input(HITTypeId = HITTypeId, Status = Status, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_reviewable_hi_ts_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_reviewable_hi_ts <- mturk_list_reviewable_hi_ts

#' The ListWorkersBlocks operation retrieves a list of Workers who are
#' blocked from working on your HITs
#'
#' @description
#' The `ListWorkersBlocks` operation retrieves a list of Workers who are
#' blocked from working on your HITs.
#'
#' @usage
#' mturk_list_worker_blocks(NextToken, MaxResults)
#'
#' @param NextToken Pagination token
#' @param MaxResults 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   WorkerBlocks = list(
#'     list(
#'       WorkerId = "string",
#'       Reason = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_worker_blocks(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_worker_blocks
#'
#' @aliases mturk_list_worker_blocks
mturk_list_worker_blocks <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListWorkerBlocks",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_worker_blocks_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_worker_blocks_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_worker_blocks <- mturk_list_worker_blocks

#' The ListWorkersWithQualificationType operation returns all of the
#' Workers that have been associated with a given Qualification type
#'
#' @description
#' The
#' [`list_workers_with_qualification_type`][mturk_list_workers_with_qualification_type]
#' operation returns all of the Workers that have been associated with a
#' given Qualification type.
#'
#' @usage
#' mturk_list_workers_with_qualification_type(QualificationTypeId, Status,
#'   NextToken, MaxResults)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the Qualification type of the Qualifications to return.
#' @param Status The status of the Qualifications to return. Can be `Granted | Revoked`.
#' @param NextToken Pagination Token
#' @param MaxResults Limit the number of results returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   NumResults = 123,
#'   Qualifications = list(
#'     list(
#'       QualificationTypeId = "string",
#'       WorkerId = "string",
#'       GrantTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       IntegerValue = 123,
#'       LocaleValue = list(
#'         Country = "string",
#'         Subdivision = "string"
#'       ),
#'       Status = "Granted"|"Revoked"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_workers_with_qualification_type(
#'   QualificationTypeId = "string",
#'   Status = "Granted"|"Revoked",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_list_workers_with_qualification_type
#'
#' @aliases mturk_list_workers_with_qualification_type
mturk_list_workers_with_qualification_type <- function(QualificationTypeId, Status = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListWorkersWithQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults")
  )
  input <- .mturk$list_workers_with_qualification_type_input(QualificationTypeId = QualificationTypeId, Status = Status, NextToken = NextToken, MaxResults = MaxResults)
  output <- .mturk$list_workers_with_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$list_workers_with_qualification_type <- mturk_list_workers_with_qualification_type

#' The NotifyWorkers operation sends an email to one or more Workers that
#' you specify with the Worker ID
#'
#' @description
#' The [`notify_workers`][mturk_notify_workers] operation sends an email to
#' one or more Workers that you specify with the Worker ID. You can specify
#' up to 100 Worker IDs to send the same message with a single call to the
#' NotifyWorkers operation. The NotifyWorkers operation will send a
#' notification email to a Worker only if you have previously approved or
#' rejected work from the Worker.
#'
#' @usage
#' mturk_notify_workers(Subject, MessageText, WorkerIds)
#'
#' @param Subject &#91;required&#93; The subject line of the email message to send. Can include up to 200
#' characters.
#' @param MessageText &#91;required&#93; The text of the email message to send. Can include up to 4,096
#' characters
#' @param WorkerIds &#91;required&#93; A list of Worker IDs you wish to notify. You can notify upto 100 Workers
#' at a time.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NotifyWorkersFailureStatuses = list(
#'     list(
#'       NotifyWorkersFailureCode = "SoftFailure"|"HardFailure",
#'       NotifyWorkersFailureMessage = "string",
#'       WorkerId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$notify_workers(
#'   Subject = "string",
#'   MessageText = "string",
#'   WorkerIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_notify_workers
#'
#' @aliases mturk_notify_workers
mturk_notify_workers <- function(Subject, MessageText, WorkerIds) {
  op <- new_operation(
    name = "NotifyWorkers",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$notify_workers_input(Subject = Subject, MessageText = MessageText, WorkerIds = WorkerIds)
  output <- .mturk$notify_workers_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$notify_workers <- mturk_notify_workers

#' The RejectAssignment operation rejects the results of a completed
#' assignment
#'
#' @description
#' The [`reject_assignment`][mturk_reject_assignment] operation rejects the
#' results of a completed assignment.
#' 
#' You can include an optional feedback message with the rejection, which
#' the Worker can see in the Status section of the web site. When you
#' include a feedback message with the rejection, it helps the Worker
#' understand why the assignment was rejected, and can improve the quality
#' of the results the Worker submits in the future.
#' 
#' Only the Requester who created the HIT can reject an assignment for the
#' HIT.
#'
#' @usage
#' mturk_reject_assignment(AssignmentId, RequesterFeedback)
#'
#' @param AssignmentId &#91;required&#93; The ID of the assignment. The assignment must correspond to a HIT
#' created by the Requester.
#' @param RequesterFeedback &#91;required&#93; A message for the Worker, which the Worker can see in the Status section
#' of the web site.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$reject_assignment(
#'   AssignmentId = "string",
#'   RequesterFeedback = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_reject_assignment
#'
#' @aliases mturk_reject_assignment
mturk_reject_assignment <- function(AssignmentId, RequesterFeedback) {
  op <- new_operation(
    name = "RejectAssignment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$reject_assignment_input(AssignmentId = AssignmentId, RequesterFeedback = RequesterFeedback)
  output <- .mturk$reject_assignment_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$reject_assignment <- mturk_reject_assignment

#' The RejectQualificationRequest operation rejects a user's request for a
#' Qualification
#'
#' @description
#' The [`reject_qualification_request`][mturk_reject_qualification_request]
#' operation rejects a user's request for a Qualification.
#' 
#' You can provide a text message explaining why the request was rejected.
#' The Worker who made the request can see this message.
#'
#' @usage
#' mturk_reject_qualification_request(QualificationRequestId, Reason)
#'
#' @param QualificationRequestId &#91;required&#93; The ID of the Qualification request, as returned by the
#' [`list_qualification_requests`][mturk_list_qualification_requests]
#' operation.
#' @param Reason A text message explaining why the request was rejected, to be shown to
#' the Worker who made the request.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$reject_qualification_request(
#'   QualificationRequestId = "string",
#'   Reason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_reject_qualification_request
#'
#' @aliases mturk_reject_qualification_request
mturk_reject_qualification_request <- function(QualificationRequestId, Reason = NULL) {
  op <- new_operation(
    name = "RejectQualificationRequest",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$reject_qualification_request_input(QualificationRequestId = QualificationRequestId, Reason = Reason)
  output <- .mturk$reject_qualification_request_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$reject_qualification_request <- mturk_reject_qualification_request

#' The SendBonus operation issues a payment of money from your account to a
#' Worker
#'
#' @description
#' The [`send_bonus`][mturk_send_bonus] operation issues a payment of money
#' from your account to a Worker. This payment happens separately from the
#' reward you pay to the Worker when you approve the Worker's assignment.
#' The SendBonus operation requires the Worker's ID and the assignment ID
#' as parameters to initiate payment of the bonus. You must include a
#' message that explains the reason for the bonus payment, as the Worker
#' may not be expecting the payment. Amazon Mechanical Turk collects a fee
#' for bonus payments, similar to the HIT listing fee. This operation fails
#' if your account does not have enough funds to pay for both the bonus and
#' the fees.
#'
#' @usage
#' mturk_send_bonus(WorkerId, BonusAmount, AssignmentId, Reason,
#'   UniqueRequestToken)
#'
#' @param WorkerId &#91;required&#93; The ID of the Worker being paid the bonus.
#' @param BonusAmount &#91;required&#93; The Bonus amount is a US Dollar amount specified using a string (for
#' example, "5" represents $5.00 USD and "101.42" represents $101.42 USD).
#' Do not include currency symbols or currency codes.
#' @param AssignmentId &#91;required&#93; The ID of the assignment for which this bonus is paid.
#' @param Reason &#91;required&#93; A message that explains the reason for the bonus payment. The Worker
#' receiving the bonus can see this message.
#' @param UniqueRequestToken A unique identifier for this request, which allows you to retry the call
#' on error without granting multiple bonuses. This is useful in cases such
#' as network timeouts where it is unclear whether or not the call
#' succeeded on the server. If the bonus already exists in the system from
#' a previous call using the same UniqueRequestToken, subsequent calls will
#' return an error with a message containing the request ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$send_bonus(
#'   WorkerId = "string",
#'   BonusAmount = "string",
#'   AssignmentId = "string",
#'   Reason = "string",
#'   UniqueRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_send_bonus
#'
#' @aliases mturk_send_bonus
mturk_send_bonus <- function(WorkerId, BonusAmount, AssignmentId, Reason, UniqueRequestToken = NULL) {
  op <- new_operation(
    name = "SendBonus",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$send_bonus_input(WorkerId = WorkerId, BonusAmount = BonusAmount, AssignmentId = AssignmentId, Reason = Reason, UniqueRequestToken = UniqueRequestToken)
  output <- .mturk$send_bonus_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$send_bonus <- mturk_send_bonus

#' The SendTestEventNotification operation causes Amazon Mechanical Turk to
#' send a notification message as if a HIT event occurred, according to the
#' provided notification specification
#'
#' @description
#' The [`send_test_event_notification`][mturk_send_test_event_notification]
#' operation causes Amazon Mechanical Turk to send a notification message
#' as if a HIT event occurred, according to the provided notification
#' specification. This allows you to test notifications without setting up
#' notifications for a real HIT type and trying to trigger them using the
#' website. When you call this operation, the service attempts to send the
#' test notification immediately.
#'
#' @usage
#' mturk_send_test_event_notification(Notification, TestEventType)
#'
#' @param Notification &#91;required&#93; The notification specification to test. This value is identical to the
#' value you would provide to the UpdateNotificationSettings operation when
#' you establish the notification specification for a HIT type.
#' @param TestEventType &#91;required&#93; The event to simulate to test the notification specification. This event
#' is included in the test message even if the notification specification
#' does not include the event type. The notification specification does not
#' filter out the test event.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$send_test_event_notification(
#'   Notification = list(
#'     Destination = "string",
#'     Transport = "Email"|"SQS"|"SNS",
#'     Version = "string",
#'     EventTypes = list(
#'       "AssignmentAccepted"|"AssignmentAbandoned"|"AssignmentReturned"|"AssignmentSubmitted"|"AssignmentRejected"|"AssignmentApproved"|"HITCreated"|"HITExpired"|"HITReviewable"|"HITExtended"|"HITDisposed"|"Ping"
#'     )
#'   ),
#'   TestEventType = "AssignmentAccepted"|"AssignmentAbandoned"|"AssignmentReturned"|"AssignmentSubmitted"|"AssignmentRejected"|"AssignmentApproved"|"HITCreated"|"HITExpired"|"HITReviewable"|"HITExtended"|"HITDisposed"|"Ping"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_send_test_event_notification
#'
#' @aliases mturk_send_test_event_notification
mturk_send_test_event_notification <- function(Notification, TestEventType) {
  op <- new_operation(
    name = "SendTestEventNotification",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$send_test_event_notification_input(Notification = Notification, TestEventType = TestEventType)
  output <- .mturk$send_test_event_notification_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$send_test_event_notification <- mturk_send_test_event_notification

#' The UpdateExpirationForHIT operation allows you update the expiration
#' time of a HIT
#'
#' @description
#' The [`update_expiration_for_hit`][mturk_update_expiration_for_hit]
#' operation allows you update the expiration time of a HIT. If you update
#' it to a time in the past, the HIT will be immediately expired.
#'
#' @usage
#' mturk_update_expiration_for_hit(HITId, ExpireAt)
#'
#' @param HITId &#91;required&#93; The HIT to update.
#' @param ExpireAt &#91;required&#93; The date and time at which you want the HIT to expire
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_expiration_for_hit(
#'   HITId = "string",
#'   ExpireAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_update_expiration_for_hit
#'
#' @aliases mturk_update_expiration_for_hit
mturk_update_expiration_for_hit <- function(HITId, ExpireAt) {
  op <- new_operation(
    name = "UpdateExpirationForHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$update_expiration_for_hit_input(HITId = HITId, ExpireAt = ExpireAt)
  output <- .mturk$update_expiration_for_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$update_expiration_for_hit <- mturk_update_expiration_for_hit

#' The UpdateHITReviewStatus operation updates the status of a HIT
#'
#' @description
#' The [`update_hit_review_status`][mturk_update_hit_review_status]
#' operation updates the status of a HIT. If the status is Reviewable, this
#' operation can update the status to Reviewing, or it can revert a
#' Reviewing HIT back to the Reviewable status.
#'
#' @usage
#' mturk_update_hit_review_status(HITId, Revert)
#'
#' @param HITId &#91;required&#93; The ID of the HIT to update.
#' @param Revert Specifies how to update the HIT status. Default is `False`.
#' 
#' -   Setting this to false will only transition a HIT from `Reviewable`
#'     to `Reviewing`
#' 
#' -   Setting this to true will only transition a HIT from `Reviewing` to
#'     `Reviewable`
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_hit_review_status(
#'   HITId = "string",
#'   Revert = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_update_hit_review_status
#'
#' @aliases mturk_update_hit_review_status
mturk_update_hit_review_status <- function(HITId, Revert = NULL) {
  op <- new_operation(
    name = "UpdateHITReviewStatus",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$update_hit_review_status_input(HITId = HITId, Revert = Revert)
  output <- .mturk$update_hit_review_status_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$update_hit_review_status <- mturk_update_hit_review_status

#' The UpdateHITTypeOfHIT operation allows you to change the HITType
#' properties of a HIT
#'
#' @description
#' The [`update_hit_type_of_hit`][mturk_update_hit_type_of_hit] operation
#' allows you to change the HITType properties of a HIT. This operation
#' disassociates the HIT from its old HITType properties and associates it
#' with the new HITType properties. The HIT takes on the properties of the
#' new HITType in place of the old ones.
#'
#' @usage
#' mturk_update_hit_type_of_hit(HITId, HITTypeId)
#'
#' @param HITId &#91;required&#93; The HIT to update.
#' @param HITTypeId &#91;required&#93; The ID of the new HIT type.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_hit_type_of_hit(
#'   HITId = "string",
#'   HITTypeId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_update_hit_type_of_hit
#'
#' @aliases mturk_update_hit_type_of_hit
mturk_update_hit_type_of_hit <- function(HITId, HITTypeId) {
  op <- new_operation(
    name = "UpdateHITTypeOfHIT",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$update_hit_type_of_hit_input(HITId = HITId, HITTypeId = HITTypeId)
  output <- .mturk$update_hit_type_of_hit_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$update_hit_type_of_hit <- mturk_update_hit_type_of_hit

#' The UpdateNotificationSettings operation creates, updates, disables or
#' re-enables notifications for a HIT type
#'
#' @description
#' The [`update_notification_settings`][mturk_update_notification_settings]
#' operation creates, updates, disables or re-enables notifications for a
#' HIT type. If you call the UpdateNotificationSettings operation for a HIT
#' type that already has a notification specification, the operation
#' replaces the old specification with a new one. You can call the
#' UpdateNotificationSettings operation to enable or disable notifications
#' for the HIT type, without having to modify the notification
#' specification itself by providing updates to the Active status without
#' specifying a new notification specification. To change the Active status
#' of a HIT type's notifications, the HIT type must already have a
#' notification specification, or one must be provided in the same call to
#' [`update_notification_settings`][mturk_update_notification_settings].
#'
#' @usage
#' mturk_update_notification_settings(HITTypeId, Notification, Active)
#'
#' @param HITTypeId &#91;required&#93; The ID of the HIT type whose notification specification is being
#' updated.
#' @param Notification The notification specification for the HIT type.
#' @param Active Specifies whether notifications are sent for HITs of this HIT type,
#' according to the notification specification. You must specify either the
#' Notification parameter or the Active parameter for the call to
#' UpdateNotificationSettings to succeed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_notification_settings(
#'   HITTypeId = "string",
#'   Notification = list(
#'     Destination = "string",
#'     Transport = "Email"|"SQS"|"SNS",
#'     Version = "string",
#'     EventTypes = list(
#'       "AssignmentAccepted"|"AssignmentAbandoned"|"AssignmentReturned"|"AssignmentSubmitted"|"AssignmentRejected"|"AssignmentApproved"|"HITCreated"|"HITExpired"|"HITReviewable"|"HITExtended"|"HITDisposed"|"Ping"
#'     )
#'   ),
#'   Active = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_update_notification_settings
#'
#' @aliases mturk_update_notification_settings
mturk_update_notification_settings <- function(HITTypeId, Notification = NULL, Active = NULL) {
  op <- new_operation(
    name = "UpdateNotificationSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$update_notification_settings_input(HITTypeId = HITTypeId, Notification = Notification, Active = Active)
  output <- .mturk$update_notification_settings_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$update_notification_settings <- mturk_update_notification_settings

#' The UpdateQualificationType operation modifies the attributes of an
#' existing Qualification type, which is represented by a QualificationType
#' data structure
#'
#' @description
#' The [`update_qualification_type`][mturk_update_qualification_type]
#' operation modifies the attributes of an existing Qualification type,
#' which is represented by a QualificationType data structure. Only the
#' owner of a Qualification type can modify its attributes.
#' 
#' Most attributes of a Qualification type can be changed after the type
#' has been created. However, the Name and Keywords fields cannot be
#' modified. The RetryDelayInSeconds parameter can be modified or added to
#' change the delay or to enable retries, but RetryDelayInSeconds cannot be
#' used to disable retries.
#' 
#' You can use this operation to update the test for a Qualification type.
#' The test is updated based on the values specified for the Test,
#' TestDurationInSeconds and AnswerKey parameters. All three parameters
#' specify the updated test. If you are updating the test for a type, you
#' must specify the Test and TestDurationInSeconds parameters. The
#' AnswerKey parameter is optional; omitting it specifies that the updated
#' test does not have an answer key.
#' 
#' If you omit the Test parameter, the test for the Qualification type is
#' unchanged. There is no way to remove a test from a Qualification type
#' that has one. If the type already has a test, you cannot update it to be
#' AutoGranted. If the Qualification type does not have a test and one is
#' provided by an update, the type will henceforth have a test.
#' 
#' If you want to update the test duration or answer key for an existing
#' test without changing the questions, you must specify a Test parameter
#' with the original questions, along with the updated values.
#' 
#' If you provide an updated Test but no AnswerKey, the new test will not
#' have an answer key. Requests for such Qualifications must be granted
#' manually.
#' 
#' You can also update the AutoGranted and AutoGrantedValue attributes of
#' the Qualification type.
#'
#' @usage
#' mturk_update_qualification_type(QualificationTypeId, Description,
#'   QualificationTypeStatus, Test, AnswerKey, TestDurationInSeconds,
#'   RetryDelayInSeconds, AutoGranted, AutoGrantedValue)
#'
#' @param QualificationTypeId &#91;required&#93; The ID of the Qualification type to update.
#' @param Description The new description of the Qualification type.
#' @param QualificationTypeStatus The new status of the Qualification type - Active | Inactive
#' @param Test The questions for the Qualification test a Worker must answer correctly
#' to obtain a Qualification of this type. If this parameter is specified,
#' `TestDurationInSeconds` must also be specified.
#' 
#' Constraints: Must not be longer than 65535 bytes. Must be a QuestionForm
#' data structure. This parameter cannot be specified if AutoGranted is
#' true.
#' 
#' Constraints: None. If not specified, the Worker may request the
#' Qualification without answering any questions.
#' @param AnswerKey The answers to the Qualification test specified in the Test parameter,
#' in the form of an AnswerKey data structure.
#' @param TestDurationInSeconds The number of seconds the Worker has to complete the Qualification test,
#' starting from the time the Worker requests the Qualification.
#' @param RetryDelayInSeconds The amount of time, in seconds, that Workers must wait after requesting
#' a Qualification of the specified Qualification type before they can
#' retry the Qualification request. It is not possible to disable retries
#' for a Qualification type after it has been created with retries enabled.
#' If you want to disable retries, you must dispose of the existing
#' retry-enabled Qualification type using DisposeQualificationType and then
#' create a new Qualification type with retries disabled using
#' CreateQualificationType.
#' @param AutoGranted Specifies whether requests for the Qualification type are granted
#' immediately, without prompting the Worker with a Qualification test.
#' 
#' Constraints: If the Test parameter is specified, this parameter cannot
#' be true.
#' @param AutoGrantedValue The Qualification value to use for automatically granted Qualifications.
#' This parameter is used only if the AutoGranted parameter is true.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   QualificationType = list(
#'     QualificationTypeId = "string",
#'     CreationTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Name = "string",
#'     Description = "string",
#'     Keywords = "string",
#'     QualificationTypeStatus = "Active"|"Inactive",
#'     Test = "string",
#'     TestDurationInSeconds = 123,
#'     AnswerKey = "string",
#'     RetryDelayInSeconds = 123,
#'     IsRequestable = TRUE|FALSE,
#'     AutoGranted = TRUE|FALSE,
#'     AutoGrantedValue = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_qualification_type(
#'   QualificationTypeId = "string",
#'   Description = "string",
#'   QualificationTypeStatus = "Active"|"Inactive",
#'   Test = "string",
#'   AnswerKey = "string",
#'   TestDurationInSeconds = 123,
#'   RetryDelayInSeconds = 123,
#'   AutoGranted = TRUE|FALSE,
#'   AutoGrantedValue = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mturk_update_qualification_type
#'
#' @aliases mturk_update_qualification_type
mturk_update_qualification_type <- function(QualificationTypeId, Description = NULL, QualificationTypeStatus = NULL, Test = NULL, AnswerKey = NULL, TestDurationInSeconds = NULL, RetryDelayInSeconds = NULL, AutoGranted = NULL, AutoGrantedValue = NULL) {
  op <- new_operation(
    name = "UpdateQualificationType",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list()
  )
  input <- .mturk$update_qualification_type_input(QualificationTypeId = QualificationTypeId, Description = Description, QualificationTypeStatus = QualificationTypeStatus, Test = Test, AnswerKey = AnswerKey, TestDurationInSeconds = TestDurationInSeconds, RetryDelayInSeconds = RetryDelayInSeconds, AutoGranted = AutoGranted, AutoGrantedValue = AutoGrantedValue)
  output <- .mturk$update_qualification_type_output()
  config <- get_config()
  svc <- .mturk$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mturk$operations$update_qualification_type <- mturk_update_qualification_type

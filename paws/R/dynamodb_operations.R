# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include dynamodb_service.R
NULL

#' This operation allows you to perform batch reads or writes on data
#' stored in DynamoDB, using PartiQL
#'
#' @description
#' This operation allows you to perform batch reads or writes on data
#' stored in DynamoDB, using PartiQL. Each read statement in a
#' [`batch_execute_statement`][dynamodb_batch_execute_statement] must
#' specify an equality condition on all key attributes. This enforces that
#' each `SELECT` statement in a batch returns at most a single item. For
#' more information, see [Running batch operations with PartiQL for
#' DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ql-reference.multiplestatements.batching.html)
#' .
#' 
#' The entire batch must consist of either read statements or write
#' statements, you cannot mix both in one batch.
#' 
#' A HTTP 200 response does not mean that all statements in the
#' BatchExecuteStatement succeeded. Error details for individual statements
#' can be found under the
#' [Error](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchStatementResponse.html#DDB-Type-BatchStatementResponse-Error)
#' field of the `BatchStatementResponse` for each statement.
#'
#' @usage
#' dynamodb_batch_execute_statement(Statements, ReturnConsumedCapacity)
#'
#' @param Statements &#91;required&#93; The list of PartiQL statements representing the batch to run.
#' @param ReturnConsumedCapacity 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Responses = list(
#'     list(
#'       Error = list(
#'         Code = "ConditionalCheckFailed"|"ItemCollectionSizeLimitExceeded"|"RequestLimitExceeded"|"ValidationError"|"ProvisionedThroughputExceeded"|"TransactionConflict"|"ThrottlingError"|"InternalServerError"|"ResourceNotFound"|"AccessDenied"|"DuplicateItem",
#'         Message = "string",
#'         Item = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       TableName = "string",
#'       Item = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_execute_statement(
#'   Statements = list(
#'     list(
#'       Statement = "string",
#'       Parameters = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       ),
#'       ConsistentRead = TRUE|FALSE,
#'       ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_batch_execute_statement
#'
#' @aliases dynamodb_batch_execute_statement
dynamodb_batch_execute_statement <- function(Statements, ReturnConsumedCapacity = NULL) {
  op <- new_operation(
    name = "BatchExecuteStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$batch_execute_statement_input(Statements = Statements, ReturnConsumedCapacity = ReturnConsumedCapacity)
  output <- .dynamodb$batch_execute_statement_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$batch_execute_statement <- dynamodb_batch_execute_statement

#' The BatchGetItem operation returns the attributes of one or more items
#' from one or more tables
#'
#' @description
#' The [`batch_get_item`][dynamodb_batch_get_item] operation returns the
#' attributes of one or more items from one or more tables. You identify
#' requested items by primary key.
#' 
#' A single operation can retrieve up to 16 MB of data, which can contain
#' as many as 100 items. [`batch_get_item`][dynamodb_batch_get_item]
#' returns a partial result if the response size limit is exceeded, the
#' table's provisioned throughput is exceeded, more than 1MB per partition
#' is requested, or an internal processing failure occurs. If a partial
#' result is returned, the operation returns a value for `UnprocessedKeys`.
#' You can use this value to retry the operation starting with the next
#' item to get.
#' 
#' If you request more than 100 items,
#' [`batch_get_item`][dynamodb_batch_get_item] returns a
#' `ValidationException` with the message "Too many items requested for the
#' BatchGetItem call."
#' 
#' For example, if you ask to retrieve 100 items, but each individual item
#' is 300 KB in size, the system returns 52 items (so as not to exceed the
#' 16 MB limit). It also returns an appropriate `UnprocessedKeys` value so
#' you can get the next page of results. If desired, your application can
#' include its own logic to assemble the pages of results into one dataset.
#' 
#' If *none* of the items can be processed due to insufficient provisioned
#' throughput on all of the tables in the request, then
#' [`batch_get_item`][dynamodb_batch_get_item] returns a
#' `ProvisionedThroughputExceededException`. If *at least one* of the items
#' is successfully processed, then
#' [`batch_get_item`][dynamodb_batch_get_item] completes successfully,
#' while returning the keys of the unread items in `UnprocessedKeys`.
#' 
#' If DynamoDB returns any unprocessed items, you should retry the batch
#' operation on those items. However, *we strongly recommend that you use
#' an exponential backoff algorithm*. If you retry the batch operation
#' immediately, the underlying read or write requests can still fail due to
#' throttling on the individual tables. If you delay the batch operation
#' using exponential backoff, the individual requests in the batch are much
#' more likely to succeed.
#' 
#' For more information, see [Batch Operations and Error
#' Handling](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#BatchOperations)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' By default, [`batch_get_item`][dynamodb_batch_get_item] performs
#' eventually consistent reads on every table in the request. If you want
#' strongly consistent reads instead, you can set `ConsistentRead` to
#' `true` for any or all tables.
#' 
#' In order to minimize response latency,
#' [`batch_get_item`][dynamodb_batch_get_item] may retrieve items in
#' parallel.
#' 
#' When designing your application, keep in mind that DynamoDB does not
#' return items in any particular order. To help parse the response by
#' item, include the primary key values for the items in your request in
#' the `ProjectionExpression` parameter.
#' 
#' If a requested item does not exist, it is not returned in the result.
#' Requests for nonexistent items consume the minimum read capacity units
#' according to the type of read. For more information, see [Working with
#' Tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' [`batch_get_item`][dynamodb_batch_get_item] will result in a
#' `ValidationException` if the same key is specified multiple times.
#'
#' @usage
#' dynamodb_batch_get_item(RequestItems, ReturnConsumedCapacity)
#'
#' @param RequestItems &#91;required&#93; A map of one or more table names or table ARNs and, for each table, a
#' map that describes one or more items to retrieve from that table. Each
#' table name or ARN can be used only once per
#' [`batch_get_item`][dynamodb_batch_get_item] request.
#' 
#' Each element in the map of items to retrieve consists of the following:
#' 
#' -   `ConsistentRead` - If `true`, a strongly consistent read is used; if
#'     `false` (the default), an eventually consistent read is used.
#' 
#' -   `ExpressionAttributeNames` - One or more substitution tokens for
#'     attribute names in the `ProjectionExpression` parameter. The
#'     following are some use cases for using `ExpressionAttributeNames`:
#' 
#'     -   To access an attribute whose name conflicts with a DynamoDB
#'         reserved word.
#' 
#'     -   To create a placeholder for repeating occurrences of an
#'         attribute name in an expression.
#' 
#'     -   To prevent special characters in an attribute name from being
#'         misinterpreted in an expression.
#' 
#'     Use the **#** character in an expression to dereference an
#'     attribute name. For example, consider the following attribute name:
#' 
#'     -   `Percentile`
#' 
#'     The name of this attribute conflicts with a reserved word, so it
#'     cannot be used directly in an expression. (For the complete list of
#'     reserved words, see [Reserved
#'     Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#'     in the *Amazon DynamoDB Developer Guide*). To work around this, you
#'     could specify the following for `ExpressionAttributeNames`:
#' 
#'     -   `{"#P":"Percentile"}`
#' 
#'     You could then use this substitution in an expression, as in this
#'     example:
#' 
#'     -   `#P = :val`
#' 
#'     Tokens that begin with the **:** character are *expression attribute
#'     values*, which are placeholders for the actual value at runtime.
#' 
#'     For more information about expression attribute names, see
#'     [Accessing Item
#'     Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#'     in the *Amazon DynamoDB Developer Guide*.
#' 
#' -   `Keys` - An array of primary key attribute values that define
#'     specific items in the table. For each primary key, you must provide
#'     *all* of the key attributes. For example, with a simple primary key,
#'     you only need to provide the partition key value. For a composite
#'     key, you must provide *both* the partition key value and the sort
#'     key value.
#' 
#' -   `ProjectionExpression` - A string that identifies one or more
#'     attributes to retrieve from the table. These attributes can include
#'     scalars, sets, or elements of a JSON document. The attributes in the
#'     expression must be separated by commas.
#' 
#'     If no attribute names are specified, then all attributes are
#'     returned. If any of the requested attributes are not found, they do
#'     not appear in the result.
#' 
#'     For more information, see [Accessing Item
#'     Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#'     in the *Amazon DynamoDB Developer Guide*.
#' 
#' -   `AttributesToGet` - This is a legacy parameter. Use
#'     `ProjectionExpression` instead. For more information, see
#'     [AttributesToGet](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
#'     in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnConsumedCapacity 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Responses = list(
#'     list(
#'       list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   UnprocessedKeys = list(
#'     list(
#'       Keys = list(
#'         list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       AttributesToGet = list(
#'         "string"
#'       ),
#'       ConsistentRead = TRUE|FALSE,
#'       ProjectionExpression = "string",
#'       ExpressionAttributeNames = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_item(
#'   RequestItems = list(
#'     list(
#'       Keys = list(
#'         list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         )
#'       ),
#'       AttributesToGet = list(
#'         "string"
#'       ),
#'       ConsistentRead = TRUE|FALSE,
#'       ProjectionExpression = "string",
#'       ExpressionAttributeNames = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example reads multiple items from the Music table using a batch of
#' # three GetItem requests.  Only the AlbumTitle attribute is returned.
#' svc$batch_get_item(
#'   RequestItems = list(
#'     Music = list(
#'       Keys = list(
#'         list(
#'           Artist = list(
#'             S = "No One You Know"
#'           ),
#'           SongTitle = list(
#'             S = "Call Me Today"
#'           )
#'         ),
#'         list(
#'           Artist = list(
#'             S = "Acme Band"
#'           ),
#'           SongTitle = list(
#'             S = "Happy Day"
#'           )
#'         ),
#'         list(
#'           Artist = list(
#'             S = "No One You Know"
#'           ),
#'           SongTitle = list(
#'             S = "Scared of My Shadow"
#'           )
#'         )
#'       ),
#'       ProjectionExpression = "AlbumTitle"
#'     )
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_batch_get_item
#'
#' @aliases dynamodb_batch_get_item
dynamodb_batch_get_item <- function(RequestItems, ReturnConsumedCapacity = NULL) {
  op <- new_operation(
    name = "BatchGetItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "RequestItems", output_token = "UnprocessedKeys"),
    stream_api = FALSE
  )
  input <- .dynamodb$batch_get_item_input(RequestItems = RequestItems, ReturnConsumedCapacity = ReturnConsumedCapacity)
  output <- .dynamodb$batch_get_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$batch_get_item <- dynamodb_batch_get_item

#' The BatchWriteItem operation puts or deletes multiple items in one or
#' more tables
#'
#' @description
#' The [`batch_write_item`][dynamodb_batch_write_item] operation puts or
#' deletes multiple items in one or more tables. A single call to
#' [`batch_write_item`][dynamodb_batch_write_item] can transmit up to 16MB
#' of data over the network, consisting of up to 25 item put or delete
#' operations. While individual items can be up to 400 KB once stored, it's
#' important to note that an item's representation might be greater than
#' 400KB while being sent in DynamoDB's JSON format for the API call. For
#' more details on this distinction, see [Naming Rules and Data
#' Types](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html).
#' 
#' [`batch_write_item`][dynamodb_batch_write_item] cannot update items. If
#' you perform a [`batch_write_item`][dynamodb_batch_write_item] operation
#' on an existing item, that item's values will be overwritten by the
#' operation and it will appear like it was updated. To update items, we
#' recommend you use the [`update_item`][dynamodb_update_item] action.
#' 
#' The individual [`put_item`][dynamodb_put_item] and
#' [`delete_item`][dynamodb_delete_item] operations specified in
#' [`batch_write_item`][dynamodb_batch_write_item] are atomic; however
#' [`batch_write_item`][dynamodb_batch_write_item] as a whole is not. If
#' any requested operations fail because the table's provisioned throughput
#' is exceeded or an internal processing failure occurs, the failed
#' operations are returned in the `UnprocessedItems` response parameter.
#' You can investigate and optionally resend the requests. Typically, you
#' would call [`batch_write_item`][dynamodb_batch_write_item] in a loop.
#' Each iteration would check for unprocessed items and submit a new
#' [`batch_write_item`][dynamodb_batch_write_item] request with those
#' unprocessed items until all items have been processed.
#' 
#' For tables and indexes with provisioned capacity, if none of the items
#' can be processed due to insufficient provisioned throughput on all of
#' the tables in the request, then
#' [`batch_write_item`][dynamodb_batch_write_item] returns a
#' `ProvisionedThroughputExceededException`. For all tables and indexes, if
#' none of the items can be processed due to other throttling scenarios
#' (such as exceeding partition level limits), then
#' [`batch_write_item`][dynamodb_batch_write_item] returns a
#' `ThrottlingException`.
#' 
#' If DynamoDB returns any unprocessed items, you should retry the batch
#' operation on those items. However, *we strongly recommend that you use
#' an exponential backoff algorithm*. If you retry the batch operation
#' immediately, the underlying read or write requests can still fail due to
#' throttling on the individual tables. If you delay the batch operation
#' using exponential backoff, the individual requests in the batch are much
#' more likely to succeed.
#' 
#' For more information, see [Batch Operations and Error
#' Handling](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.BatchOperations)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' With [`batch_write_item`][dynamodb_batch_write_item], you can
#' efficiently write or delete large amounts of data, such as from Amazon
#' EMR, or copy data from another database into DynamoDB. In order to
#' improve performance with these large-scale operations,
#' [`batch_write_item`][dynamodb_batch_write_item] does not behave in the
#' same way as individual [`put_item`][dynamodb_put_item] and
#' [`delete_item`][dynamodb_delete_item] calls would. For example, you
#' cannot specify conditions on individual put and delete requests, and
#' [`batch_write_item`][dynamodb_batch_write_item] does not return deleted
#' items in the response.
#' 
#' If you use a programming language that supports concurrency, you can use
#' threads to write items in parallel. Your application must include the
#' necessary logic to manage the threads. With languages that don't support
#' threading, you must update or delete the specified items one at a time.
#' In both situations, [`batch_write_item`][dynamodb_batch_write_item]
#' performs the specified put and delete operations in parallel, giving you
#' the power of the thread pool approach without having to introduce
#' complexity into your application.
#' 
#' Parallel processing reduces latency, but each specified put and delete
#' request consumes the same number of write capacity units whether it is
#' processed in parallel or not. Delete operations on nonexistent items
#' consume one write capacity unit.
#' 
#' If one or more of the following is true, DynamoDB rejects the entire
#' batch write operation:
#' 
#' -   One or more tables specified in the
#'     [`batch_write_item`][dynamodb_batch_write_item] request does not
#'     exist.
#' 
#' -   Primary key attributes specified on an item in the request do not
#'     match those in the corresponding table's primary key schema.
#' 
#' -   You try to perform multiple operations on the same item in the same
#'     [`batch_write_item`][dynamodb_batch_write_item] request. For
#'     example, you cannot put and delete the same item in the same
#'     [`batch_write_item`][dynamodb_batch_write_item] request.
#' 
#' -   Your request contains at least two items with identical hash and
#'     range keys (which essentially is two put operations).
#' 
#' -   There are more than 25 requests in the batch.
#' 
#' -   Any individual item in a batch exceeds 400 KB.
#' 
#' -   The total request size exceeds 16 MB.
#' 
#' -   Any individual items with keys exceeding the key length limits. For
#'     a partition key, the limit is 2048 bytes and for a sort key, the
#'     limit is 1024 bytes.
#'
#' @usage
#' dynamodb_batch_write_item(RequestItems, ReturnConsumedCapacity,
#'   ReturnItemCollectionMetrics)
#'
#' @param RequestItems &#91;required&#93; A map of one or more table names or table ARNs and, for each table, a
#' list of operations to be performed (`DeleteRequest` or `PutRequest`).
#' Each element in the map consists of the following:
#' 
#' -   `DeleteRequest` - Perform a [`delete_item`][dynamodb_delete_item]
#'     operation on the specified item. The item to be deleted is
#'     identified by a `Key` subelement:
#' 
#'     -   `Key` - A map of primary key attribute values that uniquely
#'         identify the item. Each entry in this map consists of an
#'         attribute name and an attribute value. For each primary key, you
#'         must provide *all* of the key attributes. For example, with a
#'         simple primary key, you only need to provide a value for the
#'         partition key. For a composite primary key, you must provide
#'         values for *both* the partition key and the sort key.
#' 
#' -   `PutRequest` - Perform a [`put_item`][dynamodb_put_item] operation
#'     on the specified item. The item to be put is identified by an `Item`
#'     subelement:
#' 
#'     -   `Item` - A map of attributes and their values. Each entry in
#'         this map consists of an attribute name and an attribute value.
#'         Attribute values must not be null; string and binary type
#'         attributes must have lengths greater than zero; and set type
#'         attributes must not be empty. Requests that contain empty values
#'         are rejected with a `ValidationException` exception.
#' 
#'         If you specify any attributes that are part of an index key,
#'         then the data types for those attributes must match those of the
#'         schema in the table's attribute definition.
#' @param ReturnConsumedCapacity 
#' @param ReturnItemCollectionMetrics Determines whether item collection metrics are returned. If set to
#' `SIZE`, the response includes statistics about item collections, if any,
#' that were modified during the operation are returned in the response. If
#' set to `NONE` (the default), no statistics are returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UnprocessedItems = list(
#'     list(
#'       list(
#'         PutRequest = list(
#'           Item = list(
#'             list(
#'               S = "string",
#'               N = "string",
#'               B = raw,
#'               SS = list(
#'                 "string"
#'               ),
#'               NS = list(
#'                 "string"
#'               ),
#'               BS = list(
#'                 raw
#'               ),
#'               M = list(
#'                 list()
#'               ),
#'               L = list(
#'                 list()
#'               ),
#'               NULL = TRUE|FALSE,
#'               BOOL = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         DeleteRequest = list(
#'           Key = list(
#'             list(
#'               S = "string",
#'               N = "string",
#'               B = raw,
#'               SS = list(
#'                 "string"
#'               ),
#'               NS = list(
#'                 "string"
#'               ),
#'               BS = list(
#'                 raw
#'               ),
#'               M = list(
#'                 list()
#'               ),
#'               L = list(
#'                 list()
#'               ),
#'               NULL = TRUE|FALSE,
#'               BOOL = TRUE|FALSE
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ItemCollectionMetrics = list(
#'     list(
#'       list(
#'         ItemCollectionKey = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         SizeEstimateRangeGB = list(
#'           123.0
#'         )
#'       )
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_write_item(
#'   RequestItems = list(
#'     list(
#'       list(
#'         PutRequest = list(
#'           Item = list(
#'             list(
#'               S = "string",
#'               N = "string",
#'               B = raw,
#'               SS = list(
#'                 "string"
#'               ),
#'               NS = list(
#'                 "string"
#'               ),
#'               BS = list(
#'                 raw
#'               ),
#'               M = list(
#'                 list()
#'               ),
#'               L = list(
#'                 list()
#'               ),
#'               NULL = TRUE|FALSE,
#'               BOOL = TRUE|FALSE
#'             )
#'           )
#'         ),
#'         DeleteRequest = list(
#'           Key = list(
#'             list(
#'               S = "string",
#'               N = "string",
#'               B = raw,
#'               SS = list(
#'                 "string"
#'               ),
#'               NS = list(
#'                 "string"
#'               ),
#'               BS = list(
#'                 raw
#'               ),
#'               M = list(
#'                 list()
#'               ),
#'               L = list(
#'                 list()
#'               ),
#'               NULL = TRUE|FALSE,
#'               BOOL = TRUE|FALSE
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ReturnItemCollectionMetrics = "SIZE"|"NONE"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example adds three new items to the Music table using a batch of
#' # three PutItem requests.
#' svc$batch_write_item(
#'   RequestItems = list(
#'     Music = list(
#'       list(
#'         PutRequest = list(
#'           Item = list(
#'             AlbumTitle = list(
#'               S = "Somewhat Famous"
#'             ),
#'             Artist = list(
#'               S = "No One You Know"
#'             ),
#'             SongTitle = list(
#'               S = "Call Me Today"
#'             )
#'           )
#'         )
#'       ),
#'       list(
#'         PutRequest = list(
#'           Item = list(
#'             AlbumTitle = list(
#'               S = "Songs About Life"
#'             ),
#'             Artist = list(
#'               S = "Acme Band"
#'             ),
#'             SongTitle = list(
#'               S = "Happy Day"
#'             )
#'           )
#'         )
#'       ),
#'       list(
#'         PutRequest = list(
#'           Item = list(
#'             AlbumTitle = list(
#'               S = "Blue Sky Blues"
#'             ),
#'             Artist = list(
#'               S = "No One You Know"
#'             ),
#'             SongTitle = list(
#'               S = "Scared of My Shadow"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_batch_write_item
#'
#' @aliases dynamodb_batch_write_item
dynamodb_batch_write_item <- function(RequestItems, ReturnConsumedCapacity = NULL, ReturnItemCollectionMetrics = NULL) {
  op <- new_operation(
    name = "BatchWriteItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$batch_write_item_input(RequestItems = RequestItems, ReturnConsumedCapacity = ReturnConsumedCapacity, ReturnItemCollectionMetrics = ReturnItemCollectionMetrics)
  output <- .dynamodb$batch_write_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$batch_write_item <- dynamodb_batch_write_item

#' Creates a backup for an existing table
#'
#' @description
#' Creates a backup for an existing table.
#' 
#' Each time you create an on-demand backup, the entire table data is
#' backed up. There is no limit to the number of on-demand backups that can
#' be taken.
#' 
#' When you create an on-demand backup, a time marker of the request is
#' cataloged, and the backup is created asynchronously, by applying all
#' changes until the time of the request to the last full table snapshot.
#' Backup requests are processed instantaneously and become available for
#' restore within minutes.
#' 
#' You can call [`create_backup`][dynamodb_create_backup] at a maximum rate
#' of 50 times per second.
#' 
#' All backups in DynamoDB work without consuming any provisioned
#' throughput on the table.
#' 
#' If you submit a backup request on 2018-12-14 at 14:25:00, the backup is
#' guaranteed to contain all data committed to the table up to 14:24:00,
#' and data committed after 14:26:00 will not be. The backup might contain
#' data modifications made between 14:24:00 and 14:26:00. On-demand backup
#' does not support causal consistency.
#' 
#' Along with data, the following are also included on the backups:
#' 
#' -   Global secondary indexes (GSIs)
#' 
#' -   Local secondary indexes (LSIs)
#' 
#' -   Streams
#' 
#' -   Provisioned read and write capacity
#'
#' @usage
#' dynamodb_create_backup(TableName, BackupName)
#'
#' @param TableName &#91;required&#93; The name of the table. You can also provide the Amazon Resource Name
#' (ARN) of the table in this parameter.
#' @param BackupName &#91;required&#93; Specified name for the backup.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BackupDetails = list(
#'     BackupArn = "string",
#'     BackupName = "string",
#'     BackupSizeBytes = 123,
#'     BackupStatus = "CREATING"|"DELETED"|"AVAILABLE",
#'     BackupType = "USER"|"SYSTEM"|"AWS_BACKUP",
#'     BackupCreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     BackupExpiryDateTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_backup(
#'   TableName = "string",
#'   BackupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_create_backup
#'
#' @aliases dynamodb_create_backup
dynamodb_create_backup <- function(TableName, BackupName) {
  op <- new_operation(
    name = "CreateBackup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$create_backup_input(TableName = TableName, BackupName = BackupName)
  output <- .dynamodb$create_backup_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$create_backup <- dynamodb_create_backup

#' Creates a global table from an existing table
#'
#' @description
#' Creates a global table from an existing table. A global table creates a
#' replication relationship between two or more DynamoDB tables with the
#' same table name in the provided Regions.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#' 
#' If you want to add a new replica table to a global table, each of the
#' following conditions must be true:
#' 
#' -   The table must have the same primary key as all of the other
#'     replicas.
#' 
#' -   The table must have the same name as all of the other replicas.
#' 
#' -   The table must have DynamoDB Streams enabled, with the stream
#'     containing both the new and the old images of the item.
#' 
#' -   None of the replica tables in the global table can contain any data.
#' 
#' If global secondary indexes are specified, then the following conditions
#' must also be met:
#' 
#' -   The global secondary indexes must have the same name.
#' 
#' -   The global secondary indexes must have the same hash key and sort
#'     key (if present).
#' 
#' If local secondary indexes are specified, then the following conditions
#' must also be met:
#' 
#' -   The local secondary indexes must have the same name.
#' 
#' -   The local secondary indexes must have the same hash key and sort key
#'     (if present).
#' 
#' Write capacity settings should be set consistently across your replica
#' tables and secondary indexes. DynamoDB strongly recommends enabling auto
#' scaling to manage the write capacity settings for all of your global
#' tables replicas and indexes.
#' 
#' If you prefer to manage write capacity settings manually, you should
#' provision equal replicated write capacity units to your replica tables.
#' You should also provision equal replicated write capacity units to
#' matching secondary indexes across your global table.
#'
#' @usage
#' dynamodb_create_global_table(GlobalTableName, ReplicationGroup)
#'
#' @param GlobalTableName &#91;required&#93; The global table name.
#' @param ReplicationGroup &#91;required&#93; The Regions where the global table needs to be created.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTableDescription = list(
#'     ReplicationGroup = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableArn = "string",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     GlobalTableStatus = "CREATING"|"ACTIVE"|"DELETING"|"UPDATING",
#'     GlobalTableName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_global_table(
#'   GlobalTableName = "string",
#'   ReplicationGroup = list(
#'     list(
#'       RegionName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_create_global_table
#'
#' @aliases dynamodb_create_global_table
dynamodb_create_global_table <- function(GlobalTableName, ReplicationGroup) {
  op <- new_operation(
    name = "CreateGlobalTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$create_global_table_input(GlobalTableName = GlobalTableName, ReplicationGroup = ReplicationGroup)
  output <- .dynamodb$create_global_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$create_global_table <- dynamodb_create_global_table

#' The CreateTable operation adds a new table to your account
#'
#' @description
#' The [`create_table`][dynamodb_create_table] operation adds a new table
#' to your account. In an Amazon Web Services account, table names must be
#' unique within each Region. That is, you can have two tables with same
#' name if you create the tables in different Regions.
#' 
#' [`create_table`][dynamodb_create_table] is an asynchronous operation.
#' Upon receiving a [`create_table`][dynamodb_create_table] request,
#' DynamoDB immediately returns a response with a `TableStatus` of
#' `CREATING`. After the table is created, DynamoDB sets the `TableStatus`
#' to `ACTIVE`. You can perform read and write operations only on an
#' `ACTIVE` table.
#' 
#' You can optionally define secondary indexes on the new table, as part of
#' the [`create_table`][dynamodb_create_table] operation. If you want to
#' create multiple tables with secondary indexes on them, you must create
#' the tables sequentially. Only one table with secondary indexes can be in
#' the `CREATING` state at any given time.
#' 
#' You can use the [`describe_table`][dynamodb_describe_table] action to
#' check the table status.
#'
#' @usage
#' dynamodb_create_table(AttributeDefinitions, TableName, KeySchema,
#'   LocalSecondaryIndexes, GlobalSecondaryIndexes, BillingMode,
#'   ProvisionedThroughput, StreamSpecification, SSESpecification, Tags,
#'   TableClass, DeletionProtectionEnabled, WarmThroughput, ResourcePolicy,
#'   OnDemandThroughput)
#'
#' @param AttributeDefinitions &#91;required&#93; An array of attributes that describe the key schema for the table and
#' indexes.
#' @param TableName &#91;required&#93; The name of the table to create. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#' @param KeySchema &#91;required&#93; Specifies the attributes that make up the primary key for a table or an
#' index. The attributes in `KeySchema` must also be defined in the
#' `AttributeDefinitions` array. For more information, see [Data
#' Model](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' Each `KeySchemaElement` in the array is composed of:
#' 
#' -   `AttributeName` - The name of this key attribute.
#' 
#' -   `KeyType` - The role that the key attribute will assume:
#' 
#'     -   `HASH` - partition key
#' 
#'     -   `RANGE` - sort key
#' 
#' The partition key of an item is also known as its *hash attribute*. The
#' term "hash attribute" derives from the DynamoDB usage of an internal
#' hash function to evenly distribute data items across partitions, based
#' on their partition key values.
#' 
#' The sort key of an item is also known as its *range attribute*. The term
#' "range attribute" derives from the way DynamoDB stores items with the
#' same partition key physically close together, in sorted order by the
#' sort key value.
#' 
#' For a simple primary key (partition key), you must provide exactly one
#' element with a `KeyType` of `HASH`.
#' 
#' For a composite primary key (partition key and sort key), you must
#' provide exactly two elements, in this order: The first element must have
#' a `KeyType` of `HASH`, and the second element must have a `KeyType` of
#' `RANGE`.
#' 
#' For more information, see [Working with
#' Tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param LocalSecondaryIndexes One or more local secondary indexes (the maximum is 5) to be created on
#' the table. Each index is scoped to a given partition key value. There is
#' a 10 GB size limit per partition key value; otherwise, the size of a
#' local secondary index is unconstrained.
#' 
#' Each local secondary index in the array includes the following:
#' 
#' -   `IndexName` - The name of the local secondary index. Must be unique
#'     only for this table.
#' 
#' -   `KeySchema` - Specifies the key schema for the local secondary
#'     index. The key schema must begin with the same partition key as the
#'     table.
#' 
#' -   `Projection` - Specifies attributes that are copied (projected) from
#'     the table into the index. These are in addition to the primary key
#'     attributes and index key attributes, which are automatically
#'     projected. Each attribute specification is composed of:
#' 
#'     -   `ProjectionType` - One of the following:
#' 
#'         -   `KEYS_ONLY` - Only the index and primary keys are projected
#'             into the index.
#' 
#'         -   `INCLUDE` - Only the specified table attributes are
#'             projected into the index. The list of projected attributes
#'             is in `NonKeyAttributes`.
#' 
#'         -   `ALL` - All of the table attributes are projected into the
#'             index.
#' 
#'     -   `NonKeyAttributes` - A list of one or more non-key attribute
#'         names that are projected into the secondary index. The total
#'         count of attributes provided in `NonKeyAttributes`, summed
#'         across all of the secondary indexes, must not exceed 100. If you
#'         project the same attribute into two different indexes, this
#'         counts as two distinct attributes when determining the total.
#'         This limit only applies when you specify the ProjectionType of
#'         `INCLUDE`. You still can specify the ProjectionType of `ALL` to
#'         project all attributes from the source table, even if the table
#'         has more than 100 attributes.
#' @param GlobalSecondaryIndexes One or more global secondary indexes (the maximum is 20) to be created
#' on the table. Each global secondary index in the array includes the
#' following:
#' 
#' -   `IndexName` - The name of the global secondary index. Must be unique
#'     only for this table.
#' 
#' -   `KeySchema` - Specifies the key schema for the global secondary
#'     index.
#' 
#' -   `Projection` - Specifies attributes that are copied (projected) from
#'     the table into the index. These are in addition to the primary key
#'     attributes and index key attributes, which are automatically
#'     projected. Each attribute specification is composed of:
#' 
#'     -   `ProjectionType` - One of the following:
#' 
#'         -   `KEYS_ONLY` - Only the index and primary keys are projected
#'             into the index.
#' 
#'         -   `INCLUDE` - Only the specified table attributes are
#'             projected into the index. The list of projected attributes
#'             is in `NonKeyAttributes`.
#' 
#'         -   `ALL` - All of the table attributes are projected into the
#'             index.
#' 
#'     -   `NonKeyAttributes` - A list of one or more non-key attribute
#'         names that are projected into the secondary index. The total
#'         count of attributes provided in `NonKeyAttributes`, summed
#'         across all of the secondary indexes, must not exceed 100. If you
#'         project the same attribute into two different indexes, this
#'         counts as two distinct attributes when determining the total.
#'         This limit only applies when you specify the ProjectionType of
#'         `INCLUDE`. You still can specify the ProjectionType of `ALL` to
#'         project all attributes from the source table, even if the table
#'         has more than 100 attributes.
#' 
#' -   `ProvisionedThroughput` - The provisioned throughput settings for
#'     the global secondary index, consisting of read and write capacity
#'     units.
#' @param BillingMode Controls how you are charged for read and write throughput and how you
#' manage capacity. This setting can be changed later.
#' 
#' -   `PAY_PER_REQUEST` - We recommend using `PAY_PER_REQUEST` for most
#'     DynamoDB workloads. `PAY_PER_REQUEST` sets the billing mode to
#'     [On-demand capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html).
#' 
#' -   `PROVISIONED` - We recommend using `PROVISIONED` for steady
#'     workloads with predictable growth where capacity requirements can be
#'     reliably forecasted. `PROVISIONED` sets the billing mode to
#'     [Provisioned capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html).
#' @param ProvisionedThroughput Represents the provisioned throughput settings for a specified table or
#' index. The settings can be modified using the
#' [`update_table`][dynamodb_update_table] operation.
#' 
#' If you set BillingMode as `PROVISIONED`, you must specify this property.
#' If you set BillingMode as `PAY_PER_REQUEST`, you cannot specify this
#' property.
#' 
#' For current minimum and maximum provisioned throughput values, see
#' [Service, Account, and Table
#' Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param StreamSpecification The settings for DynamoDB Streams on the table. These settings consist
#' of:
#' 
#' -   `StreamEnabled` - Indicates whether DynamoDB Streams is to be
#'     enabled (true) or disabled (false).
#' 
#' -   `StreamViewType` - When an item in the table is modified,
#'     `StreamViewType` determines what information is written to the
#'     table's stream. Valid values for `StreamViewType` are:
#' 
#'     -   `KEYS_ONLY` - Only the key attributes of the modified item are
#'         written to the stream.
#' 
#'     -   `NEW_IMAGE` - The entire item, as it appears after it was
#'         modified, is written to the stream.
#' 
#'     -   `OLD_IMAGE` - The entire item, as it appeared before it was
#'         modified, is written to the stream.
#' 
#'     -   `NEW_AND_OLD_IMAGES` - Both the new and the old item images of
#'         the item are written to the stream.
#' @param SSESpecification Represents the settings used to enable server-side encryption.
#' @param Tags A list of key-value pairs to label the table. For more information, see
#' [Tagging for
#' DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html).
#' @param TableClass The table class of the new table. Valid values are `STANDARD` and
#' `STANDARD_INFREQUENT_ACCESS`.
#' @param DeletionProtectionEnabled Indicates whether deletion protection is to be enabled (true) or
#' disabled (false) on the table.
#' @param WarmThroughput Represents the warm throughput (in read units per second and write units
#' per second) for creating a table.
#' @param ResourcePolicy An Amazon Web Services resource-based policy document in JSON format
#' that will be attached to the table.
#' 
#' When you attach a resource-based policy while creating a table, the
#' policy application is *strongly consistent*.
#' 
#' The maximum size supported for a resource-based policy document is 20
#' KB. DynamoDB counts whitespaces when calculating the size of a policy
#' against this limit. For a full list of all considerations that apply for
#' resource-based policies, see [Resource-based policy
#' considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
#' 
#' You need to specify the [`create_table`][dynamodb_create_table] and
#' [`put_resource_policy`][dynamodb_put_resource_policy] IAM actions for
#' authorizing a user to create a table with a resource-based policy.
#' @param OnDemandThroughput Sets the maximum number of read and write units for the specified table
#' in on-demand capacity mode. If you use this parameter, you must specify
#' `MaxReadRequestUnits`, `MaxWriteRequestUnits`, or both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableDescription = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_table(
#'   AttributeDefinitions = list(
#'     list(
#'       AttributeName = "string",
#'       AttributeType = "S"|"N"|"B"
#'     )
#'   ),
#'   TableName = "string",
#'   KeySchema = list(
#'     list(
#'       AttributeName = "string",
#'       KeyType = "HASH"|"RANGE"
#'     )
#'   ),
#'   LocalSecondaryIndexes = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   GlobalSecondaryIndexes = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       ),
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       WarmThroughput = list(
#'         ReadUnitsPerSecond = 123,
#'         WriteUnitsPerSecond = 123
#'       )
#'     )
#'   ),
#'   BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'   ProvisionedThroughput = list(
#'     ReadCapacityUnits = 123,
#'     WriteCapacityUnits = 123
#'   ),
#'   StreamSpecification = list(
#'     StreamEnabled = TRUE|FALSE,
#'     StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'   ),
#'   SSESpecification = list(
#'     Enabled = TRUE|FALSE,
#'     SSEType = "AES256"|"KMS",
#'     KMSMasterKeyId = "string"
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'   DeletionProtectionEnabled = TRUE|FALSE,
#'   WarmThroughput = list(
#'     ReadUnitsPerSecond = 123,
#'     WriteUnitsPerSecond = 123
#'   ),
#'   ResourcePolicy = "string",
#'   OnDemandThroughput = list(
#'     MaxReadRequestUnits = 123,
#'     MaxWriteRequestUnits = 123
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example creates a table named Music.
#' svc$create_table(
#'   AttributeDefinitions = list(
#'     list(
#'       AttributeName = "Artist",
#'       AttributeType = "S"
#'     ),
#'     list(
#'       AttributeName = "SongTitle",
#'       AttributeType = "S"
#'     )
#'   ),
#'   KeySchema = list(
#'     list(
#'       AttributeName = "Artist",
#'       KeyType = "HASH"
#'     ),
#'     list(
#'       AttributeName = "SongTitle",
#'       KeyType = "RANGE"
#'     )
#'   ),
#'   ProvisionedThroughput = list(
#'     ReadCapacityUnits = 5L,
#'     WriteCapacityUnits = 5L
#'   ),
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_create_table
#'
#' @aliases dynamodb_create_table
dynamodb_create_table <- function(AttributeDefinitions, TableName, KeySchema, LocalSecondaryIndexes = NULL, GlobalSecondaryIndexes = NULL, BillingMode = NULL, ProvisionedThroughput = NULL, StreamSpecification = NULL, SSESpecification = NULL, Tags = NULL, TableClass = NULL, DeletionProtectionEnabled = NULL, WarmThroughput = NULL, ResourcePolicy = NULL, OnDemandThroughput = NULL) {
  op <- new_operation(
    name = "CreateTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$create_table_input(AttributeDefinitions = AttributeDefinitions, TableName = TableName, KeySchema = KeySchema, LocalSecondaryIndexes = LocalSecondaryIndexes, GlobalSecondaryIndexes = GlobalSecondaryIndexes, BillingMode = BillingMode, ProvisionedThroughput = ProvisionedThroughput, StreamSpecification = StreamSpecification, SSESpecification = SSESpecification, Tags = Tags, TableClass = TableClass, DeletionProtectionEnabled = DeletionProtectionEnabled, WarmThroughput = WarmThroughput, ResourcePolicy = ResourcePolicy, OnDemandThroughput = OnDemandThroughput)
  output <- .dynamodb$create_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$create_table <- dynamodb_create_table

#' Deletes an existing backup of a table
#'
#' @description
#' Deletes an existing backup of a table.
#' 
#' You can call [`delete_backup`][dynamodb_delete_backup] at a maximum rate
#' of 10 times per second.
#'
#' @usage
#' dynamodb_delete_backup(BackupArn)
#'
#' @param BackupArn &#91;required&#93; The ARN associated with the backup.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BackupDescription = list(
#'     BackupDetails = list(
#'       BackupArn = "string",
#'       BackupName = "string",
#'       BackupSizeBytes = 123,
#'       BackupStatus = "CREATING"|"DELETED"|"AVAILABLE",
#'       BackupType = "USER"|"SYSTEM"|"AWS_BACKUP",
#'       BackupCreationDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       BackupExpiryDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     SourceTableDetails = list(
#'       TableName = "string",
#'       TableId = "string",
#'       TableArn = "string",
#'       TableSizeBytes = 123,
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       TableCreationDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       ItemCount = 123,
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST"
#'     ),
#'     SourceTableFeatureDetails = list(
#'       LocalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           )
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           ),
#'           ProvisionedThroughput = list(
#'             ReadCapacityUnits = 123,
#'             WriteCapacityUnits = 123
#'           ),
#'           OnDemandThroughput = list(
#'             MaxReadRequestUnits = 123,
#'             MaxWriteRequestUnits = 123
#'           )
#'         )
#'       ),
#'       StreamDescription = list(
#'         StreamEnabled = TRUE|FALSE,
#'         StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'       ),
#'       TimeToLiveDescription = list(
#'         TimeToLiveStatus = "ENABLING"|"DISABLING"|"ENABLED"|"DISABLED",
#'         AttributeName = "string"
#'       ),
#'       SSEDescription = list(
#'         Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'         SSEType = "AES256"|"KMS",
#'         KMSMasterKeyArn = "string",
#'         InaccessibleEncryptionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_backup(
#'   BackupArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_delete_backup
#'
#' @aliases dynamodb_delete_backup
dynamodb_delete_backup <- function(BackupArn) {
  op <- new_operation(
    name = "DeleteBackup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$delete_backup_input(BackupArn = BackupArn)
  output <- .dynamodb$delete_backup_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$delete_backup <- dynamodb_delete_backup

#' Deletes a single item in a table by primary key
#'
#' @description
#' Deletes a single item in a table by primary key. You can perform a
#' conditional delete operation that deletes the item if it exists, or if
#' it has an expected attribute value.
#' 
#' In addition to deleting an item, you can also return the item's
#' attribute values in the same operation, using the `ReturnValues`
#' parameter.
#' 
#' Unless you specify conditions, the [`delete_item`][dynamodb_delete_item]
#' is an idempotent operation; running it multiple times on the same item
#' or attribute does *not* result in an error response.
#' 
#' Conditional deletes are useful for deleting items only if specific
#' conditions are met. If those conditions are met, DynamoDB performs the
#' delete. Otherwise, the item is not deleted.
#'
#' @usage
#' dynamodb_delete_item(TableName, Key, Expected, ConditionalOperator,
#'   ReturnValues, ReturnConsumedCapacity, ReturnItemCollectionMetrics,
#'   ConditionExpression, ExpressionAttributeNames,
#'   ExpressionAttributeValues, ReturnValuesOnConditionCheckFailure)
#'
#' @param TableName &#91;required&#93; The name of the table from which to delete the item. You can also
#' provide the Amazon Resource Name (ARN) of the table in this parameter.
#' @param Key &#91;required&#93; A map of attribute names to `AttributeValue` objects, representing the
#' primary key of the item to delete.
#' 
#' For the primary key, you must provide all of the key attributes. For
#' example, with a simple primary key, you only need to provide a value for
#' the partition key. For a composite primary key, you must provide values
#' for both the partition key and the sort key.
#' @param Expected This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [Expected](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionalOperator This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [ConditionalOperator](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValues Use `ReturnValues` if you want to get the item attributes as they
#' appeared before they were deleted. For
#' [`delete_item`][dynamodb_delete_item], the valid values are:
#' 
#' -   `NONE` - If `ReturnValues` is not specified, or if its value is
#'     `NONE`, then nothing is returned. (This setting is the default for
#'     `ReturnValues`.)
#' 
#' -   `ALL_OLD` - The content of the old item is returned.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#' 
#' The `ReturnValues` parameter is used by several DynamoDB operations;
#' however, [`delete_item`][dynamodb_delete_item] does not recognize any
#' values other than `NONE` or `ALL_OLD`.
#' @param ReturnConsumedCapacity 
#' @param ReturnItemCollectionMetrics Determines whether item collection metrics are returned. If set to
#' `SIZE`, the response includes statistics about item collections, if any,
#' that were modified during the operation are returned in the response. If
#' set to `NONE` (the default), no statistics are returned.
#' @param ConditionExpression A condition that must be satisfied in order for a conditional
#' [`delete_item`][dynamodb_delete_item] to succeed.
#' 
#' An expression can contain any of the following:
#' 
#' -   Functions:
#'     `attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size`
#' 
#'     These function names are case-sensitive.
#' 
#' -   Comparison operators: `= | <> | < | > | <= | >= | BETWEEN | IN `
#' 
#' -   Logical operators: `AND | OR | NOT`
#' 
#' For more information about condition expressions, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*). To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information on expression attribute names, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeValues One or more values that can be substituted in an expression.
#' 
#' Use the **:** (colon) character in an expression to dereference an
#' attribute value. For example, suppose that you wanted to check whether
#' the value of the *ProductStatus* attribute was one of the following:
#' 
#' `Available | Backordered | Discontinued`
#' 
#' You would first need to specify `ExpressionAttributeValues` as follows:
#' 
#' `{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }`
#' 
#' You could then use these values in an expression, such as this:
#' 
#' `ProductStatus IN (:avail, :back, :disc)`
#' 
#' For more information on expression attribute values, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValuesOnConditionCheckFailure An optional parameter that returns the item attributes for a
#' [`delete_item`][dynamodb_delete_item] operation that failed a condition
#' check.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Attributes = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   ),
#'   ItemCollectionMetrics = list(
#'     ItemCollectionKey = list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     ),
#'     SizeEstimateRangeGB = list(
#'       123.0
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_item(
#'   TableName = "string",
#'   Key = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   Expected = list(
#'     list(
#'       Value = list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       ),
#'       Exists = TRUE|FALSE,
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH",
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   ConditionalOperator = "AND"|"OR",
#'   ReturnValues = "NONE"|"ALL_OLD"|"UPDATED_OLD"|"ALL_NEW"|"UPDATED_NEW",
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ReturnItemCollectionMetrics = "SIZE"|"NONE",
#'   ConditionExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   ),
#'   ExpressionAttributeValues = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example deletes an item from the Music table.
#' svc$delete_item(
#'   Key = list(
#'     Artist = list(
#'       S = "No One You Know"
#'     ),
#'     SongTitle = list(
#'       S = "Scared of My Shadow"
#'     )
#'   ),
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_delete_item
#'
#' @aliases dynamodb_delete_item
dynamodb_delete_item <- function(TableName, Key, Expected = NULL, ConditionalOperator = NULL, ReturnValues = NULL, ReturnConsumedCapacity = NULL, ReturnItemCollectionMetrics = NULL, ConditionExpression = NULL, ExpressionAttributeNames = NULL, ExpressionAttributeValues = NULL, ReturnValuesOnConditionCheckFailure = NULL) {
  op <- new_operation(
    name = "DeleteItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$delete_item_input(TableName = TableName, Key = Key, Expected = Expected, ConditionalOperator = ConditionalOperator, ReturnValues = ReturnValues, ReturnConsumedCapacity = ReturnConsumedCapacity, ReturnItemCollectionMetrics = ReturnItemCollectionMetrics, ConditionExpression = ConditionExpression, ExpressionAttributeNames = ExpressionAttributeNames, ExpressionAttributeValues = ExpressionAttributeValues, ReturnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure)
  output <- .dynamodb$delete_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$delete_item <- dynamodb_delete_item

#' Deletes the resource-based policy attached to the resource, which can be
#' a table or stream
#'
#' @description
#' Deletes the resource-based policy attached to the resource, which can be
#' a table or stream.
#' 
#' [`delete_resource_policy`][dynamodb_delete_resource_policy] is an
#' idempotent operation; running it multiple times on the same resource
#' *doesn't* result in an error response, unless you specify an
#' `ExpectedRevisionId`, which will then return a
#' `PolicyNotFoundException`.
#' 
#' To make sure that you don't inadvertently lock yourself out of your own
#' resources, the root principal in your Amazon Web Services account can
#' perform [`delete_resource_policy`][dynamodb_delete_resource_policy]
#' requests, even if your resource-based policy explicitly denies the root
#' principal's access.
#' 
#' [`delete_resource_policy`][dynamodb_delete_resource_policy] is an
#' asynchronous operation. If you issue a
#' [`get_resource_policy`][dynamodb_get_resource_policy] request
#' immediately after running the
#' [`delete_resource_policy`][dynamodb_delete_resource_policy] request,
#' DynamoDB might still return the deleted policy. This is because the
#' policy for your resource might not have been deleted yet. Wait for a few
#' seconds, and then try the
#' [`get_resource_policy`][dynamodb_get_resource_policy] request again.
#'
#' @usage
#' dynamodb_delete_resource_policy(ResourceArn, ExpectedRevisionId)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the DynamoDB resource from which the
#' policy will be removed. The resources you can specify include tables and
#' streams. If you remove the policy of a table, it will also remove the
#' permissions for the table's indexes defined in that policy document.
#' This is because index permissions are defined in the table's policy.
#' @param ExpectedRevisionId A string value that you can use to conditionally delete your policy.
#' When you provide an expected revision ID, if the revision ID of the
#' existing policy on the resource doesn't match or if there's no policy
#' attached to the resource, the request will fail and return a
#' `PolicyNotFoundException`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_resource_policy(
#'   ResourceArn = "string",
#'   ExpectedRevisionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_delete_resource_policy
#'
#' @aliases dynamodb_delete_resource_policy
dynamodb_delete_resource_policy <- function(ResourceArn, ExpectedRevisionId = NULL) {
  op <- new_operation(
    name = "DeleteResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$delete_resource_policy_input(ResourceArn = ResourceArn, ExpectedRevisionId = ExpectedRevisionId)
  output <- .dynamodb$delete_resource_policy_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$delete_resource_policy <- dynamodb_delete_resource_policy

#' The DeleteTable operation deletes a table and all of its items
#'
#' @description
#' The [`delete_table`][dynamodb_delete_table] operation deletes a table
#' and all of its items. After a [`delete_table`][dynamodb_delete_table]
#' request, the specified table is in the `DELETING` state until DynamoDB
#' completes the deletion. If the table is in the `ACTIVE` state, you can
#' delete it. If a table is in `CREATING` or `UPDATING` states, then
#' DynamoDB returns a `ResourceInUseException`. If the specified table does
#' not exist, DynamoDB returns a `ResourceNotFoundException`. If table is
#' already in the `DELETING` state, no error is returned.
#' 
#' DynamoDB might continue to accept data read and write operations, such
#' as [`get_item`][dynamodb_get_item] and [`put_item`][dynamodb_put_item],
#' on a table in the `DELETING` state until the table deletion is complete.
#' For the full list of table states, see
#' [TableStatus](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TableDescription.html#DDB-Type-TableDescription-TableStatus).
#' 
#' When you delete a table, any indexes on that table are also deleted.
#' 
#' If you have DynamoDB Streams enabled on the table, then the
#' corresponding stream on that table goes into the `DISABLED` state, and
#' the stream is automatically deleted after 24 hours.
#' 
#' Use the [`describe_table`][dynamodb_describe_table] action to check the
#' status of the table.
#'
#' @usage
#' dynamodb_delete_table(TableName)
#'
#' @param TableName &#91;required&#93; The name of the table to delete. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableDescription = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_table(
#'   TableName = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example deletes the Music table.
#' svc$delete_table(
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_delete_table
#'
#' @aliases dynamodb_delete_table
dynamodb_delete_table <- function(TableName) {
  op <- new_operation(
    name = "DeleteTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$delete_table_input(TableName = TableName)
  output <- .dynamodb$delete_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$delete_table <- dynamodb_delete_table

#' Describes an existing backup of a table
#'
#' @description
#' Describes an existing backup of a table.
#' 
#' You can call [`describe_backup`][dynamodb_describe_backup] at a maximum
#' rate of 10 times per second.
#'
#' @usage
#' dynamodb_describe_backup(BackupArn)
#'
#' @param BackupArn &#91;required&#93; The Amazon Resource Name (ARN) associated with the backup.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BackupDescription = list(
#'     BackupDetails = list(
#'       BackupArn = "string",
#'       BackupName = "string",
#'       BackupSizeBytes = 123,
#'       BackupStatus = "CREATING"|"DELETED"|"AVAILABLE",
#'       BackupType = "USER"|"SYSTEM"|"AWS_BACKUP",
#'       BackupCreationDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       BackupExpiryDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     SourceTableDetails = list(
#'       TableName = "string",
#'       TableId = "string",
#'       TableArn = "string",
#'       TableSizeBytes = 123,
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       TableCreationDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       ItemCount = 123,
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST"
#'     ),
#'     SourceTableFeatureDetails = list(
#'       LocalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           )
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           ),
#'           ProvisionedThroughput = list(
#'             ReadCapacityUnits = 123,
#'             WriteCapacityUnits = 123
#'           ),
#'           OnDemandThroughput = list(
#'             MaxReadRequestUnits = 123,
#'             MaxWriteRequestUnits = 123
#'           )
#'         )
#'       ),
#'       StreamDescription = list(
#'         StreamEnabled = TRUE|FALSE,
#'         StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'       ),
#'       TimeToLiveDescription = list(
#'         TimeToLiveStatus = "ENABLING"|"DISABLING"|"ENABLED"|"DISABLED",
#'         AttributeName = "string"
#'       ),
#'       SSEDescription = list(
#'         Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'         SSEType = "AES256"|"KMS",
#'         KMSMasterKeyArn = "string",
#'         InaccessibleEncryptionDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_backup(
#'   BackupArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_backup
#'
#' @aliases dynamodb_describe_backup
dynamodb_describe_backup <- function(BackupArn) {
  op <- new_operation(
    name = "DescribeBackup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_backup_input(BackupArn = BackupArn)
  output <- .dynamodb$describe_backup_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_backup <- dynamodb_describe_backup

#' Checks the status of continuous backups and point in time recovery on
#' the specified table
#'
#' @description
#' Checks the status of continuous backups and point in time recovery on
#' the specified table. Continuous backups are `ENABLED` on all tables at
#' table creation. If point in time recovery is enabled,
#' `PointInTimeRecoveryStatus` will be set to ENABLED.
#' 
#' After continuous backups and point in time recovery are enabled, you can
#' restore to any point in time within `EarliestRestorableDateTime` and
#' `LatestRestorableDateTime`.
#' 
#' `LatestRestorableDateTime` is typically 5 minutes before the current
#' time. You can restore your table to any point in time in the last 35
#' days. You can set the recovery period to any value between 1 and 35
#' days.
#' 
#' You can call
#' [`describe_continuous_backups`][dynamodb_describe_continuous_backups] at
#' a maximum rate of 10 times per second.
#'
#' @usage
#' dynamodb_describe_continuous_backups(TableName)
#'
#' @param TableName &#91;required&#93; Name of the table for which the customer wants to check the continuous
#' backups and point in time recovery settings.
#' 
#' You can also provide the Amazon Resource Name (ARN) of the table in this
#' parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ContinuousBackupsDescription = list(
#'     ContinuousBackupsStatus = "ENABLED"|"DISABLED",
#'     PointInTimeRecoveryDescription = list(
#'       PointInTimeRecoveryStatus = "ENABLED"|"DISABLED",
#'       RecoveryPeriodInDays = 123,
#'       EarliestRestorableDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LatestRestorableDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_continuous_backups(
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_continuous_backups
#'
#' @aliases dynamodb_describe_continuous_backups
dynamodb_describe_continuous_backups <- function(TableName) {
  op <- new_operation(
    name = "DescribeContinuousBackups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_continuous_backups_input(TableName = TableName)
  output <- .dynamodb$describe_continuous_backups_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_continuous_backups <- dynamodb_describe_continuous_backups

#' Returns information about contributor insights for a given table or
#' global secondary index
#'
#' @description
#' Returns information about contributor insights for a given table or
#' global secondary index.
#'
#' @usage
#' dynamodb_describe_contributor_insights(TableName, IndexName)
#'
#' @param TableName &#91;required&#93; The name of the table to describe. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#' @param IndexName The name of the global secondary index to describe, if applicable.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   IndexName = "string",
#'   ContributorInsightsRuleList = list(
#'     "string"
#'   ),
#'   ContributorInsightsStatus = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"FAILED",
#'   LastUpdateDateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FailureException = list(
#'     ExceptionName = "string",
#'     ExceptionDescription = "string"
#'   ),
#'   ContributorInsightsMode = "ACCESSED_AND_THROTTLED_KEYS"|"THROTTLED_KEYS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_contributor_insights(
#'   TableName = "string",
#'   IndexName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_contributor_insights
#'
#' @aliases dynamodb_describe_contributor_insights
dynamodb_describe_contributor_insights <- function(TableName, IndexName = NULL) {
  op <- new_operation(
    name = "DescribeContributorInsights",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_contributor_insights_input(TableName = TableName, IndexName = IndexName)
  output <- .dynamodb$describe_contributor_insights_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_contributor_insights <- dynamodb_describe_contributor_insights

#' Returns the regional endpoint information
#'
#' @description
#' Returns the regional endpoint information. For more information on
#' policy permissions, please see [Internetwork traffic
#' privacy](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/inter-network-traffic-privacy.html#inter-network-traffic-DescribeEndpoints).
#'
#' @usage
#' dynamodb_describe_endpoints()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Endpoints = list(
#'     list(
#'       Address = "string",
#'       CachePeriodInMinutes = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_endpoints()
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_endpoints
#'
#' @aliases dynamodb_describe_endpoints
dynamodb_describe_endpoints <- function() {
  op <- new_operation(
    name = "DescribeEndpoints",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_endpoints_input()
  output <- .dynamodb$describe_endpoints_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_endpoints <- dynamodb_describe_endpoints

#' Describes an existing table export
#'
#' @description
#' Describes an existing table export.
#'
#' @usage
#' dynamodb_describe_export(ExportArn)
#'
#' @param ExportArn &#91;required&#93; The Amazon Resource Name (ARN) associated with the export.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ExportDescription = list(
#'     ExportArn = "string",
#'     ExportStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED",
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExportManifest = "string",
#'     TableArn = "string",
#'     TableId = "string",
#'     ExportTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ClientToken = "string",
#'     S3Bucket = "string",
#'     S3BucketOwner = "string",
#'     S3Prefix = "string",
#'     S3SseAlgorithm = "AES256"|"KMS",
#'     S3SseKmsKeyId = "string",
#'     FailureCode = "string",
#'     FailureMessage = "string",
#'     ExportFormat = "DYNAMODB_JSON"|"ION",
#'     BilledSizeBytes = 123,
#'     ItemCount = 123,
#'     ExportType = "FULL_EXPORT"|"INCREMENTAL_EXPORT",
#'     IncrementalExportSpecification = list(
#'       ExportFromTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExportToTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExportViewType = "NEW_IMAGE"|"NEW_AND_OLD_IMAGES"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_export(
#'   ExportArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_export
#'
#' @aliases dynamodb_describe_export
dynamodb_describe_export <- function(ExportArn) {
  op <- new_operation(
    name = "DescribeExport",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_export_input(ExportArn = ExportArn)
  output <- .dynamodb$describe_export_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_export <- dynamodb_describe_export

#' Returns information about the specified global table
#'
#' @description
#' Returns information about the specified global table.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#'
#' @usage
#' dynamodb_describe_global_table(GlobalTableName)
#'
#' @param GlobalTableName &#91;required&#93; The name of the global table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTableDescription = list(
#'     ReplicationGroup = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableArn = "string",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     GlobalTableStatus = "CREATING"|"ACTIVE"|"DELETING"|"UPDATING",
#'     GlobalTableName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_global_table(
#'   GlobalTableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_global_table
#'
#' @aliases dynamodb_describe_global_table
dynamodb_describe_global_table <- function(GlobalTableName) {
  op <- new_operation(
    name = "DescribeGlobalTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_global_table_input(GlobalTableName = GlobalTableName)
  output <- .dynamodb$describe_global_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_global_table <- dynamodb_describe_global_table

#' Describes Region-specific settings for a global table
#'
#' @description
#' Describes Region-specific settings for a global table.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#'
#' @usage
#' dynamodb_describe_global_table_settings(GlobalTableName)
#'
#' @param GlobalTableName &#91;required&#93; The name of the global table to describe.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTableName = "string",
#'   ReplicaSettings = list(
#'     list(
#'       RegionName = "string",
#'       ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'       ReplicaBillingModeSummary = list(
#'         BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'         LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       ReplicaProvisionedReadCapacityUnits = 123,
#'       ReplicaProvisionedReadCapacityAutoScalingSettings = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicies = list(
#'           list(
#'             PolicyName = "string",
#'             TargetTrackingScalingPolicyConfiguration = list(
#'               DisableScaleIn = TRUE|FALSE,
#'               ScaleInCooldown = 123,
#'               ScaleOutCooldown = 123,
#'               TargetValue = 123.0
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaProvisionedWriteCapacityUnits = 123,
#'       ReplicaProvisionedWriteCapacityAutoScalingSettings = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicies = list(
#'           list(
#'             PolicyName = "string",
#'             TargetTrackingScalingPolicyConfiguration = list(
#'               DisableScaleIn = TRUE|FALSE,
#'               ScaleInCooldown = 123,
#'               ScaleOutCooldown = 123,
#'               TargetValue = 123.0
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaGlobalSecondaryIndexSettings = list(
#'         list(
#'           IndexName = "string",
#'           IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'           ProvisionedReadCapacityUnits = 123,
#'           ProvisionedReadCapacityAutoScalingSettings = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicies = list(
#'               list(
#'                 PolicyName = "string",
#'                 TargetTrackingScalingPolicyConfiguration = list(
#'                   DisableScaleIn = TRUE|FALSE,
#'                   ScaleInCooldown = 123,
#'                   ScaleOutCooldown = 123,
#'                   TargetValue = 123.0
#'                 )
#'               )
#'             )
#'           ),
#'           ProvisionedWriteCapacityUnits = 123,
#'           ProvisionedWriteCapacityAutoScalingSettings = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicies = list(
#'               list(
#'                 PolicyName = "string",
#'                 TargetTrackingScalingPolicyConfiguration = list(
#'                   DisableScaleIn = TRUE|FALSE,
#'                   ScaleInCooldown = 123,
#'                   ScaleOutCooldown = 123,
#'                   TargetValue = 123.0
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaTableClassSummary = list(
#'         TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'         LastUpdateDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_global_table_settings(
#'   GlobalTableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_global_table_settings
#'
#' @aliases dynamodb_describe_global_table_settings
dynamodb_describe_global_table_settings <- function(GlobalTableName) {
  op <- new_operation(
    name = "DescribeGlobalTableSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_global_table_settings_input(GlobalTableName = GlobalTableName)
  output <- .dynamodb$describe_global_table_settings_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_global_table_settings <- dynamodb_describe_global_table_settings

#' Represents the properties of the import
#'
#' @description
#' Represents the properties of the import.
#'
#' @usage
#' dynamodb_describe_import(ImportArn)
#'
#' @param ImportArn &#91;required&#93; The Amazon Resource Name (ARN) associated with the table you're
#' importing to.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ImportTableDescription = list(
#'     ImportArn = "string",
#'     ImportStatus = "IN_PROGRESS"|"COMPLETED"|"CANCELLING"|"CANCELLED"|"FAILED",
#'     TableArn = "string",
#'     TableId = "string",
#'     ClientToken = "string",
#'     S3BucketSource = list(
#'       S3BucketOwner = "string",
#'       S3Bucket = "string",
#'       S3KeyPrefix = "string"
#'     ),
#'     ErrorCount = 123,
#'     CloudWatchLogGroupArn = "string",
#'     InputFormat = "DYNAMODB_JSON"|"ION"|"CSV",
#'     InputFormatOptions = list(
#'       Csv = list(
#'         Delimiter = "string",
#'         HeaderList = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     InputCompressionType = "GZIP"|"ZSTD"|"NONE",
#'     TableCreationParameters = list(
#'       TableName = "string",
#'       AttributeDefinitions = list(
#'         list(
#'           AttributeName = "string",
#'           AttributeType = "S"|"N"|"B"
#'         )
#'       ),
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       SSESpecification = list(
#'         Enabled = TRUE|FALSE,
#'         SSEType = "AES256"|"KMS",
#'         KMSMasterKeyId = "string"
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           ),
#'           ProvisionedThroughput = list(
#'             ReadCapacityUnits = 123,
#'             WriteCapacityUnits = 123
#'           ),
#'           OnDemandThroughput = list(
#'             MaxReadRequestUnits = 123,
#'             MaxWriteRequestUnits = 123
#'           ),
#'           WarmThroughput = list(
#'             ReadUnitsPerSecond = 123,
#'             WriteUnitsPerSecond = 123
#'           )
#'         )
#'       )
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProcessedSizeBytes = 123,
#'     ProcessedItemCount = 123,
#'     ImportedItemCount = 123,
#'     FailureCode = "string",
#'     FailureMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_import(
#'   ImportArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_import
#'
#' @aliases dynamodb_describe_import
dynamodb_describe_import <- function(ImportArn) {
  op <- new_operation(
    name = "DescribeImport",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_import_input(ImportArn = ImportArn)
  output <- .dynamodb$describe_import_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_import <- dynamodb_describe_import

#' Returns information about the status of Kinesis streaming
#'
#' @description
#' Returns information about the status of Kinesis streaming.
#'
#' @usage
#' dynamodb_describe_kinesis_streaming_destination(TableName)
#'
#' @param TableName &#91;required&#93; The name of the table being described. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   KinesisDataStreamDestinations = list(
#'     list(
#'       StreamArn = "string",
#'       DestinationStatus = "ENABLING"|"ACTIVE"|"DISABLING"|"DISABLED"|"ENABLE_FAILED"|"UPDATING",
#'       DestinationStatusDescription = "string",
#'       ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_kinesis_streaming_destination(
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_kinesis_streaming_destination
#'
#' @aliases dynamodb_describe_kinesis_streaming_destination
dynamodb_describe_kinesis_streaming_destination <- function(TableName) {
  op <- new_operation(
    name = "DescribeKinesisStreamingDestination",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_kinesis_streaming_destination_input(TableName = TableName)
  output <- .dynamodb$describe_kinesis_streaming_destination_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_kinesis_streaming_destination <- dynamodb_describe_kinesis_streaming_destination

#' Returns the current provisioned-capacity quotas for your Amazon Web
#' Services account in a Region, both for the Region as a whole and for any
#' one DynamoDB table that you create there
#'
#' @description
#' Returns the current provisioned-capacity quotas for your Amazon Web
#' Services account in a Region, both for the Region as a whole and for any
#' one DynamoDB table that you create there.
#' 
#' When you establish an Amazon Web Services account, the account has
#' initial quotas on the maximum read capacity units and write capacity
#' units that you can provision across all of your DynamoDB tables in a
#' given Region. Also, there are per-table quotas that apply when you
#' create a table there. For more information, see [Service, Account, and
#' Table
#' Quotas](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html)
#' page in the *Amazon DynamoDB Developer Guide*.
#' 
#' Although you can increase these quotas by filing a case at Amazon Web
#' Services Support Center, obtaining the increase is not instantaneous.
#' The [`describe_limits`][dynamodb_describe_limits] action lets you write
#' code to compare the capacity you are currently using to those quotas
#' imposed by your account so that you have enough time to apply for an
#' increase before you hit a quota.
#' 
#' For example, you could use one of the Amazon Web Services SDKs to do the
#' following:
#' 
#' 1.  Call [`describe_limits`][dynamodb_describe_limits] for a particular
#'     Region to obtain your current account quotas on provisioned capacity
#'     there.
#' 
#' 2.  Create a variable to hold the aggregate read capacity units
#'     provisioned for all your tables in that Region, and one to hold the
#'     aggregate write capacity units. Zero them both.
#' 
#' 3.  Call [`list_tables`][dynamodb_list_tables] to obtain a list of all
#'     your DynamoDB tables.
#' 
#' 4.  For each table name listed by [`list_tables`][dynamodb_list_tables],
#'     do the following:
#' 
#'     -   Call [`describe_table`][dynamodb_describe_table] with the table
#'         name.
#' 
#'     -   Use the data returned by
#'         [`describe_table`][dynamodb_describe_table] to add the read
#'         capacity units and write capacity units provisioned for the
#'         table itself to your variables.
#' 
#'     -   If the table has one or more global secondary indexes (GSIs),
#'         loop over these GSIs and add their provisioned capacity values
#'         to your variables as well.
#' 
#' 5.  Report the account quotas for that Region returned by
#'     [`describe_limits`][dynamodb_describe_limits], along with the total
#'     current provisioned capacity levels you have calculated.
#' 
#' This will let you see whether you are getting close to your
#' account-level quotas.
#' 
#' The per-table quotas apply only when you are creating a new table. They
#' restrict the sum of the provisioned capacity of the new table itself and
#' all its global secondary indexes.
#' 
#' For existing tables and their GSIs, DynamoDB doesn't let you increase
#' provisioned capacity extremely rapidly, but the only quota that applies
#' is that the aggregate provisioned capacity over all your tables and GSIs
#' cannot exceed either of the per-account quotas.
#' 
#' [`describe_limits`][dynamodb_describe_limits] should only be called
#' periodically. You can expect throttling errors if you call it more than
#' once in a minute.
#' 
#' The [`describe_limits`][dynamodb_describe_limits] Request element has no
#' content.
#'
#' @usage
#' dynamodb_describe_limits()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AccountMaxReadCapacityUnits = 123,
#'   AccountMaxWriteCapacityUnits = 123,
#'   TableMaxReadCapacityUnits = 123,
#'   TableMaxWriteCapacityUnits = 123
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_limits()
#' ```
#'
#' @examples
#' \dontrun{
#' # The following example returns the maximum read and write capacity units
#' # per table, and for the AWS account, in the current AWS region.
#' svc$describe_limits()
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_limits
#'
#' @aliases dynamodb_describe_limits
dynamodb_describe_limits <- function() {
  op <- new_operation(
    name = "DescribeLimits",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_limits_input()
  output <- .dynamodb$describe_limits_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_limits <- dynamodb_describe_limits

#' Returns information about the table, including the current status of the
#' table, when it was created, the primary key schema, and any indexes on
#' the table
#'
#' @description
#' Returns information about the table, including the current status of the
#' table, when it was created, the primary key schema, and any indexes on
#' the table.
#' 
#' If you issue a [`describe_table`][dynamodb_describe_table] request
#' immediately after a [`create_table`][dynamodb_create_table] request,
#' DynamoDB might return a `ResourceNotFoundException`. This is because
#' [`describe_table`][dynamodb_describe_table] uses an eventually
#' consistent query, and the metadata for your table might not be available
#' at that moment. Wait for a few seconds, and then try the
#' [`describe_table`][dynamodb_describe_table] request again.
#'
#' @usage
#' dynamodb_describe_table(TableName)
#'
#' @param TableName &#91;required&#93; The name of the table to describe. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Table = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_table(
#'   TableName = "string"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example describes the Music table.
#' svc$describe_table(
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_table
#'
#' @aliases dynamodb_describe_table
dynamodb_describe_table <- function(TableName) {
  op <- new_operation(
    name = "DescribeTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_table_input(TableName = TableName)
  output <- .dynamodb$describe_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_table <- dynamodb_describe_table

#' Describes auto scaling settings across replicas of the global table at
#' once
#'
#' @description
#' Describes auto scaling settings across replicas of the global table at
#' once.
#'
#' @usage
#' dynamodb_describe_table_replica_auto_scaling(TableName)
#'
#' @param TableName &#91;required&#93; The name of the table. You can also provide the Amazon Resource Name
#' (ARN) of the table in this parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableAutoScalingDescription = list(
#'     TableName = "string",
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'             ProvisionedReadCapacityAutoScalingSettings = list(
#'               MinimumUnits = 123,
#'               MaximumUnits = 123,
#'               AutoScalingDisabled = TRUE|FALSE,
#'               AutoScalingRoleArn = "string",
#'               ScalingPolicies = list(
#'                 list(
#'                   PolicyName = "string",
#'                   TargetTrackingScalingPolicyConfiguration = list(
#'                     DisableScaleIn = TRUE|FALSE,
#'                     ScaleInCooldown = 123,
#'                     ScaleOutCooldown = 123,
#'                     TargetValue = 123.0
#'                   )
#'                 )
#'               )
#'             ),
#'             ProvisionedWriteCapacityAutoScalingSettings = list(
#'               MinimumUnits = 123,
#'               MaximumUnits = 123,
#'               AutoScalingDisabled = TRUE|FALSE,
#'               AutoScalingRoleArn = "string",
#'               ScalingPolicies = list(
#'                 list(
#'                   PolicyName = "string",
#'                   TargetTrackingScalingPolicyConfiguration = list(
#'                     DisableScaleIn = TRUE|FALSE,
#'                     ScaleInCooldown = 123,
#'                     ScaleOutCooldown = 123,
#'                     TargetValue = 123.0
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaProvisionedReadCapacityAutoScalingSettings = list(
#'           MinimumUnits = 123,
#'           MaximumUnits = 123,
#'           AutoScalingDisabled = TRUE|FALSE,
#'           AutoScalingRoleArn = "string",
#'           ScalingPolicies = list(
#'             list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaProvisionedWriteCapacityAutoScalingSettings = list(
#'           MinimumUnits = 123,
#'           MaximumUnits = 123,
#'           AutoScalingDisabled = TRUE|FALSE,
#'           AutoScalingRoleArn = "string",
#'           ScalingPolicies = list(
#'             list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_table_replica_auto_scaling(
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_table_replica_auto_scaling
#'
#' @aliases dynamodb_describe_table_replica_auto_scaling
dynamodb_describe_table_replica_auto_scaling <- function(TableName) {
  op <- new_operation(
    name = "DescribeTableReplicaAutoScaling",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_table_replica_auto_scaling_input(TableName = TableName)
  output <- .dynamodb$describe_table_replica_auto_scaling_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_table_replica_auto_scaling <- dynamodb_describe_table_replica_auto_scaling

#' Gives a description of the Time to Live (TTL) status on the specified
#' table
#'
#' @description
#' Gives a description of the Time to Live (TTL) status on the specified
#' table.
#'
#' @usage
#' dynamodb_describe_time_to_live(TableName)
#'
#' @param TableName &#91;required&#93; The name of the table to be described. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TimeToLiveDescription = list(
#'     TimeToLiveStatus = "ENABLING"|"DISABLING"|"ENABLED"|"DISABLED",
#'     AttributeName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_time_to_live(
#'   TableName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_describe_time_to_live
#'
#' @aliases dynamodb_describe_time_to_live
dynamodb_describe_time_to_live <- function(TableName) {
  op <- new_operation(
    name = "DescribeTimeToLive",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$describe_time_to_live_input(TableName = TableName)
  output <- .dynamodb$describe_time_to_live_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$describe_time_to_live <- dynamodb_describe_time_to_live

#' Stops replication from the DynamoDB table to the Kinesis data stream
#'
#' @description
#' Stops replication from the DynamoDB table to the Kinesis data stream.
#' This is done without deleting either of the resources.
#'
#' @usage
#' dynamodb_disable_kinesis_streaming_destination(TableName, StreamArn,
#'   EnableKinesisStreamingConfiguration)
#'
#' @param TableName &#91;required&#93; The name of the DynamoDB table. You can also provide the Amazon Resource
#' Name (ARN) of the table in this parameter.
#' @param StreamArn &#91;required&#93; The ARN for a Kinesis data stream.
#' @param EnableKinesisStreamingConfiguration The source for the Kinesis streaming information that is being enabled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   StreamArn = "string",
#'   DestinationStatus = "ENABLING"|"ACTIVE"|"DISABLING"|"DISABLED"|"ENABLE_FAILED"|"UPDATING",
#'   EnableKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disable_kinesis_streaming_destination(
#'   TableName = "string",
#'   StreamArn = "string",
#'   EnableKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_disable_kinesis_streaming_destination
#'
#' @aliases dynamodb_disable_kinesis_streaming_destination
dynamodb_disable_kinesis_streaming_destination <- function(TableName, StreamArn, EnableKinesisStreamingConfiguration = NULL) {
  op <- new_operation(
    name = "DisableKinesisStreamingDestination",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$disable_kinesis_streaming_destination_input(TableName = TableName, StreamArn = StreamArn, EnableKinesisStreamingConfiguration = EnableKinesisStreamingConfiguration)
  output <- .dynamodb$disable_kinesis_streaming_destination_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$disable_kinesis_streaming_destination <- dynamodb_disable_kinesis_streaming_destination

#' Starts table data replication to the specified Kinesis data stream at a
#' timestamp chosen during the enable workflow
#'
#' @description
#' Starts table data replication to the specified Kinesis data stream at a
#' timestamp chosen during the enable workflow. If this operation doesn't
#' return results immediately, use DescribeKinesisStreamingDestination to
#' check if streaming to the Kinesis data stream is ACTIVE.
#'
#' @usage
#' dynamodb_enable_kinesis_streaming_destination(TableName, StreamArn,
#'   EnableKinesisStreamingConfiguration)
#'
#' @param TableName &#91;required&#93; The name of the DynamoDB table. You can also provide the Amazon Resource
#' Name (ARN) of the table in this parameter.
#' @param StreamArn &#91;required&#93; The ARN for a Kinesis data stream.
#' @param EnableKinesisStreamingConfiguration The source for the Kinesis streaming information that is being enabled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   StreamArn = "string",
#'   DestinationStatus = "ENABLING"|"ACTIVE"|"DISABLING"|"DISABLED"|"ENABLE_FAILED"|"UPDATING",
#'   EnableKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$enable_kinesis_streaming_destination(
#'   TableName = "string",
#'   StreamArn = "string",
#'   EnableKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_enable_kinesis_streaming_destination
#'
#' @aliases dynamodb_enable_kinesis_streaming_destination
dynamodb_enable_kinesis_streaming_destination <- function(TableName, StreamArn, EnableKinesisStreamingConfiguration = NULL) {
  op <- new_operation(
    name = "EnableKinesisStreamingDestination",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$enable_kinesis_streaming_destination_input(TableName = TableName, StreamArn = StreamArn, EnableKinesisStreamingConfiguration = EnableKinesisStreamingConfiguration)
  output <- .dynamodb$enable_kinesis_streaming_destination_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$enable_kinesis_streaming_destination <- dynamodb_enable_kinesis_streaming_destination

#' This operation allows you to perform reads and singleton writes on data
#' stored in DynamoDB, using PartiQL
#'
#' @description
#' This operation allows you to perform reads and singleton writes on data
#' stored in DynamoDB, using PartiQL.
#' 
#' For PartiQL reads (`SELECT` statement), if the total number of processed
#' items exceeds the maximum dataset size limit of 1 MB, the read stops and
#' results are returned to the user as a `LastEvaluatedKey` value to
#' continue the read in a subsequent operation. If the filter criteria in
#' `WHERE` clause does not match any data, the read will return an empty
#' result set.
#' 
#' A single `SELECT` statement response can return up to the maximum number
#' of items (if using the Limit parameter) or a maximum of 1 MB of data
#' (and then apply any filtering to the results using `WHERE` clause). If
#' `LastEvaluatedKey` is present in the response, you need to paginate the
#' result set. If `NextToken` is present, you need to paginate the result
#' set and include `NextToken`.
#'
#' @usage
#' dynamodb_execute_statement(Statement, Parameters, ConsistentRead,
#'   NextToken, ReturnConsumedCapacity, Limit,
#'   ReturnValuesOnConditionCheckFailure)
#'
#' @param Statement &#91;required&#93; The PartiQL statement representing the operation to run.
#' @param Parameters The parameters for the PartiQL statement, if any.
#' @param ConsistentRead The consistency of a read operation. If set to `true`, then a strongly
#' consistent read is used; otherwise, an eventually consistent read is
#' used.
#' @param NextToken Set this value to get remaining results, if `NextToken` was returned in
#' the statement response.
#' @param ReturnConsumedCapacity 
#' @param Limit The maximum number of items to evaluate (not necessarily the number of
#' matching items). If DynamoDB processes the number of items up to the
#' limit while processing the results, it stops the operation and returns
#' the matching values up to that point, along with a key in
#' `LastEvaluatedKey` to apply in a subsequent operation so you can pick up
#' where you left off. Also, if the processed dataset size exceeds 1 MB
#' before DynamoDB reaches this limit, it stops the operation and returns
#' the matching values up to the limit, and a key in `LastEvaluatedKey` to
#' apply in a subsequent operation to continue the operation.
#' @param ReturnValuesOnConditionCheckFailure An optional parameter that returns the item attributes for an
#' [`execute_statement`][dynamodb_execute_statement] operation that failed
#' a condition check.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Items = list(
#'     list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   NextToken = "string",
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   ),
#'   LastEvaluatedKey = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$execute_statement(
#'   Statement = "string",
#'   Parameters = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsistentRead = TRUE|FALSE,
#'   NextToken = "string",
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   Limit = 123,
#'   ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_execute_statement
#'
#' @aliases dynamodb_execute_statement
dynamodb_execute_statement <- function(Statement, Parameters = NULL, ConsistentRead = NULL, NextToken = NULL, ReturnConsumedCapacity = NULL, Limit = NULL, ReturnValuesOnConditionCheckFailure = NULL) {
  op <- new_operation(
    name = "ExecuteStatement",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$execute_statement_input(Statement = Statement, Parameters = Parameters, ConsistentRead = ConsistentRead, NextToken = NextToken, ReturnConsumedCapacity = ReturnConsumedCapacity, Limit = Limit, ReturnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure)
  output <- .dynamodb$execute_statement_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$execute_statement <- dynamodb_execute_statement

#' This operation allows you to perform transactional reads or writes on
#' data stored in DynamoDB, using PartiQL
#'
#' @description
#' This operation allows you to perform transactional reads or writes on
#' data stored in DynamoDB, using PartiQL.
#' 
#' The entire transaction must consist of either read statements or write
#' statements, you cannot mix both in one transaction. The EXISTS function
#' is an exception and can be used to check the condition of specific
#' attributes of the item in a similar manner to `ConditionCheck` in the
#' [`transact_write_items`][dynamodb_transact_write_items] API.
#'
#' @usage
#' dynamodb_execute_transaction(TransactStatements, ClientRequestToken,
#'   ReturnConsumedCapacity)
#'
#' @param TransactStatements &#91;required&#93; The list of PartiQL statements representing the transaction to run.
#' @param ClientRequestToken Set this value to get remaining results, if `NextToken` was returned in
#' the statement response.
#' @param ReturnConsumedCapacity Determines the level of detail about either provisioned or on-demand
#' throughput consumption that is returned in the response. For more
#' information, see [`transact_get_items`][dynamodb_transact_get_items] and
#' [`transact_write_items`][dynamodb_transact_write_items].
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Responses = list(
#'     list(
#'       Item = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$execute_transaction(
#'   TransactStatements = list(
#'     list(
#'       Statement = "string",
#'       Parameters = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       ),
#'       ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'     )
#'   ),
#'   ClientRequestToken = "string",
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_execute_transaction
#'
#' @aliases dynamodb_execute_transaction
dynamodb_execute_transaction <- function(TransactStatements, ClientRequestToken = NULL, ReturnConsumedCapacity = NULL) {
  op <- new_operation(
    name = "ExecuteTransaction",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$execute_transaction_input(TransactStatements = TransactStatements, ClientRequestToken = ClientRequestToken, ReturnConsumedCapacity = ReturnConsumedCapacity)
  output <- .dynamodb$execute_transaction_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$execute_transaction <- dynamodb_execute_transaction

#' Exports table data to an S3 bucket
#'
#' @description
#' Exports table data to an S3 bucket. The table must have point in time
#' recovery enabled, and you can export data from any time within the point
#' in time recovery window.
#'
#' @usage
#' dynamodb_export_table_to_point_in_time(TableArn, ExportTime,
#'   ClientToken, S3Bucket, S3BucketOwner, S3Prefix, S3SseAlgorithm,
#'   S3SseKmsKeyId, ExportFormat, ExportType, IncrementalExportSpecification)
#'
#' @param TableArn &#91;required&#93; The Amazon Resource Name (ARN) associated with the table to export.
#' @param ExportTime Time in the past from which to export table data, counted in seconds
#' from the start of the Unix epoch. The table export will be a snapshot of
#' the table's state at this point in time.
#' @param ClientToken Providing a `ClientToken` makes the call to
#' `ExportTableToPointInTimeInput` idempotent, meaning that multiple
#' identical calls have the same effect as one single call.
#' 
#' A client token is valid for 8 hours after the first request that uses it
#' is completed. After 8 hours, any request with the same client token is
#' treated as a new request. Do not resubmit the same request with the same
#' client token for more than 8 hours, or the result might not be
#' idempotent.
#' 
#' If you submit a request with the same client token but a change in other
#' parameters within the 8-hour idempotency window, DynamoDB returns an
#' `ImportConflictException`.
#' @param S3Bucket &#91;required&#93; The name of the Amazon S3 bucket to export the snapshot to.
#' @param S3BucketOwner The ID of the Amazon Web Services account that owns the bucket the
#' export will be stored in.
#' 
#' S3BucketOwner is a required parameter when exporting to a S3 bucket in
#' another account.
#' @param S3Prefix The Amazon S3 bucket prefix to use as the file name and path of the
#' exported snapshot.
#' @param S3SseAlgorithm Type of encryption used on the bucket where export data will be stored.
#' Valid values for `S3SseAlgorithm` are:
#' 
#' -   `AES256` - server-side encryption with Amazon S3 managed keys
#' 
#' -   `KMS` - server-side encryption with KMS managed keys
#' @param S3SseKmsKeyId The ID of the KMS managed key used to encrypt the S3 bucket where export
#' data will be stored (if applicable).
#' @param ExportFormat The format for the exported data. Valid values for `ExportFormat` are
#' `DYNAMODB_JSON` or `ION`.
#' @param ExportType Choice of whether to execute as a full export or incremental export.
#' Valid values are FULL_EXPORT or INCREMENTAL_EXPORT. The default value is
#' FULL_EXPORT. If INCREMENTAL_EXPORT is provided, the
#' IncrementalExportSpecification must also be used.
#' @param IncrementalExportSpecification Optional object containing the parameters specific to an incremental
#' export.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ExportDescription = list(
#'     ExportArn = "string",
#'     ExportStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED",
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExportManifest = "string",
#'     TableArn = "string",
#'     TableId = "string",
#'     ExportTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ClientToken = "string",
#'     S3Bucket = "string",
#'     S3BucketOwner = "string",
#'     S3Prefix = "string",
#'     S3SseAlgorithm = "AES256"|"KMS",
#'     S3SseKmsKeyId = "string",
#'     FailureCode = "string",
#'     FailureMessage = "string",
#'     ExportFormat = "DYNAMODB_JSON"|"ION",
#'     BilledSizeBytes = 123,
#'     ItemCount = 123,
#'     ExportType = "FULL_EXPORT"|"INCREMENTAL_EXPORT",
#'     IncrementalExportSpecification = list(
#'       ExportFromTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExportToTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ExportViewType = "NEW_IMAGE"|"NEW_AND_OLD_IMAGES"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$export_table_to_point_in_time(
#'   TableArn = "string",
#'   ExportTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ClientToken = "string",
#'   S3Bucket = "string",
#'   S3BucketOwner = "string",
#'   S3Prefix = "string",
#'   S3SseAlgorithm = "AES256"|"KMS",
#'   S3SseKmsKeyId = "string",
#'   ExportFormat = "DYNAMODB_JSON"|"ION",
#'   ExportType = "FULL_EXPORT"|"INCREMENTAL_EXPORT",
#'   IncrementalExportSpecification = list(
#'     ExportFromTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExportToTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ExportViewType = "NEW_IMAGE"|"NEW_AND_OLD_IMAGES"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_export_table_to_point_in_time
#'
#' @aliases dynamodb_export_table_to_point_in_time
dynamodb_export_table_to_point_in_time <- function(TableArn, ExportTime = NULL, ClientToken = NULL, S3Bucket, S3BucketOwner = NULL, S3Prefix = NULL, S3SseAlgorithm = NULL, S3SseKmsKeyId = NULL, ExportFormat = NULL, ExportType = NULL, IncrementalExportSpecification = NULL) {
  op <- new_operation(
    name = "ExportTableToPointInTime",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$export_table_to_point_in_time_input(TableArn = TableArn, ExportTime = ExportTime, ClientToken = ClientToken, S3Bucket = S3Bucket, S3BucketOwner = S3BucketOwner, S3Prefix = S3Prefix, S3SseAlgorithm = S3SseAlgorithm, S3SseKmsKeyId = S3SseKmsKeyId, ExportFormat = ExportFormat, ExportType = ExportType, IncrementalExportSpecification = IncrementalExportSpecification)
  output <- .dynamodb$export_table_to_point_in_time_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$export_table_to_point_in_time <- dynamodb_export_table_to_point_in_time

#' The GetItem operation returns a set of attributes for the item with the
#' given primary key
#'
#' @description
#' The [`get_item`][dynamodb_get_item] operation returns a set of
#' attributes for the item with the given primary key. If there is no
#' matching item, [`get_item`][dynamodb_get_item] does not return any data
#' and there will be no `Item` element in the response.
#' 
#' [`get_item`][dynamodb_get_item] provides an eventually consistent read
#' by default. If your application requires a strongly consistent read, set
#' `ConsistentRead` to `true`. Although a strongly consistent read might
#' take more time than an eventually consistent read, it always returns the
#' last updated value.
#'
#' @usage
#' dynamodb_get_item(TableName, Key, AttributesToGet, ConsistentRead,
#'   ReturnConsumedCapacity, ProjectionExpression, ExpressionAttributeNames)
#'
#' @param TableName &#91;required&#93; The name of the table containing the requested item. You can also
#' provide the Amazon Resource Name (ARN) of the table in this parameter.
#' @param Key &#91;required&#93; A map of attribute names to `AttributeValue` objects, representing the
#' primary key of the item to retrieve.
#' 
#' For the primary key, you must provide all of the attributes. For
#' example, with a simple primary key, you only need to provide a value for
#' the partition key. For a composite primary key, you must provide values
#' for both the partition key and the sort key.
#' @param AttributesToGet This is a legacy parameter. Use `ProjectionExpression` instead. For more
#' information, see
#' [AttributesToGet](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConsistentRead Determines the read consistency model: If set to `true`, then the
#' operation uses strongly consistent reads; otherwise, the operation uses
#' eventually consistent reads.
#' @param ReturnConsumedCapacity 
#' @param ProjectionExpression A string that identifies one or more attributes to retrieve from the
#' table. These attributes can include scalars, sets, or elements of a JSON
#' document. The attributes in the expression must be separated by commas.
#' 
#' If no attribute names are specified, then all attributes are returned.
#' If any of the requested attributes are not found, they do not appear in
#' the result.
#' 
#' For more information, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*). To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information on expression attribute names, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Item = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_item(
#'   TableName = "string",
#'   Key = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   AttributesToGet = list(
#'     "string"
#'   ),
#'   ConsistentRead = TRUE|FALSE,
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ProjectionExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example retrieves an item from the Music table. The table has a
#' # partition key and a sort key (Artist and SongTitle), so you must specify
#' # both of these attributes.
#' svc$get_item(
#'   Key = list(
#'     Artist = list(
#'       S = "Acme Band"
#'     ),
#'     SongTitle = list(
#'       S = "Happy Day"
#'     )
#'   ),
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_get_item
#'
#' @aliases dynamodb_get_item
dynamodb_get_item <- function(TableName, Key, AttributesToGet = NULL, ConsistentRead = NULL, ReturnConsumedCapacity = NULL, ProjectionExpression = NULL, ExpressionAttributeNames = NULL) {
  op <- new_operation(
    name = "GetItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$get_item_input(TableName = TableName, Key = Key, AttributesToGet = AttributesToGet, ConsistentRead = ConsistentRead, ReturnConsumedCapacity = ReturnConsumedCapacity, ProjectionExpression = ProjectionExpression, ExpressionAttributeNames = ExpressionAttributeNames)
  output <- .dynamodb$get_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$get_item <- dynamodb_get_item

#' Returns the resource-based policy document attached to the resource,
#' which can be a table or stream, in JSON format
#'
#' @description
#' Returns the resource-based policy document attached to the resource,
#' which can be a table or stream, in JSON format.
#' 
#' [`get_resource_policy`][dynamodb_get_resource_policy] follows an
#' [*eventually
#' consistent*](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html)
#' model. The following list describes the outcomes when you issue the
#' [`get_resource_policy`][dynamodb_get_resource_policy] request
#' immediately after issuing another request:
#' 
#' -   If you issue a [`get_resource_policy`][dynamodb_get_resource_policy]
#'     request immediately after a
#'     [`put_resource_policy`][dynamodb_put_resource_policy] request,
#'     DynamoDB might return a `PolicyNotFoundException`.
#' 
#' -   If you issue a
#'     [`get_resource_policy`][dynamodb_get_resource_policy]request
#'     immediately after a
#'     [`delete_resource_policy`][dynamodb_delete_resource_policy] request,
#'     DynamoDB might return the policy that was present before the
#'     deletion request.
#' 
#' -   If you issue a [`get_resource_policy`][dynamodb_get_resource_policy]
#'     request immediately after a [`create_table`][dynamodb_create_table]
#'     request, which includes a resource-based policy, DynamoDB might
#'     return a `ResourceNotFoundException` or a `PolicyNotFoundException`.
#' 
#' Because [`get_resource_policy`][dynamodb_get_resource_policy] uses an
#' *eventually consistent* query, the metadata for your policy or table
#' might not be available at that moment. Wait for a few seconds, and then
#' retry the [`get_resource_policy`][dynamodb_get_resource_policy] request.
#' 
#' After a [`get_resource_policy`][dynamodb_get_resource_policy] request
#' returns a policy created using the
#' [`put_resource_policy`][dynamodb_put_resource_policy] request, the
#' policy will be applied in the authorization of requests to the resource.
#' Because this process is eventually consistent, it will take some time to
#' apply the policy to all requests to a resource. Policies that you attach
#' while creating a table using the [`create_table`][dynamodb_create_table]
#' request will always be applied to all requests for that table.
#'
#' @usage
#' dynamodb_get_resource_policy(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the DynamoDB resource to which the
#' policy is attached. The resources you can specify include tables and
#' streams.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Policy = "string",
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_resource_policy(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_get_resource_policy
#'
#' @aliases dynamodb_get_resource_policy
dynamodb_get_resource_policy <- function(ResourceArn) {
  op <- new_operation(
    name = "GetResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$get_resource_policy_input(ResourceArn = ResourceArn)
  output <- .dynamodb$get_resource_policy_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$get_resource_policy <- dynamodb_get_resource_policy

#' Imports table data from an S3 bucket
#'
#' @description
#' Imports table data from an S3 bucket.
#'
#' @usage
#' dynamodb_import_table(ClientToken, S3BucketSource, InputFormat,
#'   InputFormatOptions, InputCompressionType, TableCreationParameters)
#'
#' @param ClientToken Providing a `ClientToken` makes the call to `ImportTableInput`
#' idempotent, meaning that multiple identical calls have the same effect
#' as one single call.
#' 
#' A client token is valid for 8 hours after the first request that uses it
#' is completed. After 8 hours, any request with the same client token is
#' treated as a new request. Do not resubmit the same request with the same
#' client token for more than 8 hours, or the result might not be
#' idempotent.
#' 
#' If you submit a request with the same client token but a change in other
#' parameters within the 8-hour idempotency window, DynamoDB returns an
#' `IdempotentParameterMismatch` exception.
#' @param S3BucketSource &#91;required&#93; The S3 bucket that provides the source for the import.
#' @param InputFormat &#91;required&#93; The format of the source data. Valid values for `ImportFormat` are
#' `CSV`, `DYNAMODB_JSON` or `ION`.
#' @param InputFormatOptions Additional properties that specify how the input is formatted,
#' @param InputCompressionType Type of compression to be used on the input coming from the imported
#' table.
#' @param TableCreationParameters &#91;required&#93; Parameters for the table to import the data into.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ImportTableDescription = list(
#'     ImportArn = "string",
#'     ImportStatus = "IN_PROGRESS"|"COMPLETED"|"CANCELLING"|"CANCELLED"|"FAILED",
#'     TableArn = "string",
#'     TableId = "string",
#'     ClientToken = "string",
#'     S3BucketSource = list(
#'       S3BucketOwner = "string",
#'       S3Bucket = "string",
#'       S3KeyPrefix = "string"
#'     ),
#'     ErrorCount = 123,
#'     CloudWatchLogGroupArn = "string",
#'     InputFormat = "DYNAMODB_JSON"|"ION"|"CSV",
#'     InputFormatOptions = list(
#'       Csv = list(
#'         Delimiter = "string",
#'         HeaderList = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     InputCompressionType = "GZIP"|"ZSTD"|"NONE",
#'     TableCreationParameters = list(
#'       TableName = "string",
#'       AttributeDefinitions = list(
#'         list(
#'           AttributeName = "string",
#'           AttributeType = "S"|"N"|"B"
#'         )
#'       ),
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       SSESpecification = list(
#'         Enabled = TRUE|FALSE,
#'         SSEType = "AES256"|"KMS",
#'         KMSMasterKeyId = "string"
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           IndexName = "string",
#'           KeySchema = list(
#'             list(
#'               AttributeName = "string",
#'               KeyType = "HASH"|"RANGE"
#'             )
#'           ),
#'           Projection = list(
#'             ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'             NonKeyAttributes = list(
#'               "string"
#'             )
#'           ),
#'           ProvisionedThroughput = list(
#'             ReadCapacityUnits = 123,
#'             WriteCapacityUnits = 123
#'           ),
#'           OnDemandThroughput = list(
#'             MaxReadRequestUnits = 123,
#'             MaxWriteRequestUnits = 123
#'           ),
#'           WarmThroughput = list(
#'             ReadUnitsPerSecond = 123,
#'             WriteUnitsPerSecond = 123
#'           )
#'         )
#'       )
#'     ),
#'     StartTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     EndTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProcessedSizeBytes = 123,
#'     ProcessedItemCount = 123,
#'     ImportedItemCount = 123,
#'     FailureCode = "string",
#'     FailureMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$import_table(
#'   ClientToken = "string",
#'   S3BucketSource = list(
#'     S3BucketOwner = "string",
#'     S3Bucket = "string",
#'     S3KeyPrefix = "string"
#'   ),
#'   InputFormat = "DYNAMODB_JSON"|"ION"|"CSV",
#'   InputFormatOptions = list(
#'     Csv = list(
#'       Delimiter = "string",
#'       HeaderList = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   InputCompressionType = "GZIP"|"ZSTD"|"NONE",
#'   TableCreationParameters = list(
#'     TableName = "string",
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'     ProvisionedThroughput = list(
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     SSESpecification = list(
#'       Enabled = TRUE|FALSE,
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyId = "string"
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         ProvisionedThroughput = list(
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_import_table
#'
#' @aliases dynamodb_import_table
dynamodb_import_table <- function(ClientToken = NULL, S3BucketSource, InputFormat, InputFormatOptions = NULL, InputCompressionType = NULL, TableCreationParameters) {
  op <- new_operation(
    name = "ImportTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$import_table_input(ClientToken = ClientToken, S3BucketSource = S3BucketSource, InputFormat = InputFormat, InputFormatOptions = InputFormatOptions, InputCompressionType = InputCompressionType, TableCreationParameters = TableCreationParameters)
  output <- .dynamodb$import_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$import_table <- dynamodb_import_table

#' List DynamoDB backups that are associated with an Amazon Web Services
#' account and weren't made with Amazon Web Services Backup
#'
#' @description
#' List DynamoDB backups that are associated with an Amazon Web Services
#' account and weren't made with Amazon Web Services Backup. To list these
#' backups for a given table, specify `TableName`.
#' [`list_backups`][dynamodb_list_backups] returns a paginated list of
#' results with at most 1 MB worth of items in a page. You can also specify
#' a maximum number of entries to be returned in a page.
#' 
#' In the request, start time is inclusive, but end time is exclusive. Note
#' that these boundaries are for the time at which the original backup was
#' requested.
#' 
#' You can call [`list_backups`][dynamodb_list_backups] a maximum of five
#' times per second.
#' 
#' If you want to retrieve the complete list of backups made with Amazon
#' Web Services Backup, use the [Amazon Web Services Backup list
#' API.](https://docs.aws.amazon.com/aws-backup/latest/devguide/API_ListBackupJobs.html)
#'
#' @usage
#' dynamodb_list_backups(TableName, Limit, TimeRangeLowerBound,
#'   TimeRangeUpperBound, ExclusiveStartBackupArn, BackupType)
#'
#' @param TableName Lists the backups from the table specified in `TableName`. You can also
#' provide the Amazon Resource Name (ARN) of the table in this parameter.
#' @param Limit Maximum number of backups to return at once.
#' @param TimeRangeLowerBound Only backups created after this time are listed. `TimeRangeLowerBound`
#' is inclusive.
#' @param TimeRangeUpperBound Only backups created before this time are listed. `TimeRangeUpperBound`
#' is exclusive.
#' @param ExclusiveStartBackupArn `LastEvaluatedBackupArn` is the Amazon Resource Name (ARN) of the backup
#' last evaluated when the current page of results was returned, inclusive
#' of the current page of results. This value may be specified as the
#' `ExclusiveStartBackupArn` of a new
#' [`list_backups`][dynamodb_list_backups] operation in order to fetch the
#' next page of results.
#' @param BackupType The backups from the table specified by `BackupType` are listed.
#' 
#' Where `BackupType` can be:
#' 
#' -   `USER` - On-demand backup created by you. (The default setting if no
#'     other backup types are specified.)
#' 
#' -   `SYSTEM` - On-demand backup automatically created by DynamoDB.
#' 
#' -   `ALL` - All types of on-demand backups (USER and SYSTEM).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   BackupSummaries = list(
#'     list(
#'       TableName = "string",
#'       TableId = "string",
#'       TableArn = "string",
#'       BackupArn = "string",
#'       BackupName = "string",
#'       BackupCreationDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       BackupExpiryDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       BackupStatus = "CREATING"|"DELETED"|"AVAILABLE",
#'       BackupType = "USER"|"SYSTEM"|"AWS_BACKUP",
#'       BackupSizeBytes = 123
#'     )
#'   ),
#'   LastEvaluatedBackupArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_backups(
#'   TableName = "string",
#'   Limit = 123,
#'   TimeRangeLowerBound = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   TimeRangeUpperBound = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ExclusiveStartBackupArn = "string",
#'   BackupType = "USER"|"SYSTEM"|"AWS_BACKUP"|"ALL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_backups
#'
#' @aliases dynamodb_list_backups
dynamodb_list_backups <- function(TableName = NULL, Limit = NULL, TimeRangeLowerBound = NULL, TimeRangeUpperBound = NULL, ExclusiveStartBackupArn = NULL, BackupType = NULL) {
  op <- new_operation(
    name = "ListBackups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "ExclusiveStartBackupArn", output_token = "LastEvaluatedBackupArn", limit_key = "Limit", result_key = "BackupSummaries"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_backups_input(TableName = TableName, Limit = Limit, TimeRangeLowerBound = TimeRangeLowerBound, TimeRangeUpperBound = TimeRangeUpperBound, ExclusiveStartBackupArn = ExclusiveStartBackupArn, BackupType = BackupType)
  output <- .dynamodb$list_backups_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_backups <- dynamodb_list_backups

#' Returns a list of ContributorInsightsSummary for a table and all its
#' global secondary indexes
#'
#' @description
#' Returns a list of ContributorInsightsSummary for a table and all its
#' global secondary indexes.
#'
#' @usage
#' dynamodb_list_contributor_insights(TableName, NextToken, MaxResults)
#'
#' @param TableName The name of the table. You can also provide the Amazon Resource Name
#' (ARN) of the table in this parameter.
#' @param NextToken A token to for the desired page, if there is one.
#' @param MaxResults Maximum number of results to return per page.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ContributorInsightsSummaries = list(
#'     list(
#'       TableName = "string",
#'       IndexName = "string",
#'       ContributorInsightsStatus = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"FAILED",
#'       ContributorInsightsMode = "ACCESSED_AND_THROTTLED_KEYS"|"THROTTLED_KEYS"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_contributor_insights(
#'   TableName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_contributor_insights
#'
#' @aliases dynamodb_list_contributor_insights
dynamodb_list_contributor_insights <- function(TableName = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListContributorInsights",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_contributor_insights_input(TableName = TableName, NextToken = NextToken, MaxResults = MaxResults)
  output <- .dynamodb$list_contributor_insights_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_contributor_insights <- dynamodb_list_contributor_insights

#' Lists completed exports within the past 90 days
#'
#' @description
#' Lists completed exports within the past 90 days.
#'
#' @usage
#' dynamodb_list_exports(TableArn, MaxResults, NextToken)
#'
#' @param TableArn The Amazon Resource Name (ARN) associated with the exported table.
#' @param MaxResults Maximum number of results to return per page.
#' @param NextToken An optional string that, if supplied, must be copied from the output of
#' a previous call to [`list_exports`][dynamodb_list_exports]. When
#' provided in this manner, the API fetches the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ExportSummaries = list(
#'     list(
#'       ExportArn = "string",
#'       ExportStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED",
#'       ExportType = "FULL_EXPORT"|"INCREMENTAL_EXPORT"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_exports(
#'   TableArn = "string",
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_exports
#'
#' @aliases dynamodb_list_exports
dynamodb_list_exports <- function(TableArn = NULL, MaxResults = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListExports",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "MaxResults", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_exports_input(TableArn = TableArn, MaxResults = MaxResults, NextToken = NextToken)
  output <- .dynamodb$list_exports_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_exports <- dynamodb_list_exports

#' Lists all global tables that have a replica in the specified Region
#'
#' @description
#' Lists all global tables that have a replica in the specified Region.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#'
#' @usage
#' dynamodb_list_global_tables(ExclusiveStartGlobalTableName, Limit,
#'   RegionName)
#'
#' @param ExclusiveStartGlobalTableName The first global table name that this operation will evaluate.
#' @param Limit The maximum number of table names to return, if the parameter is not
#' specified DynamoDB defaults to 100.
#' 
#' If the number of global tables DynamoDB finds reaches this limit, it
#' stops the operation and returns the table names collected up to that
#' point, with a table name in the `LastEvaluatedGlobalTableName` to apply
#' in a subsequent operation to the `ExclusiveStartGlobalTableName`
#' parameter.
#' @param RegionName Lists the global tables in a specific Region.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTables = list(
#'     list(
#'       GlobalTableName = "string",
#'       ReplicationGroup = list(
#'         list(
#'           RegionName = "string"
#'         )
#'       )
#'     )
#'   ),
#'   LastEvaluatedGlobalTableName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_global_tables(
#'   ExclusiveStartGlobalTableName = "string",
#'   Limit = 123,
#'   RegionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_global_tables
#'
#' @aliases dynamodb_list_global_tables
dynamodb_list_global_tables <- function(ExclusiveStartGlobalTableName = NULL, Limit = NULL, RegionName = NULL) {
  op <- new_operation(
    name = "ListGlobalTables",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$list_global_tables_input(ExclusiveStartGlobalTableName = ExclusiveStartGlobalTableName, Limit = Limit, RegionName = RegionName)
  output <- .dynamodb$list_global_tables_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_global_tables <- dynamodb_list_global_tables

#' Lists completed imports within the past 90 days
#'
#' @description
#' Lists completed imports within the past 90 days.
#'
#' @usage
#' dynamodb_list_imports(TableArn, PageSize, NextToken)
#'
#' @param TableArn The Amazon Resource Name (ARN) associated with the table that was
#' imported to.
#' @param PageSize The number of `ImportSummary `objects returned in a single page.
#' @param NextToken An optional string that, if supplied, must be copied from the output of
#' a previous call to [`list_imports`][dynamodb_list_imports]. When
#' provided in this manner, the API fetches the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ImportSummaryList = list(
#'     list(
#'       ImportArn = "string",
#'       ImportStatus = "IN_PROGRESS"|"COMPLETED"|"CANCELLING"|"CANCELLED"|"FAILED",
#'       TableArn = "string",
#'       S3BucketSource = list(
#'         S3BucketOwner = "string",
#'         S3Bucket = "string",
#'         S3KeyPrefix = "string"
#'       ),
#'       CloudWatchLogGroupArn = "string",
#'       InputFormat = "DYNAMODB_JSON"|"ION"|"CSV",
#'       StartTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       EndTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_imports(
#'   TableArn = "string",
#'   PageSize = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_imports
#'
#' @aliases dynamodb_list_imports
dynamodb_list_imports <- function(TableArn = NULL, PageSize = NULL, NextToken = NULL) {
  op <- new_operation(
    name = "ListImports",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", limit_key = "PageSize", output_token = "NextToken"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_imports_input(TableArn = TableArn, PageSize = PageSize, NextToken = NextToken)
  output <- .dynamodb$list_imports_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_imports <- dynamodb_list_imports

#' Returns an array of table names associated with the current account and
#' endpoint
#'
#' @description
#' Returns an array of table names associated with the current account and
#' endpoint. The output from [`list_tables`][dynamodb_list_tables] is
#' paginated, with each page returning a maximum of 100 table names.
#'
#' @usage
#' dynamodb_list_tables(ExclusiveStartTableName, Limit)
#'
#' @param ExclusiveStartTableName The first table name that this operation will evaluate. Use the value
#' that was returned for `LastEvaluatedTableName` in a previous operation,
#' so that you can obtain the next page of results.
#' @param Limit A maximum number of table names to return. If this parameter is not
#' specified, the limit is 100.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableNames = list(
#'     "string"
#'   ),
#'   LastEvaluatedTableName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tables(
#'   ExclusiveStartTableName = "string",
#'   Limit = 123
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example lists all of the tables associated with the current AWS
#' # account and endpoint.
#' svc$list_tables()
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_tables
#'
#' @aliases dynamodb_list_tables
dynamodb_list_tables <- function(ExclusiveStartTableName = NULL, Limit = NULL) {
  op <- new_operation(
    name = "ListTables",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "ExclusiveStartTableName", output_token = "LastEvaluatedTableName", limit_key = "Limit", result_key = "TableNames"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_tables_input(ExclusiveStartTableName = ExclusiveStartTableName, Limit = Limit)
  output <- .dynamodb$list_tables_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_tables <- dynamodb_list_tables

#' List all tags on an Amazon DynamoDB resource
#'
#' @description
#' List all tags on an Amazon DynamoDB resource. You can call
#' ListTagsOfResource up to 10 times per second, per account.
#' 
#' For an overview on tagging DynamoDB resources, see [Tagging for
#' DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @usage
#' dynamodb_list_tags_of_resource(ResourceArn, NextToken)
#'
#' @param ResourceArn &#91;required&#93; The Amazon DynamoDB resource with tags to be listed. This value is an
#' Amazon Resource Name (ARN).
#' @param NextToken An optional string that, if supplied, must be copied from the output of
#' a previous call to ListTagOfResource. When provided in this manner, this
#' API fetches the next page of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_of_resource(
#'   ResourceArn = "string",
#'   NextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_list_tags_of_resource
#'
#' @aliases dynamodb_list_tags_of_resource
dynamodb_list_tags_of_resource <- function(ResourceArn, NextToken = NULL) {
  op <- new_operation(
    name = "ListTagsOfResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", result_key = "Tags"),
    stream_api = FALSE
  )
  input <- .dynamodb$list_tags_of_resource_input(ResourceArn = ResourceArn, NextToken = NextToken)
  output <- .dynamodb$list_tags_of_resource_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$list_tags_of_resource <- dynamodb_list_tags_of_resource

#' Creates a new item, or replaces an old item with a new item
#'
#' @description
#' Creates a new item, or replaces an old item with a new item. If an item
#' that has the same primary key as the new item already exists in the
#' specified table, the new item completely replaces the existing item. You
#' can perform a conditional put operation (add a new item if one with the
#' specified primary key doesn't exist), or replace an existing item if it
#' has certain attribute values. You can return the item's attribute values
#' in the same operation, using the `ReturnValues` parameter.
#' 
#' When you add an item, the primary key attributes are the only required
#' attributes.
#' 
#' Empty String and Binary attribute values are allowed. Attribute values
#' of type String and Binary must have a length greater than zero if the
#' attribute is used as a key attribute for a table or index. Set type
#' attributes cannot be empty.
#' 
#' Invalid Requests with empty values will be rejected with a
#' `ValidationException` exception.
#' 
#' To prevent a new item from replacing an existing item, use a conditional
#' expression that contains the `attribute_not_exists` function with the
#' name of the attribute being used as the partition key for the table.
#' Since every record must contain that attribute, the
#' `attribute_not_exists` function will only succeed if no matching item
#' exists.
#' 
#' For more information about [`put_item`][dynamodb_put_item], see [Working
#' with
#' Items](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @usage
#' dynamodb_put_item(TableName, Item, Expected, ReturnValues,
#'   ReturnConsumedCapacity, ReturnItemCollectionMetrics,
#'   ConditionalOperator, ConditionExpression, ExpressionAttributeNames,
#'   ExpressionAttributeValues, ReturnValuesOnConditionCheckFailure)
#'
#' @param TableName &#91;required&#93; The name of the table to contain the item. You can also provide the
#' Amazon Resource Name (ARN) of the table in this parameter.
#' @param Item &#91;required&#93; A map of attribute name/value pairs, one for each attribute. Only the
#' primary key attributes are required; you can optionally provide other
#' attribute name-value pairs for the item.
#' 
#' You must provide all of the attributes for the primary key. For example,
#' with a simple primary key, you only need to provide a value for the
#' partition key. For a composite primary key, you must provide both values
#' for both the partition key and the sort key.
#' 
#' If you specify any attributes that are part of an index key, then the
#' data types for those attributes must match those of the schema in the
#' table's attribute definition.
#' 
#' Empty String and Binary attribute values are allowed. Attribute values
#' of type String and Binary must have a length greater than zero if the
#' attribute is used as a key attribute for a table or index.
#' 
#' For more information about primary keys, see [Primary
#' Key](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html#HowItWorks.CoreComponents.PrimaryKey)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' Each element in the `Item` map is an `AttributeValue` object.
#' @param Expected This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [Expected](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValues Use `ReturnValues` if you want to get the item attributes as they
#' appeared before they were updated with the
#' [`put_item`][dynamodb_put_item] request. For
#' [`put_item`][dynamodb_put_item], the valid values are:
#' 
#' -   `NONE` - If `ReturnValues` is not specified, or if its value is
#'     `NONE`, then nothing is returned. (This setting is the default for
#'     `ReturnValues`.)
#' 
#' -   `ALL_OLD` - If [`put_item`][dynamodb_put_item] overwrote an
#'     attribute name-value pair, then the content of the old item is
#'     returned.
#' 
#' The values returned are strongly consistent.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#' 
#' The `ReturnValues` parameter is used by several DynamoDB operations;
#' however, [`put_item`][dynamodb_put_item] does not recognize any values
#' other than `NONE` or `ALL_OLD`.
#' @param ReturnConsumedCapacity 
#' @param ReturnItemCollectionMetrics Determines whether item collection metrics are returned. If set to
#' `SIZE`, the response includes statistics about item collections, if any,
#' that were modified during the operation are returned in the response. If
#' set to `NONE` (the default), no statistics are returned.
#' @param ConditionalOperator This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [ConditionalOperator](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionExpression A condition that must be satisfied in order for a conditional
#' [`put_item`][dynamodb_put_item] operation to succeed.
#' 
#' An expression can contain any of the following:
#' 
#' -   Functions:
#'     `attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size`
#' 
#'     These function names are case-sensitive.
#' 
#' -   Comparison operators: `= | <> | < | > | <= | >= | BETWEEN | IN `
#' 
#' -   Logical operators: `AND | OR | NOT`
#' 
#' For more information on condition expressions, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*). To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information on expression attribute names, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeValues One or more values that can be substituted in an expression.
#' 
#' Use the **:** (colon) character in an expression to dereference an
#' attribute value. For example, suppose that you wanted to check whether
#' the value of the *ProductStatus* attribute was one of the following:
#' 
#' `Available | Backordered | Discontinued`
#' 
#' You would first need to specify `ExpressionAttributeValues` as follows:
#' 
#' `{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }`
#' 
#' You could then use these values in an expression, such as this:
#' 
#' `ProductStatus IN (:avail, :back, :disc)`
#' 
#' For more information on expression attribute values, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValuesOnConditionCheckFailure An optional parameter that returns the item attributes for a
#' [`put_item`][dynamodb_put_item] operation that failed a condition check.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Attributes = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   ),
#'   ItemCollectionMetrics = list(
#'     ItemCollectionKey = list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     ),
#'     SizeEstimateRangeGB = list(
#'       123.0
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_item(
#'   TableName = "string",
#'   Item = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   Expected = list(
#'     list(
#'       Value = list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       ),
#'       Exists = TRUE|FALSE,
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH",
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   ReturnValues = "NONE"|"ALL_OLD"|"UPDATED_OLD"|"ALL_NEW"|"UPDATED_NEW",
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ReturnItemCollectionMetrics = "SIZE"|"NONE",
#'   ConditionalOperator = "AND"|"OR",
#'   ConditionExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   ),
#'   ExpressionAttributeValues = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example adds a new item to the Music table.
#' svc$put_item(
#'   Item = list(
#'     AlbumTitle = list(
#'       S = "Somewhat Famous"
#'     ),
#'     Artist = list(
#'       S = "No One You Know"
#'     ),
#'     SongTitle = list(
#'       S = "Call Me Today"
#'     )
#'   ),
#'   ReturnConsumedCapacity = "TOTAL",
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_put_item
#'
#' @aliases dynamodb_put_item
dynamodb_put_item <- function(TableName, Item, Expected = NULL, ReturnValues = NULL, ReturnConsumedCapacity = NULL, ReturnItemCollectionMetrics = NULL, ConditionalOperator = NULL, ConditionExpression = NULL, ExpressionAttributeNames = NULL, ExpressionAttributeValues = NULL, ReturnValuesOnConditionCheckFailure = NULL) {
  op <- new_operation(
    name = "PutItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$put_item_input(TableName = TableName, Item = Item, Expected = Expected, ReturnValues = ReturnValues, ReturnConsumedCapacity = ReturnConsumedCapacity, ReturnItemCollectionMetrics = ReturnItemCollectionMetrics, ConditionalOperator = ConditionalOperator, ConditionExpression = ConditionExpression, ExpressionAttributeNames = ExpressionAttributeNames, ExpressionAttributeValues = ExpressionAttributeValues, ReturnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure)
  output <- .dynamodb$put_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$put_item <- dynamodb_put_item

#' Attaches a resource-based policy document to the resource, which can be
#' a table or stream
#'
#' @description
#' Attaches a resource-based policy document to the resource, which can be
#' a table or stream. When you attach a resource-based policy using this
#' API, the policy application is [*eventually
#' consistent*](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html)
#' .
#' 
#' [`put_resource_policy`][dynamodb_put_resource_policy] is an idempotent
#' operation; running it multiple times on the same resource using the same
#' policy document will return the same revision ID. If you specify an
#' `ExpectedRevisionId` that doesn't match the current policy's
#' `RevisionId`, the `PolicyNotFoundException` will be returned.
#' 
#' [`put_resource_policy`][dynamodb_put_resource_policy] is an asynchronous
#' operation. If you issue a
#' [`get_resource_policy`][dynamodb_get_resource_policy] request
#' immediately after a
#' [`put_resource_policy`][dynamodb_put_resource_policy] request, DynamoDB
#' might return your previous policy, if there was one, or return the
#' `PolicyNotFoundException`. This is because
#' [`get_resource_policy`][dynamodb_get_resource_policy] uses an eventually
#' consistent query, and the metadata for your policy or table might not be
#' available at that moment. Wait for a few seconds, and then try the
#' [`get_resource_policy`][dynamodb_get_resource_policy] request again.
#'
#' @usage
#' dynamodb_put_resource_policy(ResourceArn, Policy, ExpectedRevisionId,
#'   ConfirmRemoveSelfResourceAccess)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the DynamoDB resource to which the
#' policy will be attached. The resources you can specify include tables
#' and streams.
#' 
#' You can control index permissions using the base table's policy. To
#' specify the same permission level for your table and its indexes, you
#' can provide both the table and index Amazon Resource Name (ARN)s in the
#' `Resource` field of a given `Statement` in your policy document.
#' Alternatively, to specify different permissions for your table, indexes,
#' or both, you can define multiple `Statement` fields in your policy
#' document.
#' @param Policy &#91;required&#93; An Amazon Web Services resource-based policy document in JSON format.
#' 
#' -   The maximum size supported for a resource-based policy document is
#'     20 KB. DynamoDB counts whitespaces when calculating the size of a
#'     policy against this limit.
#' 
#' -   Within a resource-based policy, if the action for a DynamoDB
#'     service-linked role (SLR) to replicate data for a global table is
#'     denied, adding or deleting a replica will fail with an error.
#' 
#' For a full list of all considerations that apply while attaching a
#' resource-based policy, see [Resource-based policy
#' considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
#' @param ExpectedRevisionId A string value that you can use to conditionally update your policy. You
#' can provide the revision ID of your existing policy to make mutating
#' requests against that policy.
#' 
#' When you provide an expected revision ID, if the revision ID of the
#' existing policy on the resource doesn't match or if there's no policy
#' attached to the resource, your request will be rejected with a
#' `PolicyNotFoundException`.
#' 
#' To conditionally attach a policy when no policy exists for the resource,
#' specify `NO_POLICY` for the revision ID.
#' @param ConfirmRemoveSelfResourceAccess Set this parameter to `true` to confirm that you want to remove your
#' permissions to change the policy of this resource in the future.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RevisionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_resource_policy(
#'   ResourceArn = "string",
#'   Policy = "string",
#'   ExpectedRevisionId = "string",
#'   ConfirmRemoveSelfResourceAccess = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_put_resource_policy
#'
#' @aliases dynamodb_put_resource_policy
dynamodb_put_resource_policy <- function(ResourceArn, Policy, ExpectedRevisionId = NULL, ConfirmRemoveSelfResourceAccess = NULL) {
  op <- new_operation(
    name = "PutResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$put_resource_policy_input(ResourceArn = ResourceArn, Policy = Policy, ExpectedRevisionId = ExpectedRevisionId, ConfirmRemoveSelfResourceAccess = ConfirmRemoveSelfResourceAccess)
  output <- .dynamodb$put_resource_policy_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$put_resource_policy <- dynamodb_put_resource_policy

#' You must provide the name of the partition key attribute and a single
#' value for that attribute
#'
#' @description
#' You must provide the name of the partition key attribute and a single
#' value for that attribute. [`query`][dynamodb_query] returns all items
#' with that partition key value. Optionally, you can provide a sort key
#' attribute and use a comparison operator to refine the search results.
#' 
#' Use the `KeyConditionExpression` parameter to provide a specific value
#' for the partition key. The [`query`][dynamodb_query] operation will
#' return all of the items from the table or index with that partition key
#' value. You can optionally narrow the scope of the
#' [`query`][dynamodb_query] operation by specifying a sort key value and a
#' comparison operator in `KeyConditionExpression`. To further refine the
#' [`query`][dynamodb_query] results, you can optionally provide a
#' `FilterExpression`. A `FilterExpression` determines which items within
#' the results should be returned to you. All of the other results are
#' discarded.
#' 
#' A [`query`][dynamodb_query] operation always returns a result set. If no
#' matching items are found, the result set will be empty. Queries that do
#' not return results consume the minimum number of read capacity units for
#' that type of read operation.
#' 
#' DynamoDB calculates the number of read capacity units consumed based on
#' item size, not on the amount of data that is returned to an application.
#' The number of capacity units consumed will be the same whether you
#' request all of the attributes (the default behavior) or just some of
#' them (using a projection expression). The number will also be the same
#' whether or not you use a `FilterExpression`.
#' 
#' [`query`][dynamodb_query] results are always sorted by the sort key
#' value. If the data type of the sort key is Number, the results are
#' returned in numeric order; otherwise, the results are returned in order
#' of UTF-8 bytes. By default, the sort order is ascending. To reverse the
#' order, set the `ScanIndexForward` parameter to false.
#' 
#' A single [`query`][dynamodb_query] operation will read up to the maximum
#' number of items set (if using the `Limit` parameter) or a maximum of 1
#' MB of data and then apply any filtering to the results using
#' `FilterExpression`. If `LastEvaluatedKey` is present in the response,
#' you will need to paginate the result set. For more information, see
#' [Paginating the
#' Results](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html#Query.Pagination)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' `FilterExpression` is applied after a [`query`][dynamodb_query]
#' finishes, but before the results are returned. A `FilterExpression`
#' cannot contain partition key or sort key attributes. You need to specify
#' those attributes in the `KeyConditionExpression`.
#' 
#' A [`query`][dynamodb_query] operation can return an empty result set and
#' a `LastEvaluatedKey` if all the items read for the page of results are
#' filtered out.
#' 
#' You can query a table, a local secondary index, or a global secondary
#' index. For a query on a table or on a local secondary index, you can set
#' the `ConsistentRead` parameter to `true` and obtain a strongly
#' consistent result. Global secondary indexes support eventually
#' consistent reads only, so do not specify `ConsistentRead` when querying
#' a global secondary index.
#'
#' @usage
#' dynamodb_query(TableName, IndexName, Select, AttributesToGet, Limit,
#'   ConsistentRead, KeyConditions, QueryFilter, ConditionalOperator,
#'   ScanIndexForward, ExclusiveStartKey, ReturnConsumedCapacity,
#'   ProjectionExpression, FilterExpression, KeyConditionExpression,
#'   ExpressionAttributeNames, ExpressionAttributeValues)
#'
#' @param TableName &#91;required&#93; The name of the table containing the requested items. You can also
#' provide the Amazon Resource Name (ARN) of the table in this parameter.
#' @param IndexName The name of an index to query. This index can be any local secondary
#' index or global secondary index on the table. Note that if you use the
#' `IndexName` parameter, you must also provide `TableName.`
#' @param Select The attributes to be returned in the result. You can retrieve all item
#' attributes, specific item attributes, the count of matching items, or in
#' the case of an index, some or all of the attributes projected into the
#' index.
#' 
#' -   `ALL_ATTRIBUTES` - Returns all of the item attributes from the
#'     specified table or index. If you query a local secondary index, then
#'     for each matching item in the index, DynamoDB fetches the entire
#'     item from the parent table. If the index is configured to project
#'     all item attributes, then all of the data can be obtained from the
#'     local secondary index, and no fetching is required.
#' 
#' -   `ALL_PROJECTED_ATTRIBUTES` - Allowed only when querying an index.
#'     Retrieves all attributes that have been projected into the index. If
#'     the index is configured to project all attributes, this return value
#'     is equivalent to specifying `ALL_ATTRIBUTES`.
#' 
#' -   `COUNT` - Returns the number of matching items, rather than the
#'     matching items themselves. Note that this uses the same quantity of
#'     read capacity units as getting the items, and is subject to the same
#'     item size calculations.
#' 
#' -   `SPECIFIC_ATTRIBUTES` - Returns only the attributes listed in
#'     `ProjectionExpression`. This return value is equivalent to
#'     specifying `ProjectionExpression` without specifying any value for
#'     `Select`.
#' 
#'     If you query or scan a local secondary index and request only
#'     attributes that are projected into that index, the operation will
#'     read only the index and not the table. If any of the requested
#'     attributes are not projected into the local secondary index,
#'     DynamoDB fetches each of these attributes from the parent table.
#'     This extra fetching incurs additional throughput cost and latency.
#' 
#'     If you query or scan a global secondary index, you can only request
#'     attributes that are projected into the index. Global secondary index
#'     queries cannot fetch attributes from the parent table.
#' 
#' If neither `Select` nor `ProjectionExpression` are specified, DynamoDB
#' defaults to `ALL_ATTRIBUTES` when accessing a table, and
#' `ALL_PROJECTED_ATTRIBUTES` when accessing an index. You cannot use both
#' `Select` and `ProjectionExpression` together in a single request, unless
#' the value for `Select` is `SPECIFIC_ATTRIBUTES`. (This usage is
#' equivalent to specifying `ProjectionExpression` without any value for
#' `Select`.)
#' 
#' If you use the `ProjectionExpression` parameter, then the value for
#' `Select` can only be `SPECIFIC_ATTRIBUTES`. Any other value for `Select`
#' will return an error.
#' @param AttributesToGet This is a legacy parameter. Use `ProjectionExpression` instead. For more
#' information, see
#' [AttributesToGet](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param Limit The maximum number of items to evaluate (not necessarily the number of
#' matching items). If DynamoDB processes the number of items up to the
#' limit while processing the results, it stops the operation and returns
#' the matching values up to that point, and a key in `LastEvaluatedKey` to
#' apply in a subsequent operation, so that you can pick up where you left
#' off. Also, if the processed dataset size exceeds 1 MB before DynamoDB
#' reaches this limit, it stops the operation and returns the matching
#' values up to the limit, and a key in `LastEvaluatedKey` to apply in a
#' subsequent operation to continue the operation. For more information,
#' see [Query and
#' Scan](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConsistentRead Determines the read consistency model: If set to `true`, then the
#' operation uses strongly consistent reads; otherwise, the operation uses
#' eventually consistent reads.
#' 
#' Strongly consistent reads are not supported on global secondary indexes.
#' If you query a global secondary index with `ConsistentRead` set to
#' `true`, you will receive a `ValidationException`.
#' @param KeyConditions This is a legacy parameter. Use `KeyConditionExpression` instead. For
#' more information, see
#' [KeyConditions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.KeyConditions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param QueryFilter This is a legacy parameter. Use `FilterExpression` instead. For more
#' information, see
#' [QueryFilter](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.QueryFilter.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionalOperator This is a legacy parameter. Use `FilterExpression` instead. For more
#' information, see
#' [ConditionalOperator](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ScanIndexForward Specifies the order for index traversal: If `true` (default), the
#' traversal is performed in ascending order; if `false`, the traversal is
#' performed in descending order.
#' 
#' Items with the same partition key value are stored in sorted order by
#' sort key. If the sort key data type is Number, the results are stored in
#' numeric order. For type String, the results are stored in order of UTF-8
#' bytes. For type Binary, DynamoDB treats each byte of the binary data as
#' unsigned.
#' 
#' If `ScanIndexForward` is `true`, DynamoDB returns the results in the
#' order in which they are stored (by sort key value). This is the default
#' behavior. If `ScanIndexForward` is `false`, DynamoDB reads the results
#' in reverse order by sort key value, and then returns the results to the
#' client.
#' @param ExclusiveStartKey The primary key of the first item that this operation will evaluate. Use
#' the value that was returned for `LastEvaluatedKey` in the previous
#' operation.
#' 
#' The data type for `ExclusiveStartKey` must be String, Number, or Binary.
#' No set data types are allowed.
#' @param ReturnConsumedCapacity 
#' @param ProjectionExpression A string that identifies one or more attributes to retrieve from the
#' table. These attributes can include scalars, sets, or elements of a JSON
#' document. The attributes in the expression must be separated by commas.
#' 
#' If no attribute names are specified, then all attributes will be
#' returned. If any of the requested attributes are not found, they will
#' not appear in the result.
#' 
#' For more information, see [Accessing Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param FilterExpression A string that contains conditions that DynamoDB applies after the
#' [`query`][dynamodb_query] operation, but before the data is returned to
#' you. Items that do not satisfy the `FilterExpression` criteria are not
#' returned.
#' 
#' A `FilterExpression` does not allow key attributes. You cannot define a
#' filter expression based on a partition key or a sort key.
#' 
#' A `FilterExpression` is applied after the items have already been read;
#' the process of filtering does not consume any additional read capacity
#' units.
#' 
#' For more information, see [Filter
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.FilterExpression.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param KeyConditionExpression The condition that specifies the key values for items to be retrieved by
#' the [`query`][dynamodb_query] action.
#' 
#' The condition must perform an equality test on a single partition key
#' value.
#' 
#' The condition can optionally perform one of several comparison tests on
#' a single sort key value. This allows [`query`][dynamodb_query] to
#' retrieve one item with a given partition key value and sort key value,
#' or several items that have the same partition key value but different
#' sort key values.
#' 
#' The partition key equality test is required, and must be specified in
#' the following format:
#' 
#' `partitionKeyName` *=* `:partitionkeyval`
#' 
#' If you also want to provide a condition for the sort key, it must be
#' combined using `AND` with the condition for the sort key. Following is
#' an example, using the **=** comparison operator for the sort key:
#' 
#' `partitionKeyName` `=` `:partitionkeyval` `AND` `sortKeyName` `=`
#' `:sortkeyval`
#' 
#' Valid comparisons for the sort key condition are as follows:
#' 
#' -   `sortKeyName` `=` `:sortkeyval` - true if the sort key value is
#'     equal to `:sortkeyval`.
#' 
#' -   `sortKeyName` `<` `:sortkeyval` - true if the sort key value is less
#'     than `:sortkeyval`.
#' 
#' -   `sortKeyName` `<=` `:sortkeyval` - true if the sort key value is
#'     less than or equal to `:sortkeyval`.
#' 
#' -   `sortKeyName` `>` `:sortkeyval` - true if the sort key value is
#'     greater than `:sortkeyval`.
#' 
#' -   `sortKeyName` `>= ` `:sortkeyval` - true if the sort key value is
#'     greater than or equal to `:sortkeyval`.
#' 
#' -   `sortKeyName` `BETWEEN` `:sortkeyval1` `AND` `:sortkeyval2` - true
#'     if the sort key value is greater than or equal to `:sortkeyval1`,
#'     and less than or equal to `:sortkeyval2`.
#' 
#' -   `begins_with (` `sortKeyName`, `:sortkeyval` `)` - true if the sort
#'     key value begins with a particular operand. (You cannot use this
#'     function with a sort key that is of type Number.) Note that the
#'     function name `begins_with` is case-sensitive.
#' 
#' Use the `ExpressionAttributeValues` parameter to replace tokens such as
#' `:partitionval` and `:sortval` with actual values at runtime.
#' 
#' You can optionally use the `ExpressionAttributeNames` parameter to
#' replace the names of the partition key and sort key with placeholder
#' tokens. This option might be necessary if an attribute name conflicts
#' with a DynamoDB reserved word. For example, the following
#' `KeyConditionExpression` parameter causes an error because *Size* is a
#' reserved word:
#' 
#' -   `Size = :myval`
#' 
#' To work around this, define a placeholder (such a `#S`) to represent the
#' attribute name *Size*. `KeyConditionExpression` then is as follows:
#' 
#' -   `#S = :myval`
#' 
#' For a list of reserved words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' For more information on `ExpressionAttributeNames` and
#' `ExpressionAttributeValues`, see [Using Placeholders for Attribute Names
#' and
#' Values](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionAttributeNames.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*). To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information on expression attribute names, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeValues One or more values that can be substituted in an expression.
#' 
#' Use the **:** (colon) character in an expression to dereference an
#' attribute value. For example, suppose that you wanted to check whether
#' the value of the *ProductStatus* attribute was one of the following:
#' 
#' `Available | Backordered | Discontinued`
#' 
#' You would first need to specify `ExpressionAttributeValues` as follows:
#' 
#' `{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }`
#' 
#' You could then use these values in an expression, such as this:
#' 
#' `ProductStatus IN (:avail, :back, :disc)`
#' 
#' For more information on expression attribute values, see [Specifying
#' Conditions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Items = list(
#'     list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   Count = 123,
#'   ScannedCount = 123,
#'   LastEvaluatedKey = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$query(
#'   TableName = "string",
#'   IndexName = "string",
#'   Select = "ALL_ATTRIBUTES"|"ALL_PROJECTED_ATTRIBUTES"|"SPECIFIC_ATTRIBUTES"|"COUNT",
#'   AttributesToGet = list(
#'     "string"
#'   ),
#'   Limit = 123,
#'   ConsistentRead = TRUE|FALSE,
#'   KeyConditions = list(
#'     list(
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       ),
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH"
#'     )
#'   ),
#'   QueryFilter = list(
#'     list(
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       ),
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH"
#'     )
#'   ),
#'   ConditionalOperator = "AND"|"OR",
#'   ScanIndexForward = TRUE|FALSE,
#'   ExclusiveStartKey = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ProjectionExpression = "string",
#'   FilterExpression = "string",
#'   KeyConditionExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   ),
#'   ExpressionAttributeValues = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example queries items in the Music table. The table has a partition
#' # key and sort key (Artist and SongTitle), but this query only specifies
#' # the partition key value. It returns song titles by the artist named "No
#' # One You Know".
#' svc$query(
#'   ExpressionAttributeValues = list(
#'     `:v1` = list(
#'       S = "No One You Know"
#'     )
#'   ),
#'   KeyConditionExpression = "Artist = :v1",
#'   ProjectionExpression = "SongTitle",
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_query
#'
#' @aliases dynamodb_query
dynamodb_query <- function(TableName, IndexName = NULL, Select = NULL, AttributesToGet = NULL, Limit = NULL, ConsistentRead = NULL, KeyConditions = NULL, QueryFilter = NULL, ConditionalOperator = NULL, ScanIndexForward = NULL, ExclusiveStartKey = NULL, ReturnConsumedCapacity = NULL, ProjectionExpression = NULL, FilterExpression = NULL, KeyConditionExpression = NULL, ExpressionAttributeNames = NULL, ExpressionAttributeValues = NULL) {
  op <- new_operation(
    name = "Query",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "ExclusiveStartKey", output_token = "LastEvaluatedKey", limit_key = "Limit", result_key = list("Items", "Count", "ScannedCount"), non_aggregate_keys = list("ConsumedCapacity")),
    stream_api = FALSE
  )
  input <- .dynamodb$query_input(TableName = TableName, IndexName = IndexName, Select = Select, AttributesToGet = AttributesToGet, Limit = Limit, ConsistentRead = ConsistentRead, KeyConditions = KeyConditions, QueryFilter = QueryFilter, ConditionalOperator = ConditionalOperator, ScanIndexForward = ScanIndexForward, ExclusiveStartKey = ExclusiveStartKey, ReturnConsumedCapacity = ReturnConsumedCapacity, ProjectionExpression = ProjectionExpression, FilterExpression = FilterExpression, KeyConditionExpression = KeyConditionExpression, ExpressionAttributeNames = ExpressionAttributeNames, ExpressionAttributeValues = ExpressionAttributeValues)
  output <- .dynamodb$query_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$query <- dynamodb_query

#' Creates a new table from an existing backup
#'
#' @description
#' Creates a new table from an existing backup. Any number of users can
#' execute up to 50 concurrent restores (any type of restore) in a given
#' account.
#' 
#' You can call
#' [`restore_table_from_backup`][dynamodb_restore_table_from_backup] at a
#' maximum rate of 10 times per second.
#' 
#' You must manually set up the following on the restored table:
#' 
#' -   Auto scaling policies
#' 
#' -   IAM policies
#' 
#' -   Amazon CloudWatch metrics and alarms
#' 
#' -   Tags
#' 
#' -   Stream settings
#' 
#' -   Time to Live (TTL) settings
#'
#' @usage
#' dynamodb_restore_table_from_backup(TargetTableName, BackupArn,
#'   BillingModeOverride, GlobalSecondaryIndexOverride,
#'   LocalSecondaryIndexOverride, ProvisionedThroughputOverride,
#'   OnDemandThroughputOverride, SSESpecificationOverride)
#'
#' @param TargetTableName &#91;required&#93; The name of the new table to which the backup must be restored.
#' @param BackupArn &#91;required&#93; The Amazon Resource Name (ARN) associated with the backup.
#' @param BillingModeOverride The billing mode of the restored table.
#' @param GlobalSecondaryIndexOverride List of global secondary indexes for the restored table. The indexes
#' provided should match existing secondary indexes. You can choose to
#' exclude some or all of the indexes at the time of restore.
#' @param LocalSecondaryIndexOverride List of local secondary indexes for the restored table. The indexes
#' provided should match existing secondary indexes. You can choose to
#' exclude some or all of the indexes at the time of restore.
#' @param ProvisionedThroughputOverride Provisioned throughput settings for the restored table.
#' @param OnDemandThroughputOverride 
#' @param SSESpecificationOverride The new server-side encryption settings for the restored table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableDescription = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$restore_table_from_backup(
#'   TargetTableName = "string",
#'   BackupArn = "string",
#'   BillingModeOverride = "PROVISIONED"|"PAY_PER_REQUEST",
#'   GlobalSecondaryIndexOverride = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       ),
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       WarmThroughput = list(
#'         ReadUnitsPerSecond = 123,
#'         WriteUnitsPerSecond = 123
#'       )
#'     )
#'   ),
#'   LocalSecondaryIndexOverride = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ProvisionedThroughputOverride = list(
#'     ReadCapacityUnits = 123,
#'     WriteCapacityUnits = 123
#'   ),
#'   OnDemandThroughputOverride = list(
#'     MaxReadRequestUnits = 123,
#'     MaxWriteRequestUnits = 123
#'   ),
#'   SSESpecificationOverride = list(
#'     Enabled = TRUE|FALSE,
#'     SSEType = "AES256"|"KMS",
#'     KMSMasterKeyId = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_restore_table_from_backup
#'
#' @aliases dynamodb_restore_table_from_backup
dynamodb_restore_table_from_backup <- function(TargetTableName, BackupArn, BillingModeOverride = NULL, GlobalSecondaryIndexOverride = NULL, LocalSecondaryIndexOverride = NULL, ProvisionedThroughputOverride = NULL, OnDemandThroughputOverride = NULL, SSESpecificationOverride = NULL) {
  op <- new_operation(
    name = "RestoreTableFromBackup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$restore_table_from_backup_input(TargetTableName = TargetTableName, BackupArn = BackupArn, BillingModeOverride = BillingModeOverride, GlobalSecondaryIndexOverride = GlobalSecondaryIndexOverride, LocalSecondaryIndexOverride = LocalSecondaryIndexOverride, ProvisionedThroughputOverride = ProvisionedThroughputOverride, OnDemandThroughputOverride = OnDemandThroughputOverride, SSESpecificationOverride = SSESpecificationOverride)
  output <- .dynamodb$restore_table_from_backup_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$restore_table_from_backup <- dynamodb_restore_table_from_backup

#' Restores the specified table to the specified point in time within
#' EarliestRestorableDateTime and LatestRestorableDateTime
#'
#' @description
#' Restores the specified table to the specified point in time within
#' `EarliestRestorableDateTime` and `LatestRestorableDateTime`. You can
#' restore your table to any point in time in the last 35 days. You can set
#' the recovery period to any value between 1 and 35 days. Any number of
#' users can execute up to 50 concurrent restores (any type of restore) in
#' a given account.
#' 
#' When you restore using point in time recovery, DynamoDB restores your
#' table data to the state based on the selected date and time
#' (day:hour:minute:second) to a new table.
#' 
#' Along with data, the following are also included on the new restored
#' table using point in time recovery:
#' 
#' -   Global secondary indexes (GSIs)
#' 
#' -   Local secondary indexes (LSIs)
#' 
#' -   Provisioned read and write capacity
#' 
#' -   Encryption settings
#' 
#'     All these settings come from the current settings of the source
#'     table at the time of restore.
#' 
#' You must manually set up the following on the restored table:
#' 
#' -   Auto scaling policies
#' 
#' -   IAM policies
#' 
#' -   Amazon CloudWatch metrics and alarms
#' 
#' -   Tags
#' 
#' -   Stream settings
#' 
#' -   Time to Live (TTL) settings
#' 
#' -   Point in time recovery settings
#'
#' @usage
#' dynamodb_restore_table_to_point_in_time(SourceTableArn, SourceTableName,
#'   TargetTableName, UseLatestRestorableTime, RestoreDateTime,
#'   BillingModeOverride, GlobalSecondaryIndexOverride,
#'   LocalSecondaryIndexOverride, ProvisionedThroughputOverride,
#'   OnDemandThroughputOverride, SSESpecificationOverride)
#'
#' @param SourceTableArn The DynamoDB table that will be restored. This value is an Amazon
#' Resource Name (ARN).
#' @param SourceTableName Name of the source table that is being restored.
#' @param TargetTableName &#91;required&#93; The name of the new table to which it must be restored to.
#' @param UseLatestRestorableTime Restore the table to the latest possible time.
#' `LatestRestorableDateTime` is typically 5 minutes before the current
#' time.
#' @param RestoreDateTime Time in the past to restore the table to.
#' @param BillingModeOverride The billing mode of the restored table.
#' @param GlobalSecondaryIndexOverride List of global secondary indexes for the restored table. The indexes
#' provided should match existing secondary indexes. You can choose to
#' exclude some or all of the indexes at the time of restore.
#' @param LocalSecondaryIndexOverride List of local secondary indexes for the restored table. The indexes
#' provided should match existing secondary indexes. You can choose to
#' exclude some or all of the indexes at the time of restore.
#' @param ProvisionedThroughputOverride Provisioned throughput settings for the restored table.
#' @param OnDemandThroughputOverride 
#' @param SSESpecificationOverride The new server-side encryption settings for the restored table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableDescription = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$restore_table_to_point_in_time(
#'   SourceTableArn = "string",
#'   SourceTableName = "string",
#'   TargetTableName = "string",
#'   UseLatestRestorableTime = TRUE|FALSE,
#'   RestoreDateTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   BillingModeOverride = "PROVISIONED"|"PAY_PER_REQUEST",
#'   GlobalSecondaryIndexOverride = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       ),
#'       ProvisionedThroughput = list(
#'         ReadCapacityUnits = 123,
#'         WriteCapacityUnits = 123
#'       ),
#'       OnDemandThroughput = list(
#'         MaxReadRequestUnits = 123,
#'         MaxWriteRequestUnits = 123
#'       ),
#'       WarmThroughput = list(
#'         ReadUnitsPerSecond = 123,
#'         WriteUnitsPerSecond = 123
#'       )
#'     )
#'   ),
#'   LocalSecondaryIndexOverride = list(
#'     list(
#'       IndexName = "string",
#'       KeySchema = list(
#'         list(
#'           AttributeName = "string",
#'           KeyType = "HASH"|"RANGE"
#'         )
#'       ),
#'       Projection = list(
#'         ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'         NonKeyAttributes = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ProvisionedThroughputOverride = list(
#'     ReadCapacityUnits = 123,
#'     WriteCapacityUnits = 123
#'   ),
#'   OnDemandThroughputOverride = list(
#'     MaxReadRequestUnits = 123,
#'     MaxWriteRequestUnits = 123
#'   ),
#'   SSESpecificationOverride = list(
#'     Enabled = TRUE|FALSE,
#'     SSEType = "AES256"|"KMS",
#'     KMSMasterKeyId = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_restore_table_to_point_in_time
#'
#' @aliases dynamodb_restore_table_to_point_in_time
dynamodb_restore_table_to_point_in_time <- function(SourceTableArn = NULL, SourceTableName = NULL, TargetTableName, UseLatestRestorableTime = NULL, RestoreDateTime = NULL, BillingModeOverride = NULL, GlobalSecondaryIndexOverride = NULL, LocalSecondaryIndexOverride = NULL, ProvisionedThroughputOverride = NULL, OnDemandThroughputOverride = NULL, SSESpecificationOverride = NULL) {
  op <- new_operation(
    name = "RestoreTableToPointInTime",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$restore_table_to_point_in_time_input(SourceTableArn = SourceTableArn, SourceTableName = SourceTableName, TargetTableName = TargetTableName, UseLatestRestorableTime = UseLatestRestorableTime, RestoreDateTime = RestoreDateTime, BillingModeOverride = BillingModeOverride, GlobalSecondaryIndexOverride = GlobalSecondaryIndexOverride, LocalSecondaryIndexOverride = LocalSecondaryIndexOverride, ProvisionedThroughputOverride = ProvisionedThroughputOverride, OnDemandThroughputOverride = OnDemandThroughputOverride, SSESpecificationOverride = SSESpecificationOverride)
  output <- .dynamodb$restore_table_to_point_in_time_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$restore_table_to_point_in_time <- dynamodb_restore_table_to_point_in_time

#' The Scan operation returns one or more items and item attributes by
#' accessing every item in a table or a secondary index
#'
#' @description
#' The [`scan`][dynamodb_scan] operation returns one or more items and item
#' attributes by accessing every item in a table or a secondary index. To
#' have DynamoDB return fewer items, you can provide a `FilterExpression`
#' operation.
#' 
#' If the total size of scanned items exceeds the maximum dataset size
#' limit of 1 MB, the scan completes and results are returned to the user.
#' The `LastEvaluatedKey` value is also returned and the requestor can use
#' the `LastEvaluatedKey` to continue the scan in a subsequent operation.
#' Each scan response also includes number of items that were scanned
#' (ScannedCount) as part of the request. If using a `FilterExpression`, a
#' scan result can result in no items meeting the criteria and the `Count`
#' will result in zero. If you did not use a `FilterExpression` in the scan
#' request, then `Count` is the same as `ScannedCount`.
#' 
#' `Count` and `ScannedCount` only return the count of items specific to a
#' single scan request and, unless the table is less than 1MB, do not
#' represent the total number of items in the table.
#' 
#' A single [`scan`][dynamodb_scan] operation first reads up to the maximum
#' number of items set (if using the `Limit` parameter) or a maximum of 1
#' MB of data and then applies any filtering to the results if a
#' `FilterExpression` is provided. If `LastEvaluatedKey` is present in the
#' response, pagination is required to complete the full table scan. For
#' more information, see [Paginating the
#' Results](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.Pagination)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' [`scan`][dynamodb_scan] operations proceed sequentially; however, for
#' faster performance on a large table or secondary index, applications can
#' request a parallel [`scan`][dynamodb_scan] operation by providing the
#' `Segment` and `TotalSegments` parameters. For more information, see
#' [Parallel
#' Scan](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.ParallelScan)
#' in the *Amazon DynamoDB Developer Guide*.
#' 
#' By default, a [`scan`][dynamodb_scan] uses eventually consistent reads
#' when accessing the items in a table. Therefore, the results from an
#' eventually consistent [`scan`][dynamodb_scan] may not include the latest
#' item changes at the time the scan iterates through each item in the
#' table. If you require a strongly consistent read of each item as the
#' scan iterates through the items in the table, you can set the
#' `ConsistentRead` parameter to true. Strong consistency only relates to
#' the consistency of the read at the item level.
#' 
#' DynamoDB does not provide snapshot isolation for a scan operation when
#' the `ConsistentRead` parameter is set to true. Thus, a DynamoDB scan
#' operation does not guarantee that all reads in a scan see a consistent
#' snapshot of the table when the scan operation was requested.
#'
#' @usage
#' dynamodb_scan(TableName, IndexName, AttributesToGet, Limit, Select,
#'   ScanFilter, ConditionalOperator, ExclusiveStartKey,
#'   ReturnConsumedCapacity, TotalSegments, Segment, ProjectionExpression,
#'   FilterExpression, ExpressionAttributeNames, ExpressionAttributeValues,
#'   ConsistentRead)
#'
#' @param TableName &#91;required&#93; The name of the table containing the requested items or if you provide
#' `IndexName`, the name of the table to which that index belongs.
#' 
#' You can also provide the Amazon Resource Name (ARN) of the table in this
#' parameter.
#' @param IndexName The name of a secondary index to scan. This index can be any local
#' secondary index or global secondary index. Note that if you use the
#' `IndexName` parameter, you must also provide `TableName`.
#' @param AttributesToGet This is a legacy parameter. Use `ProjectionExpression` instead. For more
#' information, see
#' [AttributesToGet](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributesToGet.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param Limit The maximum number of items to evaluate (not necessarily the number of
#' matching items). If DynamoDB processes the number of items up to the
#' limit while processing the results, it stops the operation and returns
#' the matching values up to that point, and a key in `LastEvaluatedKey` to
#' apply in a subsequent operation, so that you can pick up where you left
#' off. Also, if the processed dataset size exceeds 1 MB before DynamoDB
#' reaches this limit, it stops the operation and returns the matching
#' values up to the limit, and a key in `LastEvaluatedKey` to apply in a
#' subsequent operation to continue the operation. For more information,
#' see [Working with
#' Queries](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param Select The attributes to be returned in the result. You can retrieve all item
#' attributes, specific item attributes, the count of matching items, or in
#' the case of an index, some or all of the attributes projected into the
#' index.
#' 
#' -   `ALL_ATTRIBUTES` - Returns all of the item attributes from the
#'     specified table or index. If you query a local secondary index, then
#'     for each matching item in the index, DynamoDB fetches the entire
#'     item from the parent table. If the index is configured to project
#'     all item attributes, then all of the data can be obtained from the
#'     local secondary index, and no fetching is required.
#' 
#' -   `ALL_PROJECTED_ATTRIBUTES` - Allowed only when querying an index.
#'     Retrieves all attributes that have been projected into the index. If
#'     the index is configured to project all attributes, this return value
#'     is equivalent to specifying `ALL_ATTRIBUTES`.
#' 
#' -   `COUNT` - Returns the number of matching items, rather than the
#'     matching items themselves. Note that this uses the same quantity of
#'     read capacity units as getting the items, and is subject to the same
#'     item size calculations.
#' 
#' -   `SPECIFIC_ATTRIBUTES` - Returns only the attributes listed in
#'     `ProjectionExpression`. This return value is equivalent to
#'     specifying `ProjectionExpression` without specifying any value for
#'     `Select`.
#' 
#'     If you query or scan a local secondary index and request only
#'     attributes that are projected into that index, the operation reads
#'     only the index and not the table. If any of the requested attributes
#'     are not projected into the local secondary index, DynamoDB fetches
#'     each of these attributes from the parent table. This extra fetching
#'     incurs additional throughput cost and latency.
#' 
#'     If you query or scan a global secondary index, you can only request
#'     attributes that are projected into the index. Global secondary index
#'     queries cannot fetch attributes from the parent table.
#' 
#' If neither `Select` nor `ProjectionExpression` are specified, DynamoDB
#' defaults to `ALL_ATTRIBUTES` when accessing a table, and
#' `ALL_PROJECTED_ATTRIBUTES` when accessing an index. You cannot use both
#' `Select` and `ProjectionExpression` together in a single request, unless
#' the value for `Select` is `SPECIFIC_ATTRIBUTES`. (This usage is
#' equivalent to specifying `ProjectionExpression` without any value for
#' `Select`.)
#' 
#' If you use the `ProjectionExpression` parameter, then the value for
#' `Select` can only be `SPECIFIC_ATTRIBUTES`. Any other value for `Select`
#' will return an error.
#' @param ScanFilter This is a legacy parameter. Use `FilterExpression` instead. For more
#' information, see
#' [ScanFilter](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ScanFilter.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionalOperator This is a legacy parameter. Use `FilterExpression` instead. For more
#' information, see
#' [ConditionalOperator](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExclusiveStartKey The primary key of the first item that this operation will evaluate. Use
#' the value that was returned for `LastEvaluatedKey` in the previous
#' operation.
#' 
#' The data type for `ExclusiveStartKey` must be String, Number or Binary.
#' No set data types are allowed.
#' 
#' In a parallel scan, a [`scan`][dynamodb_scan] request that includes
#' `ExclusiveStartKey` must specify the same segment whose previous
#' [`scan`][dynamodb_scan] returned the corresponding value of
#' `LastEvaluatedKey`.
#' @param ReturnConsumedCapacity 
#' @param TotalSegments For a parallel [`scan`][dynamodb_scan] request, `TotalSegments`
#' represents the total number of segments into which the
#' [`scan`][dynamodb_scan] operation will be divided. The value of
#' `TotalSegments` corresponds to the number of application workers that
#' will perform the parallel scan. For example, if you want to use four
#' application threads to scan a table or an index, specify a
#' `TotalSegments` value of 4.
#' 
#' The value for `TotalSegments` must be greater than or equal to 1, and
#' less than or equal to 1000000. If you specify a `TotalSegments` value of
#' 1, the [`scan`][dynamodb_scan] operation will be sequential rather than
#' parallel.
#' 
#' If you specify `TotalSegments`, you must also specify `Segment`.
#' @param Segment For a parallel [`scan`][dynamodb_scan] request, `Segment` identifies an
#' individual segment to be scanned by an application worker.
#' 
#' Segment IDs are zero-based, so the first segment is always 0. For
#' example, if you want to use four application threads to scan a table or
#' an index, then the first thread specifies a `Segment` value of 0, the
#' second thread specifies 1, and so on.
#' 
#' The value of `LastEvaluatedKey` returned from a parallel
#' [`scan`][dynamodb_scan] request must be used as `ExclusiveStartKey` with
#' the same segment ID in a subsequent [`scan`][dynamodb_scan] operation.
#' 
#' The value for `Segment` must be greater than or equal to 0, and less
#' than the value provided for `TotalSegments`.
#' 
#' If you provide `Segment`, you must also provide `TotalSegments`.
#' @param ProjectionExpression A string that identifies one or more attributes to retrieve from the
#' specified table or index. These attributes can include scalars, sets, or
#' elements of a JSON document. The attributes in the expression must be
#' separated by commas.
#' 
#' If no attribute names are specified, then all attributes will be
#' returned. If any of the requested attributes are not found, they will
#' not appear in the result.
#' 
#' For more information, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param FilterExpression A string that contains conditions that DynamoDB applies after the
#' [`scan`][dynamodb_scan] operation, but before the data is returned to
#' you. Items that do not satisfy the `FilterExpression` criteria are not
#' returned.
#' 
#' A `FilterExpression` is applied after the items have already been read;
#' the process of filtering does not consume any additional read capacity
#' units.
#' 
#' For more information, see [Filter
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Scan.html#Scan.FilterExpression)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*). To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information on expression attribute names, see [Specifying Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeValues One or more values that can be substituted in an expression.
#' 
#' Use the **:** (colon) character in an expression to dereference an
#' attribute value. For example, suppose that you wanted to check whether
#' the value of the `ProductStatus` attribute was one of the following:
#' 
#' `Available | Backordered | Discontinued`
#' 
#' You would first need to specify `ExpressionAttributeValues` as follows:
#' 
#' `{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }`
#' 
#' You could then use these values in an expression, such as this:
#' 
#' `ProductStatus IN (:avail, :back, :disc)`
#' 
#' For more information on expression attribute values, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConsistentRead A Boolean value that determines the read consistency model during the
#' scan:
#' 
#' -   If `ConsistentRead` is `false`, then the data returned from
#'     [`scan`][dynamodb_scan] might not contain the results from other
#'     recently completed write operations
#'     ([`put_item`][dynamodb_put_item],
#'     [`update_item`][dynamodb_update_item], or
#'     [`delete_item`][dynamodb_delete_item]).
#' 
#' -   If `ConsistentRead` is `true`, then all of the write operations that
#'     completed before the [`scan`][dynamodb_scan] began are guaranteed to
#'     be contained in the [`scan`][dynamodb_scan] response.
#' 
#' The default setting for `ConsistentRead` is `false`.
#' 
#' The `ConsistentRead` parameter is not supported on global secondary
#' indexes. If you scan a global secondary index with `ConsistentRead` set
#' to true, you will receive a `ValidationException`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Items = list(
#'     list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   Count = 123,
#'   ScannedCount = 123,
#'   LastEvaluatedKey = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$scan(
#'   TableName = "string",
#'   IndexName = "string",
#'   AttributesToGet = list(
#'     "string"
#'   ),
#'   Limit = 123,
#'   Select = "ALL_ATTRIBUTES"|"ALL_PROJECTED_ATTRIBUTES"|"SPECIFIC_ATTRIBUTES"|"COUNT",
#'   ScanFilter = list(
#'     list(
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       ),
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH"
#'     )
#'   ),
#'   ConditionalOperator = "AND"|"OR",
#'   ExclusiveStartKey = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   TotalSegments = 123,
#'   Segment = 123,
#'   ProjectionExpression = "string",
#'   FilterExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   ),
#'   ExpressionAttributeValues = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsistentRead = TRUE|FALSE
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example scans the entire Music table, and then narrows the results
#' # to songs by the artist "No One You Know". For each item, only the album
#' # title and song title are returned.
#' svc$scan(
#'   ExpressionAttributeNames = list(
#'     `#AT` = "AlbumTitle",
#'     `#ST` = "SongTitle"
#'   ),
#'   ExpressionAttributeValues = list(
#'     `:a` = list(
#'       S = "No One You Know"
#'     )
#'   ),
#'   FilterExpression = "Artist = :a",
#'   ProjectionExpression = "#ST, #AT",
#'   TableName = "Music"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_scan
#'
#' @aliases dynamodb_scan
dynamodb_scan <- function(TableName, IndexName = NULL, AttributesToGet = NULL, Limit = NULL, Select = NULL, ScanFilter = NULL, ConditionalOperator = NULL, ExclusiveStartKey = NULL, ReturnConsumedCapacity = NULL, TotalSegments = NULL, Segment = NULL, ProjectionExpression = NULL, FilterExpression = NULL, ExpressionAttributeNames = NULL, ExpressionAttributeValues = NULL, ConsistentRead = NULL) {
  op <- new_operation(
    name = "Scan",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "ExclusiveStartKey", output_token = "LastEvaluatedKey", limit_key = "Limit", result_key = list("Items", "Count", "ScannedCount"), non_aggregate_keys = list("ConsumedCapacity")),
    stream_api = FALSE
  )
  input <- .dynamodb$scan_input(TableName = TableName, IndexName = IndexName, AttributesToGet = AttributesToGet, Limit = Limit, Select = Select, ScanFilter = ScanFilter, ConditionalOperator = ConditionalOperator, ExclusiveStartKey = ExclusiveStartKey, ReturnConsumedCapacity = ReturnConsumedCapacity, TotalSegments = TotalSegments, Segment = Segment, ProjectionExpression = ProjectionExpression, FilterExpression = FilterExpression, ExpressionAttributeNames = ExpressionAttributeNames, ExpressionAttributeValues = ExpressionAttributeValues, ConsistentRead = ConsistentRead)
  output <- .dynamodb$scan_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$scan <- dynamodb_scan

#' Associate a set of tags with an Amazon DynamoDB resource
#'
#' @description
#' Associate a set of tags with an Amazon DynamoDB resource. You can then
#' activate these user-defined tags so that they appear on the Billing and
#' Cost Management console for cost allocation tracking. You can call
#' TagResource up to five times per second, per account.
#' 
#' -   [`tag_resource`][dynamodb_tag_resource] is an asynchronous
#'     operation. If you issue a
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] request
#'     immediately after a [`tag_resource`][dynamodb_tag_resource] request,
#'     DynamoDB might return your previous tag set, if there was one, or an
#'     empty tag set. This is because
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] uses an
#'     eventually consistent query, and the metadata for your tags or table
#'     might not be available at that moment. Wait for a few seconds, and
#'     then try the
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] request
#'     again.
#' 
#' -   The application or removal of tags using
#'     [`tag_resource`][dynamodb_tag_resource] and
#'     [`untag_resource`][dynamodb_untag_resource] APIs is eventually
#'     consistent.
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] API will
#'     only reflect the changes after a few seconds.
#' 
#' For an overview on tagging DynamoDB resources, see [Tagging for
#' DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @usage
#' dynamodb_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; Identifies the Amazon DynamoDB resource to which tags should be added.
#' This value is an Amazon Resource Name (ARN).
#' @param Tags &#91;required&#93; The tags to be assigned to the Amazon DynamoDB resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_tag_resource
#'
#' @aliases dynamodb_tag_resource
dynamodb_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .dynamodb$tag_resource_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$tag_resource <- dynamodb_tag_resource

#' TransactGetItems is a synchronous operation that atomically retrieves
#' multiple items from one or more tables (but not from indexes) in a
#' single account and Region
#'
#' @description
#' [`transact_get_items`][dynamodb_transact_get_items] is a synchronous
#' operation that atomically retrieves multiple items from one or more
#' tables (but not from indexes) in a single account and Region. A
#' [`transact_get_items`][dynamodb_transact_get_items] call can contain up
#' to 100 `TransactGetItem` objects, each of which contains a `Get`
#' structure that specifies an item to retrieve from a table in the account
#' and Region. A call to
#' [`transact_get_items`][dynamodb_transact_get_items] cannot retrieve
#' items from tables in more than one Amazon Web Services account or
#' Region. The aggregate size of the items in the transaction cannot exceed
#' 4 MB.
#' 
#' DynamoDB rejects the entire
#' [`transact_get_items`][dynamodb_transact_get_items] request if any of
#' the following is true:
#' 
#' -   A conflicting operation is in the process of updating an item to be
#'     read.
#' 
#' -   There is insufficient provisioned capacity for the transaction to be
#'     completed.
#' 
#' -   There is a user error, such as an invalid data format.
#' 
#' -   The aggregate size of the items in the transaction exceeded 4 MB.
#'
#' @usage
#' dynamodb_transact_get_items(TransactItems, ReturnConsumedCapacity)
#'
#' @param TransactItems &#91;required&#93; An ordered array of up to 100 `TransactGetItem` objects, each of which
#' contains a `Get` structure.
#' @param ReturnConsumedCapacity A value of `TOTAL` causes consumed capacity information to be returned,
#' and a value of `NONE` prevents that information from being returned. No
#' other value is valid.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   ),
#'   Responses = list(
#'     list(
#'       Item = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$transact_get_items(
#'   TransactItems = list(
#'     list(
#'       Get = list(
#'         Key = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         TableName = "string",
#'         ProjectionExpression = "string",
#'         ExpressionAttributeNames = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_transact_get_items
#'
#' @aliases dynamodb_transact_get_items
dynamodb_transact_get_items <- function(TransactItems, ReturnConsumedCapacity = NULL) {
  op <- new_operation(
    name = "TransactGetItems",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$transact_get_items_input(TransactItems = TransactItems, ReturnConsumedCapacity = ReturnConsumedCapacity)
  output <- .dynamodb$transact_get_items_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$transact_get_items <- dynamodb_transact_get_items

#' TransactWriteItems is a synchronous write operation that groups up to
#' 100 action requests
#'
#' @description
#' [`transact_write_items`][dynamodb_transact_write_items] is a synchronous
#' write operation that groups up to 100 action requests. These actions can
#' target items in different tables, but not in different Amazon Web
#' Services accounts or Regions, and no two actions can target the same
#' item. For example, you cannot both `ConditionCheck` and `Update` the
#' same item. The aggregate size of the items in the transaction cannot
#' exceed 4 MB.
#' 
#' The actions are completed atomically so that either all of them succeed,
#' or all of them fail. They are defined by the following objects:
#' 
#' -   `Put`   Initiates a [`put_item`][dynamodb_put_item] operation to
#'     write a new item. This structure specifies the primary key of the
#'     item to be written, the name of the table to write it in, an
#'     optional condition expression that must be satisfied for the write
#'     to succeed, a list of the item's attributes, and a field indicating
#'     whether to retrieve the item's attributes if the condition is not
#'     met.
#' 
#' -   `Update`   Initiates an [`update_item`][dynamodb_update_item]
#'     operation to update an existing item. This structure specifies the
#'     primary key of the item to be updated, the name of the table where
#'     it resides, an optional condition expression that must be satisfied
#'     for the update to succeed, an expression that defines one or more
#'     attributes to be updated, and a field indicating whether to retrieve
#'     the item's attributes if the condition is not met.
#' 
#' -   `Delete`   Initiates a [`delete_item`][dynamodb_delete_item]
#'     operation to delete an existing item. This structure specifies the
#'     primary key of the item to be deleted, the name of the table where
#'     it resides, an optional condition expression that must be satisfied
#'     for the deletion to succeed, and a field indicating whether to
#'     retrieve the item's attributes if the condition is not met.
#' 
#' -   `ConditionCheck`   Applies a condition to an item that is not
#'     being modified by the transaction. This structure specifies the
#'     primary key of the item to be checked, the name of the table where
#'     it resides, a condition expression that must be satisfied for the
#'     transaction to succeed, and a field indicating whether to retrieve
#'     the item's attributes if the condition is not met.
#' 
#' DynamoDB rejects the entire
#' [`transact_write_items`][dynamodb_transact_write_items] request if any
#' of the following is true:
#' 
#' -   A condition in one of the condition expressions is not met.
#' 
#' -   An ongoing operation is in the process of updating the same item.
#' 
#' -   There is insufficient provisioned capacity for the transaction to be
#'     completed.
#' 
#' -   An item size becomes too large (bigger than 400 KB), a local
#'     secondary index (LSI) becomes too large, or a similar validation
#'     error occurs because of changes made by the transaction.
#' 
#' -   The aggregate size of the items in the transaction exceeds 4 MB.
#' 
#' -   There is a user error, such as an invalid data format.
#'
#' @usage
#' dynamodb_transact_write_items(TransactItems, ReturnConsumedCapacity,
#'   ReturnItemCollectionMetrics, ClientRequestToken)
#'
#' @param TransactItems &#91;required&#93; An ordered array of up to 100 `TransactWriteItem` objects, each of which
#' contains a `ConditionCheck`, `Put`, `Update`, or `Delete` object. These
#' can operate on items in different tables, but the tables must reside in
#' the same Amazon Web Services account and Region, and no two of them can
#' operate on the same item.
#' @param ReturnConsumedCapacity 
#' @param ReturnItemCollectionMetrics Determines whether item collection metrics are returned. If set to
#' `SIZE`, the response includes statistics about item collections (if
#' any), that were modified during the operation and are returned in the
#' response. If set to `NONE` (the default), no statistics are returned.
#' @param ClientRequestToken Providing a `ClientRequestToken` makes the call to
#' [`transact_write_items`][dynamodb_transact_write_items] idempotent,
#' meaning that multiple identical calls have the same effect as one single
#' call.
#' 
#' Although multiple identical calls using the same client request token
#' produce the same result on the server (no side effects), the responses
#' to the calls might not be the same. If the `ReturnConsumedCapacity`
#' parameter is set, then the initial
#' [`transact_write_items`][dynamodb_transact_write_items] call returns the
#' amount of write capacity units consumed in making the changes.
#' Subsequent [`transact_write_items`][dynamodb_transact_write_items] calls
#' with the same client token return the number of read capacity units
#' consumed in reading the item.
#' 
#' A client request token is valid for 10 minutes after the first request
#' that uses it is completed. After 10 minutes, any request with the same
#' client token is treated as a new request. Do not resubmit the same
#' request with the same client token for more than 10 minutes, or the
#' result might not be idempotent.
#' 
#' If you submit a request with the same client token but a change in other
#' parameters within the 10-minute idempotency window, DynamoDB returns an
#' `IdempotentParameterMismatch` exception.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ConsumedCapacity = list(
#'     list(
#'       TableName = "string",
#'       CapacityUnits = 123.0,
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       Table = list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       ),
#'       LocalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       ),
#'       GlobalSecondaryIndexes = list(
#'         list(
#'           ReadCapacityUnits = 123.0,
#'           WriteCapacityUnits = 123.0,
#'           CapacityUnits = 123.0
#'         )
#'       )
#'     )
#'   ),
#'   ItemCollectionMetrics = list(
#'     list(
#'       list(
#'         ItemCollectionKey = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         SizeEstimateRangeGB = list(
#'           123.0
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$transact_write_items(
#'   TransactItems = list(
#'     list(
#'       ConditionCheck = list(
#'         Key = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         TableName = "string",
#'         ConditionExpression = "string",
#'         ExpressionAttributeNames = list(
#'           "string"
#'         ),
#'         ExpressionAttributeValues = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'       ),
#'       Put = list(
#'         Item = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         TableName = "string",
#'         ConditionExpression = "string",
#'         ExpressionAttributeNames = list(
#'           "string"
#'         ),
#'         ExpressionAttributeValues = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'       ),
#'       Delete = list(
#'         Key = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         TableName = "string",
#'         ConditionExpression = "string",
#'         ExpressionAttributeNames = list(
#'           "string"
#'         ),
#'         ExpressionAttributeValues = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'       ),
#'       Update = list(
#'         Key = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         UpdateExpression = "string",
#'         TableName = "string",
#'         ConditionExpression = "string",
#'         ExpressionAttributeNames = list(
#'           "string"
#'         ),
#'         ExpressionAttributeValues = list(
#'           list(
#'             S = "string",
#'             N = "string",
#'             B = raw,
#'             SS = list(
#'               "string"
#'             ),
#'             NS = list(
#'               "string"
#'             ),
#'             BS = list(
#'               raw
#'             ),
#'             M = list(
#'               list()
#'             ),
#'             L = list(
#'               list()
#'             ),
#'             NULL = TRUE|FALSE,
#'             BOOL = TRUE|FALSE
#'           )
#'         ),
#'         ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#'       )
#'     )
#'   ),
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ReturnItemCollectionMetrics = "SIZE"|"NONE",
#'   ClientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_transact_write_items
#'
#' @aliases dynamodb_transact_write_items
dynamodb_transact_write_items <- function(TransactItems, ReturnConsumedCapacity = NULL, ReturnItemCollectionMetrics = NULL, ClientRequestToken = NULL) {
  op <- new_operation(
    name = "TransactWriteItems",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$transact_write_items_input(TransactItems = TransactItems, ReturnConsumedCapacity = ReturnConsumedCapacity, ReturnItemCollectionMetrics = ReturnItemCollectionMetrics, ClientRequestToken = ClientRequestToken)
  output <- .dynamodb$transact_write_items_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$transact_write_items <- dynamodb_transact_write_items

#' Removes the association of tags from an Amazon DynamoDB resource
#'
#' @description
#' Removes the association of tags from an Amazon DynamoDB resource. You
#' can call [`untag_resource`][dynamodb_untag_resource] up to five times
#' per second, per account.
#' 
#' -   [`untag_resource`][dynamodb_untag_resource] is an asynchronous
#'     operation. If you issue a
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] request
#'     immediately after an [`untag_resource`][dynamodb_untag_resource]
#'     request, DynamoDB might return your previous tag set, if there was
#'     one, or an empty tag set. This is because
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] uses an
#'     eventually consistent query, and the metadata for your tags or table
#'     might not be available at that moment. Wait for a few seconds, and
#'     then try the
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] request
#'     again.
#' 
#' -   The application or removal of tags using
#'     [`tag_resource`][dynamodb_tag_resource] and
#'     [`untag_resource`][dynamodb_untag_resource] APIs is eventually
#'     consistent.
#'     [`list_tags_of_resource`][dynamodb_list_tags_of_resource] API will
#'     only reflect the changes after a few seconds.
#' 
#' For an overview on tagging DynamoDB resources, see [Tagging for
#' DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tagging.html)
#' in the *Amazon DynamoDB Developer Guide*.
#'
#' @usage
#' dynamodb_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; The DynamoDB resource that the tags will be removed from. This value is
#' an Amazon Resource Name (ARN).
#' @param TagKeys &#91;required&#93; A list of tag keys. Existing tags of the resource whose keys are members
#' of this list will be removed from the DynamoDB resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_untag_resource
#'
#' @aliases dynamodb_untag_resource
dynamodb_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .dynamodb$untag_resource_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$untag_resource <- dynamodb_untag_resource

#' UpdateContinuousBackups enables or disables point in time recovery for
#' the specified table
#'
#' @description
#' [`update_continuous_backups`][dynamodb_update_continuous_backups]
#' enables or disables point in time recovery for the specified table. A
#' successful
#' [`update_continuous_backups`][dynamodb_update_continuous_backups] call
#' returns the current `ContinuousBackupsDescription`. Continuous backups
#' are `ENABLED` on all tables at table creation. If point in time recovery
#' is enabled, `PointInTimeRecoveryStatus` will be set to ENABLED.
#' 
#' Once continuous backups and point in time recovery are enabled, you can
#' restore to any point in time within `EarliestRestorableDateTime` and
#' `LatestRestorableDateTime`.
#' 
#' `LatestRestorableDateTime` is typically 5 minutes before the current
#' time. You can restore your table to any point in time in the last 35
#' days. You can set the `RecoveryPeriodInDays` to any value between 1 and
#' 35 days.
#'
#' @usage
#' dynamodb_update_continuous_backups(TableName,
#'   PointInTimeRecoverySpecification)
#'
#' @param TableName &#91;required&#93; The name of the table. You can also provide the Amazon Resource Name
#' (ARN) of the table in this parameter.
#' @param PointInTimeRecoverySpecification &#91;required&#93; Represents the settings used to enable point in time recovery.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ContinuousBackupsDescription = list(
#'     ContinuousBackupsStatus = "ENABLED"|"DISABLED",
#'     PointInTimeRecoveryDescription = list(
#'       PointInTimeRecoveryStatus = "ENABLED"|"DISABLED",
#'       RecoveryPeriodInDays = 123,
#'       EarliestRestorableDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LatestRestorableDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_continuous_backups(
#'   TableName = "string",
#'   PointInTimeRecoverySpecification = list(
#'     PointInTimeRecoveryEnabled = TRUE|FALSE,
#'     RecoveryPeriodInDays = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_continuous_backups
#'
#' @aliases dynamodb_update_continuous_backups
dynamodb_update_continuous_backups <- function(TableName, PointInTimeRecoverySpecification) {
  op <- new_operation(
    name = "UpdateContinuousBackups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_continuous_backups_input(TableName = TableName, PointInTimeRecoverySpecification = PointInTimeRecoverySpecification)
  output <- .dynamodb$update_continuous_backups_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_continuous_backups <- dynamodb_update_continuous_backups

#' Updates the status for contributor insights for a specific table or
#' index
#'
#' @description
#' Updates the status for contributor insights for a specific table or
#' index. CloudWatch Contributor Insights for DynamoDB graphs display the
#' partition key and (if applicable) sort key of frequently accessed items
#' and frequently throttled items in plaintext. If you require the use of
#' Amazon Web Services Key Management Service (KMS) to encrypt this tables
#' partition key and sort key data with an Amazon Web Services managed key
#' or customer managed key, you should not enable CloudWatch Contributor
#' Insights for DynamoDB for this table.
#'
#' @usage
#' dynamodb_update_contributor_insights(TableName, IndexName,
#'   ContributorInsightsAction, ContributorInsightsMode)
#'
#' @param TableName &#91;required&#93; The name of the table. You can also provide the Amazon Resource Name
#' (ARN) of the table in this parameter.
#' @param IndexName The global secondary index name, if applicable.
#' @param ContributorInsightsAction &#91;required&#93; Represents the contributor insights action.
#' @param ContributorInsightsMode Specifies whether to track all access and throttled events or throttled
#' events only for the DynamoDB table or index.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   IndexName = "string",
#'   ContributorInsightsStatus = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"FAILED",
#'   ContributorInsightsMode = "ACCESSED_AND_THROTTLED_KEYS"|"THROTTLED_KEYS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_contributor_insights(
#'   TableName = "string",
#'   IndexName = "string",
#'   ContributorInsightsAction = "ENABLE"|"DISABLE",
#'   ContributorInsightsMode = "ACCESSED_AND_THROTTLED_KEYS"|"THROTTLED_KEYS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_contributor_insights
#'
#' @aliases dynamodb_update_contributor_insights
dynamodb_update_contributor_insights <- function(TableName, IndexName = NULL, ContributorInsightsAction, ContributorInsightsMode = NULL) {
  op <- new_operation(
    name = "UpdateContributorInsights",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_contributor_insights_input(TableName = TableName, IndexName = IndexName, ContributorInsightsAction = ContributorInsightsAction, ContributorInsightsMode = ContributorInsightsMode)
  output <- .dynamodb$update_contributor_insights_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_contributor_insights <- dynamodb_update_contributor_insights

#' Adds or removes replicas in the specified global table
#'
#' @description
#' Adds or removes replicas in the specified global table. The global table
#' must already exist to be able to use this operation. Any replica to be
#' added must be empty, have the same name as the global table, have the
#' same key schema, have DynamoDB Streams enabled, and have the same
#' provisioned and maximum write capacity units.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#' 
#' If you are using global tables [Version
#' 2019.11.21](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' (Current) you can use [`update_table`][dynamodb_update_table] instead.
#' 
#' Although you can use
#' [`update_global_table`][dynamodb_update_global_table] to add replicas
#' and remove replicas in a single request, for simplicity we recommend
#' that you issue separate requests for adding or removing replicas.
#' 
#' If global secondary indexes are specified, then the following conditions
#' must also be met:
#' 
#' -   The global secondary indexes must have the same name.
#' 
#' -   The global secondary indexes must have the same hash key and sort
#'     key (if present).
#' 
#' -   The global secondary indexes must have the same provisioned and
#'     maximum write capacity units.
#'
#' @usage
#' dynamodb_update_global_table(GlobalTableName, ReplicaUpdates)
#'
#' @param GlobalTableName &#91;required&#93; The global table name.
#' @param ReplicaUpdates &#91;required&#93; A list of Regions that should be added or removed from the global table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTableDescription = list(
#'     ReplicationGroup = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableArn = "string",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     GlobalTableStatus = "CREATING"|"ACTIVE"|"DELETING"|"UPDATING",
#'     GlobalTableName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_global_table(
#'   GlobalTableName = "string",
#'   ReplicaUpdates = list(
#'     list(
#'       Create = list(
#'         RegionName = "string"
#'       ),
#'       Delete = list(
#'         RegionName = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_global_table
#'
#' @aliases dynamodb_update_global_table
dynamodb_update_global_table <- function(GlobalTableName, ReplicaUpdates) {
  op <- new_operation(
    name = "UpdateGlobalTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_global_table_input(GlobalTableName = GlobalTableName, ReplicaUpdates = ReplicaUpdates)
  output <- .dynamodb$update_global_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_global_table <- dynamodb_update_global_table

#' Updates settings for a global table
#'
#' @description
#' Updates settings for a global table.
#' 
#' This documentation is for version 2017.11.29 (Legacy) of global tables,
#' which should be avoided for new global tables. Customers should use
#' [Global Tables version 2019.11.21
#' (Current)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html)
#' when possible, because it provides greater flexibility, higher
#' efficiency, and consumes less write capacity than 2017.11.29 (Legacy).
#' 
#' To determine which version you're using, see [Determining the global
#' table version you are
#' using](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_versions.html).
#' To update existing global tables from version 2017.11.29 (Legacy) to
#' version 2019.11.21 (Current), see [Upgrading global
#' tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/).
#'
#' @usage
#' dynamodb_update_global_table_settings(GlobalTableName,
#'   GlobalTableBillingMode, GlobalTableProvisionedWriteCapacityUnits,
#'   GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate,
#'   GlobalTableGlobalSecondaryIndexSettingsUpdate, ReplicaSettingsUpdate)
#'
#' @param GlobalTableName &#91;required&#93; The name of the global table
#' @param GlobalTableBillingMode The billing mode of the global table. If `GlobalTableBillingMode` is not
#' specified, the global table defaults to `PROVISIONED` capacity billing
#' mode.
#' 
#' -   `PROVISIONED` - We recommend using `PROVISIONED` for predictable
#'     workloads. `PROVISIONED` sets the billing mode to [Provisioned
#'     capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html).
#' 
#' -   `PAY_PER_REQUEST` - We recommend using `PAY_PER_REQUEST` for
#'     unpredictable workloads. `PAY_PER_REQUEST` sets the billing mode to
#'     [On-demand capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html).
#' @param GlobalTableProvisionedWriteCapacityUnits The maximum number of writes consumed per second before DynamoDB returns
#' a `ThrottlingException.`
#' @param GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate Auto scaling settings for managing provisioned write capacity for the
#' global table.
#' @param GlobalTableGlobalSecondaryIndexSettingsUpdate Represents the settings of a global secondary index for a global table
#' that will be modified.
#' @param ReplicaSettingsUpdate Represents the settings for a global table in a Region that will be
#' modified.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   GlobalTableName = "string",
#'   ReplicaSettings = list(
#'     list(
#'       RegionName = "string",
#'       ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'       ReplicaBillingModeSummary = list(
#'         BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'         LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       ),
#'       ReplicaProvisionedReadCapacityUnits = 123,
#'       ReplicaProvisionedReadCapacityAutoScalingSettings = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicies = list(
#'           list(
#'             PolicyName = "string",
#'             TargetTrackingScalingPolicyConfiguration = list(
#'               DisableScaleIn = TRUE|FALSE,
#'               ScaleInCooldown = 123,
#'               ScaleOutCooldown = 123,
#'               TargetValue = 123.0
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaProvisionedWriteCapacityUnits = 123,
#'       ReplicaProvisionedWriteCapacityAutoScalingSettings = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicies = list(
#'           list(
#'             PolicyName = "string",
#'             TargetTrackingScalingPolicyConfiguration = list(
#'               DisableScaleIn = TRUE|FALSE,
#'               ScaleInCooldown = 123,
#'               ScaleOutCooldown = 123,
#'               TargetValue = 123.0
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaGlobalSecondaryIndexSettings = list(
#'         list(
#'           IndexName = "string",
#'           IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'           ProvisionedReadCapacityUnits = 123,
#'           ProvisionedReadCapacityAutoScalingSettings = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicies = list(
#'               list(
#'                 PolicyName = "string",
#'                 TargetTrackingScalingPolicyConfiguration = list(
#'                   DisableScaleIn = TRUE|FALSE,
#'                   ScaleInCooldown = 123,
#'                   ScaleOutCooldown = 123,
#'                   TargetValue = 123.0
#'                 )
#'               )
#'             )
#'           ),
#'           ProvisionedWriteCapacityUnits = 123,
#'           ProvisionedWriteCapacityAutoScalingSettings = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicies = list(
#'               list(
#'                 PolicyName = "string",
#'                 TargetTrackingScalingPolicyConfiguration = list(
#'                   DisableScaleIn = TRUE|FALSE,
#'                   ScaleInCooldown = 123,
#'                   ScaleOutCooldown = 123,
#'                   TargetValue = 123.0
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaTableClassSummary = list(
#'         TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'         LastUpdateDateTime = as.POSIXct(
#'           "2015-01-01"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_global_table_settings(
#'   GlobalTableName = "string",
#'   GlobalTableBillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'   GlobalTableProvisionedWriteCapacityUnits = 123,
#'   GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate = list(
#'     MinimumUnits = 123,
#'     MaximumUnits = 123,
#'     AutoScalingDisabled = TRUE|FALSE,
#'     AutoScalingRoleArn = "string",
#'     ScalingPolicyUpdate = list(
#'       PolicyName = "string",
#'       TargetTrackingScalingPolicyConfiguration = list(
#'         DisableScaleIn = TRUE|FALSE,
#'         ScaleInCooldown = 123,
#'         ScaleOutCooldown = 123,
#'         TargetValue = 123.0
#'       )
#'     )
#'   ),
#'   GlobalTableGlobalSecondaryIndexSettingsUpdate = list(
#'     list(
#'       IndexName = "string",
#'       ProvisionedWriteCapacityUnits = 123,
#'       ProvisionedWriteCapacityAutoScalingSettingsUpdate = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicyUpdate = list(
#'           PolicyName = "string",
#'           TargetTrackingScalingPolicyConfiguration = list(
#'             DisableScaleIn = TRUE|FALSE,
#'             ScaleInCooldown = 123,
#'             ScaleOutCooldown = 123,
#'             TargetValue = 123.0
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   ReplicaSettingsUpdate = list(
#'     list(
#'       RegionName = "string",
#'       ReplicaProvisionedReadCapacityUnits = 123,
#'       ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicyUpdate = list(
#'           PolicyName = "string",
#'           TargetTrackingScalingPolicyConfiguration = list(
#'             DisableScaleIn = TRUE|FALSE,
#'             ScaleInCooldown = 123,
#'             ScaleOutCooldown = 123,
#'             TargetValue = 123.0
#'           )
#'         )
#'       ),
#'       ReplicaGlobalSecondaryIndexSettingsUpdate = list(
#'         list(
#'           IndexName = "string",
#'           ProvisionedReadCapacityUnits = 123,
#'           ProvisionedReadCapacityAutoScalingSettingsUpdate = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicyUpdate = list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaTableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_global_table_settings
#'
#' @aliases dynamodb_update_global_table_settings
dynamodb_update_global_table_settings <- function(GlobalTableName, GlobalTableBillingMode = NULL, GlobalTableProvisionedWriteCapacityUnits = NULL, GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate = NULL, GlobalTableGlobalSecondaryIndexSettingsUpdate = NULL, ReplicaSettingsUpdate = NULL) {
  op <- new_operation(
    name = "UpdateGlobalTableSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_global_table_settings_input(GlobalTableName = GlobalTableName, GlobalTableBillingMode = GlobalTableBillingMode, GlobalTableProvisionedWriteCapacityUnits = GlobalTableProvisionedWriteCapacityUnits, GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate = GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate, GlobalTableGlobalSecondaryIndexSettingsUpdate = GlobalTableGlobalSecondaryIndexSettingsUpdate, ReplicaSettingsUpdate = ReplicaSettingsUpdate)
  output <- .dynamodb$update_global_table_settings_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_global_table_settings <- dynamodb_update_global_table_settings

#' Edits an existing item's attributes, or adds a new item to the table if
#' it does not already exist
#'
#' @description
#' Edits an existing item's attributes, or adds a new item to the table if
#' it does not already exist. You can put, delete, or add attribute values.
#' You can also perform a conditional update on an existing item (insert a
#' new attribute name-value pair if it doesn't exist, or replace an
#' existing name-value pair if it has certain expected attribute values).
#' 
#' You can also return the item's attribute values in the same
#' [`update_item`][dynamodb_update_item] operation using the `ReturnValues`
#' parameter.
#'
#' @usage
#' dynamodb_update_item(TableName, Key, AttributeUpdates, Expected,
#'   ConditionalOperator, ReturnValues, ReturnConsumedCapacity,
#'   ReturnItemCollectionMetrics, UpdateExpression, ConditionExpression,
#'   ExpressionAttributeNames, ExpressionAttributeValues,
#'   ReturnValuesOnConditionCheckFailure)
#'
#' @param TableName &#91;required&#93; The name of the table containing the item to update. You can also
#' provide the Amazon Resource Name (ARN) of the table in this parameter.
#' @param Key &#91;required&#93; The primary key of the item to be updated. Each element consists of an
#' attribute name and a value for that attribute.
#' 
#' For the primary key, you must provide all of the attributes. For
#' example, with a simple primary key, you only need to provide a value for
#' the partition key. For a composite primary key, you must provide values
#' for both the partition key and the sort key.
#' @param AttributeUpdates This is a legacy parameter. Use `UpdateExpression` instead. For more
#' information, see
#' [AttributeUpdates](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.AttributeUpdates.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param Expected This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [Expected](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.Expected.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionalOperator This is a legacy parameter. Use `ConditionExpression` instead. For more
#' information, see
#' [ConditionalOperator](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.ConditionalOperator.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValues Use `ReturnValues` if you want to get the item attributes as they appear
#' before or after they are successfully updated. For
#' [`update_item`][dynamodb_update_item], the valid values are:
#' 
#' -   `NONE` - If `ReturnValues` is not specified, or if its value is
#'     `NONE`, then nothing is returned. (This setting is the default for
#'     `ReturnValues`.)
#' 
#' -   `ALL_OLD` - Returns all of the attributes of the item, as they
#'     appeared before the UpdateItem operation.
#' 
#' -   `UPDATED_OLD` - Returns only the updated attributes, as they
#'     appeared before the UpdateItem operation.
#' 
#' -   `ALL_NEW` - Returns all of the attributes of the item, as they
#'     appear after the UpdateItem operation.
#' 
#' -   `UPDATED_NEW` - Returns only the updated attributes, as they appear
#'     after the UpdateItem operation.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#' 
#' The values returned are strongly consistent.
#' @param ReturnConsumedCapacity 
#' @param ReturnItemCollectionMetrics Determines whether item collection metrics are returned. If set to
#' `SIZE`, the response includes statistics about item collections, if any,
#' that were modified during the operation are returned in the response. If
#' set to `NONE` (the default), no statistics are returned.
#' @param UpdateExpression An expression that defines one or more attributes to be updated, the
#' action to be performed on them, and new values for them.
#' 
#' The following action values are available for `UpdateExpression`.
#' 
#' -   `SET` - Adds one or more attributes and values to an item. If any of
#'     these attributes already exist, they are replaced by the new values.
#'     You can also use `SET` to add or subtract from an attribute that is
#'     of type Number. For example: `SET myNum = myNum + :val`
#' 
#'     `SET` supports the following functions:
#' 
#'     -   `if_not_exists (path, operand)` - if the item does not contain
#'         an attribute at the specified path, then `if_not_exists`
#'         evaluates to operand; otherwise, it evaluates to path. You can
#'         use this function to avoid overwriting an attribute that may
#'         already be present in the item.
#' 
#'     -   `list_append (operand, operand)` - evaluates to a list with a
#'         new element added to it. You can append the new element to the
#'         start or the end of the list by reversing the order of the
#'         operands.
#' 
#'     These function names are case-sensitive.
#' 
#' -   `REMOVE` - Removes one or more attributes from an item.
#' 
#' -   `ADD` - Adds the specified value to the item, if the attribute does
#'     not already exist. If the attribute does exist, then the behavior of
#'     `ADD` depends on the data type of the attribute:
#' 
#'     -   If the existing attribute is a number, and if `Value` is also a
#'         number, then `Value` is mathematically added to the existing
#'         attribute. If `Value` is a negative number, then it is
#'         subtracted from the existing attribute.
#' 
#'         If you use `ADD` to increment or decrement a number value for an
#'         item that doesn't exist before the update, DynamoDB uses `0` as
#'         the initial value.
#' 
#'         Similarly, if you use `ADD` for an existing item to increment or
#'         decrement an attribute value that doesn't exist before the
#'         update, DynamoDB uses `0` as the initial value. For example,
#'         suppose that the item you want to update doesn't have an
#'         attribute named `itemcount`, but you decide to `ADD` the number
#'         `3` to this attribute anyway. DynamoDB will create the
#'         `itemcount` attribute, set its initial value to `0`, and finally
#'         add `3` to it. The result will be a new `itemcount` attribute in
#'         the item, with a value of `3`.
#' 
#'     -   If the existing data type is a set and if `Value` is also a set,
#'         then `Value` is added to the existing set. For example, if the
#'         attribute value is the set `[1,2]`, and the `ADD` action
#'         specified `[3]`, then the final attribute value is `[1,2,3]`. An
#'         error occurs if an `ADD` action is specified for a set attribute
#'         and the attribute type specified does not match the existing set
#'         type.
#' 
#'         Both sets must have the same primitive data type. For example,
#'         if the existing data type is a set of strings, the `Value` must
#'         also be a set of strings.
#' 
#'     The `ADD` action only supports Number and set data types. In
#'     addition, `ADD` can only be used on top-level attributes, not nested
#'     attributes.
#' 
#' -   `DELETE` - Deletes an element from a set.
#' 
#'     If a set of values is specified, then those values are subtracted
#'     from the old set. For example, if the attribute value was the set
#'     `[a,b,c]` and the `DELETE` action specifies `[a,c]`, then the final
#'     attribute value is `[b]`. Specifying an empty set is an error.
#' 
#'     The `DELETE` action only supports set data types. In addition,
#'     `DELETE` can only be used on top-level attributes, not nested
#'     attributes.
#' 
#' You can have many actions in a single expression, such as the following:
#' `SET a=:value1, b=:value2 DELETE :value3, :value4, :value5`
#' 
#' For more information on update expressions, see [Modifying Items and
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.UpdateExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ConditionExpression A condition that must be satisfied in order for a conditional update to
#' succeed.
#' 
#' An expression can contain any of the following:
#' 
#' -   Functions:
#'     `attribute_exists | attribute_not_exists | attribute_type | contains | begins_with | size`
#' 
#'     These function names are case-sensitive.
#' 
#' -   Comparison operators: `= | <> | < | > | <= | >= | BETWEEN | IN `
#' 
#' -   Logical operators: `AND | OR | NOT`
#' 
#' For more information about condition expressions, see [Specifying
#' Conditions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeNames One or more substitution tokens for attribute names in an expression.
#' The following are some use cases for using `ExpressionAttributeNames`:
#' 
#' -   To access an attribute whose name conflicts with a DynamoDB reserved
#'     word.
#' 
#' -   To create a placeholder for repeating occurrences of an attribute
#'     name in an expression.
#' 
#' -   To prevent special characters in an attribute name from being
#'     misinterpreted in an expression.
#' 
#' Use the **#** character in an expression to dereference an attribute
#' name. For example, consider the following attribute name:
#' 
#' -   `Percentile`
#' 
#' The name of this attribute conflicts with a reserved word, so it cannot
#' be used directly in an expression. (For the complete list of reserved
#' words, see [Reserved
#' Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
#' in the *Amazon DynamoDB Developer Guide*.) To work around this, you
#' could specify the following for `ExpressionAttributeNames`:
#' 
#' -   `{"#P":"Percentile"}`
#' 
#' You could then use this substitution in an expression, as in this
#' example:
#' 
#' -   `#P = :val`
#' 
#' Tokens that begin with the **:** character are *expression attribute
#' values*, which are placeholders for the actual value at runtime.
#' 
#' For more information about expression attribute names, see [Specifying
#' Item
#' Attributes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Attributes.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ExpressionAttributeValues One or more values that can be substituted in an expression.
#' 
#' Use the **:** (colon) character in an expression to dereference an
#' attribute value. For example, suppose that you wanted to check whether
#' the value of the `ProductStatus` attribute was one of the following:
#' 
#' `Available | Backordered | Discontinued`
#' 
#' You would first need to specify `ExpressionAttributeValues` as follows:
#' 
#' `{ ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"} }`
#' 
#' You could then use these values in an expression, such as this:
#' 
#' `ProductStatus IN (:avail, :back, :disc)`
#' 
#' For more information on expression attribute values, see [Condition
#' Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ConditionExpressions.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param ReturnValuesOnConditionCheckFailure An optional parameter that returns the item attributes for an
#' [`update_item`][dynamodb_update_item] operation that failed a condition
#' check.
#' 
#' There is no additional cost associated with requesting a return value
#' aside from the small network and processing overhead of receiving a
#' larger response. No read capacity units are consumed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Attributes = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ConsumedCapacity = list(
#'     TableName = "string",
#'     CapacityUnits = 123.0,
#'     ReadCapacityUnits = 123.0,
#'     WriteCapacityUnits = 123.0,
#'     Table = list(
#'       ReadCapacityUnits = 123.0,
#'       WriteCapacityUnits = 123.0,
#'       CapacityUnits = 123.0
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         ReadCapacityUnits = 123.0,
#'         WriteCapacityUnits = 123.0,
#'         CapacityUnits = 123.0
#'       )
#'     )
#'   ),
#'   ItemCollectionMetrics = list(
#'     ItemCollectionKey = list(
#'       list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       )
#'     ),
#'     SizeEstimateRangeGB = list(
#'       123.0
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_item(
#'   TableName = "string",
#'   Key = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   AttributeUpdates = list(
#'     list(
#'       Value = list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       ),
#'       Action = "ADD"|"PUT"|"DELETE"
#'     )
#'   ),
#'   Expected = list(
#'     list(
#'       Value = list(
#'         S = "string",
#'         N = "string",
#'         B = raw,
#'         SS = list(
#'           "string"
#'         ),
#'         NS = list(
#'           "string"
#'         ),
#'         BS = list(
#'           raw
#'         ),
#'         M = list(
#'           list()
#'         ),
#'         L = list(
#'           list()
#'         ),
#'         NULL = TRUE|FALSE,
#'         BOOL = TRUE|FALSE
#'       ),
#'       Exists = TRUE|FALSE,
#'       ComparisonOperator = "EQ"|"NE"|"IN"|"LE"|"LT"|"GE"|"GT"|"BETWEEN"|"NOT_NULL"|"NULL"|"CONTAINS"|"NOT_CONTAINS"|"BEGINS_WITH",
#'       AttributeValueList = list(
#'         list(
#'           S = "string",
#'           N = "string",
#'           B = raw,
#'           SS = list(
#'             "string"
#'           ),
#'           NS = list(
#'             "string"
#'           ),
#'           BS = list(
#'             raw
#'           ),
#'           M = list(
#'             list()
#'           ),
#'           L = list(
#'             list()
#'           ),
#'           NULL = TRUE|FALSE,
#'           BOOL = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   ConditionalOperator = "AND"|"OR",
#'   ReturnValues = "NONE"|"ALL_OLD"|"UPDATED_OLD"|"ALL_NEW"|"UPDATED_NEW",
#'   ReturnConsumedCapacity = "INDEXES"|"TOTAL"|"NONE",
#'   ReturnItemCollectionMetrics = "SIZE"|"NONE",
#'   UpdateExpression = "string",
#'   ConditionExpression = "string",
#'   ExpressionAttributeNames = list(
#'     "string"
#'   ),
#'   ExpressionAttributeValues = list(
#'     list(
#'       S = "string",
#'       N = "string",
#'       B = raw,
#'       SS = list(
#'         "string"
#'       ),
#'       NS = list(
#'         "string"
#'       ),
#'       BS = list(
#'         raw
#'       ),
#'       M = list(
#'         list()
#'       ),
#'       L = list(
#'         list()
#'       ),
#'       NULL = TRUE|FALSE,
#'       BOOL = TRUE|FALSE
#'     )
#'   ),
#'   ReturnValuesOnConditionCheckFailure = "ALL_OLD"|"NONE"
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example updates an item in the Music table. It adds a new attribute
#' # (Year) and modifies the AlbumTitle attribute.  All of the attributes in
#' # the item, as they appear after the update, are returned in the response.
#' svc$update_item(
#'   ExpressionAttributeNames = list(
#'     `#AT` = "AlbumTitle",
#'     `#Y` = "Year"
#'   ),
#'   ExpressionAttributeValues = list(
#'     `:t` = list(
#'       S = "Louder Than Ever"
#'     ),
#'     `:y` = list(
#'       N = "2015"
#'     )
#'   ),
#'   Key = list(
#'     Artist = list(
#'       S = "Acme Band"
#'     ),
#'     SongTitle = list(
#'       S = "Happy Day"
#'     )
#'   ),
#'   ReturnValues = "ALL_NEW",
#'   TableName = "Music",
#'   UpdateExpression = "SET #Y = :y, #AT = :t"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_item
#'
#' @aliases dynamodb_update_item
dynamodb_update_item <- function(TableName, Key, AttributeUpdates = NULL, Expected = NULL, ConditionalOperator = NULL, ReturnValues = NULL, ReturnConsumedCapacity = NULL, ReturnItemCollectionMetrics = NULL, UpdateExpression = NULL, ConditionExpression = NULL, ExpressionAttributeNames = NULL, ExpressionAttributeValues = NULL, ReturnValuesOnConditionCheckFailure = NULL) {
  op <- new_operation(
    name = "UpdateItem",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_item_input(TableName = TableName, Key = Key, AttributeUpdates = AttributeUpdates, Expected = Expected, ConditionalOperator = ConditionalOperator, ReturnValues = ReturnValues, ReturnConsumedCapacity = ReturnConsumedCapacity, ReturnItemCollectionMetrics = ReturnItemCollectionMetrics, UpdateExpression = UpdateExpression, ConditionExpression = ConditionExpression, ExpressionAttributeNames = ExpressionAttributeNames, ExpressionAttributeValues = ExpressionAttributeValues, ReturnValuesOnConditionCheckFailure = ReturnValuesOnConditionCheckFailure)
  output <- .dynamodb$update_item_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_item <- dynamodb_update_item

#' The command to update the Kinesis stream destination
#'
#' @description
#' The command to update the Kinesis stream destination.
#'
#' @usage
#' dynamodb_update_kinesis_streaming_destination(TableName, StreamArn,
#'   UpdateKinesisStreamingConfiguration)
#'
#' @param TableName &#91;required&#93; The table name for the Kinesis streaming destination input. You can also
#' provide the ARN of the table in this parameter.
#' @param StreamArn &#91;required&#93; The Amazon Resource Name (ARN) for the Kinesis stream input.
#' @param UpdateKinesisStreamingConfiguration The command to update the Kinesis stream configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableName = "string",
#'   StreamArn = "string",
#'   DestinationStatus = "ENABLING"|"ACTIVE"|"DISABLING"|"DISABLED"|"ENABLE_FAILED"|"UPDATING",
#'   UpdateKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_kinesis_streaming_destination(
#'   TableName = "string",
#'   StreamArn = "string",
#'   UpdateKinesisStreamingConfiguration = list(
#'     ApproximateCreationDateTimePrecision = "MILLISECOND"|"MICROSECOND"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_kinesis_streaming_destination
#'
#' @aliases dynamodb_update_kinesis_streaming_destination
dynamodb_update_kinesis_streaming_destination <- function(TableName, StreamArn, UpdateKinesisStreamingConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateKinesisStreamingDestination",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_kinesis_streaming_destination_input(TableName = TableName, StreamArn = StreamArn, UpdateKinesisStreamingConfiguration = UpdateKinesisStreamingConfiguration)
  output <- .dynamodb$update_kinesis_streaming_destination_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_kinesis_streaming_destination <- dynamodb_update_kinesis_streaming_destination

#' Modifies the provisioned throughput settings, global secondary indexes,
#' or DynamoDB Streams settings for a given table
#'
#' @description
#' Modifies the provisioned throughput settings, global secondary indexes,
#' or DynamoDB Streams settings for a given table.
#' 
#' You can only perform one of the following operations at once:
#' 
#' -   Modify the provisioned throughput settings of the table.
#' 
#' -   Remove a global secondary index from the table.
#' 
#' -   Create a new global secondary index on the table. After the index
#'     begins backfilling, you can use
#'     [`update_table`][dynamodb_update_table] to perform other operations.
#' 
#' [`update_table`][dynamodb_update_table] is an asynchronous operation;
#' while it's executing, the table status changes from `ACTIVE` to
#' `UPDATING`. While it's `UPDATING`, you can't issue another
#' [`update_table`][dynamodb_update_table] request. When the table returns
#' to the `ACTIVE` state, the [`update_table`][dynamodb_update_table]
#' operation is complete.
#'
#' @usage
#' dynamodb_update_table(AttributeDefinitions, TableName, BillingMode,
#'   ProvisionedThroughput, GlobalSecondaryIndexUpdates, StreamSpecification,
#'   SSESpecification, ReplicaUpdates, TableClass, DeletionProtectionEnabled,
#'   MultiRegionConsistency, GlobalTableWitnessUpdates, OnDemandThroughput,
#'   WarmThroughput)
#'
#' @param AttributeDefinitions An array of attributes that describe the key schema for the table and
#' indexes. If you are adding a new global secondary index to the table,
#' `AttributeDefinitions` must include the key element(s) of the new index.
#' @param TableName &#91;required&#93; The name of the table to be updated. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#' @param BillingMode Controls how you are charged for read and write throughput and how you
#' manage capacity. When switching from pay-per-request to provisioned
#' capacity, initial provisioned capacity values must be set. The initial
#' provisioned capacity values are estimated based on the consumed read and
#' write capacity of your table and global secondary indexes over the past
#' 30 minutes.
#' 
#' -   `PAY_PER_REQUEST` - We recommend using `PAY_PER_REQUEST` for most
#'     DynamoDB workloads. `PAY_PER_REQUEST` sets the billing mode to
#'     [On-demand capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/on-demand-capacity-mode.html).
#' 
#' -   `PROVISIONED` - We recommend using `PROVISIONED` for steady
#'     workloads with predictable growth where capacity requirements can be
#'     reliably forecasted. `PROVISIONED` sets the billing mode to
#'     [Provisioned capacity
#'     mode](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/provisioned-capacity-mode.html).
#' @param ProvisionedThroughput The new provisioned throughput settings for the specified table or
#' index.
#' @param GlobalSecondaryIndexUpdates An array of one or more global secondary indexes for the table. For each
#' index in the array, you can request one action:
#' 
#' -   `Create` - add a new global secondary index to the table.
#' 
#' -   `Update` - modify the provisioned throughput settings of an existing
#'     global secondary index.
#' 
#' -   `Delete` - remove a global secondary index from the table.
#' 
#' You can create or delete only one global secondary index per
#' [`update_table`][dynamodb_update_table] operation.
#' 
#' For more information, see [Managing Global Secondary
#' Indexes](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html)
#' in the *Amazon DynamoDB Developer Guide*.
#' @param StreamSpecification Represents the DynamoDB Streams configuration for the table.
#' 
#' You receive a `ValidationException` if you try to enable a stream on a
#' table that already has a stream, or if you try to disable a stream on a
#' table that doesn't have a stream.
#' @param SSESpecification The new server-side encryption settings for the specified table.
#' @param ReplicaUpdates A list of replica update actions (create, delete, or update) for the
#' table.
#' @param TableClass The table class of the table to be updated. Valid values are `STANDARD`
#' and `STANDARD_INFREQUENT_ACCESS`.
#' @param DeletionProtectionEnabled Indicates whether deletion protection is to be enabled (true) or
#' disabled (false) on the table.
#' @param MultiRegionConsistency Specifies the consistency mode for a new global table. This parameter is
#' only valid when you create a global table by specifying one or more
#' [Create](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_ReplicationGroupUpdate.html#DDB-Type-ReplicationGroupUpdate-Create)
#' actions in the
#' [ReplicaUpdates](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_UpdateTable.html#DDB-UpdateTable-request-ReplicaUpdates)
#' action list.
#' 
#' You can specify one of the following consistency modes:
#' 
#' -   `EVENTUAL`: Configures a new global table for multi-Region eventual
#'     consistency (MREC). This is the default consistency mode for global
#'     tables.
#' 
#' -   `STRONG`: Configures a new global table for multi-Region strong
#'     consistency (MRSC).
#' 
#' If you don't specify this field, the global table consistency mode
#' defaults to `EVENTUAL`. For more information about global tables
#' consistency modes, see Consistency modes in DynamoDB developer guide.
#' @param GlobalTableWitnessUpdates A list of witness updates for a MRSC global table. A witness provides a
#' cost-effective alternative to a full replica in a MRSC global table by
#' maintaining replicated change data written to global table replicas. You
#' cannot perform read or write operations on a witness. For each witness,
#' you can request one action:
#' 
#' -   `Create` - add a new witness to the global table.
#' 
#' -   `Delete` - remove a witness from the global table.
#' 
#' You can create or delete only one witness per
#' [`update_table`][dynamodb_update_table] operation.
#' 
#' For more information, see [Multi-Region strong consistency
#' (MRSC)](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/V2globaltables_HowItWorks.html#V2globaltables_HowItWorks.consistency-modes)
#' in the Amazon DynamoDB Developer Guide
#' @param OnDemandThroughput Updates the maximum number of read and write units for the specified
#' table in on-demand capacity mode. If you use this parameter, you must
#' specify `MaxReadRequestUnits`, `MaxWriteRequestUnits`, or both.
#' @param WarmThroughput Represents the warm throughput (in read units per second and write units
#' per second) for updating a table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableDescription = list(
#'     AttributeDefinitions = list(
#'       list(
#'         AttributeName = "string",
#'         AttributeType = "S"|"N"|"B"
#'       )
#'     ),
#'     TableName = "string",
#'     KeySchema = list(
#'       list(
#'         AttributeName = "string",
#'         KeyType = "HASH"|"RANGE"
#'       )
#'     ),
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     CreationDateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ProvisionedThroughput = list(
#'       LastIncreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastDecreaseDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       NumberOfDecreasesToday = 123,
#'       ReadCapacityUnits = 123,
#'       WriteCapacityUnits = 123
#'     ),
#'     TableSizeBytes = 123,
#'     ItemCount = 123,
#'     TableArn = "string",
#'     TableId = "string",
#'     BillingModeSummary = list(
#'       BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'       LastUpdateToPayPerRequestDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     LocalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string"
#'       )
#'     ),
#'     GlobalSecondaryIndexes = list(
#'       list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'         Backfilling = TRUE|FALSE,
#'         ProvisionedThroughput = list(
#'           LastIncreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           LastDecreaseDateTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           NumberOfDecreasesToday = 123,
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         IndexSizeBytes = 123,
#'         ItemCount = 123,
#'         IndexArn = "string",
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'         )
#'       )
#'     ),
#'     StreamSpecification = list(
#'       StreamEnabled = TRUE|FALSE,
#'       StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'     ),
#'     LatestStreamLabel = "string",
#'     LatestStreamArn = "string",
#'     GlobalTableVersion = "string",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'         ReplicaStatusDescription = "string",
#'         ReplicaStatusPercentProgress = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123,
#'           Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             ),
#'             WarmThroughput = list(
#'               ReadUnitsPerSecond = 123,
#'               WriteUnitsPerSecond = 123,
#'               Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"
#'             )
#'           )
#'         ),
#'         ReplicaInaccessibleDateTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         ReplicaTableClassSummary = list(
#'           TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'           LastUpdateDateTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     GlobalTableWitnesses = list(
#'       list(
#'         RegionName = "string",
#'         WitnessStatus = "CREATING"|"DELETING"|"ACTIVE"
#'       )
#'     ),
#'     RestoreSummary = list(
#'       SourceBackupArn = "string",
#'       SourceTableArn = "string",
#'       RestoreDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       RestoreInProgress = TRUE|FALSE
#'     ),
#'     SSEDescription = list(
#'       Status = "ENABLING"|"ENABLED"|"DISABLING"|"DISABLED"|"UPDATING",
#'       SSEType = "AES256"|"KMS",
#'       KMSMasterKeyArn = "string",
#'       InaccessibleEncryptionDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     ArchivalSummary = list(
#'       ArchivalDateTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       ArchivalReason = "string",
#'       ArchivalBackupArn = "string"
#'     ),
#'     TableClassSummary = list(
#'       TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'       LastUpdateDateTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     DeletionProtectionEnabled = TRUE|FALSE,
#'     OnDemandThroughput = list(
#'       MaxReadRequestUnits = 123,
#'       MaxWriteRequestUnits = 123
#'     ),
#'     WarmThroughput = list(
#'       ReadUnitsPerSecond = 123,
#'       WriteUnitsPerSecond = 123,
#'       Status = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'     ),
#'     MultiRegionConsistency = "EVENTUAL"|"STRONG"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_table(
#'   AttributeDefinitions = list(
#'     list(
#'       AttributeName = "string",
#'       AttributeType = "S"|"N"|"B"
#'     )
#'   ),
#'   TableName = "string",
#'   BillingMode = "PROVISIONED"|"PAY_PER_REQUEST",
#'   ProvisionedThroughput = list(
#'     ReadCapacityUnits = 123,
#'     WriteCapacityUnits = 123
#'   ),
#'   GlobalSecondaryIndexUpdates = list(
#'     list(
#'       Update = list(
#'         IndexName = "string",
#'         ProvisionedThroughput = list(
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123
#'         )
#'       ),
#'       Create = list(
#'         IndexName = "string",
#'         KeySchema = list(
#'           list(
#'             AttributeName = "string",
#'             KeyType = "HASH"|"RANGE"
#'           )
#'         ),
#'         Projection = list(
#'           ProjectionType = "ALL"|"KEYS_ONLY"|"INCLUDE",
#'           NonKeyAttributes = list(
#'             "string"
#'           )
#'         ),
#'         ProvisionedThroughput = list(
#'           ReadCapacityUnits = 123,
#'           WriteCapacityUnits = 123
#'         ),
#'         OnDemandThroughput = list(
#'           MaxReadRequestUnits = 123,
#'           MaxWriteRequestUnits = 123
#'         ),
#'         WarmThroughput = list(
#'           ReadUnitsPerSecond = 123,
#'           WriteUnitsPerSecond = 123
#'         )
#'       ),
#'       Delete = list(
#'         IndexName = "string"
#'       )
#'     )
#'   ),
#'   StreamSpecification = list(
#'     StreamEnabled = TRUE|FALSE,
#'     StreamViewType = "NEW_IMAGE"|"OLD_IMAGE"|"NEW_AND_OLD_IMAGES"|"KEYS_ONLY"
#'   ),
#'   SSESpecification = list(
#'     Enabled = TRUE|FALSE,
#'     SSEType = "AES256"|"KMS",
#'     KMSMasterKeyId = "string"
#'   ),
#'   ReplicaUpdates = list(
#'     list(
#'       Create = list(
#'         RegionName = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             )
#'           )
#'         ),
#'         TableClassOverride = "STANDARD"|"STANDARD_INFREQUENT_ACCESS"
#'       ),
#'       Update = list(
#'         RegionName = "string",
#'         KMSMasterKeyId = "string",
#'         ProvisionedThroughputOverride = list(
#'           ReadCapacityUnits = 123
#'         ),
#'         OnDemandThroughputOverride = list(
#'           MaxReadRequestUnits = 123
#'         ),
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             ProvisionedThroughputOverride = list(
#'               ReadCapacityUnits = 123
#'             ),
#'             OnDemandThroughputOverride = list(
#'               MaxReadRequestUnits = 123
#'             )
#'           )
#'         ),
#'         TableClassOverride = "STANDARD"|"STANDARD_INFREQUENT_ACCESS"
#'       ),
#'       Delete = list(
#'         RegionName = "string"
#'       )
#'     )
#'   ),
#'   TableClass = "STANDARD"|"STANDARD_INFREQUENT_ACCESS",
#'   DeletionProtectionEnabled = TRUE|FALSE,
#'   MultiRegionConsistency = "EVENTUAL"|"STRONG",
#'   GlobalTableWitnessUpdates = list(
#'     list(
#'       Create = list(
#'         RegionName = "string"
#'       ),
#'       Delete = list(
#'         RegionName = "string"
#'       )
#'     )
#'   ),
#'   OnDemandThroughput = list(
#'     MaxReadRequestUnits = 123,
#'     MaxWriteRequestUnits = 123
#'   ),
#'   WarmThroughput = list(
#'     ReadUnitsPerSecond = 123,
#'     WriteUnitsPerSecond = 123
#'   )
#' )
#' ```
#'
#' @examples
#' \dontrun{
#' # This example increases the provisioned read and write capacity on the
#' # Music table.
#' svc$update_table(
#'   ProvisionedThroughput = list(
#'     ReadCapacityUnits = 10L,
#'     WriteCapacityUnits = 10L
#'   ),
#'   TableName = "MusicCollection"
#' )
#' }
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_table
#'
#' @aliases dynamodb_update_table
dynamodb_update_table <- function(AttributeDefinitions = NULL, TableName, BillingMode = NULL, ProvisionedThroughput = NULL, GlobalSecondaryIndexUpdates = NULL, StreamSpecification = NULL, SSESpecification = NULL, ReplicaUpdates = NULL, TableClass = NULL, DeletionProtectionEnabled = NULL, MultiRegionConsistency = NULL, GlobalTableWitnessUpdates = NULL, OnDemandThroughput = NULL, WarmThroughput = NULL) {
  op <- new_operation(
    name = "UpdateTable",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_table_input(AttributeDefinitions = AttributeDefinitions, TableName = TableName, BillingMode = BillingMode, ProvisionedThroughput = ProvisionedThroughput, GlobalSecondaryIndexUpdates = GlobalSecondaryIndexUpdates, StreamSpecification = StreamSpecification, SSESpecification = SSESpecification, ReplicaUpdates = ReplicaUpdates, TableClass = TableClass, DeletionProtectionEnabled = DeletionProtectionEnabled, MultiRegionConsistency = MultiRegionConsistency, GlobalTableWitnessUpdates = GlobalTableWitnessUpdates, OnDemandThroughput = OnDemandThroughput, WarmThroughput = WarmThroughput)
  output <- .dynamodb$update_table_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_table <- dynamodb_update_table

#' Updates auto scaling settings on your global tables at once
#'
#' @description
#' Updates auto scaling settings on your global tables at once.
#'
#' @usage
#' dynamodb_update_table_replica_auto_scaling(GlobalSecondaryIndexUpdates,
#'   TableName, ProvisionedWriteCapacityAutoScalingUpdate, ReplicaUpdates)
#'
#' @param GlobalSecondaryIndexUpdates Represents the auto scaling settings of the global secondary indexes of
#' the replica to be updated.
#' @param TableName &#91;required&#93; The name of the global table to be updated. You can also provide the
#' Amazon Resource Name (ARN) of the table in this parameter.
#' @param ProvisionedWriteCapacityAutoScalingUpdate 
#' @param ReplicaUpdates Represents the auto scaling settings of replicas of the table that will
#' be modified.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TableAutoScalingDescription = list(
#'     TableName = "string",
#'     TableStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED",
#'     Replicas = list(
#'       list(
#'         RegionName = "string",
#'         GlobalSecondaryIndexes = list(
#'           list(
#'             IndexName = "string",
#'             IndexStatus = "CREATING"|"UPDATING"|"DELETING"|"ACTIVE",
#'             ProvisionedReadCapacityAutoScalingSettings = list(
#'               MinimumUnits = 123,
#'               MaximumUnits = 123,
#'               AutoScalingDisabled = TRUE|FALSE,
#'               AutoScalingRoleArn = "string",
#'               ScalingPolicies = list(
#'                 list(
#'                   PolicyName = "string",
#'                   TargetTrackingScalingPolicyConfiguration = list(
#'                     DisableScaleIn = TRUE|FALSE,
#'                     ScaleInCooldown = 123,
#'                     ScaleOutCooldown = 123,
#'                     TargetValue = 123.0
#'                   )
#'                 )
#'               )
#'             ),
#'             ProvisionedWriteCapacityAutoScalingSettings = list(
#'               MinimumUnits = 123,
#'               MaximumUnits = 123,
#'               AutoScalingDisabled = TRUE|FALSE,
#'               AutoScalingRoleArn = "string",
#'               ScalingPolicies = list(
#'                 list(
#'                   PolicyName = "string",
#'                   TargetTrackingScalingPolicyConfiguration = list(
#'                     DisableScaleIn = TRUE|FALSE,
#'                     ScaleInCooldown = 123,
#'                     ScaleOutCooldown = 123,
#'                     TargetValue = 123.0
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaProvisionedReadCapacityAutoScalingSettings = list(
#'           MinimumUnits = 123,
#'           MaximumUnits = 123,
#'           AutoScalingDisabled = TRUE|FALSE,
#'           AutoScalingRoleArn = "string",
#'           ScalingPolicies = list(
#'             list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaProvisionedWriteCapacityAutoScalingSettings = list(
#'           MinimumUnits = 123,
#'           MaximumUnits = 123,
#'           AutoScalingDisabled = TRUE|FALSE,
#'           AutoScalingRoleArn = "string",
#'           ScalingPolicies = list(
#'             list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         ),
#'         ReplicaStatus = "CREATING"|"CREATION_FAILED"|"UPDATING"|"DELETING"|"ACTIVE"|"REGION_DISABLED"|"INACCESSIBLE_ENCRYPTION_CREDENTIALS"|"ARCHIVING"|"ARCHIVED"|"REPLICATION_NOT_AUTHORIZED"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_table_replica_auto_scaling(
#'   GlobalSecondaryIndexUpdates = list(
#'     list(
#'       IndexName = "string",
#'       ProvisionedWriteCapacityAutoScalingUpdate = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicyUpdate = list(
#'           PolicyName = "string",
#'           TargetTrackingScalingPolicyConfiguration = list(
#'             DisableScaleIn = TRUE|FALSE,
#'             ScaleInCooldown = 123,
#'             ScaleOutCooldown = 123,
#'             TargetValue = 123.0
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   TableName = "string",
#'   ProvisionedWriteCapacityAutoScalingUpdate = list(
#'     MinimumUnits = 123,
#'     MaximumUnits = 123,
#'     AutoScalingDisabled = TRUE|FALSE,
#'     AutoScalingRoleArn = "string",
#'     ScalingPolicyUpdate = list(
#'       PolicyName = "string",
#'       TargetTrackingScalingPolicyConfiguration = list(
#'         DisableScaleIn = TRUE|FALSE,
#'         ScaleInCooldown = 123,
#'         ScaleOutCooldown = 123,
#'         TargetValue = 123.0
#'       )
#'     )
#'   ),
#'   ReplicaUpdates = list(
#'     list(
#'       RegionName = "string",
#'       ReplicaGlobalSecondaryIndexUpdates = list(
#'         list(
#'           IndexName = "string",
#'           ProvisionedReadCapacityAutoScalingUpdate = list(
#'             MinimumUnits = 123,
#'             MaximumUnits = 123,
#'             AutoScalingDisabled = TRUE|FALSE,
#'             AutoScalingRoleArn = "string",
#'             ScalingPolicyUpdate = list(
#'               PolicyName = "string",
#'               TargetTrackingScalingPolicyConfiguration = list(
#'                 DisableScaleIn = TRUE|FALSE,
#'                 ScaleInCooldown = 123,
#'                 ScaleOutCooldown = 123,
#'                 TargetValue = 123.0
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       ReplicaProvisionedReadCapacityAutoScalingUpdate = list(
#'         MinimumUnits = 123,
#'         MaximumUnits = 123,
#'         AutoScalingDisabled = TRUE|FALSE,
#'         AutoScalingRoleArn = "string",
#'         ScalingPolicyUpdate = list(
#'           PolicyName = "string",
#'           TargetTrackingScalingPolicyConfiguration = list(
#'             DisableScaleIn = TRUE|FALSE,
#'             ScaleInCooldown = 123,
#'             ScaleOutCooldown = 123,
#'             TargetValue = 123.0
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_table_replica_auto_scaling
#'
#' @aliases dynamodb_update_table_replica_auto_scaling
dynamodb_update_table_replica_auto_scaling <- function(GlobalSecondaryIndexUpdates = NULL, TableName, ProvisionedWriteCapacityAutoScalingUpdate = NULL, ReplicaUpdates = NULL) {
  op <- new_operation(
    name = "UpdateTableReplicaAutoScaling",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_table_replica_auto_scaling_input(GlobalSecondaryIndexUpdates = GlobalSecondaryIndexUpdates, TableName = TableName, ProvisionedWriteCapacityAutoScalingUpdate = ProvisionedWriteCapacityAutoScalingUpdate, ReplicaUpdates = ReplicaUpdates)
  output <- .dynamodb$update_table_replica_auto_scaling_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_table_replica_auto_scaling <- dynamodb_update_table_replica_auto_scaling

#' The UpdateTimeToLive method enables or disables Time to Live (TTL) for
#' the specified table
#'
#' @description
#' The [`update_time_to_live`][dynamodb_update_time_to_live] method enables
#' or disables Time to Live (TTL) for the specified table. A successful
#' [`update_time_to_live`][dynamodb_update_time_to_live] call returns the
#' current `TimeToLiveSpecification`. It can take up to one hour for the
#' change to fully process. Any additional
#' [`update_time_to_live`][dynamodb_update_time_to_live] calls for the same
#' table during this one hour duration result in a `ValidationException`.
#' 
#' TTL compares the current time in epoch time format to the time stored in
#' the TTL attribute of an item. If the epoch time value stored in the
#' attribute is less than the current time, the item is marked as expired
#' and subsequently deleted.
#' 
#' The epoch time format is the number of seconds elapsed since 12:00:00 AM
#' January 1, 1970 UTC.
#' 
#' DynamoDB deletes expired items on a best-effort basis to ensure
#' availability of throughput for other data operations.
#' 
#' DynamoDB typically deletes expired items within two days of expiration.
#' The exact duration within which an item gets deleted after expiration is
#' specific to the nature of the workload. Items that have expired and not
#' been deleted will still show up in reads, queries, and scans.
#' 
#' As items are deleted, they are removed from any local secondary index
#' and global secondary index immediately in the same eventually consistent
#' way as a standard delete operation.
#' 
#' For more information, see [Time To
#' Live](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html)
#' in the Amazon DynamoDB Developer Guide.
#'
#' @usage
#' dynamodb_update_time_to_live(TableName, TimeToLiveSpecification)
#'
#' @param TableName &#91;required&#93; The name of the table to be configured. You can also provide the Amazon
#' Resource Name (ARN) of the table in this parameter.
#' @param TimeToLiveSpecification &#91;required&#93; Represents the settings used to enable or disable Time to Live for the
#' specified table.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TimeToLiveSpecification = list(
#'     Enabled = TRUE|FALSE,
#'     AttributeName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_time_to_live(
#'   TableName = "string",
#'   TimeToLiveSpecification = list(
#'     Enabled = TRUE|FALSE,
#'     AttributeName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname dynamodb_update_time_to_live
#'
#' @aliases dynamodb_update_time_to_live
dynamodb_update_time_to_live <- function(TableName, TimeToLiveSpecification) {
  op <- new_operation(
    name = "UpdateTimeToLive",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .dynamodb$update_time_to_live_input(TableName = TableName, TimeToLiveSpecification = TimeToLiveSpecification)
  output <- .dynamodb$update_time_to_live_output()
  config <- get_config()
  svc <- .dynamodb$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.dynamodb$operations$update_time_to_live <- dynamodb_update_time_to_live

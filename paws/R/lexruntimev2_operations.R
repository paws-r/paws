# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include lexruntimev2_service.R
NULL

#' Removes session information for a specified bot, alias, and user ID
#'
#' @description
#' Removes session information for a specified bot, alias, and user ID.
#' 
#' You can use this operation to restart a conversation with a bot. When
#' you remove a session, the entire history of the session is removed so
#' that you can start again.
#' 
#' You don't need to delete a session. Sessions have a time limit and will
#' expire. Set the session time limit when you create the bot. The default
#' is 5 minutes, but you can specify anything between 1 minute and 24
#' hours.
#' 
#' If you specify a bot or alias ID that doesn't exist, you receive a
#' `BadRequestException.`
#' 
#' If the locale doesn't exist in the bot, or if the locale hasn't been
#' enables for the alias, you receive a `BadRequestException`.
#'
#' @usage
#' lexruntimev2_delete_session(botId, botAliasId, localeId, sessionId)
#'
#' @param botId &#91;required&#93; The identifier of the bot that contains the session data.
#' @param botAliasId &#91;required&#93; The alias identifier in use for the bot that contains the session data.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the session to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_session(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_delete_session
#'
#' @aliases lexruntimev2_delete_session
lexruntimev2_delete_session <- function(botId, botAliasId, localeId, sessionId) {
  op <- new_operation(
    name = "DeleteSession",
    http_method = "DELETE",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lexruntimev2$delete_session_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId)
  output <- .lexruntimev2$delete_session_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$delete_session <- lexruntimev2_delete_session

#' Returns session information for a specified bot, alias, and user
#'
#' @description
#' Returns session information for a specified bot, alias, and user.
#' 
#' For example, you can use this operation to retrieve session information
#' for a user that has left a long-running session in use.
#' 
#' If the bot, alias, or session identifier doesn't exist, Amazon Lex V2
#' returns a `BadRequestException`. If the locale doesn't exist or is not
#' enabled for the alias, you receive a `BadRequestException`.
#'
#' @usage
#' lexruntimev2_get_session(botId, botAliasId, localeId, sessionId)
#'
#' @param botId &#91;required&#93; The identifier of the bot that contains the session data.
#' @param botAliasId &#91;required&#93; The alias identifier in use for the bot that contains the session data.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the session to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sessionId = "string",
#'   messages = list(
#'     list(
#'       content = "string",
#'       contentType = "CustomPayload"|"ImageResponseCard"|"PlainText"|"SSML",
#'       imageResponseCard = list(
#'         title = "string",
#'         subtitle = "string",
#'         imageUrl = "string",
#'         buttons = list(
#'           list(
#'             text = "string",
#'             value = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   interpretations = list(
#'     list(
#'       nluConfidence = list(
#'         score = 123.0
#'       ),
#'       sentimentResponse = list(
#'         sentiment = "MIXED"|"NEGATIVE"|"NEUTRAL"|"POSITIVE",
#'         sentimentScore = list(
#'           positive = 123.0,
#'           negative = 123.0,
#'           neutral = 123.0,
#'           mixed = 123.0
#'         )
#'       ),
#'       intent = list(
#'         name = "string",
#'         slots = list(
#'           list(
#'             value = list(
#'               originalValue = "string",
#'               interpretedValue = "string",
#'               resolvedValues = list(
#'                 "string"
#'               )
#'             ),
#'             shape = "Scalar"|"List"|"Composite",
#'             values = list(
#'               list()
#'             ),
#'             subSlots = list()
#'           )
#'         ),
#'         state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'         confirmationState = "Confirmed"|"Denied"|"None"
#'       ),
#'       interpretationSource = "Bedrock"|"Lex"
#'     )
#'   ),
#'   sessionState = list(
#'     dialogAction = list(
#'       type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'       slotToElicit = "string",
#'       slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'       subSlotToElicit = list(
#'         name = "string",
#'         subSlotToElicit = list()
#'       )
#'     ),
#'     intent = list(
#'       name = "string",
#'       slots = list(
#'         list(
#'           value = list(
#'             originalValue = "string",
#'             interpretedValue = "string",
#'             resolvedValues = list(
#'               "string"
#'             )
#'           ),
#'           shape = "Scalar"|"List"|"Composite",
#'           values = list(
#'             list()
#'           ),
#'           subSlots = list()
#'         )
#'       ),
#'       state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'       confirmationState = "Confirmed"|"Denied"|"None"
#'     ),
#'     activeContexts = list(
#'       list(
#'         name = "string",
#'         timeToLive = list(
#'           timeToLiveInSeconds = 123,
#'           turnsToLive = 123
#'         ),
#'         contextAttributes = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     ),
#'     originatingRequestId = "string",
#'     runtimeHints = list(
#'       slotHints = list(
#'         list(
#'           list(
#'             runtimeHintValues = list(
#'               list(
#'                 phrase = "string"
#'               )
#'             ),
#'             subSlotHints = list()
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_get_session
#'
#' @aliases lexruntimev2_get_session
lexruntimev2_get_session <- function(botId, botAliasId, localeId, sessionId) {
  op <- new_operation(
    name = "GetSession",
    http_method = "GET",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lexruntimev2$get_session_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId)
  output <- .lexruntimev2$get_session_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$get_session <- lexruntimev2_get_session

#' Creates a new session or modifies an existing session with an Amazon Lex
#' V2 bot
#'
#' @description
#' Creates a new session or modifies an existing session with an Amazon Lex
#' V2 bot. Use this operation to enable your application to set the state
#' of the bot.
#'
#' @usage
#' lexruntimev2_put_session(botId, botAliasId, localeId, sessionId,
#'   messages, sessionState, requestAttributes, responseContentType)
#'
#' @param botId &#91;required&#93; The identifier of the bot that receives the session data.
#' @param botAliasId &#91;required&#93; The alias identifier of the bot that receives the session data.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the session that receives the session data.
#' @param messages A list of messages to send to the user. Messages are sent in the order
#' that they are defined in the list.
#' @param sessionState &#91;required&#93; Sets the state of the session with the user. You can use this to set the
#' current intent, attributes, context, and dialog action. Use the dialog
#' action to determine the next step that Amazon Lex V2 should use in the
#' conversation with the user.
#' @param requestAttributes Request-specific information passed between Amazon Lex V2 and the client
#' application.
#' 
#' The namespace `x-amz-lex:` is reserved for special attributes. Don't
#' create any request attributes with the prefix `x-amz-lex:`.
#' @param responseContentType The message that Amazon Lex V2 returns in the response can be either
#' text or speech depending on the value of this parameter.
#' 
#' -   If the value is `text/plain; charset=utf-8`, Amazon Lex V2 returns
#'     text in the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   contentType = "string",
#'   messages = "string",
#'   sessionState = "string",
#'   requestAttributes = "string",
#'   sessionId = "string",
#'   audioStream = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_session(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string",
#'   messages = list(
#'     list(
#'       content = "string",
#'       contentType = "CustomPayload"|"ImageResponseCard"|"PlainText"|"SSML",
#'       imageResponseCard = list(
#'         title = "string",
#'         subtitle = "string",
#'         imageUrl = "string",
#'         buttons = list(
#'           list(
#'             text = "string",
#'             value = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   sessionState = list(
#'     dialogAction = list(
#'       type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'       slotToElicit = "string",
#'       slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'       subSlotToElicit = list(
#'         name = "string",
#'         subSlotToElicit = list()
#'       )
#'     ),
#'     intent = list(
#'       name = "string",
#'       slots = list(
#'         list(
#'           value = list(
#'             originalValue = "string",
#'             interpretedValue = "string",
#'             resolvedValues = list(
#'               "string"
#'             )
#'           ),
#'           shape = "Scalar"|"List"|"Composite",
#'           values = list(
#'             list()
#'           ),
#'           subSlots = list()
#'         )
#'       ),
#'       state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'       confirmationState = "Confirmed"|"Denied"|"None"
#'     ),
#'     activeContexts = list(
#'       list(
#'         name = "string",
#'         timeToLive = list(
#'           timeToLiveInSeconds = 123,
#'           turnsToLive = 123
#'         ),
#'         contextAttributes = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     ),
#'     originatingRequestId = "string",
#'     runtimeHints = list(
#'       slotHints = list(
#'         list(
#'           list(
#'             runtimeHintValues = list(
#'               list(
#'                 phrase = "string"
#'               )
#'             ),
#'             subSlotHints = list()
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   requestAttributes = list(
#'     "string"
#'   ),
#'   responseContentType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_put_session
#'
#' @aliases lexruntimev2_put_session
lexruntimev2_put_session <- function(botId, botAliasId, localeId, sessionId, messages = NULL, sessionState, requestAttributes = NULL, responseContentType = NULL) {
  op <- new_operation(
    name = "PutSession",
    http_method = "POST",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lexruntimev2$put_session_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId, messages = messages, sessionState = sessionState, requestAttributes = requestAttributes, responseContentType = responseContentType)
  output <- .lexruntimev2$put_session_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$put_session <- lexruntimev2_put_session

#' Sends user input to Amazon Lex V2
#'
#' @description
#' Sends user input to Amazon Lex V2. Client applications use this API to
#' send requests to Amazon Lex V2 at runtime. Amazon Lex V2 then interprets
#' the user input using the machine learning model that it build for the
#' bot.
#' 
#' In response, Amazon Lex V2 returns the next message to convey to the
#' user and an optional response card to display.
#' 
#' If the optional post-fulfillment response is specified, the messages are
#' returned as follows. For more information, see
#' [PostFulfillmentStatusSpecification](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_PostFulfillmentStatusSpecification.html).
#' 
#' -   **Success message** - Returned if the Lambda function completes
#'     successfully and the intent state is fulfilled or ready fulfillment
#'     if the message is present.
#' 
#' -   **Failed message** - The failed message is returned if the Lambda
#'     function throws an exception or if the Lambda function returns a
#'     failed intent state without a message.
#' 
#' -   **Timeout message** - If you don't configure a timeout message and a
#'     timeout, and the Lambda function doesn't return within 30 seconds,
#'     the timeout message is returned. If you configure a timeout, the
#'     timeout message is returned when the period times out.
#' 
#' For more information, see [Completion
#' message](https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html).
#'
#' @usage
#' lexruntimev2_recognize_text(botId, botAliasId, localeId, sessionId,
#'   text, sessionState, requestAttributes)
#'
#' @param botId &#91;required&#93; The identifier of the bot that processes the request.
#' @param botAliasId &#91;required&#93; The alias identifier in use for the bot that processes the request.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the user session that is having the conversation.
#' @param text &#91;required&#93; The text that the user entered. Amazon Lex V2 interprets this text.
#' @param sessionState The current state of the dialog between the user and the bot.
#' @param requestAttributes Request-specific information passed between the client application and
#' Amazon Lex V2
#' 
#' The namespace `x-amz-lex:` is reserved for special attributes. Don't
#' create any request attributes with the prefix `x-amz-lex:`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   messages = list(
#'     list(
#'       content = "string",
#'       contentType = "CustomPayload"|"ImageResponseCard"|"PlainText"|"SSML",
#'       imageResponseCard = list(
#'         title = "string",
#'         subtitle = "string",
#'         imageUrl = "string",
#'         buttons = list(
#'           list(
#'             text = "string",
#'             value = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   sessionState = list(
#'     dialogAction = list(
#'       type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'       slotToElicit = "string",
#'       slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'       subSlotToElicit = list(
#'         name = "string",
#'         subSlotToElicit = list()
#'       )
#'     ),
#'     intent = list(
#'       name = "string",
#'       slots = list(
#'         list(
#'           value = list(
#'             originalValue = "string",
#'             interpretedValue = "string",
#'             resolvedValues = list(
#'               "string"
#'             )
#'           ),
#'           shape = "Scalar"|"List"|"Composite",
#'           values = list(
#'             list()
#'           ),
#'           subSlots = list()
#'         )
#'       ),
#'       state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'       confirmationState = "Confirmed"|"Denied"|"None"
#'     ),
#'     activeContexts = list(
#'       list(
#'         name = "string",
#'         timeToLive = list(
#'           timeToLiveInSeconds = 123,
#'           turnsToLive = 123
#'         ),
#'         contextAttributes = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     ),
#'     originatingRequestId = "string",
#'     runtimeHints = list(
#'       slotHints = list(
#'         list(
#'           list(
#'             runtimeHintValues = list(
#'               list(
#'                 phrase = "string"
#'               )
#'             ),
#'             subSlotHints = list()
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   interpretations = list(
#'     list(
#'       nluConfidence = list(
#'         score = 123.0
#'       ),
#'       sentimentResponse = list(
#'         sentiment = "MIXED"|"NEGATIVE"|"NEUTRAL"|"POSITIVE",
#'         sentimentScore = list(
#'           positive = 123.0,
#'           negative = 123.0,
#'           neutral = 123.0,
#'           mixed = 123.0
#'         )
#'       ),
#'       intent = list(
#'         name = "string",
#'         slots = list(
#'           list(
#'             value = list(
#'               originalValue = "string",
#'               interpretedValue = "string",
#'               resolvedValues = list(
#'                 "string"
#'               )
#'             ),
#'             shape = "Scalar"|"List"|"Composite",
#'             values = list(
#'               list()
#'             ),
#'             subSlots = list()
#'           )
#'         ),
#'         state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'         confirmationState = "Confirmed"|"Denied"|"None"
#'       ),
#'       interpretationSource = "Bedrock"|"Lex"
#'     )
#'   ),
#'   requestAttributes = list(
#'     "string"
#'   ),
#'   sessionId = "string",
#'   recognizedBotMember = list(
#'     botId = "string",
#'     botName = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$recognize_text(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string",
#'   text = "string",
#'   sessionState = list(
#'     dialogAction = list(
#'       type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'       slotToElicit = "string",
#'       slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'       subSlotToElicit = list(
#'         name = "string",
#'         subSlotToElicit = list()
#'       )
#'     ),
#'     intent = list(
#'       name = "string",
#'       slots = list(
#'         list(
#'           value = list(
#'             originalValue = "string",
#'             interpretedValue = "string",
#'             resolvedValues = list(
#'               "string"
#'             )
#'           ),
#'           shape = "Scalar"|"List"|"Composite",
#'           values = list(
#'             list()
#'           ),
#'           subSlots = list()
#'         )
#'       ),
#'       state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'       confirmationState = "Confirmed"|"Denied"|"None"
#'     ),
#'     activeContexts = list(
#'       list(
#'         name = "string",
#'         timeToLive = list(
#'           timeToLiveInSeconds = 123,
#'           turnsToLive = 123
#'         ),
#'         contextAttributes = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     ),
#'     originatingRequestId = "string",
#'     runtimeHints = list(
#'       slotHints = list(
#'         list(
#'           list(
#'             runtimeHintValues = list(
#'               list(
#'                 phrase = "string"
#'               )
#'             ),
#'             subSlotHints = list()
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   requestAttributes = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_recognize_text
#'
#' @aliases lexruntimev2_recognize_text
lexruntimev2_recognize_text <- function(botId, botAliasId, localeId, sessionId, text, sessionState = NULL, requestAttributes = NULL) {
  op <- new_operation(
    name = "RecognizeText",
    http_method = "POST",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/text",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lexruntimev2$recognize_text_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId, text = text, sessionState = sessionState, requestAttributes = requestAttributes)
  output <- .lexruntimev2$recognize_text_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$recognize_text <- lexruntimev2_recognize_text

#' Sends user input to Amazon Lex V2
#'
#' @description
#' Sends user input to Amazon Lex V2. You can send text or speech. Clients
#' use this API to send text and audio requests to Amazon Lex V2 at
#' runtime. Amazon Lex V2 interprets the user input using the machine
#' learning model built for the bot.
#' 
#' The following request fields must be compressed with gzip and then
#' base64 encoded before you send them to Amazon Lex V2.
#' 
#' -   requestAttributes
#' 
#' -   sessionState
#' 
#' The following response fields are compressed using gzip and then base64
#' encoded by Amazon Lex V2. Before you can use these fields, you must
#' decode and decompress them.
#' 
#' -   inputTranscript
#' 
#' -   interpretations
#' 
#' -   messages
#' 
#' -   requestAttributes
#' 
#' -   sessionState
#' 
#' The example contains a Java application that compresses and encodes a
#' Java object to send to Amazon Lex V2, and a second that decodes and
#' decompresses a response from Amazon Lex V2.
#' 
#' If the optional post-fulfillment response is specified, the messages are
#' returned as follows. For more information, see
#' [PostFulfillmentStatusSpecification](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_PostFulfillmentStatusSpecification.html).
#' 
#' -   **Success message** - Returned if the Lambda function completes
#'     successfully and the intent state is fulfilled or ready fulfillment
#'     if the message is present.
#' 
#' -   **Failed message** - The failed message is returned if the Lambda
#'     function throws an exception or if the Lambda function returns a
#'     failed intent state without a message.
#' 
#' -   **Timeout message** - If you don't configure a timeout message and a
#'     timeout, and the Lambda function doesn't return within 30 seconds,
#'     the timeout message is returned. If you configure a timeout, the
#'     timeout message is returned when the period times out.
#' 
#' For more information, see [Completion
#' message](https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html).
#'
#' @usage
#' lexruntimev2_recognize_utterance(botId, botAliasId, localeId, sessionId,
#'   sessionState, requestAttributes, requestContentType,
#'   responseContentType, inputStream)
#'
#' @param botId &#91;required&#93; The identifier of the bot that should receive the request.
#' @param botAliasId &#91;required&#93; The alias identifier in use for the bot that should receive the request.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the session in use.
#' @param sessionState Sets the state of the session with the user. You can use this to set the
#' current intent, attributes, context, and dialog action. Use the dialog
#' action to determine the next step that Amazon Lex V2 should use in the
#' conversation with the user.
#' 
#' The `sessionState` field must be compressed using gzip and then base64
#' encoded before sending to Amazon Lex V2.
#' @param requestAttributes Request-specific information passed between the client application and
#' Amazon Lex V2
#' 
#' The namespace `x-amz-lex:` is reserved for special attributes. Don't
#' create any request attributes for prefix `x-amz-lex:`.
#' 
#' The `requestAttributes` field must be compressed using gzip and then
#' base64 encoded before sending to Amazon Lex V2.
#' @param requestContentType &#91;required&#93; Indicates the format for audio input or that the content is text. The
#' header must start with one of the following prefixes:
#' 
#' -   PCM format, audio data must be in little-endian byte order.
#' 
#'     -   audio/l16; rate=16000; channels=1
#' 
#'     -   audio/x-l16; sample-rate=16000; channel-count=1
#' 
#'     -   audio/lpcm; sample-rate=8000; sample-size-bits=16;
#'         channel-count=1; is-big-endian=false
#' 
#' -   Opus format
#' 
#'     -   audio/x-cbr-opus-with-preamble;preamble-size=0;bit-rate=256000;frame-size-milliseconds=4
#' 
#' -   Text format
#' 
#'     -   text/plain; charset=utf-8
#' @param responseContentType The message that Amazon Lex V2 returns in the response can be either
#' text or speech based on the `responseContentType` value.
#' 
#' -   If the value is `text/plain;charset=utf-8`, Amazon Lex V2 returns
#'     text in the response.
#' 
#' -   If the value begins with `audio/`, Amazon Lex V2 returns speech in
#'     the response. Amazon Lex V2 uses Amazon Polly to generate the speech
#'     using the configuration that you specified in the
#'     `responseContentType` parameter. For example, if you specify
#'     `audio/mpeg` as the value, Amazon Lex V2 returns speech in the MPEG
#'     format.
#' 
#' -   If the value is `audio/pcm`, the speech returned is `audio/pcm` at
#'     16 KHz in 16-bit, little-endian format.
#' 
#' -   The following are the accepted values:
#' 
#'     -   audio/mpeg
#' 
#'     -   audio/ogg
#' 
#'     -   audio/pcm (16 KHz)
#' 
#'     -   audio/* (defaults to mpeg)
#' 
#'     -   text/plain; charset=utf-8
#' @param inputStream User input in PCM or Opus audio format or text format as described in
#' the `requestContentType` parameter.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   inputMode = "string",
#'   contentType = "string",
#'   messages = "string",
#'   interpretations = "string",
#'   sessionState = "string",
#'   requestAttributes = "string",
#'   sessionId = "string",
#'   inputTranscript = "string",
#'   audioStream = raw,
#'   recognizedBotMember = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$recognize_utterance(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string",
#'   sessionState = "string",
#'   requestAttributes = "string",
#'   requestContentType = "string",
#'   responseContentType = "string",
#'   inputStream = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_recognize_utterance
#'
#' @aliases lexruntimev2_recognize_utterance
lexruntimev2_recognize_utterance <- function(botId, botAliasId, localeId, sessionId, sessionState = NULL, requestAttributes = NULL, requestContentType, responseContentType = NULL, inputStream = NULL) {
  op <- new_operation(
    name = "RecognizeUtterance",
    http_method = "POST",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/utterance",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .lexruntimev2$recognize_utterance_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId, sessionState = sessionState, requestAttributes = requestAttributes, requestContentType = requestContentType, responseContentType = responseContentType, inputStream = inputStream)
  output <- .lexruntimev2$recognize_utterance_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$recognize_utterance <- lexruntimev2_recognize_utterance

#' Starts an HTTP/2 bidirectional event stream that enables you to send
#' audio, text, or DTMF input in real time
#'
#' @description
#' Starts an HTTP/2 bidirectional event stream that enables you to send
#' audio, text, or DTMF input in real time. After your application starts a
#' conversation, users send input to Amazon Lex V2 as a stream of events.
#' Amazon Lex V2 processes the incoming events and responds with streaming
#' text or audio events.
#' 
#' Audio input must be in the following format:
#' `audio/lpcm sample-rate=8000 sample-size-bits=16 channel-count=1; is-big-endian=false`.
#' 
#' If the optional post-fulfillment response is specified, the messages are
#' returned as follows. For more information, see
#' [PostFulfillmentStatusSpecification](https://docs.aws.amazon.com/lexv2/latest/APIReference/API_PostFulfillmentStatusSpecification.html).
#' 
#' -   **Success message** - Returned if the Lambda function completes
#'     successfully and the intent state is fulfilled or ready fulfillment
#'     if the message is present.
#' 
#' -   **Failed message** - The failed message is returned if the Lambda
#'     function throws an exception or if the Lambda function returns a
#'     failed intent state without a message.
#' 
#' -   **Timeout message** - If you don't configure a timeout message and a
#'     timeout, and the Lambda function doesn't return within 30 seconds,
#'     the timeout message is returned. If you configure a timeout, the
#'     timeout message is returned when the period times out.
#' 
#' For more information, see [Completion
#' message](https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-complete.html).
#' 
#' If the optional update message is configured, it is played at the
#' specified frequency while the Lambda function is running and the update
#' message state is active. If the fulfillment update message is not
#' active, the Lambda function runs with a 30 second timeout.
#' 
#' For more information, see [Update
#' message](https://docs.aws.amazon.com/lexv2/latest/dg/streaming-progress.html#progress-update.html)
#' 
#' The [`start_conversation`][lexruntimev2_start_conversation] operation is
#' supported only in the following SDKs:
#' 
#' -   [AWS SDK for
#'     C++](https://docs.aws.amazon.com/sdk-for-cpp/latest/api/crosslink_redirect.html?uid=runtime.lex.v2-2020-08-07&type=StartConversation)
#' 
#' -   [AWS SDK for Java
#'     V2](https://sdk.amazonaws.com/java/api/latest/crosslink_redirect.html?uid=runtime.lex.v2-2020-08-07&type=StartConversation)
#' 
#' -   [AWS SDK for Ruby
#'     V3](https://docs.aws.amazon.com/sdk-for-ruby/v3/api/Aws/LexRuntimeV2/Client.html#start_conversation-instance_method)
#'
#' @usage
#' lexruntimev2_start_conversation(botId, botAliasId, localeId, sessionId,
#'   conversationMode, requestEventStream)
#'
#' @param botId &#91;required&#93; The identifier of the bot to process the request.
#' @param botAliasId &#91;required&#93; The alias identifier in use for the bot that processes the request.
#' @param localeId &#91;required&#93; The locale where the session is in use.
#' @param sessionId &#91;required&#93; The identifier of the user session that is having the conversation.
#' @param conversationMode The conversation type that you are using the Amazon Lex V2. If the
#' conversation mode is `AUDIO` you can send both audio and DTMF
#' information. If the mode is `TEXT` you can only send text.
#' @param requestEventStream &#91;required&#93; Represents the stream of events to Amazon Lex V2 from your application.
#' The events are encoded as HTTP/2 data frames.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   responseEventStream = list(
#'     PlaybackInterruptionEvent = list(
#'       eventReason = "DTMF_START_DETECTED"|"TEXT_DETECTED"|"VOICE_START_DETECTED",
#'       causedByEventId = "string",
#'       eventId = "string"
#'     ),
#'     TranscriptEvent = list(
#'       transcript = "string",
#'       eventId = "string"
#'     ),
#'     IntentResultEvent = list(
#'       inputMode = "Text"|"Speech"|"DTMF",
#'       interpretations = list(
#'         list(
#'           nluConfidence = list(
#'             score = 123.0
#'           ),
#'           sentimentResponse = list(
#'             sentiment = "MIXED"|"NEGATIVE"|"NEUTRAL"|"POSITIVE",
#'             sentimentScore = list(
#'               positive = 123.0,
#'               negative = 123.0,
#'               neutral = 123.0,
#'               mixed = 123.0
#'             )
#'           ),
#'           intent = list(
#'             name = "string",
#'             slots = list(
#'               list(
#'                 value = list(
#'                   originalValue = "string",
#'                   interpretedValue = "string",
#'                   resolvedValues = list(
#'                     "string"
#'                   )
#'                 ),
#'                 shape = "Scalar"|"List"|"Composite",
#'                 values = list(
#'                   list()
#'                 ),
#'                 subSlots = list()
#'               )
#'             ),
#'             state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'             confirmationState = "Confirmed"|"Denied"|"None"
#'           ),
#'           interpretationSource = "Bedrock"|"Lex"
#'         )
#'       ),
#'       sessionState = list(
#'         dialogAction = list(
#'           type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'           slotToElicit = "string",
#'           slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'           subSlotToElicit = list(
#'             name = "string",
#'             subSlotToElicit = list()
#'           )
#'         ),
#'         intent = list(
#'           name = "string",
#'           slots = list(
#'             list(
#'               value = list(
#'                 originalValue = "string",
#'                 interpretedValue = "string",
#'                 resolvedValues = list(
#'                   "string"
#'                 )
#'               ),
#'               shape = "Scalar"|"List"|"Composite",
#'               values = list(
#'                 list()
#'               ),
#'               subSlots = list()
#'             )
#'           ),
#'           state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'           confirmationState = "Confirmed"|"Denied"|"None"
#'         ),
#'         activeContexts = list(
#'           list(
#'             name = "string",
#'             timeToLive = list(
#'               timeToLiveInSeconds = 123,
#'               turnsToLive = 123
#'             ),
#'             contextAttributes = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         sessionAttributes = list(
#'           "string"
#'         ),
#'         originatingRequestId = "string",
#'         runtimeHints = list(
#'           slotHints = list(
#'             list(
#'               list(
#'                 runtimeHintValues = list(
#'                   list(
#'                     phrase = "string"
#'                   )
#'                 ),
#'                 subSlotHints = list()
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       requestAttributes = list(
#'         "string"
#'       ),
#'       sessionId = "string",
#'       eventId = "string",
#'       recognizedBotMember = list(
#'         botId = "string",
#'         botName = "string"
#'       )
#'     ),
#'     TextResponseEvent = list(
#'       messages = list(
#'         list(
#'           content = "string",
#'           contentType = "CustomPayload"|"ImageResponseCard"|"PlainText"|"SSML",
#'           imageResponseCard = list(
#'             title = "string",
#'             subtitle = "string",
#'             imageUrl = "string",
#'             buttons = list(
#'               list(
#'                 text = "string",
#'                 value = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       eventId = "string"
#'     ),
#'     AudioResponseEvent = list(
#'       audioChunk = raw,
#'       contentType = "string",
#'       eventId = "string"
#'     ),
#'     HeartbeatEvent = list(
#'       eventId = "string"
#'     ),
#'     AccessDeniedException = list(
#'       message = "string"
#'     ),
#'     ResourceNotFoundException = list(
#'       message = "string"
#'     ),
#'     ValidationException = list(
#'       message = "string"
#'     ),
#'     ThrottlingException = list(
#'       message = "string"
#'     ),
#'     InternalServerException = list(
#'       message = "string"
#'     ),
#'     ConflictException = list(
#'       message = "string"
#'     ),
#'     DependencyFailedException = list(
#'       message = "string"
#'     ),
#'     BadGatewayException = list(
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_conversation(
#'   botId = "string",
#'   botAliasId = "string",
#'   localeId = "string",
#'   sessionId = "string",
#'   conversationMode = "AUDIO"|"TEXT",
#'   requestEventStream = list(
#'     ConfigurationEvent = list(
#'       requestAttributes = list(
#'         "string"
#'       ),
#'       responseContentType = "string",
#'       sessionState = list(
#'         dialogAction = list(
#'           type = "Close"|"ConfirmIntent"|"Delegate"|"ElicitIntent"|"ElicitSlot"|"None",
#'           slotToElicit = "string",
#'           slotElicitationStyle = "Default"|"SpellByLetter"|"SpellByWord",
#'           subSlotToElicit = list(
#'             name = "string",
#'             subSlotToElicit = list()
#'           )
#'         ),
#'         intent = list(
#'           name = "string",
#'           slots = list(
#'             list(
#'               value = list(
#'                 originalValue = "string",
#'                 interpretedValue = "string",
#'                 resolvedValues = list(
#'                   "string"
#'                 )
#'               ),
#'               shape = "Scalar"|"List"|"Composite",
#'               values = list(
#'                 list()
#'               ),
#'               subSlots = list()
#'             )
#'           ),
#'           state = "Failed"|"Fulfilled"|"InProgress"|"ReadyForFulfillment"|"Waiting"|"FulfillmentInProgress",
#'           confirmationState = "Confirmed"|"Denied"|"None"
#'         ),
#'         activeContexts = list(
#'           list(
#'             name = "string",
#'             timeToLive = list(
#'               timeToLiveInSeconds = 123,
#'               turnsToLive = 123
#'             ),
#'             contextAttributes = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         sessionAttributes = list(
#'           "string"
#'         ),
#'         originatingRequestId = "string",
#'         runtimeHints = list(
#'           slotHints = list(
#'             list(
#'               list(
#'                 runtimeHintValues = list(
#'                   list(
#'                     phrase = "string"
#'                   )
#'                 ),
#'                 subSlotHints = list()
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       welcomeMessages = list(
#'         list(
#'           content = "string",
#'           contentType = "CustomPayload"|"ImageResponseCard"|"PlainText"|"SSML",
#'           imageResponseCard = list(
#'             title = "string",
#'             subtitle = "string",
#'             imageUrl = "string",
#'             buttons = list(
#'               list(
#'                 text = "string",
#'                 value = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       disablePlayback = TRUE|FALSE,
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     ),
#'     AudioInputEvent = list(
#'       audioChunk = raw,
#'       contentType = "string",
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     ),
#'     DTMFInputEvent = list(
#'       inputCharacter = "string",
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     ),
#'     TextInputEvent = list(
#'       text = "string",
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     ),
#'     PlaybackCompletionEvent = list(
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     ),
#'     DisconnectionEvent = list(
#'       eventId = "string",
#'       clientTimestampMillis = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname lexruntimev2_start_conversation
#'
#' @aliases lexruntimev2_start_conversation
lexruntimev2_start_conversation <- function(botId, botAliasId, localeId, sessionId, conversationMode = NULL, requestEventStream) {
  op <- new_operation(
    name = "StartConversation",
    http_method = "POST",
    http_path = "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/conversation",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .lexruntimev2$start_conversation_input(botId = botId, botAliasId = botAliasId, localeId = localeId, sessionId = sessionId, conversationMode = conversationMode, requestEventStream = requestEventStream)
  output <- .lexruntimev2$start_conversation_output()
  config <- get_config()
  svc <- .lexruntimev2$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.lexruntimev2$operations$start_conversation <- lexruntimev2_start_conversation

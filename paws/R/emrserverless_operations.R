# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include emrserverless_service.R
NULL

#' Cancels a job run
#'
#' @description
#' Cancels a job run.
#'
#' @usage
#' emrserverless_cancel_job_run(applicationId, jobRunId)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which the job run will be canceled.
#' @param jobRunId &#91;required&#93; The ID of the job run to cancel.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   jobRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_run(
#'   applicationId = "string",
#'   jobRunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_cancel_job_run
emrserverless_cancel_job_run <- function(applicationId, jobRunId) {
  op <- new_operation(
    name = "CancelJobRun",
    http_method = "DELETE",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}",
    paginator = list()
  )
  input <- .emrserverless$cancel_job_run_input(applicationId = applicationId, jobRunId = jobRunId)
  output <- .emrserverless$cancel_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$cancel_job_run <- emrserverless_cancel_job_run

#' Creates an application
#'
#' @description
#' Creates an application.
#'
#' @usage
#' emrserverless_create_application(name, releaseLabel, type, clientToken,
#'   initialCapacity, maximumCapacity, tags, autoStartConfiguration,
#'   autoStopConfiguration, networkConfiguration)
#'
#' @param name The name of the application.
#' @param releaseLabel &#91;required&#93; The EMR release version associated with the application.
#' @param type &#91;required&#93; The type of application you want to start, such as Spark or Hive.
#' @param clientToken &#91;required&#93; The client idempotency token of the application to create. Its value
#' must be unique for each request.
#' @param initialCapacity The capacity to initialize when the application is created.
#' @param maximumCapacity The maximum capacity to allocate when the application is created. This
#' is cumulative across all workers at any given point in time, not just
#' when an application is created. No new resources will be created once
#' any one of the defined limits is hit.
#' @param tags The tags assigned to the application.
#' @param autoStartConfiguration The configuration for an application to automatically start on job
#' submission.
#' @param autoStopConfiguration The configuration for an application to automatically stop after a
#' certain amount of time being idle.
#' @param networkConfiguration The network configuration for customer VPC connectivity.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   name = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_application(
#'   name = "string",
#'   releaseLabel = "string",
#'   type = "string",
#'   clientToken = "string",
#'   initialCapacity = list(
#'     list(
#'       workerCount = 123,
#'       workerConfiguration = list(
#'         cpu = "string",
#'         memory = "string",
#'         disk = "string"
#'       )
#'     )
#'   ),
#'   maximumCapacity = list(
#'     cpu = "string",
#'     memory = "string",
#'     disk = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   autoStartConfiguration = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   autoStopConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     idleTimeoutMinutes = 123
#'   ),
#'   networkConfiguration = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_create_application
emrserverless_create_application <- function(name = NULL, releaseLabel, type, clientToken, initialCapacity = NULL, maximumCapacity = NULL, tags = NULL, autoStartConfiguration = NULL, autoStopConfiguration = NULL, networkConfiguration = NULL) {
  op <- new_operation(
    name = "CreateApplication",
    http_method = "POST",
    http_path = "/applications",
    paginator = list()
  )
  input <- .emrserverless$create_application_input(name = name, releaseLabel = releaseLabel, type = type, clientToken = clientToken, initialCapacity = initialCapacity, maximumCapacity = maximumCapacity, tags = tags, autoStartConfiguration = autoStartConfiguration, autoStopConfiguration = autoStopConfiguration, networkConfiguration = networkConfiguration)
  output <- .emrserverless$create_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$create_application <- emrserverless_create_application

#' Deletes an application
#'
#' @description
#' Deletes an application. An application has to be in a stopped or created
#' state in order to be deleted.
#'
#' @usage
#' emrserverless_delete_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application that will be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_delete_application
emrserverless_delete_application <- function(applicationId) {
  op <- new_operation(
    name = "DeleteApplication",
    http_method = "DELETE",
    http_path = "/applications/{applicationId}",
    paginator = list()
  )
  input <- .emrserverless$delete_application_input(applicationId = applicationId)
  output <- .emrserverless$delete_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$delete_application <- emrserverless_delete_application

#' Displays detailed information about a specified application
#'
#' @description
#' Displays detailed information about a specified application.
#'
#' @usage
#' emrserverless_get_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application that will be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   application = list(
#'     applicationId = "string",
#'     name = "string",
#'     arn = "string",
#'     releaseLabel = "string",
#'     type = "string",
#'     state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'     stateDetails = "string",
#'     initialCapacity = list(
#'       list(
#'         workerCount = 123,
#'         workerConfiguration = list(
#'           cpu = "string",
#'           memory = "string",
#'           disk = "string"
#'         )
#'       )
#'     ),
#'     maximumCapacity = list(
#'       cpu = "string",
#'       memory = "string",
#'       disk = "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     autoStartConfiguration = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     autoStopConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       idleTimeoutMinutes = 123
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_get_application
emrserverless_get_application <- function(applicationId) {
  op <- new_operation(
    name = "GetApplication",
    http_method = "GET",
    http_path = "/applications/{applicationId}",
    paginator = list()
  )
  input <- .emrserverless$get_application_input(applicationId = applicationId)
  output <- .emrserverless$get_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$get_application <- emrserverless_get_application

#' Displays detailed information about a job run
#'
#' @description
#' Displays detailed information about a job run.
#'
#' @usage
#' emrserverless_get_job_run(applicationId, jobRunId)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which the job run is submitted.
#' @param jobRunId &#91;required&#93; The ID of the job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRun = list(
#'     applicationId = "string",
#'     jobRunId = "string",
#'     name = "string",
#'     arn = "string",
#'     createdBy = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     executionRole = "string",
#'     state = "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED",
#'     stateDetails = "string",
#'     releaseLabel = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         s3MonitoringConfiguration = list(
#'           logUri = "string",
#'           encryptionKeyArn = "string"
#'         ),
#'         managedPersistenceMonitoringConfiguration = list(
#'           enabled = TRUE|FALSE,
#'           encryptionKeyArn = "string"
#'         )
#'       )
#'     ),
#'     jobDriver = list(
#'       sparkSubmit = list(
#'         entryPoint = "string",
#'         entryPointArguments = list(
#'           "string"
#'         ),
#'         sparkSubmitParameters = "string"
#'       ),
#'       hive = list(
#'         query = "string",
#'         initQueryFile = "string",
#'         parameters = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     totalResourceUtilization = list(
#'       vCPUHour = 123.0,
#'       memoryGBHour = 123.0,
#'       storageGBHour = 123.0
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     totalExecutionDurationSeconds = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_run(
#'   applicationId = "string",
#'   jobRunId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_get_job_run
emrserverless_get_job_run <- function(applicationId, jobRunId) {
  op <- new_operation(
    name = "GetJobRun",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}",
    paginator = list()
  )
  input <- .emrserverless$get_job_run_input(applicationId = applicationId, jobRunId = jobRunId)
  output <- .emrserverless$get_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$get_job_run <- emrserverless_get_job_run

#' Lists applications based on a set of parameters
#'
#' @description
#' Lists applications based on a set of parameters.
#'
#' @usage
#' emrserverless_list_applications(nextToken, maxResults, states)
#'
#' @param nextToken The token for the next set of application results.
#' @param maxResults The maximum number of applications that can be listed.
#' @param states An optional filter for application states. Note that if this filter
#' contains multiple states, the resulting list will be grouped by the
#' state.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applications = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       releaseLabel = "string",
#'       type = "string",
#'       state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'       stateDetails = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_applications(
#'   nextToken = "string",
#'   maxResults = 123,
#'   states = list(
#'     "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_applications
emrserverless_list_applications <- function(nextToken = NULL, maxResults = NULL, states = NULL) {
  op <- new_operation(
    name = "ListApplications",
    http_method = "GET",
    http_path = "/applications",
    paginator = list()
  )
  input <- .emrserverless$list_applications_input(nextToken = nextToken, maxResults = maxResults, states = states)
  output <- .emrserverless$list_applications_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_applications <- emrserverless_list_applications

#' Lists job runs based on a set of parameters
#'
#' @description
#' Lists job runs based on a set of parameters.
#'
#' @usage
#' emrserverless_list_job_runs(applicationId, nextToken, maxResults,
#'   createdAtAfter, createdAtBefore, states)
#'
#' @param applicationId &#91;required&#93; The ID of the application for which to list the job run.
#' @param nextToken The token for the next set of job run results.
#' @param maxResults The maximum number of job runs that can be listed.
#' @param createdAtAfter The lower bound of the option to filter by creation date and time.
#' @param createdAtBefore The upper bound of the option to filter by creation date and time.
#' @param states An optional filter for job run states. Note that if this filter contains
#' multiple states, the resulting list will be grouped by the state.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRuns = list(
#'     list(
#'       applicationId = "string",
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       createdBy = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       executionRole = "string",
#'       state = "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED",
#'       stateDetails = "string",
#'       releaseLabel = "string",
#'       type = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   applicationId = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   createdAtAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAtBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   states = list(
#'     "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_job_runs
emrserverless_list_job_runs <- function(applicationId, nextToken = NULL, maxResults = NULL, createdAtAfter = NULL, createdAtBefore = NULL, states = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns",
    paginator = list()
  )
  input <- .emrserverless$list_job_runs_input(applicationId = applicationId, nextToken = nextToken, maxResults = maxResults, createdAtAfter = createdAtAfter, createdAtBefore = createdAtBefore, states = states)
  output <- .emrserverless$list_job_runs_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_job_runs <- emrserverless_list_job_runs

#' Lists the tags assigned to the resources
#'
#' @description
#' Lists the tags assigned to the resources.
#'
#' @usage
#' emrserverless_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_tags_for_resource
emrserverless_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrserverless$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .emrserverless$list_tags_for_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_tags_for_resource <- emrserverless_list_tags_for_resource

#' Starts a specified application and initializes initial capacity if
#' configured
#'
#' @description
#' Starts a specified application and initializes initial capacity if
#' configured.
#'
#' @usage
#' emrserverless_start_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application to start.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_start_application
emrserverless_start_application <- function(applicationId) {
  op <- new_operation(
    name = "StartApplication",
    http_method = "POST",
    http_path = "/applications/{applicationId}/start",
    paginator = list()
  )
  input <- .emrserverless$start_application_input(applicationId = applicationId)
  output <- .emrserverless$start_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$start_application <- emrserverless_start_application

#' Starts a job run
#'
#' @description
#' Starts a job run.
#'
#' @usage
#' emrserverless_start_job_run(applicationId, clientToken,
#'   executionRoleArn, jobDriver, configurationOverrides, tags,
#'   executionTimeoutMinutes, name)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which to run the job.
#' @param clientToken &#91;required&#93; The client idempotency token of the job run to start. Its value must be
#' unique for each request.
#' @param executionRoleArn &#91;required&#93; The execution role ARN for the job run.
#' @param jobDriver The job driver for the job run.
#' @param configurationOverrides The configuration overrides for the job run.
#' @param tags The tags assigned to the job run.
#' @param executionTimeoutMinutes The maximum duration for the job run to run. If the job run runs beyond
#' this duration, it will be automatically cancelled.
#' @param name The optional job run name. This doesn't have to be unique.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   applicationId = "string",
#'   clientToken = "string",
#'   executionRoleArn = "string",
#'   jobDriver = list(
#'     sparkSubmit = list(
#'       entryPoint = "string",
#'       entryPointArguments = list(
#'         "string"
#'       ),
#'       sparkSubmitParameters = "string"
#'     ),
#'     hive = list(
#'       query = "string",
#'       initQueryFile = "string",
#'       parameters = "string"
#'     )
#'   ),
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       s3MonitoringConfiguration = list(
#'         logUri = "string",
#'         encryptionKeyArn = "string"
#'       ),
#'       managedPersistenceMonitoringConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         encryptionKeyArn = "string"
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   executionTimeoutMinutes = 123,
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_start_job_run
emrserverless_start_job_run <- function(applicationId, clientToken, executionRoleArn, jobDriver = NULL, configurationOverrides = NULL, tags = NULL, executionTimeoutMinutes = NULL, name = NULL) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/applications/{applicationId}/jobruns",
    paginator = list()
  )
  input <- .emrserverless$start_job_run_input(applicationId = applicationId, clientToken = clientToken, executionRoleArn = executionRoleArn, jobDriver = jobDriver, configurationOverrides = configurationOverrides, tags = tags, executionTimeoutMinutes = executionTimeoutMinutes, name = name)
  output <- .emrserverless$start_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$start_job_run <- emrserverless_start_job_run

#' Stops a specified application and releases initial capacity if
#' configured
#'
#' @description
#' Stops a specified application and releases initial capacity if
#' configured. All scheduled and running jobs must be completed or
#' cancelled before stopping an application.
#'
#' @usage
#' emrserverless_stop_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_stop_application
emrserverless_stop_application <- function(applicationId) {
  op <- new_operation(
    name = "StopApplication",
    http_method = "POST",
    http_path = "/applications/{applicationId}/stop",
    paginator = list()
  )
  input <- .emrserverless$stop_application_input(applicationId = applicationId)
  output <- .emrserverless$stop_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$stop_application <- emrserverless_stop_application

#' Assigns tags to resources
#'
#' @description
#' Assigns tags to resources. A tag is a label that you assign to an AWS
#' resource. Each tag consists of a key and an optional value, both of
#' which you define. Tags enable you to categorize your AWS resources by
#' attributes such as purpose, owner, or environment. When you have many
#' resources of the same type, you can quickly identify a specific resource
#' based on the tags you've assigned to it.
#'
#' @usage
#' emrserverless_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#' @param tags &#91;required&#93; The tags to add to the resource. A tag is an array of key-value pairs.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_tag_resource
emrserverless_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrserverless$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .emrserverless$tag_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$tag_resource <- emrserverless_tag_resource

#' Removes tags from resources
#'
#' @description
#' Removes tags from resources.
#'
#' @usage
#' emrserverless_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#' @param tagKeys &#91;required&#93; The keys of the tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_untag_resource
emrserverless_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrserverless$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .emrserverless$untag_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$untag_resource <- emrserverless_untag_resource

#' Updates a specified application
#'
#' @description
#' Updates a specified application. An application has to be in a stopped
#' or created state in order to be updated.
#'
#' @usage
#' emrserverless_update_application(applicationId, clientToken,
#'   initialCapacity, maximumCapacity, autoStartConfiguration,
#'   autoStopConfiguration, networkConfiguration)
#'
#' @param applicationId &#91;required&#93; The ID of the application to update.
#' @param clientToken &#91;required&#93; The client idempotency token of the application to update. Its value
#' must be unique for each request.
#' @param initialCapacity The capacity to initialize when the application is updated.
#' @param maximumCapacity The maximum capacity to allocate when the application is updated. This
#' is cumulative across all workers at any given point in time during the
#' lifespan of the application. No new resources will be created once any
#' one of the defined limits is hit.
#' @param autoStartConfiguration The configuration for an application to automatically start on job
#' submission.
#' @param autoStopConfiguration The configuration for an application to automatically stop after a
#' certain amount of time being idle.
#' @param networkConfiguration 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   application = list(
#'     applicationId = "string",
#'     name = "string",
#'     arn = "string",
#'     releaseLabel = "string",
#'     type = "string",
#'     state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'     stateDetails = "string",
#'     initialCapacity = list(
#'       list(
#'         workerCount = 123,
#'         workerConfiguration = list(
#'           cpu = "string",
#'           memory = "string",
#'           disk = "string"
#'         )
#'       )
#'     ),
#'     maximumCapacity = list(
#'       cpu = "string",
#'       memory = "string",
#'       disk = "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     autoStartConfiguration = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     autoStopConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       idleTimeoutMinutes = 123
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_application(
#'   applicationId = "string",
#'   clientToken = "string",
#'   initialCapacity = list(
#'     list(
#'       workerCount = 123,
#'       workerConfiguration = list(
#'         cpu = "string",
#'         memory = "string",
#'         disk = "string"
#'       )
#'     )
#'   ),
#'   maximumCapacity = list(
#'     cpu = "string",
#'     memory = "string",
#'     disk = "string"
#'   ),
#'   autoStartConfiguration = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   autoStopConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     idleTimeoutMinutes = 123
#'   ),
#'   networkConfiguration = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_update_application
emrserverless_update_application <- function(applicationId, clientToken, initialCapacity = NULL, maximumCapacity = NULL, autoStartConfiguration = NULL, autoStopConfiguration = NULL, networkConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateApplication",
    http_method = "PATCH",
    http_path = "/applications/{applicationId}",
    paginator = list()
  )
  input <- .emrserverless$update_application_input(applicationId = applicationId, clientToken = clientToken, initialCapacity = initialCapacity, maximumCapacity = maximumCapacity, autoStartConfiguration = autoStartConfiguration, autoStopConfiguration = autoStopConfiguration, networkConfiguration = networkConfiguration)
  output <- .emrserverless$update_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$update_application <- emrserverless_update_application

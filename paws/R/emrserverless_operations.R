# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include emrserverless_service.R
NULL

#' Cancels a job run
#'
#' @description
#' Cancels a job run.
#'
#' @usage
#' emrserverless_cancel_job_run(applicationId, jobRunId,
#'   shutdownGracePeriodInSeconds)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which the job run will be canceled.
#' @param jobRunId &#91;required&#93; The ID of the job run to cancel.
#' @param shutdownGracePeriodInSeconds The duration in seconds to wait before forcefully terminating the job
#' after cancellation is requested.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   jobRunId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_run(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   shutdownGracePeriodInSeconds = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_cancel_job_run
#'
#' @aliases emrserverless_cancel_job_run
emrserverless_cancel_job_run <- function(applicationId, jobRunId, shutdownGracePeriodInSeconds = NULL) {
  op <- new_operation(
    name = "CancelJobRun",
    http_method = "DELETE",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$cancel_job_run_input(applicationId = applicationId, jobRunId = jobRunId, shutdownGracePeriodInSeconds = shutdownGracePeriodInSeconds)
  output <- .emrserverless$cancel_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$cancel_job_run <- emrserverless_cancel_job_run

#' Creates an application
#'
#' @description
#' Creates an application.
#'
#' @usage
#' emrserverless_create_application(name, releaseLabel, type, clientToken,
#'   initialCapacity, maximumCapacity, tags, autoStartConfiguration,
#'   autoStopConfiguration, networkConfiguration, architecture,
#'   imageConfiguration, workerTypeSpecifications, runtimeConfiguration,
#'   monitoringConfiguration, interactiveConfiguration,
#'   schedulerConfiguration, identityCenterConfiguration,
#'   jobLevelCostAllocationConfiguration)
#'
#' @param name The name of the application.
#' @param releaseLabel &#91;required&#93; The Amazon EMR release associated with the application.
#' @param type &#91;required&#93; The type of application you want to start, such as Spark or Hive.
#' @param clientToken &#91;required&#93; The client idempotency token of the application to create. Its value
#' must be unique for each request.
#' @param initialCapacity The capacity to initialize when the application is created.
#' @param maximumCapacity The maximum capacity to allocate when the application is created. This
#' is cumulative across all workers at any given point in time, not just
#' when an application is created. No new resources will be created once
#' any one of the defined limits is hit.
#' @param tags The tags assigned to the application.
#' @param autoStartConfiguration The configuration for an application to automatically start on job
#' submission.
#' @param autoStopConfiguration The configuration for an application to automatically stop after a
#' certain amount of time being idle.
#' @param networkConfiguration The network configuration for customer VPC connectivity.
#' @param architecture The CPU architecture of an application.
#' @param imageConfiguration The image configuration for all worker types. You can either set this
#' parameter or `imageConfiguration` for each worker type in
#' `workerTypeSpecifications`.
#' @param workerTypeSpecifications The key-value pairs that specify worker type to
#' `WorkerTypeSpecificationInput`. This parameter must contain all valid
#' worker types for a Spark or Hive application. Valid worker types include
#' `Driver` and `Executor` for Spark applications and `HiveDriver` and
#' `TezTask` for Hive applications. You can either set image details in
#' this parameter for each worker type, or in `imageConfiguration` for all
#' worker types.
#' @param runtimeConfiguration The
#' [Configuration](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_Configuration.html)
#' specifications to use when creating an application. Each configuration
#' consists of a classification and properties. This configuration is
#' applied to all the job runs submitted under the application.
#' @param monitoringConfiguration The configuration setting for monitoring.
#' @param interactiveConfiguration The interactive configuration object that enables the interactive use
#' cases to use when running an application.
#' @param schedulerConfiguration The scheduler configuration for batch and streaming jobs running on this
#' application. Supported with release labels emr-7.0.0 and above.
#' @param identityCenterConfiguration The IAM Identity Center Configuration accepts the Identity Center
#' instance parameter required to enable trusted identity propagation. This
#' configuration allows identity propagation between integrated services
#' and the Identity Center instance.
#' @param jobLevelCostAllocationConfiguration The configuration object that enables job level cost allocation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   name = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_application(
#'   name = "string",
#'   releaseLabel = "string",
#'   type = "string",
#'   clientToken = "string",
#'   initialCapacity = list(
#'     list(
#'       workerCount = 123,
#'       workerConfiguration = list(
#'         cpu = "string",
#'         memory = "string",
#'         disk = "string",
#'         diskType = "string"
#'       )
#'     )
#'   ),
#'   maximumCapacity = list(
#'     cpu = "string",
#'     memory = "string",
#'     disk = "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   autoStartConfiguration = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   autoStopConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     idleTimeoutMinutes = 123
#'   ),
#'   networkConfiguration = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   architecture = "ARM64"|"X86_64",
#'   imageConfiguration = list(
#'     imageUri = "string"
#'   ),
#'   workerTypeSpecifications = list(
#'     list(
#'       imageConfiguration = list(
#'         imageUri = "string"
#'       )
#'     )
#'   ),
#'   runtimeConfiguration = list(
#'     list(
#'       classification = "string",
#'       properties = list(
#'         "string"
#'       ),
#'       configurations = list()
#'     )
#'   ),
#'   monitoringConfiguration = list(
#'     s3MonitoringConfiguration = list(
#'       logUri = "string",
#'       encryptionKeyArn = "string"
#'     ),
#'     managedPersistenceMonitoringConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       encryptionKeyArn = "string"
#'     ),
#'     cloudWatchLoggingConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       logGroupName = "string",
#'       logStreamNamePrefix = "string",
#'       encryptionKeyArn = "string",
#'       logTypes = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     ),
#'     prometheusMonitoringConfiguration = list(
#'       remoteWriteUrl = "string"
#'     )
#'   ),
#'   interactiveConfiguration = list(
#'     studioEnabled = TRUE|FALSE,
#'     livyEndpointEnabled = TRUE|FALSE
#'   ),
#'   schedulerConfiguration = list(
#'     queueTimeoutMinutes = 123,
#'     maxConcurrentRuns = 123
#'   ),
#'   identityCenterConfiguration = list(
#'     identityCenterInstanceArn = "string",
#'     userBackgroundSessionsEnabled = TRUE|FALSE
#'   ),
#'   jobLevelCostAllocationConfiguration = list(
#'     enabled = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_create_application
#'
#' @aliases emrserverless_create_application
emrserverless_create_application <- function(name = NULL, releaseLabel, type, clientToken, initialCapacity = NULL, maximumCapacity = NULL, tags = NULL, autoStartConfiguration = NULL, autoStopConfiguration = NULL, networkConfiguration = NULL, architecture = NULL, imageConfiguration = NULL, workerTypeSpecifications = NULL, runtimeConfiguration = NULL, monitoringConfiguration = NULL, interactiveConfiguration = NULL, schedulerConfiguration = NULL, identityCenterConfiguration = NULL, jobLevelCostAllocationConfiguration = NULL) {
  op <- new_operation(
    name = "CreateApplication",
    http_method = "POST",
    http_path = "/applications",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$create_application_input(name = name, releaseLabel = releaseLabel, type = type, clientToken = clientToken, initialCapacity = initialCapacity, maximumCapacity = maximumCapacity, tags = tags, autoStartConfiguration = autoStartConfiguration, autoStopConfiguration = autoStopConfiguration, networkConfiguration = networkConfiguration, architecture = architecture, imageConfiguration = imageConfiguration, workerTypeSpecifications = workerTypeSpecifications, runtimeConfiguration = runtimeConfiguration, monitoringConfiguration = monitoringConfiguration, interactiveConfiguration = interactiveConfiguration, schedulerConfiguration = schedulerConfiguration, identityCenterConfiguration = identityCenterConfiguration, jobLevelCostAllocationConfiguration = jobLevelCostAllocationConfiguration)
  output <- .emrserverless$create_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$create_application <- emrserverless_create_application

#' Deletes an application
#'
#' @description
#' Deletes an application. An application has to be in a stopped or created
#' state in order to be deleted.
#'
#' @usage
#' emrserverless_delete_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application that will be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_delete_application
#'
#' @aliases emrserverless_delete_application
emrserverless_delete_application <- function(applicationId) {
  op <- new_operation(
    name = "DeleteApplication",
    http_method = "DELETE",
    http_path = "/applications/{applicationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$delete_application_input(applicationId = applicationId)
  output <- .emrserverless$delete_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$delete_application <- emrserverless_delete_application

#' Displays detailed information about a specified application
#'
#' @description
#' Displays detailed information about a specified application.
#'
#' @usage
#' emrserverless_get_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application that will be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   application = list(
#'     applicationId = "string",
#'     name = "string",
#'     arn = "string",
#'     releaseLabel = "string",
#'     type = "string",
#'     state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'     stateDetails = "string",
#'     initialCapacity = list(
#'       list(
#'         workerCount = 123,
#'         workerConfiguration = list(
#'           cpu = "string",
#'           memory = "string",
#'           disk = "string",
#'           diskType = "string"
#'         )
#'       )
#'     ),
#'     maximumCapacity = list(
#'       cpu = "string",
#'       memory = "string",
#'       disk = "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     autoStartConfiguration = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     autoStopConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       idleTimeoutMinutes = 123
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     architecture = "ARM64"|"X86_64",
#'     imageConfiguration = list(
#'       imageUri = "string",
#'       resolvedImageDigest = "string"
#'     ),
#'     workerTypeSpecifications = list(
#'       list(
#'         imageConfiguration = list(
#'           imageUri = "string",
#'           resolvedImageDigest = "string"
#'         )
#'       )
#'     ),
#'     runtimeConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       s3MonitoringConfiguration = list(
#'         logUri = "string",
#'         encryptionKeyArn = "string"
#'       ),
#'       managedPersistenceMonitoringConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         encryptionKeyArn = "string"
#'       ),
#'       cloudWatchLoggingConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string",
#'         encryptionKeyArn = "string",
#'         logTypes = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       prometheusMonitoringConfiguration = list(
#'         remoteWriteUrl = "string"
#'       )
#'     ),
#'     interactiveConfiguration = list(
#'       studioEnabled = TRUE|FALSE,
#'       livyEndpointEnabled = TRUE|FALSE
#'     ),
#'     schedulerConfiguration = list(
#'       queueTimeoutMinutes = 123,
#'       maxConcurrentRuns = 123
#'     ),
#'     identityCenterConfiguration = list(
#'       identityCenterInstanceArn = "string",
#'       identityCenterApplicationArn = "string",
#'       userBackgroundSessionsEnabled = TRUE|FALSE
#'     ),
#'     jobLevelCostAllocationConfiguration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_get_application
#'
#' @aliases emrserverless_get_application
emrserverless_get_application <- function(applicationId) {
  op <- new_operation(
    name = "GetApplication",
    http_method = "GET",
    http_path = "/applications/{applicationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$get_application_input(applicationId = applicationId)
  output <- .emrserverless$get_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$get_application <- emrserverless_get_application

#' Creates and returns a URL that you can use to access the application UIs
#' for a job run
#'
#' @description
#' Creates and returns a URL that you can use to access the application UIs
#' for a job run.
#' 
#' For jobs in a running state, the application UI is a live user interface
#' such as the Spark or Tez web UI. For completed jobs, the application UI
#' is a persistent application user interface such as the Spark History
#' Server or persistent Tez UI.
#' 
#' The URL is valid for one hour after you generate it. To access the
#' application UI after that hour elapses, you must invoke the API again to
#' generate a new URL.
#'
#' @usage
#' emrserverless_get_dashboard_for_job_run(applicationId, jobRunId,
#'   attempt, accessSystemProfileLogs)
#'
#' @param applicationId &#91;required&#93; The ID of the application.
#' @param jobRunId &#91;required&#93; The ID of the job run.
#' @param attempt An optimal parameter that indicates the amount of attempts for the job.
#' If not specified, this value defaults to the attempt of the latest job.
#' @param accessSystemProfileLogs Allows access to system profile logs for Lake Formation-enabled jobs.
#' Default is false.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   url = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_dashboard_for_job_run(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   attempt = 123,
#'   accessSystemProfileLogs = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_get_dashboard_for_job_run
#'
#' @aliases emrserverless_get_dashboard_for_job_run
emrserverless_get_dashboard_for_job_run <- function(applicationId, jobRunId, attempt = NULL, accessSystemProfileLogs = NULL) {
  op <- new_operation(
    name = "GetDashboardForJobRun",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}/dashboard",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$get_dashboard_for_job_run_input(applicationId = applicationId, jobRunId = jobRunId, attempt = attempt, accessSystemProfileLogs = accessSystemProfileLogs)
  output <- .emrserverless$get_dashboard_for_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$get_dashboard_for_job_run <- emrserverless_get_dashboard_for_job_run

#' Displays detailed information about a job run
#'
#' @description
#' Displays detailed information about a job run.
#'
#' @usage
#' emrserverless_get_job_run(applicationId, jobRunId, attempt)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which the job run is submitted.
#' @param jobRunId &#91;required&#93; The ID of the job run.
#' @param attempt An optimal parameter that indicates the amount of attempts for the job.
#' If not specified, this value defaults to the attempt of the latest job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRun = list(
#'     applicationId = "string",
#'     jobRunId = "string",
#'     name = "string",
#'     arn = "string",
#'     createdBy = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     executionRole = "string",
#'     executionIamPolicy = list(
#'       policy = "string",
#'       policyArns = list(
#'         "string"
#'       )
#'     ),
#'     state = "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED"|"QUEUED",
#'     stateDetails = "string",
#'     releaseLabel = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         s3MonitoringConfiguration = list(
#'           logUri = "string",
#'           encryptionKeyArn = "string"
#'         ),
#'         managedPersistenceMonitoringConfiguration = list(
#'           enabled = TRUE|FALSE,
#'           encryptionKeyArn = "string"
#'         ),
#'         cloudWatchLoggingConfiguration = list(
#'           enabled = TRUE|FALSE,
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string",
#'           encryptionKeyArn = "string",
#'           logTypes = list(
#'             list(
#'               "string"
#'             )
#'           )
#'         ),
#'         prometheusMonitoringConfiguration = list(
#'           remoteWriteUrl = "string"
#'         )
#'       )
#'     ),
#'     jobDriver = list(
#'       sparkSubmit = list(
#'         entryPoint = "string",
#'         entryPointArguments = list(
#'           "string"
#'         ),
#'         sparkSubmitParameters = "string"
#'       ),
#'       hive = list(
#'         query = "string",
#'         initQueryFile = "string",
#'         parameters = "string"
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     totalResourceUtilization = list(
#'       vCPUHour = 123.0,
#'       memoryGBHour = 123.0,
#'       storageGBHour = 123.0
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     totalExecutionDurationSeconds = 123,
#'     executionTimeoutMinutes = 123,
#'     billedResourceUtilization = list(
#'       vCPUHour = 123.0,
#'       memoryGBHour = 123.0,
#'       storageGBHour = 123.0
#'     ),
#'     mode = "BATCH"|"STREAMING",
#'     retryPolicy = list(
#'       maxAttempts = 123,
#'       maxFailedAttemptsPerHour = 123
#'     ),
#'     attempt = 123,
#'     attemptCreatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     attemptUpdatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     startedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     queuedDurationMilliseconds = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_job_run(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   attempt = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_get_job_run
#'
#' @aliases emrserverless_get_job_run
emrserverless_get_job_run <- function(applicationId, jobRunId, attempt = NULL) {
  op <- new_operation(
    name = "GetJobRun",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$get_job_run_input(applicationId = applicationId, jobRunId = jobRunId, attempt = attempt)
  output <- .emrserverless$get_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$get_job_run <- emrserverless_get_job_run

#' Lists applications based on a set of parameters
#'
#' @description
#' Lists applications based on a set of parameters.
#'
#' @usage
#' emrserverless_list_applications(nextToken, maxResults, states)
#'
#' @param nextToken The token for the next set of application results.
#' @param maxResults The maximum number of applications that can be listed.
#' @param states An optional filter for application states. Note that if this filter
#' contains multiple states, the resulting list will be grouped by the
#' state.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applications = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       releaseLabel = "string",
#'       type = "string",
#'       state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'       stateDetails = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       architecture = "ARM64"|"X86_64"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_applications(
#'   nextToken = "string",
#'   maxResults = 123,
#'   states = list(
#'     "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_applications
#'
#' @aliases emrserverless_list_applications
emrserverless_list_applications <- function(nextToken = NULL, maxResults = NULL, states = NULL) {
  op <- new_operation(
    name = "ListApplications",
    http_method = "GET",
    http_path = "/applications",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "applications"),
    stream_api = FALSE
  )
  input <- .emrserverless$list_applications_input(nextToken = nextToken, maxResults = maxResults, states = states)
  output <- .emrserverless$list_applications_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_applications <- emrserverless_list_applications

#' Lists all attempt of a job run
#'
#' @description
#' Lists all attempt of a job run.
#'
#' @usage
#' emrserverless_list_job_run_attempts(applicationId, jobRunId, nextToken,
#'   maxResults)
#'
#' @param applicationId &#91;required&#93; The ID of the application for which to list job runs.
#' @param jobRunId &#91;required&#93; The ID of the job run to list.
#' @param nextToken The token for the next set of job run attempt results.
#' @param maxResults The maximum number of job run attempts to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRunAttempts = list(
#'     list(
#'       applicationId = "string",
#'       id = "string",
#'       name = "string",
#'       mode = "BATCH"|"STREAMING",
#'       arn = "string",
#'       createdBy = "string",
#'       jobCreatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       executionRole = "string",
#'       state = "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED"|"QUEUED",
#'       stateDetails = "string",
#'       releaseLabel = "string",
#'       type = "string",
#'       attempt = 123
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_run_attempts(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_job_run_attempts
#'
#' @aliases emrserverless_list_job_run_attempts
emrserverless_list_job_run_attempts <- function(applicationId, jobRunId, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListJobRunAttempts",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns/{jobRunId}/attempts",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "jobRunAttempts"),
    stream_api = FALSE
  )
  input <- .emrserverless$list_job_run_attempts_input(applicationId = applicationId, jobRunId = jobRunId, nextToken = nextToken, maxResults = maxResults)
  output <- .emrserverless$list_job_run_attempts_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_job_run_attempts <- emrserverless_list_job_run_attempts

#' Lists job runs based on a set of parameters
#'
#' @description
#' Lists job runs based on a set of parameters.
#'
#' @usage
#' emrserverless_list_job_runs(applicationId, nextToken, maxResults,
#'   createdAtAfter, createdAtBefore, states, mode)
#'
#' @param applicationId &#91;required&#93; The ID of the application for which to list the job run.
#' @param nextToken The token for the next set of job run results.
#' @param maxResults The maximum number of job runs that can be listed.
#' @param createdAtAfter The lower bound of the option to filter by creation date and time.
#' @param createdAtBefore The upper bound of the option to filter by creation date and time.
#' @param states An optional filter for job run states. Note that if this filter contains
#' multiple states, the resulting list will be grouped by the state.
#' @param mode The mode of the job runs to list.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRuns = list(
#'     list(
#'       applicationId = "string",
#'       id = "string",
#'       name = "string",
#'       mode = "BATCH"|"STREAMING",
#'       arn = "string",
#'       createdBy = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       executionRole = "string",
#'       state = "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED"|"QUEUED",
#'       stateDetails = "string",
#'       releaseLabel = "string",
#'       type = "string",
#'       attempt = 123,
#'       attemptCreatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       attemptUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   applicationId = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   createdAtAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAtBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   states = list(
#'     "SUBMITTED"|"PENDING"|"SCHEDULED"|"RUNNING"|"SUCCESS"|"FAILED"|"CANCELLING"|"CANCELLED"|"QUEUED"
#'   ),
#'   mode = "BATCH"|"STREAMING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_job_runs
#'
#' @aliases emrserverless_list_job_runs
emrserverless_list_job_runs <- function(applicationId, nextToken = NULL, maxResults = NULL, createdAtAfter = NULL, createdAtBefore = NULL, states = NULL, mode = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/applications/{applicationId}/jobruns",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "jobRuns"),
    stream_api = FALSE
  )
  input <- .emrserverless$list_job_runs_input(applicationId = applicationId, nextToken = nextToken, maxResults = maxResults, createdAtAfter = createdAtAfter, createdAtBefore = createdAtBefore, states = states, mode = mode)
  output <- .emrserverless$list_job_runs_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_job_runs <- emrserverless_list_job_runs

#' Lists the tags assigned to the resources
#'
#' @description
#' Lists the tags assigned to the resources.
#'
#' @usage
#' emrserverless_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_list_tags_for_resource
#'
#' @aliases emrserverless_list_tags_for_resource
emrserverless_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .emrserverless$list_tags_for_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$list_tags_for_resource <- emrserverless_list_tags_for_resource

#' Starts a specified application and initializes initial capacity if
#' configured
#'
#' @description
#' Starts a specified application and initializes initial capacity if
#' configured.
#'
#' @usage
#' emrserverless_start_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application to start.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_start_application
#'
#' @aliases emrserverless_start_application
emrserverless_start_application <- function(applicationId) {
  op <- new_operation(
    name = "StartApplication",
    http_method = "POST",
    http_path = "/applications/{applicationId}/start",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$start_application_input(applicationId = applicationId)
  output <- .emrserverless$start_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$start_application <- emrserverless_start_application

#' Starts a job run
#'
#' @description
#' Starts a job run.
#'
#' @usage
#' emrserverless_start_job_run(applicationId, clientToken,
#'   executionRoleArn, executionIamPolicy, jobDriver, configurationOverrides,
#'   tags, executionTimeoutMinutes, name, mode, retryPolicy)
#'
#' @param applicationId &#91;required&#93; The ID of the application on which to run the job.
#' @param clientToken &#91;required&#93; The client idempotency token of the job run to start. Its value must be
#' unique for each request.
#' @param executionRoleArn &#91;required&#93; The execution role ARN for the job run.
#' @param executionIamPolicy You can pass an optional IAM policy. The resulting job IAM role
#' permissions will be an intersection of this policy and the policy
#' associated with your job execution role.
#' @param jobDriver The job driver for the job run.
#' @param configurationOverrides The configuration overrides for the job run.
#' @param tags The tags assigned to the job run.
#' @param executionTimeoutMinutes The maximum duration for the job run to run. If the job run runs beyond
#' this duration, it will be automatically cancelled.
#' @param name The optional job run name. This doesn't have to be unique.
#' @param mode The mode of the job run when it starts.
#' @param retryPolicy The retry policy when job run starts.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   applicationId = "string",
#'   jobRunId = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   applicationId = "string",
#'   clientToken = "string",
#'   executionRoleArn = "string",
#'   executionIamPolicy = list(
#'     policy = "string",
#'     policyArns = list(
#'       "string"
#'     )
#'   ),
#'   jobDriver = list(
#'     sparkSubmit = list(
#'       entryPoint = "string",
#'       entryPointArguments = list(
#'         "string"
#'       ),
#'       sparkSubmitParameters = "string"
#'     ),
#'     hive = list(
#'       query = "string",
#'       initQueryFile = "string",
#'       parameters = "string"
#'     )
#'   ),
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       s3MonitoringConfiguration = list(
#'         logUri = "string",
#'         encryptionKeyArn = "string"
#'       ),
#'       managedPersistenceMonitoringConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         encryptionKeyArn = "string"
#'       ),
#'       cloudWatchLoggingConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string",
#'         encryptionKeyArn = "string",
#'         logTypes = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       prometheusMonitoringConfiguration = list(
#'         remoteWriteUrl = "string"
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   executionTimeoutMinutes = 123,
#'   name = "string",
#'   mode = "BATCH"|"STREAMING",
#'   retryPolicy = list(
#'     maxAttempts = 123,
#'     maxFailedAttemptsPerHour = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_start_job_run
#'
#' @aliases emrserverless_start_job_run
emrserverless_start_job_run <- function(applicationId, clientToken, executionRoleArn, executionIamPolicy = NULL, jobDriver = NULL, configurationOverrides = NULL, tags = NULL, executionTimeoutMinutes = NULL, name = NULL, mode = NULL, retryPolicy = NULL) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/applications/{applicationId}/jobruns",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$start_job_run_input(applicationId = applicationId, clientToken = clientToken, executionRoleArn = executionRoleArn, executionIamPolicy = executionIamPolicy, jobDriver = jobDriver, configurationOverrides = configurationOverrides, tags = tags, executionTimeoutMinutes = executionTimeoutMinutes, name = name, mode = mode, retryPolicy = retryPolicy)
  output <- .emrserverless$start_job_run_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$start_job_run <- emrserverless_start_job_run

#' Stops a specified application and releases initial capacity if
#' configured
#'
#' @description
#' Stops a specified application and releases initial capacity if
#' configured. All scheduled and running jobs must be completed or
#' cancelled before stopping an application.
#'
#' @usage
#' emrserverless_stop_application(applicationId)
#'
#' @param applicationId &#91;required&#93; The ID of the application to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_application(
#'   applicationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_stop_application
#'
#' @aliases emrserverless_stop_application
emrserverless_stop_application <- function(applicationId) {
  op <- new_operation(
    name = "StopApplication",
    http_method = "POST",
    http_path = "/applications/{applicationId}/stop",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$stop_application_input(applicationId = applicationId)
  output <- .emrserverless$stop_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$stop_application <- emrserverless_stop_application

#' Assigns tags to resources
#'
#' @description
#' Assigns tags to resources. A tag is a label that you assign to an Amazon
#' Web Services resource. Each tag consists of a key and an optional value,
#' both of which you define. Tags enable you to categorize your Amazon Web
#' Services resources by attributes such as purpose, owner, or environment.
#' When you have many resources of the same type, you can quickly identify
#' a specific resource based on the tags you've assigned to it.
#'
#' @usage
#' emrserverless_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#' @param tags &#91;required&#93; The tags to add to the resource. A tag is an array of key-value pairs.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_tag_resource
#'
#' @aliases emrserverless_tag_resource
emrserverless_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .emrserverless$tag_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$tag_resource <- emrserverless_tag_resource

#' Removes tags from resources
#'
#' @description
#' Removes tags from resources.
#'
#' @usage
#' emrserverless_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) that identifies the resource to list the
#' tags for. Currently, the supported resources are Amazon EMR Serverless
#' applications and job runs.
#' @param tagKeys &#91;required&#93; The keys of the tags to be removed.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_untag_resource
#'
#' @aliases emrserverless_untag_resource
emrserverless_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .emrserverless$untag_resource_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$untag_resource <- emrserverless_untag_resource

#' Updates a specified application
#'
#' @description
#' Updates a specified application. An application has to be in a stopped
#' or created state in order to be updated.
#'
#' @usage
#' emrserverless_update_application(applicationId, clientToken,
#'   initialCapacity, maximumCapacity, autoStartConfiguration,
#'   autoStopConfiguration, networkConfiguration, architecture,
#'   imageConfiguration, workerTypeSpecifications, interactiveConfiguration,
#'   releaseLabel, runtimeConfiguration, monitoringConfiguration,
#'   schedulerConfiguration, identityCenterConfiguration,
#'   jobLevelCostAllocationConfiguration)
#'
#' @param applicationId &#91;required&#93; The ID of the application to update.
#' @param clientToken &#91;required&#93; The client idempotency token of the application to update. Its value
#' must be unique for each request.
#' @param initialCapacity The capacity to initialize when the application is updated.
#' @param maximumCapacity The maximum capacity to allocate when the application is updated. This
#' is cumulative across all workers at any given point in time during the
#' lifespan of the application. No new resources will be created once any
#' one of the defined limits is hit.
#' @param autoStartConfiguration The configuration for an application to automatically start on job
#' submission.
#' @param autoStopConfiguration The configuration for an application to automatically stop after a
#' certain amount of time being idle.
#' @param networkConfiguration 
#' @param architecture The CPU architecture of an application.
#' @param imageConfiguration The image configuration to be used for all worker types. You can either
#' set this parameter or `imageConfiguration` for each worker type in
#' `WorkerTypeSpecificationInput`.
#' @param workerTypeSpecifications The key-value pairs that specify worker type to
#' `WorkerTypeSpecificationInput`. This parameter must contain all valid
#' worker types for a Spark or Hive application. Valid worker types include
#' `Driver` and `Executor` for Spark applications and `HiveDriver` and
#' `TezTask` for Hive applications. You can either set image details in
#' this parameter for each worker type, or in `imageConfiguration` for all
#' worker types.
#' @param interactiveConfiguration The interactive configuration object that contains new interactive use
#' cases when the application is updated.
#' @param releaseLabel The Amazon EMR release label for the application. You can change the
#' release label to use a different release of Amazon EMR.
#' @param runtimeConfiguration The
#' [Configuration](https://docs.aws.amazon.com/emr-serverless/latest/APIReference/API_Configuration.html)
#' specifications to use when updating an application. Each configuration
#' consists of a classification and properties. This configuration is
#' applied across all the job runs submitted under the application.
#' @param monitoringConfiguration The configuration setting for monitoring.
#' @param schedulerConfiguration The scheduler configuration for batch and streaming jobs running on this
#' application. Supported with release labels emr-7.0.0 and above.
#' @param identityCenterConfiguration Specifies the IAM Identity Center configuration used to enable or
#' disable trusted identity propagation. When provided, this configuration
#' determines how the application interacts with IAM Identity Center for
#' user authentication and access control.
#' @param jobLevelCostAllocationConfiguration The configuration object that enables job level cost allocation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   application = list(
#'     applicationId = "string",
#'     name = "string",
#'     arn = "string",
#'     releaseLabel = "string",
#'     type = "string",
#'     state = "CREATING"|"CREATED"|"STARTING"|"STARTED"|"STOPPING"|"STOPPED"|"TERMINATED",
#'     stateDetails = "string",
#'     initialCapacity = list(
#'       list(
#'         workerCount = 123,
#'         workerConfiguration = list(
#'           cpu = "string",
#'           memory = "string",
#'           disk = "string",
#'           diskType = "string"
#'         )
#'       )
#'     ),
#'     maximumCapacity = list(
#'       cpu = "string",
#'       memory = "string",
#'       disk = "string"
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     autoStartConfiguration = list(
#'       enabled = TRUE|FALSE
#'     ),
#'     autoStopConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       idleTimeoutMinutes = 123
#'     ),
#'     networkConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroupIds = list(
#'         "string"
#'       )
#'     ),
#'     architecture = "ARM64"|"X86_64",
#'     imageConfiguration = list(
#'       imageUri = "string",
#'       resolvedImageDigest = "string"
#'     ),
#'     workerTypeSpecifications = list(
#'       list(
#'         imageConfiguration = list(
#'           imageUri = "string",
#'           resolvedImageDigest = "string"
#'         )
#'       )
#'     ),
#'     runtimeConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       s3MonitoringConfiguration = list(
#'         logUri = "string",
#'         encryptionKeyArn = "string"
#'       ),
#'       managedPersistenceMonitoringConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         encryptionKeyArn = "string"
#'       ),
#'       cloudWatchLoggingConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string",
#'         encryptionKeyArn = "string",
#'         logTypes = list(
#'           list(
#'             "string"
#'           )
#'         )
#'       ),
#'       prometheusMonitoringConfiguration = list(
#'         remoteWriteUrl = "string"
#'       )
#'     ),
#'     interactiveConfiguration = list(
#'       studioEnabled = TRUE|FALSE,
#'       livyEndpointEnabled = TRUE|FALSE
#'     ),
#'     schedulerConfiguration = list(
#'       queueTimeoutMinutes = 123,
#'       maxConcurrentRuns = 123
#'     ),
#'     identityCenterConfiguration = list(
#'       identityCenterInstanceArn = "string",
#'       identityCenterApplicationArn = "string",
#'       userBackgroundSessionsEnabled = TRUE|FALSE
#'     ),
#'     jobLevelCostAllocationConfiguration = list(
#'       enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_application(
#'   applicationId = "string",
#'   clientToken = "string",
#'   initialCapacity = list(
#'     list(
#'       workerCount = 123,
#'       workerConfiguration = list(
#'         cpu = "string",
#'         memory = "string",
#'         disk = "string",
#'         diskType = "string"
#'       )
#'     )
#'   ),
#'   maximumCapacity = list(
#'     cpu = "string",
#'     memory = "string",
#'     disk = "string"
#'   ),
#'   autoStartConfiguration = list(
#'     enabled = TRUE|FALSE
#'   ),
#'   autoStopConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     idleTimeoutMinutes = 123
#'   ),
#'   networkConfiguration = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   architecture = "ARM64"|"X86_64",
#'   imageConfiguration = list(
#'     imageUri = "string"
#'   ),
#'   workerTypeSpecifications = list(
#'     list(
#'       imageConfiguration = list(
#'         imageUri = "string"
#'       )
#'     )
#'   ),
#'   interactiveConfiguration = list(
#'     studioEnabled = TRUE|FALSE,
#'     livyEndpointEnabled = TRUE|FALSE
#'   ),
#'   releaseLabel = "string",
#'   runtimeConfiguration = list(
#'     list(
#'       classification = "string",
#'       properties = list(
#'         "string"
#'       ),
#'       configurations = list()
#'     )
#'   ),
#'   monitoringConfiguration = list(
#'     s3MonitoringConfiguration = list(
#'       logUri = "string",
#'       encryptionKeyArn = "string"
#'     ),
#'     managedPersistenceMonitoringConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       encryptionKeyArn = "string"
#'     ),
#'     cloudWatchLoggingConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       logGroupName = "string",
#'       logStreamNamePrefix = "string",
#'       encryptionKeyArn = "string",
#'       logTypes = list(
#'         list(
#'           "string"
#'         )
#'       )
#'     ),
#'     prometheusMonitoringConfiguration = list(
#'       remoteWriteUrl = "string"
#'     )
#'   ),
#'   schedulerConfiguration = list(
#'     queueTimeoutMinutes = 123,
#'     maxConcurrentRuns = 123
#'   ),
#'   identityCenterConfiguration = list(
#'     identityCenterInstanceArn = "string",
#'     userBackgroundSessionsEnabled = TRUE|FALSE
#'   ),
#'   jobLevelCostAllocationConfiguration = list(
#'     enabled = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrserverless_update_application
#'
#' @aliases emrserverless_update_application
emrserverless_update_application <- function(applicationId, clientToken, initialCapacity = NULL, maximumCapacity = NULL, autoStartConfiguration = NULL, autoStopConfiguration = NULL, networkConfiguration = NULL, architecture = NULL, imageConfiguration = NULL, workerTypeSpecifications = NULL, interactiveConfiguration = NULL, releaseLabel = NULL, runtimeConfiguration = NULL, monitoringConfiguration = NULL, schedulerConfiguration = NULL, identityCenterConfiguration = NULL, jobLevelCostAllocationConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateApplication",
    http_method = "PATCH",
    http_path = "/applications/{applicationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrserverless$update_application_input(applicationId = applicationId, clientToken = clientToken, initialCapacity = initialCapacity, maximumCapacity = maximumCapacity, autoStartConfiguration = autoStartConfiguration, autoStopConfiguration = autoStopConfiguration, networkConfiguration = networkConfiguration, architecture = architecture, imageConfiguration = imageConfiguration, workerTypeSpecifications = workerTypeSpecifications, interactiveConfiguration = interactiveConfiguration, releaseLabel = releaseLabel, runtimeConfiguration = runtimeConfiguration, monitoringConfiguration = monitoringConfiguration, schedulerConfiguration = schedulerConfiguration, identityCenterConfiguration = identityCenterConfiguration, jobLevelCostAllocationConfiguration = jobLevelCostAllocationConfiguration)
  output <- .emrserverless$update_application_output()
  config <- get_config()
  svc <- .emrserverless$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrserverless$operations$update_application <- emrserverless_update_application

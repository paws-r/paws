# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include verifiedpermissions_service.R
NULL

#' Retrieves information about a group (batch) of policies
#'
#' @description
#' Retrieves information about a group (batch) of policies.
#' 
#' The [`batch_get_policy`][verifiedpermissions_batch_get_policy] operation
#' doesn't have its own IAM permission. To authorize this operation for
#' Amazon Web Services principals, include the permission
#' `verifiedpermissions:GetPolicy` in their IAM policies.
#'
#' @usage
#' verifiedpermissions_batch_get_policy(requests)
#'
#' @param requests &#91;required&#93; An array of up to 100 policies you want information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   results = list(
#'     list(
#'       policyStoreId = "string",
#'       policyId = "string",
#'       policyType = "STATIC"|"TEMPLATE_LINKED",
#'       definition = list(
#'         static = list(
#'           description = "string",
#'           statement = "string"
#'         ),
#'         templateLinked = list(
#'           policyTemplateId = "string",
#'           principal = list(
#'             entityType = "string",
#'             entityId = "string"
#'           ),
#'           resource = list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         )
#'       ),
#'       createdDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedDate = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       code = "POLICY_STORE_NOT_FOUND"|"POLICY_NOT_FOUND",
#'       policyStoreId = "string",
#'       policyId = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_policy(
#'   requests = list(
#'     list(
#'       policyStoreId = "string",
#'       policyId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_batch_get_policy
#'
#' @aliases verifiedpermissions_batch_get_policy
verifiedpermissions_batch_get_policy <- function(requests) {
  op <- new_operation(
    name = "BatchGetPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$batch_get_policy_input(requests = requests)
  output <- .verifiedpermissions$batch_get_policy_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$batch_get_policy <- verifiedpermissions_batch_get_policy

#' Makes a series of decisions about multiple authorization requests for
#' one principal or resource
#'
#' @description
#' Makes a series of decisions about multiple authorization requests for
#' one principal or resource. Each request contains the equivalent content
#' of an [`is_authorized`][verifiedpermissions_is_authorized] request:
#' principal, action, resource, and context. Either the `principal` or the
#' `resource` parameter must be identical across all requests. For example,
#' Verified Permissions won't evaluate a pair of requests where `bob` views
#' `photo1` and `alice` views `photo2`. Authorization of `bob` to view
#' `photo1` and `photo2`, or `bob` and `alice` to view `photo1`, are valid
#' batches.
#' 
#' The request is evaluated against all policies in the specified policy
#' store that match the entities that you declare. The result of the
#' decisions is a series of `Allow` or `Deny` responses, along with the IDs
#' of the policies that produced each decision.
#' 
#' The `entities` of a
#' [`batch_is_authorized`][verifiedpermissions_batch_is_authorized] API
#' request can contain up to 100 principals and up to 100 resources. The
#' `requests` of a
#' [`batch_is_authorized`][verifiedpermissions_batch_is_authorized] API
#' request can contain up to 30 requests.
#' 
#' The [`batch_is_authorized`][verifiedpermissions_batch_is_authorized]
#' operation doesn't have its own IAM permission. To authorize this
#' operation for Amazon Web Services principals, include the permission
#' `verifiedpermissions:IsAuthorized` in their IAM policies.
#'
#' @usage
#' verifiedpermissions_batch_is_authorized(policyStoreId, entities,
#'   requests)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store. Policies in this policy store will
#' be used to make the authorization decisions for the input.
#' @param entities (Optional) Specifies the list of resources and principals and their
#' associated attributes that Verified Permissions can examine when
#' evaluating the policies. These additional entities and their attributes
#' can be referenced and checked by conditional elements in the policies in
#' the specified policy store.
#' 
#' You can include only principal and resource entities in this parameter;
#' you can't include actions. You must specify actions in the schema.
#' @param requests &#91;required&#93; An array of up to 30 requests that you want Verified Permissions to
#' evaluate.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   results = list(
#'     list(
#'       request = list(
#'         principal = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         action = list(
#'           actionType = "string",
#'           actionId = "string"
#'         ),
#'         resource = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         context = list(
#'           contextMap = list(
#'             list(
#'               boolean = TRUE|FALSE,
#'               entityIdentifier = list(
#'                 entityType = "string",
#'                 entityId = "string"
#'               ),
#'               long = 123,
#'               string = "string",
#'               set = list(
#'                 list()
#'               ),
#'               record = list(
#'                 list()
#'               ),
#'               ipaddr = "string",
#'               decimal = "string",
#'               datetime = "string",
#'               duration = "string"
#'             )
#'           ),
#'           cedarJson = "string"
#'         )
#'       ),
#'       decision = "ALLOW"|"DENY",
#'       determiningPolicies = list(
#'         list(
#'           policyId = "string"
#'         )
#'       ),
#'       errors = list(
#'         list(
#'           errorDescription = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_is_authorized(
#'   policyStoreId = "string",
#'   entities = list(
#'     entityList = list(
#'       list(
#'         identifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         attributes = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         parents = list(
#'           list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         ),
#'         tags = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         )
#'       )
#'     ),
#'     cedarJson = "string"
#'   ),
#'   requests = list(
#'     list(
#'       principal = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       action = list(
#'         actionType = "string",
#'         actionId = "string"
#'       ),
#'       resource = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       context = list(
#'         contextMap = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         cedarJson = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_batch_is_authorized
#'
#' @aliases verifiedpermissions_batch_is_authorized
verifiedpermissions_batch_is_authorized <- function(policyStoreId, entities = NULL, requests) {
  op <- new_operation(
    name = "BatchIsAuthorized",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$batch_is_authorized_input(policyStoreId = policyStoreId, entities = entities, requests = requests)
  output <- .verifiedpermissions$batch_is_authorized_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$batch_is_authorized <- verifiedpermissions_batch_is_authorized

#' Makes a series of decisions about multiple authorization requests for
#' one token
#'
#' @description
#' Makes a series of decisions about multiple authorization requests for
#' one token. The principal in this request comes from an external identity
#' source in the form of an identity or access token, formatted as a [JSON
#' web token (JWT)](https://en.wikipedia.org/wiki/JSON_Web_Token). The
#' information in the parameters can also define additional context that
#' Verified Permissions can include in the evaluations.
#' 
#' The request is evaluated against all policies in the specified policy
#' store that match the entities that you provide in the entities
#' declaration and in the token. The result of the decisions is a series of
#' `Allow` or `Deny` responses, along with the IDs of the policies that
#' produced each decision.
#' 
#' The `entities` of a
#' [`batch_is_authorized_with_token`][verifiedpermissions_batch_is_authorized_with_token]
#' API request can contain up to 100 resources and up to 99 user groups.
#' The `requests` of a
#' [`batch_is_authorized_with_token`][verifiedpermissions_batch_is_authorized_with_token]
#' API request can contain up to 30 requests.
#' 
#' The
#' [`batch_is_authorized_with_token`][verifiedpermissions_batch_is_authorized_with_token]
#' operation doesn't have its own IAM permission. To authorize this
#' operation for Amazon Web Services principals, include the permission
#' `verifiedpermissions:IsAuthorizedWithToken` in their IAM policies.
#'
#' @usage
#' verifiedpermissions_batch_is_authorized_with_token(policyStoreId,
#'   identityToken, accessToken, entities, requests)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store. Policies in this policy store will
#' be used to make an authorization decision for the input.
#' @param identityToken Specifies an identity (ID) token for the principal that you want to
#' authorize in each request. This token is provided to you by the identity
#' provider (IdP) associated with the specified identity source. You must
#' specify either an `accessToken`, an `identityToken`, or both.
#' 
#' Must be an ID token. Verified Permissions returns an error if the
#' `token_use` claim in the submitted token isn't `id`.
#' @param accessToken Specifies an access token for the principal that you want to authorize
#' in each request. This token is provided to you by the identity provider
#' (IdP) associated with the specified identity source. You must specify
#' either an `accessToken`, an `identityToken`, or both.
#' 
#' Must be an access token. Verified Permissions returns an error if the
#' `token_use` claim in the submitted token isn't `access`.
#' @param entities (Optional) Specifies the list of resources and their associated
#' attributes that Verified Permissions can examine when evaluating the
#' policies. These additional entities and their attributes can be
#' referenced and checked by conditional elements in the policies in the
#' specified policy store.
#' 
#' You can't include principals in this parameter, only resource and action
#' entities. This parameter can't include any entities of a type that
#' matches the user or group entity types that you defined in your identity
#' source.
#' 
#' -   The
#'     [`batch_is_authorized_with_token`][verifiedpermissions_batch_is_authorized_with_token]
#'     operation takes principal attributes from ***only*** the
#'     `identityToken` or `accessToken` passed to the operation.
#' 
#' -   For action entities, you can include only their `Identifier` and
#'     `EntityType`.
#' @param requests &#91;required&#93; An array of up to 30 requests that you want Verified Permissions to
#' evaluate.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   results = list(
#'     list(
#'       request = list(
#'         action = list(
#'           actionType = "string",
#'           actionId = "string"
#'         ),
#'         resource = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         context = list(
#'           contextMap = list(
#'             list(
#'               boolean = TRUE|FALSE,
#'               entityIdentifier = list(
#'                 entityType = "string",
#'                 entityId = "string"
#'               ),
#'               long = 123,
#'               string = "string",
#'               set = list(
#'                 list()
#'               ),
#'               record = list(
#'                 list()
#'               ),
#'               ipaddr = "string",
#'               decimal = "string",
#'               datetime = "string",
#'               duration = "string"
#'             )
#'           ),
#'           cedarJson = "string"
#'         )
#'       ),
#'       decision = "ALLOW"|"DENY",
#'       determiningPolicies = list(
#'         list(
#'           policyId = "string"
#'         )
#'       ),
#'       errors = list(
#'         list(
#'           errorDescription = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_is_authorized_with_token(
#'   policyStoreId = "string",
#'   identityToken = "string",
#'   accessToken = "string",
#'   entities = list(
#'     entityList = list(
#'       list(
#'         identifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         attributes = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         parents = list(
#'           list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         ),
#'         tags = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         )
#'       )
#'     ),
#'     cedarJson = "string"
#'   ),
#'   requests = list(
#'     list(
#'       action = list(
#'         actionType = "string",
#'         actionId = "string"
#'       ),
#'       resource = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       context = list(
#'         contextMap = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         cedarJson = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_batch_is_authorized_with_token
#'
#' @aliases verifiedpermissions_batch_is_authorized_with_token
verifiedpermissions_batch_is_authorized_with_token <- function(policyStoreId, identityToken = NULL, accessToken = NULL, entities = NULL, requests) {
  op <- new_operation(
    name = "BatchIsAuthorizedWithToken",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$batch_is_authorized_with_token_input(policyStoreId = policyStoreId, identityToken = identityToken, accessToken = accessToken, entities = entities, requests = requests)
  output <- .verifiedpermissions$batch_is_authorized_with_token_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$batch_is_authorized_with_token <- verifiedpermissions_batch_is_authorized_with_token

#' Adds an identity source to a policy store–an Amazon Cognito user pool or
#' OpenID Connect (OIDC) identity provider (IdP)
#'
#' @description
#' Adds an identity source to a policy store–an Amazon Cognito user pool or
#' OpenID Connect (OIDC) identity provider (IdP).
#' 
#' After you create an identity source, you can use the identities provided
#' by the IdP as proxies for the principal in authorization queries that
#' use the
#' [`is_authorized_with_token`][verifiedpermissions_is_authorized_with_token]
#' or
#' [`batch_is_authorized_with_token`][verifiedpermissions_batch_is_authorized_with_token]
#' API operations. These identities take the form of tokens that contain
#' claims about the user, such as IDs, attributes and group memberships.
#' Identity sources provide identity (ID) tokens and access tokens.
#' Verified Permissions derives information about your user and session
#' from token claims. Access tokens provide action `context` to your
#' policies, and ID tokens provide principal `Attributes`.
#' 
#' Tokens from an identity source user continue to be usable until they
#' expire. Token revocation and resource deletion have no effect on the
#' validity of a token in your policy store
#' 
#' To reference a user from this identity source in your Cedar policies,
#' refer to the following syntax examples.
#' 
#' -   Amazon Cognito user pool:
#'     `Namespace::[Entity type]::[User pool ID]|[user principal attribute]`,
#'     for example
#'     `MyCorp::User::us-east-1_EXAMPLE|a1b2c3d4-5678-90ab-cdef-EXAMPLE11111`.
#' 
#' -   OpenID Connect (OIDC) provider:
#'     `Namespace::[Entity type]::[entityIdPrefix]|[user principal attribute]`,
#'     for example
#'     `MyCorp::User::MyOIDCProvider|a1b2c3d4-5678-90ab-cdef-EXAMPLE22222`.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_create_identity_source(clientToken, policyStoreId,
#'   configuration, principalEntityType)
#'
#' @param clientToken Specifies a unique, case-sensitive ID that you provide to ensure the
#' idempotency of the request. This lets you safely retry the request
#' without accidentally performing the same operation a second time.
#' Passing the same value to a later call to an operation requires that you
#' also pass the same value for all other parameters. We recommend that you
#' use a [UUID type of
#' value.](https://en.wikipedia.org/wiki/Universally_unique_identifier).
#' 
#' If you don't provide this value, then Amazon Web Services generates a
#' random one for you.
#' 
#' If you retry the operation with the same `ClientToken`, but with
#' different parameters, the retry fails with an `ConflictException` error.
#' 
#' Verified Permissions recognizes a `ClientToken` for eight hours. After
#' eight hours, the next request with the same parameters performs the
#' operation again regardless of the value of `ClientToken`.
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store in which you want to store this
#' identity source. Only policies and requests made using this policy store
#' can reference identities from the identity provider configured in the
#' new identity source.
#' @param configuration &#91;required&#93; Specifies the details required to communicate with the identity provider
#' (IdP) associated with this identity source.
#' @param principalEntityType Specifies the namespace and data type of the principals generated for
#' identities authenticated by the new identity source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   identitySourceId = "string",
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   policyStoreId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_identity_source(
#'   clientToken = "string",
#'   policyStoreId = "string",
#'   configuration = list(
#'     cognitoUserPoolConfiguration = list(
#'       userPoolArn = "string",
#'       clientIds = list(
#'         "string"
#'       ),
#'       groupConfiguration = list(
#'         groupEntityType = "string"
#'       )
#'     ),
#'     openIdConnectConfiguration = list(
#'       issuer = "string",
#'       entityIdPrefix = "string",
#'       groupConfiguration = list(
#'         groupClaim = "string",
#'         groupEntityType = "string"
#'       ),
#'       tokenSelection = list(
#'         accessTokenOnly = list(
#'           principalIdClaim = "string",
#'           audiences = list(
#'             "string"
#'           )
#'         ),
#'         identityTokenOnly = list(
#'           principalIdClaim = "string",
#'           clientIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   principalEntityType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_create_identity_source
#'
#' @aliases verifiedpermissions_create_identity_source
verifiedpermissions_create_identity_source <- function(clientToken = NULL, policyStoreId, configuration, principalEntityType = NULL) {
  op <- new_operation(
    name = "CreateIdentitySource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$create_identity_source_input(clientToken = clientToken, policyStoreId = policyStoreId, configuration = configuration, principalEntityType = principalEntityType)
  output <- .verifiedpermissions$create_identity_source_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$create_identity_source <- verifiedpermissions_create_identity_source

#' Creates a Cedar policy and saves it in the specified policy store
#'
#' @description
#' Creates a Cedar policy and saves it in the specified policy store. You
#' can create either a static policy or a policy linked to a policy
#' template.
#' 
#' -   To create a static policy, provide the Cedar policy text in the
#'     `StaticPolicy` section of the `PolicyDefinition`.
#' 
#' -   To create a policy that is dynamically linked to a policy template,
#'     specify the policy template ID and the principal and resource to
#'     associate with this policy in the `templateLinked` section of the
#'     `PolicyDefinition`. If the policy template is ever updated, any
#'     policies linked to the policy template automatically use the updated
#'     template.
#' 
#' Creating a policy causes it to be validated against the schema in the
#' policy store. If the policy doesn't pass validation, the operation fails
#' and the policy isn't stored.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_create_policy(clientToken, policyStoreId,
#'   definition)
#'
#' @param clientToken Specifies a unique, case-sensitive ID that you provide to ensure the
#' idempotency of the request. This lets you safely retry the request
#' without accidentally performing the same operation a second time.
#' Passing the same value to a later call to an operation requires that you
#' also pass the same value for all other parameters. We recommend that you
#' use a [UUID type of
#' value.](https://en.wikipedia.org/wiki/Universally_unique_identifier).
#' 
#' If you don't provide this value, then Amazon Web Services generates a
#' random one for you.
#' 
#' If you retry the operation with the same `ClientToken`, but with
#' different parameters, the retry fails with an `ConflictException` error.
#' 
#' Verified Permissions recognizes a `ClientToken` for eight hours. After
#' eight hours, the next request with the same parameters performs the
#' operation again regardless of the value of `ClientToken`.
#' @param policyStoreId &#91;required&#93; Specifies the `PolicyStoreId` of the policy store you want to store the
#' policy in.
#' @param definition &#91;required&#93; A structure that specifies the policy type and content to use for the
#' new policy. You must include either a static or a templateLinked
#' element. The policy content must be written in the Cedar policy
#' language.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyId = "string",
#'   policyType = "STATIC"|"TEMPLATE_LINKED",
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   resource = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   actions = list(
#'     list(
#'       actionType = "string",
#'       actionId = "string"
#'     )
#'   ),
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   effect = "Permit"|"Forbid"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_policy(
#'   clientToken = "string",
#'   policyStoreId = "string",
#'   definition = list(
#'     static = list(
#'       description = "string",
#'       statement = "string"
#'     ),
#'     templateLinked = list(
#'       policyTemplateId = "string",
#'       principal = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       resource = list(
#'         entityType = "string",
#'         entityId = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_create_policy
#'
#' @aliases verifiedpermissions_create_policy
verifiedpermissions_create_policy <- function(clientToken = NULL, policyStoreId, definition) {
  op <- new_operation(
    name = "CreatePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$create_policy_input(clientToken = clientToken, policyStoreId = policyStoreId, definition = definition)
  output <- .verifiedpermissions$create_policy_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$create_policy <- verifiedpermissions_create_policy

#' Creates a policy store
#'
#' @description
#' Creates a policy store. A policy store is a container for policy
#' resources.
#' 
#' Although [Cedar supports multiple
#' namespaces](https://docs.cedarpolicy.com/schema/schema.html#namespace),
#' Verified Permissions currently supports only one namespace per policy
#' store.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_create_policy_store(clientToken, validationSettings,
#'   description, deletionProtection, tags)
#'
#' @param clientToken Specifies a unique, case-sensitive ID that you provide to ensure the
#' idempotency of the request. This lets you safely retry the request
#' without accidentally performing the same operation a second time.
#' Passing the same value to a later call to an operation requires that you
#' also pass the same value for all other parameters. We recommend that you
#' use a [UUID type of
#' value.](https://en.wikipedia.org/wiki/Universally_unique_identifier).
#' 
#' If you don't provide this value, then Amazon Web Services generates a
#' random one for you.
#' 
#' If you retry the operation with the same `ClientToken`, but with
#' different parameters, the retry fails with an `ConflictException` error.
#' 
#' Verified Permissions recognizes a `ClientToken` for eight hours. After
#' eight hours, the next request with the same parameters performs the
#' operation again regardless of the value of `ClientToken`.
#' @param validationSettings &#91;required&#93; Specifies the validation setting for this policy store.
#' 
#' Currently, the only valid and required value is `Mode`.
#' 
#' We recommend that you turn on `STRICT` mode only after you define a
#' schema. If a schema doesn't exist, then `STRICT` mode causes any policy
#' to fail validation, and Verified Permissions rejects the policy. You can
#' turn off validation by using the
#' [`update_policy_store`][verifiedpermissions_update_policy_store]. Then,
#' when you have a schema defined, use
#' [`update_policy_store`][verifiedpermissions_update_policy_store] again
#' to turn validation back on.
#' @param description Descriptive text that you can provide to help with identification of the
#' current policy store.
#' @param deletionProtection Specifies whether the policy store can be deleted. If enabled, the
#' policy store can't be deleted.
#' 
#' The default state is `DISABLED`.
#' @param tags The list of key-value pairs to associate with the policy store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   arn = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_policy_store(
#'   clientToken = "string",
#'   validationSettings = list(
#'     mode = "OFF"|"STRICT"
#'   ),
#'   description = "string",
#'   deletionProtection = "ENABLED"|"DISABLED",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_create_policy_store
#'
#' @aliases verifiedpermissions_create_policy_store
verifiedpermissions_create_policy_store <- function(clientToken = NULL, validationSettings, description = NULL, deletionProtection = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreatePolicyStore",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$create_policy_store_input(clientToken = clientToken, validationSettings = validationSettings, description = description, deletionProtection = deletionProtection, tags = tags)
  output <- .verifiedpermissions$create_policy_store_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$create_policy_store <- verifiedpermissions_create_policy_store

#' Creates a policy template
#'
#' @description
#' Creates a policy template. A template can use placeholders for the
#' principal and resource. A template must be instantiated into a policy by
#' associating it with specific principals and resources to use for the
#' placeholders. That instantiated policy can then be considered in
#' authorization decisions. The instantiated policy works identically to
#' any other policy, except that it is dynamically linked to the template.
#' If the template changes, then any policies that are linked to that
#' template are immediately updated as well.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_create_policy_template(clientToken, policyStoreId,
#'   description, statement)
#'
#' @param clientToken Specifies a unique, case-sensitive ID that you provide to ensure the
#' idempotency of the request. This lets you safely retry the request
#' without accidentally performing the same operation a second time.
#' Passing the same value to a later call to an operation requires that you
#' also pass the same value for all other parameters. We recommend that you
#' use a [UUID type of
#' value.](https://en.wikipedia.org/wiki/Universally_unique_identifier).
#' 
#' If you don't provide this value, then Amazon Web Services generates a
#' random one for you.
#' 
#' If you retry the operation with the same `ClientToken`, but with
#' different parameters, the retry fails with an `ConflictException` error.
#' 
#' Verified Permissions recognizes a `ClientToken` for eight hours. After
#' eight hours, the next request with the same parameters performs the
#' operation again regardless of the value of `ClientToken`.
#' @param policyStoreId &#91;required&#93; The ID of the policy store in which to create the policy template.
#' @param description Specifies a description for the policy template.
#' @param statement &#91;required&#93; Specifies the content that you want to use for the new policy template,
#' written in the Cedar policy language.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyTemplateId = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_policy_template(
#'   clientToken = "string",
#'   policyStoreId = "string",
#'   description = "string",
#'   statement = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_create_policy_template
#'
#' @aliases verifiedpermissions_create_policy_template
verifiedpermissions_create_policy_template <- function(clientToken = NULL, policyStoreId, description = NULL, statement) {
  op <- new_operation(
    name = "CreatePolicyTemplate",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$create_policy_template_input(clientToken = clientToken, policyStoreId = policyStoreId, description = description, statement = statement)
  output <- .verifiedpermissions$create_policy_template_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$create_policy_template <- verifiedpermissions_create_policy_template

#' Deletes an identity source that references an identity provider (IdP)
#' such as Amazon Cognito
#'
#' @description
#' Deletes an identity source that references an identity provider (IdP)
#' such as Amazon Cognito. After you delete the identity source, you can no
#' longer use tokens for identities from that identity source to represent
#' principals in authorization queries made using
#' [`is_authorized_with_token`][verifiedpermissions_is_authorized_with_token].
#' operations.
#'
#' @usage
#' verifiedpermissions_delete_identity_source(policyStoreId,
#'   identitySourceId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the identity source
#' that you want to delete.
#' @param identitySourceId &#91;required&#93; Specifies the ID of the identity source that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_identity_source(
#'   policyStoreId = "string",
#'   identitySourceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_delete_identity_source
#'
#' @aliases verifiedpermissions_delete_identity_source
verifiedpermissions_delete_identity_source <- function(policyStoreId, identitySourceId) {
  op <- new_operation(
    name = "DeleteIdentitySource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$delete_identity_source_input(policyStoreId = policyStoreId, identitySourceId = identitySourceId)
  output <- .verifiedpermissions$delete_identity_source_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$delete_identity_source <- verifiedpermissions_delete_identity_source

#' Deletes the specified policy from the policy store
#'
#' @description
#' Deletes the specified policy from the policy store.
#' 
#' This operation is idempotent; if you specify a policy that doesn't
#' exist, the request response returns a successful `HTTP 200` status code.
#'
#' @usage
#' verifiedpermissions_delete_policy(policyStoreId, policyId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy that you
#' want to delete.
#' @param policyId &#91;required&#93; Specifies the ID of the policy that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy(
#'   policyStoreId = "string",
#'   policyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_delete_policy
#'
#' @aliases verifiedpermissions_delete_policy
verifiedpermissions_delete_policy <- function(policyStoreId, policyId) {
  op <- new_operation(
    name = "DeletePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$delete_policy_input(policyStoreId = policyStoreId, policyId = policyId)
  output <- .verifiedpermissions$delete_policy_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$delete_policy <- verifiedpermissions_delete_policy

#' Deletes the specified policy store
#'
#' @description
#' Deletes the specified policy store.
#' 
#' This operation is idempotent. If you specify a policy store that does
#' not exist, the request response will still return a successful HTTP 200
#' status code.
#'
#' @usage
#' verifiedpermissions_delete_policy_store(policyStoreId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy_store(
#'   policyStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_delete_policy_store
#'
#' @aliases verifiedpermissions_delete_policy_store
verifiedpermissions_delete_policy_store <- function(policyStoreId) {
  op <- new_operation(
    name = "DeletePolicyStore",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$delete_policy_store_input(policyStoreId = policyStoreId)
  output <- .verifiedpermissions$delete_policy_store_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$delete_policy_store <- verifiedpermissions_delete_policy_store

#' Deletes the specified policy template from the policy store
#'
#' @description
#' Deletes the specified policy template from the policy store.
#' 
#' This operation also deletes any policies that were created from the
#' specified policy template. Those policies are immediately removed from
#' all future API responses, and are asynchronously deleted from the policy
#' store.
#'
#' @usage
#' verifiedpermissions_delete_policy_template(policyStoreId,
#'   policyTemplateId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy template
#' that you want to delete.
#' @param policyTemplateId &#91;required&#93; Specifies the ID of the policy template that you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy_template(
#'   policyStoreId = "string",
#'   policyTemplateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_delete_policy_template
#'
#' @aliases verifiedpermissions_delete_policy_template
verifiedpermissions_delete_policy_template <- function(policyStoreId, policyTemplateId) {
  op <- new_operation(
    name = "DeletePolicyTemplate",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$delete_policy_template_input(policyStoreId = policyStoreId, policyTemplateId = policyTemplateId)
  output <- .verifiedpermissions$delete_policy_template_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$delete_policy_template <- verifiedpermissions_delete_policy_template

#' Retrieves the details about the specified identity source
#'
#' @description
#' Retrieves the details about the specified identity source.
#'
#' @usage
#' verifiedpermissions_get_identity_source(policyStoreId, identitySourceId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the identity source
#' you want information about.
#' @param identitySourceId &#91;required&#93; Specifies the ID of the identity source you want information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   details = list(
#'     clientIds = list(
#'       "string"
#'     ),
#'     userPoolArn = "string",
#'     discoveryUrl = "string",
#'     openIdIssuer = "COGNITO"
#'   ),
#'   identitySourceId = "string",
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   policyStoreId = "string",
#'   principalEntityType = "string",
#'   configuration = list(
#'     cognitoUserPoolConfiguration = list(
#'       userPoolArn = "string",
#'       clientIds = list(
#'         "string"
#'       ),
#'       issuer = "string",
#'       groupConfiguration = list(
#'         groupEntityType = "string"
#'       )
#'     ),
#'     openIdConnectConfiguration = list(
#'       issuer = "string",
#'       entityIdPrefix = "string",
#'       groupConfiguration = list(
#'         groupClaim = "string",
#'         groupEntityType = "string"
#'       ),
#'       tokenSelection = list(
#'         accessTokenOnly = list(
#'           principalIdClaim = "string",
#'           audiences = list(
#'             "string"
#'           )
#'         ),
#'         identityTokenOnly = list(
#'           principalIdClaim = "string",
#'           clientIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_identity_source(
#'   policyStoreId = "string",
#'   identitySourceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_get_identity_source
#'
#' @aliases verifiedpermissions_get_identity_source
verifiedpermissions_get_identity_source <- function(policyStoreId, identitySourceId) {
  op <- new_operation(
    name = "GetIdentitySource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$get_identity_source_input(policyStoreId = policyStoreId, identitySourceId = identitySourceId)
  output <- .verifiedpermissions$get_identity_source_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$get_identity_source <- verifiedpermissions_get_identity_source

#' Retrieves information about the specified policy
#'
#' @description
#' Retrieves information about the specified policy.
#'
#' @usage
#' verifiedpermissions_get_policy(policyStoreId, policyId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy that you
#' want information about.
#' @param policyId &#91;required&#93; Specifies the ID of the policy you want information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyId = "string",
#'   policyType = "STATIC"|"TEMPLATE_LINKED",
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   resource = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   actions = list(
#'     list(
#'       actionType = "string",
#'       actionId = "string"
#'     )
#'   ),
#'   definition = list(
#'     static = list(
#'       description = "string",
#'       statement = "string"
#'     ),
#'     templateLinked = list(
#'       policyTemplateId = "string",
#'       principal = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       resource = list(
#'         entityType = "string",
#'         entityId = "string"
#'       )
#'     )
#'   ),
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   effect = "Permit"|"Forbid"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_policy(
#'   policyStoreId = "string",
#'   policyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_get_policy
#'
#' @aliases verifiedpermissions_get_policy
verifiedpermissions_get_policy <- function(policyStoreId, policyId) {
  op <- new_operation(
    name = "GetPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$get_policy_input(policyStoreId = policyStoreId, policyId = policyId)
  output <- .verifiedpermissions$get_policy_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$get_policy <- verifiedpermissions_get_policy

#' Retrieves details about a policy store
#'
#' @description
#' Retrieves details about a policy store.
#'
#' @usage
#' verifiedpermissions_get_policy_store(policyStoreId, tags)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that you want information about.
#' @param tags Specifies whether to return the tags that are attached to the policy
#' store. If this parameter is included in the API call, the tags are
#' returned, otherwise they are not returned.
#' 
#' If this parameter is included in the API call but there are no tags
#' attached to the policy store, the `tags` response parameter is omitted
#' from the response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   arn = "string",
#'   validationSettings = list(
#'     mode = "OFF"|"STRICT"
#'   ),
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   description = "string",
#'   deletionProtection = "ENABLED"|"DISABLED",
#'   cedarVersion = "CEDAR_2"|"CEDAR_4",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_policy_store(
#'   policyStoreId = "string",
#'   tags = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_get_policy_store
#'
#' @aliases verifiedpermissions_get_policy_store
verifiedpermissions_get_policy_store <- function(policyStoreId, tags = NULL) {
  op <- new_operation(
    name = "GetPolicyStore",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$get_policy_store_input(policyStoreId = policyStoreId, tags = tags)
  output <- .verifiedpermissions$get_policy_store_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$get_policy_store <- verifiedpermissions_get_policy_store

#' Retrieve the details for the specified policy template in the specified
#' policy store
#'
#' @description
#' Retrieve the details for the specified policy template in the specified
#' policy store.
#'
#' @usage
#' verifiedpermissions_get_policy_template(policyStoreId, policyTemplateId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy template
#' that you want information about.
#' @param policyTemplateId &#91;required&#93; Specifies the ID of the policy template that you want information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyTemplateId = "string",
#'   description = "string",
#'   statement = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_policy_template(
#'   policyStoreId = "string",
#'   policyTemplateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_get_policy_template
#'
#' @aliases verifiedpermissions_get_policy_template
verifiedpermissions_get_policy_template <- function(policyStoreId, policyTemplateId) {
  op <- new_operation(
    name = "GetPolicyTemplate",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$get_policy_template_input(policyStoreId = policyStoreId, policyTemplateId = policyTemplateId)
  output <- .verifiedpermissions$get_policy_template_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$get_policy_template <- verifiedpermissions_get_policy_template

#' Retrieve the details for the specified schema in the specified policy
#' store
#'
#' @description
#' Retrieve the details for the specified schema in the specified policy
#' store.
#'
#' @usage
#' verifiedpermissions_get_schema(policyStoreId)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the schema.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   schema = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   namespaces = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_schema(
#'   policyStoreId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_get_schema
#'
#' @aliases verifiedpermissions_get_schema
verifiedpermissions_get_schema <- function(policyStoreId) {
  op <- new_operation(
    name = "GetSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$get_schema_input(policyStoreId = policyStoreId)
  output <- .verifiedpermissions$get_schema_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$get_schema <- verifiedpermissions_get_schema

#' Makes an authorization decision about a service request described in the
#' parameters
#'
#' @description
#' Makes an authorization decision about a service request described in the
#' parameters. The information in the parameters can also define additional
#' context that Verified Permissions can include in the evaluation. The
#' request is evaluated against all matching policies in the specified
#' policy store. The result of the decision is either `Allow` or `Deny`,
#' along with a list of the policies that resulted in the decision.
#'
#' @usage
#' verifiedpermissions_is_authorized(policyStoreId, principal, action,
#'   resource, context, entities)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store. Policies in this policy store will
#' be used to make an authorization decision for the input.
#' @param principal Specifies the principal for which the authorization decision is to be
#' made.
#' @param action Specifies the requested action to be authorized. For example, is the
#' principal authorized to perform this action on the resource?
#' @param resource Specifies the resource for which the authorization decision is to be
#' made.
#' @param context Specifies additional context that can be used to make more granular
#' authorization decisions.
#' @param entities (Optional) Specifies the list of resources and principals and their
#' associated attributes that Verified Permissions can examine when
#' evaluating the policies. These additional entities and their attributes
#' can be referenced and checked by conditional elements in the policies in
#' the specified policy store.
#' 
#' You can include only principal and resource entities in this parameter;
#' you can't include actions. You must specify actions in the schema.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   decision = "ALLOW"|"DENY",
#'   determiningPolicies = list(
#'     list(
#'       policyId = "string"
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       errorDescription = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$is_authorized(
#'   policyStoreId = "string",
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   action = list(
#'     actionType = "string",
#'     actionId = "string"
#'   ),
#'   resource = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   context = list(
#'     contextMap = list(
#'       list(
#'         boolean = TRUE|FALSE,
#'         entityIdentifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         long = 123,
#'         string = "string",
#'         set = list(
#'           list()
#'         ),
#'         record = list(
#'           list()
#'         ),
#'         ipaddr = "string",
#'         decimal = "string",
#'         datetime = "string",
#'         duration = "string"
#'       )
#'     ),
#'     cedarJson = "string"
#'   ),
#'   entities = list(
#'     entityList = list(
#'       list(
#'         identifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         attributes = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         parents = list(
#'           list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         ),
#'         tags = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         )
#'       )
#'     ),
#'     cedarJson = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_is_authorized
#'
#' @aliases verifiedpermissions_is_authorized
verifiedpermissions_is_authorized <- function(policyStoreId, principal = NULL, action = NULL, resource = NULL, context = NULL, entities = NULL) {
  op <- new_operation(
    name = "IsAuthorized",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$is_authorized_input(policyStoreId = policyStoreId, principal = principal, action = action, resource = resource, context = context, entities = entities)
  output <- .verifiedpermissions$is_authorized_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$is_authorized <- verifiedpermissions_is_authorized

#' Makes an authorization decision about a service request described in the
#' parameters
#'
#' @description
#' Makes an authorization decision about a service request described in the
#' parameters. The principal in this request comes from an external
#' identity source in the form of an identity token formatted as a [JSON
#' web token (JWT)](https://en.wikipedia.org/wiki/JSON_Web_Token). The
#' information in the parameters can also define additional context that
#' Verified Permissions can include in the evaluation. The request is
#' evaluated against all matching policies in the specified policy store.
#' The result of the decision is either `Allow` or `Deny`, along with a
#' list of the policies that resulted in the decision.
#' 
#' Verified Permissions validates each token that is specified in a request
#' by checking its expiration date and its signature.
#' 
#' Tokens from an identity source user continue to be usable until they
#' expire. Token revocation and resource deletion have no effect on the
#' validity of a token in your policy store
#'
#' @usage
#' verifiedpermissions_is_authorized_with_token(policyStoreId,
#'   identityToken, accessToken, action, resource, context, entities)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store. Policies in this policy store will
#' be used to make an authorization decision for the input.
#' @param identityToken Specifies an identity token for the principal to be authorized. This
#' token is provided to you by the identity provider (IdP) associated with
#' the specified identity source. You must specify either an `accessToken`,
#' an `identityToken`, or both.
#' 
#' Must be an ID token. Verified Permissions returns an error if the
#' `token_use` claim in the submitted token isn't `id`.
#' @param accessToken Specifies an access token for the principal to be authorized. This token
#' is provided to you by the identity provider (IdP) associated with the
#' specified identity source. You must specify either an `accessToken`, an
#' `identityToken`, or both.
#' 
#' Must be an access token. Verified Permissions returns an error if the
#' `token_use` claim in the submitted token isn't `access`.
#' @param action Specifies the requested action to be authorized. Is the specified
#' principal authorized to perform this action on the specified resource.
#' @param resource Specifies the resource for which the authorization decision is made. For
#' example, is the principal allowed to perform the action on the resource?
#' @param context Specifies additional context that can be used to make more granular
#' authorization decisions.
#' @param entities (Optional) Specifies the list of resources and their associated
#' attributes that Verified Permissions can examine when evaluating the
#' policies. These additional entities and their attributes can be
#' referenced and checked by conditional elements in the policies in the
#' specified policy store.
#' 
#' You can't include principals in this parameter, only resource and action
#' entities. This parameter can't include any entities of a type that
#' matches the user or group entity types that you defined in your identity
#' source.
#' 
#' -   The
#'     [`is_authorized_with_token`][verifiedpermissions_is_authorized_with_token]
#'     operation takes principal attributes from ***only*** the
#'     `identityToken` or `accessToken` passed to the operation.
#' 
#' -   For action entities, you can include only their `Identifier` and
#'     `EntityType`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   decision = "ALLOW"|"DENY",
#'   determiningPolicies = list(
#'     list(
#'       policyId = "string"
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       errorDescription = "string"
#'     )
#'   ),
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$is_authorized_with_token(
#'   policyStoreId = "string",
#'   identityToken = "string",
#'   accessToken = "string",
#'   action = list(
#'     actionType = "string",
#'     actionId = "string"
#'   ),
#'   resource = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   context = list(
#'     contextMap = list(
#'       list(
#'         boolean = TRUE|FALSE,
#'         entityIdentifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         long = 123,
#'         string = "string",
#'         set = list(
#'           list()
#'         ),
#'         record = list(
#'           list()
#'         ),
#'         ipaddr = "string",
#'         decimal = "string",
#'         datetime = "string",
#'         duration = "string"
#'       )
#'     ),
#'     cedarJson = "string"
#'   ),
#'   entities = list(
#'     entityList = list(
#'       list(
#'         identifier = list(
#'           entityType = "string",
#'           entityId = "string"
#'         ),
#'         attributes = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         ),
#'         parents = list(
#'           list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         ),
#'         tags = list(
#'           list(
#'             boolean = TRUE|FALSE,
#'             entityIdentifier = list(
#'               entityType = "string",
#'               entityId = "string"
#'             ),
#'             long = 123,
#'             string = "string",
#'             set = list(
#'               list()
#'             ),
#'             record = list(
#'               list()
#'             ),
#'             ipaddr = "string",
#'             decimal = "string",
#'             datetime = "string",
#'             duration = "string"
#'           )
#'         )
#'       )
#'     ),
#'     cedarJson = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_is_authorized_with_token
#'
#' @aliases verifiedpermissions_is_authorized_with_token
verifiedpermissions_is_authorized_with_token <- function(policyStoreId, identityToken = NULL, accessToken = NULL, action = NULL, resource = NULL, context = NULL, entities = NULL) {
  op <- new_operation(
    name = "IsAuthorizedWithToken",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$is_authorized_with_token_input(policyStoreId = policyStoreId, identityToken = identityToken, accessToken = accessToken, action = action, resource = resource, context = context, entities = entities)
  output <- .verifiedpermissions$is_authorized_with_token_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$is_authorized_with_token <- verifiedpermissions_is_authorized_with_token

#' Returns a paginated list of all of the identity sources defined in the
#' specified policy store
#'
#' @description
#' Returns a paginated list of all of the identity sources defined in the
#' specified policy store.
#'
#' @usage
#' verifiedpermissions_list_identity_sources(policyStoreId, nextToken,
#'   maxResults, filters)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the identity sources
#' that you want to list.
#' @param nextToken Specifies that you want to receive the next page of results. Valid only
#' if you received a `NextToken` response in the previous request. If you
#' did, it indicates that more output is available. Set this parameter to
#' the value provided by the previous call's `NextToken` response to
#' request the next page of results.
#' @param maxResults Specifies the total number of results that you want included in each
#' response. If additional items exist beyond the number you specify, the
#' `NextToken` response element is returned with a value (not null).
#' Include the specified value as the `NextToken` request parameter in the
#' next call to the operation to get the next set of results. Note that the
#' service might return fewer results than the maximum even when there are
#' more results available. You should check `NextToken` after every
#' operation to ensure that you receive all of the results.
#' 
#' If you do not specify this parameter, the operation defaults to 10
#' identity sources per response. You can specify a maximum of 50 identity
#' sources per response.
#' @param filters Specifies characteristics of an identity source that you can use to
#' limit the output to matching identity sources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   identitySources = list(
#'     list(
#'       createdDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       details = list(
#'         clientIds = list(
#'           "string"
#'         ),
#'         userPoolArn = "string",
#'         discoveryUrl = "string",
#'         openIdIssuer = "COGNITO"
#'       ),
#'       identitySourceId = "string",
#'       lastUpdatedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       policyStoreId = "string",
#'       principalEntityType = "string",
#'       configuration = list(
#'         cognitoUserPoolConfiguration = list(
#'           userPoolArn = "string",
#'           clientIds = list(
#'             "string"
#'           ),
#'           issuer = "string",
#'           groupConfiguration = list(
#'             groupEntityType = "string"
#'           )
#'         ),
#'         openIdConnectConfiguration = list(
#'           issuer = "string",
#'           entityIdPrefix = "string",
#'           groupConfiguration = list(
#'             groupClaim = "string",
#'             groupEntityType = "string"
#'           ),
#'           tokenSelection = list(
#'             accessTokenOnly = list(
#'               principalIdClaim = "string",
#'               audiences = list(
#'                 "string"
#'               )
#'             ),
#'             identityTokenOnly = list(
#'               principalIdClaim = "string",
#'               clientIds = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_identity_sources(
#'   policyStoreId = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   filters = list(
#'     list(
#'       principalEntityType = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_list_identity_sources
#'
#' @aliases verifiedpermissions_list_identity_sources
verifiedpermissions_list_identity_sources <- function(policyStoreId, nextToken = NULL, maxResults = NULL, filters = NULL) {
  op <- new_operation(
    name = "ListIdentitySources",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "identitySources"),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$list_identity_sources_input(policyStoreId = policyStoreId, nextToken = nextToken, maxResults = maxResults, filters = filters)
  output <- .verifiedpermissions$list_identity_sources_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$list_identity_sources <- verifiedpermissions_list_identity_sources

#' Returns a paginated list of all policies stored in the specified policy
#' store
#'
#' @description
#' Returns a paginated list of all policies stored in the specified policy
#' store.
#'
#' @usage
#' verifiedpermissions_list_policies(policyStoreId, nextToken, maxResults,
#'   filter)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store you want to list policies from.
#' @param nextToken Specifies that you want to receive the next page of results. Valid only
#' if you received a `NextToken` response in the previous request. If you
#' did, it indicates that more output is available. Set this parameter to
#' the value provided by the previous call's `NextToken` response to
#' request the next page of results.
#' @param maxResults Specifies the total number of results that you want included in each
#' response. If additional items exist beyond the number you specify, the
#' `NextToken` response element is returned with a value (not null).
#' Include the specified value as the `NextToken` request parameter in the
#' next call to the operation to get the next set of results. Note that the
#' service might return fewer results than the maximum even when there are
#' more results available. You should check `NextToken` after every
#' operation to ensure that you receive all of the results.
#' 
#' If you do not specify this parameter, the operation defaults to 10
#' policies per response. You can specify a maximum of 50 policies per
#' response.
#' @param filter Specifies a filter that limits the response to only policies that match
#' the specified criteria. For example, you list only the policies that
#' reference a specified principal.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   policies = list(
#'     list(
#'       policyStoreId = "string",
#'       policyId = "string",
#'       policyType = "STATIC"|"TEMPLATE_LINKED",
#'       principal = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       resource = list(
#'         entityType = "string",
#'         entityId = "string"
#'       ),
#'       actions = list(
#'         list(
#'           actionType = "string",
#'           actionId = "string"
#'         )
#'       ),
#'       definition = list(
#'         static = list(
#'           description = "string"
#'         ),
#'         templateLinked = list(
#'           policyTemplateId = "string",
#'           principal = list(
#'             entityType = "string",
#'             entityId = "string"
#'           ),
#'           resource = list(
#'             entityType = "string",
#'             entityId = "string"
#'           )
#'         )
#'       ),
#'       createdDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       effect = "Permit"|"Forbid"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_policies(
#'   policyStoreId = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   filter = list(
#'     principal = list(
#'       unspecified = TRUE|FALSE,
#'       identifier = list(
#'         entityType = "string",
#'         entityId = "string"
#'       )
#'     ),
#'     resource = list(
#'       unspecified = TRUE|FALSE,
#'       identifier = list(
#'         entityType = "string",
#'         entityId = "string"
#'       )
#'     ),
#'     policyType = "STATIC"|"TEMPLATE_LINKED",
#'     policyTemplateId = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_list_policies
#'
#' @aliases verifiedpermissions_list_policies
verifiedpermissions_list_policies <- function(policyStoreId, nextToken = NULL, maxResults = NULL, filter = NULL) {
  op <- new_operation(
    name = "ListPolicies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "policies"),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$list_policies_input(policyStoreId = policyStoreId, nextToken = nextToken, maxResults = maxResults, filter = filter)
  output <- .verifiedpermissions$list_policies_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$list_policies <- verifiedpermissions_list_policies

#' Returns a paginated list of all policy stores in the calling Amazon Web
#' Services account
#'
#' @description
#' Returns a paginated list of all policy stores in the calling Amazon Web
#' Services account.
#'
#' @usage
#' verifiedpermissions_list_policy_stores(nextToken, maxResults)
#'
#' @param nextToken Specifies that you want to receive the next page of results. Valid only
#' if you received a `NextToken` response in the previous request. If you
#' did, it indicates that more output is available. Set this parameter to
#' the value provided by the previous call's `NextToken` response to
#' request the next page of results.
#' @param maxResults Specifies the total number of results that you want included in each
#' response. If additional items exist beyond the number you specify, the
#' `NextToken` response element is returned with a value (not null).
#' Include the specified value as the `NextToken` request parameter in the
#' next call to the operation to get the next set of results. Note that the
#' service might return fewer results than the maximum even when there are
#' more results available. You should check `NextToken` after every
#' operation to ensure that you receive all of the results.
#' 
#' If you do not specify this parameter, the operation defaults to 10
#' policy stores per response. You can specify a maximum of 50 policy
#' stores per response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   policyStores = list(
#'     list(
#'       policyStoreId = "string",
#'       arn = "string",
#'       createdDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       description = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_stores(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_list_policy_stores
#'
#' @aliases verifiedpermissions_list_policy_stores
verifiedpermissions_list_policy_stores <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListPolicyStores",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "policyStores"),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$list_policy_stores_input(nextToken = nextToken, maxResults = maxResults)
  output <- .verifiedpermissions$list_policy_stores_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$list_policy_stores <- verifiedpermissions_list_policy_stores

#' Returns a paginated list of all policy templates in the specified policy
#' store
#'
#' @description
#' Returns a paginated list of all policy templates in the specified policy
#' store.
#'
#' @usage
#' verifiedpermissions_list_policy_templates(policyStoreId, nextToken,
#'   maxResults)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy templates
#' you want to list.
#' @param nextToken Specifies that you want to receive the next page of results. Valid only
#' if you received a `NextToken` response in the previous request. If you
#' did, it indicates that more output is available. Set this parameter to
#' the value provided by the previous call's `NextToken` response to
#' request the next page of results.
#' @param maxResults Specifies the total number of results that you want included in each
#' response. If additional items exist beyond the number you specify, the
#' `NextToken` response element is returned with a value (not null).
#' Include the specified value as the `NextToken` request parameter in the
#' next call to the operation to get the next set of results. Note that the
#' service might return fewer results than the maximum even when there are
#' more results available. You should check `NextToken` after every
#' operation to ensure that you receive all of the results.
#' 
#' If you do not specify this parameter, the operation defaults to 10
#' policy templates per response. You can specify a maximum of 50 policy
#' templates per response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   policyTemplates = list(
#'     list(
#'       policyStoreId = "string",
#'       policyTemplateId = "string",
#'       description = "string",
#'       createdDate = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedDate = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_templates(
#'   policyStoreId = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_list_policy_templates
#'
#' @aliases verifiedpermissions_list_policy_templates
verifiedpermissions_list_policy_templates <- function(policyStoreId, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListPolicyTemplates",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "policyTemplates"),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$list_policy_templates_input(policyStoreId = policyStoreId, nextToken = nextToken, maxResults = maxResults)
  output <- .verifiedpermissions$list_policy_templates_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$list_policy_templates <- verifiedpermissions_list_policy_templates

#' Returns the tags associated with the specified Amazon Verified
#' Permissions resource
#'
#' @description
#' Returns the tags associated with the specified Amazon Verified
#' Permissions resource. In Verified Permissions, policy stores can be
#' tagged.
#'
#' @usage
#' verifiedpermissions_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource for which you want to view tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_list_tags_for_resource
#'
#' @aliases verifiedpermissions_list_tags_for_resource
verifiedpermissions_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .verifiedpermissions$list_tags_for_resource_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$list_tags_for_resource <- verifiedpermissions_list_tags_for_resource

#' Creates or updates the policy schema in the specified policy store
#'
#' @description
#' Creates or updates the policy schema in the specified policy store. The
#' schema is used to validate any Cedar policies and policy templates
#' submitted to the policy store. Any changes to the schema validate only
#' policies and templates submitted after the schema change. Existing
#' policies and templates are not re-evaluated against the changed schema.
#' If you later update a policy, then it is evaluated against the new
#' schema at that time.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_put_schema(policyStoreId, definition)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store in which to place the schema.
#' @param definition &#91;required&#93; Specifies the definition of the schema to be stored. The schema
#' definition must be written in Cedar schema JSON.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   namespaces = list(
#'     "string"
#'   ),
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_schema(
#'   policyStoreId = "string",
#'   definition = list(
#'     cedarJson = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_put_schema
#'
#' @aliases verifiedpermissions_put_schema
verifiedpermissions_put_schema <- function(policyStoreId, definition) {
  op <- new_operation(
    name = "PutSchema",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$put_schema_input(policyStoreId = policyStoreId, definition = definition)
  output <- .verifiedpermissions$put_schema_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$put_schema <- verifiedpermissions_put_schema

#' Assigns one or more tags (key-value pairs) to the specified Amazon
#' Verified Permissions resource
#'
#' @description
#' Assigns one or more tags (key-value pairs) to the specified Amazon
#' Verified Permissions resource. Tags can help you organize and categorize
#' your resources. You can also use them to scope user permissions by
#' granting a user permission to access or change only resources with
#' certain tag values. In Verified Permissions, policy stores can be
#' tagged.
#' 
#' Tags don't have any semantic meaning to Amazon Web Services and are
#' interpreted strictly as strings of characters.
#' 
#' You can use the TagResource action with a resource that already has
#' tags. If you specify a new tag key, this tag is appended to the list of
#' tags associated with the resource. If you specify a tag key that is
#' already associated with the resource, the new tag value that you specify
#' replaces the previous value for that tag.
#' 
#' You can associate as many as 50 tags with a resource.
#'
#' @usage
#' verifiedpermissions_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource that you're adding tags to.
#' @param tags &#91;required&#93; The list of key-value pairs to associate with the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_tag_resource
#'
#' @aliases verifiedpermissions_tag_resource
verifiedpermissions_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .verifiedpermissions$tag_resource_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$tag_resource <- verifiedpermissions_tag_resource

#' Removes one or more tags from the specified Amazon Verified Permissions
#' resource
#'
#' @description
#' Removes one or more tags from the specified Amazon Verified Permissions
#' resource. In Verified Permissions, policy stores can be tagged.
#'
#' @usage
#' verifiedpermissions_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource from which you are removing tags.
#' @param tagKeys &#91;required&#93; The list of tag keys to remove from the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_untag_resource
#'
#' @aliases verifiedpermissions_untag_resource
verifiedpermissions_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .verifiedpermissions$untag_resource_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$untag_resource <- verifiedpermissions_untag_resource

#' Updates the specified identity source to use a new identity provider
#' (IdP), or to change the mapping of identities from the IdP to a
#' different principal entity type
#'
#' @description
#' Updates the specified identity source to use a new identity provider
#' (IdP), or to change the mapping of identities from the IdP to a
#' different principal entity type.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_update_identity_source(policyStoreId,
#'   identitySourceId, updateConfiguration, principalEntityType)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the identity source
#' that you want to update.
#' @param identitySourceId &#91;required&#93; Specifies the ID of the identity source that you want to update.
#' @param updateConfiguration &#91;required&#93; Specifies the details required to communicate with the identity provider
#' (IdP) associated with this identity source.
#' @param principalEntityType Specifies the data type of principals generated for identities
#' authenticated by the identity source.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   identitySourceId = "string",
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   policyStoreId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_identity_source(
#'   policyStoreId = "string",
#'   identitySourceId = "string",
#'   updateConfiguration = list(
#'     cognitoUserPoolConfiguration = list(
#'       userPoolArn = "string",
#'       clientIds = list(
#'         "string"
#'       ),
#'       groupConfiguration = list(
#'         groupEntityType = "string"
#'       )
#'     ),
#'     openIdConnectConfiguration = list(
#'       issuer = "string",
#'       entityIdPrefix = "string",
#'       groupConfiguration = list(
#'         groupClaim = "string",
#'         groupEntityType = "string"
#'       ),
#'       tokenSelection = list(
#'         accessTokenOnly = list(
#'           principalIdClaim = "string",
#'           audiences = list(
#'             "string"
#'           )
#'         ),
#'         identityTokenOnly = list(
#'           principalIdClaim = "string",
#'           clientIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   principalEntityType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_update_identity_source
#'
#' @aliases verifiedpermissions_update_identity_source
verifiedpermissions_update_identity_source <- function(policyStoreId, identitySourceId, updateConfiguration, principalEntityType = NULL) {
  op <- new_operation(
    name = "UpdateIdentitySource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$update_identity_source_input(policyStoreId = policyStoreId, identitySourceId = identitySourceId, updateConfiguration = updateConfiguration, principalEntityType = principalEntityType)
  output <- .verifiedpermissions$update_identity_source_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$update_identity_source <- verifiedpermissions_update_identity_source

#' Modifies a Cedar static policy in the specified policy store
#'
#' @description
#' Modifies a Cedar static policy in the specified policy store. You can
#' change only certain elements of the
#' [UpdatePolicyDefinition](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/#amazonverifiedpermissions-UpdatePolicy-request-UpdatePolicyDefinition)
#' parameter. You can directly update only static policies. To change a
#' template-linked policy, you must update the template instead, using
#' [`update_policy_template`][verifiedpermissions_update_policy_template].
#' 
#' -   If policy validation is enabled in the policy store, then updating a
#'     static policy causes Verified Permissions to validate the policy
#'     against the schema in the policy store. If the updated static policy
#'     doesn't pass validation, the operation fails and the update isn't
#'     stored.
#' 
#' -   When you edit a static policy, you can change only certain elements
#'     of a static policy:
#' 
#'     -   The action referenced by the policy.
#' 
#'     -   A condition clause, such as when and unless.
#' 
#'     You can't change these elements of a static policy:
#' 
#'     -   Changing a policy from a static policy to a template-linked
#'         policy.
#' 
#'     -   Changing the effect of a static policy from permit or forbid.
#' 
#'     -   The principal referenced by a static policy.
#' 
#'     -   The resource referenced by a static policy.
#' 
#' -   To update a template-linked policy, you must update the template
#'     instead.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_update_policy(policyStoreId, policyId, definition)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy that you
#' want to update.
#' @param policyId &#91;required&#93; Specifies the ID of the policy that you want to update. To find this
#' value, you can use [`list_policies`][verifiedpermissions_list_policies].
#' @param definition &#91;required&#93; Specifies the updated policy content that you want to replace on the
#' specified policy. The content must be valid Cedar policy language text.
#' 
#' You can change only the following elements from the policy definition:
#' 
#' -   The `action` referenced by the policy.
#' 
#' -   Any conditional clauses, such as `when` or `unless` clauses.
#' 
#' You **can't** change the following elements:
#' 
#' -   Changing from `static` to `templateLinked`.
#' 
#' -   Changing the effect of the policy from `permit` or `forbid`.
#' 
#' -   The `principal` referenced by the policy.
#' 
#' -   The `resource` referenced by the policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyId = "string",
#'   policyType = "STATIC"|"TEMPLATE_LINKED",
#'   principal = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   resource = list(
#'     entityType = "string",
#'     entityId = "string"
#'   ),
#'   actions = list(
#'     list(
#'       actionType = "string",
#'       actionId = "string"
#'     )
#'   ),
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   effect = "Permit"|"Forbid"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_policy(
#'   policyStoreId = "string",
#'   policyId = "string",
#'   definition = list(
#'     static = list(
#'       description = "string",
#'       statement = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_update_policy
#'
#' @aliases verifiedpermissions_update_policy
verifiedpermissions_update_policy <- function(policyStoreId, policyId, definition) {
  op <- new_operation(
    name = "UpdatePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$update_policy_input(policyStoreId = policyStoreId, policyId = policyId, definition = definition)
  output <- .verifiedpermissions$update_policy_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$update_policy <- verifiedpermissions_update_policy

#' Modifies the validation setting for a policy store
#'
#' @description
#' Modifies the validation setting for a policy store.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_update_policy_store(policyStoreId,
#'   validationSettings, deletionProtection, description)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that you want to update
#' @param validationSettings &#91;required&#93; A structure that defines the validation settings that want to enable for
#' the policy store.
#' @param deletionProtection Specifies whether the policy store can be deleted. If enabled, the
#' policy store can't be deleted.
#' 
#' When you call
#' [`update_policy_store`][verifiedpermissions_update_policy_store], this
#' parameter is unchanged unless explicitly included in the call.
#' @param description Descriptive text that you can provide to help with identification of the
#' current policy store.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   arn = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_policy_store(
#'   policyStoreId = "string",
#'   validationSettings = list(
#'     mode = "OFF"|"STRICT"
#'   ),
#'   deletionProtection = "ENABLED"|"DISABLED",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_update_policy_store
#'
#' @aliases verifiedpermissions_update_policy_store
verifiedpermissions_update_policy_store <- function(policyStoreId, validationSettings, deletionProtection = NULL, description = NULL) {
  op <- new_operation(
    name = "UpdatePolicyStore",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$update_policy_store_input(policyStoreId = policyStoreId, validationSettings = validationSettings, deletionProtection = deletionProtection, description = description)
  output <- .verifiedpermissions$update_policy_store_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$update_policy_store <- verifiedpermissions_update_policy_store

#' Updates the specified policy template
#'
#' @description
#' Updates the specified policy template. You can update only the
#' description and the some elements of the
#' [policyBody](https://docs.aws.amazon.com/verifiedpermissions/latest/apireference/API_UpdatePolicyTemplate.html#amazonverifiedpermissions-UpdatePolicyTemplate-request-policyBody).
#' 
#' Changes you make to the policy template content are immediately (within
#' the constraints of eventual consistency) reflected in authorization
#' decisions that involve all template-linked policies instantiated from
#' this template.
#' 
#' Verified Permissions is *\href{https://wikipedia.org/wiki/Eventual_consistency}{eventually consistent}* . It can take a few seconds for a new or changed
#' element to propagate through the service and be visible in the results
#' of other Verified Permissions operations.
#'
#' @usage
#' verifiedpermissions_update_policy_template(policyStoreId,
#'   policyTemplateId, description, statement)
#'
#' @param policyStoreId &#91;required&#93; Specifies the ID of the policy store that contains the policy template
#' that you want to update.
#' @param policyTemplateId &#91;required&#93; Specifies the ID of the policy template that you want to update.
#' @param description Specifies a new description to apply to the policy template.
#' @param statement &#91;required&#93; Specifies new statement content written in Cedar policy language to
#' replace the current body of the policy template.
#' 
#' You can change only the following elements of the policy body:
#' 
#' -   The `action` referenced by the policy template.
#' 
#' -   Any conditional clauses, such as `when` or `unless` clauses.
#' 
#' You **can't** change the following elements:
#' 
#' -   The effect (`permit` or `forbid`) of the policy template.
#' 
#' -   The `principal` referenced by the policy template.
#' 
#' -   The `resource` referenced by the policy template.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyStoreId = "string",
#'   policyTemplateId = "string",
#'   createdDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedDate = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_policy_template(
#'   policyStoreId = "string",
#'   policyTemplateId = "string",
#'   description = "string",
#'   statement = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname verifiedpermissions_update_policy_template
#'
#' @aliases verifiedpermissions_update_policy_template
verifiedpermissions_update_policy_template <- function(policyStoreId, policyTemplateId, description = NULL, statement) {
  op <- new_operation(
    name = "UpdatePolicyTemplate",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .verifiedpermissions$update_policy_template_input(policyStoreId = policyStoreId, policyTemplateId = policyTemplateId, description = description, statement = statement)
  output <- .verifiedpermissions$update_policy_template_output()
  config <- get_config()
  svc <- .verifiedpermissions$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.verifiedpermissions$operations$update_policy_template <- verifiedpermissions_update_policy_template

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include ivs_service.R
NULL

#' Performs GetChannel on multiple ARNs simultaneously
#'
#' @description
#' Performs [`get_channel`][ivs_get_channel] on multiple ARNs
#' simultaneously.
#'
#' @usage
#' ivs_batch_get_channel(arns)
#'
#' @param arns &#91;required&#93; Array of ARNs, one per channel.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   channels = list(
#'     list(
#'       arn = "string",
#'       authorized = TRUE|FALSE,
#'       containerFormat = "TS"|"FRAGMENTED_MP4",
#'       ingestEndpoint = "string",
#'       insecureIngest = TRUE|FALSE,
#'       latencyMode = "NORMAL"|"LOW",
#'       multitrackInputConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         maximumResolution = "SD"|"HD"|"FULL_HD",
#'         policy = "ALLOW"|"REQUIRE"
#'       ),
#'       name = "string",
#'       playbackRestrictionPolicyArn = "string",
#'       playbackUrl = "string",
#'       preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'       recordingConfigurationArn = "string",
#'       srt = list(
#'         endpoint = "string",
#'         passphrase = "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'     )
#'   ),
#'   errors = list(
#'     list(
#'       arn = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_channel(
#'   arns = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_batch_get_channel
#'
#' @aliases ivs_batch_get_channel
ivs_batch_get_channel <- function(arns) {
  op <- new_operation(
    name = "BatchGetChannel",
    http_method = "POST",
    http_path = "/BatchGetChannel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$batch_get_channel_input(arns = arns)
  output <- .ivs$batch_get_channel_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$batch_get_channel <- ivs_batch_get_channel

#' Performs GetStreamKey on multiple ARNs simultaneously
#'
#' @description
#' Performs [`get_stream_key`][ivs_get_stream_key] on multiple ARNs
#' simultaneously.
#'
#' @usage
#' ivs_batch_get_stream_key(arns)
#'
#' @param arns &#91;required&#93; Array of ARNs, one per stream key.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       arn = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   ),
#'   streamKeys = list(
#'     list(
#'       arn = "string",
#'       channelArn = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_get_stream_key(
#'   arns = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_batch_get_stream_key
#'
#' @aliases ivs_batch_get_stream_key
ivs_batch_get_stream_key <- function(arns) {
  op <- new_operation(
    name = "BatchGetStreamKey",
    http_method = "POST",
    http_path = "/BatchGetStreamKey",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$batch_get_stream_key_input(arns = arns)
  output <- .ivs$batch_get_stream_key_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$batch_get_stream_key <- ivs_batch_get_stream_key

#' Performs StartViewerSessionRevocation on multiple channel ARN and viewer
#' ID pairs simultaneously
#'
#' @description
#' Performs
#' [`start_viewer_session_revocation`][ivs_start_viewer_session_revocation]
#' on multiple channel ARN and viewer ID pairs simultaneously.
#'
#' @usage
#' ivs_batch_start_viewer_session_revocation(viewerSessions)
#'
#' @param viewerSessions &#91;required&#93; Array of viewer sessions, one per channel-ARN and viewer-ID pair.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       channelArn = "string",
#'       code = "string",
#'       message = "string",
#'       viewerId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_start_viewer_session_revocation(
#'   viewerSessions = list(
#'     list(
#'       channelArn = "string",
#'       viewerId = "string",
#'       viewerSessionVersionsLessThanOrEqualTo = 123
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_batch_start_viewer_session_revocation
#'
#' @aliases ivs_batch_start_viewer_session_revocation
ivs_batch_start_viewer_session_revocation <- function(viewerSessions) {
  op <- new_operation(
    name = "BatchStartViewerSessionRevocation",
    http_method = "POST",
    http_path = "/BatchStartViewerSessionRevocation",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$batch_start_viewer_session_revocation_input(viewerSessions = viewerSessions)
  output <- .ivs$batch_start_viewer_session_revocation_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$batch_start_viewer_session_revocation <- ivs_batch_start_viewer_session_revocation

#' Creates a new channel and an associated stream key to start streaming
#'
#' @description
#' Creates a new channel and an associated stream key to start streaming.
#'
#' @usage
#' ivs_create_channel(authorized, containerFormat, insecureIngest,
#'   latencyMode, multitrackInputConfiguration, name,
#'   playbackRestrictionPolicyArn, preset, recordingConfigurationArn, tags,
#'   type)
#'
#' @param authorized Whether the channel is private (enabled for playback authorization).
#' Default: `false`.
#' @param containerFormat Indicates which content-packaging format is used (MPEG-TS or fMP4). If
#' `multitrackInputConfiguration` is specified and `enabled` is `true`,
#' then `containerFormat` is required and must be set to `FRAGMENTED_MP4`.
#' Otherwise, `containerFormat` may be set to `TS` or `FRAGMENTED_MP4`.
#' Default: `TS`.
#' @param insecureIngest Whether the channel allows insecure RTMP and SRT ingest. Default:
#' `false`.
#' @param latencyMode Channel latency mode. Use `NORMAL` to broadcast and deliver live video
#' up to Full HD. Use `LOW` for near-real-time interaction with viewers.
#' Default: `LOW`.
#' @param multitrackInputConfiguration Object specifying multitrack input configuration. Default: no multitrack
#' input configuration is specified.
#' @param name Channel name.
#' @param playbackRestrictionPolicyArn Playback-restriction-policy ARN. A valid ARN value here both specifies
#' the ARN and enables playback restriction. Default: "" (empty string, no
#' playback restriction policy is applied).
#' @param preset Optional transcode preset for the channel. This is selectable only for
#' `ADVANCED_HD` and `ADVANCED_SD` channel types. For those channel types,
#' the default `preset` is `HIGHER_BANDWIDTH_DELIVERY`. For other channel
#' types (`BASIC` and `STANDARD`), `preset` is the empty string (`""`).
#' @param recordingConfigurationArn Recording-configuration ARN. A valid ARN value here both specifies the
#' ARN and enables recording. Default: "" (empty string, recording is
#' disabled).
#' @param tags Array of 1-50 maps, each of the form `string:string (key:value)`. See
#' [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#' @param type Channel type, which determines the allowable resolution and bitrate. *If
#' you exceed the allowable input resolution or bitrate, the stream
#' probably will disconnect immediately.* Default: `STANDARD`. For details,
#' see [Channel
#' Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   channel = list(
#'     arn = "string",
#'     authorized = TRUE|FALSE,
#'     containerFormat = "TS"|"FRAGMENTED_MP4",
#'     ingestEndpoint = "string",
#'     insecureIngest = TRUE|FALSE,
#'     latencyMode = "NORMAL"|"LOW",
#'     multitrackInputConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       maximumResolution = "SD"|"HD"|"FULL_HD",
#'       policy = "ALLOW"|"REQUIRE"
#'     ),
#'     name = "string",
#'     playbackRestrictionPolicyArn = "string",
#'     playbackUrl = "string",
#'     preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'     recordingConfigurationArn = "string",
#'     srt = list(
#'       endpoint = "string",
#'       passphrase = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'   ),
#'   streamKey = list(
#'     arn = "string",
#'     channelArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     value = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_channel(
#'   authorized = TRUE|FALSE,
#'   containerFormat = "TS"|"FRAGMENTED_MP4",
#'   insecureIngest = TRUE|FALSE,
#'   latencyMode = "NORMAL"|"LOW",
#'   multitrackInputConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     maximumResolution = "SD"|"HD"|"FULL_HD",
#'     policy = "ALLOW"|"REQUIRE"
#'   ),
#'   name = "string",
#'   playbackRestrictionPolicyArn = "string",
#'   preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'   recordingConfigurationArn = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_create_channel
#'
#' @aliases ivs_create_channel
ivs_create_channel <- function(authorized = NULL, containerFormat = NULL, insecureIngest = NULL, latencyMode = NULL, multitrackInputConfiguration = NULL, name = NULL, playbackRestrictionPolicyArn = NULL, preset = NULL, recordingConfigurationArn = NULL, tags = NULL, type = NULL) {
  op <- new_operation(
    name = "CreateChannel",
    http_method = "POST",
    http_path = "/CreateChannel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$create_channel_input(authorized = authorized, containerFormat = containerFormat, insecureIngest = insecureIngest, latencyMode = latencyMode, multitrackInputConfiguration = multitrackInputConfiguration, name = name, playbackRestrictionPolicyArn = playbackRestrictionPolicyArn, preset = preset, recordingConfigurationArn = recordingConfigurationArn, tags = tags, type = type)
  output <- .ivs$create_channel_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$create_channel <- ivs_create_channel

#' Creates a new playback restriction policy, for constraining playback by
#' countries and/or origins
#'
#' @description
#' Creates a new playback restriction policy, for constraining playback by
#' countries and/or origins.
#'
#' @usage
#' ivs_create_playback_restriction_policy(allowedCountries, allowedOrigins,
#'   enableStrictOriginEnforcement, name, tags)
#'
#' @param allowedCountries A list of country codes that control geoblocking restriction. Allowed
#' values are the officially assigned [ISO 3166-1
#' alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes.
#' Default: All countries (an empty array).
#' @param allowedOrigins A list of origin sites that control CORS restriction. Allowed values are
#' the same as valid values of the Origin header defined at
#' <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin>.
#' Default: All origins (an empty array).
#' @param enableStrictOriginEnforcement Whether channel playback is constrained by origin site. Default:
#' `false`.
#' @param name Playback-restriction-policy name. The value does not need to be unique.
#' @param tags Array of 1-50 maps, each of the form `string:string (key:value)`. See
#' [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   playbackRestrictionPolicy = list(
#'     allowedCountries = list(
#'       "string"
#'     ),
#'     allowedOrigins = list(
#'       "string"
#'     ),
#'     arn = "string",
#'     enableStrictOriginEnforcement = TRUE|FALSE,
#'     name = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_playback_restriction_policy(
#'   allowedCountries = list(
#'     "string"
#'   ),
#'   allowedOrigins = list(
#'     "string"
#'   ),
#'   enableStrictOriginEnforcement = TRUE|FALSE,
#'   name = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_create_playback_restriction_policy
#'
#' @aliases ivs_create_playback_restriction_policy
ivs_create_playback_restriction_policy <- function(allowedCountries = NULL, allowedOrigins = NULL, enableStrictOriginEnforcement = NULL, name = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreatePlaybackRestrictionPolicy",
    http_method = "POST",
    http_path = "/CreatePlaybackRestrictionPolicy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$create_playback_restriction_policy_input(allowedCountries = allowedCountries, allowedOrigins = allowedOrigins, enableStrictOriginEnforcement = enableStrictOriginEnforcement, name = name, tags = tags)
  output <- .ivs$create_playback_restriction_policy_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$create_playback_restriction_policy <- ivs_create_playback_restriction_policy

#' Creates a new recording configuration, used to enable recording to
#' Amazon S3
#'
#' @description
#' Creates a new recording configuration, used to enable recording to
#' Amazon S3.
#' 
#' **Known issue:** In the us-east-1 region, if you use the Amazon Web
#' Services CLI to create a recording configuration, it returns success
#' even if the S3 bucket is in a different region. In this case, the
#' `state` of the recording configuration is `CREATE_FAILED` (instead of
#' `ACTIVE`). (In other regions, the CLI correctly returns failure if the
#' bucket is in a different region.)
#' 
#' **Workaround:** Ensure that your S3 bucket is in the same region as the
#' recording configuration. If you create a recording configuration in a
#' different region as your S3 bucket, delete that recording configuration
#' and create a new one with an S3 bucket from the correct region.
#'
#' @usage
#' ivs_create_recording_configuration(destinationConfiguration, name,
#'   recordingReconnectWindowSeconds, renditionConfiguration, tags,
#'   thumbnailConfiguration)
#'
#' @param destinationConfiguration &#91;required&#93; A complex type that contains a destination configuration for where
#' recorded video will be stored.
#' @param name Recording-configuration name. The value does not need to be unique.
#' @param recordingReconnectWindowSeconds If a broadcast disconnects and then reconnects within the specified
#' interval, the multiple streams will be considered a single broadcast and
#' merged together. Default: 0.
#' @param renditionConfiguration Object that describes which renditions should be recorded for a stream.
#' @param tags Array of 1-50 maps, each of the form `string:string (key:value)`. See
#' [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#' @param thumbnailConfiguration A complex type that allows you to enable/disable the recording of
#' thumbnails for a live session and modify the interval at which
#' thumbnails are generated for the live session.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   recordingConfiguration = list(
#'     arn = "string",
#'     destinationConfiguration = list(
#'       s3 = list(
#'         bucketName = "string"
#'       )
#'     ),
#'     name = "string",
#'     recordingReconnectWindowSeconds = 123,
#'     renditionConfiguration = list(
#'       renditionSelection = "ALL"|"NONE"|"CUSTOM",
#'       renditions = list(
#'         "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION"
#'       )
#'     ),
#'     state = "CREATING"|"CREATE_FAILED"|"ACTIVE",
#'     tags = list(
#'       "string"
#'     ),
#'     thumbnailConfiguration = list(
#'       recordingMode = "DISABLED"|"INTERVAL",
#'       resolution = "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION",
#'       storage = list(
#'         "SEQUENTIAL"|"LATEST"
#'       ),
#'       targetIntervalSeconds = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_recording_configuration(
#'   destinationConfiguration = list(
#'     s3 = list(
#'       bucketName = "string"
#'     )
#'   ),
#'   name = "string",
#'   recordingReconnectWindowSeconds = 123,
#'   renditionConfiguration = list(
#'     renditionSelection = "ALL"|"NONE"|"CUSTOM",
#'     renditions = list(
#'       "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   thumbnailConfiguration = list(
#'     recordingMode = "DISABLED"|"INTERVAL",
#'     resolution = "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION",
#'     storage = list(
#'       "SEQUENTIAL"|"LATEST"
#'     ),
#'     targetIntervalSeconds = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_create_recording_configuration
#'
#' @aliases ivs_create_recording_configuration
ivs_create_recording_configuration <- function(destinationConfiguration, name = NULL, recordingReconnectWindowSeconds = NULL, renditionConfiguration = NULL, tags = NULL, thumbnailConfiguration = NULL) {
  op <- new_operation(
    name = "CreateRecordingConfiguration",
    http_method = "POST",
    http_path = "/CreateRecordingConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$create_recording_configuration_input(destinationConfiguration = destinationConfiguration, name = name, recordingReconnectWindowSeconds = recordingReconnectWindowSeconds, renditionConfiguration = renditionConfiguration, tags = tags, thumbnailConfiguration = thumbnailConfiguration)
  output <- .ivs$create_recording_configuration_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$create_recording_configuration <- ivs_create_recording_configuration

#' Creates a stream key, used to initiate a stream, for the specified
#' channel ARN
#'
#' @description
#' Creates a stream key, used to initiate a stream, for the specified
#' channel ARN.
#' 
#' Note that [`create_channel`][ivs_create_channel] creates a stream key.
#' If you subsequently use CreateStreamKey on the same channel, it will
#' fail because a stream key already exists and there is a limit of 1
#' stream key per channel. To reset the stream key on a channel, use
#' [`delete_stream_key`][ivs_delete_stream_key] and then CreateStreamKey.
#'
#' @usage
#' ivs_create_stream_key(channelArn, tags)
#'
#' @param channelArn &#91;required&#93; ARN of the channel for which to create the stream key.
#' @param tags Array of 1-50 maps, each of the form `string:string (key:value)`. See
#' [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   streamKey = list(
#'     arn = "string",
#'     channelArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     value = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_stream_key(
#'   channelArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_create_stream_key
#'
#' @aliases ivs_create_stream_key
ivs_create_stream_key <- function(channelArn, tags = NULL) {
  op <- new_operation(
    name = "CreateStreamKey",
    http_method = "POST",
    http_path = "/CreateStreamKey",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$create_stream_key_input(channelArn = channelArn, tags = tags)
  output <- .ivs$create_stream_key_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$create_stream_key <- ivs_create_stream_key

#' Deletes the specified channel and its associated stream keys
#'
#' @description
#' Deletes the specified channel and its associated stream keys.
#' 
#' If you try to delete a live channel, you will get an error (409
#' ConflictException). To delete a channel that is live, call
#' [`stop_stream`][ivs_stop_stream], wait for the Amazon EventBridge
#' "Stream End" event (to verify that the stream's state is no longer
#' Live), then call DeleteChannel. (See [Using EventBridge with Amazon
#' IVS](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/eventbridge.html).)
#'
#' @usage
#' ivs_delete_channel(arn)
#'
#' @param arn &#91;required&#93; ARN of the channel to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_channel(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_delete_channel
#'
#' @aliases ivs_delete_channel
ivs_delete_channel <- function(arn) {
  op <- new_operation(
    name = "DeleteChannel",
    http_method = "POST",
    http_path = "/DeleteChannel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$delete_channel_input(arn = arn)
  output <- .ivs$delete_channel_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$delete_channel <- ivs_delete_channel

#' Deletes a specified authorization key pair
#'
#' @description
#' Deletes a specified authorization key pair. This invalidates future
#' viewer tokens generated using the key pairâ€™s `privateKey`. For more
#' information, see [Setting Up Private
#' Channels](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/private-channels.html)
#' in the *Amazon IVS User Guide*.
#'
#' @usage
#' ivs_delete_playback_key_pair(arn)
#'
#' @param arn &#91;required&#93; ARN of the key pair to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_playback_key_pair(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_delete_playback_key_pair
#'
#' @aliases ivs_delete_playback_key_pair
ivs_delete_playback_key_pair <- function(arn) {
  op <- new_operation(
    name = "DeletePlaybackKeyPair",
    http_method = "POST",
    http_path = "/DeletePlaybackKeyPair",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$delete_playback_key_pair_input(arn = arn)
  output <- .ivs$delete_playback_key_pair_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$delete_playback_key_pair <- ivs_delete_playback_key_pair

#' Deletes the specified playback restriction policy
#'
#' @description
#' Deletes the specified playback restriction policy.
#'
#' @usage
#' ivs_delete_playback_restriction_policy(arn)
#'
#' @param arn &#91;required&#93; ARN of the playback restriction policy to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_playback_restriction_policy(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_delete_playback_restriction_policy
#'
#' @aliases ivs_delete_playback_restriction_policy
ivs_delete_playback_restriction_policy <- function(arn) {
  op <- new_operation(
    name = "DeletePlaybackRestrictionPolicy",
    http_method = "POST",
    http_path = "/DeletePlaybackRestrictionPolicy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$delete_playback_restriction_policy_input(arn = arn)
  output <- .ivs$delete_playback_restriction_policy_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$delete_playback_restriction_policy <- ivs_delete_playback_restriction_policy

#' Deletes the recording configuration for the specified ARN
#'
#' @description
#' Deletes the recording configuration for the specified ARN.
#' 
#' If you try to delete a recording configuration that is associated with a
#' channel, you will get an error (409 ConflictException). To avoid this,
#' for all channels that reference the recording configuration, first use
#' [`update_channel`][ivs_update_channel] to set the
#' `recordingConfigurationArn` field to an empty string, then use
#' DeleteRecordingConfiguration.
#'
#' @usage
#' ivs_delete_recording_configuration(arn)
#'
#' @param arn &#91;required&#93; ARN of the recording configuration to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_recording_configuration(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_delete_recording_configuration
#'
#' @aliases ivs_delete_recording_configuration
ivs_delete_recording_configuration <- function(arn) {
  op <- new_operation(
    name = "DeleteRecordingConfiguration",
    http_method = "POST",
    http_path = "/DeleteRecordingConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$delete_recording_configuration_input(arn = arn)
  output <- .ivs$delete_recording_configuration_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$delete_recording_configuration <- ivs_delete_recording_configuration

#' Deletes the stream key for the specified ARN, so it can no longer be
#' used to stream
#'
#' @description
#' Deletes the stream key for the specified ARN, so it can no longer be
#' used to stream.
#'
#' @usage
#' ivs_delete_stream_key(arn)
#'
#' @param arn &#91;required&#93; ARN of the stream key to be deleted.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_stream_key(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_delete_stream_key
#'
#' @aliases ivs_delete_stream_key
ivs_delete_stream_key <- function(arn) {
  op <- new_operation(
    name = "DeleteStreamKey",
    http_method = "POST",
    http_path = "/DeleteStreamKey",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$delete_stream_key_input(arn = arn)
  output <- .ivs$delete_stream_key_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$delete_stream_key <- ivs_delete_stream_key

#' Gets the channel configuration for the specified channel ARN
#'
#' @description
#' Gets the channel configuration for the specified channel ARN. See also
#' [`batch_get_channel`][ivs_batch_get_channel].
#'
#' @usage
#' ivs_get_channel(arn)
#'
#' @param arn &#91;required&#93; ARN of the channel for which the configuration is to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   channel = list(
#'     arn = "string",
#'     authorized = TRUE|FALSE,
#'     containerFormat = "TS"|"FRAGMENTED_MP4",
#'     ingestEndpoint = "string",
#'     insecureIngest = TRUE|FALSE,
#'     latencyMode = "NORMAL"|"LOW",
#'     multitrackInputConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       maximumResolution = "SD"|"HD"|"FULL_HD",
#'       policy = "ALLOW"|"REQUIRE"
#'     ),
#'     name = "string",
#'     playbackRestrictionPolicyArn = "string",
#'     playbackUrl = "string",
#'     preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'     recordingConfigurationArn = "string",
#'     srt = list(
#'       endpoint = "string",
#'       passphrase = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_channel(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_channel
#'
#' @aliases ivs_get_channel
ivs_get_channel <- function(arn) {
  op <- new_operation(
    name = "GetChannel",
    http_method = "POST",
    http_path = "/GetChannel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_channel_input(arn = arn)
  output <- .ivs$get_channel_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_channel <- ivs_get_channel

#' Gets a specified playback authorization key pair and returns the arn and
#' fingerprint
#'
#' @description
#' Gets a specified playback authorization key pair and returns the `arn`
#' and `fingerprint`. The `privateKey` held by the caller can be used to
#' generate viewer authorization tokens, to grant viewers access to private
#' channels. For more information, see [Setting Up Private
#' Channels](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/private-channels.html)
#' in the *Amazon IVS User Guide*.
#'
#' @usage
#' ivs_get_playback_key_pair(arn)
#'
#' @param arn &#91;required&#93; ARN of the key pair to be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   keyPair = list(
#'     arn = "string",
#'     fingerprint = "string",
#'     name = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_playback_key_pair(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_playback_key_pair
#'
#' @aliases ivs_get_playback_key_pair
ivs_get_playback_key_pair <- function(arn) {
  op <- new_operation(
    name = "GetPlaybackKeyPair",
    http_method = "POST",
    http_path = "/GetPlaybackKeyPair",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_playback_key_pair_input(arn = arn)
  output <- .ivs$get_playback_key_pair_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_playback_key_pair <- ivs_get_playback_key_pair

#' Gets the specified playback restriction policy
#'
#' @description
#' Gets the specified playback restriction policy.
#'
#' @usage
#' ivs_get_playback_restriction_policy(arn)
#'
#' @param arn &#91;required&#93; ARN of the playback restriction policy to be returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   playbackRestrictionPolicy = list(
#'     allowedCountries = list(
#'       "string"
#'     ),
#'     allowedOrigins = list(
#'       "string"
#'     ),
#'     arn = "string",
#'     enableStrictOriginEnforcement = TRUE|FALSE,
#'     name = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_playback_restriction_policy(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_playback_restriction_policy
#'
#' @aliases ivs_get_playback_restriction_policy
ivs_get_playback_restriction_policy <- function(arn) {
  op <- new_operation(
    name = "GetPlaybackRestrictionPolicy",
    http_method = "POST",
    http_path = "/GetPlaybackRestrictionPolicy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_playback_restriction_policy_input(arn = arn)
  output <- .ivs$get_playback_restriction_policy_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_playback_restriction_policy <- ivs_get_playback_restriction_policy

#' Gets the recording configuration for the specified ARN
#'
#' @description
#' Gets the recording configuration for the specified ARN.
#'
#' @usage
#' ivs_get_recording_configuration(arn)
#'
#' @param arn &#91;required&#93; ARN of the recording configuration to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   recordingConfiguration = list(
#'     arn = "string",
#'     destinationConfiguration = list(
#'       s3 = list(
#'         bucketName = "string"
#'       )
#'     ),
#'     name = "string",
#'     recordingReconnectWindowSeconds = 123,
#'     renditionConfiguration = list(
#'       renditionSelection = "ALL"|"NONE"|"CUSTOM",
#'       renditions = list(
#'         "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION"
#'       )
#'     ),
#'     state = "CREATING"|"CREATE_FAILED"|"ACTIVE",
#'     tags = list(
#'       "string"
#'     ),
#'     thumbnailConfiguration = list(
#'       recordingMode = "DISABLED"|"INTERVAL",
#'       resolution = "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION",
#'       storage = list(
#'         "SEQUENTIAL"|"LATEST"
#'       ),
#'       targetIntervalSeconds = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_recording_configuration(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_recording_configuration
#'
#' @aliases ivs_get_recording_configuration
ivs_get_recording_configuration <- function(arn) {
  op <- new_operation(
    name = "GetRecordingConfiguration",
    http_method = "POST",
    http_path = "/GetRecordingConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_recording_configuration_input(arn = arn)
  output <- .ivs$get_recording_configuration_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_recording_configuration <- ivs_get_recording_configuration

#' Gets information about the active (live) stream on a specified channel
#'
#' @description
#' Gets information about the active (live) stream on a specified channel.
#'
#' @usage
#' ivs_get_stream(channelArn)
#'
#' @param channelArn &#91;required&#93; Channel ARN for stream to be accessed.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   stream = list(
#'     channelArn = "string",
#'     health = "HEALTHY"|"STARVING"|"UNKNOWN",
#'     playbackUrl = "string",
#'     startTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     state = "LIVE"|"OFFLINE",
#'     streamId = "string",
#'     viewerCount = 123
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_stream(
#'   channelArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_stream
#'
#' @aliases ivs_get_stream
ivs_get_stream <- function(channelArn) {
  op <- new_operation(
    name = "GetStream",
    http_method = "POST",
    http_path = "/GetStream",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_stream_input(channelArn = channelArn)
  output <- .ivs$get_stream_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_stream <- ivs_get_stream

#' Gets stream-key information for a specified ARN
#'
#' @description
#' Gets stream-key information for a specified ARN.
#'
#' @usage
#' ivs_get_stream_key(arn)
#'
#' @param arn &#91;required&#93; ARN for the stream key to be retrieved.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   streamKey = list(
#'     arn = "string",
#'     channelArn = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     value = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_stream_key(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_stream_key
#'
#' @aliases ivs_get_stream_key
ivs_get_stream_key <- function(arn) {
  op <- new_operation(
    name = "GetStreamKey",
    http_method = "POST",
    http_path = "/GetStreamKey",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_stream_key_input(arn = arn)
  output <- .ivs$get_stream_key_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_stream_key <- ivs_get_stream_key

#' Gets metadata on a specified stream
#'
#' @description
#' Gets metadata on a specified stream.
#'
#' @usage
#' ivs_get_stream_session(channelArn, streamId)
#'
#' @param channelArn &#91;required&#93; ARN of the channel resource
#' @param streamId Unique identifier for a live or previously live stream in the specified
#' channel. If no `streamId` is provided, this returns the most recent
#' stream session for the channel, if it exists.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   streamSession = list(
#'     channel = list(
#'       arn = "string",
#'       authorized = TRUE|FALSE,
#'       containerFormat = "TS"|"FRAGMENTED_MP4",
#'       ingestEndpoint = "string",
#'       insecureIngest = TRUE|FALSE,
#'       latencyMode = "NORMAL"|"LOW",
#'       multitrackInputConfiguration = list(
#'         enabled = TRUE|FALSE,
#'         maximumResolution = "SD"|"HD"|"FULL_HD",
#'         policy = "ALLOW"|"REQUIRE"
#'       ),
#'       name = "string",
#'       playbackRestrictionPolicyArn = "string",
#'       playbackUrl = "string",
#'       preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'       recordingConfigurationArn = "string",
#'       srt = list(
#'         endpoint = "string",
#'         passphrase = "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'     ),
#'     endTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     ingestConfiguration = list(
#'       audio = list(
#'         channels = 123,
#'         codec = "string",
#'         sampleRate = 123,
#'         targetBitrate = 123,
#'         track = "string"
#'       ),
#'       video = list(
#'         avcLevel = "string",
#'         avcProfile = "string",
#'         codec = "string",
#'         encoder = "string",
#'         level = "string",
#'         profile = "string",
#'         targetBitrate = 123,
#'         targetFramerate = 123,
#'         track = "string",
#'         videoHeight = 123,
#'         videoWidth = 123
#'       )
#'     ),
#'     ingestConfigurations = list(
#'       audioConfigurations = list(
#'         list(
#'           channels = 123,
#'           codec = "string",
#'           sampleRate = 123,
#'           targetBitrate = 123,
#'           track = "string"
#'         )
#'       ),
#'       videoConfigurations = list(
#'         list(
#'           avcLevel = "string",
#'           avcProfile = "string",
#'           codec = "string",
#'           encoder = "string",
#'           level = "string",
#'           profile = "string",
#'           targetBitrate = 123,
#'           targetFramerate = 123,
#'           track = "string",
#'           videoHeight = 123,
#'           videoWidth = 123
#'         )
#'       )
#'     ),
#'     recordingConfiguration = list(
#'       arn = "string",
#'       destinationConfiguration = list(
#'         s3 = list(
#'           bucketName = "string"
#'         )
#'       ),
#'       name = "string",
#'       recordingReconnectWindowSeconds = 123,
#'       renditionConfiguration = list(
#'         renditionSelection = "ALL"|"NONE"|"CUSTOM",
#'         renditions = list(
#'           "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION"
#'         )
#'       ),
#'       state = "CREATING"|"CREATE_FAILED"|"ACTIVE",
#'       tags = list(
#'         "string"
#'       ),
#'       thumbnailConfiguration = list(
#'         recordingMode = "DISABLED"|"INTERVAL",
#'         resolution = "SD"|"HD"|"FULL_HD"|"LOWEST_RESOLUTION",
#'         storage = list(
#'           "SEQUENTIAL"|"LATEST"
#'         ),
#'         targetIntervalSeconds = 123
#'       )
#'     ),
#'     startTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     streamId = "string",
#'     truncatedEvents = list(
#'       list(
#'         code = "string",
#'         eventTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         name = "string",
#'         type = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_stream_session(
#'   channelArn = "string",
#'   streamId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_get_stream_session
#'
#' @aliases ivs_get_stream_session
ivs_get_stream_session <- function(channelArn, streamId = NULL) {
  op <- new_operation(
    name = "GetStreamSession",
    http_method = "POST",
    http_path = "/GetStreamSession",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$get_stream_session_input(channelArn = channelArn, streamId = streamId)
  output <- .ivs$get_stream_session_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$get_stream_session <- ivs_get_stream_session

#' Imports the public portion of a new key pair and returns its arn and
#' fingerprint
#'
#' @description
#' Imports the public portion of a new key pair and returns its `arn` and
#' `fingerprint`. The `privateKey` can then be used to generate viewer
#' authorization tokens, to grant viewers access to private channels. For
#' more information, see [Setting Up Private
#' Channels](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/private-channels.html)
#' in the *Amazon IVS User Guide*.
#'
#' @usage
#' ivs_import_playback_key_pair(name, publicKeyMaterial, tags)
#'
#' @param name Playback-key-pair name. The value does not need to be unique.
#' @param publicKeyMaterial &#91;required&#93; The public portion of a customer-generated key pair.
#' @param tags Any tags provided with the request are added to the playback key pair
#' tags. See [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   keyPair = list(
#'     arn = "string",
#'     fingerprint = "string",
#'     name = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$import_playback_key_pair(
#'   name = "string",
#'   publicKeyMaterial = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_import_playback_key_pair
#'
#' @aliases ivs_import_playback_key_pair
ivs_import_playback_key_pair <- function(name = NULL, publicKeyMaterial, tags = NULL) {
  op <- new_operation(
    name = "ImportPlaybackKeyPair",
    http_method = "POST",
    http_path = "/ImportPlaybackKeyPair",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$import_playback_key_pair_input(name = name, publicKeyMaterial = publicKeyMaterial, tags = tags)
  output <- .ivs$import_playback_key_pair_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$import_playback_key_pair <- ivs_import_playback_key_pair

#' Gets summary information about all channels in your account, in the
#' Amazon Web Services region where the API request is processed
#'
#' @description
#' Gets summary information about all channels in your account, in the
#' Amazon Web Services region where the API request is processed. This list
#' can be filtered to match a specified name or recording-configuration
#' ARN. Filters are mutually exclusive and cannot be used together. If you
#' try to use both filters, you will get an error (409 ConflictException).
#'
#' @usage
#' ivs_list_channels(filterByName, filterByPlaybackRestrictionPolicyArn,
#'   filterByRecordingConfigurationArn, maxResults, nextToken)
#'
#' @param filterByName Filters the channel list to match the specified name.
#' @param filterByPlaybackRestrictionPolicyArn Filters the channel list to match the specified policy.
#' @param filterByRecordingConfigurationArn Filters the channel list to match the specified recording-configuration
#' ARN.
#' @param maxResults Maximum number of channels to return. Default: 100.
#' @param nextToken The first channel to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   channels = list(
#'     list(
#'       arn = "string",
#'       authorized = TRUE|FALSE,
#'       insecureIngest = TRUE|FALSE,
#'       latencyMode = "NORMAL"|"LOW",
#'       name = "string",
#'       playbackRestrictionPolicyArn = "string",
#'       preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'       recordingConfigurationArn = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_channels(
#'   filterByName = "string",
#'   filterByPlaybackRestrictionPolicyArn = "string",
#'   filterByRecordingConfigurationArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_channels
#'
#' @aliases ivs_list_channels
ivs_list_channels <- function(filterByName = NULL, filterByPlaybackRestrictionPolicyArn = NULL, filterByRecordingConfigurationArn = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListChannels",
    http_method = "POST",
    http_path = "/ListChannels",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "channels"),
    stream_api = FALSE
  )
  input <- .ivs$list_channels_input(filterByName = filterByName, filterByPlaybackRestrictionPolicyArn = filterByPlaybackRestrictionPolicyArn, filterByRecordingConfigurationArn = filterByRecordingConfigurationArn, maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_channels_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_channels <- ivs_list_channels

#' Gets summary information about playback key pairs
#'
#' @description
#' Gets summary information about playback key pairs. For more information,
#' see [Setting Up Private
#' Channels](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/private-channels.html)
#' in the *Amazon IVS User Guide*.
#'
#' @usage
#' ivs_list_playback_key_pairs(maxResults, nextToken)
#'
#' @param maxResults Maximum number of key pairs to return. Default: your service quota or
#' 100, whichever is smaller.
#' @param nextToken The first key pair to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   keyPairs = list(
#'     list(
#'       arn = "string",
#'       name = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_playback_key_pairs(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_playback_key_pairs
#'
#' @aliases ivs_list_playback_key_pairs
ivs_list_playback_key_pairs <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListPlaybackKeyPairs",
    http_method = "POST",
    http_path = "/ListPlaybackKeyPairs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "keyPairs"),
    stream_api = FALSE
  )
  input <- .ivs$list_playback_key_pairs_input(maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_playback_key_pairs_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_playback_key_pairs <- ivs_list_playback_key_pairs

#' Gets summary information about playback restriction policies
#'
#' @description
#' Gets summary information about playback restriction policies.
#'
#' @usage
#' ivs_list_playback_restriction_policies(maxResults, nextToken)
#'
#' @param maxResults Maximum number of policies to return. Default: 1.
#' @param nextToken The first policy to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   playbackRestrictionPolicies = list(
#'     list(
#'       allowedCountries = list(
#'         "string"
#'       ),
#'       allowedOrigins = list(
#'         "string"
#'       ),
#'       arn = "string",
#'       enableStrictOriginEnforcement = TRUE|FALSE,
#'       name = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_playback_restriction_policies(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_playback_restriction_policies
#'
#' @aliases ivs_list_playback_restriction_policies
ivs_list_playback_restriction_policies <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListPlaybackRestrictionPolicies",
    http_method = "POST",
    http_path = "/ListPlaybackRestrictionPolicies",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$list_playback_restriction_policies_input(maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_playback_restriction_policies_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_playback_restriction_policies <- ivs_list_playback_restriction_policies

#' Gets summary information about all recording configurations in your
#' account, in the Amazon Web Services region where the API request is
#' processed
#'
#' @description
#' Gets summary information about all recording configurations in your
#' account, in the Amazon Web Services region where the API request is
#' processed.
#'
#' @usage
#' ivs_list_recording_configurations(maxResults, nextToken)
#'
#' @param maxResults Maximum number of recording configurations to return. Default: your
#' service quota or 100, whichever is smaller.
#' @param nextToken The first recording configuration to retrieve. This is used for
#' pagination; see the `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   recordingConfigurations = list(
#'     list(
#'       arn = "string",
#'       destinationConfiguration = list(
#'         s3 = list(
#'           bucketName = "string"
#'         )
#'       ),
#'       name = "string",
#'       state = "CREATING"|"CREATE_FAILED"|"ACTIVE",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_recording_configurations(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_recording_configurations
#'
#' @aliases ivs_list_recording_configurations
ivs_list_recording_configurations <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListRecordingConfigurations",
    http_method = "POST",
    http_path = "/ListRecordingConfigurations",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "recordingConfigurations"),
    stream_api = FALSE
  )
  input <- .ivs$list_recording_configurations_input(maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_recording_configurations_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_recording_configurations <- ivs_list_recording_configurations

#' Gets summary information about stream keys for the specified channel
#'
#' @description
#' Gets summary information about stream keys for the specified channel.
#'
#' @usage
#' ivs_list_stream_keys(channelArn, maxResults, nextToken)
#'
#' @param channelArn &#91;required&#93; Channel ARN used to filter the list.
#' @param maxResults Maximum number of streamKeys to return. Default: 1.
#' @param nextToken The first stream key to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   streamKeys = list(
#'     list(
#'       arn = "string",
#'       channelArn = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_stream_keys(
#'   channelArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_stream_keys
#'
#' @aliases ivs_list_stream_keys
ivs_list_stream_keys <- function(channelArn, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListStreamKeys",
    http_method = "POST",
    http_path = "/ListStreamKeys",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "streamKeys"),
    stream_api = FALSE
  )
  input <- .ivs$list_stream_keys_input(channelArn = channelArn, maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_stream_keys_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_stream_keys <- ivs_list_stream_keys

#' Gets a summary of current and previous streams for a specified channel
#' in your account, in the AWS region where the API request is processed
#'
#' @description
#' Gets a summary of current and previous streams for a specified channel
#' in your account, in the AWS region where the API request is processed.
#'
#' @usage
#' ivs_list_stream_sessions(channelArn, maxResults, nextToken)
#'
#' @param channelArn &#91;required&#93; Channel ARN used to filter the list.
#' @param maxResults Maximum number of streams to return. Default: 100.
#' @param nextToken The first stream to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   streamSessions = list(
#'     list(
#'       endTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       hasErrorEvent = TRUE|FALSE,
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       streamId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_stream_sessions(
#'   channelArn = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_stream_sessions
#'
#' @aliases ivs_list_stream_sessions
ivs_list_stream_sessions <- function(channelArn, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListStreamSessions",
    http_method = "POST",
    http_path = "/ListStreamSessions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$list_stream_sessions_input(channelArn = channelArn, maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_stream_sessions_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_stream_sessions <- ivs_list_stream_sessions

#' Gets summary information about live streams in your account, in the
#' Amazon Web Services region where the API request is processed
#'
#' @description
#' Gets summary information about live streams in your account, in the
#' Amazon Web Services region where the API request is processed.
#'
#' @usage
#' ivs_list_streams(filterBy, maxResults, nextToken)
#'
#' @param filterBy Filters the stream list to match the specified criterion.
#' @param maxResults Maximum number of streams to return. Default: 100.
#' @param nextToken The first stream to retrieve. This is used for pagination; see the
#' `nextToken` response field.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   streams = list(
#'     list(
#'       channelArn = "string",
#'       health = "HEALTHY"|"STARVING"|"UNKNOWN",
#'       startTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       state = "LIVE"|"OFFLINE",
#'       streamId = "string",
#'       viewerCount = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_streams(
#'   filterBy = list(
#'     health = "HEALTHY"|"STARVING"|"UNKNOWN"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_streams
#'
#' @aliases ivs_list_streams
ivs_list_streams <- function(filterBy = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListStreams",
    http_method = "POST",
    http_path = "/ListStreams",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "streams"),
    stream_api = FALSE
  )
  input <- .ivs$list_streams_input(filterBy = filterBy, maxResults = maxResults, nextToken = nextToken)
  output <- .ivs$list_streams_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_streams <- ivs_list_streams

#' Gets information about Amazon Web Services tags for the specified ARN
#'
#' @description
#' Gets information about Amazon Web Services tags for the specified ARN.
#'
#' @usage
#' ivs_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource to be retrieved. The ARN must be URL-encoded.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_list_tags_for_resource
#'
#' @aliases ivs_list_tags_for_resource
ivs_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .ivs$list_tags_for_resource_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$list_tags_for_resource <- ivs_list_tags_for_resource

#' Inserts metadata into the active stream of the specified channel
#'
#' @description
#' Inserts metadata into the active stream of the specified channel. At
#' most 5 requests per second per channel are allowed, each with a maximum
#' 1 KB payload. (If 5 TPS is not sufficient for your needs, we recommend
#' batching your data into a single PutMetadata call.) At most 155 requests
#' per second per account are allowed. Also see [Embedding Metadata within
#' a Video
#' Stream](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/metadata.html)
#' in the *Amazon IVS User Guide*.
#'
#' @usage
#' ivs_put_metadata(channelArn, metadata)
#'
#' @param channelArn &#91;required&#93; ARN of the channel into which metadata is inserted. This channel must
#' have an active stream.
#' @param metadata &#91;required&#93; Metadata to insert into the stream. Maximum: 1 KB per request.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_metadata(
#'   channelArn = "string",
#'   metadata = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_put_metadata
#'
#' @aliases ivs_put_metadata
ivs_put_metadata <- function(channelArn, metadata) {
  op <- new_operation(
    name = "PutMetadata",
    http_method = "POST",
    http_path = "/PutMetadata",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$put_metadata_input(channelArn = channelArn, metadata = metadata)
  output <- .ivs$put_metadata_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$put_metadata <- ivs_put_metadata

#' Starts the process of revoking the viewer session associated with a
#' specified channel ARN and viewer ID
#'
#' @description
#' Starts the process of revoking the viewer session associated with a
#' specified channel ARN and viewer ID. Optionally, you can provide a
#' version to revoke viewer sessions less than and including that version.
#' For instructions on associating a viewer ID with a viewer session, see
#' [Setting Up Private
#' Channels](https://docs.aws.amazon.com/ivs/latest/LowLatencyUserGuide/private-channels.html).
#'
#' @usage
#' ivs_start_viewer_session_revocation(channelArn, viewerId,
#'   viewerSessionVersionsLessThanOrEqualTo)
#'
#' @param channelArn &#91;required&#93; The ARN of the channel associated with the viewer session to revoke.
#' @param viewerId &#91;required&#93; The ID of the viewer associated with the viewer session to revoke. Do
#' not use this field for personally identifying, confidential, or
#' sensitive information.
#' @param viewerSessionVersionsLessThanOrEqualTo An optional filter on which versions of the viewer session to revoke.
#' All versions less than or equal to the specified version will be
#' revoked. Default: 0.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$start_viewer_session_revocation(
#'   channelArn = "string",
#'   viewerId = "string",
#'   viewerSessionVersionsLessThanOrEqualTo = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_start_viewer_session_revocation
#'
#' @aliases ivs_start_viewer_session_revocation
ivs_start_viewer_session_revocation <- function(channelArn, viewerId, viewerSessionVersionsLessThanOrEqualTo = NULL) {
  op <- new_operation(
    name = "StartViewerSessionRevocation",
    http_method = "POST",
    http_path = "/StartViewerSessionRevocation",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$start_viewer_session_revocation_input(channelArn = channelArn, viewerId = viewerId, viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualTo)
  output <- .ivs$start_viewer_session_revocation_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$start_viewer_session_revocation <- ivs_start_viewer_session_revocation

#' Disconnects the incoming RTMPS stream for the specified channel
#'
#' @description
#' Disconnects the incoming RTMPS stream for the specified channel. Can be
#' used in conjunction with [`delete_stream_key`][ivs_delete_stream_key] to
#' prevent further streaming to a channel.
#' 
#' Many streaming client-software libraries automatically reconnect a
#' dropped RTMPS session, so to stop the stream permanently, you may want
#' to first revoke the `streamKey` attached to the channel.
#'
#' @usage
#' ivs_stop_stream(channelArn)
#'
#' @param channelArn &#91;required&#93; ARN of the channel for which the stream is to be stopped.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_stream(
#'   channelArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_stop_stream
#'
#' @aliases ivs_stop_stream
ivs_stop_stream <- function(channelArn) {
  op <- new_operation(
    name = "StopStream",
    http_method = "POST",
    http_path = "/StopStream",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$stop_stream_input(channelArn = channelArn)
  output <- .ivs$stop_stream_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$stop_stream <- ivs_stop_stream

#' Adds or updates tags for the Amazon Web Services resource with the
#' specified ARN
#'
#' @description
#' Adds or updates tags for the Amazon Web Services resource with the
#' specified ARN.
#'
#' @usage
#' ivs_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be added or updated. The ARN
#' must be URL-encoded.
#' @param tags &#91;required&#93; Array of tags to be added or updated. Array of maps, each of the form
#' `string:string (key:value)`. See [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_tag_resource
#'
#' @aliases ivs_tag_resource
ivs_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .ivs$tag_resource_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$tag_resource <- ivs_tag_resource

#' Removes tags from the resource with the specified ARN
#'
#' @description
#' Removes tags from the resource with the specified ARN.
#'
#' @usage
#' ivs_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; ARN of the resource for which tags are to be removed. The ARN must be
#' URL-encoded.
#' @param tagKeys &#91;required&#93; Array of tags to be removed. Array of maps, each of the form
#' `string:string (key:value)`. See [Best practices and
#' strategies](https://docs.aws.amazon.com/tag-editor/latest/userguide/best-practices-and-strats.html)
#' in *Tagging Amazon Web Services Resources and Tag Editor* for details,
#' including restrictions that apply to tags and "Tag naming limits and
#' requirements"; Amazon IVS has no service-specific constraints beyond
#' what is documented there.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_untag_resource
#'
#' @aliases ivs_untag_resource
ivs_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .ivs$untag_resource_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$untag_resource <- ivs_untag_resource

#' Updates a channel's configuration
#'
#' @description
#' Updates a channel's configuration. Live channels cannot be updated. You
#' must stop the ongoing stream, update the channel, and restart the stream
#' for the changes to take effect.
#'
#' @usage
#' ivs_update_channel(arn, authorized, containerFormat, insecureIngest,
#'   latencyMode, multitrackInputConfiguration, name,
#'   playbackRestrictionPolicyArn, preset, recordingConfigurationArn, type)
#'
#' @param arn &#91;required&#93; ARN of the channel to be updated.
#' @param authorized Whether the channel is private (enabled for playback authorization).
#' @param containerFormat Indicates which content-packaging format is used (MPEG-TS or fMP4). If
#' `multitrackInputConfiguration` is specified and `enabled` is `true`,
#' then `containerFormat` is required and must be set to `FRAGMENTED_MP4`.
#' Otherwise, `containerFormat` may be set to `TS` or `FRAGMENTED_MP4`.
#' Default: `TS`.
#' @param insecureIngest Whether the channel allows insecure RTMP and SRT ingest. Default:
#' `false`.
#' @param latencyMode Channel latency mode. Use `NORMAL` to broadcast and deliver live video
#' up to Full HD. Use `LOW` for near-real-time interaction with viewers.
#' @param multitrackInputConfiguration Object specifying multitrack input configuration. Default: no multitrack
#' input configuration is specified.
#' @param name Channel name.
#' @param playbackRestrictionPolicyArn Playback-restriction-policy ARN. A valid ARN value here both specifies
#' the ARN and enables playback restriction. If this is set to an empty
#' string, playback restriction policy is disabled.
#' @param preset Optional transcode preset for the channel. This is selectable only for
#' `ADVANCED_HD` and `ADVANCED_SD` channel types. For those channel types,
#' the default `preset` is `HIGHER_BANDWIDTH_DELIVERY`. For other channel
#' types (`BASIC` and `STANDARD`), `preset` is the empty string (`""`).
#' @param recordingConfigurationArn Recording-configuration ARN. A valid ARN value here both specifies the
#' ARN and enables recording. If this is set to an empty string, recording
#' is disabled.
#' @param type Channel type, which determines the allowable resolution and bitrate. *If
#' you exceed the allowable input resolution or bitrate, the stream
#' probably will disconnect immediately.* Default: `STANDARD`. For details,
#' see [Channel
#' Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   channel = list(
#'     arn = "string",
#'     authorized = TRUE|FALSE,
#'     containerFormat = "TS"|"FRAGMENTED_MP4",
#'     ingestEndpoint = "string",
#'     insecureIngest = TRUE|FALSE,
#'     latencyMode = "NORMAL"|"LOW",
#'     multitrackInputConfiguration = list(
#'       enabled = TRUE|FALSE,
#'       maximumResolution = "SD"|"HD"|"FULL_HD",
#'       policy = "ALLOW"|"REQUIRE"
#'     ),
#'     name = "string",
#'     playbackRestrictionPolicyArn = "string",
#'     playbackUrl = "string",
#'     preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'     recordingConfigurationArn = "string",
#'     srt = list(
#'       endpoint = "string",
#'       passphrase = "string"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_channel(
#'   arn = "string",
#'   authorized = TRUE|FALSE,
#'   containerFormat = "TS"|"FRAGMENTED_MP4",
#'   insecureIngest = TRUE|FALSE,
#'   latencyMode = "NORMAL"|"LOW",
#'   multitrackInputConfiguration = list(
#'     enabled = TRUE|FALSE,
#'     maximumResolution = "SD"|"HD"|"FULL_HD",
#'     policy = "ALLOW"|"REQUIRE"
#'   ),
#'   name = "string",
#'   playbackRestrictionPolicyArn = "string",
#'   preset = "HIGHER_BANDWIDTH_DELIVERY"|"CONSTRAINED_BANDWIDTH_DELIVERY",
#'   recordingConfigurationArn = "string",
#'   type = "BASIC"|"STANDARD"|"ADVANCED_SD"|"ADVANCED_HD"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_update_channel
#'
#' @aliases ivs_update_channel
ivs_update_channel <- function(arn, authorized = NULL, containerFormat = NULL, insecureIngest = NULL, latencyMode = NULL, multitrackInputConfiguration = NULL, name = NULL, playbackRestrictionPolicyArn = NULL, preset = NULL, recordingConfigurationArn = NULL, type = NULL) {
  op <- new_operation(
    name = "UpdateChannel",
    http_method = "POST",
    http_path = "/UpdateChannel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$update_channel_input(arn = arn, authorized = authorized, containerFormat = containerFormat, insecureIngest = insecureIngest, latencyMode = latencyMode, multitrackInputConfiguration = multitrackInputConfiguration, name = name, playbackRestrictionPolicyArn = playbackRestrictionPolicyArn, preset = preset, recordingConfigurationArn = recordingConfigurationArn, type = type)
  output <- .ivs$update_channel_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$update_channel <- ivs_update_channel

#' Updates a specified playback restriction policy
#'
#' @description
#' Updates a specified playback restriction policy.
#'
#' @usage
#' ivs_update_playback_restriction_policy(allowedCountries, allowedOrigins,
#'   arn, enableStrictOriginEnforcement, name)
#'
#' @param allowedCountries A list of country codes that control geoblocking restriction. Allowed
#' values are the officially assigned [ISO 3166-1
#' alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) codes.
#' Default: All countries (an empty array).
#' @param allowedOrigins A list of origin sites that control CORS restriction. Allowed values are
#' the same as valid values of the Origin header defined at
#' <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin>.
#' Default: All origins (an empty array).
#' @param arn &#91;required&#93; ARN of the playback-restriction-policy to be updated.
#' @param enableStrictOriginEnforcement Whether channel playback is constrained by origin site. Default:
#' `false`.
#' @param name Playback-restriction-policy name. The value does not need to be unique.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   playbackRestrictionPolicy = list(
#'     allowedCountries = list(
#'       "string"
#'     ),
#'     allowedOrigins = list(
#'       "string"
#'     ),
#'     arn = "string",
#'     enableStrictOriginEnforcement = TRUE|FALSE,
#'     name = "string",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_playback_restriction_policy(
#'   allowedCountries = list(
#'     "string"
#'   ),
#'   allowedOrigins = list(
#'     "string"
#'   ),
#'   arn = "string",
#'   enableStrictOriginEnforcement = TRUE|FALSE,
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname ivs_update_playback_restriction_policy
#'
#' @aliases ivs_update_playback_restriction_policy
ivs_update_playback_restriction_policy <- function(allowedCountries = NULL, allowedOrigins = NULL, arn, enableStrictOriginEnforcement = NULL, name = NULL) {
  op <- new_operation(
    name = "UpdatePlaybackRestrictionPolicy",
    http_method = "POST",
    http_path = "/UpdatePlaybackRestrictionPolicy",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .ivs$update_playback_restriction_policy_input(allowedCountries = allowedCountries, allowedOrigins = allowedOrigins, arn = arn, enableStrictOriginEnforcement = enableStrictOriginEnforcement, name = name)
  output <- .ivs$update_playback_restriction_policy_output()
  config <- get_config()
  svc <- .ivs$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.ivs$operations$update_playback_restriction_policy <- ivs_update_playback_restriction_policy

# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include bedrock_service.R
NULL

#' Deletes a batch of evaluation jobs
#'
#' @description
#' Deletes a batch of evaluation jobs. An evaluation job can only be
#' deleted if it has following status `FAILED`, `COMPLETED`, and `STOPPED`.
#' You can request up to 25 model evaluation jobs be deleted in a single
#' request.
#'
#' @usage
#' bedrock_batch_delete_evaluation_job(jobIdentifiers)
#'
#' @param jobIdentifiers &#91;required&#93; A list of one or more evaluation job Amazon Resource Names (ARNs) you
#' want to delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   errors = list(
#'     list(
#'       jobIdentifier = "string",
#'       code = "string",
#'       message = "string"
#'     )
#'   ),
#'   evaluationJobs = list(
#'     list(
#'       jobIdentifier = "string",
#'       jobStatus = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"Deleting"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$batch_delete_evaluation_job(
#'   jobIdentifiers = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_batch_delete_evaluation_job
#'
#' @aliases bedrock_batch_delete_evaluation_job
bedrock_batch_delete_evaluation_job <- function(jobIdentifiers) {
  op <- new_operation(
    name = "BatchDeleteEvaluationJob",
    http_method = "POST",
    http_path = "/evaluation-jobs/batch-delete",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$batch_delete_evaluation_job_input(jobIdentifiers = jobIdentifiers)
  output <- .bedrock$batch_delete_evaluation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$batch_delete_evaluation_job <- bedrock_batch_delete_evaluation_job

#' Cancels a running Automated Reasoning policy build workflow
#'
#' @description
#' Cancels a running Automated Reasoning policy build workflow. This stops
#' the policy generation process and prevents further processing of the
#' source documents.
#'
#' @usage
#' bedrock_cancel_automated_reasoning_policy_build_workflow(policyArn,
#'   buildWorkflowId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' build workflow you want to cancel.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow to cancel. You can get this
#' ID from the StartAutomatedReasoningPolicyBuildWorkflow response or by
#' listing build workflows.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_automated_reasoning_policy_build_workflow(
#'   policyArn = "string",
#'   buildWorkflowId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_cancel_automated_reasoning_policy_build_workflow
#'
#' @aliases bedrock_cancel_automated_reasoning_policy_build_workflow
bedrock_cancel_automated_reasoning_policy_build_workflow <- function(policyArn, buildWorkflowId) {
  op <- new_operation(
    name = "CancelAutomatedReasoningPolicyBuildWorkflow",
    http_method = "POST",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/cancel",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$cancel_automated_reasoning_policy_build_workflow_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId)
  output <- .bedrock$cancel_automated_reasoning_policy_build_workflow_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$cancel_automated_reasoning_policy_build_workflow <- bedrock_cancel_automated_reasoning_policy_build_workflow

#' Creates an Automated Reasoning policy for Amazon Bedrock Guardrails
#'
#' @description
#' Creates an Automated Reasoning policy for Amazon Bedrock Guardrails.
#' Automated Reasoning policies use mathematical techniques to detect
#' hallucinations, suggest corrections, and highlight unstated assumptions
#' in the responses of your GenAI application.
#' 
#' To create a policy, you upload a source document that describes the
#' rules that you're encoding. Automated Reasoning extracts important
#' concepts from the source document that will become variables in the
#' policy and infers policy rules.
#'
#' @usage
#' bedrock_create_automated_reasoning_policy(name, description,
#'   clientRequestToken, policyDefinition, kmsKeyId, tags)
#'
#' @param name &#91;required&#93; A unique name for the Automated Reasoning policy. The name must be
#' between 1 and 63 characters and can contain letters, numbers, hyphens,
#' and underscores.
#' @param description A description of the Automated Reasoning policy. Use this to provide
#' context about the policy's purpose and the types of validations it
#' performs.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than once. If this token matches a previous request,
#' Amazon Bedrock ignores the request but doesn't return an error.
#' @param policyDefinition The policy definition that contains the formal logic rules, variables,
#' and custom variable types used to validate foundation model responses in
#' your application.
#' @param kmsKeyId The identifier of the KMS key to use for encrypting the automated
#' reasoning policy and its associated artifacts. If you don't specify a
#' KMS key, Amazon Bedrock uses an KMS managed key for encryption. For
#' enhanced security and control, you can specify a customer managed KMS
#' key.
#' @param tags A list of tags to associate with the Automated Reasoning policy. Tags
#' help you organize and manage your policies.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   version = "string",
#'   name = "string",
#'   description = "string",
#'   definitionHash = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_automated_reasoning_policy(
#'   name = "string",
#'   description = "string",
#'   clientRequestToken = "string",
#'   policyDefinition = list(
#'     version = "string",
#'     types = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             value = "string",
#'             description = "string"
#'           )
#'         )
#'       )
#'     ),
#'     rules = list(
#'       list(
#'         id = "string",
#'         expression = "string",
#'         alternateExpression = "string"
#'       )
#'     ),
#'     variables = list(
#'       list(
#'         name = "string",
#'         type = "string",
#'         description = "string"
#'       )
#'     )
#'   ),
#'   kmsKeyId = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_automated_reasoning_policy
#'
#' @aliases bedrock_create_automated_reasoning_policy
bedrock_create_automated_reasoning_policy <- function(name, description = NULL, clientRequestToken = NULL, policyDefinition = NULL, kmsKeyId = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateAutomatedReasoningPolicy",
    http_method = "POST",
    http_path = "/automated-reasoning-policies",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_automated_reasoning_policy_input(name = name, description = description, clientRequestToken = clientRequestToken, policyDefinition = policyDefinition, kmsKeyId = kmsKeyId, tags = tags)
  output <- .bedrock$create_automated_reasoning_policy_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_automated_reasoning_policy <- bedrock_create_automated_reasoning_policy

#' Creates a test for an Automated Reasoning policy
#'
#' @description
#' Creates a test for an Automated Reasoning policy. Tests validate that
#' your policy works as expected by providing sample inputs and expected
#' outcomes. Use tests to verify policy behavior before deploying to
#' production.
#'
#' @usage
#' bedrock_create_automated_reasoning_policy_test_case(policyArn,
#'   guardContent, queryContent, expectedAggregatedFindingsResult,
#'   clientRequestToken, confidenceThreshold)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy for
#' which to create the test.
#' @param guardContent &#91;required&#93; The output content that's validated by the Automated Reasoning policy.
#' This represents the foundation model response that will be checked for
#' accuracy.
#' @param queryContent The input query or prompt that generated the content. This provides
#' context for the validation.
#' @param expectedAggregatedFindingsResult &#91;required&#93; The expected result of the Automated Reasoning check. Valid values
#' include: , TOO_COMPLEX, and NO_TRANSLATIONS.
#' 
#' -   `VALID` - The claims are true. The claims are implied by the
#'     premises and the Automated Reasoning policy. Given the Automated
#'     Reasoning policy and premises, it is not possible for these claims
#'     to be false. In other words, there are no alternative answers that
#'     are true that contradict the claims.
#' 
#' -   `INVALID` - The claims are false. The claims are not implied by the
#'     premises and Automated Reasoning policy. Furthermore, there exists
#'     different claims that are consistent with the premises and Automated
#'     Reasoning policy.
#' 
#' -   `SATISFIABLE` - The claims can be true or false. It depends on what
#'     assumptions are made for the claim to be implied from the premises
#'     and Automated Reasoning policy rules. In this situation, different
#'     assumptions can make input claims false and alternative claims true.
#' 
#' -   `IMPOSSIBLE` - Automated Reasoning canâ€™t make a statement about the
#'     claims. This can happen if the premises are logically incorrect, or
#'     if there is a conflict within the Automated Reasoning policy itself.
#' 
#' -   `TRANSLATION_AMBIGUOUS` - Detected an ambiguity in the translation
#'     meant it would be unsound to continue with validity checking.
#'     Additional context or follow-up questions might be needed to get
#'     translation to succeed.
#' 
#' -   `TOO_COMPLEX` - The input contains too much information for
#'     Automated Reasoning to process within its latency limits.
#' 
#' -   `NO_TRANSLATIONS` - Identifies that some or all of the input prompt
#'     wasn't translated into logic. This can happen if the input isn't
#'     relevant to the Automated Reasoning policy, or if the policy doesn't
#'     have variables to model relevant input. If Automated Reasoning can't
#'     translate anything, you get a single `NO_TRANSLATIONS` finding. You
#'     might also see a `NO_TRANSLATIONS` (along with other findings) if
#'     some part of the validation isn't translated.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error.
#' @param confidenceThreshold The minimum confidence level for logic validation. Content that meets
#' the threshold is considered a high-confidence finding that can be
#' validated.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   testCaseId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_automated_reasoning_policy_test_case(
#'   policyArn = "string",
#'   guardContent = "string",
#'   queryContent = "string",
#'   expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'   clientRequestToken = "string",
#'   confidenceThreshold = 123.0
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_automated_reasoning_policy_test_case
#'
#' @aliases bedrock_create_automated_reasoning_policy_test_case
bedrock_create_automated_reasoning_policy_test_case <- function(policyArn, guardContent, queryContent = NULL, expectedAggregatedFindingsResult, clientRequestToken = NULL, confidenceThreshold = NULL) {
  op <- new_operation(
    name = "CreateAutomatedReasoningPolicyTestCase",
    http_method = "POST",
    http_path = "/automated-reasoning-policies/{policyArn}/test-cases",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_automated_reasoning_policy_test_case_input(policyArn = policyArn, guardContent = guardContent, queryContent = queryContent, expectedAggregatedFindingsResult = expectedAggregatedFindingsResult, clientRequestToken = clientRequestToken, confidenceThreshold = confidenceThreshold)
  output <- .bedrock$create_automated_reasoning_policy_test_case_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_automated_reasoning_policy_test_case <- bedrock_create_automated_reasoning_policy_test_case

#' Creates a new version of an existing Automated Reasoning policy
#'
#' @description
#' Creates a new version of an existing Automated Reasoning policy. This
#' allows you to iterate on your policy rules while maintaining previous
#' versions for rollback or comparison purposes.
#'
#' @usage
#' bedrock_create_automated_reasoning_policy_version(policyArn,
#'   clientRequestToken, lastUpdatedDefinitionHash, tags)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy for
#' which to create a version.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error.
#' @param lastUpdatedDefinitionHash &#91;required&#93; The hash of the current policy definition used as a concurrency token to
#' ensure the policy hasn't been modified since you last retrieved it.
#' @param tags A list of tags to associate with the policy version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   version = "string",
#'   name = "string",
#'   description = "string",
#'   definitionHash = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_automated_reasoning_policy_version(
#'   policyArn = "string",
#'   clientRequestToken = "string",
#'   lastUpdatedDefinitionHash = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_automated_reasoning_policy_version
#'
#' @aliases bedrock_create_automated_reasoning_policy_version
bedrock_create_automated_reasoning_policy_version <- function(policyArn, clientRequestToken = NULL, lastUpdatedDefinitionHash, tags = NULL) {
  op <- new_operation(
    name = "CreateAutomatedReasoningPolicyVersion",
    http_method = "POST",
    http_path = "/automated-reasoning-policies/{policyArn}/versions",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_automated_reasoning_policy_version_input(policyArn = policyArn, clientRequestToken = clientRequestToken, lastUpdatedDefinitionHash = lastUpdatedDefinitionHash, tags = tags)
  output <- .bedrock$create_automated_reasoning_policy_version_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_automated_reasoning_policy_version <- bedrock_create_automated_reasoning_policy_version

#' Creates a new custom model in Amazon Bedrock
#'
#' @description
#' Creates a new custom model in Amazon Bedrock. After the model is active,
#' you can use it for inference.
#' 
#' To use the model for inference, you must purchase Provisioned Throughput
#' for it. You can't use On-demand inference with these custom models. For
#' more information about Provisioned Throughput, see [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html).
#' 
#' The model appears in [`list_custom_models`][bedrock_list_custom_models]
#' with a `customizationType` of `imported`. To track the status of the new
#' model, you use the [`get_custom_model`][bedrock_get_custom_model] API
#' operation. The model can be in the following states:
#' 
#' -   `Creating` - Initial state during validation and registration
#' 
#' -   `Active` - Model is ready for use in inference
#' 
#' -   `Failed` - Creation process encountered an error
#' 
#' **Related APIs**
#' 
#' -   [`get_custom_model`][bedrock_get_custom_model]
#' 
#' -   [`list_custom_models`][bedrock_list_custom_models]
#' 
#' -   [`delete_custom_model`][bedrock_delete_custom_model]
#'
#' @usage
#' bedrock_create_custom_model(modelName, modelSourceConfig,
#'   modelKmsKeyArn, roleArn, modelTags, clientRequestToken)
#'
#' @param modelName &#91;required&#93; A unique name for the custom model.
#' @param modelSourceConfig &#91;required&#93; The data source for the model. The Amazon S3 URI in the model source
#' must be for the Amazon-managed Amazon S3 bucket containing your model
#' artifacts.
#' @param modelKmsKeyArn The Amazon Resource Name (ARN) of the customer managed KMS key to
#' encrypt the custom model. If you don't provide a KMS key, Amazon Bedrock
#' uses an Amazon Web Services-managed KMS key to encrypt the model.
#' 
#' If you provide a customer managed KMS key, your Amazon Bedrock service
#' role must have permissions to use it. For more information see
#' [Encryption of imported
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/encryption-import-model.html).
#' @param roleArn The Amazon Resource Name (ARN) of an IAM service role that Amazon
#' Bedrock assumes to perform tasks on your behalf. This role must have
#' permissions to access the Amazon S3 bucket containing your model
#' artifacts and the KMS key (if specified). For more information, see
#' [Setting up an IAM service role for importing
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-import-iam-role.html)
#' in the Amazon Bedrock User Guide.
#' @param modelTags A list of key-value pairs to associate with the custom model resource.
#' You can use these tags to organize and identify your resources.
#' 
#' For more information, see [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_custom_model(
#'   modelName = "string",
#'   modelSourceConfig = list(
#'     s3DataSource = list(
#'       s3Uri = "string"
#'     )
#'   ),
#'   modelKmsKeyArn = "string",
#'   roleArn = "string",
#'   modelTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_custom_model
#'
#' @aliases bedrock_create_custom_model
bedrock_create_custom_model <- function(modelName, modelSourceConfig, modelKmsKeyArn = NULL, roleArn = NULL, modelTags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateCustomModel",
    http_method = "POST",
    http_path = "/custom-models/create-custom-model",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_custom_model_input(modelName = modelName, modelSourceConfig = modelSourceConfig, modelKmsKeyArn = modelKmsKeyArn, roleArn = roleArn, modelTags = modelTags, clientRequestToken = clientRequestToken)
  output <- .bedrock$create_custom_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_custom_model <- bedrock_create_custom_model

#' Deploys a custom model for on-demand inference in Amazon Bedrock
#'
#' @description
#' Deploys a custom model for on-demand inference in Amazon Bedrock. After
#' you deploy your custom model, you use the deployment's Amazon Resource
#' Name (ARN) as the `modelId` parameter when you submit prompts and
#' generate responses with model inference.
#' 
#' For more information about setting up on-demand inference for custom
#' models, see [Set up inference for a custom
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-use.html).
#' 
#' The following actions are related to the
#' [`create_custom_model_deployment`][bedrock_create_custom_model_deployment]
#' operation:
#' 
#' -   [`get_custom_model_deployment`][bedrock_get_custom_model_deployment]
#' 
#' -   [`list_custom_model_deployments`][bedrock_list_custom_model_deployments]
#' 
#' -   [`delete_custom_model_deployment`][bedrock_delete_custom_model_deployment]
#'
#' @usage
#' bedrock_create_custom_model_deployment(modelDeploymentName, modelArn,
#'   description, tags, clientRequestToken)
#'
#' @param modelDeploymentName &#91;required&#93; The name for the custom model deployment. The name must be unique within
#' your Amazon Web Services account and Region.
#' @param modelArn &#91;required&#93; The Amazon Resource Name (ARN) of the custom model to deploy for
#' on-demand inference. The custom model must be in the `Active` state.
#' @param description A description for the custom model deployment to help you identify its
#' purpose.
#' @param tags Tags to assign to the custom model deployment. You can use tags to
#' organize and track your Amazon Web Services resources for cost
#' allocation and management purposes.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/bedrock/latest/userguide/).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   customModelDeploymentArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_custom_model_deployment(
#'   modelDeploymentName = "string",
#'   modelArn = "string",
#'   description = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_custom_model_deployment
#'
#' @aliases bedrock_create_custom_model_deployment
bedrock_create_custom_model_deployment <- function(modelDeploymentName, modelArn, description = NULL, tags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateCustomModelDeployment",
    http_method = "POST",
    http_path = "/model-customization/custom-model-deployments",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_custom_model_deployment_input(modelDeploymentName = modelDeploymentName, modelArn = modelArn, description = description, tags = tags, clientRequestToken = clientRequestToken)
  output <- .bedrock$create_custom_model_deployment_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_custom_model_deployment <- bedrock_create_custom_model_deployment

#' Creates an evaluation job
#'
#' @description
#' Creates an evaluation job.
#'
#' @usage
#' bedrock_create_evaluation_job(jobName, jobDescription,
#'   clientRequestToken, roleArn, customerEncryptionKeyId, jobTags,
#'   applicationType, evaluationConfig, inferenceConfig, outputDataConfig)
#'
#' @param jobName &#91;required&#93; A name for the evaluation job. Names must unique with your Amazon Web
#' Services account, and your account's Amazon Web Services region.
#' @param jobDescription A description of the evaluation job.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of an IAM service role that Amazon
#' Bedrock can assume to perform tasks on your behalf. To learn more about
#' the required permissions, see [Required permissions for model
#' evaluations](https://docs.aws.amazon.com/bedrock/latest/userguide/model-evaluation-security-service-roles.html).
#' @param customerEncryptionKeyId Specify your customer managed encryption key Amazon Resource Name (ARN)
#' that will be used to encrypt your evaluation job.
#' @param jobTags Tags to attach to the model evaluation job.
#' @param applicationType Specifies whether the evaluation job is for evaluating a model or
#' evaluating a knowledge base (retrieval and response generation).
#' @param evaluationConfig &#91;required&#93; Contains the configuration details of either an automated or human-based
#' evaluation job.
#' @param inferenceConfig &#91;required&#93; Contains the configuration details of the inference model for the
#' evaluation job.
#' 
#' For model evaluation jobs, automated jobs support a single model or
#' [inference
#' profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html),
#' and jobs that use human workers support two models or inference
#' profiles.
#' @param outputDataConfig &#91;required&#93; Contains the configuration details of the Amazon S3 bucket for storing
#' the results of the evaluation job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_evaluation_job(
#'   jobName = "string",
#'   jobDescription = "string",
#'   clientRequestToken = "string",
#'   roleArn = "string",
#'   customerEncryptionKeyId = "string",
#'   jobTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   applicationType = "ModelEvaluation"|"RagEvaluation",
#'   evaluationConfig = list(
#'     automated = list(
#'       datasetMetricConfigs = list(
#'         list(
#'           taskType = "Summarization"|"Classification"|"QuestionAndAnswer"|"Generation"|"Custom",
#'           dataset = list(
#'             name = "string",
#'             datasetLocation = list(
#'               s3Uri = "string"
#'             )
#'           ),
#'           metricNames = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       evaluatorModelConfig = list(
#'         bedrockEvaluatorModels = list(
#'           list(
#'             modelIdentifier = "string"
#'           )
#'         )
#'       ),
#'       customMetricConfig = list(
#'         customMetrics = list(
#'           list(
#'             customMetricDefinition = list(
#'               name = "string",
#'               instructions = "string",
#'               ratingScale = list(
#'                 list(
#'                   definition = "string",
#'                   value = list(
#'                     stringValue = "string",
#'                     floatValue = 123.0
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         evaluatorModelConfig = list(
#'           bedrockEvaluatorModels = list(
#'             list(
#'               modelIdentifier = "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     human = list(
#'       humanWorkflowConfig = list(
#'         flowDefinitionArn = "string",
#'         instructions = "string"
#'       ),
#'       customMetrics = list(
#'         list(
#'           name = "string",
#'           description = "string",
#'           ratingMethod = "string"
#'         )
#'       ),
#'       datasetMetricConfigs = list(
#'         list(
#'           taskType = "Summarization"|"Classification"|"QuestionAndAnswer"|"Generation"|"Custom",
#'           dataset = list(
#'             name = "string",
#'             datasetLocation = list(
#'               s3Uri = "string"
#'             )
#'           ),
#'           metricNames = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   inferenceConfig = list(
#'     models = list(
#'       list(
#'         bedrockModel = list(
#'           modelIdentifier = "string",
#'           inferenceParams = "string",
#'           performanceConfig = list(
#'             latency = "standard"|"optimized"
#'           )
#'         ),
#'         precomputedInferenceSource = list(
#'           inferenceSourceIdentifier = "string"
#'         )
#'       )
#'     ),
#'     ragConfigs = list(
#'       list(
#'         knowledgeBaseConfig = list(
#'           retrieveConfig = list(
#'             knowledgeBaseId = "string",
#'             knowledgeBaseRetrievalConfiguration = list(
#'               vectorSearchConfiguration = list(
#'                 numberOfResults = 123,
#'                 overrideSearchType = "HYBRID"|"SEMANTIC",
#'                 filter = list(
#'                   equals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   notEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   greaterThan = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   greaterThanOrEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   lessThan = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   lessThanOrEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   in = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   notIn = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   startsWith = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   listContains = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   stringContains = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   andAll = list(
#'                     list()
#'                   ),
#'                   orAll = list(
#'                     list()
#'                   )
#'                 ),
#'                 implicitFilterConfiguration = list(
#'                   metadataAttributes = list(
#'                     list(
#'                       key = "string",
#'                       type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST",
#'                       description = "string"
#'                     )
#'                   ),
#'                   modelArn = "string"
#'                 ),
#'                 rerankingConfiguration = list(
#'                   type = "BEDROCK_RERANKING_MODEL",
#'                   bedrockRerankingConfiguration = list(
#'                     modelConfiguration = list(
#'                       modelArn = "string",
#'                       additionalModelRequestFields = list(
#'                         list()
#'                       )
#'                     ),
#'                     numberOfRerankedResults = 123,
#'                     metadataConfiguration = list(
#'                       selectionMode = "SELECTIVE"|"ALL",
#'                       selectiveModeConfiguration = list(
#'                         fieldsToInclude = list(
#'                           list(
#'                             fieldName = "string"
#'                           )
#'                         ),
#'                         fieldsToExclude = list(
#'                           list(
#'                             fieldName = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           retrieveAndGenerateConfig = list(
#'             type = "KNOWLEDGE_BASE"|"EXTERNAL_SOURCES",
#'             knowledgeBaseConfiguration = list(
#'               knowledgeBaseId = "string",
#'               modelArn = "string",
#'               retrievalConfiguration = list(
#'                 vectorSearchConfiguration = list(
#'                   numberOfResults = 123,
#'                   overrideSearchType = "HYBRID"|"SEMANTIC",
#'                   filter = list(
#'                     equals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     notEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     greaterThan = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     greaterThanOrEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     lessThan = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     lessThanOrEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     in = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     notIn = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     startsWith = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     listContains = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     stringContains = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     andAll = list(
#'                       list()
#'                     ),
#'                     orAll = list(
#'                       list()
#'                     )
#'                   ),
#'                   implicitFilterConfiguration = list(
#'                     metadataAttributes = list(
#'                       list(
#'                         key = "string",
#'                         type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST",
#'                         description = "string"
#'                       )
#'                     ),
#'                     modelArn = "string"
#'                   ),
#'                   rerankingConfiguration = list(
#'                     type = "BEDROCK_RERANKING_MODEL",
#'                     bedrockRerankingConfiguration = list(
#'                       modelConfiguration = list(
#'                         modelArn = "string",
#'                         additionalModelRequestFields = list(
#'                           list()
#'                         )
#'                       ),
#'                       numberOfRerankedResults = 123,
#'                       metadataConfiguration = list(
#'                         selectionMode = "SELECTIVE"|"ALL",
#'                         selectiveModeConfiguration = list(
#'                           fieldsToInclude = list(
#'                             list(
#'                               fieldName = "string"
#'                             )
#'                           ),
#'                           fieldsToExclude = list(
#'                             list(
#'                               fieldName = "string"
#'                             )
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               ),
#'               generationConfiguration = list(
#'                 promptTemplate = list(
#'                   textPromptTemplate = "string"
#'                 ),
#'                 guardrailConfiguration = list(
#'                   guardrailId = "string",
#'                   guardrailVersion = "string"
#'                 ),
#'                 kbInferenceConfig = list(
#'                   textInferenceConfig = list(
#'                     temperature = 123.0,
#'                     topP = 123.0,
#'                     maxTokens = 123,
#'                     stopSequences = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 )
#'               ),
#'               orchestrationConfiguration = list(
#'                 queryTransformationConfiguration = list(
#'                   type = "QUERY_DECOMPOSITION"
#'                 )
#'               )
#'             ),
#'             externalSourcesConfiguration = list(
#'               modelArn = "string",
#'               sources = list(
#'                 list(
#'                   sourceType = "S3"|"BYTE_CONTENT",
#'                   s3Location = list(
#'                     uri = "string"
#'                   ),
#'                   byteContent = list(
#'                     identifier = "string",
#'                     contentType = "string",
#'                     data = raw
#'                   )
#'                 )
#'               ),
#'               generationConfiguration = list(
#'                 promptTemplate = list(
#'                   textPromptTemplate = "string"
#'                 ),
#'                 guardrailConfiguration = list(
#'                   guardrailId = "string",
#'                   guardrailVersion = "string"
#'                 ),
#'                 kbInferenceConfig = list(
#'                   textInferenceConfig = list(
#'                     temperature = 123.0,
#'                     topP = 123.0,
#'                     maxTokens = 123,
#'                     stopSequences = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         precomputedRagSourceConfig = list(
#'           retrieveSourceConfig = list(
#'             ragSourceIdentifier = "string"
#'           ),
#'           retrieveAndGenerateSourceConfig = list(
#'             ragSourceIdentifier = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3Uri = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_evaluation_job
#'
#' @aliases bedrock_create_evaluation_job
bedrock_create_evaluation_job <- function(jobName, jobDescription = NULL, clientRequestToken = NULL, roleArn, customerEncryptionKeyId = NULL, jobTags = NULL, applicationType = NULL, evaluationConfig, inferenceConfig, outputDataConfig) {
  op <- new_operation(
    name = "CreateEvaluationJob",
    http_method = "POST",
    http_path = "/evaluation-jobs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_evaluation_job_input(jobName = jobName, jobDescription = jobDescription, clientRequestToken = clientRequestToken, roleArn = roleArn, customerEncryptionKeyId = customerEncryptionKeyId, jobTags = jobTags, applicationType = applicationType, evaluationConfig = evaluationConfig, inferenceConfig = inferenceConfig, outputDataConfig = outputDataConfig)
  output <- .bedrock$create_evaluation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_evaluation_job <- bedrock_create_evaluation_job

#' Request a model access agreement for the specified model
#'
#' @description
#' Request a model access agreement for the specified model.
#'
#' @usage
#' bedrock_create_foundation_model_agreement(offerToken, modelId)
#'
#' @param offerToken &#91;required&#93; An offer token encapsulates the information for an offer.
#' @param modelId &#91;required&#93; Model Id of the model for the access request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_foundation_model_agreement(
#'   offerToken = "string",
#'   modelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_foundation_model_agreement
#'
#' @aliases bedrock_create_foundation_model_agreement
bedrock_create_foundation_model_agreement <- function(offerToken, modelId) {
  op <- new_operation(
    name = "CreateFoundationModelAgreement",
    http_method = "POST",
    http_path = "/create-foundation-model-agreement",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_foundation_model_agreement_input(offerToken = offerToken, modelId = modelId)
  output <- .bedrock$create_foundation_model_agreement_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_foundation_model_agreement <- bedrock_create_foundation_model_agreement

#' Creates a guardrail to block topics and to implement safeguards for your
#' generative AI applications
#'
#' @description
#' Creates a guardrail to block topics and to implement safeguards for your
#' generative AI applications.
#' 
#' You can configure the following policies in a guardrail to avoid
#' undesirable and harmful content, filter out denied topics and words, and
#' remove sensitive information for privacy protection.
#' 
#' -   **Content filters** - Adjust filter strengths to block input prompts
#'     or model responses containing harmful content.
#' 
#' -   **Denied topics** - Define a set of topics that are undesirable in
#'     the context of your application. These topics will be blocked if
#'     detected in user queries or model responses.
#' 
#' -   **Word filters** - Configure filters to block undesirable words,
#'     phrases, and profanity. Such words can include offensive terms,
#'     competitor names etc.
#' 
#' -   **Sensitive information filters** - Block or mask sensitive
#'     information such as personally identifiable information (PII) or
#'     custom regex in user inputs and model responses.
#' 
#' In addition to the above policies, you can also configure the messages
#' to be returned to the user if a user input or model response is in
#' violation of the policies defined in the guardrail.
#' 
#' For more information, see [Amazon Bedrock
#' Guardrails](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails.html)
#' in the *Amazon Bedrock User Guide*.
#'
#' @usage
#' bedrock_create_guardrail(name, description, topicPolicyConfig,
#'   contentPolicyConfig, wordPolicyConfig, sensitiveInformationPolicyConfig,
#'   contextualGroundingPolicyConfig, automatedReasoningPolicyConfig,
#'   crossRegionConfig, blockedInputMessaging, blockedOutputsMessaging,
#'   kmsKeyId, tags, clientRequestToken)
#'
#' @param name &#91;required&#93; The name to give the guardrail.
#' @param description A description of the guardrail.
#' @param topicPolicyConfig The topic policies to configure for the guardrail.
#' @param contentPolicyConfig The content filter policies to configure for the guardrail.
#' @param wordPolicyConfig The word policy you configure for the guardrail.
#' @param sensitiveInformationPolicyConfig The sensitive information policy to configure for the guardrail.
#' @param contextualGroundingPolicyConfig The contextual grounding policy configuration used to create a
#' guardrail.
#' @param automatedReasoningPolicyConfig Optional configuration for integrating Automated Reasoning policies with
#' the new guardrail.
#' @param crossRegionConfig The system-defined guardrail profile that you're using with your
#' guardrail. Guardrail profiles define the destination Amazon Web Services
#' Regions where guardrail inference requests can be automatically routed.
#' 
#' For more information, see the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
#' @param blockedInputMessaging &#91;required&#93; The message to return when the guardrail blocks a prompt.
#' @param blockedOutputsMessaging &#91;required&#93; The message to return when the guardrail blocks a model response.
#' @param kmsKeyId The ARN of the KMS key that you use to encrypt the guardrail.
#' @param tags The tags that you want to attach to the guardrail.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than once. If this token matches a previous request,
#' Amazon Bedrock ignores the request, but does not return an error. For
#' more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html)
#' in the *Amazon S3 User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrailId = "string",
#'   guardrailArn = "string",
#'   version = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_guardrail(
#'   name = "string",
#'   description = "string",
#'   topicPolicyConfig = list(
#'     topicsConfig = list(
#'       list(
#'         name = "string",
#'         definition = "string",
#'         examples = list(
#'           "string"
#'         ),
#'         type = "DENY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tierConfig = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   contentPolicyConfig = list(
#'     filtersConfig = list(
#'       list(
#'         type = "SEXUAL"|"VIOLENCE"|"HATE"|"INSULTS"|"MISCONDUCT"|"PROMPT_ATTACK",
#'         inputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         outputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         inputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         outputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tierConfig = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   wordPolicyConfig = list(
#'     wordsConfig = list(
#'       list(
#'         text = "string",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     managedWordListsConfig = list(
#'       list(
#'         type = "PROFANITY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   sensitiveInformationPolicyConfig = list(
#'     piiEntitiesConfig = list(
#'       list(
#'         type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     regexesConfig = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         pattern = "string",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   contextualGroundingPolicyConfig = list(
#'     filtersConfig = list(
#'       list(
#'         type = "GROUNDING"|"RELEVANCE",
#'         threshold = 123.0,
#'         action = "BLOCK"|"NONE",
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   automatedReasoningPolicyConfig = list(
#'     policies = list(
#'       "string"
#'     ),
#'     confidenceThreshold = 123.0
#'   ),
#'   crossRegionConfig = list(
#'     guardrailProfileIdentifier = "string"
#'   ),
#'   blockedInputMessaging = "string",
#'   blockedOutputsMessaging = "string",
#'   kmsKeyId = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_guardrail
#'
#' @aliases bedrock_create_guardrail
bedrock_create_guardrail <- function(name, description = NULL, topicPolicyConfig = NULL, contentPolicyConfig = NULL, wordPolicyConfig = NULL, sensitiveInformationPolicyConfig = NULL, contextualGroundingPolicyConfig = NULL, automatedReasoningPolicyConfig = NULL, crossRegionConfig = NULL, blockedInputMessaging, blockedOutputsMessaging, kmsKeyId = NULL, tags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateGuardrail",
    http_method = "POST",
    http_path = "/guardrails",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_guardrail_input(name = name, description = description, topicPolicyConfig = topicPolicyConfig, contentPolicyConfig = contentPolicyConfig, wordPolicyConfig = wordPolicyConfig, sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig, contextualGroundingPolicyConfig = contextualGroundingPolicyConfig, automatedReasoningPolicyConfig = automatedReasoningPolicyConfig, crossRegionConfig = crossRegionConfig, blockedInputMessaging = blockedInputMessaging, blockedOutputsMessaging = blockedOutputsMessaging, kmsKeyId = kmsKeyId, tags = tags, clientRequestToken = clientRequestToken)
  output <- .bedrock$create_guardrail_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_guardrail <- bedrock_create_guardrail

#' Creates a version of the guardrail
#'
#' @description
#' Creates a version of the guardrail. Use this API to create a snapshot of
#' the guardrail when you are satisfied with a configuration, or to compare
#' the configuration with another version.
#'
#' @usage
#' bedrock_create_guardrail_version(guardrailIdentifier, description,
#'   clientRequestToken)
#'
#' @param guardrailIdentifier &#91;required&#93; The unique identifier of the guardrail. This can be an ID or the ARN.
#' @param description A description of the guardrail version.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than once. If this token matches a previous request,
#' Amazon Bedrock ignores the request, but does not return an error. For
#' more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html)
#' in the *Amazon S3 User Guide*.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrailId = "string",
#'   version = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_guardrail_version(
#'   guardrailIdentifier = "string",
#'   description = "string",
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_guardrail_version
#'
#' @aliases bedrock_create_guardrail_version
bedrock_create_guardrail_version <- function(guardrailIdentifier, description = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateGuardrailVersion",
    http_method = "POST",
    http_path = "/guardrails/{guardrailIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_guardrail_version_input(guardrailIdentifier = guardrailIdentifier, description = description, clientRequestToken = clientRequestToken)
  output <- .bedrock$create_guardrail_version_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_guardrail_version <- bedrock_create_guardrail_version

#' Creates an application inference profile to track metrics and costs when
#' invoking a model
#'
#' @description
#' Creates an application inference profile to track metrics and costs when
#' invoking a model. To create an application inference profile for a
#' foundation model in one region, specify the ARN of the model in that
#' region. To create an application inference profile for a foundation
#' model across multiple regions, specify the ARN of the system-defined
#' inference profile that contains the regions that you want to route
#' requests to. For more information, see [Increase throughput and
#' resilience with cross-region inference in Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrock_create_inference_profile(inferenceProfileName, description,
#'   clientRequestToken, modelSource, tags)
#'
#' @param inferenceProfileName &#91;required&#93; A name for the inference profile.
#' @param description A description for the inference profile.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#' @param modelSource &#91;required&#93; The foundation model or system-defined inference profile that the
#' inference profile will track metrics and costs for.
#' @param tags An array of objects, each of which contains a tag and its value. For
#' more information, see [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   inferenceProfileArn = "string",
#'   status = "ACTIVE"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_inference_profile(
#'   inferenceProfileName = "string",
#'   description = "string",
#'   clientRequestToken = "string",
#'   modelSource = list(
#'     copyFrom = "string"
#'   ),
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_inference_profile
#'
#' @aliases bedrock_create_inference_profile
bedrock_create_inference_profile <- function(inferenceProfileName, description = NULL, clientRequestToken = NULL, modelSource, tags = NULL) {
  op <- new_operation(
    name = "CreateInferenceProfile",
    http_method = "POST",
    http_path = "/inference-profiles",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_inference_profile_input(inferenceProfileName = inferenceProfileName, description = description, clientRequestToken = clientRequestToken, modelSource = modelSource, tags = tags)
  output <- .bedrock$create_inference_profile_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_inference_profile <- bedrock_create_inference_profile

#' Creates an endpoint for a model from Amazon Bedrock Marketplace
#'
#' @description
#' Creates an endpoint for a model from Amazon Bedrock Marketplace. The
#' endpoint is hosted by Amazon SageMaker.
#'
#' @usage
#' bedrock_create_marketplace_model_endpoint(modelSourceIdentifier,
#'   endpointConfig, acceptEula, endpointName, clientRequestToken, tags)
#'
#' @param modelSourceIdentifier &#91;required&#93; The ARN of the model from Amazon Bedrock Marketplace that you want to
#' deploy to the endpoint.
#' @param endpointConfig &#91;required&#93; The configuration for the endpoint, including the number and type of
#' instances to use.
#' @param acceptEula Indicates whether you accept the end-user license agreement (EULA) for
#' the model. Set to `true` to accept the EULA.
#' @param endpointName &#91;required&#93; The name of the endpoint. This name must be unique within your Amazon
#' Web Services account and region.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. This token is listed as not required because
#' Amazon Web Services SDKs automatically generate it for you and set this
#' parameter. If you're not using the Amazon Web Services SDK or the CLI,
#' you must provide this token or the action will fail.
#' @param tags An array of key-value pairs to apply to the underlying Amazon SageMaker
#' endpoint. You can use these tags to organize and identify your Amazon
#' Web Services resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   marketplaceModelEndpoint = list(
#'     endpointArn = "string",
#'     modelSourceIdentifier = "string",
#'     status = "REGISTERED"|"INCOMPATIBLE_ENDPOINT",
#'     statusMessage = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endpointConfig = list(
#'       sageMaker = list(
#'         initialInstanceCount = 123,
#'         instanceType = "string",
#'         executionRole = "string",
#'         kmsEncryptionKey = "string",
#'         vpc = list(
#'           subnetIds = list(
#'             "string"
#'           ),
#'           securityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     endpointStatus = "string",
#'     endpointStatusMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_marketplace_model_endpoint(
#'   modelSourceIdentifier = "string",
#'   endpointConfig = list(
#'     sageMaker = list(
#'       initialInstanceCount = 123,
#'       instanceType = "string",
#'       executionRole = "string",
#'       kmsEncryptionKey = "string",
#'       vpc = list(
#'         subnetIds = list(
#'           "string"
#'         ),
#'         securityGroupIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   acceptEula = TRUE|FALSE,
#'   endpointName = "string",
#'   clientRequestToken = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_marketplace_model_endpoint
#'
#' @aliases bedrock_create_marketplace_model_endpoint
bedrock_create_marketplace_model_endpoint <- function(modelSourceIdentifier, endpointConfig, acceptEula = NULL, endpointName, clientRequestToken = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateMarketplaceModelEndpoint",
    http_method = "POST",
    http_path = "/marketplace-model/endpoints",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_marketplace_model_endpoint_input(modelSourceIdentifier = modelSourceIdentifier, endpointConfig = endpointConfig, acceptEula = acceptEula, endpointName = endpointName, clientRequestToken = clientRequestToken, tags = tags)
  output <- .bedrock$create_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_marketplace_model_endpoint <- bedrock_create_marketplace_model_endpoint

#' Copies a model to another region so that it can be used there
#'
#' @description
#' Copies a model to another region so that it can be used there. For more
#' information, see [Copy models to be used in other
#' regions](https://docs.aws.amazon.com/bedrock/latest/userguide/copy-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_create_model_copy_job(sourceModelArn, targetModelName,
#'   modelKmsKeyId, targetModelTags, clientRequestToken)
#'
#' @param sourceModelArn &#91;required&#93; The Amazon Resource Name (ARN) of the model to be copied.
#' @param targetModelName &#91;required&#93; A name for the copied model.
#' @param modelKmsKeyId The ARN of the KMS key that you use to encrypt the model copy.
#' @param targetModelTags Tags to associate with the target model. For more information, see [Tag
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_model_copy_job(
#'   sourceModelArn = "string",
#'   targetModelName = "string",
#'   modelKmsKeyId = "string",
#'   targetModelTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_model_copy_job
#'
#' @aliases bedrock_create_model_copy_job
bedrock_create_model_copy_job <- function(sourceModelArn, targetModelName, modelKmsKeyId = NULL, targetModelTags = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "CreateModelCopyJob",
    http_method = "POST",
    http_path = "/model-copy-jobs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_model_copy_job_input(sourceModelArn = sourceModelArn, targetModelName = targetModelName, modelKmsKeyId = modelKmsKeyId, targetModelTags = targetModelTags, clientRequestToken = clientRequestToken)
  output <- .bedrock$create_model_copy_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_model_copy_job <- bedrock_create_model_copy_job

#' Creates a fine-tuning job to customize a base model
#'
#' @description
#' Creates a fine-tuning job to customize a base model.
#' 
#' You specify the base foundation model and the location of the training
#' data. After the model-customization job completes successfully, your
#' custom model resource will be ready to use. Amazon Bedrock returns
#' validation loss metrics and output generations after the job completes.
#' 
#' For information on the format of training and validation data, see
#' [Prepare the
#' datasets](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-prepare.html).
#' 
#' Model-customization jobs are asynchronous and the completion time
#' depends on the base model and the training/validation data size. To
#' monitor a job, use the
#' [`get_model_customization_job`][bedrock_get_model_customization_job]
#' operation to retrieve the job status.
#' 
#' For more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_create_model_customization_job(jobName, customModelName,
#'   roleArn, clientRequestToken, baseModelIdentifier, customizationType,
#'   customModelKmsKeyId, jobTags, customModelTags, trainingDataConfig,
#'   validationDataConfig, outputDataConfig, hyperParameters, vpcConfig,
#'   customizationConfig)
#'
#' @param jobName &#91;required&#93; A name for the fine-tuning job.
#' @param customModelName &#91;required&#93; A name for the resulting custom model.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of an IAM service role that Amazon
#' Bedrock can assume to perform tasks on your behalf. For example, during
#' model training, Amazon Bedrock needs your permission to read input data
#' from an S3 bucket, write model artifacts to an S3 bucket. To pass this
#' role to Amazon Bedrock, the caller of this API must have the
#' `iam:PassRole` permission.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#' @param baseModelIdentifier &#91;required&#93; Name of the base model.
#' @param customizationType The customization type.
#' @param customModelKmsKeyId The custom model is encrypted at rest using this key.
#' @param jobTags Tags to attach to the job.
#' @param customModelTags Tags to attach to the resulting custom model.
#' @param trainingDataConfig &#91;required&#93; Information about the training dataset.
#' @param validationDataConfig Information about the validation dataset.
#' @param outputDataConfig &#91;required&#93; S3 location for the output data.
#' @param hyperParameters Parameters related to tuning the model. For details on the format for
#' different models, see [Custom model
#' hyperparameters](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models-hp.html).
#' @param vpcConfig The configuration of the Virtual Private Cloud (VPC) that contains the
#' resources that you're using for this job. For more information, see
#' [Protect your model customization jobs using a
#' VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/).
#' @param customizationConfig The customization configuration for the model customization job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_model_customization_job(
#'   jobName = "string",
#'   customModelName = "string",
#'   roleArn = "string",
#'   clientRequestToken = "string",
#'   baseModelIdentifier = "string",
#'   customizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"|"REINFORCEMENT_FINE_TUNING"|"IMPORTED",
#'   customModelKmsKeyId = "string",
#'   jobTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   customModelTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   trainingDataConfig = list(
#'     s3Uri = "string",
#'     invocationLogsConfig = list(
#'       usePromptResponse = TRUE|FALSE,
#'       invocationLogSource = list(
#'         s3Uri = "string"
#'       ),
#'       requestMetadataFilters = list(
#'         equals = list(
#'           "string"
#'         ),
#'         notEquals = list(
#'           "string"
#'         ),
#'         andAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         orAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   validationDataConfig = list(
#'     validators = list(
#'       list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3Uri = "string"
#'   ),
#'   hyperParameters = list(
#'     "string"
#'   ),
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   customizationConfig = list(
#'     distillationConfig = list(
#'       teacherModelConfig = list(
#'         teacherModelIdentifier = "string",
#'         maxResponseLengthForInference = 123
#'       )
#'     ),
#'     rftConfig = list(
#'       graderConfig = list(
#'         lambdaGrader = list(
#'           lambdaArn = "string"
#'         )
#'       ),
#'       hyperParameters = list(
#'         epochCount = 123,
#'         batchSize = 123,
#'         learningRate = 123.0,
#'         maxPromptLength = 123,
#'         trainingSamplePerPrompt = 123,
#'         inferenceMaxTokens = 123,
#'         reasoningEffort = "low"|"medium"|"high",
#'         evalInterval = 123
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_model_customization_job
#'
#' @aliases bedrock_create_model_customization_job
bedrock_create_model_customization_job <- function(jobName, customModelName, roleArn, clientRequestToken = NULL, baseModelIdentifier, customizationType = NULL, customModelKmsKeyId = NULL, jobTags = NULL, customModelTags = NULL, trainingDataConfig, validationDataConfig = NULL, outputDataConfig, hyperParameters = NULL, vpcConfig = NULL, customizationConfig = NULL) {
  op <- new_operation(
    name = "CreateModelCustomizationJob",
    http_method = "POST",
    http_path = "/model-customization-jobs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_model_customization_job_input(jobName = jobName, customModelName = customModelName, roleArn = roleArn, clientRequestToken = clientRequestToken, baseModelIdentifier = baseModelIdentifier, customizationType = customizationType, customModelKmsKeyId = customModelKmsKeyId, jobTags = jobTags, customModelTags = customModelTags, trainingDataConfig = trainingDataConfig, validationDataConfig = validationDataConfig, outputDataConfig = outputDataConfig, hyperParameters = hyperParameters, vpcConfig = vpcConfig, customizationConfig = customizationConfig)
  output <- .bedrock$create_model_customization_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_model_customization_job <- bedrock_create_model_customization_job

#' Creates a model import job to import model that you have customized in
#' other environments, such as Amazon SageMaker
#'
#' @description
#' Creates a model import job to import model that you have customized in
#' other environments, such as Amazon SageMaker. For more information, see
#' [Import a customized
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html)
#'
#' @usage
#' bedrock_create_model_import_job(jobName, importedModelName, roleArn,
#'   modelDataSource, jobTags, importedModelTags, clientRequestToken,
#'   vpcConfig, importedModelKmsKeyId)
#'
#' @param jobName &#91;required&#93; The name of the import job.
#' @param importedModelName &#91;required&#93; The name of the imported model.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the model import job.
#' @param modelDataSource &#91;required&#93; The data source for the imported model.
#' @param jobTags Tags to attach to this import job.
#' @param importedModelTags Tags to attach to the imported model.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#' @param vpcConfig VPC configuration parameters for the private Virtual Private Cloud (VPC)
#' that contains the resources you are using for the import job.
#' @param importedModelKmsKeyId The imported model is encrypted at rest using this key.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_model_import_job(
#'   jobName = "string",
#'   importedModelName = "string",
#'   roleArn = "string",
#'   modelDataSource = list(
#'     s3DataSource = list(
#'       s3Uri = "string"
#'     )
#'   ),
#'   jobTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   importedModelTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string",
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   importedModelKmsKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_model_import_job
#'
#' @aliases bedrock_create_model_import_job
bedrock_create_model_import_job <- function(jobName, importedModelName, roleArn, modelDataSource, jobTags = NULL, importedModelTags = NULL, clientRequestToken = NULL, vpcConfig = NULL, importedModelKmsKeyId = NULL) {
  op <- new_operation(
    name = "CreateModelImportJob",
    http_method = "POST",
    http_path = "/model-import-jobs",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_model_import_job_input(jobName = jobName, importedModelName = importedModelName, roleArn = roleArn, modelDataSource = modelDataSource, jobTags = jobTags, importedModelTags = importedModelTags, clientRequestToken = clientRequestToken, vpcConfig = vpcConfig, importedModelKmsKeyId = importedModelKmsKeyId)
  output <- .bedrock$create_model_import_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_model_import_job <- bedrock_create_model_import_job

#' Creates a batch inference job to invoke a model on multiple prompts
#'
#' @description
#' Creates a batch inference job to invoke a model on multiple prompts.
#' Format your data according to [Format your inference
#' data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html)
#' and upload it to an Amazon S3 bucket. For more information, see [Process
#' multiple prompts with batch
#' inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference.html).
#' 
#' The response returns a `jobArn` that you can use to stop or get details
#' about the job.
#'
#' @usage
#' bedrock_create_model_invocation_job(jobName, roleArn,
#'   clientRequestToken, modelId, inputDataConfig, outputDataConfig,
#'   vpcConfig, timeoutDurationInHours, tags)
#'
#' @param jobName &#91;required&#93; A name to give the batch inference job.
#' @param roleArn &#91;required&#93; The Amazon Resource Name (ARN) of the service role with permissions to
#' carry out and manage batch inference. You can use the console to create
#' a default service role or follow the steps at [Create a service role for
#' batch
#' inference](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-iam-sr.html).
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html).
#' @param modelId &#91;required&#93; The unique identifier of the foundation model to use for the batch
#' inference job.
#' @param inputDataConfig &#91;required&#93; Details about the location of the input to the batch inference job.
#' @param outputDataConfig &#91;required&#93; Details about the location of the output of the batch inference job.
#' @param vpcConfig The configuration of the Virtual Private Cloud (VPC) for the data in the
#' batch inference job. For more information, see [Protect batch inference
#' jobs using a
#' VPC](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-vpc.html).
#' @param timeoutDurationInHours The number of hours after which to force the batch inference job to time
#' out.
#' @param tags Any tags to associate with the batch inference job. For more
#' information, see [Tagging Amazon Bedrock
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/tagging.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_model_invocation_job(
#'   jobName = "string",
#'   roleArn = "string",
#'   clientRequestToken = "string",
#'   modelId = "string",
#'   inputDataConfig = list(
#'     s3InputDataConfig = list(
#'       s3InputFormat = "JSONL",
#'       s3Uri = "string",
#'       s3BucketOwner = "string"
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3OutputDataConfig = list(
#'       s3Uri = "string",
#'       s3EncryptionKeyId = "string",
#'       s3BucketOwner = "string"
#'     )
#'   ),
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   timeoutDurationInHours = 123,
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_model_invocation_job
#'
#' @aliases bedrock_create_model_invocation_job
bedrock_create_model_invocation_job <- function(jobName, roleArn, clientRequestToken = NULL, modelId, inputDataConfig, outputDataConfig, vpcConfig = NULL, timeoutDurationInHours = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateModelInvocationJob",
    http_method = "POST",
    http_path = "/model-invocation-job",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_model_invocation_job_input(jobName = jobName, roleArn = roleArn, clientRequestToken = clientRequestToken, modelId = modelId, inputDataConfig = inputDataConfig, outputDataConfig = outputDataConfig, vpcConfig = vpcConfig, timeoutDurationInHours = timeoutDurationInHours, tags = tags)
  output <- .bedrock$create_model_invocation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_model_invocation_job <- bedrock_create_model_invocation_job

#' Creates a prompt router that manages the routing of requests between
#' multiple foundation models based on the routing criteria
#'
#' @description
#' Creates a prompt router that manages the routing of requests between
#' multiple foundation models based on the routing criteria.
#'
#' @usage
#' bedrock_create_prompt_router(clientRequestToken, promptRouterName,
#'   models, description, routingCriteria, fallbackModel, tags)
#'
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure
#' idempotency of your requests. If not specified, the Amazon Web Services
#' SDK automatically generates one for you.
#' @param promptRouterName &#91;required&#93; The name of the prompt router. The name must be unique within your
#' Amazon Web Services account in the current region.
#' @param models &#91;required&#93; A list of foundation models that the prompt router can route requests
#' to. At least one model must be specified.
#' @param description An optional description of the prompt router to help identify its
#' purpose.
#' @param routingCriteria &#91;required&#93; The criteria, which is the response quality difference, used to
#' determine how incoming requests are routed to different models.
#' @param fallbackModel &#91;required&#93; The default model to use when the routing criteria is not met.
#' @param tags An array of key-value pairs to apply to this resource as tags. You can
#' use tags to categorize and manage your Amazon Web Services resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   promptRouterArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_prompt_router(
#'   clientRequestToken = "string",
#'   promptRouterName = "string",
#'   models = list(
#'     list(
#'       modelArn = "string"
#'     )
#'   ),
#'   description = "string",
#'   routingCriteria = list(
#'     responseQualityDifference = 123.0
#'   ),
#'   fallbackModel = list(
#'     modelArn = "string"
#'   ),
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_prompt_router
#'
#' @aliases bedrock_create_prompt_router
bedrock_create_prompt_router <- function(clientRequestToken = NULL, promptRouterName, models, description = NULL, routingCriteria, fallbackModel, tags = NULL) {
  op <- new_operation(
    name = "CreatePromptRouter",
    http_method = "POST",
    http_path = "/prompt-routers",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_prompt_router_input(clientRequestToken = clientRequestToken, promptRouterName = promptRouterName, models = models, description = description, routingCriteria = routingCriteria, fallbackModel = fallbackModel, tags = tags)
  output <- .bedrock$create_prompt_router_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_prompt_router <- bedrock_create_prompt_router

#' Creates dedicated throughput for a base or custom model with the model
#' units and for the duration that you specify
#'
#' @description
#' Creates dedicated throughput for a base or custom model with the model
#' units and for the duration that you specify. For pricing details, see
#' [Amazon Bedrock Pricing](https://aws.amazon.com/bedrock/pricing/). For
#' more information, see [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_create_provisioned_model_throughput(clientRequestToken,
#'   modelUnits, provisionedModelName, modelId, commitmentDuration, tags)
#'
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the API request
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error. For more information, see [Ensuring
#' idempotency](https://docs.aws.amazon.com/ec2/latest/devguide/ec2-api-idempotency.html)
#' in the Amazon S3 User Guide.
#' @param modelUnits &#91;required&#93; Number of model units to allocate. A model unit delivers a specific
#' throughput level for the specified model. The throughput level of a
#' model unit specifies the total number of input and output tokens that it
#' can process and generate within a span of one minute. By default, your
#' account has no model units for purchasing Provisioned Throughputs with
#' commitment. You must first visit the Amazon Web Services support center
#' to request MUs.
#' 
#' For model unit quotas, see [Provisioned Throughput
#' quotas](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html#prov-thru-quotas)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' 
#' For more information about what an MU specifies, contact your Amazon Web
#' Services account manager.
#' @param provisionedModelName &#91;required&#93; The name for this Provisioned Throughput.
#' @param modelId &#91;required&#93; The Amazon Resource Name (ARN) or name of the model to associate with
#' this Provisioned Throughput. For a list of models for which you can
#' purchase Provisioned Throughput, see [Amazon Bedrock model IDs for
#' purchasing Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html#prov-throughput-models)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' @param commitmentDuration The commitment duration requested for the Provisioned Throughput.
#' Billing occurs hourly and is discounted for longer commitment terms. To
#' request a no-commit Provisioned Throughput, omit this field.
#' 
#' Custom models support all levels of commitment. To see which base models
#' support no commitment, see [Supported regions and models for Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/) in
#' the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' @param tags Tags to associate with this Provisioned Throughput.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   provisionedModelArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_provisioned_model_throughput(
#'   clientRequestToken = "string",
#'   modelUnits = 123,
#'   provisionedModelName = "string",
#'   modelId = "string",
#'   commitmentDuration = "OneMonth"|"SixMonths",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_create_provisioned_model_throughput
#'
#' @aliases bedrock_create_provisioned_model_throughput
bedrock_create_provisioned_model_throughput <- function(clientRequestToken = NULL, modelUnits, provisionedModelName, modelId, commitmentDuration = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateProvisionedModelThroughput",
    http_method = "POST",
    http_path = "/provisioned-model-throughput",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$create_provisioned_model_throughput_input(clientRequestToken = clientRequestToken, modelUnits = modelUnits, provisionedModelName = provisionedModelName, modelId = modelId, commitmentDuration = commitmentDuration, tags = tags)
  output <- .bedrock$create_provisioned_model_throughput_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$create_provisioned_model_throughput <- bedrock_create_provisioned_model_throughput

#' Deletes an Automated Reasoning policy or policy version
#'
#' @description
#' Deletes an Automated Reasoning policy or policy version. This operation
#' is idempotent. If you delete a policy more than once, each call
#' succeeds. Deleting a policy removes it permanently and cannot be undone.
#'
#' @usage
#' bedrock_delete_automated_reasoning_policy(policyArn, force)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy to
#' delete.
#' @param force Specifies whether to force delete the automated reasoning policy even if
#' it has active resources. When `false`, Amazon Bedrock validates if all
#' artifacts have been deleted (e.g. policy version, test case, test
#' result) for a policy before deletion. When `true`, Amazon Bedrock will
#' delete the policy and all its artifacts without validation. Default is
#' `false`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_automated_reasoning_policy(
#'   policyArn = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_automated_reasoning_policy
#'
#' @aliases bedrock_delete_automated_reasoning_policy
bedrock_delete_automated_reasoning_policy <- function(policyArn, force = NULL) {
  op <- new_operation(
    name = "DeleteAutomatedReasoningPolicy",
    http_method = "DELETE",
    http_path = "/automated-reasoning-policies/{policyArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_automated_reasoning_policy_input(policyArn = policyArn, force = force)
  output <- .bedrock$delete_automated_reasoning_policy_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_automated_reasoning_policy <- bedrock_delete_automated_reasoning_policy

#' Deletes an Automated Reasoning policy build workflow and its associated
#' artifacts
#'
#' @description
#' Deletes an Automated Reasoning policy build workflow and its associated
#' artifacts. This permanently removes the workflow history and any
#' generated assets.
#'
#' @usage
#' bedrock_delete_automated_reasoning_policy_build_workflow(policyArn,
#'   buildWorkflowId, lastUpdatedAt)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' build workflow you want to delete.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow to delete.
#' @param lastUpdatedAt &#91;required&#93; The timestamp when the build workflow was last updated. This is used for
#' optimistic concurrency control to prevent accidental deletion of
#' workflows that have been modified.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_automated_reasoning_policy_build_workflow(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_automated_reasoning_policy_build_workflow
#'
#' @aliases bedrock_delete_automated_reasoning_policy_build_workflow
bedrock_delete_automated_reasoning_policy_build_workflow <- function(policyArn, buildWorkflowId, lastUpdatedAt) {
  op <- new_operation(
    name = "DeleteAutomatedReasoningPolicyBuildWorkflow",
    http_method = "DELETE",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_automated_reasoning_policy_build_workflow_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, lastUpdatedAt = lastUpdatedAt)
  output <- .bedrock$delete_automated_reasoning_policy_build_workflow_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_automated_reasoning_policy_build_workflow <- bedrock_delete_automated_reasoning_policy_build_workflow

#' Deletes an Automated Reasoning policy test
#'
#' @description
#' Deletes an Automated Reasoning policy test. This operation is
#' idempotent; if you delete a test more than once, each call succeeds.
#'
#' @usage
#' bedrock_delete_automated_reasoning_policy_test_case(policyArn,
#'   testCaseId, lastUpdatedAt)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy that
#' contains the test.
#' @param testCaseId &#91;required&#93; The unique identifier of the test to delete.
#' @param lastUpdatedAt &#91;required&#93; The timestamp when the test was last updated. This is used as a
#' concurrency token to prevent conflicting modifications.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_automated_reasoning_policy_test_case(
#'   policyArn = "string",
#'   testCaseId = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_automated_reasoning_policy_test_case
#'
#' @aliases bedrock_delete_automated_reasoning_policy_test_case
bedrock_delete_automated_reasoning_policy_test_case <- function(policyArn, testCaseId, lastUpdatedAt) {
  op <- new_operation(
    name = "DeleteAutomatedReasoningPolicyTestCase",
    http_method = "DELETE",
    http_path = "/automated-reasoning-policies/{policyArn}/test-cases/{testCaseId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_automated_reasoning_policy_test_case_input(policyArn = policyArn, testCaseId = testCaseId, lastUpdatedAt = lastUpdatedAt)
  output <- .bedrock$delete_automated_reasoning_policy_test_case_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_automated_reasoning_policy_test_case <- bedrock_delete_automated_reasoning_policy_test_case

#' Deletes a custom model that you created earlier
#'
#' @description
#' Deletes a custom model that you created earlier. For more information,
#' see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_delete_custom_model(modelIdentifier)
#'
#' @param modelIdentifier &#91;required&#93; Name of the model to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_custom_model(
#'   modelIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_custom_model
#'
#' @aliases bedrock_delete_custom_model
bedrock_delete_custom_model <- function(modelIdentifier) {
  op <- new_operation(
    name = "DeleteCustomModel",
    http_method = "DELETE",
    http_path = "/custom-models/{modelIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_custom_model_input(modelIdentifier = modelIdentifier)
  output <- .bedrock$delete_custom_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_custom_model <- bedrock_delete_custom_model

#' Deletes a custom model deployment
#'
#' @description
#' Deletes a custom model deployment. This operation stops the deployment
#' and removes it from your account. After deletion, the deployment ARN can
#' no longer be used for inference requests.
#' 
#' The following actions are related to the
#' [`delete_custom_model_deployment`][bedrock_delete_custom_model_deployment]
#' operation:
#' 
#' -   [`create_custom_model_deployment`][bedrock_create_custom_model_deployment]
#' 
#' -   [`get_custom_model_deployment`][bedrock_get_custom_model_deployment]
#' 
#' -   [`list_custom_model_deployments`][bedrock_list_custom_model_deployments]
#'
#' @usage
#' bedrock_delete_custom_model_deployment(customModelDeploymentIdentifier)
#'
#' @param customModelDeploymentIdentifier &#91;required&#93; The Amazon Resource Name (ARN) or name of the custom model deployment to
#' delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_custom_model_deployment(
#'   customModelDeploymentIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_custom_model_deployment
#'
#' @aliases bedrock_delete_custom_model_deployment
bedrock_delete_custom_model_deployment <- function(customModelDeploymentIdentifier) {
  op <- new_operation(
    name = "DeleteCustomModelDeployment",
    http_method = "DELETE",
    http_path = "/model-customization/custom-model-deployments/{customModelDeploymentIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_custom_model_deployment_input(customModelDeploymentIdentifier = customModelDeploymentIdentifier)
  output <- .bedrock$delete_custom_model_deployment_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_custom_model_deployment <- bedrock_delete_custom_model_deployment

#' Deletes the account-level enforced guardrail configuration
#'
#' @description
#' Deletes the account-level enforced guardrail configuration.
#'
#' @usage
#' bedrock_delete_enforced_guardrail_configuration(configId)
#'
#' @param configId &#91;required&#93; Unique ID for the account enforced configuration.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_enforced_guardrail_configuration(
#'   configId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_enforced_guardrail_configuration
#'
#' @aliases bedrock_delete_enforced_guardrail_configuration
bedrock_delete_enforced_guardrail_configuration <- function(configId) {
  op <- new_operation(
    name = "DeleteEnforcedGuardrailConfiguration",
    http_method = "DELETE",
    http_path = "/enforcedGuardrailsConfiguration/{configId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_enforced_guardrail_configuration_input(configId = configId)
  output <- .bedrock$delete_enforced_guardrail_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_enforced_guardrail_configuration <- bedrock_delete_enforced_guardrail_configuration

#' Delete the model access agreement for the specified model
#'
#' @description
#' Delete the model access agreement for the specified model.
#'
#' @usage
#' bedrock_delete_foundation_model_agreement(modelId)
#'
#' @param modelId &#91;required&#93; Model Id of the model access to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_foundation_model_agreement(
#'   modelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_foundation_model_agreement
#'
#' @aliases bedrock_delete_foundation_model_agreement
bedrock_delete_foundation_model_agreement <- function(modelId) {
  op <- new_operation(
    name = "DeleteFoundationModelAgreement",
    http_method = "POST",
    http_path = "/delete-foundation-model-agreement",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_foundation_model_agreement_input(modelId = modelId)
  output <- .bedrock$delete_foundation_model_agreement_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_foundation_model_agreement <- bedrock_delete_foundation_model_agreement

#' Deletes a guardrail
#'
#' @description
#' Deletes a guardrail.
#' 
#' -   To delete a guardrail, only specify the ARN of the guardrail in the
#'     `guardrailIdentifier` field. If you delete a guardrail, all of its
#'     versions will be deleted.
#' 
#' -   To delete a version of a guardrail, specify the ARN of the guardrail
#'     in the `guardrailIdentifier` field and the version in the
#'     `guardrailVersion` field.
#'
#' @usage
#' bedrock_delete_guardrail(guardrailIdentifier, guardrailVersion)
#'
#' @param guardrailIdentifier &#91;required&#93; The unique identifier of the guardrail. This can be an ID or the ARN.
#' @param guardrailVersion The version of the guardrail.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_guardrail(
#'   guardrailIdentifier = "string",
#'   guardrailVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_guardrail
#'
#' @aliases bedrock_delete_guardrail
bedrock_delete_guardrail <- function(guardrailIdentifier, guardrailVersion = NULL) {
  op <- new_operation(
    name = "DeleteGuardrail",
    http_method = "DELETE",
    http_path = "/guardrails/{guardrailIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_guardrail_input(guardrailIdentifier = guardrailIdentifier, guardrailVersion = guardrailVersion)
  output <- .bedrock$delete_guardrail_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_guardrail <- bedrock_delete_guardrail

#' Deletes a custom model that you imported earlier
#'
#' @description
#' Deletes a custom model that you imported earlier. For more information,
#' see [Import a customized
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_delete_imported_model(modelIdentifier)
#'
#' @param modelIdentifier &#91;required&#93; Name of the imported model to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_imported_model(
#'   modelIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_imported_model
#'
#' @aliases bedrock_delete_imported_model
bedrock_delete_imported_model <- function(modelIdentifier) {
  op <- new_operation(
    name = "DeleteImportedModel",
    http_method = "DELETE",
    http_path = "/imported-models/{modelIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_imported_model_input(modelIdentifier = modelIdentifier)
  output <- .bedrock$delete_imported_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_imported_model <- bedrock_delete_imported_model

#' Deletes an application inference profile
#'
#' @description
#' Deletes an application inference profile. For more information, see
#' [Increase throughput and resilience with cross-region inference in
#' Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrock_delete_inference_profile(inferenceProfileIdentifier)
#'
#' @param inferenceProfileIdentifier &#91;required&#93; The Amazon Resource Name (ARN) or ID of the application inference
#' profile to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_inference_profile(
#'   inferenceProfileIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_inference_profile
#'
#' @aliases bedrock_delete_inference_profile
bedrock_delete_inference_profile <- function(inferenceProfileIdentifier) {
  op <- new_operation(
    name = "DeleteInferenceProfile",
    http_method = "DELETE",
    http_path = "/inference-profiles/{inferenceProfileIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_inference_profile_input(inferenceProfileIdentifier = inferenceProfileIdentifier)
  output <- .bedrock$delete_inference_profile_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_inference_profile <- bedrock_delete_inference_profile

#' Deletes an endpoint for a model from Amazon Bedrock Marketplace
#'
#' @description
#' Deletes an endpoint for a model from Amazon Bedrock Marketplace.
#'
#' @usage
#' bedrock_delete_marketplace_model_endpoint(endpointArn)
#'
#' @param endpointArn &#91;required&#93; The Amazon Resource Name (ARN) of the endpoint you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_marketplace_model_endpoint(
#'   endpointArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_marketplace_model_endpoint
#'
#' @aliases bedrock_delete_marketplace_model_endpoint
bedrock_delete_marketplace_model_endpoint <- function(endpointArn) {
  op <- new_operation(
    name = "DeleteMarketplaceModelEndpoint",
    http_method = "DELETE",
    http_path = "/marketplace-model/endpoints/{endpointArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_marketplace_model_endpoint_input(endpointArn = endpointArn)
  output <- .bedrock$delete_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_marketplace_model_endpoint <- bedrock_delete_marketplace_model_endpoint

#' Delete the invocation logging
#'
#' @description
#' Delete the invocation logging.
#'
#' @usage
#' bedrock_delete_model_invocation_logging_configuration()
#'

#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_model_invocation_logging_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_model_invocation_logging_configuration
#'
#' @aliases bedrock_delete_model_invocation_logging_configuration
bedrock_delete_model_invocation_logging_configuration <- function() {
  op <- new_operation(
    name = "DeleteModelInvocationLoggingConfiguration",
    http_method = "DELETE",
    http_path = "/logging/modelinvocations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_model_invocation_logging_configuration_input()
  output <- .bedrock$delete_model_invocation_logging_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_model_invocation_logging_configuration <- bedrock_delete_model_invocation_logging_configuration

#' Deletes a specified prompt router
#'
#' @description
#' Deletes a specified prompt router. This action cannot be undone.
#'
#' @usage
#' bedrock_delete_prompt_router(promptRouterArn)
#'
#' @param promptRouterArn &#91;required&#93; The Amazon Resource Name (ARN) of the prompt router to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_prompt_router(
#'   promptRouterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_prompt_router
#'
#' @aliases bedrock_delete_prompt_router
bedrock_delete_prompt_router <- function(promptRouterArn) {
  op <- new_operation(
    name = "DeletePromptRouter",
    http_method = "DELETE",
    http_path = "/prompt-routers/{promptRouterArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_prompt_router_input(promptRouterArn = promptRouterArn)
  output <- .bedrock$delete_prompt_router_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_prompt_router <- bedrock_delete_prompt_router

#' Deletes a Provisioned Throughput
#'
#' @description
#' Deletes a Provisioned Throughput. You can't delete a Provisioned
#' Throughput before the commitment term is over. For more information, see
#' [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_delete_provisioned_model_throughput(provisionedModelId)
#'
#' @param provisionedModelId &#91;required&#93; The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_provisioned_model_throughput(
#'   provisionedModelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_delete_provisioned_model_throughput
#'
#' @aliases bedrock_delete_provisioned_model_throughput
bedrock_delete_provisioned_model_throughput <- function(provisionedModelId) {
  op <- new_operation(
    name = "DeleteProvisionedModelThroughput",
    http_method = "DELETE",
    http_path = "/provisioned-model-throughput/{provisionedModelId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$delete_provisioned_model_throughput_input(provisionedModelId = provisionedModelId)
  output <- .bedrock$delete_provisioned_model_throughput_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$delete_provisioned_model_throughput <- bedrock_delete_provisioned_model_throughput

#' Deregisters an endpoint for a model from Amazon Bedrock Marketplace
#'
#' @description
#' Deregisters an endpoint for a model from Amazon Bedrock Marketplace.
#' This operation removes the endpoint's association with Amazon Bedrock
#' but does not delete the underlying Amazon SageMaker endpoint.
#'
#' @usage
#' bedrock_deregister_marketplace_model_endpoint(endpointArn)
#'
#' @param endpointArn &#91;required&#93; The Amazon Resource Name (ARN) of the endpoint you want to deregister.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$deregister_marketplace_model_endpoint(
#'   endpointArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_deregister_marketplace_model_endpoint
#'
#' @aliases bedrock_deregister_marketplace_model_endpoint
bedrock_deregister_marketplace_model_endpoint <- function(endpointArn) {
  op <- new_operation(
    name = "DeregisterMarketplaceModelEndpoint",
    http_method = "DELETE",
    http_path = "/marketplace-model/endpoints/{endpointArn}/registration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$deregister_marketplace_model_endpoint_input(endpointArn = endpointArn)
  output <- .bedrock$deregister_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$deregister_marketplace_model_endpoint <- bedrock_deregister_marketplace_model_endpoint

#' Exports the policy definition for an Automated Reasoning policy version
#'
#' @description
#' Exports the policy definition for an Automated Reasoning policy version.
#' Returns the complete policy definition including rules, variables, and
#' custom variable types in a structured format.
#'
#' @usage
#' bedrock_export_automated_reasoning_policy_version(policyArn)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy to
#' export. Can be either the unversioned ARN for the draft policy or a
#' versioned ARN for a specific policy version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyDefinition = list(
#'     version = "string",
#'     types = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             value = "string",
#'             description = "string"
#'           )
#'         )
#'       )
#'     ),
#'     rules = list(
#'       list(
#'         id = "string",
#'         expression = "string",
#'         alternateExpression = "string"
#'       )
#'     ),
#'     variables = list(
#'       list(
#'         name = "string",
#'         type = "string",
#'         description = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$export_automated_reasoning_policy_version(
#'   policyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_export_automated_reasoning_policy_version
#'
#' @aliases bedrock_export_automated_reasoning_policy_version
bedrock_export_automated_reasoning_policy_version <- function(policyArn) {
  op <- new_operation(
    name = "ExportAutomatedReasoningPolicyVersion",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/export",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$export_automated_reasoning_policy_version_input(policyArn = policyArn)
  output <- .bedrock$export_automated_reasoning_policy_version_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$export_automated_reasoning_policy_version <- bedrock_export_automated_reasoning_policy_version

#' Retrieves details about an Automated Reasoning policy or policy version
#'
#' @description
#' Retrieves details about an Automated Reasoning policy or policy version.
#' Returns information including the policy definition, metadata, and
#' timestamps.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy(policyArn)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy to
#' retrieve. Can be either the unversioned ARN for the draft policy or an
#' ARN for a specific policy version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   name = "string",
#'   version = "string",
#'   policyId = "string",
#'   description = "string",
#'   definitionHash = "string",
#'   kmsKeyArn = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy(
#'   policyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy
#'
#' @aliases bedrock_get_automated_reasoning_policy
bedrock_get_automated_reasoning_policy <- function(policyArn) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicy",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_input(policyArn = policyArn)
  output <- .bedrock$get_automated_reasoning_policy_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy <- bedrock_get_automated_reasoning_policy

#' Retrieves the current annotations for an Automated Reasoning policy
#' build workflow
#'
#' @description
#' Retrieves the current annotations for an Automated Reasoning policy
#' build workflow. Annotations contain corrections to the rules, variables
#' and types to be applied to the policy.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_annotations(policyArn,
#'   buildWorkflowId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' annotations you want to retrieve.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow whose annotations you want
#' to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   name = "string",
#'   buildWorkflowId = "string",
#'   annotations = list(
#'     list(
#'       addType = list(
#'         name = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             value = "string",
#'             description = "string"
#'           )
#'         )
#'       ),
#'       updateType = list(
#'         name = "string",
#'         newName = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             addTypeValue = list(
#'               value = "string",
#'               description = "string"
#'             ),
#'             updateTypeValue = list(
#'               value = "string",
#'               newValue = "string",
#'               description = "string"
#'             ),
#'             deleteTypeValue = list(
#'               value = "string"
#'             )
#'           )
#'         )
#'       ),
#'       deleteType = list(
#'         name = "string"
#'       ),
#'       addVariable = list(
#'         name = "string",
#'         type = "string",
#'         description = "string"
#'       ),
#'       updateVariable = list(
#'         name = "string",
#'         newName = "string",
#'         description = "string"
#'       ),
#'       deleteVariable = list(
#'         name = "string"
#'       ),
#'       addRule = list(
#'         expression = "string"
#'       ),
#'       updateRule = list(
#'         ruleId = "string",
#'         expression = "string"
#'       ),
#'       deleteRule = list(
#'         ruleId = "string"
#'       ),
#'       addRuleFromNaturalLanguage = list(
#'         naturalLanguage = "string"
#'       ),
#'       updateFromRulesFeedback = list(
#'         ruleIds = list(
#'           "string"
#'         ),
#'         feedback = "string"
#'       ),
#'       updateFromScenarioFeedback = list(
#'         ruleIds = list(
#'           "string"
#'         ),
#'         scenarioExpression = "string",
#'         feedback = "string"
#'       ),
#'       ingestContent = list(
#'         content = "string"
#'       )
#'     )
#'   ),
#'   annotationSetHash = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_annotations(
#'   policyArn = "string",
#'   buildWorkflowId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy_annotations
#'
#' @aliases bedrock_get_automated_reasoning_policy_annotations
bedrock_get_automated_reasoning_policy_annotations <- function(policyArn, buildWorkflowId) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyAnnotations",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/annotations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_annotations_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId)
  output <- .bedrock$get_automated_reasoning_policy_annotations_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_annotations <- bedrock_get_automated_reasoning_policy_annotations

#' Retrieves detailed information about an Automated Reasoning policy build
#' workflow, including its status, configuration, and metadata
#'
#' @description
#' Retrieves detailed information about an Automated Reasoning policy build
#' workflow, including its status, configuration, and metadata.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_build_workflow(policyArn,
#'   buildWorkflowId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' build workflow you want to retrieve.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   status = "SCHEDULED"|"CANCEL_REQUESTED"|"PREPROCESSING"|"BUILDING"|"TESTING"|"COMPLETED"|"FAILED"|"CANCELLED",
#'   buildWorkflowType = "INGEST_CONTENT"|"REFINE_POLICY"|"IMPORT_POLICY",
#'   documentName = "string",
#'   documentContentType = "pdf"|"txt",
#'   documentDescription = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_build_workflow(
#'   policyArn = "string",
#'   buildWorkflowId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy_build_workflow
#'
#' @aliases bedrock_get_automated_reasoning_policy_build_workflow
bedrock_get_automated_reasoning_policy_build_workflow <- function(policyArn, buildWorkflowId) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyBuildWorkflow",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_build_workflow_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId)
  output <- .bedrock$get_automated_reasoning_policy_build_workflow_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_build_workflow <- bedrock_get_automated_reasoning_policy_build_workflow

#' Retrieves the resulting assets from a completed Automated Reasoning
#' policy build workflow, including build logs, quality reports, and
#' generated policy artifacts
#'
#' @description
#' Retrieves the resulting assets from a completed Automated Reasoning
#' policy build workflow, including build logs, quality reports, and
#' generated policy artifacts.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_build_workflow_result_assets(
#'   policyArn, buildWorkflowId, assetType)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' build workflow assets you want to retrieve.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow whose result assets you want
#' to retrieve.
#' @param assetType &#91;required&#93; The type of asset to retrieve (e.g., BUILD_LOG, QUALITY_REPORT,
#' POLICY_DEFINITION).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   buildWorkflowAssets = list(
#'     policyDefinition = list(
#'       version = "string",
#'       types = list(
#'         list(
#'           name = "string",
#'           description = "string",
#'           values = list(
#'             list(
#'               value = "string",
#'               description = "string"
#'             )
#'           )
#'         )
#'       ),
#'       rules = list(
#'         list(
#'           id = "string",
#'           expression = "string",
#'           alternateExpression = "string"
#'         )
#'       ),
#'       variables = list(
#'         list(
#'           name = "string",
#'           type = "string",
#'           description = "string"
#'         )
#'       )
#'     ),
#'     qualityReport = list(
#'       typeCount = 123,
#'       variableCount = 123,
#'       ruleCount = 123,
#'       unusedTypes = list(
#'         "string"
#'       ),
#'       unusedTypeValues = list(
#'         list(
#'           typeName = "string",
#'           valueName = "string"
#'         )
#'       ),
#'       unusedVariables = list(
#'         "string"
#'       ),
#'       conflictingRules = list(
#'         "string"
#'       ),
#'       disjointRuleSets = list(
#'         list(
#'           variables = list(
#'             "string"
#'           ),
#'           rules = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     buildLog = list(
#'       entries = list(
#'         list(
#'           annotation = list(
#'             addType = list(
#'               name = "string",
#'               description = "string",
#'               values = list(
#'                 list(
#'                   value = "string",
#'                   description = "string"
#'                 )
#'               )
#'             ),
#'             updateType = list(
#'               name = "string",
#'               newName = "string",
#'               description = "string",
#'               values = list(
#'                 list(
#'                   addTypeValue = list(
#'                     value = "string",
#'                     description = "string"
#'                   ),
#'                   updateTypeValue = list(
#'                     value = "string",
#'                     newValue = "string",
#'                     description = "string"
#'                   ),
#'                   deleteTypeValue = list(
#'                     value = "string"
#'                   )
#'                 )
#'               )
#'             ),
#'             deleteType = list(
#'               name = "string"
#'             ),
#'             addVariable = list(
#'               name = "string",
#'               type = "string",
#'               description = "string"
#'             ),
#'             updateVariable = list(
#'               name = "string",
#'               newName = "string",
#'               description = "string"
#'             ),
#'             deleteVariable = list(
#'               name = "string"
#'             ),
#'             addRule = list(
#'               expression = "string"
#'             ),
#'             updateRule = list(
#'               ruleId = "string",
#'               expression = "string"
#'             ),
#'             deleteRule = list(
#'               ruleId = "string"
#'             ),
#'             addRuleFromNaturalLanguage = list(
#'               naturalLanguage = "string"
#'             ),
#'             updateFromRulesFeedback = list(
#'               ruleIds = list(
#'                 "string"
#'               ),
#'               feedback = "string"
#'             ),
#'             updateFromScenarioFeedback = list(
#'               ruleIds = list(
#'                 "string"
#'               ),
#'               scenarioExpression = "string",
#'               feedback = "string"
#'             ),
#'             ingestContent = list(
#'               content = "string"
#'             )
#'           ),
#'           status = "APPLIED"|"FAILED",
#'           buildSteps = list(
#'             list(
#'               context = list(
#'                 planning = list(),
#'                 mutation = list(
#'                   addType = list(
#'                     type = list(
#'                       name = "string",
#'                       description = "string",
#'                       values = list(
#'                         list(
#'                           value = "string",
#'                           description = "string"
#'                         )
#'                       )
#'                     )
#'                   ),
#'                   updateType = list(
#'                     type = list(
#'                       name = "string",
#'                       description = "string",
#'                       values = list(
#'                         list(
#'                           value = "string",
#'                           description = "string"
#'                         )
#'                       )
#'                     )
#'                   ),
#'                   deleteType = list(
#'                     name = "string"
#'                   ),
#'                   addVariable = list(
#'                     variable = list(
#'                       name = "string",
#'                       type = "string",
#'                       description = "string"
#'                     )
#'                   ),
#'                   updateVariable = list(
#'                     variable = list(
#'                       name = "string",
#'                       type = "string",
#'                       description = "string"
#'                     )
#'                   ),
#'                   deleteVariable = list(
#'                     name = "string"
#'                   ),
#'                   addRule = list(
#'                     rule = list(
#'                       id = "string",
#'                       expression = "string",
#'                       alternateExpression = "string"
#'                     )
#'                   ),
#'                   updateRule = list(
#'                     rule = list(
#'                       id = "string",
#'                       expression = "string",
#'                       alternateExpression = "string"
#'                     )
#'                   ),
#'                   deleteRule = list(
#'                     id = "string"
#'                   )
#'                 )
#'               ),
#'               priorElement = list(
#'                 policyDefinitionVariable = list(
#'                   name = "string",
#'                   type = "string",
#'                   description = "string"
#'                 ),
#'                 policyDefinitionType = list(
#'                   name = "string",
#'                   description = "string",
#'                   values = list(
#'                     list(
#'                       value = "string",
#'                       description = "string"
#'                     )
#'                   )
#'                 ),
#'                 policyDefinitionRule = list(
#'                   id = "string",
#'                   expression = "string",
#'                   alternateExpression = "string"
#'                 )
#'               ),
#'               messages = list(
#'                 list(
#'                   message = "string",
#'                   messageType = "INFO"|"WARNING"|"ERROR"
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     generatedTestCases = list(
#'       generatedTestCases = list(
#'         list(
#'           queryContent = "string",
#'           guardContent = "string",
#'           expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION"
#'         )
#'       )
#'     ),
#'     policyScenarios = list(
#'       policyScenarios = list(
#'         list(
#'           expression = "string",
#'           alternateExpression = "string",
#'           expectedResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'           ruleIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_build_workflow_result_assets(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   assetType = "BUILD_LOG"|"QUALITY_REPORT"|"POLICY_DEFINITION"|"GENERATED_TEST_CASES"|"POLICY_SCENARIOS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_autom_reaso_polic_build_workf_resul_asset
#'
#' @aliases bedrock_get_automated_reasoning_policy_build_workflow_result_assets
bedrock_get_automated_reasoning_policy_build_workflow_result_assets <- function(policyArn, buildWorkflowId, assetType) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyBuildWorkflowResultAssets",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/result-assets",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_build_workflow_result_assets_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, assetType = assetType)
  output <- .bedrock$get_automated_reasoning_policy_build_workflow_result_assets_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_build_workflow_result_assets <- bedrock_get_automated_reasoning_policy_build_workflow_result_assets

#' Retrieves the next test scenario for validating an Automated Reasoning
#' policy
#'
#' @description
#' Retrieves the next test scenario for validating an Automated Reasoning
#' policy. This is used during the interactive policy refinement process to
#' test policy behavior.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_next_scenario(policyArn,
#'   buildWorkflowId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy for
#' which you want to get the next test scenario.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow associated with the test
#' scenarios.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   scenario = list(
#'     expression = "string",
#'     alternateExpression = "string",
#'     expectedResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'     ruleIds = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_next_scenario(
#'   policyArn = "string",
#'   buildWorkflowId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy_next_scenario
#'
#' @aliases bedrock_get_automated_reasoning_policy_next_scenario
bedrock_get_automated_reasoning_policy_next_scenario <- function(policyArn, buildWorkflowId) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyNextScenario",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/scenarios",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_next_scenario_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId)
  output <- .bedrock$get_automated_reasoning_policy_next_scenario_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_next_scenario <- bedrock_get_automated_reasoning_policy_next_scenario

#' Retrieves details about a specific Automated Reasoning policy test
#'
#' @description
#' Retrieves details about a specific Automated Reasoning policy test.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_test_case(policyArn, testCaseId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy that
#' contains the test.
#' @param testCaseId &#91;required&#93; The unique identifier of the test to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   testCase = list(
#'     testCaseId = "string",
#'     guardContent = "string",
#'     queryContent = "string",
#'     expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     confidenceThreshold = 123.0
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_test_case(
#'   policyArn = "string",
#'   testCaseId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy_test_case
#'
#' @aliases bedrock_get_automated_reasoning_policy_test_case
bedrock_get_automated_reasoning_policy_test_case <- function(policyArn, testCaseId) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyTestCase",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/test-cases/{testCaseId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_test_case_input(policyArn = policyArn, testCaseId = testCaseId)
  output <- .bedrock$get_automated_reasoning_policy_test_case_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_test_case <- bedrock_get_automated_reasoning_policy_test_case

#' Retrieves the test result for a specific Automated Reasoning policy test
#'
#' @description
#' Retrieves the test result for a specific Automated Reasoning policy
#' test. Returns detailed validation findings and execution status.
#'
#' @usage
#' bedrock_get_automated_reasoning_policy_test_result(policyArn,
#'   buildWorkflowId, testCaseId)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy.
#' @param buildWorkflowId &#91;required&#93; The build workflow identifier. The build workflow must display a
#' `COMPLETED` status to get results.
#' @param testCaseId &#91;required&#93; The unique identifier of the test for which to retrieve results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   testResult = list(
#'     testCase = list(
#'       testCaseId = "string",
#'       guardContent = "string",
#'       queryContent = "string",
#'       expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       confidenceThreshold = 123.0
#'     ),
#'     policyArn = "string",
#'     testRunStatus = "NOT_STARTED"|"SCHEDULED"|"IN_PROGRESS"|"COMPLETED"|"FAILED",
#'     testFindings = list(
#'       list(
#'         valid = list(
#'           translation = list(
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             untranslatedPremises = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             untranslatedClaims = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             confidence = 123.0
#'           ),
#'           claimsTrueScenario = list(
#'             statements = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           ),
#'           supportingRules = list(
#'             list(
#'               id = "string",
#'               policyVersionArn = "string"
#'             )
#'           ),
#'           logicWarning = list(
#'             type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           )
#'         ),
#'         invalid = list(
#'           translation = list(
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             untranslatedPremises = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             untranslatedClaims = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             confidence = 123.0
#'           ),
#'           contradictingRules = list(
#'             list(
#'               id = "string",
#'               policyVersionArn = "string"
#'             )
#'           ),
#'           logicWarning = list(
#'             type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           )
#'         ),
#'         satisfiable = list(
#'           translation = list(
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             untranslatedPremises = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             untranslatedClaims = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             confidence = 123.0
#'           ),
#'           claimsTrueScenario = list(
#'             statements = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           ),
#'           claimsFalseScenario = list(
#'             statements = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           ),
#'           logicWarning = list(
#'             type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           )
#'         ),
#'         impossible = list(
#'           translation = list(
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             untranslatedPremises = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             untranslatedClaims = list(
#'               list(
#'                 text = "string"
#'               )
#'             ),
#'             confidence = 123.0
#'           ),
#'           contradictingRules = list(
#'             list(
#'               id = "string",
#'               policyVersionArn = "string"
#'             )
#'           ),
#'           logicWarning = list(
#'             type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'             premises = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             ),
#'             claims = list(
#'               list(
#'                 logic = "string",
#'                 naturalLanguage = "string"
#'               )
#'             )
#'           )
#'         ),
#'         translationAmbiguous = list(
#'           options = list(
#'             list(
#'               translations = list(
#'                 list(
#'                   premises = list(
#'                     list(
#'                       logic = "string",
#'                       naturalLanguage = "string"
#'                     )
#'                   ),
#'                   claims = list(
#'                     list(
#'                       logic = "string",
#'                       naturalLanguage = "string"
#'                     )
#'                   ),
#'                   untranslatedPremises = list(
#'                     list(
#'                       text = "string"
#'                     )
#'                   ),
#'                   untranslatedClaims = list(
#'                     list(
#'                       text = "string"
#'                     )
#'                   ),
#'                   confidence = 123.0
#'                 )
#'               )
#'             )
#'           ),
#'           differenceScenarios = list(
#'             list(
#'               statements = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         tooComplex = list(),
#'         noTranslations = list()
#'       )
#'     ),
#'     testRunResult = "PASSED"|"FAILED",
#'     aggregatedTestFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_automated_reasoning_policy_test_result(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   testCaseId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_automated_reasoning_policy_test_result
#'
#' @aliases bedrock_get_automated_reasoning_policy_test_result
bedrock_get_automated_reasoning_policy_test_result <- function(policyArn, buildWorkflowId, testCaseId) {
  op <- new_operation(
    name = "GetAutomatedReasoningPolicyTestResult",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/test-cases/{testCaseId}/test-results",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_automated_reasoning_policy_test_result_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, testCaseId = testCaseId)
  output <- .bedrock$get_automated_reasoning_policy_test_result_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_automated_reasoning_policy_test_result <- bedrock_get_automated_reasoning_policy_test_result

#' Get the properties associated with a Amazon Bedrock custom model that
#' you have created
#'
#' @description
#' Get the properties associated with a Amazon Bedrock custom model that
#' you have created. For more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_get_custom_model(modelIdentifier)
#'
#' @param modelIdentifier &#91;required&#93; Name or Amazon Resource Name (ARN) of the custom model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelArn = "string",
#'   modelName = "string",
#'   jobName = "string",
#'   jobArn = "string",
#'   baseModelArn = "string",
#'   customizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"|"REINFORCEMENT_FINE_TUNING"|"IMPORTED",
#'   modelKmsKeyArn = "string",
#'   hyperParameters = list(
#'     "string"
#'   ),
#'   trainingDataConfig = list(
#'     s3Uri = "string",
#'     invocationLogsConfig = list(
#'       usePromptResponse = TRUE|FALSE,
#'       invocationLogSource = list(
#'         s3Uri = "string"
#'       ),
#'       requestMetadataFilters = list(
#'         equals = list(
#'           "string"
#'         ),
#'         notEquals = list(
#'           "string"
#'         ),
#'         andAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         orAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   validationDataConfig = list(
#'     validators = list(
#'       list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3Uri = "string"
#'   ),
#'   trainingMetrics = list(
#'     trainingLoss = 123.0
#'   ),
#'   validationMetrics = list(
#'     list(
#'       validationLoss = 123.0
#'     )
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   customizationConfig = list(
#'     distillationConfig = list(
#'       teacherModelConfig = list(
#'         teacherModelIdentifier = "string",
#'         maxResponseLengthForInference = 123
#'       )
#'     ),
#'     rftConfig = list(
#'       graderConfig = list(
#'         lambdaGrader = list(
#'           lambdaArn = "string"
#'         )
#'       ),
#'       hyperParameters = list(
#'         epochCount = 123,
#'         batchSize = 123,
#'         learningRate = 123.0,
#'         maxPromptLength = 123,
#'         trainingSamplePerPrompt = 123,
#'         inferenceMaxTokens = 123,
#'         reasoningEffort = "low"|"medium"|"high",
#'         evalInterval = 123
#'       )
#'     )
#'   ),
#'   modelStatus = "Active"|"Creating"|"Failed",
#'   failureMessage = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_custom_model(
#'   modelIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_custom_model
#'
#' @aliases bedrock_get_custom_model
bedrock_get_custom_model <- function(modelIdentifier) {
  op <- new_operation(
    name = "GetCustomModel",
    http_method = "GET",
    http_path = "/custom-models/{modelIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_custom_model_input(modelIdentifier = modelIdentifier)
  output <- .bedrock$get_custom_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_custom_model <- bedrock_get_custom_model

#' Retrieves information about a custom model deployment, including its
#' status, configuration, and metadata
#'
#' @description
#' Retrieves information about a custom model deployment, including its
#' status, configuration, and metadata. Use this operation to monitor the
#' deployment status and retrieve details needed for inference requests.
#' 
#' The following actions are related to the
#' [`get_custom_model_deployment`][bedrock_get_custom_model_deployment]
#' operation:
#' 
#' -   [`create_custom_model_deployment`][bedrock_create_custom_model_deployment]
#' 
#' -   [`list_custom_model_deployments`][bedrock_list_custom_model_deployments]
#' 
#' -   [`delete_custom_model_deployment`][bedrock_delete_custom_model_deployment]
#'
#' @usage
#' bedrock_get_custom_model_deployment(customModelDeploymentIdentifier)
#'
#' @param customModelDeploymentIdentifier &#91;required&#93; The Amazon Resource Name (ARN) or name of the custom model deployment to
#' retrieve information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   customModelDeploymentArn = "string",
#'   modelDeploymentName = "string",
#'   modelArn = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   status = "Creating"|"Active"|"Failed",
#'   description = "string",
#'   updateDetails = list(
#'     modelArn = "string",
#'     updateStatus = "Updating"|"UpdateCompleted"|"UpdateFailed"
#'   ),
#'   failureMessage = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_custom_model_deployment(
#'   customModelDeploymentIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_custom_model_deployment
#'
#' @aliases bedrock_get_custom_model_deployment
bedrock_get_custom_model_deployment <- function(customModelDeploymentIdentifier) {
  op <- new_operation(
    name = "GetCustomModelDeployment",
    http_method = "GET",
    http_path = "/model-customization/custom-model-deployments/{customModelDeploymentIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_custom_model_deployment_input(customModelDeploymentIdentifier = customModelDeploymentIdentifier)
  output <- .bedrock$get_custom_model_deployment_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_custom_model_deployment <- bedrock_get_custom_model_deployment

#' Gets information about an evaluation job, such as the status of the job
#'
#' @description
#' Gets information about an evaluation job, such as the status of the job.
#'
#' @usage
#' bedrock_get_evaluation_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; The Amazon Resource Name (ARN) of the evaluation job you want get
#' information on.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobName = "string",
#'   status = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"Deleting",
#'   jobArn = "string",
#'   jobDescription = "string",
#'   roleArn = "string",
#'   customerEncryptionKeyId = "string",
#'   jobType = "Human"|"Automated",
#'   applicationType = "ModelEvaluation"|"RagEvaluation",
#'   evaluationConfig = list(
#'     automated = list(
#'       datasetMetricConfigs = list(
#'         list(
#'           taskType = "Summarization"|"Classification"|"QuestionAndAnswer"|"Generation"|"Custom",
#'           dataset = list(
#'             name = "string",
#'             datasetLocation = list(
#'               s3Uri = "string"
#'             )
#'           ),
#'           metricNames = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       evaluatorModelConfig = list(
#'         bedrockEvaluatorModels = list(
#'           list(
#'             modelIdentifier = "string"
#'           )
#'         )
#'       ),
#'       customMetricConfig = list(
#'         customMetrics = list(
#'           list(
#'             customMetricDefinition = list(
#'               name = "string",
#'               instructions = "string",
#'               ratingScale = list(
#'                 list(
#'                   definition = "string",
#'                   value = list(
#'                     stringValue = "string",
#'                     floatValue = 123.0
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         evaluatorModelConfig = list(
#'           bedrockEvaluatorModels = list(
#'             list(
#'               modelIdentifier = "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     human = list(
#'       humanWorkflowConfig = list(
#'         flowDefinitionArn = "string",
#'         instructions = "string"
#'       ),
#'       customMetrics = list(
#'         list(
#'           name = "string",
#'           description = "string",
#'           ratingMethod = "string"
#'         )
#'       ),
#'       datasetMetricConfigs = list(
#'         list(
#'           taskType = "Summarization"|"Classification"|"QuestionAndAnswer"|"Generation"|"Custom",
#'           dataset = list(
#'             name = "string",
#'             datasetLocation = list(
#'               s3Uri = "string"
#'             )
#'           ),
#'           metricNames = list(
#'             "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   inferenceConfig = list(
#'     models = list(
#'       list(
#'         bedrockModel = list(
#'           modelIdentifier = "string",
#'           inferenceParams = "string",
#'           performanceConfig = list(
#'             latency = "standard"|"optimized"
#'           )
#'         ),
#'         precomputedInferenceSource = list(
#'           inferenceSourceIdentifier = "string"
#'         )
#'       )
#'     ),
#'     ragConfigs = list(
#'       list(
#'         knowledgeBaseConfig = list(
#'           retrieveConfig = list(
#'             knowledgeBaseId = "string",
#'             knowledgeBaseRetrievalConfiguration = list(
#'               vectorSearchConfiguration = list(
#'                 numberOfResults = 123,
#'                 overrideSearchType = "HYBRID"|"SEMANTIC",
#'                 filter = list(
#'                   equals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   notEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   greaterThan = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   greaterThanOrEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   lessThan = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   lessThanOrEquals = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   in = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   notIn = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   startsWith = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   listContains = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   stringContains = list(
#'                     key = "string",
#'                     value = list()
#'                   ),
#'                   andAll = list(
#'                     list()
#'                   ),
#'                   orAll = list(
#'                     list()
#'                   )
#'                 ),
#'                 implicitFilterConfiguration = list(
#'                   metadataAttributes = list(
#'                     list(
#'                       key = "string",
#'                       type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST",
#'                       description = "string"
#'                     )
#'                   ),
#'                   modelArn = "string"
#'                 ),
#'                 rerankingConfiguration = list(
#'                   type = "BEDROCK_RERANKING_MODEL",
#'                   bedrockRerankingConfiguration = list(
#'                     modelConfiguration = list(
#'                       modelArn = "string",
#'                       additionalModelRequestFields = list(
#'                         list()
#'                       )
#'                     ),
#'                     numberOfRerankedResults = 123,
#'                     metadataConfiguration = list(
#'                       selectionMode = "SELECTIVE"|"ALL",
#'                       selectiveModeConfiguration = list(
#'                         fieldsToInclude = list(
#'                           list(
#'                             fieldName = "string"
#'                           )
#'                         ),
#'                         fieldsToExclude = list(
#'                           list(
#'                             fieldName = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           retrieveAndGenerateConfig = list(
#'             type = "KNOWLEDGE_BASE"|"EXTERNAL_SOURCES",
#'             knowledgeBaseConfiguration = list(
#'               knowledgeBaseId = "string",
#'               modelArn = "string",
#'               retrievalConfiguration = list(
#'                 vectorSearchConfiguration = list(
#'                   numberOfResults = 123,
#'                   overrideSearchType = "HYBRID"|"SEMANTIC",
#'                   filter = list(
#'                     equals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     notEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     greaterThan = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     greaterThanOrEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     lessThan = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     lessThanOrEquals = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     in = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     notIn = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     startsWith = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     listContains = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     stringContains = list(
#'                       key = "string",
#'                       value = list()
#'                     ),
#'                     andAll = list(
#'                       list()
#'                     ),
#'                     orAll = list(
#'                       list()
#'                     )
#'                   ),
#'                   implicitFilterConfiguration = list(
#'                     metadataAttributes = list(
#'                       list(
#'                         key = "string",
#'                         type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST",
#'                         description = "string"
#'                       )
#'                     ),
#'                     modelArn = "string"
#'                   ),
#'                   rerankingConfiguration = list(
#'                     type = "BEDROCK_RERANKING_MODEL",
#'                     bedrockRerankingConfiguration = list(
#'                       modelConfiguration = list(
#'                         modelArn = "string",
#'                         additionalModelRequestFields = list(
#'                           list()
#'                         )
#'                       ),
#'                       numberOfRerankedResults = 123,
#'                       metadataConfiguration = list(
#'                         selectionMode = "SELECTIVE"|"ALL",
#'                         selectiveModeConfiguration = list(
#'                           fieldsToInclude = list(
#'                             list(
#'                               fieldName = "string"
#'                             )
#'                           ),
#'                           fieldsToExclude = list(
#'                             list(
#'                               fieldName = "string"
#'                             )
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 )
#'               ),
#'               generationConfiguration = list(
#'                 promptTemplate = list(
#'                   textPromptTemplate = "string"
#'                 ),
#'                 guardrailConfiguration = list(
#'                   guardrailId = "string",
#'                   guardrailVersion = "string"
#'                 ),
#'                 kbInferenceConfig = list(
#'                   textInferenceConfig = list(
#'                     temperature = 123.0,
#'                     topP = 123.0,
#'                     maxTokens = 123,
#'                     stopSequences = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 )
#'               ),
#'               orchestrationConfiguration = list(
#'                 queryTransformationConfiguration = list(
#'                   type = "QUERY_DECOMPOSITION"
#'                 )
#'               )
#'             ),
#'             externalSourcesConfiguration = list(
#'               modelArn = "string",
#'               sources = list(
#'                 list(
#'                   sourceType = "S3"|"BYTE_CONTENT",
#'                   s3Location = list(
#'                     uri = "string"
#'                   ),
#'                   byteContent = list(
#'                     identifier = "string",
#'                     contentType = "string",
#'                     data = raw
#'                   )
#'                 )
#'               ),
#'               generationConfiguration = list(
#'                 promptTemplate = list(
#'                   textPromptTemplate = "string"
#'                 ),
#'                 guardrailConfiguration = list(
#'                   guardrailId = "string",
#'                   guardrailVersion = "string"
#'                 ),
#'                 kbInferenceConfig = list(
#'                   textInferenceConfig = list(
#'                     temperature = 123.0,
#'                     topP = 123.0,
#'                     maxTokens = 123,
#'                     stopSequences = list(
#'                       "string"
#'                     )
#'                   )
#'                 ),
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 )
#'               )
#'             )
#'           )
#'         ),
#'         precomputedRagSourceConfig = list(
#'           retrieveSourceConfig = list(
#'             ragSourceIdentifier = "string"
#'           ),
#'           retrieveAndGenerateSourceConfig = list(
#'             ragSourceIdentifier = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3Uri = "string"
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   failureMessages = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_evaluation_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_evaluation_job
#'
#' @aliases bedrock_get_evaluation_job
bedrock_get_evaluation_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "GetEvaluationJob",
    http_method = "GET",
    http_path = "/evaluation-jobs/{jobIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_evaluation_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$get_evaluation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_evaluation_job <- bedrock_get_evaluation_job

#' Get details about a Amazon Bedrock foundation model
#'
#' @description
#' Get details about a Amazon Bedrock foundation model.
#'
#' @usage
#' bedrock_get_foundation_model(modelIdentifier)
#'
#' @param modelIdentifier &#91;required&#93; The model identifier.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelDetails = list(
#'     modelArn = "string",
#'     modelId = "string",
#'     modelName = "string",
#'     providerName = "string",
#'     inputModalities = list(
#'       "TEXT"|"IMAGE"|"EMBEDDING"
#'     ),
#'     outputModalities = list(
#'       "TEXT"|"IMAGE"|"EMBEDDING"
#'     ),
#'     responseStreamingSupported = TRUE|FALSE,
#'     customizationsSupported = list(
#'       "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"
#'     ),
#'     inferenceTypesSupported = list(
#'       "ON_DEMAND"|"PROVISIONED"
#'     ),
#'     modelLifecycle = list(
#'       status = "ACTIVE"|"LEGACY"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_foundation_model(
#'   modelIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_foundation_model
#'
#' @aliases bedrock_get_foundation_model
bedrock_get_foundation_model <- function(modelIdentifier) {
  op <- new_operation(
    name = "GetFoundationModel",
    http_method = "GET",
    http_path = "/foundation-models/{modelIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_foundation_model_input(modelIdentifier = modelIdentifier)
  output <- .bedrock$get_foundation_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_foundation_model <- bedrock_get_foundation_model

#' Get information about the Foundation model availability
#'
#' @description
#' Get information about the Foundation model availability.
#'
#' @usage
#' bedrock_get_foundation_model_availability(modelId)
#'
#' @param modelId &#91;required&#93; The model Id of the foundation model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelId = "string",
#'   agreementAvailability = list(
#'     status = "AVAILABLE"|"PENDING"|"NOT_AVAILABLE"|"ERROR",
#'     errorMessage = "string"
#'   ),
#'   authorizationStatus = "AUTHORIZED"|"NOT_AUTHORIZED",
#'   entitlementAvailability = "AVAILABLE"|"NOT_AVAILABLE",
#'   regionAvailability = "AVAILABLE"|"NOT_AVAILABLE"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_foundation_model_availability(
#'   modelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_foundation_model_availability
#'
#' @aliases bedrock_get_foundation_model_availability
bedrock_get_foundation_model_availability <- function(modelId) {
  op <- new_operation(
    name = "GetFoundationModelAvailability",
    http_method = "GET",
    http_path = "/foundation-model-availability/{modelId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_foundation_model_availability_input(modelId = modelId)
  output <- .bedrock$get_foundation_model_availability_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_foundation_model_availability <- bedrock_get_foundation_model_availability

#' Gets details about a guardrail
#'
#' @description
#' Gets details about a guardrail. If you don't specify a version, the
#' response returns details for the `DRAFT` version.
#'
#' @usage
#' bedrock_get_guardrail(guardrailIdentifier, guardrailVersion)
#'
#' @param guardrailIdentifier &#91;required&#93; The unique identifier of the guardrail for which to get details. This
#' can be an ID or the ARN.
#' @param guardrailVersion The version of the guardrail for which to get details. If you don't
#' specify a version, the response returns details for the `DRAFT` version.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   name = "string",
#'   description = "string",
#'   guardrailId = "string",
#'   guardrailArn = "string",
#'   version = "string",
#'   status = "CREATING"|"UPDATING"|"VERSIONING"|"READY"|"FAILED"|"DELETING",
#'   topicPolicy = list(
#'     topics = list(
#'       list(
#'         name = "string",
#'         definition = "string",
#'         examples = list(
#'           "string"
#'         ),
#'         type = "DENY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tier = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   contentPolicy = list(
#'     filters = list(
#'       list(
#'         type = "SEXUAL"|"VIOLENCE"|"HATE"|"INSULTS"|"MISCONDUCT"|"PROMPT_ATTACK",
#'         inputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         outputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         inputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         outputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tier = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   wordPolicy = list(
#'     words = list(
#'       list(
#'         text = "string",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     managedWordLists = list(
#'       list(
#'         type = "PROFANITY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   sensitiveInformationPolicy = list(
#'     piiEntities = list(
#'       list(
#'         type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     regexes = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         pattern = "string",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   contextualGroundingPolicy = list(
#'     filters = list(
#'       list(
#'         type = "GROUNDING"|"RELEVANCE",
#'         threshold = 123.0,
#'         action = "BLOCK"|"NONE",
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   automatedReasoningPolicy = list(
#'     policies = list(
#'       "string"
#'     ),
#'     confidenceThreshold = 123.0
#'   ),
#'   crossRegionDetails = list(
#'     guardrailProfileId = "string",
#'     guardrailProfileArn = "string"
#'   ),
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusReasons = list(
#'     "string"
#'   ),
#'   failureRecommendations = list(
#'     "string"
#'   ),
#'   blockedInputMessaging = "string",
#'   blockedOutputsMessaging = "string",
#'   kmsKeyArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_guardrail(
#'   guardrailIdentifier = "string",
#'   guardrailVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_guardrail
#'
#' @aliases bedrock_get_guardrail
bedrock_get_guardrail <- function(guardrailIdentifier, guardrailVersion = NULL) {
  op <- new_operation(
    name = "GetGuardrail",
    http_method = "GET",
    http_path = "/guardrails/{guardrailIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_guardrail_input(guardrailIdentifier = guardrailIdentifier, guardrailVersion = guardrailVersion)
  output <- .bedrock$get_guardrail_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_guardrail <- bedrock_get_guardrail

#' Gets properties associated with a customized model you imported
#'
#' @description
#' Gets properties associated with a customized model you imported.
#'
#' @usage
#' bedrock_get_imported_model(modelIdentifier)
#'
#' @param modelIdentifier &#91;required&#93; Name or Amazon Resource Name (ARN) of the imported model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelArn = "string",
#'   modelName = "string",
#'   jobName = "string",
#'   jobArn = "string",
#'   modelDataSource = list(
#'     s3DataSource = list(
#'       s3Uri = "string"
#'     )
#'   ),
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   modelArchitecture = "string",
#'   modelKmsKeyArn = "string",
#'   instructSupported = TRUE|FALSE,
#'   customModelUnits = list(
#'     customModelUnitsPerModelCopy = 123,
#'     customModelUnitsVersion = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_imported_model(
#'   modelIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_imported_model
#'
#' @aliases bedrock_get_imported_model
bedrock_get_imported_model <- function(modelIdentifier) {
  op <- new_operation(
    name = "GetImportedModel",
    http_method = "GET",
    http_path = "/imported-models/{modelIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_imported_model_input(modelIdentifier = modelIdentifier)
  output <- .bedrock$get_imported_model_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_imported_model <- bedrock_get_imported_model

#' Gets information about an inference profile
#'
#' @description
#' Gets information about an inference profile. For more information, see
#' [Increase throughput and resilience with cross-region inference in
#' Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrock_get_inference_profile(inferenceProfileIdentifier)
#'
#' @param inferenceProfileIdentifier &#91;required&#93; The ID or Amazon Resource Name (ARN) of the inference profile.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   inferenceProfileName = "string",
#'   description = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   inferenceProfileArn = "string",
#'   models = list(
#'     list(
#'       modelArn = "string"
#'     )
#'   ),
#'   inferenceProfileId = "string",
#'   status = "ACTIVE",
#'   type = "SYSTEM_DEFINED"|"APPLICATION"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_inference_profile(
#'   inferenceProfileIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_inference_profile
#'
#' @aliases bedrock_get_inference_profile
bedrock_get_inference_profile <- function(inferenceProfileIdentifier) {
  op <- new_operation(
    name = "GetInferenceProfile",
    http_method = "GET",
    http_path = "/inference-profiles/{inferenceProfileIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_inference_profile_input(inferenceProfileIdentifier = inferenceProfileIdentifier)
  output <- .bedrock$get_inference_profile_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_inference_profile <- bedrock_get_inference_profile

#' Retrieves details about a specific endpoint for a model from Amazon
#' Bedrock Marketplace
#'
#' @description
#' Retrieves details about a specific endpoint for a model from Amazon
#' Bedrock Marketplace.
#'
#' @usage
#' bedrock_get_marketplace_model_endpoint(endpointArn)
#'
#' @param endpointArn &#91;required&#93; The Amazon Resource Name (ARN) of the endpoint you want to get
#' information about.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   marketplaceModelEndpoint = list(
#'     endpointArn = "string",
#'     modelSourceIdentifier = "string",
#'     status = "REGISTERED"|"INCOMPATIBLE_ENDPOINT",
#'     statusMessage = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endpointConfig = list(
#'       sageMaker = list(
#'         initialInstanceCount = 123,
#'         instanceType = "string",
#'         executionRole = "string",
#'         kmsEncryptionKey = "string",
#'         vpc = list(
#'           subnetIds = list(
#'             "string"
#'           ),
#'           securityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     endpointStatus = "string",
#'     endpointStatusMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_marketplace_model_endpoint(
#'   endpointArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_marketplace_model_endpoint
#'
#' @aliases bedrock_get_marketplace_model_endpoint
bedrock_get_marketplace_model_endpoint <- function(endpointArn) {
  op <- new_operation(
    name = "GetMarketplaceModelEndpoint",
    http_method = "GET",
    http_path = "/marketplace-model/endpoints/{endpointArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_marketplace_model_endpoint_input(endpointArn = endpointArn)
  output <- .bedrock$get_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_marketplace_model_endpoint <- bedrock_get_marketplace_model_endpoint

#' Retrieves information about a model copy job
#'
#' @description
#' Retrieves information about a model copy job. For more information, see
#' [Copy models to be used in other
#' regions](https://docs.aws.amazon.com/bedrock/latest/userguide/copy-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_get_model_copy_job(jobArn)
#'
#' @param jobArn &#91;required&#93; The Amazon Resource Name (ARN) of the model copy job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string",
#'   status = "InProgress"|"Completed"|"Failed",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   targetModelArn = "string",
#'   targetModelName = "string",
#'   sourceAccountId = "string",
#'   sourceModelArn = "string",
#'   targetModelKmsKeyArn = "string",
#'   targetModelTags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   ),
#'   failureMessage = "string",
#'   sourceModelName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_model_copy_job(
#'   jobArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_model_copy_job
#'
#' @aliases bedrock_get_model_copy_job
bedrock_get_model_copy_job <- function(jobArn) {
  op <- new_operation(
    name = "GetModelCopyJob",
    http_method = "GET",
    http_path = "/model-copy-jobs/{jobArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_model_copy_job_input(jobArn = jobArn)
  output <- .bedrock$get_model_copy_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_model_copy_job <- bedrock_get_model_copy_job

#' Retrieves the properties associated with a model-customization job,
#' including the status of the job
#'
#' @description
#' Retrieves the properties associated with a model-customization job,
#' including the status of the job. For more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_get_model_customization_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; Identifier for the customization job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string",
#'   jobName = "string",
#'   outputModelName = "string",
#'   outputModelArn = "string",
#'   clientRequestToken = "string",
#'   roleArn = "string",
#'   status = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped",
#'   statusDetails = list(
#'     validationDetails = list(
#'       status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     dataProcessingDetails = list(
#'       status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     ),
#'     trainingDetails = list(
#'       status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   failureMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   baseModelArn = "string",
#'   hyperParameters = list(
#'     "string"
#'   ),
#'   trainingDataConfig = list(
#'     s3Uri = "string",
#'     invocationLogsConfig = list(
#'       usePromptResponse = TRUE|FALSE,
#'       invocationLogSource = list(
#'         s3Uri = "string"
#'       ),
#'       requestMetadataFilters = list(
#'         equals = list(
#'           "string"
#'         ),
#'         notEquals = list(
#'           "string"
#'         ),
#'         andAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         orAll = list(
#'           list(
#'             equals = list(
#'               "string"
#'             ),
#'             notEquals = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   validationDataConfig = list(
#'     validators = list(
#'       list(
#'         s3Uri = "string"
#'       )
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3Uri = "string"
#'   ),
#'   customizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"|"REINFORCEMENT_FINE_TUNING"|"IMPORTED",
#'   outputModelKmsKeyArn = "string",
#'   trainingMetrics = list(
#'     trainingLoss = 123.0
#'   ),
#'   validationMetrics = list(
#'     list(
#'       validationLoss = 123.0
#'     )
#'   ),
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   customizationConfig = list(
#'     distillationConfig = list(
#'       teacherModelConfig = list(
#'         teacherModelIdentifier = "string",
#'         maxResponseLengthForInference = 123
#'       )
#'     ),
#'     rftConfig = list(
#'       graderConfig = list(
#'         lambdaGrader = list(
#'           lambdaArn = "string"
#'         )
#'       ),
#'       hyperParameters = list(
#'         epochCount = 123,
#'         batchSize = 123,
#'         learningRate = 123.0,
#'         maxPromptLength = 123,
#'         trainingSamplePerPrompt = 123,
#'         inferenceMaxTokens = 123,
#'         reasoningEffort = "low"|"medium"|"high",
#'         evalInterval = 123
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_model_customization_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_model_customization_job
#'
#' @aliases bedrock_get_model_customization_job
bedrock_get_model_customization_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "GetModelCustomizationJob",
    http_method = "GET",
    http_path = "/model-customization-jobs/{jobIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_model_customization_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$get_model_customization_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_model_customization_job <- bedrock_get_model_customization_job

#' Retrieves the properties associated with import model job, including the
#' status of the job
#'
#' @description
#' Retrieves the properties associated with import model job, including the
#' status of the job. For more information, see [Import a customized
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_get_model_import_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; The identifier of the import job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string",
#'   jobName = "string",
#'   importedModelName = "string",
#'   importedModelArn = "string",
#'   roleArn = "string",
#'   modelDataSource = list(
#'     s3DataSource = list(
#'       s3Uri = "string"
#'     )
#'   ),
#'   status = "InProgress"|"Completed"|"Failed",
#'   failureMessage = "string",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   importedModelKmsKeyArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_model_import_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_model_import_job
#'
#' @aliases bedrock_get_model_import_job
bedrock_get_model_import_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "GetModelImportJob",
    http_method = "GET",
    http_path = "/model-import-jobs/{jobIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_model_import_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$get_model_import_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_model_import_job <- bedrock_get_model_import_job

#' Gets details about a batch inference job
#'
#' @description
#' Gets details about a batch inference job. For more information, see
#' [Monitor batch inference
#' jobs](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-monitor.html)
#'
#' @usage
#' bedrock_get_model_invocation_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; The Amazon Resource Name (ARN) of the batch inference job.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobArn = "string",
#'   jobName = "string",
#'   modelId = "string",
#'   clientRequestToken = "string",
#'   roleArn = "string",
#'   status = "Submitted"|"InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"PartiallyCompleted"|"Expired"|"Validating"|"Scheduled",
#'   message = "string",
#'   submitTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   inputDataConfig = list(
#'     s3InputDataConfig = list(
#'       s3InputFormat = "JSONL",
#'       s3Uri = "string",
#'       s3BucketOwner = "string"
#'     )
#'   ),
#'   outputDataConfig = list(
#'     s3OutputDataConfig = list(
#'       s3Uri = "string",
#'       s3EncryptionKeyId = "string",
#'       s3BucketOwner = "string"
#'     )
#'   ),
#'   vpcConfig = list(
#'     subnetIds = list(
#'       "string"
#'     ),
#'     securityGroupIds = list(
#'       "string"
#'     )
#'   ),
#'   timeoutDurationInHours = 123,
#'   jobExpirationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_model_invocation_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_model_invocation_job
#'
#' @aliases bedrock_get_model_invocation_job
bedrock_get_model_invocation_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "GetModelInvocationJob",
    http_method = "GET",
    http_path = "/model-invocation-job/{jobIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_model_invocation_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$get_model_invocation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_model_invocation_job <- bedrock_get_model_invocation_job

#' Get the current configuration values for model invocation logging
#'
#' @description
#' Get the current configuration values for model invocation logging.
#'
#' @usage
#' bedrock_get_model_invocation_logging_configuration()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   loggingConfig = list(
#'     cloudWatchConfig = list(
#'       logGroupName = "string",
#'       roleArn = "string",
#'       largeDataDeliveryS3Config = list(
#'         bucketName = "string",
#'         keyPrefix = "string"
#'       )
#'     ),
#'     s3Config = list(
#'       bucketName = "string",
#'       keyPrefix = "string"
#'     ),
#'     textDataDeliveryEnabled = TRUE|FALSE,
#'     imageDataDeliveryEnabled = TRUE|FALSE,
#'     embeddingDataDeliveryEnabled = TRUE|FALSE,
#'     videoDataDeliveryEnabled = TRUE|FALSE,
#'     audioDataDeliveryEnabled = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_model_invocation_logging_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_model_invocation_logging_configuration
#'
#' @aliases bedrock_get_model_invocation_logging_configuration
bedrock_get_model_invocation_logging_configuration <- function() {
  op <- new_operation(
    name = "GetModelInvocationLoggingConfiguration",
    http_method = "GET",
    http_path = "/logging/modelinvocations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_model_invocation_logging_configuration_input()
  output <- .bedrock$get_model_invocation_logging_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_model_invocation_logging_configuration <- bedrock_get_model_invocation_logging_configuration

#' Retrieves details about a prompt router
#'
#' @description
#' Retrieves details about a prompt router.
#'
#' @usage
#' bedrock_get_prompt_router(promptRouterArn)
#'
#' @param promptRouterArn &#91;required&#93; The prompt router's ARN
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   promptRouterName = "string",
#'   routingCriteria = list(
#'     responseQualityDifference = 123.0
#'   ),
#'   description = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   promptRouterArn = "string",
#'   models = list(
#'     list(
#'       modelArn = "string"
#'     )
#'   ),
#'   fallbackModel = list(
#'     modelArn = "string"
#'   ),
#'   status = "AVAILABLE",
#'   type = "custom"|"default"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_prompt_router(
#'   promptRouterArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_prompt_router
#'
#' @aliases bedrock_get_prompt_router
bedrock_get_prompt_router <- function(promptRouterArn) {
  op <- new_operation(
    name = "GetPromptRouter",
    http_method = "GET",
    http_path = "/prompt-routers/{promptRouterArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_prompt_router_input(promptRouterArn = promptRouterArn)
  output <- .bedrock$get_prompt_router_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_prompt_router <- bedrock_get_prompt_router

#' Returns details for a Provisioned Throughput
#'
#' @description
#' Returns details for a Provisioned Throughput. For more information, see
#' [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_get_provisioned_model_throughput(provisionedModelId)
#'
#' @param provisionedModelId &#91;required&#93; The Amazon Resource Name (ARN) or name of the Provisioned Throughput.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelUnits = 123,
#'   desiredModelUnits = 123,
#'   provisionedModelName = "string",
#'   provisionedModelArn = "string",
#'   modelArn = "string",
#'   desiredModelArn = "string",
#'   foundationModelArn = "string",
#'   status = "Creating"|"InService"|"Updating"|"Failed",
#'   creationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   failureMessage = "string",
#'   commitmentDuration = "OneMonth"|"SixMonths",
#'   commitmentExpirationTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_provisioned_model_throughput(
#'   provisionedModelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_provisioned_model_throughput
#'
#' @aliases bedrock_get_provisioned_model_throughput
bedrock_get_provisioned_model_throughput <- function(provisionedModelId) {
  op <- new_operation(
    name = "GetProvisionedModelThroughput",
    http_method = "GET",
    http_path = "/provisioned-model-throughput/{provisionedModelId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_provisioned_model_throughput_input(provisionedModelId = provisionedModelId)
  output <- .bedrock$get_provisioned_model_throughput_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_provisioned_model_throughput <- bedrock_get_provisioned_model_throughput

#' Get usecase for model access
#'
#' @description
#' Get usecase for model access.
#'
#' @usage
#' bedrock_get_use_case_for_model_access()
#'

#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   formData = raw
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_use_case_for_model_access()
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_get_use_case_for_model_access
#'
#' @aliases bedrock_get_use_case_for_model_access
bedrock_get_use_case_for_model_access <- function() {
  op <- new_operation(
    name = "GetUseCaseForModelAccess",
    http_method = "GET",
    http_path = "/use-case-for-model-access",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$get_use_case_for_model_access_input()
  output <- .bedrock$get_use_case_for_model_access_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$get_use_case_for_model_access <- bedrock_get_use_case_for_model_access

#' Lists all Automated Reasoning policies in your account, with optional
#' filtering by policy ARN
#'
#' @description
#' Lists all Automated Reasoning policies in your account, with optional
#' filtering by policy ARN. This helps you manage and discover existing
#' policies.
#'
#' @usage
#' bedrock_list_automated_reasoning_policies(policyArn, nextToken,
#'   maxResults)
#'
#' @param policyArn Optional filter to list only the policy versions with the specified
#' Amazon Resource Name (ARN). If not provided, the DRAFT versions for all
#' policies are listed.
#' @param nextToken The pagination token from a previous request to retrieve the next page
#' of results.
#' @param maxResults The maximum number of policies to return in a single call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   automatedReasoningPolicySummaries = list(
#'     list(
#'       policyArn = "string",
#'       name = "string",
#'       description = "string",
#'       version = "string",
#'       policyId = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_automated_reasoning_policies(
#'   policyArn = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_automated_reasoning_policies
#'
#' @aliases bedrock_list_automated_reasoning_policies
bedrock_list_automated_reasoning_policies <- function(policyArn = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAutomatedReasoningPolicies",
    http_method = "GET",
    http_path = "/automated-reasoning-policies",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "automatedReasoningPolicySummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_automated_reasoning_policies_input(policyArn = policyArn, nextToken = nextToken, maxResults = maxResults)
  output <- .bedrock$list_automated_reasoning_policies_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_automated_reasoning_policies <- bedrock_list_automated_reasoning_policies

#' Lists all build workflows for an Automated Reasoning policy, showing the
#' history of policy creation and modification attempts
#'
#' @description
#' Lists all build workflows for an Automated Reasoning policy, showing the
#' history of policy creation and modification attempts.
#'
#' @usage
#' bedrock_list_automated_reasoning_policy_build_workflows(policyArn,
#'   nextToken, maxResults)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' build workflows you want to list.
#' @param nextToken A pagination token from a previous request to continue listing build
#' workflows from where the previous request left off.
#' @param maxResults The maximum number of build workflows to return in a single response.
#' Valid range is 1-100.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   automatedReasoningPolicyBuildWorkflowSummaries = list(
#'     list(
#'       policyArn = "string",
#'       buildWorkflowId = "string",
#'       status = "SCHEDULED"|"CANCEL_REQUESTED"|"PREPROCESSING"|"BUILDING"|"TESTING"|"COMPLETED"|"FAILED"|"CANCELLED",
#'       buildWorkflowType = "INGEST_CONTENT"|"REFINE_POLICY"|"IMPORT_POLICY",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_automated_reasoning_policy_build_workflows(
#'   policyArn = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_automated_reasoning_policy_build_workflows
#'
#' @aliases bedrock_list_automated_reasoning_policy_build_workflows
bedrock_list_automated_reasoning_policy_build_workflows <- function(policyArn, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAutomatedReasoningPolicyBuildWorkflows",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "automatedReasoningPolicyBuildWorkflowSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_automated_reasoning_policy_build_workflows_input(policyArn = policyArn, nextToken = nextToken, maxResults = maxResults)
  output <- .bedrock$list_automated_reasoning_policy_build_workflows_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_automated_reasoning_policy_build_workflows <- bedrock_list_automated_reasoning_policy_build_workflows

#' Lists tests for an Automated Reasoning policy
#'
#' @description
#' Lists tests for an Automated Reasoning policy. We recommend using
#' pagination to ensure that the operation returns quickly and
#' successfully.
#'
#' @usage
#' bedrock_list_automated_reasoning_policy_test_cases(policyArn, nextToken,
#'   maxResults)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy for
#' which to list tests.
#' @param nextToken The pagination token from a previous request to retrieve the next page
#' of results.
#' @param maxResults The maximum number of tests to return in a single call.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   testCases = list(
#'     list(
#'       testCaseId = "string",
#'       guardContent = "string",
#'       queryContent = "string",
#'       expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       confidenceThreshold = 123.0
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_automated_reasoning_policy_test_cases(
#'   policyArn = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_automated_reasoning_policy_test_cases
#'
#' @aliases bedrock_list_automated_reasoning_policy_test_cases
bedrock_list_automated_reasoning_policy_test_cases <- function(policyArn, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAutomatedReasoningPolicyTestCases",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/test-cases",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "testCases"),
    stream_api = FALSE
  )
  input <- .bedrock$list_automated_reasoning_policy_test_cases_input(policyArn = policyArn, nextToken = nextToken, maxResults = maxResults)
  output <- .bedrock$list_automated_reasoning_policy_test_cases_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_automated_reasoning_policy_test_cases <- bedrock_list_automated_reasoning_policy_test_cases

#' Lists test results for an Automated Reasoning policy, showing how the
#' policy performed against various test scenarios and validation checks
#'
#' @description
#' Lists test results for an Automated Reasoning policy, showing how the
#' policy performed against various test scenarios and validation checks.
#'
#' @usage
#' bedrock_list_automated_reasoning_policy_test_results(policyArn,
#'   buildWorkflowId, nextToken, maxResults)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' test results you want to list.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow whose test results you want
#' to list.
#' @param nextToken A pagination token from a previous request to continue listing test
#' results from where the previous request left off.
#' @param maxResults The maximum number of test results to return in a single response. Valid
#' range is 1-100.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   testResults = list(
#'     list(
#'       testCase = list(
#'         testCaseId = "string",
#'         guardContent = "string",
#'         queryContent = "string",
#'         expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'         createdAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         updatedAt = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         confidenceThreshold = 123.0
#'       ),
#'       policyArn = "string",
#'       testRunStatus = "NOT_STARTED"|"SCHEDULED"|"IN_PROGRESS"|"COMPLETED"|"FAILED",
#'       testFindings = list(
#'         list(
#'           valid = list(
#'             translation = list(
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               untranslatedPremises = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               untranslatedClaims = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               confidence = 123.0
#'             ),
#'             claimsTrueScenario = list(
#'               statements = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             ),
#'             supportingRules = list(
#'               list(
#'                 id = "string",
#'                 policyVersionArn = "string"
#'               )
#'             ),
#'             logicWarning = list(
#'               type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           invalid = list(
#'             translation = list(
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               untranslatedPremises = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               untranslatedClaims = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               confidence = 123.0
#'             ),
#'             contradictingRules = list(
#'               list(
#'                 id = "string",
#'                 policyVersionArn = "string"
#'               )
#'             ),
#'             logicWarning = list(
#'               type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           satisfiable = list(
#'             translation = list(
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               untranslatedPremises = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               untranslatedClaims = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               confidence = 123.0
#'             ),
#'             claimsTrueScenario = list(
#'               statements = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             ),
#'             claimsFalseScenario = list(
#'               statements = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             ),
#'             logicWarning = list(
#'               type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           impossible = list(
#'             translation = list(
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               untranslatedPremises = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               untranslatedClaims = list(
#'                 list(
#'                   text = "string"
#'                 )
#'               ),
#'               confidence = 123.0
#'             ),
#'             contradictingRules = list(
#'               list(
#'                 id = "string",
#'                 policyVersionArn = "string"
#'               )
#'             ),
#'             logicWarning = list(
#'               type = "ALWAYS_TRUE"|"ALWAYS_FALSE",
#'               premises = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               ),
#'               claims = list(
#'                 list(
#'                   logic = "string",
#'                   naturalLanguage = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           translationAmbiguous = list(
#'             options = list(
#'               list(
#'                 translations = list(
#'                   list(
#'                     premises = list(
#'                       list(
#'                         logic = "string",
#'                         naturalLanguage = "string"
#'                       )
#'                     ),
#'                     claims = list(
#'                       list(
#'                         logic = "string",
#'                         naturalLanguage = "string"
#'                       )
#'                     ),
#'                     untranslatedPremises = list(
#'                       list(
#'                         text = "string"
#'                       )
#'                     ),
#'                     untranslatedClaims = list(
#'                       list(
#'                         text = "string"
#'                       )
#'                     ),
#'                     confidence = 123.0
#'                   )
#'                 )
#'               )
#'             ),
#'             differenceScenarios = list(
#'               list(
#'                 statements = list(
#'                   list(
#'                     logic = "string",
#'                     naturalLanguage = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           tooComplex = list(),
#'           noTranslations = list()
#'         )
#'       ),
#'       testRunResult = "PASSED"|"FAILED",
#'       aggregatedTestFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_automated_reasoning_policy_test_results(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_automated_reasoning_policy_test_results
#'
#' @aliases bedrock_list_automated_reasoning_policy_test_results
bedrock_list_automated_reasoning_policy_test_results <- function(policyArn, buildWorkflowId, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAutomatedReasoningPolicyTestResults",
    http_method = "GET",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/test-results",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "testResults"),
    stream_api = FALSE
  )
  input <- .bedrock$list_automated_reasoning_policy_test_results_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, nextToken = nextToken, maxResults = maxResults)
  output <- .bedrock$list_automated_reasoning_policy_test_results_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_automated_reasoning_policy_test_results <- bedrock_list_automated_reasoning_policy_test_results

#' Lists custom model deployments in your account
#'
#' @description
#' Lists custom model deployments in your account. You can filter the
#' results by creation time, name, status, and associated model. Use this
#' operation to manage and monitor your custom model deployments.
#' 
#' We recommend using pagination to ensure that the operation returns
#' quickly and successfully.
#' 
#' The following actions are related to the
#' [`list_custom_model_deployments`][bedrock_list_custom_model_deployments]
#' operation:
#' 
#' -   [`create_custom_model_deployment`][bedrock_create_custom_model_deployment]
#' 
#' -   [`get_custom_model_deployment`][bedrock_get_custom_model_deployment]
#' 
#' -   [`delete_custom_model_deployment`][bedrock_delete_custom_model_deployment]
#'
#' @usage
#' bedrock_list_custom_model_deployments(createdBefore, createdAfter,
#'   nameContains, maxResults, nextToken, sortBy, sortOrder, statusEquals,
#'   modelArnEquals)
#'
#' @param createdBefore Filters deployments created before the specified date and time.
#' @param createdAfter Filters deployments created after the specified date and time.
#' @param nameContains Filters deployments whose names contain the specified string.
#' @param maxResults The maximum number of results to return in a single call.
#' @param nextToken The token for the next set of results. Use this token to retrieve
#' additional results when the response is truncated.
#' @param sortBy The field to sort the results by. The only supported value is
#' `CreationTime`.
#' @param sortOrder The sort order for the results. Valid values are `Ascending` and
#' `Descending`. Default is `Descending`.
#' @param statusEquals Filters deployments by status. Valid values are `CREATING`, `ACTIVE`,
#' and `FAILED`.
#' @param modelArnEquals Filters deployments by the Amazon Resource Name (ARN) of the associated
#' custom model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelDeploymentSummaries = list(
#'     list(
#'       customModelDeploymentArn = "string",
#'       customModelDeploymentName = "string",
#'       modelArn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       status = "Creating"|"Active"|"Failed",
#'       lastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       failureMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_custom_model_deployments(
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending",
#'   statusEquals = "Creating"|"Active"|"Failed",
#'   modelArnEquals = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_custom_model_deployments
#'
#' @aliases bedrock_list_custom_model_deployments
bedrock_list_custom_model_deployments <- function(createdBefore = NULL, createdAfter = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL, statusEquals = NULL, modelArnEquals = NULL) {
  op <- new_operation(
    name = "ListCustomModelDeployments",
    http_method = "GET",
    http_path = "/model-customization/custom-model-deployments",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelDeploymentSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_custom_model_deployments_input(createdBefore = createdBefore, createdAfter = createdAfter, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder, statusEquals = statusEquals, modelArnEquals = modelArnEquals)
  output <- .bedrock$list_custom_model_deployments_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_custom_model_deployments <- bedrock_list_custom_model_deployments

#' Returns a list of the custom models that you have created with the
#' CreateModelCustomizationJob operation
#'
#' @description
#' Returns a list of the custom models that you have created with the
#' [`create_model_customization_job`][bedrock_create_model_customization_job]
#' operation.
#' 
#' For more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_custom_models(creationTimeBefore, creationTimeAfter,
#'   nameContains, baseModelArnEquals, foundationModelArnEquals, maxResults,
#'   nextToken, sortBy, sortOrder, isOwned, modelStatus)
#'
#' @param creationTimeBefore Return custom models created before the specified time.
#' @param creationTimeAfter Return custom models created after the specified time.
#' @param nameContains Return custom models only if the job name contains these characters.
#' @param baseModelArnEquals Return custom models only if the base model Amazon Resource Name (ARN)
#' matches this parameter.
#' @param foundationModelArnEquals Return custom models only if the foundation model Amazon Resource Name
#' (ARN) matches this parameter.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sortBy The field to sort by in the returned list of models.
#' @param sortOrder The sort order of the results.
#' @param isOwned Return custom models depending on if the current account owns them
#' (`true`) or if they were shared with the current account (`false`).
#' @param modelStatus The status of them model to filter results by. Possible values include:
#' 
#' -   `Creating` - Include only models that are currently being created
#'     and validated.
#' 
#' -   `Active` - Include only models that have been successfully created
#'     and are ready for use.
#' 
#' -   `Failed` - Include only models where the creation process failed.
#' 
#' If you don't specify a status, the API returns models in all states.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelSummaries = list(
#'     list(
#'       modelArn = "string",
#'       modelName = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       baseModelArn = "string",
#'       baseModelName = "string",
#'       customizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"|"REINFORCEMENT_FINE_TUNING"|"IMPORTED",
#'       ownerAccountId = "string",
#'       modelStatus = "Active"|"Creating"|"Failed"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_custom_models(
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   nameContains = "string",
#'   baseModelArnEquals = "string",
#'   foundationModelArnEquals = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending",
#'   isOwned = TRUE|FALSE,
#'   modelStatus = "Active"|"Creating"|"Failed"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_custom_models
#'
#' @aliases bedrock_list_custom_models
bedrock_list_custom_models <- function(creationTimeBefore = NULL, creationTimeAfter = NULL, nameContains = NULL, baseModelArnEquals = NULL, foundationModelArnEquals = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL, isOwned = NULL, modelStatus = NULL) {
  op <- new_operation(
    name = "ListCustomModels",
    http_method = "GET",
    http_path = "/custom-models",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_custom_models_input(creationTimeBefore = creationTimeBefore, creationTimeAfter = creationTimeAfter, nameContains = nameContains, baseModelArnEquals = baseModelArnEquals, foundationModelArnEquals = foundationModelArnEquals, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder, isOwned = isOwned, modelStatus = modelStatus)
  output <- .bedrock$list_custom_models_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_custom_models <- bedrock_list_custom_models

#' Lists the account-level enforced guardrail configurations
#'
#' @description
#' Lists the account-level enforced guardrail configurations.
#'
#' @usage
#' bedrock_list_enforced_guardrails_configuration(nextToken)
#'
#' @param nextToken Opaque continuation token of previous paginated response.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrailsConfig = list(
#'     list(
#'       configId = "string",
#'       guardrailArn = "string",
#'       guardrailId = "string",
#'       inputTags = "HONOR"|"IGNORE",
#'       guardrailVersion = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedBy = "string",
#'       owner = "ACCOUNT"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_enforced_guardrails_configuration(
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_enforced_guardrails_configuration
#'
#' @aliases bedrock_list_enforced_guardrails_configuration
bedrock_list_enforced_guardrails_configuration <- function(nextToken = NULL) {
  op <- new_operation(
    name = "ListEnforcedGuardrailsConfiguration",
    http_method = "GET",
    http_path = "/enforcedGuardrailsConfiguration",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", result_key = "guardrailsConfig"),
    stream_api = FALSE
  )
  input <- .bedrock$list_enforced_guardrails_configuration_input(nextToken = nextToken)
  output <- .bedrock$list_enforced_guardrails_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_enforced_guardrails_configuration <- bedrock_list_enforced_guardrails_configuration

#' Lists all existing evaluation jobs
#'
#' @description
#' Lists all existing evaluation jobs.
#'
#' @usage
#' bedrock_list_evaluation_jobs(creationTimeAfter, creationTimeBefore,
#'   statusEquals, applicationTypeEquals, nameContains, maxResults,
#'   nextToken, sortBy, sortOrder)
#'
#' @param creationTimeAfter A filter to only list evaluation jobs created after a specified time.
#' @param creationTimeBefore A filter to only list evaluation jobs created before a specified time.
#' @param statusEquals A filter to only list evaluation jobs that are of a certain status.
#' @param applicationTypeEquals A filter to only list evaluation jobs that are either model evaluations
#' or knowledge base evaluations.
#' @param nameContains A filter to only list evaluation jobs that contain a specified string in
#' the job name.
#' @param maxResults The maximum number of results to return.
#' @param nextToken Continuation token from the previous response, for Amazon Bedrock to
#' list the next set of results.
#' @param sortBy Specifies a creation time to sort the list of evaluation jobs by when
#' they were created.
#' @param sortOrder Specifies whether to sort the list of evaluation jobs by either
#' ascending or descending order.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   jobSummaries = list(
#'     list(
#'       jobArn = "string",
#'       jobName = "string",
#'       status = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"Deleting",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       jobType = "Human"|"Automated",
#'       evaluationTaskTypes = list(
#'         "Summarization"|"Classification"|"QuestionAndAnswer"|"Generation"|"Custom"
#'       ),
#'       modelIdentifiers = list(
#'         "string"
#'       ),
#'       ragIdentifiers = list(
#'         "string"
#'       ),
#'       evaluatorModelIdentifiers = list(
#'         "string"
#'       ),
#'       customMetricsEvaluatorModelIdentifiers = list(
#'         "string"
#'       ),
#'       inferenceConfigSummary = list(
#'         modelConfigSummary = list(
#'           bedrockModelIdentifiers = list(
#'             "string"
#'           ),
#'           precomputedInferenceSourceIdentifiers = list(
#'             "string"
#'           )
#'         ),
#'         ragConfigSummary = list(
#'           bedrockKnowledgeBaseIdentifiers = list(
#'             "string"
#'           ),
#'           precomputedRagSourceIdentifiers = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       applicationType = "ModelEvaluation"|"RagEvaluation"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_evaluation_jobs(
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"Deleting",
#'   applicationTypeEquals = "ModelEvaluation"|"RagEvaluation",
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_evaluation_jobs
#'
#' @aliases bedrock_list_evaluation_jobs
bedrock_list_evaluation_jobs <- function(creationTimeAfter = NULL, creationTimeBefore = NULL, statusEquals = NULL, applicationTypeEquals = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListEvaluationJobs",
    http_method = "GET",
    http_path = "/evaluation-jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "jobSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_evaluation_jobs_input(creationTimeAfter = creationTimeAfter, creationTimeBefore = creationTimeBefore, statusEquals = statusEquals, applicationTypeEquals = applicationTypeEquals, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_evaluation_jobs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_evaluation_jobs <- bedrock_list_evaluation_jobs

#' Get the offers associated with the specified model
#'
#' @description
#' Get the offers associated with the specified model.
#'
#' @usage
#' bedrock_list_foundation_model_agreement_offers(modelId, offerType)
#'
#' @param modelId &#91;required&#93; Model Id of the foundation model.
#' @param offerType Type of offer associated with the model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelId = "string",
#'   offers = list(
#'     list(
#'       offerId = "string",
#'       offerToken = "string",
#'       termDetails = list(
#'         usageBasedPricingTerm = list(
#'           rateCard = list(
#'             list(
#'               dimension = "string",
#'               price = "string",
#'               description = "string",
#'               unit = "string"
#'             )
#'           )
#'         ),
#'         legalTerm = list(
#'           url = "string"
#'         ),
#'         supportTerm = list(
#'           refundPolicyDescription = "string"
#'         ),
#'         validityTerm = list(
#'           agreementDuration = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_foundation_model_agreement_offers(
#'   modelId = "string",
#'   offerType = "ALL"|"PUBLIC"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_foundation_model_agreement_offers
#'
#' @aliases bedrock_list_foundation_model_agreement_offers
bedrock_list_foundation_model_agreement_offers <- function(modelId, offerType = NULL) {
  op <- new_operation(
    name = "ListFoundationModelAgreementOffers",
    http_method = "GET",
    http_path = "/list-foundation-model-agreement-offers/{modelId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$list_foundation_model_agreement_offers_input(modelId = modelId, offerType = offerType)
  output <- .bedrock$list_foundation_model_agreement_offers_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_foundation_model_agreement_offers <- bedrock_list_foundation_model_agreement_offers

#' Lists Amazon Bedrock foundation models that you can use
#'
#' @description
#' Lists Amazon Bedrock foundation models that you can use. You can filter
#' the results with the request parameters. For more information, see
#' [Foundation
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/) in the
#' [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_foundation_models(byProvider, byCustomizationType,
#'   byOutputModality, byInferenceType)
#'
#' @param byProvider Return models belonging to the model provider that you specify.
#' @param byCustomizationType Return models that support the customization type that you specify. For
#' more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' @param byOutputModality Return models that support the output modality that you specify.
#' @param byInferenceType Return models that support the inference type that you specify. For more
#' information, see [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   modelSummaries = list(
#'     list(
#'       modelArn = "string",
#'       modelId = "string",
#'       modelName = "string",
#'       providerName = "string",
#'       inputModalities = list(
#'         "TEXT"|"IMAGE"|"EMBEDDING"
#'       ),
#'       outputModalities = list(
#'         "TEXT"|"IMAGE"|"EMBEDDING"
#'       ),
#'       responseStreamingSupported = TRUE|FALSE,
#'       customizationsSupported = list(
#'         "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"
#'       ),
#'       inferenceTypesSupported = list(
#'         "ON_DEMAND"|"PROVISIONED"
#'       ),
#'       modelLifecycle = list(
#'         status = "ACTIVE"|"LEGACY"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_foundation_models(
#'   byProvider = "string",
#'   byCustomizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION",
#'   byOutputModality = "TEXT"|"IMAGE"|"EMBEDDING",
#'   byInferenceType = "ON_DEMAND"|"PROVISIONED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_foundation_models
#'
#' @aliases bedrock_list_foundation_models
bedrock_list_foundation_models <- function(byProvider = NULL, byCustomizationType = NULL, byOutputModality = NULL, byInferenceType = NULL) {
  op <- new_operation(
    name = "ListFoundationModels",
    http_method = "GET",
    http_path = "/foundation-models",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$list_foundation_models_input(byProvider = byProvider, byCustomizationType = byCustomizationType, byOutputModality = byOutputModality, byInferenceType = byInferenceType)
  output <- .bedrock$list_foundation_models_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_foundation_models <- bedrock_list_foundation_models

#' Lists details about all the guardrails in an account
#'
#' @description
#' Lists details about all the guardrails in an account. To list the
#' `DRAFT` version of all your guardrails, don't specify the
#' `guardrailIdentifier` field. To list all versions of a guardrail,
#' specify the ARN of the guardrail in the `guardrailIdentifier` field.
#' 
#' You can set the maximum number of results to return in a response in the
#' `maxResults` field. If there are more results than the number you set,
#' the response returns a `nextToken` that you can send in another
#' [`list_guardrails`][bedrock_list_guardrails] request to see the next
#' batch of results.
#'
#' @usage
#' bedrock_list_guardrails(guardrailIdentifier, maxResults, nextToken)
#'
#' @param guardrailIdentifier The unique identifier of the guardrail. This can be an ID or the ARN.
#' @param maxResults The maximum number of results to return in the response.
#' @param nextToken If there are more results than were returned in the response, the
#' response returns a `nextToken` that you can send in another
#' [`list_guardrails`][bedrock_list_guardrails] request to see the next
#' batch of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrails = list(
#'     list(
#'       id = "string",
#'       arn = "string",
#'       status = "CREATING"|"UPDATING"|"VERSIONING"|"READY"|"FAILED"|"DELETING",
#'       name = "string",
#'       description = "string",
#'       version = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       crossRegionDetails = list(
#'         guardrailProfileId = "string",
#'         guardrailProfileArn = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_guardrails(
#'   guardrailIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_guardrails
#'
#' @aliases bedrock_list_guardrails
bedrock_list_guardrails <- function(guardrailIdentifier = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListGuardrails",
    http_method = "GET",
    http_path = "/guardrails",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "guardrails"),
    stream_api = FALSE
  )
  input <- .bedrock$list_guardrails_input(guardrailIdentifier = guardrailIdentifier, maxResults = maxResults, nextToken = nextToken)
  output <- .bedrock$list_guardrails_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_guardrails <- bedrock_list_guardrails

#' Returns a list of models you've imported
#'
#' @description
#' Returns a list of models you've imported. You can filter the results to
#' return based on one or more criteria. For more information, see [Import
#' a customized
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_imported_models(creationTimeBefore, creationTimeAfter,
#'   nameContains, maxResults, nextToken, sortBy, sortOrder)
#'
#' @param creationTimeBefore Return imported models that created before the specified time.
#' @param creationTimeAfter Return imported models that were created after the specified time.
#' @param nameContains Return imported models only if the model name contains these characters.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sortBy The field to sort by in the returned list of imported models.
#' @param sortOrder Specifies whetehr to sort the results in ascending or descending order.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelSummaries = list(
#'     list(
#'       modelArn = "string",
#'       modelName = "string",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       instructSupported = TRUE|FALSE,
#'       modelArchitecture = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_imported_models(
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_imported_models
#'
#' @aliases bedrock_list_imported_models
bedrock_list_imported_models <- function(creationTimeBefore = NULL, creationTimeAfter = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListImportedModels",
    http_method = "GET",
    http_path = "/imported-models",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_imported_models_input(creationTimeBefore = creationTimeBefore, creationTimeAfter = creationTimeAfter, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_imported_models_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_imported_models <- bedrock_list_imported_models

#' Returns a list of inference profiles that you can use
#'
#' @description
#' Returns a list of inference profiles that you can use. For more
#' information, see [Increase throughput and resilience with cross-region
#' inference in Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrock_list_inference_profiles(maxResults, nextToken, typeEquals)
#'
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param typeEquals Filters for inference profiles that match the type you specify.
#' 
#' -   `SYSTEM_DEFINED` â€“ The inference profile is defined by Amazon
#'     Bedrock. You can route inference requests across regions with these
#'     inference profiles.
#' 
#' -   `APPLICATION` â€“ The inference profile was created by a user. This
#'     type of inference profile can track metrics and costs when invoking
#'     the model in it. The inference profile may route requests to one or
#'     multiple regions.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   inferenceProfileSummaries = list(
#'     list(
#'       inferenceProfileName = "string",
#'       description = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       inferenceProfileArn = "string",
#'       models = list(
#'         list(
#'           modelArn = "string"
#'         )
#'       ),
#'       inferenceProfileId = "string",
#'       status = "ACTIVE",
#'       type = "SYSTEM_DEFINED"|"APPLICATION"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_inference_profiles(
#'   maxResults = 123,
#'   nextToken = "string",
#'   typeEquals = "SYSTEM_DEFINED"|"APPLICATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_inference_profiles
#'
#' @aliases bedrock_list_inference_profiles
bedrock_list_inference_profiles <- function(maxResults = NULL, nextToken = NULL, typeEquals = NULL) {
  op <- new_operation(
    name = "ListInferenceProfiles",
    http_method = "GET",
    http_path = "/inference-profiles",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "inferenceProfileSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_inference_profiles_input(maxResults = maxResults, nextToken = nextToken, typeEquals = typeEquals)
  output <- .bedrock$list_inference_profiles_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_inference_profiles <- bedrock_list_inference_profiles

#' Lists the endpoints for models from Amazon Bedrock Marketplace in your
#' Amazon Web Services account
#'
#' @description
#' Lists the endpoints for models from Amazon Bedrock Marketplace in your
#' Amazon Web Services account.
#'
#' @usage
#' bedrock_list_marketplace_model_endpoints(maxResults, nextToken,
#'   modelSourceEquals)
#'
#' @param maxResults The maximum number of results to return in a single call. If more
#' results are available, the operation returns a `NextToken` value.
#' @param nextToken The token for the next set of results. You receive this token from a
#' previous
#' [`list_marketplace_model_endpoints`][bedrock_list_marketplace_model_endpoints]
#' call.
#' @param modelSourceEquals If specified, only endpoints for the given model source identifier are
#' returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   marketplaceModelEndpoints = list(
#'     list(
#'       endpointArn = "string",
#'       modelSourceIdentifier = "string",
#'       status = "REGISTERED"|"INCOMPATIBLE_ENDPOINT",
#'       statusMessage = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_marketplace_model_endpoints(
#'   maxResults = 123,
#'   nextToken = "string",
#'   modelSourceEquals = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_marketplace_model_endpoints
#'
#' @aliases bedrock_list_marketplace_model_endpoints
bedrock_list_marketplace_model_endpoints <- function(maxResults = NULL, nextToken = NULL, modelSourceEquals = NULL) {
  op <- new_operation(
    name = "ListMarketplaceModelEndpoints",
    http_method = "GET",
    http_path = "/marketplace-model/endpoints",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "marketplaceModelEndpoints"),
    stream_api = FALSE
  )
  input <- .bedrock$list_marketplace_model_endpoints_input(maxResults = maxResults, nextToken = nextToken, modelSourceEquals = modelSourceEquals)
  output <- .bedrock$list_marketplace_model_endpoints_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_marketplace_model_endpoints <- bedrock_list_marketplace_model_endpoints

#' Returns a list of model copy jobs that you have submitted
#'
#' @description
#' Returns a list of model copy jobs that you have submitted. You can
#' filter the jobs to return based on one or more criteria. For more
#' information, see [Copy models to be used in other
#' regions](https://docs.aws.amazon.com/bedrock/latest/userguide/copy-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_model_copy_jobs(creationTimeAfter, creationTimeBefore,
#'   statusEquals, sourceAccountEquals, sourceModelArnEquals,
#'   targetModelNameContains, maxResults, nextToken, sortBy, sortOrder)
#'
#' @param creationTimeAfter Filters for model copy jobs created after the specified time.
#' @param creationTimeBefore Filters for model copy jobs created before the specified time.
#' @param statusEquals Filters for model copy jobs whose status matches the value that you
#' specify.
#' @param sourceAccountEquals Filters for model copy jobs in which the account that the source model
#' belongs to is equal to the value that you specify.
#' @param sourceModelArnEquals Filters for model copy jobs in which the Amazon Resource Name (ARN) of
#' the source model to is equal to the value that you specify.
#' @param targetModelNameContains Filters for model copy jobs in which the name of the copied model
#' contains the string that you specify.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sortBy The field to sort by in the returned list of model copy jobs.
#' @param sortOrder Specifies whether to sort the results in ascending or descending order.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelCopyJobSummaries = list(
#'     list(
#'       jobArn = "string",
#'       status = "InProgress"|"Completed"|"Failed",
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       targetModelArn = "string",
#'       targetModelName = "string",
#'       sourceAccountId = "string",
#'       sourceModelArn = "string",
#'       targetModelKmsKeyArn = "string",
#'       targetModelTags = list(
#'         list(
#'           key = "string",
#'           value = "string"
#'         )
#'       ),
#'       failureMessage = "string",
#'       sourceModelName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_model_copy_jobs(
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "InProgress"|"Completed"|"Failed",
#'   sourceAccountEquals = "string",
#'   sourceModelArnEquals = "string",
#'   targetModelNameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_model_copy_jobs
#'
#' @aliases bedrock_list_model_copy_jobs
bedrock_list_model_copy_jobs <- function(creationTimeAfter = NULL, creationTimeBefore = NULL, statusEquals = NULL, sourceAccountEquals = NULL, sourceModelArnEquals = NULL, targetModelNameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListModelCopyJobs",
    http_method = "GET",
    http_path = "/model-copy-jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelCopyJobSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_model_copy_jobs_input(creationTimeAfter = creationTimeAfter, creationTimeBefore = creationTimeBefore, statusEquals = statusEquals, sourceAccountEquals = sourceAccountEquals, sourceModelArnEquals = sourceModelArnEquals, targetModelNameContains = targetModelNameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_model_copy_jobs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_model_copy_jobs <- bedrock_list_model_copy_jobs

#' Returns a list of model customization jobs that you have submitted
#'
#' @description
#' Returns a list of model customization jobs that you have submitted. You
#' can filter the jobs to return based on one or more criteria.
#' 
#' For more information, see [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_model_customization_jobs(creationTimeAfter,
#'   creationTimeBefore, statusEquals, nameContains, maxResults, nextToken,
#'   sortBy, sortOrder)
#'
#' @param creationTimeAfter Return customization jobs created after the specified time.
#' @param creationTimeBefore Return customization jobs created before the specified time.
#' @param statusEquals Return customization jobs with the specified status.
#' @param nameContains Return customization jobs only if the job name contains these
#' characters.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sortBy The field to sort by in the returned list of jobs.
#' @param sortOrder The sort order of the results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelCustomizationJobSummaries = list(
#'     list(
#'       jobArn = "string",
#'       baseModelArn = "string",
#'       jobName = "string",
#'       status = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped",
#'       statusDetails = list(
#'         validationDetails = list(
#'           status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'           creationTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           lastModifiedTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         dataProcessingDetails = list(
#'           status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'           creationTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           lastModifiedTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         trainingDetails = list(
#'           status = "InProgress"|"Completed"|"Stopping"|"Stopped"|"Failed"|"NotStarted",
#'           creationTime = as.POSIXct(
#'             "2015-01-01"
#'           ),
#'           lastModifiedTime = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       customModelArn = "string",
#'       customModelName = "string",
#'       customizationType = "FINE_TUNING"|"CONTINUED_PRE_TRAINING"|"DISTILLATION"|"REINFORCEMENT_FINE_TUNING"|"IMPORTED"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_model_customization_jobs(
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped",
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_model_customization_jobs
#'
#' @aliases bedrock_list_model_customization_jobs
bedrock_list_model_customization_jobs <- function(creationTimeAfter = NULL, creationTimeBefore = NULL, statusEquals = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListModelCustomizationJobs",
    http_method = "GET",
    http_path = "/model-customization-jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelCustomizationJobSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_model_customization_jobs_input(creationTimeAfter = creationTimeAfter, creationTimeBefore = creationTimeBefore, statusEquals = statusEquals, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_model_customization_jobs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_model_customization_jobs <- bedrock_list_model_customization_jobs

#' Returns a list of import jobs you've submitted
#'
#' @description
#' Returns a list of import jobs you've submitted. You can filter the
#' results to return based on one or more criteria. For more information,
#' see [Import a customized
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/model-customization-import-model.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_model_import_jobs(creationTimeAfter, creationTimeBefore,
#'   statusEquals, nameContains, maxResults, nextToken, sortBy, sortOrder)
#'
#' @param creationTimeAfter Return import jobs that were created after the specified time.
#' @param creationTimeBefore Return import jobs that were created before the specified time.
#' @param statusEquals Return imported jobs with the specified status.
#' @param nameContains Return imported jobs only if the job name contains these characters.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sortBy The field to sort by in the returned list of imported jobs.
#' @param sortOrder Specifies whether to sort the results in ascending or descending order.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   modelImportJobSummaries = list(
#'     list(
#'       jobArn = "string",
#'       jobName = "string",
#'       status = "InProgress"|"Completed"|"Failed",
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       importedModelArn = "string",
#'       importedModelName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_model_import_jobs(
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "InProgress"|"Completed"|"Failed",
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_model_import_jobs
#'
#' @aliases bedrock_list_model_import_jobs
bedrock_list_model_import_jobs <- function(creationTimeAfter = NULL, creationTimeBefore = NULL, statusEquals = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListModelImportJobs",
    http_method = "GET",
    http_path = "/model-import-jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "modelImportJobSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_model_import_jobs_input(creationTimeAfter = creationTimeAfter, creationTimeBefore = creationTimeBefore, statusEquals = statusEquals, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_model_import_jobs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_model_import_jobs <- bedrock_list_model_import_jobs

#' Lists all batch inference jobs in the account
#'
#' @description
#' Lists all batch inference jobs in the account. For more information, see
#' [View details about a batch inference
#' job](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-monitor.html).
#'
#' @usage
#' bedrock_list_model_invocation_jobs(submitTimeAfter, submitTimeBefore,
#'   statusEquals, nameContains, maxResults, nextToken, sortBy, sortOrder)
#'
#' @param submitTimeAfter Specify a time to filter for batch inference jobs that were submitted
#' after the time you specify.
#' @param submitTimeBefore Specify a time to filter for batch inference jobs that were submitted
#' before the time you specify.
#' @param statusEquals Specify a status to filter for batch inference jobs whose statuses match
#' the string you specify.
#' 
#' The following statuses are possible:
#' 
#' -   Submitted â€“ This job has been submitted to a queue for validation.
#' 
#' -   Validating â€“ This job is being validated for the requirements
#'     described in [Format and upload your batch inference
#'     data](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-data.html).
#'     The criteria include the following:
#' 
#'     -   Your IAM service role has access to the Amazon S3 buckets
#'         containing your files.
#' 
#'     -   Your files are .jsonl files and each individual record is a JSON
#'         object in the correct format. Note that validation doesn't check
#'         if the `modelInput` value matches the request body for the
#'         model.
#' 
#'     -   Your files fulfill the requirements for file size and number of
#'         records. For more information, see [Quotas for Amazon
#'         Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/quotas.html).
#' 
#' -   Scheduled â€“ This job has been validated and is now in a queue. The
#'     job will automatically start when it reaches its turn.
#' 
#' -   Expired â€“ This job timed out because it was scheduled but didn't
#'     begin before the set timeout duration. Submit a new job request.
#' 
#' -   InProgress â€“ This job has begun. You can start viewing the results
#'     in the output S3 location.
#' 
#' -   Completed â€“ This job has successfully completed. View the output
#'     files in the output S3 location.
#' 
#' -   PartiallyCompleted â€“ This job has partially completed. Not all of
#'     your records could be processed in time. View the output files in
#'     the output S3 location.
#' 
#' -   Failed â€“ This job has failed. Check the failure message for any
#'     further details. For further assistance, reach out to the Amazon Web
#'     Services Support Center.
#' 
#' -   Stopped â€“ This job was stopped by a user.
#' 
#' -   Stopping â€“ This job is being stopped by a user.
#' @param nameContains Specify a string to filter for batch inference jobs whose names contain
#' the string.
#' @param maxResults The maximum number of results to return. If there are more results than
#' the number that you specify, a `nextToken` value is returned. Use the
#' `nextToken` in a request to return the next batch of results.
#' @param nextToken If there were more results than the value you specified in the
#' `maxResults` field in a previous
#' [`list_model_invocation_jobs`][bedrock_list_model_invocation_jobs]
#' request, the response would have returned a `nextToken` value. To see
#' the next batch of results, send the `nextToken` value in another
#' request.
#' @param sortBy An attribute by which to sort the results.
#' @param sortOrder Specifies whether to sort the results by ascending or descending order.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   invocationJobSummaries = list(
#'     list(
#'       jobArn = "string",
#'       jobName = "string",
#'       modelId = "string",
#'       clientRequestToken = "string",
#'       roleArn = "string",
#'       status = "Submitted"|"InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"PartiallyCompleted"|"Expired"|"Validating"|"Scheduled",
#'       message = "string",
#'       submitTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       endTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       inputDataConfig = list(
#'         s3InputDataConfig = list(
#'           s3InputFormat = "JSONL",
#'           s3Uri = "string",
#'           s3BucketOwner = "string"
#'         )
#'       ),
#'       outputDataConfig = list(
#'         s3OutputDataConfig = list(
#'           s3Uri = "string",
#'           s3EncryptionKeyId = "string",
#'           s3BucketOwner = "string"
#'         )
#'       ),
#'       vpcConfig = list(
#'         subnetIds = list(
#'           "string"
#'         ),
#'         securityGroupIds = list(
#'           "string"
#'         )
#'       ),
#'       timeoutDurationInHours = 123,
#'       jobExpirationTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_model_invocation_jobs(
#'   submitTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   submitTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "Submitted"|"InProgress"|"Completed"|"Failed"|"Stopping"|"Stopped"|"PartiallyCompleted"|"Expired"|"Validating"|"Scheduled",
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_model_invocation_jobs
#'
#' @aliases bedrock_list_model_invocation_jobs
bedrock_list_model_invocation_jobs <- function(submitTimeAfter = NULL, submitTimeBefore = NULL, statusEquals = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListModelInvocationJobs",
    http_method = "GET",
    http_path = "/model-invocation-jobs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "invocationJobSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_model_invocation_jobs_input(submitTimeAfter = submitTimeAfter, submitTimeBefore = submitTimeBefore, statusEquals = statusEquals, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_model_invocation_jobs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_model_invocation_jobs <- bedrock_list_model_invocation_jobs

#' Retrieves a list of prompt routers
#'
#' @description
#' Retrieves a list of prompt routers.
#'
#' @usage
#' bedrock_list_prompt_routers(maxResults, nextToken, type)
#'
#' @param maxResults The maximum number of prompt routers to return in one page of results.
#' @param nextToken Specify the pagination token from a previous request to retrieve the
#' next page of results.
#' @param type The type of the prompt routers, such as whether it's default or custom.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   promptRouterSummaries = list(
#'     list(
#'       promptRouterName = "string",
#'       routingCriteria = list(
#'         responseQualityDifference = 123.0
#'       ),
#'       description = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       updatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       promptRouterArn = "string",
#'       models = list(
#'         list(
#'           modelArn = "string"
#'         )
#'       ),
#'       fallbackModel = list(
#'         modelArn = "string"
#'       ),
#'       status = "AVAILABLE",
#'       type = "custom"|"default"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_prompt_routers(
#'   maxResults = 123,
#'   nextToken = "string",
#'   type = "custom"|"default"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_prompt_routers
#'
#' @aliases bedrock_list_prompt_routers
bedrock_list_prompt_routers <- function(maxResults = NULL, nextToken = NULL, type = NULL) {
  op <- new_operation(
    name = "ListPromptRouters",
    http_method = "GET",
    http_path = "/prompt-routers",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "promptRouterSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_prompt_routers_input(maxResults = maxResults, nextToken = nextToken, type = type)
  output <- .bedrock$list_prompt_routers_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_prompt_routers <- bedrock_list_prompt_routers

#' Lists the Provisioned Throughputs in the account
#'
#' @description
#' Lists the Provisioned Throughputs in the account. For more information,
#' see [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_provisioned_model_throughputs(creationTimeAfter,
#'   creationTimeBefore, statusEquals, modelArnEquals, nameContains,
#'   maxResults, nextToken, sortBy, sortOrder)
#'
#' @param creationTimeAfter A filter that returns Provisioned Throughputs created after the
#' specified time.
#' @param creationTimeBefore A filter that returns Provisioned Throughputs created before the
#' specified time.
#' @param statusEquals A filter that returns Provisioned Throughputs if their statuses matches
#' the value that you specify.
#' @param modelArnEquals A filter that returns Provisioned Throughputs whose model Amazon
#' Resource Name (ARN) is equal to the value that you specify.
#' @param nameContains A filter that returns Provisioned Throughputs if their name contains the
#' expression that you specify.
#' @param maxResults THe maximum number of results to return in the response. If there are
#' more results than the number you specified, the response returns a
#' `nextToken` value. To see the next batch of results, send the
#' `nextToken` value in another list request.
#' @param nextToken If there are more results than the number you specified in the
#' `maxResults` field, the response returns a `nextToken` value. To see the
#' next batch of results, specify the `nextToken` value in this field.
#' @param sortBy The field by which to sort the returned list of Provisioned Throughputs.
#' @param sortOrder The sort order of the results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   provisionedModelSummaries = list(
#'     list(
#'       provisionedModelName = "string",
#'       provisionedModelArn = "string",
#'       modelArn = "string",
#'       desiredModelArn = "string",
#'       foundationModelArn = "string",
#'       modelUnits = 123,
#'       desiredModelUnits = 123,
#'       status = "Creating"|"InService"|"Updating"|"Failed",
#'       commitmentDuration = "OneMonth"|"SixMonths",
#'       commitmentExpirationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       creationTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastModifiedTime = as.POSIXct(
#'         "2015-01-01"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_provisioned_model_throughputs(
#'   creationTimeAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   creationTimeBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   statusEquals = "Creating"|"InService"|"Updating"|"Failed",
#'   modelArnEquals = "string",
#'   nameContains = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sortBy = "CreationTime",
#'   sortOrder = "Ascending"|"Descending"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_provisioned_model_throughputs
#'
#' @aliases bedrock_list_provisioned_model_throughputs
bedrock_list_provisioned_model_throughputs <- function(creationTimeAfter = NULL, creationTimeBefore = NULL, statusEquals = NULL, modelArnEquals = NULL, nameContains = NULL, maxResults = NULL, nextToken = NULL, sortBy = NULL, sortOrder = NULL) {
  op <- new_operation(
    name = "ListProvisionedModelThroughputs",
    http_method = "GET",
    http_path = "/provisioned-model-throughputs",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "provisionedModelSummaries"),
    stream_api = FALSE
  )
  input <- .bedrock$list_provisioned_model_throughputs_input(creationTimeAfter = creationTimeAfter, creationTimeBefore = creationTimeBefore, statusEquals = statusEquals, modelArnEquals = modelArnEquals, nameContains = nameContains, maxResults = maxResults, nextToken = nextToken, sortBy = sortBy, sortOrder = sortOrder)
  output <- .bedrock$list_provisioned_model_throughputs_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_provisioned_model_throughputs <- bedrock_list_provisioned_model_throughputs

#' List the tags associated with the specified resource
#'
#' @description
#' List the tags associated with the specified resource.
#' 
#' For more information, see [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_list_tags_for_resource(resourceARN)
#'
#' @param resourceARN &#91;required&#93; The Amazon Resource Name (ARN) of the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceARN = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_list_tags_for_resource
#'
#' @aliases bedrock_list_tags_for_resource
bedrock_list_tags_for_resource <- function(resourceARN) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/listTagsForResource",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$list_tags_for_resource_input(resourceARN = resourceARN)
  output <- .bedrock$list_tags_for_resource_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$list_tags_for_resource <- bedrock_list_tags_for_resource

#' Sets the account-level enforced guardrail configuration
#'
#' @description
#' Sets the account-level enforced guardrail configuration.
#'
#' @usage
#' bedrock_put_enforced_guardrail_configuration(configId,
#'   guardrailInferenceConfig)
#'
#' @param configId Unique ID for the account enforced configuration.
#' @param guardrailInferenceConfig &#91;required&#93; Account-level enforced guardrail input configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   configId = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   updatedBy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_enforced_guardrail_configuration(
#'   configId = "string",
#'   guardrailInferenceConfig = list(
#'     guardrailIdentifier = "string",
#'     guardrailVersion = "string",
#'     inputTags = "HONOR"|"IGNORE"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_put_enforced_guardrail_configuration
#'
#' @aliases bedrock_put_enforced_guardrail_configuration
bedrock_put_enforced_guardrail_configuration <- function(configId = NULL, guardrailInferenceConfig) {
  op <- new_operation(
    name = "PutEnforcedGuardrailConfiguration",
    http_method = "PUT",
    http_path = "/enforcedGuardrailsConfiguration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$put_enforced_guardrail_configuration_input(configId = configId, guardrailInferenceConfig = guardrailInferenceConfig)
  output <- .bedrock$put_enforced_guardrail_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$put_enforced_guardrail_configuration <- bedrock_put_enforced_guardrail_configuration

#' Set the configuration values for model invocation logging
#'
#' @description
#' Set the configuration values for model invocation logging.
#'
#' @usage
#' bedrock_put_model_invocation_logging_configuration(loggingConfig)
#'
#' @param loggingConfig &#91;required&#93; The logging configuration values to set.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_model_invocation_logging_configuration(
#'   loggingConfig = list(
#'     cloudWatchConfig = list(
#'       logGroupName = "string",
#'       roleArn = "string",
#'       largeDataDeliveryS3Config = list(
#'         bucketName = "string",
#'         keyPrefix = "string"
#'       )
#'     ),
#'     s3Config = list(
#'       bucketName = "string",
#'       keyPrefix = "string"
#'     ),
#'     textDataDeliveryEnabled = TRUE|FALSE,
#'     imageDataDeliveryEnabled = TRUE|FALSE,
#'     embeddingDataDeliveryEnabled = TRUE|FALSE,
#'     videoDataDeliveryEnabled = TRUE|FALSE,
#'     audioDataDeliveryEnabled = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_put_model_invocation_logging_configuration
#'
#' @aliases bedrock_put_model_invocation_logging_configuration
bedrock_put_model_invocation_logging_configuration <- function(loggingConfig) {
  op <- new_operation(
    name = "PutModelInvocationLoggingConfiguration",
    http_method = "PUT",
    http_path = "/logging/modelinvocations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$put_model_invocation_logging_configuration_input(loggingConfig = loggingConfig)
  output <- .bedrock$put_model_invocation_logging_configuration_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$put_model_invocation_logging_configuration <- bedrock_put_model_invocation_logging_configuration

#' Put usecase for model access
#'
#' @description
#' Put usecase for model access.
#'
#' @usage
#' bedrock_put_use_case_for_model_access(formData)
#'
#' @param formData &#91;required&#93; Put customer profile Request.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_use_case_for_model_access(
#'   formData = raw
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_put_use_case_for_model_access
#'
#' @aliases bedrock_put_use_case_for_model_access
bedrock_put_use_case_for_model_access <- function(formData) {
  op <- new_operation(
    name = "PutUseCaseForModelAccess",
    http_method = "POST",
    http_path = "/use-case-for-model-access",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$put_use_case_for_model_access_input(formData = formData)
  output <- .bedrock$put_use_case_for_model_access_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$put_use_case_for_model_access <- bedrock_put_use_case_for_model_access

#' Registers an existing Amazon SageMaker endpoint with Amazon Bedrock
#' Marketplace, allowing it to be used with Amazon Bedrock APIs
#'
#' @description
#' Registers an existing Amazon SageMaker endpoint with Amazon Bedrock
#' Marketplace, allowing it to be used with Amazon Bedrock APIs.
#'
#' @usage
#' bedrock_register_marketplace_model_endpoint(endpointIdentifier,
#'   modelSourceIdentifier)
#'
#' @param endpointIdentifier &#91;required&#93; The ARN of the Amazon SageMaker endpoint you want to register with
#' Amazon Bedrock Marketplace.
#' @param modelSourceIdentifier &#91;required&#93; The ARN of the model from Amazon Bedrock Marketplace that is deployed on
#' the endpoint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   marketplaceModelEndpoint = list(
#'     endpointArn = "string",
#'     modelSourceIdentifier = "string",
#'     status = "REGISTERED"|"INCOMPATIBLE_ENDPOINT",
#'     statusMessage = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endpointConfig = list(
#'       sageMaker = list(
#'         initialInstanceCount = 123,
#'         instanceType = "string",
#'         executionRole = "string",
#'         kmsEncryptionKey = "string",
#'         vpc = list(
#'           subnetIds = list(
#'             "string"
#'           ),
#'           securityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     endpointStatus = "string",
#'     endpointStatusMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$register_marketplace_model_endpoint(
#'   endpointIdentifier = "string",
#'   modelSourceIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_register_marketplace_model_endpoint
#'
#' @aliases bedrock_register_marketplace_model_endpoint
bedrock_register_marketplace_model_endpoint <- function(endpointIdentifier, modelSourceIdentifier) {
  op <- new_operation(
    name = "RegisterMarketplaceModelEndpoint",
    http_method = "POST",
    http_path = "/marketplace-model/endpoints/{endpointIdentifier}/registration",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$register_marketplace_model_endpoint_input(endpointIdentifier = endpointIdentifier, modelSourceIdentifier = modelSourceIdentifier)
  output <- .bedrock$register_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$register_marketplace_model_endpoint <- bedrock_register_marketplace_model_endpoint

#' Starts a new build workflow for an Automated Reasoning policy
#'
#' @description
#' Starts a new build workflow for an Automated Reasoning policy. This
#' initiates the process of analyzing source documents and generating
#' policy rules, variables, and types.
#'
#' @usage
#' bedrock_start_automated_reasoning_policy_build_workflow(policyArn,
#'   buildWorkflowType, clientRequestToken, sourceContent)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy for
#' which to start the build workflow.
#' @param buildWorkflowType &#91;required&#93; The type of build workflow to start (e.g., DOCUMENT_INGESTION for
#' processing new documents, POLICY_REPAIR for fixing existing policies).
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than once. If this token matches a previous request,
#' Amazon Bedrock ignores the request but doesn't return an error.
#' @param sourceContent &#91;required&#93; The source content for the build workflow, such as documents to analyze
#' or repair instructions for existing policies.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   buildWorkflowId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_automated_reasoning_policy_build_workflow(
#'   policyArn = "string",
#'   buildWorkflowType = "INGEST_CONTENT"|"REFINE_POLICY"|"IMPORT_POLICY",
#'   clientRequestToken = "string",
#'   sourceContent = list(
#'     policyDefinition = list(
#'       version = "string",
#'       types = list(
#'         list(
#'           name = "string",
#'           description = "string",
#'           values = list(
#'             list(
#'               value = "string",
#'               description = "string"
#'             )
#'           )
#'         )
#'       ),
#'       rules = list(
#'         list(
#'           id = "string",
#'           expression = "string",
#'           alternateExpression = "string"
#'         )
#'       ),
#'       variables = list(
#'         list(
#'           name = "string",
#'           type = "string",
#'           description = "string"
#'         )
#'       )
#'     ),
#'     workflowContent = list(
#'       documents = list(
#'         list(
#'           document = raw,
#'           documentContentType = "pdf"|"txt",
#'           documentName = "string",
#'           documentDescription = "string"
#'         )
#'       ),
#'       policyRepairAssets = list(
#'         annotations = list(
#'           list(
#'             addType = list(
#'               name = "string",
#'               description = "string",
#'               values = list(
#'                 list(
#'                   value = "string",
#'                   description = "string"
#'                 )
#'               )
#'             ),
#'             updateType = list(
#'               name = "string",
#'               newName = "string",
#'               description = "string",
#'               values = list(
#'                 list(
#'                   addTypeValue = list(
#'                     value = "string",
#'                     description = "string"
#'                   ),
#'                   updateTypeValue = list(
#'                     value = "string",
#'                     newValue = "string",
#'                     description = "string"
#'                   ),
#'                   deleteTypeValue = list(
#'                     value = "string"
#'                   )
#'                 )
#'               )
#'             ),
#'             deleteType = list(
#'               name = "string"
#'             ),
#'             addVariable = list(
#'               name = "string",
#'               type = "string",
#'               description = "string"
#'             ),
#'             updateVariable = list(
#'               name = "string",
#'               newName = "string",
#'               description = "string"
#'             ),
#'             deleteVariable = list(
#'               name = "string"
#'             ),
#'             addRule = list(
#'               expression = "string"
#'             ),
#'             updateRule = list(
#'               ruleId = "string",
#'               expression = "string"
#'             ),
#'             deleteRule = list(
#'               ruleId = "string"
#'             ),
#'             addRuleFromNaturalLanguage = list(
#'               naturalLanguage = "string"
#'             ),
#'             updateFromRulesFeedback = list(
#'               ruleIds = list(
#'                 "string"
#'               ),
#'               feedback = "string"
#'             ),
#'             updateFromScenarioFeedback = list(
#'               ruleIds = list(
#'                 "string"
#'               ),
#'               scenarioExpression = "string",
#'               feedback = "string"
#'             ),
#'             ingestContent = list(
#'               content = "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_start_automated_reasoning_policy_build_workflow
#'
#' @aliases bedrock_start_automated_reasoning_policy_build_workflow
bedrock_start_automated_reasoning_policy_build_workflow <- function(policyArn, buildWorkflowType, clientRequestToken = NULL, sourceContent) {
  op <- new_operation(
    name = "StartAutomatedReasoningPolicyBuildWorkflow",
    http_method = "POST",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowType}/start",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$start_automated_reasoning_policy_build_workflow_input(policyArn = policyArn, buildWorkflowType = buildWorkflowType, clientRequestToken = clientRequestToken, sourceContent = sourceContent)
  output <- .bedrock$start_automated_reasoning_policy_build_workflow_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$start_automated_reasoning_policy_build_workflow <- bedrock_start_automated_reasoning_policy_build_workflow

#' Initiates a test workflow to validate Automated Reasoning policy tests
#'
#' @description
#' Initiates a test workflow to validate Automated Reasoning policy tests.
#' The workflow executes the specified tests against the policy and
#' generates validation results.
#'
#' @usage
#' bedrock_start_automated_reasoning_policy_test_workflow(policyArn,
#'   buildWorkflowId, testCaseIds, clientRequestToken)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy to
#' test.
#' @param buildWorkflowId &#91;required&#93; The build workflow identifier. The build workflow must show a
#' `COMPLETED` status before running tests.
#' @param testCaseIds The list of test identifiers to run. If not provided, all tests for the
#' policy are run.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request but doesn't return an error.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_automated_reasoning_policy_test_workflow(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   testCaseIds = list(
#'     "string"
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_start_automated_reasoning_policy_test_workflow
#'
#' @aliases bedrock_start_automated_reasoning_policy_test_workflow
bedrock_start_automated_reasoning_policy_test_workflow <- function(policyArn, buildWorkflowId, testCaseIds = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "StartAutomatedReasoningPolicyTestWorkflow",
    http_method = "POST",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/test-workflows",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$start_automated_reasoning_policy_test_workflow_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, testCaseIds = testCaseIds, clientRequestToken = clientRequestToken)
  output <- .bedrock$start_automated_reasoning_policy_test_workflow_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$start_automated_reasoning_policy_test_workflow <- bedrock_start_automated_reasoning_policy_test_workflow

#' Stops an evaluation job that is current being created or running
#'
#' @description
#' Stops an evaluation job that is current being created or running.
#'
#' @usage
#' bedrock_stop_evaluation_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; The Amazon Resource Name (ARN) of the evaluation job you want to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_evaluation_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_stop_evaluation_job
#'
#' @aliases bedrock_stop_evaluation_job
bedrock_stop_evaluation_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "StopEvaluationJob",
    http_method = "POST",
    http_path = "/evaluation-job/{jobIdentifier}/stop",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$stop_evaluation_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$stop_evaluation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$stop_evaluation_job <- bedrock_stop_evaluation_job

#' Stops an active model customization job
#'
#' @description
#' Stops an active model customization job. For more information, see
#' [Custom
#' models](https://docs.aws.amazon.com/bedrock/latest/userguide/custom-models.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_stop_model_customization_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; Job identifier of the job to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_model_customization_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_stop_model_customization_job
#'
#' @aliases bedrock_stop_model_customization_job
bedrock_stop_model_customization_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "StopModelCustomizationJob",
    http_method = "POST",
    http_path = "/model-customization-jobs/{jobIdentifier}/stop",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$stop_model_customization_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$stop_model_customization_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$stop_model_customization_job <- bedrock_stop_model_customization_job

#' Stops a batch inference job
#'
#' @description
#' Stops a batch inference job. You're only charged for tokens that were
#' already processed. For more information, see [Stop a batch inference
#' job](https://docs.aws.amazon.com/bedrock/latest/userguide/batch-inference-stop.html).
#'
#' @usage
#' bedrock_stop_model_invocation_job(jobIdentifier)
#'
#' @param jobIdentifier &#91;required&#93; The Amazon Resource Name (ARN) of the batch inference job to stop.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$stop_model_invocation_job(
#'   jobIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_stop_model_invocation_job
#'
#' @aliases bedrock_stop_model_invocation_job
bedrock_stop_model_invocation_job <- function(jobIdentifier) {
  op <- new_operation(
    name = "StopModelInvocationJob",
    http_method = "POST",
    http_path = "/model-invocation-job/{jobIdentifier}/stop",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$stop_model_invocation_job_input(jobIdentifier = jobIdentifier)
  output <- .bedrock$stop_model_invocation_job_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$stop_model_invocation_job <- bedrock_stop_model_invocation_job

#' Associate tags with a resource
#'
#' @description
#' Associate tags with a resource. For more information, see [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_tag_resource(resourceARN, tags)
#'
#' @param resourceARN &#91;required&#93; The Amazon Resource Name (ARN) of the resource to tag.
#' @param tags &#91;required&#93; Tags to associate with the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceARN = "string",
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_tag_resource
#'
#' @aliases bedrock_tag_resource
bedrock_tag_resource <- function(resourceARN, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tagResource",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$tag_resource_input(resourceARN = resourceARN, tags = tags)
  output <- .bedrock$tag_resource_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$tag_resource <- bedrock_tag_resource

#' Remove one or more tags from a resource
#'
#' @description
#' Remove one or more tags from a resource. For more information, see
#' [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_untag_resource(resourceARN, tagKeys)
#'
#' @param resourceARN &#91;required&#93; The Amazon Resource Name (ARN) of the resource to untag.
#' @param tagKeys &#91;required&#93; Tag keys of the tags to remove from the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceARN = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_untag_resource
#'
#' @aliases bedrock_untag_resource
bedrock_untag_resource <- function(resourceARN, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/untagResource",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$untag_resource_input(resourceARN = resourceARN, tagKeys = tagKeys)
  output <- .bedrock$untag_resource_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$untag_resource <- bedrock_untag_resource

#' Updates an existing Automated Reasoning policy with new rules,
#' variables, or configuration
#'
#' @description
#' Updates an existing Automated Reasoning policy with new rules,
#' variables, or configuration. This creates a new version of the policy
#' while preserving the previous version.
#'
#' @usage
#' bedrock_update_automated_reasoning_policy(policyArn, policyDefinition,
#'   name, description)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy to
#' update. This must be the ARN of a draft policy.
#' @param policyDefinition &#91;required&#93; The updated policy definition containing the formal logic rules,
#' variables, and types.
#' @param name The updated name for the Automated Reasoning policy.
#' @param description The updated description for the Automated Reasoning policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   name = "string",
#'   definitionHash = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_automated_reasoning_policy(
#'   policyArn = "string",
#'   policyDefinition = list(
#'     version = "string",
#'     types = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             value = "string",
#'             description = "string"
#'           )
#'         )
#'       )
#'     ),
#'     rules = list(
#'       list(
#'         id = "string",
#'         expression = "string",
#'         alternateExpression = "string"
#'       )
#'     ),
#'     variables = list(
#'       list(
#'         name = "string",
#'         type = "string",
#'         description = "string"
#'       )
#'     )
#'   ),
#'   name = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_automated_reasoning_policy
#'
#' @aliases bedrock_update_automated_reasoning_policy
bedrock_update_automated_reasoning_policy <- function(policyArn, policyDefinition, name = NULL, description = NULL) {
  op <- new_operation(
    name = "UpdateAutomatedReasoningPolicy",
    http_method = "PATCH",
    http_path = "/automated-reasoning-policies/{policyArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_automated_reasoning_policy_input(policyArn = policyArn, policyDefinition = policyDefinition, name = name, description = description)
  output <- .bedrock$update_automated_reasoning_policy_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_automated_reasoning_policy <- bedrock_update_automated_reasoning_policy

#' Updates the annotations for an Automated Reasoning policy build workflow
#'
#' @description
#' Updates the annotations for an Automated Reasoning policy build
#' workflow. This allows you to modify extracted rules, variables, and
#' types before finalizing the policy.
#'
#' @usage
#' bedrock_update_automated_reasoning_policy_annotations(policyArn,
#'   buildWorkflowId, annotations, lastUpdatedAnnotationSetHash)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy whose
#' annotations you want to update.
#' @param buildWorkflowId &#91;required&#93; The unique identifier of the build workflow whose annotations you want
#' to update.
#' @param annotations &#91;required&#93; The updated annotations containing modified rules, variables, and types
#' for the policy.
#' @param lastUpdatedAnnotationSetHash &#91;required&#93; The hash value of the annotation set that you're updating. This is used
#' for optimistic concurrency control to prevent conflicting updates.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   annotationSetHash = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_automated_reasoning_policy_annotations(
#'   policyArn = "string",
#'   buildWorkflowId = "string",
#'   annotations = list(
#'     list(
#'       addType = list(
#'         name = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             value = "string",
#'             description = "string"
#'           )
#'         )
#'       ),
#'       updateType = list(
#'         name = "string",
#'         newName = "string",
#'         description = "string",
#'         values = list(
#'           list(
#'             addTypeValue = list(
#'               value = "string",
#'               description = "string"
#'             ),
#'             updateTypeValue = list(
#'               value = "string",
#'               newValue = "string",
#'               description = "string"
#'             ),
#'             deleteTypeValue = list(
#'               value = "string"
#'             )
#'           )
#'         )
#'       ),
#'       deleteType = list(
#'         name = "string"
#'       ),
#'       addVariable = list(
#'         name = "string",
#'         type = "string",
#'         description = "string"
#'       ),
#'       updateVariable = list(
#'         name = "string",
#'         newName = "string",
#'         description = "string"
#'       ),
#'       deleteVariable = list(
#'         name = "string"
#'       ),
#'       addRule = list(
#'         expression = "string"
#'       ),
#'       updateRule = list(
#'         ruleId = "string",
#'         expression = "string"
#'       ),
#'       deleteRule = list(
#'         ruleId = "string"
#'       ),
#'       addRuleFromNaturalLanguage = list(
#'         naturalLanguage = "string"
#'       ),
#'       updateFromRulesFeedback = list(
#'         ruleIds = list(
#'           "string"
#'         ),
#'         feedback = "string"
#'       ),
#'       updateFromScenarioFeedback = list(
#'         ruleIds = list(
#'           "string"
#'         ),
#'         scenarioExpression = "string",
#'         feedback = "string"
#'       ),
#'       ingestContent = list(
#'         content = "string"
#'       )
#'     )
#'   ),
#'   lastUpdatedAnnotationSetHash = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_automated_reasoning_policy_annotations
#'
#' @aliases bedrock_update_automated_reasoning_policy_annotations
bedrock_update_automated_reasoning_policy_annotations <- function(policyArn, buildWorkflowId, annotations, lastUpdatedAnnotationSetHash) {
  op <- new_operation(
    name = "UpdateAutomatedReasoningPolicyAnnotations",
    http_method = "PATCH",
    http_path = "/automated-reasoning-policies/{policyArn}/build-workflows/{buildWorkflowId}/annotations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_automated_reasoning_policy_annotations_input(policyArn = policyArn, buildWorkflowId = buildWorkflowId, annotations = annotations, lastUpdatedAnnotationSetHash = lastUpdatedAnnotationSetHash)
  output <- .bedrock$update_automated_reasoning_policy_annotations_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_automated_reasoning_policy_annotations <- bedrock_update_automated_reasoning_policy_annotations

#' Updates an existing Automated Reasoning policy test
#'
#' @description
#' Updates an existing Automated Reasoning policy test. You can modify the
#' content, query, expected result, and confidence threshold.
#'
#' @usage
#' bedrock_update_automated_reasoning_policy_test_case(policyArn,
#'   testCaseId, guardContent, queryContent, lastUpdatedAt,
#'   expectedAggregatedFindingsResult, confidenceThreshold,
#'   clientRequestToken)
#'
#' @param policyArn &#91;required&#93; The Amazon Resource Name (ARN) of the Automated Reasoning policy that
#' contains the test.
#' @param testCaseId &#91;required&#93; The unique identifier of the test to update.
#' @param guardContent &#91;required&#93; The updated content to be validated by the Automated Reasoning policy.
#' @param queryContent The updated input query or prompt that generated the content.
#' @param lastUpdatedAt &#91;required&#93; The timestamp when the test was last updated. This is used as a
#' concurrency token to prevent conflicting modifications.
#' @param expectedAggregatedFindingsResult &#91;required&#93; The updated expected result of the Automated Reasoning check.
#' @param confidenceThreshold The updated minimum confidence level for logic validation. If null is
#' provided, the threshold will be removed.
#' @param clientRequestToken A unique, case-sensitive identifier to ensure that the operation
#' completes no more than one time. If this token matches a previous
#' request, Amazon Bedrock ignores the request, but does not return an
#' error.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   policyArn = "string",
#'   testCaseId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_automated_reasoning_policy_test_case(
#'   policyArn = "string",
#'   testCaseId = "string",
#'   guardContent = "string",
#'   queryContent = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   expectedAggregatedFindingsResult = "VALID"|"INVALID"|"SATISFIABLE"|"IMPOSSIBLE"|"TRANSLATION_AMBIGUOUS"|"TOO_COMPLEX"|"NO_TRANSLATION",
#'   confidenceThreshold = 123.0,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_automated_reasoning_policy_test_case
#'
#' @aliases bedrock_update_automated_reasoning_policy_test_case
bedrock_update_automated_reasoning_policy_test_case <- function(policyArn, testCaseId, guardContent, queryContent = NULL, lastUpdatedAt, expectedAggregatedFindingsResult, confidenceThreshold = NULL, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateAutomatedReasoningPolicyTestCase",
    http_method = "PATCH",
    http_path = "/automated-reasoning-policies/{policyArn}/test-cases/{testCaseId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_automated_reasoning_policy_test_case_input(policyArn = policyArn, testCaseId = testCaseId, guardContent = guardContent, queryContent = queryContent, lastUpdatedAt = lastUpdatedAt, expectedAggregatedFindingsResult = expectedAggregatedFindingsResult, confidenceThreshold = confidenceThreshold, clientRequestToken = clientRequestToken)
  output <- .bedrock$update_automated_reasoning_policy_test_case_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_automated_reasoning_policy_test_case <- bedrock_update_automated_reasoning_policy_test_case

#' Updates a custom model deployment with a new custom model
#'
#' @description
#' Updates a custom model deployment with a new custom model. This allows
#' you to deploy updated models without creating new deployment endpoints.
#'
#' @usage
#' bedrock_update_custom_model_deployment(modelArn,
#'   customModelDeploymentIdentifier)
#'
#' @param modelArn &#91;required&#93; ARN of the new custom model to deploy. This replaces the currently
#' deployed model.
#' @param customModelDeploymentIdentifier &#91;required&#93; Identifier of the custom model deployment to update with the new custom
#' model.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   customModelDeploymentArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_custom_model_deployment(
#'   modelArn = "string",
#'   customModelDeploymentIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_custom_model_deployment
#'
#' @aliases bedrock_update_custom_model_deployment
bedrock_update_custom_model_deployment <- function(modelArn, customModelDeploymentIdentifier) {
  op <- new_operation(
    name = "UpdateCustomModelDeployment",
    http_method = "PATCH",
    http_path = "/model-customization/custom-model-deployments/{customModelDeploymentIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_custom_model_deployment_input(modelArn = modelArn, customModelDeploymentIdentifier = customModelDeploymentIdentifier)
  output <- .bedrock$update_custom_model_deployment_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_custom_model_deployment <- bedrock_update_custom_model_deployment

#' Updates a guardrail with the values you specify
#'
#' @description
#' Updates a guardrail with the values you specify.
#' 
#' -   Specify a `name` and optional `description`.
#' 
#' -   Specify messages for when the guardrail successfully blocks a prompt
#'     or a model response in the `blockedInputMessaging` and
#'     `blockedOutputsMessaging` fields.
#' 
#' -   Specify topics for the guardrail to deny in the `topicPolicyConfig`
#'     object. Each
#'     [GuardrailTopicConfig](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GuardrailTopicConfig.html)
#'     object in the `topicsConfig` list pertains to one topic.
#' 
#'     -   Give a `name` and `description` so that the guardrail can
#'         properly identify the topic.
#' 
#'     -   Specify `DENY` in the `type` field.
#' 
#'     -   (Optional) Provide up to five prompts that you would categorize
#'         as belonging to the topic in the `examples` list.
#' 
#' -   Specify filter strengths for the harmful categories defined in
#'     Amazon Bedrock in the `contentPolicyConfig` object. Each
#'     [GuardrailContentFilterConfig](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GuardrailContentFilterConfig.html)
#'     object in the `filtersConfig` list pertains to a harmful category.
#'     For more information, see [Content
#'     filters](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-content-filters.html).
#'     For more information about the fields in a content filter, see
#'     [GuardrailContentFilterConfig](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GuardrailContentFilterConfig.html).
#' 
#'     -   Specify the category in the `type` field.
#' 
#'     -   Specify the strength of the filter for prompts in the
#'         `inputStrength` field and for model responses in the `strength`
#'         field of the
#'         [GuardrailContentFilterConfig](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_GuardrailContentFilterConfig.html).
#' 
#' -   (Optional) For security, include the ARN of a KMS key in the
#'     `kmsKeyId` field.
#'
#' @usage
#' bedrock_update_guardrail(guardrailIdentifier, name, description,
#'   topicPolicyConfig, contentPolicyConfig, wordPolicyConfig,
#'   sensitiveInformationPolicyConfig, contextualGroundingPolicyConfig,
#'   automatedReasoningPolicyConfig, crossRegionConfig,
#'   blockedInputMessaging, blockedOutputsMessaging, kmsKeyId)
#'
#' @param guardrailIdentifier &#91;required&#93; The unique identifier of the guardrail. This can be an ID or the ARN.
#' @param name &#91;required&#93; A name for the guardrail.
#' @param description A description of the guardrail.
#' @param topicPolicyConfig The topic policy to configure for the guardrail.
#' @param contentPolicyConfig The content policy to configure for the guardrail.
#' @param wordPolicyConfig The word policy to configure for the guardrail.
#' @param sensitiveInformationPolicyConfig The sensitive information policy to configure for the guardrail.
#' @param contextualGroundingPolicyConfig The contextual grounding policy configuration used to update a
#' guardrail.
#' @param automatedReasoningPolicyConfig Updated configuration for Automated Reasoning policies associated with
#' the guardrail.
#' @param crossRegionConfig The system-defined guardrail profile that you're using with your
#' guardrail. Guardrail profiles define the destination Amazon Web Services
#' Regions where guardrail inference requests can be automatically routed.
#' 
#' For more information, see the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails-cross-region.html).
#' @param blockedInputMessaging &#91;required&#93; The message to return when the guardrail blocks a prompt.
#' @param blockedOutputsMessaging &#91;required&#93; The message to return when the guardrail blocks a model response.
#' @param kmsKeyId The ARN of the KMS key with which to encrypt the guardrail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrailId = "string",
#'   guardrailArn = "string",
#'   version = "string",
#'   updatedAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_guardrail(
#'   guardrailIdentifier = "string",
#'   name = "string",
#'   description = "string",
#'   topicPolicyConfig = list(
#'     topicsConfig = list(
#'       list(
#'         name = "string",
#'         definition = "string",
#'         examples = list(
#'           "string"
#'         ),
#'         type = "DENY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tierConfig = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   contentPolicyConfig = list(
#'     filtersConfig = list(
#'       list(
#'         type = "SEXUAL"|"VIOLENCE"|"HATE"|"INSULTS"|"MISCONDUCT"|"PROMPT_ATTACK",
#'         inputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         outputStrength = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'         inputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         outputModalities = list(
#'           "TEXT"|"IMAGE"
#'         ),
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     tierConfig = list(
#'       tierName = "CLASSIC"|"STANDARD"
#'     )
#'   ),
#'   wordPolicyConfig = list(
#'     wordsConfig = list(
#'       list(
#'         text = "string",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     managedWordListsConfig = list(
#'       list(
#'         type = "PROFANITY",
#'         inputAction = "BLOCK"|"NONE",
#'         outputAction = "BLOCK"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   sensitiveInformationPolicyConfig = list(
#'     piiEntitiesConfig = list(
#'       list(
#'         type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     ),
#'     regexesConfig = list(
#'       list(
#'         name = "string",
#'         description = "string",
#'         pattern = "string",
#'         action = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         outputAction = "BLOCK"|"ANONYMIZE"|"NONE",
#'         inputEnabled = TRUE|FALSE,
#'         outputEnabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   contextualGroundingPolicyConfig = list(
#'     filtersConfig = list(
#'       list(
#'         type = "GROUNDING"|"RELEVANCE",
#'         threshold = 123.0,
#'         action = "BLOCK"|"NONE",
#'         enabled = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   automatedReasoningPolicyConfig = list(
#'     policies = list(
#'       "string"
#'     ),
#'     confidenceThreshold = 123.0
#'   ),
#'   crossRegionConfig = list(
#'     guardrailProfileIdentifier = "string"
#'   ),
#'   blockedInputMessaging = "string",
#'   blockedOutputsMessaging = "string",
#'   kmsKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_guardrail
#'
#' @aliases bedrock_update_guardrail
bedrock_update_guardrail <- function(guardrailIdentifier, name, description = NULL, topicPolicyConfig = NULL, contentPolicyConfig = NULL, wordPolicyConfig = NULL, sensitiveInformationPolicyConfig = NULL, contextualGroundingPolicyConfig = NULL, automatedReasoningPolicyConfig = NULL, crossRegionConfig = NULL, blockedInputMessaging, blockedOutputsMessaging, kmsKeyId = NULL) {
  op <- new_operation(
    name = "UpdateGuardrail",
    http_method = "PUT",
    http_path = "/guardrails/{guardrailIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_guardrail_input(guardrailIdentifier = guardrailIdentifier, name = name, description = description, topicPolicyConfig = topicPolicyConfig, contentPolicyConfig = contentPolicyConfig, wordPolicyConfig = wordPolicyConfig, sensitiveInformationPolicyConfig = sensitiveInformationPolicyConfig, contextualGroundingPolicyConfig = contextualGroundingPolicyConfig, automatedReasoningPolicyConfig = automatedReasoningPolicyConfig, crossRegionConfig = crossRegionConfig, blockedInputMessaging = blockedInputMessaging, blockedOutputsMessaging = blockedOutputsMessaging, kmsKeyId = kmsKeyId)
  output <- .bedrock$update_guardrail_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_guardrail <- bedrock_update_guardrail

#' Updates the configuration of an existing endpoint for a model from
#' Amazon Bedrock Marketplace
#'
#' @description
#' Updates the configuration of an existing endpoint for a model from
#' Amazon Bedrock Marketplace.
#'
#' @usage
#' bedrock_update_marketplace_model_endpoint(endpointArn, endpointConfig,
#'   clientRequestToken)
#'
#' @param endpointArn &#91;required&#93; The Amazon Resource Name (ARN) of the endpoint you want to update.
#' @param endpointConfig &#91;required&#93; The new configuration for the endpoint, including the number and type of
#' instances to use.
#' @param clientRequestToken A unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. This token is listed as not required because
#' Amazon Web Services SDKs automatically generate it for you and set this
#' parameter. If you're not using the Amazon Web Services SDK or the CLI,
#' you must provide this token or the action will fail.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   marketplaceModelEndpoint = list(
#'     endpointArn = "string",
#'     modelSourceIdentifier = "string",
#'     status = "REGISTERED"|"INCOMPATIBLE_ENDPOINT",
#'     statusMessage = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     updatedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endpointConfig = list(
#'       sageMaker = list(
#'         initialInstanceCount = 123,
#'         instanceType = "string",
#'         executionRole = "string",
#'         kmsEncryptionKey = "string",
#'         vpc = list(
#'           subnetIds = list(
#'             "string"
#'           ),
#'           securityGroupIds = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     endpointStatus = "string",
#'     endpointStatusMessage = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_marketplace_model_endpoint(
#'   endpointArn = "string",
#'   endpointConfig = list(
#'     sageMaker = list(
#'       initialInstanceCount = 123,
#'       instanceType = "string",
#'       executionRole = "string",
#'       kmsEncryptionKey = "string",
#'       vpc = list(
#'         subnetIds = list(
#'           "string"
#'         ),
#'         securityGroupIds = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_marketplace_model_endpoint
#'
#' @aliases bedrock_update_marketplace_model_endpoint
bedrock_update_marketplace_model_endpoint <- function(endpointArn, endpointConfig, clientRequestToken = NULL) {
  op <- new_operation(
    name = "UpdateMarketplaceModelEndpoint",
    http_method = "PATCH",
    http_path = "/marketplace-model/endpoints/{endpointArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_marketplace_model_endpoint_input(endpointArn = endpointArn, endpointConfig = endpointConfig, clientRequestToken = clientRequestToken)
  output <- .bedrock$update_marketplace_model_endpoint_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_marketplace_model_endpoint <- bedrock_update_marketplace_model_endpoint

#' Updates the name or associated model for a Provisioned Throughput
#'
#' @description
#' Updates the name or associated model for a Provisioned Throughput. For
#' more information, see [Provisioned
#' Throughput](https://docs.aws.amazon.com/bedrock/latest/userguide/prov-throughput.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrock_update_provisioned_model_throughput(provisionedModelId,
#'   desiredProvisionedModelName, desiredModelId)
#'
#' @param provisionedModelId &#91;required&#93; The Amazon Resource Name (ARN) or name of the Provisioned Throughput to
#' update.
#' @param desiredProvisionedModelName The new name for this Provisioned Throughput.
#' @param desiredModelId The Amazon Resource Name (ARN) of the new model to associate with this
#' Provisioned Throughput. You can't specify this field if this Provisioned
#' Throughput is associated with a base model.
#' 
#' If this Provisioned Throughput is associated with a custom model, you
#' can specify one of the following options:
#' 
#' -   The base model from which the custom model was customized.
#' 
#' -   Another custom model that was customized from the same base model as
#'     the custom model.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$update_provisioned_model_throughput(
#'   provisionedModelId = "string",
#'   desiredProvisionedModelName = "string",
#'   desiredModelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrock_update_provisioned_model_throughput
#'
#' @aliases bedrock_update_provisioned_model_throughput
bedrock_update_provisioned_model_throughput <- function(provisionedModelId, desiredProvisionedModelName = NULL, desiredModelId = NULL) {
  op <- new_operation(
    name = "UpdateProvisionedModelThroughput",
    http_method = "PATCH",
    http_path = "/provisioned-model-throughput/{provisionedModelId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrock$update_provisioned_model_throughput_input(provisionedModelId = provisionedModelId, desiredProvisionedModelName = desiredProvisionedModelName, desiredModelId = desiredModelId)
  output <- .bedrock$update_provisioned_model_throughput_output()
  config <- get_config()
  svc <- .bedrock$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrock$operations$update_provisioned_model_throughput <- bedrock_update_provisioned_model_throughput

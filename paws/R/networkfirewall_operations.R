# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include networkfirewall_service.R
NULL

#' Accepts a transit gateway attachment request for Network Firewall
#'
#' @description
#' Accepts a transit gateway attachment request for Network Firewall. When
#' you accept the attachment request, Network Firewall creates the
#' necessary routing components to enable traffic flow between the transit
#' gateway and firewall endpoints.
#' 
#' You must accept a transit gateway attachment to complete the creation of
#' a transit gateway-attached firewall, unless auto-accept is enabled on
#' the transit gateway. After acceptance, use
#' [`describe_firewall`][networkfirewall_describe_firewall] to verify the
#' firewall status.
#' 
#' To reject an attachment instead of accepting it, use
#' [`reject_network_firewall_transit_gateway_attachment`][networkfirewall_reject_network_firewall_transit_gateway_attachment].
#' 
#' It can take several minutes for the attachment acceptance to complete
#' and the firewall to become available.
#'
#' @usage
#' networkfirewall_accept_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId)
#'
#' @param TransitGatewayAttachmentId &#91;required&#93; Required. The unique identifier of the transit gateway attachment to
#' accept. This ID is returned in the response when creating a transit
#' gateway-attached firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransitGatewayAttachmentId = "string",
#'   TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$accept_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_accep_netwo_firew_trans_gatew_attac
#'
#' @aliases networkfirewall_accept_network_firewall_transit_gateway_attachment
networkfirewall_accept_network_firewall_transit_gateway_attachment <- function(TransitGatewayAttachmentId) {
  op <- new_operation(
    name = "AcceptNetworkFirewallTransitGatewayAttachment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$accept_network_firewall_transit_gateway_attachment_input(TransitGatewayAttachmentId = TransitGatewayAttachmentId)
  output <- .networkfirewall$accept_network_firewall_transit_gateway_attachment_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$accept_network_firewall_transit_gateway_attachment <- networkfirewall_accept_network_firewall_transit_gateway_attachment

#' Associates the specified Availability Zones with a transit
#' gateway-attached firewall
#'
#' @description
#' Associates the specified Availability Zones with a transit
#' gateway-attached firewall. For each Availability Zone, Network Firewall
#' creates a firewall endpoint to process traffic. You can specify one or
#' more Availability Zones where you want to deploy the firewall.
#' 
#' After adding Availability Zones, you must update your transit gateway
#' route tables to direct traffic through the new firewall endpoints. Use
#' [`describe_firewall`][networkfirewall_describe_firewall] to monitor the
#' status of the new endpoints.
#'
#' @usage
#' networkfirewall_associate_availability_zones(UpdateToken, FirewallArn,
#'   FirewallName, AvailabilityZoneMappings)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param AvailabilityZoneMappings &#91;required&#93; Required. The Availability Zones where you want to create firewall
#' endpoints. You must specify at least one Availability Zone.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneMappings = list(
#'     list(
#'       AvailabilityZone = "string"
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_availability_zones(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneMappings = list(
#'     list(
#'       AvailabilityZone = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_associate_availability_zones
#'
#' @aliases networkfirewall_associate_availability_zones
networkfirewall_associate_availability_zones <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, AvailabilityZoneMappings) {
  op <- new_operation(
    name = "AssociateAvailabilityZones",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$associate_availability_zones_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, AvailabilityZoneMappings = AvailabilityZoneMappings)
  output <- .networkfirewall$associate_availability_zones_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$associate_availability_zones <- networkfirewall_associate_availability_zones

#' Associates a FirewallPolicy to a Firewall
#'
#' @description
#' Associates a FirewallPolicy to a Firewall.
#' 
#' A firewall policy defines how to monitor and manage your VPC network
#' traffic, using a collection of inspection rule groups and other
#' settings. Each firewall requires one firewall policy association, and
#' you can use the same firewall policy for multiple firewalls.
#'
#' @usage
#' networkfirewall_associate_firewall_policy(UpdateToken, FirewallArn,
#'   FirewallName, FirewallPolicyArn)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicyArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall policy.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   FirewallPolicyArn = "string",
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_firewall_policy(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   FirewallPolicyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_associate_firewall_policy
#'
#' @aliases networkfirewall_associate_firewall_policy
networkfirewall_associate_firewall_policy <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, FirewallPolicyArn) {
  op <- new_operation(
    name = "AssociateFirewallPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$associate_firewall_policy_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, FirewallPolicyArn = FirewallPolicyArn)
  output <- .networkfirewall$associate_firewall_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$associate_firewall_policy <- networkfirewall_associate_firewall_policy

#' Associates the specified subnets in the Amazon VPC to the firewall
#'
#' @description
#' Associates the specified subnets in the Amazon VPC to the firewall. You
#' can specify one subnet for each of the Availability Zones that the VPC
#' spans.
#' 
#' This request creates an Network Firewall firewall endpoint in each of
#' the subnets. To enable the firewall's protections, you must also modify
#' the VPC's route tables for each subnet's Availability Zone, to redirect
#' the traffic that's coming into and going out of the zone through the
#' firewall endpoint.
#'
#' @usage
#' networkfirewall_associate_subnets(UpdateToken, FirewallArn,
#'   FirewallName, SubnetMappings)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param SubnetMappings &#91;required&#93; The IDs of the subnets that you want to associate with the firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetMappings = list(
#'     list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$associate_subnets(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetMappings = list(
#'     list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_associate_subnets
#'
#' @aliases networkfirewall_associate_subnets
networkfirewall_associate_subnets <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, SubnetMappings) {
  op <- new_operation(
    name = "AssociateSubnets",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$associate_subnets_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, SubnetMappings = SubnetMappings)
  output <- .networkfirewall$associate_subnets_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$associate_subnets <- networkfirewall_associate_subnets

#' Attaches ProxyRuleGroup resources to a ProxyConfiguration
#'
#' @description
#' Attaches ProxyRuleGroup resources to a ProxyConfiguration
#' 
#' A Proxy Configuration defines the monitoring and protection behavior for
#' a Proxy. The details of the behavior are defined in the rule groups that
#' you add to your configuration.
#'
#' @usage
#' networkfirewall_attach_rule_groups_to_proxy_configuration(
#'   ProxyConfigurationName, ProxyConfigurationArn, RuleGroups, UpdateToken)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroups &#91;required&#93; The proxy rule group(s) to attach to the proxy configuration
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy configuration. The token marks the
#' state of the proxy configuration resource at the time of the request.
#' 
#' To make changes to the proxy configuration, you provide the token in
#' your request. Network Firewall uses the token to ensure that the proxy
#' configuration hasn't changed since you last retrieved it. If it has
#' changed, the operation fails with an `InvalidTokenException`. If this
#' happens, retrieve the proxy configuration again to get a current copy of
#' it with a current token. Reapply your changes as needed, then try the
#' operation again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfiguration = list(
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     Description = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RuleGroups = list(
#'       list(
#'         ProxyRuleGroupName = "string",
#'         ProxyRuleGroupArn = "string",
#'         Type = "string",
#'         Priority = 123
#'       )
#'     ),
#'     DefaultRulePhaseActions = list(
#'       PreDNS = "ALLOW"|"DENY"|"ALERT",
#'       PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'       PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$attach_rule_groups_to_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string",
#'   RuleGroups = list(
#'     list(
#'       ProxyRuleGroupName = "string",
#'       InsertPosition = 123
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_attach_rule_groups_to_proxy_configuration
#'
#' @aliases networkfirewall_attach_rule_groups_to_proxy_configuration
networkfirewall_attach_rule_groups_to_proxy_configuration <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL, RuleGroups, UpdateToken) {
  op <- new_operation(
    name = "AttachRuleGroupsToProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$attach_rule_groups_to_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn, RuleGroups = RuleGroups, UpdateToken = UpdateToken)
  output <- .networkfirewall$attach_rule_groups_to_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$attach_rule_groups_to_proxy_configuration <- networkfirewall_attach_rule_groups_to_proxy_configuration

#' Creates an Network Firewall Firewall and accompanying FirewallStatus for
#' a VPC
#'
#' @description
#' Creates an Network Firewall Firewall and accompanying FirewallStatus for
#' a VPC.
#' 
#' The firewall defines the configuration settings for an Network Firewall
#' firewall. The settings that you can define at creation include the
#' firewall policy, the subnets in your VPC to use for the firewall
#' endpoints, and any tags that are attached to the firewall Amazon Web
#' Services resource.
#' 
#' After you create a firewall, you can provide additional settings, like
#' the logging configuration.
#' 
#' To update the settings for a firewall, you use the operations that apply
#' to the settings themselves, for example
#' [`update_logging_configuration`][networkfirewall_update_logging_configuration],
#' [`associate_subnets`][networkfirewall_associate_subnets], and
#' [`update_firewall_delete_protection`][networkfirewall_update_firewall_delete_protection].
#' 
#' To manage a firewall's tags, use the standard Amazon Web Services
#' resource tagging operations,
#' [`list_tags_for_resource`][networkfirewall_list_tags_for_resource],
#' [`tag_resource`][networkfirewall_tag_resource], and
#' [`untag_resource`][networkfirewall_untag_resource].
#' 
#' To retrieve information about firewalls, use
#' [`list_firewalls`][networkfirewall_list_firewalls] and
#' [`describe_firewall`][networkfirewall_describe_firewall].
#' 
#' To generate a report on the last 30 days of traffic monitored by a
#' firewall, use
#' [`start_analysis_report`][networkfirewall_start_analysis_report].
#'
#' @usage
#' networkfirewall_create_firewall(FirewallName, FirewallPolicyArn, VpcId,
#'   SubnetMappings, DeleteProtection, SubnetChangeProtection,
#'   FirewallPolicyChangeProtection, Description, Tags,
#'   EncryptionConfiguration, EnabledAnalysisTypes, TransitGatewayId,
#'   AvailabilityZoneMappings, AvailabilityZoneChangeProtection)
#'
#' @param FirewallName &#91;required&#93; The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' @param FirewallPolicyArn &#91;required&#93; The Amazon Resource Name (ARN) of the FirewallPolicy that you want to
#' use for the firewall.
#' @param VpcId The unique identifier of the VPC where Network Firewall should create
#' the firewall.
#' 
#' You can't change this setting after you create the firewall.
#' @param SubnetMappings The public subnets to use for your Network Firewall firewalls. Each
#' subnet must belong to a different Availability Zone in the VPC. Network
#' Firewall creates a firewall endpoint in each subnet.
#' @param DeleteProtection A flag indicating whether it is possible to delete the firewall. A
#' setting of `TRUE` indicates that the firewall is protected against
#' deletion. Use this setting to protect against accidentally deleting a
#' firewall that is in use. When you create a firewall, the operation
#' initializes this flag to `TRUE`.
#' @param SubnetChangeProtection A setting indicating whether the firewall is protected against changes
#' to the subnet associations. Use this setting to protect against
#' accidentally modifying the subnet associations for a firewall that is in
#' use. When you create a firewall, the operation initializes this setting
#' to `TRUE`.
#' @param FirewallPolicyChangeProtection A setting indicating whether the firewall is protected against a change
#' to the firewall policy association. Use this setting to protect against
#' accidentally modifying the firewall policy for a firewall that is in
#' use. When you create a firewall, the operation initializes this setting
#' to `TRUE`.
#' @param Description A description of the firewall.
#' @param Tags The key:value pairs to associate with the resource.
#' @param EncryptionConfiguration A complex type that contains settings for encryption of your firewall
#' resources.
#' @param EnabledAnalysisTypes An optional setting indicating the specific traffic analysis types to
#' enable on the firewall.
#' @param TransitGatewayId Required when creating a transit gateway-attached firewall. The unique
#' identifier of the transit gateway to attach to this firewall. You can
#' provide either a transit gateway from your account or one that has been
#' shared with you through Resource Access Manager.
#' 
#' After creating the firewall, you cannot change the transit gateway
#' association. To use a different transit gateway, you must create a new
#' firewall.
#' 
#' For information about creating firewalls, see
#' [`create_firewall`][networkfirewall_create_firewall]. For specific
#' guidance about transit gateway-attached firewalls, see [Considerations
#' for transit gateway-attached
#' firewalls](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tgw-firewall-considerations.html)
#' in the *Network Firewall Developer Guide*.
#' @param AvailabilityZoneMappings Required. The Availability Zones where you want to create firewall
#' endpoints for a transit gateway-attached firewall. You must specify at
#' least one Availability Zone. Consider enabling the firewall in every
#' Availability Zone where you have workloads to maintain Availability Zone
#' isolation.
#' 
#' You can modify Availability Zones later using
#' [`associate_availability_zones`][networkfirewall_associate_availability_zones]
#' or
#' [`disassociate_availability_zones`][networkfirewall_disassociate_availability_zones],
#' but this may briefly disrupt traffic. The
#' `AvailabilityZoneChangeProtection` setting controls whether you can make
#' these modifications.
#' @param AvailabilityZoneChangeProtection Optional. A setting indicating whether the firewall is protected against
#' changes to its Availability Zone configuration. When set to `TRUE`, you
#' cannot add or remove Availability Zones without first disabling this
#' protection using
#' [`update_availability_zone_change_protection`][networkfirewall_update_availability_zone_change_protection].
#' 
#' Default value: `FALSE`
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Firewall = list(
#'     FirewallName = "string",
#'     FirewallArn = "string",
#'     FirewallPolicyArn = "string",
#'     VpcId = "string",
#'     SubnetMappings = list(
#'       list(
#'         SubnetId = "string",
#'         IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'       )
#'     ),
#'     DeleteProtection = TRUE|FALSE,
#'     SubnetChangeProtection = TRUE|FALSE,
#'     FirewallPolicyChangeProtection = TRUE|FALSE,
#'     Description = "string",
#'     FirewallId = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     NumberOfAssociations = 123,
#'     EnabledAnalysisTypes = list(
#'       "TLS_SNI"|"HTTP_HOST"
#'     ),
#'     TransitGatewayId = "string",
#'     TransitGatewayOwnerAccountId = "string",
#'     AvailabilityZoneMappings = list(
#'       list(
#'         AvailabilityZone = "string"
#'       )
#'     ),
#'     AvailabilityZoneChangeProtection = TRUE|FALSE
#'   ),
#'   FirewallStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     ConfigurationSyncStateSummary = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED",
#'     SyncStates = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         ),
#'         Config = list(
#'           list(
#'             SyncStatus = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED"|"NOT_SUBSCRIBED"|"DEPRECATED",
#'             UpdateToken = "string"
#'           )
#'         )
#'       )
#'     ),
#'     CapacityUsageSummary = list(
#'       CIDRs = list(
#'         AvailableCIDRCount = 123,
#'         UtilizedCIDRCount = 123,
#'         IPSetReferences = list(
#'           list(
#'             ResolvedCIDRCount = 123
#'           )
#'         )
#'       )
#'     ),
#'     TransitGatewayAttachmentSyncState = list(
#'       AttachmentId = "string",
#'       TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_firewall(
#'   FirewallName = "string",
#'   FirewallPolicyArn = "string",
#'   VpcId = "string",
#'   SubnetMappings = list(
#'     list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     )
#'   ),
#'   DeleteProtection = TRUE|FALSE,
#'   SubnetChangeProtection = TRUE|FALSE,
#'   FirewallPolicyChangeProtection = TRUE|FALSE,
#'   Description = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   ),
#'   EnabledAnalysisTypes = list(
#'     "TLS_SNI"|"HTTP_HOST"
#'   ),
#'   TransitGatewayId = "string",
#'   AvailabilityZoneMappings = list(
#'     list(
#'       AvailabilityZone = "string"
#'     )
#'   ),
#'   AvailabilityZoneChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_firewall
#'
#' @aliases networkfirewall_create_firewall
networkfirewall_create_firewall <- function(FirewallName, FirewallPolicyArn, VpcId = NULL, SubnetMappings = NULL, DeleteProtection = NULL, SubnetChangeProtection = NULL, FirewallPolicyChangeProtection = NULL, Description = NULL, Tags = NULL, EncryptionConfiguration = NULL, EnabledAnalysisTypes = NULL, TransitGatewayId = NULL, AvailabilityZoneMappings = NULL, AvailabilityZoneChangeProtection = NULL) {
  op <- new_operation(
    name = "CreateFirewall",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_firewall_input(FirewallName = FirewallName, FirewallPolicyArn = FirewallPolicyArn, VpcId = VpcId, SubnetMappings = SubnetMappings, DeleteProtection = DeleteProtection, SubnetChangeProtection = SubnetChangeProtection, FirewallPolicyChangeProtection = FirewallPolicyChangeProtection, Description = Description, Tags = Tags, EncryptionConfiguration = EncryptionConfiguration, EnabledAnalysisTypes = EnabledAnalysisTypes, TransitGatewayId = TransitGatewayId, AvailabilityZoneMappings = AvailabilityZoneMappings, AvailabilityZoneChangeProtection = AvailabilityZoneChangeProtection)
  output <- .networkfirewall$create_firewall_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_firewall <- networkfirewall_create_firewall

#' Creates the firewall policy for the firewall according to the
#' specifications
#'
#' @description
#' Creates the firewall policy for the firewall according to the
#' specifications.
#' 
#' An Network Firewall firewall policy defines the behavior of a firewall,
#' in a collection of stateless and stateful rule groups and other
#' settings. You can use one firewall policy for multiple firewalls.
#'
#' @usage
#' networkfirewall_create_firewall_policy(FirewallPolicyName,
#'   FirewallPolicy, Description, Tags, DryRun, EncryptionConfiguration)
#'
#' @param FirewallPolicyName &#91;required&#93; The descriptive name of the firewall policy. You can't change the name
#' of a firewall policy after you create it.
#' @param FirewallPolicy &#91;required&#93; The rule groups and policy actions to use in the firewall policy.
#' @param Description A description of the firewall policy.
#' @param Tags The key:value pairs to associate with the resource.
#' @param DryRun Indicates whether you want Network Firewall to just check the validity
#' of the request, rather than run the request.
#' 
#' If set to `TRUE`, Network Firewall checks whether the request can run
#' successfully, but doesn't actually make the requested changes. The call
#' returns the value that the request would return if you ran it with dry
#' run set to `FALSE`, but doesn't make additions or changes to your
#' resources. This option allows you to make sure that you have the
#' required permissions to run the request and that your request parameters
#' are valid.
#' 
#' If set to `FALSE`, Network Firewall makes the requested changes to your
#' resources.
#' @param EncryptionConfiguration A complex type that contains settings for encryption of your firewall
#' policy resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallPolicyResponse = list(
#'     FirewallPolicyName = "string",
#'     FirewallPolicyArn = "string",
#'     FirewallPolicyId = "string",
#'     Description = "string",
#'     FirewallPolicyStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedStatelessRuleCapacity = 123,
#'     ConsumedStatefulRuleCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_firewall_policy(
#'   FirewallPolicyName = "string",
#'   FirewallPolicy = list(
#'     StatelessRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123
#'       )
#'     ),
#'     StatelessDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessFragmentDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessCustomActions = list(
#'       list(
#'         ActionName = "string",
#'         ActionDefinition = list(
#'           PublishMetricAction = list(
#'             Dimensions = list(
#'               list(
#'                 Value = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123,
#'         Override = list(
#'           Action = "DROP_TO_ALERT"
#'         ),
#'         DeepThreatInspection = TRUE|FALSE
#'       )
#'     ),
#'     StatefulDefaultActions = list(
#'       "string"
#'     ),
#'     StatefulEngineOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER",
#'       StreamExceptionPolicy = "DROP"|"CONTINUE"|"REJECT",
#'       FlowTimeouts = list(
#'         TcpIdleTimeoutSeconds = 123
#'       )
#'     ),
#'     TLSInspectionConfigurationArn = "string",
#'     PolicyVariables = list(
#'       RuleVariables = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     EnableTLSSessionHolding = TRUE|FALSE
#'   ),
#'   Description = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   DryRun = TRUE|FALSE,
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_firewall_policy
#'
#' @aliases networkfirewall_create_firewall_policy
networkfirewall_create_firewall_policy <- function(FirewallPolicyName, FirewallPolicy, Description = NULL, Tags = NULL, DryRun = NULL, EncryptionConfiguration = NULL) {
  op <- new_operation(
    name = "CreateFirewallPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_firewall_policy_input(FirewallPolicyName = FirewallPolicyName, FirewallPolicy = FirewallPolicy, Description = Description, Tags = Tags, DryRun = DryRun, EncryptionConfiguration = EncryptionConfiguration)
  output <- .networkfirewall$create_firewall_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_firewall_policy <- networkfirewall_create_firewall_policy

#' Creates an Network Firewall Proxy
#'
#' @description
#' Creates an Network Firewall Proxy
#' 
#' Attaches a Proxy configuration to a NAT Gateway.
#' 
#' To manage a proxy's tags, use the standard Amazon Web Services resource
#' tagging operations,
#' [`list_tags_for_resource`][networkfirewall_list_tags_for_resource],
#' [`tag_resource`][networkfirewall_tag_resource], and
#' [`untag_resource`][networkfirewall_untag_resource].
#' 
#' To retrieve information about proxies, use
#' [`list_proxies`][networkfirewall_list_proxies] and
#' [`describe_proxy`][networkfirewall_describe_proxy].
#'
#' @usage
#' networkfirewall_create_proxy(ProxyName, NatGatewayId,
#'   ProxyConfigurationName, ProxyConfigurationArn, ListenerProperties,
#'   TlsInterceptProperties, Tags)
#'
#' @param ProxyName &#91;required&#93; The descriptive name of the proxy. You can't change the name of a proxy
#' after you create it.
#' @param NatGatewayId &#91;required&#93; A unique identifier for the NAT gateway to use with proxy resources.
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ListenerProperties Listener properties for HTTP and HTTPS traffic.
#' @param TlsInterceptProperties &#91;required&#93; TLS decryption on traffic to filter on attributes in the HTTP header.
#' @param Tags The key:value pairs to associate with the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Proxy = list(
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureCode = "string",
#'     FailureMessage = "string",
#'     ProxyState = "ATTACHING"|"ATTACHED"|"DETACHING"|"DETACHED"|"ATTACH_FAILED"|"DETACH_FAILED",
#'     ProxyModifyState = "MODIFYING"|"COMPLETED"|"FAILED",
#'     NatGatewayId = "string",
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     ProxyName = "string",
#'     ProxyArn = "string",
#'     ListenerProperties = list(
#'       list(
#'         Port = 123,
#'         Type = "HTTP"|"HTTPS"
#'       )
#'     ),
#'     TlsInterceptProperties = list(
#'       PcaArn = "string",
#'       TlsInterceptMode = "ENABLED"|"DISABLED"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_proxy(
#'   ProxyName = "string",
#'   NatGatewayId = "string",
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string",
#'   ListenerProperties = list(
#'     list(
#'       Port = 123,
#'       Type = "HTTP"|"HTTPS"
#'     )
#'   ),
#'   TlsInterceptProperties = list(
#'     PcaArn = "string",
#'     TlsInterceptMode = "ENABLED"|"DISABLED"
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_proxy
#'
#' @aliases networkfirewall_create_proxy
networkfirewall_create_proxy <- function(ProxyName, NatGatewayId, ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL, ListenerProperties = NULL, TlsInterceptProperties, Tags = NULL) {
  op <- new_operation(
    name = "CreateProxy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_proxy_input(ProxyName = ProxyName, NatGatewayId = NatGatewayId, ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn, ListenerProperties = ListenerProperties, TlsInterceptProperties = TlsInterceptProperties, Tags = Tags)
  output <- .networkfirewall$create_proxy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_proxy <- networkfirewall_create_proxy

#' Creates an Network Firewall ProxyConfiguration
#'
#' @description
#' Creates an Network Firewall ProxyConfiguration
#' 
#' A Proxy Configuration defines the monitoring and protection behavior for
#' a Proxy. The details of the behavior are defined in the rule groups that
#' you add to your configuration.
#' 
#' To manage a proxy configuration's tags, use the standard Amazon Web
#' Services resource tagging operations,
#' [`list_tags_for_resource`][networkfirewall_list_tags_for_resource],
#' [`tag_resource`][networkfirewall_tag_resource], and
#' [`untag_resource`][networkfirewall_untag_resource].
#' 
#' To retrieve information about proxies, use
#' [`list_proxy_configurations`][networkfirewall_list_proxy_configurations]
#' and
#' [`describe_proxy_configuration`][networkfirewall_describe_proxy_configuration].
#'
#' @usage
#' networkfirewall_create_proxy_configuration(ProxyConfigurationName,
#'   Description, RuleGroupNames, RuleGroupArns, DefaultRulePhaseActions,
#'   Tags)
#'
#' @param ProxyConfigurationName &#91;required&#93; The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' @param Description A description of the proxy configuration.
#' @param RuleGroupNames The proxy rule group name(s) to attach to the proxy configuration.
#' 
#' You must specify the ARNs or the names, and you can specify both.
#' @param RuleGroupArns The proxy rule group arn(s) to attach to the proxy configuration.
#' 
#' You must specify the ARNs or the names, and you can specify both.
#' @param DefaultRulePhaseActions &#91;required&#93; Evaluation points in the traffic flow where rules are applied. There are
#' three phases in a traffic where the rule match is applied.
#' @param Tags The key:value pairs to associate with the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfiguration = list(
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     Description = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RuleGroups = list(
#'       list(
#'         ProxyRuleGroupName = "string",
#'         ProxyRuleGroupArn = "string",
#'         Type = "string",
#'         Priority = 123
#'       )
#'     ),
#'     DefaultRulePhaseActions = list(
#'       PreDNS = "ALLOW"|"DENY"|"ALERT",
#'       PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'       PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   Description = "string",
#'   RuleGroupNames = list(
#'     "string"
#'   ),
#'   RuleGroupArns = list(
#'     "string"
#'   ),
#'   DefaultRulePhaseActions = list(
#'     PreDNS = "ALLOW"|"DENY"|"ALERT",
#'     PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'     PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_proxy_configuration
#'
#' @aliases networkfirewall_create_proxy_configuration
networkfirewall_create_proxy_configuration <- function(ProxyConfigurationName, Description = NULL, RuleGroupNames = NULL, RuleGroupArns = NULL, DefaultRulePhaseActions, Tags = NULL) {
  op <- new_operation(
    name = "CreateProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, Description = Description, RuleGroupNames = RuleGroupNames, RuleGroupArns = RuleGroupArns, DefaultRulePhaseActions = DefaultRulePhaseActions, Tags = Tags)
  output <- .networkfirewall$create_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_proxy_configuration <- networkfirewall_create_proxy_configuration

#' Creates an Network Firewall ProxyRuleGroup
#'
#' @description
#' Creates an Network Firewall ProxyRuleGroup
#' 
#' Collections of related proxy filtering rules. Rule groups help you
#' manage and reuse sets of rules across multiple proxy configurations.
#' 
#' To manage a proxy rule group's tags, use the standard Amazon Web
#' Services resource tagging operations,
#' [`list_tags_for_resource`][networkfirewall_list_tags_for_resource],
#' [`tag_resource`][networkfirewall_tag_resource], and
#' [`untag_resource`][networkfirewall_untag_resource].
#' 
#' To retrieve information about proxy rule groups, use
#' [`list_proxy_rule_groups`][networkfirewall_list_proxy_rule_groups] and
#' [`describe_proxy_rule_group`][networkfirewall_describe_proxy_rule_group].
#' 
#' To retrieve information about individual proxy rules, use
#' [`describe_proxy_rule_group`][networkfirewall_describe_proxy_rule_group]
#' and [`describe_proxy_rule`][networkfirewall_describe_proxy_rule].
#'
#' @usage
#' networkfirewall_create_proxy_rule_group(ProxyRuleGroupName, Description,
#'   Rules, Tags)
#'
#' @param ProxyRuleGroupName &#91;required&#93; The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' @param Description A description of the proxy rule group.
#' @param Rules Individual rules that define match conditions and actions for
#' application-layer traffic. Rules specify what to inspect (domains,
#' headers, methods) and what action to take (allow, deny, alert).
#' @param Tags The key:value pairs to associate with the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroup = list(
#'     ProxyRuleGroupName = "string",
#'     ProxyRuleGroupArn = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Rules = list(
#'       PreDNS = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PreREQUEST = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PostRESPONSE = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_proxy_rule_group(
#'   ProxyRuleGroupName = "string",
#'   Description = "string",
#'   Rules = list(
#'     PreDNS = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     PreREQUEST = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     PostRESPONSE = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_proxy_rule_group
#'
#' @aliases networkfirewall_create_proxy_rule_group
networkfirewall_create_proxy_rule_group <- function(ProxyRuleGroupName, Description = NULL, Rules = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateProxyRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_proxy_rule_group_input(ProxyRuleGroupName = ProxyRuleGroupName, Description = Description, Rules = Rules, Tags = Tags)
  output <- .networkfirewall$create_proxy_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_proxy_rule_group <- networkfirewall_create_proxy_rule_group

#' Creates Network Firewall ProxyRule resources
#'
#' @description
#' Creates Network Firewall ProxyRule resources.
#' 
#' Attaches new proxy rule(s) to an existing proxy rule group.
#' 
#' To retrieve information about individual proxy rules, use
#' [`describe_proxy_rule_group`][networkfirewall_describe_proxy_rule_group]
#' and [`describe_proxy_rule`][networkfirewall_describe_proxy_rule].
#'
#' @usage
#' networkfirewall_create_proxy_rules(ProxyRuleGroupArn,
#'   ProxyRuleGroupName, Rules)
#'
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Rules &#91;required&#93; Individual rules that define match conditions and actions for
#' application-layer traffic. Rules specify what to inspect (domains,
#' headers, methods) and what action to take (allow, deny, alert).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroup = list(
#'     ProxyRuleGroupName = "string",
#'     ProxyRuleGroupArn = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Rules = list(
#'       PreDNS = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PreREQUEST = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PostRESPONSE = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_proxy_rules(
#'   ProxyRuleGroupArn = "string",
#'   ProxyRuleGroupName = "string",
#'   Rules = list(
#'     PreDNS = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         InsertPosition = 123
#'       )
#'     ),
#'     PreREQUEST = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         InsertPosition = 123
#'       )
#'     ),
#'     PostRESPONSE = list(
#'       list(
#'         ProxyRuleName = "string",
#'         Description = "string",
#'         Action = "ALLOW"|"DENY"|"ALERT",
#'         Conditions = list(
#'           list(
#'             ConditionOperator = "string",
#'             ConditionKey = "string",
#'             ConditionValues = list(
#'               "string"
#'             )
#'           )
#'         ),
#'         InsertPosition = 123
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_proxy_rules
#'
#' @aliases networkfirewall_create_proxy_rules
networkfirewall_create_proxy_rules <- function(ProxyRuleGroupArn = NULL, ProxyRuleGroupName = NULL, Rules) {
  op <- new_operation(
    name = "CreateProxyRules",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_proxy_rules_input(ProxyRuleGroupArn = ProxyRuleGroupArn, ProxyRuleGroupName = ProxyRuleGroupName, Rules = Rules)
  output <- .networkfirewall$create_proxy_rules_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_proxy_rules <- networkfirewall_create_proxy_rules

#' Creates the specified stateless or stateful rule group, which includes
#' the rules for network traffic inspection, a capacity setting, and tags
#'
#' @description
#' Creates the specified stateless or stateful rule group, which includes
#' the rules for network traffic inspection, a capacity setting, and tags.
#' 
#' You provide your rule group specification in your request using either
#' `RuleGroup` or `Rules`.
#'
#' @usage
#' networkfirewall_create_rule_group(RuleGroupName, RuleGroup, Rules, Type,
#'   Description, Capacity, Tags, DryRun, EncryptionConfiguration,
#'   SourceMetadata, AnalyzeRuleGroup, SummaryConfiguration)
#'
#' @param RuleGroupName &#91;required&#93; The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' @param RuleGroup An object that defines the rule group rules.
#' 
#' You must provide either this rule group setting or a `Rules` setting,
#' but not both.
#' @param Rules A string containing stateful rule group rules specifications in Suricata
#' flat format, with one rule per line. Use this to import your existing
#' Suricata compatible rule groups.
#' 
#' You must provide either this rules setting or a populated `RuleGroup`
#' setting, but not both.
#' 
#' You can provide your rule group specification in Suricata flat format
#' through this setting when you create or update your rule group. The call
#' response returns a RuleGroup object that Network Firewall has populated
#' from your string.
#' @param Type &#91;required&#93; Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#' @param Description A description of the rule group.
#' @param Capacity &#91;required&#93; The maximum operating resources that this rule group can use. Rule group
#' capacity is fixed at creation. When you update a rule group, you are
#' limited to this capacity. When you reference a rule group from a
#' firewall policy, Network Firewall reserves this capacity for the rule
#' group.
#' 
#' You can retrieve the capacity that would be required for a rule group
#' before you create the rule group by calling
#' [`create_rule_group`][networkfirewall_create_rule_group] with `DryRun`
#' set to `TRUE`.
#' 
#' You can't change or exceed this capacity when you update the rule group,
#' so leave room for your rule group to grow.
#' 
#' **Capacity for a stateless rule group**
#' 
#' For a stateless rule group, the capacity required is the sum of the
#' capacity requirements of the individual rules that you expect to have in
#' the rule group.
#' 
#' To calculate the capacity requirement of a single rule, multiply the
#' capacity requirement values of each of the rule's match settings:
#' 
#' -   A match setting with no criteria specified has a value of 1.
#' 
#' -   A match setting with `Any` specified has a value of 1.
#' 
#' -   All other match settings have a value equal to the number of
#'     elements provided in the setting. For example, a protocol setting
#'     \["UDP"\] and a source setting \["10.0.0.0/24"\] each have a value
#'     of 1. A protocol setting \["UDP","TCP"\] has a value of 2. A source
#'     setting \["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"\] has a value of
#'     3.
#' 
#' A rule with no criteria specified in any of its match settings has a
#' capacity requirement of 1. A rule with protocol setting \["UDP","TCP"\],
#' source setting \["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"\], and a
#' single specification or no specification for each of the other match
#' settings has a capacity requirement of 6.
#' 
#' **Capacity for a stateful rule group**
#' 
#' For a stateful rule group, the minimum capacity required is the number
#' of individual rules that you expect to have in the rule group.
#' @param Tags The key:value pairs to associate with the resource.
#' @param DryRun Indicates whether you want Network Firewall to just check the validity
#' of the request, rather than run the request.
#' 
#' If set to `TRUE`, Network Firewall checks whether the request can run
#' successfully, but doesn't actually make the requested changes. The call
#' returns the value that the request would return if you ran it with dry
#' run set to `FALSE`, but doesn't make additions or changes to your
#' resources. This option allows you to make sure that you have the
#' required permissions to run the request and that your request parameters
#' are valid.
#' 
#' If set to `FALSE`, Network Firewall makes the requested changes to your
#' resources.
#' @param EncryptionConfiguration A complex type that contains settings for encryption of your rule group
#' resources.
#' @param SourceMetadata A complex type that contains metadata about the rule group that your own
#' rule group is copied from. You can use the metadata to keep track of
#' updates made to the originating rule group.
#' @param AnalyzeRuleGroup Indicates whether you want Network Firewall to analyze the stateless
#' rules in the rule group for rule behavior such as asymmetric routing. If
#' set to `TRUE`, Network Firewall runs the analysis and then creates the
#' rule group for you. To run the stateless rule group analyzer without
#' creating the rule group, set `DryRun` to `TRUE`.
#' @param SummaryConfiguration An object that contains a `RuleOptions` array of strings. You use
#' `RuleOptions` to determine which of the following RuleSummary values are
#' returned in response to
#' [`describe_rule_group_summary`][networkfirewall_describe_rule_group_summary].
#' 
#' -   `Metadata` - returns
#' 
#' -   `Msg`
#' 
#' -   `SID`
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   RuleGroupResponse = list(
#'     RuleGroupArn = "string",
#'     RuleGroupName = "string",
#'     RuleGroupId = "string",
#'     Description = "string",
#'     Type = "STATELESS"|"STATEFUL",
#'     Capacity = 123,
#'     RuleGroupStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     SourceMetadata = list(
#'       SourceArn = "string",
#'       SourceUpdateToken = "string"
#'     ),
#'     SnsTopic = "string",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AnalysisResults = list(
#'       list(
#'         IdentifiedRuleIds = list(
#'           "string"
#'         ),
#'         IdentifiedType = "STATELESS_RULE_FORWARDING_ASYMMETRICALLY"|"STATELESS_RULE_CONTAINS_TCP_FLAGS",
#'         AnalysisDetail = "string"
#'       )
#'     ),
#'     SummaryConfiguration = list(
#'       RuleOptions = list(
#'         "SID"|"MSG"|"METADATA"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_rule_group(
#'   RuleGroupName = "string",
#'   RuleGroup = list(
#'     RuleVariables = list(
#'       IPSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       PortSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ReferenceSets = list(
#'       IPSetReferences = list(
#'         list(
#'           ReferenceArn = "string"
#'         )
#'       )
#'     ),
#'     RulesSource = list(
#'       RulesString = "string",
#'       RulesSourceList = list(
#'         Targets = list(
#'           "string"
#'         ),
#'         TargetTypes = list(
#'           "TLS_SNI"|"HTTP_HOST"
#'         ),
#'         GeneratedRulesType = "ALLOWLIST"|"DENYLIST"|"REJECTLIST"|"ALERTLIST"
#'       ),
#'       StatefulRules = list(
#'         list(
#'           Action = "PASS"|"DROP"|"ALERT"|"REJECT",
#'           Header = list(
#'             Protocol = "IP"|"TCP"|"UDP"|"ICMP"|"HTTP"|"FTP"|"TLS"|"SMB"|"DNS"|"DCERPC"|"SSH"|"SMTP"|"IMAP"|"MSN"|"KRB5"|"IKEV2"|"TFTP"|"NTP"|"DHCP"|"HTTP2"|"QUIC",
#'             Source = "string",
#'             SourcePort = "string",
#'             Direction = "FORWARD"|"ANY",
#'             Destination = "string",
#'             DestinationPort = "string"
#'           ),
#'           RuleOptions = list(
#'             list(
#'               Keyword = "string",
#'               Settings = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       StatelessRulesAndCustomActions = list(
#'         StatelessRules = list(
#'           list(
#'             RuleDefinition = list(
#'               MatchAttributes = list(
#'                 Sources = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 Destinations = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 SourcePorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 DestinationPorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 Protocols = list(
#'                   123
#'                 ),
#'                 TCPFlags = list(
#'                   list(
#'                     Flags = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     ),
#'                     Masks = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     )
#'                   )
#'                 )
#'               ),
#'               Actions = list(
#'                 "string"
#'               )
#'             ),
#'             Priority = 123
#'           )
#'         ),
#'         CustomActions = list(
#'           list(
#'             ActionName = "string",
#'             ActionDefinition = list(
#'               PublishMetricAction = list(
#'                 Dimensions = list(
#'                   list(
#'                     Value = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER"
#'     )
#'   ),
#'   Rules = "string",
#'   Type = "STATELESS"|"STATEFUL",
#'   Description = "string",
#'   Capacity = 123,
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   DryRun = TRUE|FALSE,
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   ),
#'   SourceMetadata = list(
#'     SourceArn = "string",
#'     SourceUpdateToken = "string"
#'   ),
#'   AnalyzeRuleGroup = TRUE|FALSE,
#'   SummaryConfiguration = list(
#'     RuleOptions = list(
#'       "SID"|"MSG"|"METADATA"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_rule_group
#'
#' @aliases networkfirewall_create_rule_group
networkfirewall_create_rule_group <- function(RuleGroupName, RuleGroup = NULL, Rules = NULL, Type, Description = NULL, Capacity, Tags = NULL, DryRun = NULL, EncryptionConfiguration = NULL, SourceMetadata = NULL, AnalyzeRuleGroup = NULL, SummaryConfiguration = NULL) {
  op <- new_operation(
    name = "CreateRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_rule_group_input(RuleGroupName = RuleGroupName, RuleGroup = RuleGroup, Rules = Rules, Type = Type, Description = Description, Capacity = Capacity, Tags = Tags, DryRun = DryRun, EncryptionConfiguration = EncryptionConfiguration, SourceMetadata = SourceMetadata, AnalyzeRuleGroup = AnalyzeRuleGroup, SummaryConfiguration = SummaryConfiguration)
  output <- .networkfirewall$create_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_rule_group <- networkfirewall_create_rule_group

#' Creates an Network Firewall TLS inspection configuration
#'
#' @description
#' Creates an Network Firewall TLS inspection configuration. Network
#' Firewall uses TLS inspection configurations to decrypt your firewall's
#' inbound and outbound SSL/TLS traffic. After decryption, Network Firewall
#' inspects the traffic according to your firewall policy's stateful rules,
#' and then re-encrypts it before sending it to its destination. You can
#' enable inspection of your firewall's inbound traffic, outbound traffic,
#' or both. To use TLS inspection with your firewall, you must first import
#' or provision certificates using ACM, create a TLS inspection
#' configuration, add that configuration to a new firewall policy, and then
#' associate that policy with your firewall.
#' 
#' To update the settings for a TLS inspection configuration, use
#' [`update_tls_inspection_configuration`][networkfirewall_update_tls_inspection_configuration].
#' 
#' To manage a TLS inspection configuration's tags, use the standard Amazon
#' Web Services resource tagging operations,
#' [`list_tags_for_resource`][networkfirewall_list_tags_for_resource],
#' [`tag_resource`][networkfirewall_tag_resource], and
#' [`untag_resource`][networkfirewall_untag_resource].
#' 
#' To retrieve information about TLS inspection configurations, use
#' [`list_tls_inspection_configurations`][networkfirewall_list_tls_inspection_configurations]
#' and
#' [`describe_tls_inspection_configuration`][networkfirewall_describe_tls_inspection_configuration].
#' 
#' For more information about TLS inspection configurations, see
#' [Inspecting SSL/TLS traffic with TLS inspection
#' configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/)
#' in the *Network Firewall Developer Guide*.
#'
#' @usage
#' networkfirewall_create_tls_inspection_configuration(
#'   TLSInspectionConfigurationName, TLSInspectionConfiguration, Description,
#'   Tags, EncryptionConfiguration)
#'
#' @param TLSInspectionConfigurationName &#91;required&#93; The descriptive name of the TLS inspection configuration. You can't
#' change the name of a TLS inspection configuration after you create it.
#' @param TLSInspectionConfiguration &#91;required&#93; The object that defines a TLS inspection configuration. This, along with
#' TLSInspectionConfigurationResponse, define the TLS inspection
#' configuration. You can retrieve all objects for a TLS inspection
#' configuration by calling
#' [`describe_tls_inspection_configuration`][networkfirewall_describe_tls_inspection_configuration].
#' 
#' Network Firewall uses a TLS inspection configuration to decrypt traffic.
#' Network Firewall re-encrypts the traffic before sending it to its
#' destination.
#' 
#' To use a TLS inspection configuration, you add it to a new Network
#' Firewall firewall policy, then you apply the firewall policy to a
#' firewall. Network Firewall acts as a proxy service to decrypt and
#' inspect the traffic traveling through your firewalls. You can reference
#' a TLS inspection configuration from more than one firewall policy, and
#' you can use a firewall policy in more than one firewall. For more
#' information about using TLS inspection configurations, see [Inspecting
#' SSL/TLS traffic with TLS inspection
#' configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/)
#' in the *Network Firewall Developer Guide*.
#' @param Description A description of the TLS inspection configuration.
#' @param Tags The key:value pairs to associate with the resource.
#' @param EncryptionConfiguration 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   TLSInspectionConfigurationResponse = list(
#'     TLSInspectionConfigurationArn = "string",
#'     TLSInspectionConfigurationName = "string",
#'     TLSInspectionConfigurationId = "string",
#'     TLSInspectionConfigurationStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     Certificates = list(
#'       list(
#'         CertificateArn = "string",
#'         CertificateSerial = "string",
#'         Status = "string",
#'         StatusMessage = "string"
#'       )
#'     ),
#'     CertificateAuthority = list(
#'       CertificateArn = "string",
#'       CertificateSerial = "string",
#'       Status = "string",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_tls_inspection_configuration(
#'   TLSInspectionConfigurationName = "string",
#'   TLSInspectionConfiguration = list(
#'     ServerCertificateConfigurations = list(
#'       list(
#'         ServerCertificates = list(
#'           list(
#'             ResourceArn = "string"
#'           )
#'         ),
#'         Scopes = list(
#'           list(
#'             Sources = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             Destinations = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             SourcePorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             DestinationPorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             Protocols = list(
#'               123
#'             )
#'           )
#'         ),
#'         CertificateAuthorityArn = "string",
#'         CheckCertificateRevocationStatus = list(
#'           RevokedStatusAction = "PASS"|"DROP"|"REJECT",
#'           UnknownStatusAction = "PASS"|"DROP"|"REJECT"
#'         )
#'       )
#'     )
#'   ),
#'   Description = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_tls_inspection_configuration
#'
#' @aliases networkfirewall_create_tls_inspection_configuration
networkfirewall_create_tls_inspection_configuration <- function(TLSInspectionConfigurationName, TLSInspectionConfiguration, Description = NULL, Tags = NULL, EncryptionConfiguration = NULL) {
  op <- new_operation(
    name = "CreateTLSInspectionConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_tls_inspection_configuration_input(TLSInspectionConfigurationName = TLSInspectionConfigurationName, TLSInspectionConfiguration = TLSInspectionConfiguration, Description = Description, Tags = Tags, EncryptionConfiguration = EncryptionConfiguration)
  output <- .networkfirewall$create_tls_inspection_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_tls_inspection_configuration <- networkfirewall_create_tls_inspection_configuration

#' Creates a firewall endpoint for an Network Firewall firewall
#'
#' @description
#' Creates a firewall endpoint for an Network Firewall firewall. This type
#' of firewall endpoint is independent of the firewall endpoints that you
#' specify in the `Firewall` itself, and you define it in addition to those
#' endpoints after the firewall has been created. You can define a VPC
#' endpoint association using a different VPC than the one you used in the
#' firewall specifications.
#'
#' @usage
#' networkfirewall_create_vpc_endpoint_association(FirewallArn, VpcId,
#'   SubnetMapping, Description, Tags)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param VpcId &#91;required&#93; The unique identifier of the VPC where you want to create a firewall
#' endpoint.
#' @param SubnetMapping &#91;required&#93; 
#' @param Description A description of the VPC endpoint association.
#' @param Tags The key:value pairs to associate with the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcEndpointAssociation = list(
#'     VpcEndpointAssociationId = "string",
#'     VpcEndpointAssociationArn = "string",
#'     FirewallArn = "string",
#'     VpcId = "string",
#'     SubnetMapping = list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   VpcEndpointAssociationStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     AssociationSyncState = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_vpc_endpoint_association(
#'   FirewallArn = "string",
#'   VpcId = "string",
#'   SubnetMapping = list(
#'     SubnetId = "string",
#'     IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'   ),
#'   Description = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_create_vpc_endpoint_association
#'
#' @aliases networkfirewall_create_vpc_endpoint_association
networkfirewall_create_vpc_endpoint_association <- function(FirewallArn, VpcId, SubnetMapping, Description = NULL, Tags = NULL) {
  op <- new_operation(
    name = "CreateVpcEndpointAssociation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$create_vpc_endpoint_association_input(FirewallArn = FirewallArn, VpcId = VpcId, SubnetMapping = SubnetMapping, Description = Description, Tags = Tags)
  output <- .networkfirewall$create_vpc_endpoint_association_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$create_vpc_endpoint_association <- networkfirewall_create_vpc_endpoint_association

#' Deletes the specified Firewall and its FirewallStatus
#'
#' @description
#' Deletes the specified Firewall and its FirewallStatus. This operation
#' requires the firewall's `DeleteProtection` flag to be `FALSE`. You can't
#' revert this operation.
#' 
#' You can check whether a firewall is in use by reviewing the route tables
#' for the Availability Zones where you have firewall subnet mappings.
#' Retrieve the subnet mappings by calling
#' [`describe_firewall`][networkfirewall_describe_firewall]. You define and
#' update the route tables through Amazon VPC. As needed, update the route
#' tables for the zones to remove the firewall endpoints. When the route
#' tables no longer use the firewall endpoints, you can remove the firewall
#' safely.
#' 
#' To delete a firewall, remove the delete protection if you need to using
#' [`update_firewall_delete_protection`][networkfirewall_update_firewall_delete_protection],
#' then delete the firewall by calling
#' [`delete_firewall`][networkfirewall_delete_firewall].
#'
#' @usage
#' networkfirewall_delete_firewall(FirewallName, FirewallArn)
#'
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Firewall = list(
#'     FirewallName = "string",
#'     FirewallArn = "string",
#'     FirewallPolicyArn = "string",
#'     VpcId = "string",
#'     SubnetMappings = list(
#'       list(
#'         SubnetId = "string",
#'         IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'       )
#'     ),
#'     DeleteProtection = TRUE|FALSE,
#'     SubnetChangeProtection = TRUE|FALSE,
#'     FirewallPolicyChangeProtection = TRUE|FALSE,
#'     Description = "string",
#'     FirewallId = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     NumberOfAssociations = 123,
#'     EnabledAnalysisTypes = list(
#'       "TLS_SNI"|"HTTP_HOST"
#'     ),
#'     TransitGatewayId = "string",
#'     TransitGatewayOwnerAccountId = "string",
#'     AvailabilityZoneMappings = list(
#'       list(
#'         AvailabilityZone = "string"
#'       )
#'     ),
#'     AvailabilityZoneChangeProtection = TRUE|FALSE
#'   ),
#'   FirewallStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     ConfigurationSyncStateSummary = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED",
#'     SyncStates = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         ),
#'         Config = list(
#'           list(
#'             SyncStatus = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED"|"NOT_SUBSCRIBED"|"DEPRECATED",
#'             UpdateToken = "string"
#'           )
#'         )
#'       )
#'     ),
#'     CapacityUsageSummary = list(
#'       CIDRs = list(
#'         AvailableCIDRCount = 123,
#'         UtilizedCIDRCount = 123,
#'         IPSetReferences = list(
#'           list(
#'             ResolvedCIDRCount = 123
#'           )
#'         )
#'       )
#'     ),
#'     TransitGatewayAttachmentSyncState = list(
#'       AttachmentId = "string",
#'       TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_firewall(
#'   FirewallName = "string",
#'   FirewallArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_firewall
#'
#' @aliases networkfirewall_delete_firewall
networkfirewall_delete_firewall <- function(FirewallName = NULL, FirewallArn = NULL) {
  op <- new_operation(
    name = "DeleteFirewall",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_firewall_input(FirewallName = FirewallName, FirewallArn = FirewallArn)
  output <- .networkfirewall$delete_firewall_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_firewall <- networkfirewall_delete_firewall

#' Deletes the specified FirewallPolicy
#'
#' @description
#' Deletes the specified FirewallPolicy.
#'
#' @usage
#' networkfirewall_delete_firewall_policy(FirewallPolicyName,
#'   FirewallPolicyArn)
#'
#' @param FirewallPolicyName The descriptive name of the firewall policy. You can't change the name
#' of a firewall policy after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicyArn The Amazon Resource Name (ARN) of the firewall policy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallPolicyResponse = list(
#'     FirewallPolicyName = "string",
#'     FirewallPolicyArn = "string",
#'     FirewallPolicyId = "string",
#'     Description = "string",
#'     FirewallPolicyStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedStatelessRuleCapacity = 123,
#'     ConsumedStatefulRuleCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_firewall_policy(
#'   FirewallPolicyName = "string",
#'   FirewallPolicyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_firewall_policy
#'
#' @aliases networkfirewall_delete_firewall_policy
networkfirewall_delete_firewall_policy <- function(FirewallPolicyName = NULL, FirewallPolicyArn = NULL) {
  op <- new_operation(
    name = "DeleteFirewallPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_firewall_policy_input(FirewallPolicyName = FirewallPolicyName, FirewallPolicyArn = FirewallPolicyArn)
  output <- .networkfirewall$delete_firewall_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_firewall_policy <- networkfirewall_delete_firewall_policy

#' Deletes a transit gateway attachment from a Network Firewall
#'
#' @description
#' Deletes a transit gateway attachment from a Network Firewall. Either the
#' firewall owner or the transit gateway owner can delete the attachment.
#' 
#' After you delete a transit gateway attachment, traffic will no longer
#' flow through the firewall endpoints.
#' 
#' After you initiate the delete operation, use
#' [`describe_firewall`][networkfirewall_describe_firewall] to monitor the
#' deletion status.
#'
#' @usage
#' networkfirewall_delete_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId)
#'
#' @param TransitGatewayAttachmentId &#91;required&#93; Required. The unique identifier of the transit gateway attachment to
#' delete.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransitGatewayAttachmentId = "string",
#'   TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delet_netwo_firew_trans_gatew_attac
#'
#' @aliases networkfirewall_delete_network_firewall_transit_gateway_attachment
networkfirewall_delete_network_firewall_transit_gateway_attachment <- function(TransitGatewayAttachmentId) {
  op <- new_operation(
    name = "DeleteNetworkFirewallTransitGatewayAttachment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_network_firewall_transit_gateway_attachment_input(TransitGatewayAttachmentId = TransitGatewayAttachmentId)
  output <- .networkfirewall$delete_network_firewall_transit_gateway_attachment_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_network_firewall_transit_gateway_attachment <- networkfirewall_delete_network_firewall_transit_gateway_attachment

#' Deletes the specified Proxy
#'
#' @description
#' Deletes the specified Proxy.
#' 
#' Detaches a Proxy configuration from a NAT Gateway.
#'
#' @usage
#' networkfirewall_delete_proxy(NatGatewayId, ProxyName, ProxyArn)
#'
#' @param NatGatewayId &#91;required&#93; The NAT Gateway the proxy is attached to.
#' @param ProxyName The descriptive name of the proxy. You can't change the name of a proxy
#' after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyArn The Amazon Resource Name (ARN) of a proxy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NatGatewayId = "string",
#'   ProxyName = "string",
#'   ProxyArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_proxy(
#'   NatGatewayId = "string",
#'   ProxyName = "string",
#'   ProxyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_proxy
#'
#' @aliases networkfirewall_delete_proxy
networkfirewall_delete_proxy <- function(NatGatewayId, ProxyName = NULL, ProxyArn = NULL) {
  op <- new_operation(
    name = "DeleteProxy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_proxy_input(NatGatewayId = NatGatewayId, ProxyName = ProxyName, ProxyArn = ProxyArn)
  output <- .networkfirewall$delete_proxy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_proxy <- networkfirewall_delete_proxy

#' Deletes the specified ProxyConfiguration
#'
#' @description
#' Deletes the specified ProxyConfiguration.
#'
#' @usage
#' networkfirewall_delete_proxy_configuration(ProxyConfigurationName,
#'   ProxyConfigurationArn)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_proxy_configuration
#'
#' @aliases networkfirewall_delete_proxy_configuration
networkfirewall_delete_proxy_configuration <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL) {
  op <- new_operation(
    name = "DeleteProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn)
  output <- .networkfirewall$delete_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_proxy_configuration <- networkfirewall_delete_proxy_configuration

#' Deletes the specified ProxyRuleGroup
#'
#' @description
#' Deletes the specified ProxyRuleGroup.
#'
#' @usage
#' networkfirewall_delete_proxy_rule_group(ProxyRuleGroupName,
#'   ProxyRuleGroupArn)
#'
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_proxy_rule_group(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_proxy_rule_group
#'
#' @aliases networkfirewall_delete_proxy_rule_group
networkfirewall_delete_proxy_rule_group <- function(ProxyRuleGroupName = NULL, ProxyRuleGroupArn = NULL) {
  op <- new_operation(
    name = "DeleteProxyRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_proxy_rule_group_input(ProxyRuleGroupName = ProxyRuleGroupName, ProxyRuleGroupArn = ProxyRuleGroupArn)
  output <- .networkfirewall$delete_proxy_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_proxy_rule_group <- networkfirewall_delete_proxy_rule_group

#' Deletes the specified ProxyRule(s)
#'
#' @description
#' Deletes the specified ProxyRule(s). currently attached to a
#' ProxyRuleGroup
#'
#' @usage
#' networkfirewall_delete_proxy_rules(ProxyRuleGroupArn,
#'   ProxyRuleGroupName, Rules)
#'
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Rules &#91;required&#93; The proxy rule(s) to remove from the existing proxy rule group.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroup = list(
#'     ProxyRuleGroupName = "string",
#'     ProxyRuleGroupArn = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Rules = list(
#'       PreDNS = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PreREQUEST = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PostRESPONSE = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_proxy_rules(
#'   ProxyRuleGroupArn = "string",
#'   ProxyRuleGroupName = "string",
#'   Rules = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_proxy_rules
#'
#' @aliases networkfirewall_delete_proxy_rules
networkfirewall_delete_proxy_rules <- function(ProxyRuleGroupArn = NULL, ProxyRuleGroupName = NULL, Rules) {
  op <- new_operation(
    name = "DeleteProxyRules",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_proxy_rules_input(ProxyRuleGroupArn = ProxyRuleGroupArn, ProxyRuleGroupName = ProxyRuleGroupName, Rules = Rules)
  output <- .networkfirewall$delete_proxy_rules_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_proxy_rules <- networkfirewall_delete_proxy_rules

#' Deletes a resource policy that you created in a PutResourcePolicy
#' request
#'
#' @description
#' Deletes a resource policy that you created in a
#' [`put_resource_policy`][networkfirewall_put_resource_policy] request.
#'
#' @usage
#' networkfirewall_delete_resource_policy(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the rule group or firewall policy
#' whose resource policy you want to delete.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_resource_policy(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_resource_policy
#'
#' @aliases networkfirewall_delete_resource_policy
networkfirewall_delete_resource_policy <- function(ResourceArn) {
  op <- new_operation(
    name = "DeleteResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_resource_policy_input(ResourceArn = ResourceArn)
  output <- .networkfirewall$delete_resource_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_resource_policy <- networkfirewall_delete_resource_policy

#' Deletes the specified RuleGroup
#'
#' @description
#' Deletes the specified RuleGroup.
#'
#' @usage
#' networkfirewall_delete_rule_group(RuleGroupName, RuleGroupArn, Type)
#'
#' @param RuleGroupName The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupArn The Amazon Resource Name (ARN) of the rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Type Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#' 
#' This setting is required for requests that do not include the
#' `RuleGroupARN`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RuleGroupResponse = list(
#'     RuleGroupArn = "string",
#'     RuleGroupName = "string",
#'     RuleGroupId = "string",
#'     Description = "string",
#'     Type = "STATELESS"|"STATEFUL",
#'     Capacity = 123,
#'     RuleGroupStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     SourceMetadata = list(
#'       SourceArn = "string",
#'       SourceUpdateToken = "string"
#'     ),
#'     SnsTopic = "string",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AnalysisResults = list(
#'       list(
#'         IdentifiedRuleIds = list(
#'           "string"
#'         ),
#'         IdentifiedType = "STATELESS_RULE_FORWARDING_ASYMMETRICALLY"|"STATELESS_RULE_CONTAINS_TCP_FLAGS",
#'         AnalysisDetail = "string"
#'       )
#'     ),
#'     SummaryConfiguration = list(
#'       RuleOptions = list(
#'         "SID"|"MSG"|"METADATA"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_rule_group(
#'   RuleGroupName = "string",
#'   RuleGroupArn = "string",
#'   Type = "STATELESS"|"STATEFUL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_rule_group
#'
#' @aliases networkfirewall_delete_rule_group
networkfirewall_delete_rule_group <- function(RuleGroupName = NULL, RuleGroupArn = NULL, Type = NULL) {
  op <- new_operation(
    name = "DeleteRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_rule_group_input(RuleGroupName = RuleGroupName, RuleGroupArn = RuleGroupArn, Type = Type)
  output <- .networkfirewall$delete_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_rule_group <- networkfirewall_delete_rule_group

#' Deletes the specified TLSInspectionConfiguration
#'
#' @description
#' Deletes the specified TLSInspectionConfiguration.
#'
#' @usage
#' networkfirewall_delete_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn, TLSInspectionConfigurationName)
#'
#' @param TLSInspectionConfigurationArn The Amazon Resource Name (ARN) of the TLS inspection configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param TLSInspectionConfigurationName The descriptive name of the TLS inspection configuration. You can't
#' change the name of a TLS inspection configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TLSInspectionConfigurationResponse = list(
#'     TLSInspectionConfigurationArn = "string",
#'     TLSInspectionConfigurationName = "string",
#'     TLSInspectionConfigurationId = "string",
#'     TLSInspectionConfigurationStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     Certificates = list(
#'       list(
#'         CertificateArn = "string",
#'         CertificateSerial = "string",
#'         Status = "string",
#'         StatusMessage = "string"
#'       )
#'     ),
#'     CertificateAuthority = list(
#'       CertificateArn = "string",
#'       CertificateSerial = "string",
#'       Status = "string",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn = "string",
#'   TLSInspectionConfigurationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_tls_inspection_configuration
#'
#' @aliases networkfirewall_delete_tls_inspection_configuration
networkfirewall_delete_tls_inspection_configuration <- function(TLSInspectionConfigurationArn = NULL, TLSInspectionConfigurationName = NULL) {
  op <- new_operation(
    name = "DeleteTLSInspectionConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_tls_inspection_configuration_input(TLSInspectionConfigurationArn = TLSInspectionConfigurationArn, TLSInspectionConfigurationName = TLSInspectionConfigurationName)
  output <- .networkfirewall$delete_tls_inspection_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_tls_inspection_configuration <- networkfirewall_delete_tls_inspection_configuration

#' Deletes the specified VpcEndpointAssociation
#'
#' @description
#' Deletes the specified VpcEndpointAssociation.
#' 
#' You can check whether an endpoint association is in use by reviewing the
#' route tables for the Availability Zones where you have the endpoint
#' subnet mapping. You can retrieve the subnet mapping by calling
#' [`describe_vpc_endpoint_association`][networkfirewall_describe_vpc_endpoint_association].
#' You define and update the route tables through Amazon VPC. As needed,
#' update the route tables for the Availability Zone to remove the firewall
#' endpoint for the association. When the route tables no longer use the
#' firewall endpoint, you can remove the endpoint association safely.
#'
#' @usage
#' networkfirewall_delete_vpc_endpoint_association(
#'   VpcEndpointAssociationArn)
#'
#' @param VpcEndpointAssociationArn &#91;required&#93; The Amazon Resource Name (ARN) of a VPC endpoint association.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcEndpointAssociation = list(
#'     VpcEndpointAssociationId = "string",
#'     VpcEndpointAssociationArn = "string",
#'     FirewallArn = "string",
#'     VpcId = "string",
#'     SubnetMapping = list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   VpcEndpointAssociationStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     AssociationSyncState = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_vpc_endpoint_association(
#'   VpcEndpointAssociationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_delete_vpc_endpoint_association
#'
#' @aliases networkfirewall_delete_vpc_endpoint_association
networkfirewall_delete_vpc_endpoint_association <- function(VpcEndpointAssociationArn) {
  op <- new_operation(
    name = "DeleteVpcEndpointAssociation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$delete_vpc_endpoint_association_input(VpcEndpointAssociationArn = VpcEndpointAssociationArn)
  output <- .networkfirewall$delete_vpc_endpoint_association_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$delete_vpc_endpoint_association <- networkfirewall_delete_vpc_endpoint_association

#' Returns the data objects for the specified firewall
#'
#' @description
#' Returns the data objects for the specified firewall.
#'
#' @usage
#' networkfirewall_describe_firewall(FirewallName, FirewallArn)
#'
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   Firewall = list(
#'     FirewallName = "string",
#'     FirewallArn = "string",
#'     FirewallPolicyArn = "string",
#'     VpcId = "string",
#'     SubnetMappings = list(
#'       list(
#'         SubnetId = "string",
#'         IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'       )
#'     ),
#'     DeleteProtection = TRUE|FALSE,
#'     SubnetChangeProtection = TRUE|FALSE,
#'     FirewallPolicyChangeProtection = TRUE|FALSE,
#'     Description = "string",
#'     FirewallId = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     NumberOfAssociations = 123,
#'     EnabledAnalysisTypes = list(
#'       "TLS_SNI"|"HTTP_HOST"
#'     ),
#'     TransitGatewayId = "string",
#'     TransitGatewayOwnerAccountId = "string",
#'     AvailabilityZoneMappings = list(
#'       list(
#'         AvailabilityZone = "string"
#'       )
#'     ),
#'     AvailabilityZoneChangeProtection = TRUE|FALSE
#'   ),
#'   FirewallStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     ConfigurationSyncStateSummary = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED",
#'     SyncStates = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         ),
#'         Config = list(
#'           list(
#'             SyncStatus = "PENDING"|"IN_SYNC"|"CAPACITY_CONSTRAINED"|"NOT_SUBSCRIBED"|"DEPRECATED",
#'             UpdateToken = "string"
#'           )
#'         )
#'       )
#'     ),
#'     CapacityUsageSummary = list(
#'       CIDRs = list(
#'         AvailableCIDRCount = 123,
#'         UtilizedCIDRCount = 123,
#'         IPSetReferences = list(
#'           list(
#'             ResolvedCIDRCount = 123
#'           )
#'         )
#'       )
#'     ),
#'     TransitGatewayAttachmentSyncState = list(
#'       AttachmentId = "string",
#'       TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_firewall(
#'   FirewallName = "string",
#'   FirewallArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_firewall
#'
#' @aliases networkfirewall_describe_firewall
networkfirewall_describe_firewall <- function(FirewallName = NULL, FirewallArn = NULL) {
  op <- new_operation(
    name = "DescribeFirewall",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_firewall_input(FirewallName = FirewallName, FirewallArn = FirewallArn)
  output <- .networkfirewall$describe_firewall_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_firewall <- networkfirewall_describe_firewall

#' Returns the high-level information about a firewall, including the
#' Availability Zones where the Firewall is currently in use
#'
#' @description
#' Returns the high-level information about a firewall, including the
#' Availability Zones where the Firewall is currently in use.
#'
#' @usage
#' networkfirewall_describe_firewall_metadata(FirewallArn)
#'
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallPolicyArn = "string",
#'   Description = "string",
#'   Status = "PROVISIONING"|"DELETING"|"READY",
#'   SupportedAvailabilityZones = list(
#'     list(
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     )
#'   ),
#'   TransitGatewayAttachmentId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_firewall_metadata(
#'   FirewallArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_firewall_metadata
#'
#' @aliases networkfirewall_describe_firewall_metadata
networkfirewall_describe_firewall_metadata <- function(FirewallArn = NULL) {
  op <- new_operation(
    name = "DescribeFirewallMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_firewall_metadata_input(FirewallArn = FirewallArn)
  output <- .networkfirewall$describe_firewall_metadata_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_firewall_metadata <- networkfirewall_describe_firewall_metadata

#' Returns the data objects for the specified firewall policy
#'
#' @description
#' Returns the data objects for the specified firewall policy.
#'
#' @usage
#' networkfirewall_describe_firewall_policy(FirewallPolicyName,
#'   FirewallPolicyArn)
#'
#' @param FirewallPolicyName The descriptive name of the firewall policy. You can't change the name
#' of a firewall policy after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicyArn The Amazon Resource Name (ARN) of the firewall policy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallPolicyResponse = list(
#'     FirewallPolicyName = "string",
#'     FirewallPolicyArn = "string",
#'     FirewallPolicyId = "string",
#'     Description = "string",
#'     FirewallPolicyStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedStatelessRuleCapacity = 123,
#'     ConsumedStatefulRuleCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   FirewallPolicy = list(
#'     StatelessRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123
#'       )
#'     ),
#'     StatelessDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessFragmentDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessCustomActions = list(
#'       list(
#'         ActionName = "string",
#'         ActionDefinition = list(
#'           PublishMetricAction = list(
#'             Dimensions = list(
#'               list(
#'                 Value = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123,
#'         Override = list(
#'           Action = "DROP_TO_ALERT"
#'         ),
#'         DeepThreatInspection = TRUE|FALSE
#'       )
#'     ),
#'     StatefulDefaultActions = list(
#'       "string"
#'     ),
#'     StatefulEngineOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER",
#'       StreamExceptionPolicy = "DROP"|"CONTINUE"|"REJECT",
#'       FlowTimeouts = list(
#'         TcpIdleTimeoutSeconds = 123
#'       )
#'     ),
#'     TLSInspectionConfigurationArn = "string",
#'     PolicyVariables = list(
#'       RuleVariables = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     EnableTLSSessionHolding = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_firewall_policy(
#'   FirewallPolicyName = "string",
#'   FirewallPolicyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_firewall_policy
#'
#' @aliases networkfirewall_describe_firewall_policy
networkfirewall_describe_firewall_policy <- function(FirewallPolicyName = NULL, FirewallPolicyArn = NULL) {
  op <- new_operation(
    name = "DescribeFirewallPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_firewall_policy_input(FirewallPolicyName = FirewallPolicyName, FirewallPolicyArn = FirewallPolicyArn)
  output <- .networkfirewall$describe_firewall_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_firewall_policy <- networkfirewall_describe_firewall_policy

#' Returns key information about a specific flow operation
#'
#' @description
#' Returns key information about a specific flow operation.
#'
#' @usage
#' networkfirewall_describe_flow_operation(FirewallArn, AvailabilityZone,
#'   VpcEndpointAssociationArn, VpcEndpointId, FlowOperationId)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param AvailabilityZone The ID of the Availability Zone where the firewall is located. For
#' example, `us-east-2a`.
#' 
#' Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#' @param VpcEndpointAssociationArn The Amazon Resource Name (ARN) of a VPC endpoint association.
#' @param VpcEndpointId A unique identifier for the primary endpoint associated with a firewall.
#' @param FlowOperationId &#91;required&#93; A unique identifier for the flow operation. This ID is returned in the
#' responses to start and list commands. You provide to describe commands.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   FlowOperationId = "string",
#'   FlowOperationType = "FLOW_FLUSH"|"FLOW_CAPTURE",
#'   FlowOperationStatus = "COMPLETED"|"IN_PROGRESS"|"FAILED"|"COMPLETED_WITH_ERRORS",
#'   StatusMessage = "string",
#'   FlowRequestTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   FlowOperation = list(
#'     MinimumFlowAgeInSeconds = 123,
#'     FlowFilters = list(
#'       list(
#'         SourceAddress = list(
#'           AddressDefinition = "string"
#'         ),
#'         DestinationAddress = list(
#'           AddressDefinition = "string"
#'         ),
#'         SourcePort = "string",
#'         DestinationPort = "string",
#'         Protocols = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_flow_operation(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   FlowOperationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_flow_operation
#'
#' @aliases networkfirewall_describe_flow_operation
networkfirewall_describe_flow_operation <- function(FirewallArn, AvailabilityZone = NULL, VpcEndpointAssociationArn = NULL, VpcEndpointId = NULL, FlowOperationId) {
  op <- new_operation(
    name = "DescribeFlowOperation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_flow_operation_input(FirewallArn = FirewallArn, AvailabilityZone = AvailabilityZone, VpcEndpointAssociationArn = VpcEndpointAssociationArn, VpcEndpointId = VpcEndpointId, FlowOperationId = FlowOperationId)
  output <- .networkfirewall$describe_flow_operation_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_flow_operation <- networkfirewall_describe_flow_operation

#' Returns the logging configuration for the specified firewall
#'
#' @description
#' Returns the logging configuration for the specified firewall.
#'
#' @usage
#' networkfirewall_describe_logging_configuration(FirewallArn,
#'   FirewallName)
#'
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   LoggingConfiguration = list(
#'     LogDestinationConfigs = list(
#'       list(
#'         LogType = "ALERT"|"FLOW"|"TLS",
#'         LogDestinationType = "S3"|"CloudWatchLogs"|"KinesisDataFirehose",
#'         LogDestination = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   EnableMonitoringDashboard = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_logging_configuration(
#'   FirewallArn = "string",
#'   FirewallName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_logging_configuration
#'
#' @aliases networkfirewall_describe_logging_configuration
networkfirewall_describe_logging_configuration <- function(FirewallArn = NULL, FirewallName = NULL) {
  op <- new_operation(
    name = "DescribeLoggingConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_logging_configuration_input(FirewallArn = FirewallArn, FirewallName = FirewallName)
  output <- .networkfirewall$describe_logging_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_logging_configuration <- networkfirewall_describe_logging_configuration

#' Returns the data objects for the specified proxy
#'
#' @description
#' Returns the data objects for the specified proxy.
#'
#' @usage
#' networkfirewall_describe_proxy(ProxyName, ProxyArn)
#'
#' @param ProxyName The descriptive name of the proxy. You can't change the name of a proxy
#' after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyArn The Amazon Resource Name (ARN) of a proxy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Proxy = list(
#'     ProxyName = "string",
#'     ProxyArn = "string",
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     NatGatewayId = "string",
#'     ProxyState = "ATTACHING"|"ATTACHED"|"DETACHING"|"DETACHED"|"ATTACH_FAILED"|"DETACH_FAILED",
#'     ProxyModifyState = "MODIFYING"|"COMPLETED"|"FAILED",
#'     ListenerProperties = list(
#'       list(
#'         Port = 123,
#'         Type = "HTTP"|"HTTPS"
#'       )
#'     ),
#'     TlsInterceptProperties = list(
#'       PcaArn = "string",
#'       TlsInterceptMode = "ENABLED"|"DISABLED"
#'     ),
#'     VpcEndpointServiceName = "string",
#'     PrivateDNSName = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureCode = "string",
#'     FailureMessage = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_proxy(
#'   ProxyName = "string",
#'   ProxyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_proxy
#'
#' @aliases networkfirewall_describe_proxy
networkfirewall_describe_proxy <- function(ProxyName = NULL, ProxyArn = NULL) {
  op <- new_operation(
    name = "DescribeProxy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_proxy_input(ProxyName = ProxyName, ProxyArn = ProxyArn)
  output <- .networkfirewall$describe_proxy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_proxy <- networkfirewall_describe_proxy

#' Returns the data objects for the specified proxy configuration
#'
#' @description
#' Returns the data objects for the specified proxy configuration.
#'
#' @usage
#' networkfirewall_describe_proxy_configuration(ProxyConfigurationName,
#'   ProxyConfigurationArn)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfiguration = list(
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     Description = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RuleGroups = list(
#'       list(
#'         ProxyRuleGroupName = "string",
#'         ProxyRuleGroupArn = "string",
#'         Type = "string",
#'         Priority = 123
#'       )
#'     ),
#'     DefaultRulePhaseActions = list(
#'       PreDNS = "ALLOW"|"DENY"|"ALERT",
#'       PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'       PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_proxy_configuration
#'
#' @aliases networkfirewall_describe_proxy_configuration
networkfirewall_describe_proxy_configuration <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL) {
  op <- new_operation(
    name = "DescribeProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn)
  output <- .networkfirewall$describe_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_proxy_configuration <- networkfirewall_describe_proxy_configuration

#' Returns the data objects for the specified proxy configuration for the
#' specified proxy rule group
#'
#' @description
#' Returns the data objects for the specified proxy configuration for the
#' specified proxy rule group.
#'
#' @usage
#' networkfirewall_describe_proxy_rule(ProxyRuleName, ProxyRuleGroupName,
#'   ProxyRuleGroupArn)
#'
#' @param ProxyRuleName &#91;required&#93; The descriptive name of the proxy rule. You can't change the name of a
#' proxy rule after you create it.
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRule = list(
#'     ProxyRuleName = "string",
#'     Description = "string",
#'     Action = "ALLOW"|"DENY"|"ALERT",
#'     Conditions = list(
#'       list(
#'         ConditionOperator = "string",
#'         ConditionKey = "string",
#'         ConditionValues = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_proxy_rule(
#'   ProxyRuleName = "string",
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_proxy_rule
#'
#' @aliases networkfirewall_describe_proxy_rule
networkfirewall_describe_proxy_rule <- function(ProxyRuleName, ProxyRuleGroupName = NULL, ProxyRuleGroupArn = NULL) {
  op <- new_operation(
    name = "DescribeProxyRule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_proxy_rule_input(ProxyRuleName = ProxyRuleName, ProxyRuleGroupName = ProxyRuleGroupName, ProxyRuleGroupArn = ProxyRuleGroupArn)
  output <- .networkfirewall$describe_proxy_rule_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_proxy_rule <- networkfirewall_describe_proxy_rule

#' Returns the data objects for the specified proxy rule group
#'
#' @description
#' Returns the data objects for the specified proxy rule group.
#'
#' @usage
#' networkfirewall_describe_proxy_rule_group(ProxyRuleGroupName,
#'   ProxyRuleGroupArn)
#'
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroup = list(
#'     ProxyRuleGroupName = "string",
#'     ProxyRuleGroupArn = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     Rules = list(
#'       PreDNS = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PreREQUEST = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       PostRESPONSE = list(
#'         list(
#'           ProxyRuleName = "string",
#'           Description = "string",
#'           Action = "ALLOW"|"DENY"|"ALERT",
#'           Conditions = list(
#'             list(
#'               ConditionOperator = "string",
#'               ConditionKey = "string",
#'               ConditionValues = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_proxy_rule_group(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_proxy_rule_group
#'
#' @aliases networkfirewall_describe_proxy_rule_group
networkfirewall_describe_proxy_rule_group <- function(ProxyRuleGroupName = NULL, ProxyRuleGroupArn = NULL) {
  op <- new_operation(
    name = "DescribeProxyRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_proxy_rule_group_input(ProxyRuleGroupName = ProxyRuleGroupName, ProxyRuleGroupArn = ProxyRuleGroupArn)
  output <- .networkfirewall$describe_proxy_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_proxy_rule_group <- networkfirewall_describe_proxy_rule_group

#' Retrieves a resource policy that you created in a PutResourcePolicy
#' request
#'
#' @description
#' Retrieves a resource policy that you created in a
#' [`put_resource_policy`][networkfirewall_put_resource_policy] request.
#'
#' @usage
#' networkfirewall_describe_resource_policy(ResourceArn)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the rule group or firewall policy
#' whose resource policy you want to retrieve.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Policy = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_resource_policy(
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_resource_policy
#'
#' @aliases networkfirewall_describe_resource_policy
networkfirewall_describe_resource_policy <- function(ResourceArn) {
  op <- new_operation(
    name = "DescribeResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_resource_policy_input(ResourceArn = ResourceArn)
  output <- .networkfirewall$describe_resource_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_resource_policy <- networkfirewall_describe_resource_policy

#' Returns the data objects for the specified rule group
#'
#' @description
#' Returns the data objects for the specified rule group.
#'
#' @usage
#' networkfirewall_describe_rule_group(RuleGroupName, RuleGroupArn, Type,
#'   AnalyzeRuleGroup)
#'
#' @param RuleGroupName The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupArn The Amazon Resource Name (ARN) of the rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Type Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#' 
#' This setting is required for requests that do not include the
#' `RuleGroupARN`.
#' @param AnalyzeRuleGroup Indicates whether you want Network Firewall to analyze the stateless
#' rules in the rule group for rule behavior such as asymmetric routing. If
#' set to `TRUE`, Network Firewall runs the analysis.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   RuleGroup = list(
#'     RuleVariables = list(
#'       IPSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       PortSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ReferenceSets = list(
#'       IPSetReferences = list(
#'         list(
#'           ReferenceArn = "string"
#'         )
#'       )
#'     ),
#'     RulesSource = list(
#'       RulesString = "string",
#'       RulesSourceList = list(
#'         Targets = list(
#'           "string"
#'         ),
#'         TargetTypes = list(
#'           "TLS_SNI"|"HTTP_HOST"
#'         ),
#'         GeneratedRulesType = "ALLOWLIST"|"DENYLIST"|"REJECTLIST"|"ALERTLIST"
#'       ),
#'       StatefulRules = list(
#'         list(
#'           Action = "PASS"|"DROP"|"ALERT"|"REJECT",
#'           Header = list(
#'             Protocol = "IP"|"TCP"|"UDP"|"ICMP"|"HTTP"|"FTP"|"TLS"|"SMB"|"DNS"|"DCERPC"|"SSH"|"SMTP"|"IMAP"|"MSN"|"KRB5"|"IKEV2"|"TFTP"|"NTP"|"DHCP"|"HTTP2"|"QUIC",
#'             Source = "string",
#'             SourcePort = "string",
#'             Direction = "FORWARD"|"ANY",
#'             Destination = "string",
#'             DestinationPort = "string"
#'           ),
#'           RuleOptions = list(
#'             list(
#'               Keyword = "string",
#'               Settings = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       StatelessRulesAndCustomActions = list(
#'         StatelessRules = list(
#'           list(
#'             RuleDefinition = list(
#'               MatchAttributes = list(
#'                 Sources = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 Destinations = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 SourcePorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 DestinationPorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 Protocols = list(
#'                   123
#'                 ),
#'                 TCPFlags = list(
#'                   list(
#'                     Flags = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     ),
#'                     Masks = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     )
#'                   )
#'                 )
#'               ),
#'               Actions = list(
#'                 "string"
#'               )
#'             ),
#'             Priority = 123
#'           )
#'         ),
#'         CustomActions = list(
#'           list(
#'             ActionName = "string",
#'             ActionDefinition = list(
#'               PublishMetricAction = list(
#'                 Dimensions = list(
#'                   list(
#'                     Value = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER"
#'     )
#'   ),
#'   RuleGroupResponse = list(
#'     RuleGroupArn = "string",
#'     RuleGroupName = "string",
#'     RuleGroupId = "string",
#'     Description = "string",
#'     Type = "STATELESS"|"STATEFUL",
#'     Capacity = 123,
#'     RuleGroupStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     SourceMetadata = list(
#'       SourceArn = "string",
#'       SourceUpdateToken = "string"
#'     ),
#'     SnsTopic = "string",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AnalysisResults = list(
#'       list(
#'         IdentifiedRuleIds = list(
#'           "string"
#'         ),
#'         IdentifiedType = "STATELESS_RULE_FORWARDING_ASYMMETRICALLY"|"STATELESS_RULE_CONTAINS_TCP_FLAGS",
#'         AnalysisDetail = "string"
#'       )
#'     ),
#'     SummaryConfiguration = list(
#'       RuleOptions = list(
#'         "SID"|"MSG"|"METADATA"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_rule_group(
#'   RuleGroupName = "string",
#'   RuleGroupArn = "string",
#'   Type = "STATELESS"|"STATEFUL",
#'   AnalyzeRuleGroup = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_rule_group
#'
#' @aliases networkfirewall_describe_rule_group
networkfirewall_describe_rule_group <- function(RuleGroupName = NULL, RuleGroupArn = NULL, Type = NULL, AnalyzeRuleGroup = NULL) {
  op <- new_operation(
    name = "DescribeRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_rule_group_input(RuleGroupName = RuleGroupName, RuleGroupArn = RuleGroupArn, Type = Type, AnalyzeRuleGroup = AnalyzeRuleGroup)
  output <- .networkfirewall$describe_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_rule_group <- networkfirewall_describe_rule_group

#' High-level information about a rule group, returned by operations like
#' create and describe
#'
#' @description
#' High-level information about a rule group, returned by operations like
#' create and describe. You can use the information provided in the
#' metadata to retrieve and manage a rule group. You can retrieve all
#' objects for a rule group by calling
#' [`describe_rule_group`][networkfirewall_describe_rule_group].
#'
#' @usage
#' networkfirewall_describe_rule_group_metadata(RuleGroupName,
#'   RuleGroupArn, Type)
#'
#' @param RuleGroupName The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupArn The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Type Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#' 
#' This setting is required for requests that do not include the
#' `RuleGroupARN`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RuleGroupArn = "string",
#'   RuleGroupName = "string",
#'   Description = "string",
#'   Type = "STATELESS"|"STATEFUL",
#'   Capacity = 123,
#'   StatefulRuleOptions = list(
#'     RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER"
#'   ),
#'   LastModifiedTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   VendorName = "string",
#'   ProductId = "string",
#'   ListingName = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_rule_group_metadata(
#'   RuleGroupName = "string",
#'   RuleGroupArn = "string",
#'   Type = "STATELESS"|"STATEFUL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_rule_group_metadata
#'
#' @aliases networkfirewall_describe_rule_group_metadata
networkfirewall_describe_rule_group_metadata <- function(RuleGroupName = NULL, RuleGroupArn = NULL, Type = NULL) {
  op <- new_operation(
    name = "DescribeRuleGroupMetadata",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_rule_group_metadata_input(RuleGroupName = RuleGroupName, RuleGroupArn = RuleGroupArn, Type = Type)
  output <- .networkfirewall$describe_rule_group_metadata_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_rule_group_metadata <- networkfirewall_describe_rule_group_metadata

#' Returns detailed information for a stateful rule group
#'
#' @description
#' Returns detailed information for a stateful rule group.
#' 
#' For active threat defense Amazon Web Services managed rule groups, this
#' operation provides insight into the protections enabled by the rule
#' group, based on Suricata rule metadata fields. Summaries are available
#' for rule groups you manage and for active threat defense Amazon Web
#' Services managed rule groups.
#' 
#' To modify how threat information appears in summaries, use the
#' `SummaryConfiguration` parameter in
#' [`update_rule_group`][networkfirewall_update_rule_group].
#'
#' @usage
#' networkfirewall_describe_rule_group_summary(RuleGroupName, RuleGroupArn,
#'   Type)
#'
#' @param RuleGroupName The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupArn Required. The Amazon Resource Name (ARN) of the rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Type The type of rule group you want a summary for. This is a required field.
#' 
#' Valid value: `STATEFUL`
#' 
#' Note that `STATELESS` exists but is not currently supported. If you
#' provide `STATELESS`, an exception is returned.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   RuleGroupName = "string",
#'   Description = "string",
#'   Summary = list(
#'     RuleSummaries = list(
#'       list(
#'         SID = "string",
#'         Msg = "string",
#'         Metadata = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_rule_group_summary(
#'   RuleGroupName = "string",
#'   RuleGroupArn = "string",
#'   Type = "STATELESS"|"STATEFUL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_rule_group_summary
#'
#' @aliases networkfirewall_describe_rule_group_summary
networkfirewall_describe_rule_group_summary <- function(RuleGroupName = NULL, RuleGroupArn = NULL, Type = NULL) {
  op <- new_operation(
    name = "DescribeRuleGroupSummary",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_rule_group_summary_input(RuleGroupName = RuleGroupName, RuleGroupArn = RuleGroupArn, Type = Type)
  output <- .networkfirewall$describe_rule_group_summary_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_rule_group_summary <- networkfirewall_describe_rule_group_summary

#' Returns the data objects for the specified TLS inspection configuration
#'
#' @description
#' Returns the data objects for the specified TLS inspection configuration.
#'
#' @usage
#' networkfirewall_describe_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn, TLSInspectionConfigurationName)
#'
#' @param TLSInspectionConfigurationArn The Amazon Resource Name (ARN) of the TLS inspection configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param TLSInspectionConfigurationName The descriptive name of the TLS inspection configuration. You can't
#' change the name of a TLS inspection configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   TLSInspectionConfiguration = list(
#'     ServerCertificateConfigurations = list(
#'       list(
#'         ServerCertificates = list(
#'           list(
#'             ResourceArn = "string"
#'           )
#'         ),
#'         Scopes = list(
#'           list(
#'             Sources = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             Destinations = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             SourcePorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             DestinationPorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             Protocols = list(
#'               123
#'             )
#'           )
#'         ),
#'         CertificateAuthorityArn = "string",
#'         CheckCertificateRevocationStatus = list(
#'           RevokedStatusAction = "PASS"|"DROP"|"REJECT",
#'           UnknownStatusAction = "PASS"|"DROP"|"REJECT"
#'         )
#'       )
#'     )
#'   ),
#'   TLSInspectionConfigurationResponse = list(
#'     TLSInspectionConfigurationArn = "string",
#'     TLSInspectionConfigurationName = "string",
#'     TLSInspectionConfigurationId = "string",
#'     TLSInspectionConfigurationStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     Certificates = list(
#'       list(
#'         CertificateArn = "string",
#'         CertificateSerial = "string",
#'         Status = "string",
#'         StatusMessage = "string"
#'       )
#'     ),
#'     CertificateAuthority = list(
#'       CertificateArn = "string",
#'       CertificateSerial = "string",
#'       Status = "string",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn = "string",
#'   TLSInspectionConfigurationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_tls_inspection_configuration
#'
#' @aliases networkfirewall_describe_tls_inspection_configuration
networkfirewall_describe_tls_inspection_configuration <- function(TLSInspectionConfigurationArn = NULL, TLSInspectionConfigurationName = NULL) {
  op <- new_operation(
    name = "DescribeTLSInspectionConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_tls_inspection_configuration_input(TLSInspectionConfigurationArn = TLSInspectionConfigurationArn, TLSInspectionConfigurationName = TLSInspectionConfigurationName)
  output <- .networkfirewall$describe_tls_inspection_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_tls_inspection_configuration <- networkfirewall_describe_tls_inspection_configuration

#' Returns the data object for the specified VPC endpoint association
#'
#' @description
#' Returns the data object for the specified VPC endpoint association.
#'
#' @usage
#' networkfirewall_describe_vpc_endpoint_association(
#'   VpcEndpointAssociationArn)
#'
#' @param VpcEndpointAssociationArn &#91;required&#93; The Amazon Resource Name (ARN) of a VPC endpoint association.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   VpcEndpointAssociation = list(
#'     VpcEndpointAssociationId = "string",
#'     VpcEndpointAssociationArn = "string",
#'     FirewallArn = "string",
#'     VpcId = "string",
#'     SubnetMapping = list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     ),
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   VpcEndpointAssociationStatus = list(
#'     Status = "PROVISIONING"|"DELETING"|"READY",
#'     AssociationSyncState = list(
#'       list(
#'         Attachment = list(
#'           SubnetId = "string",
#'           EndpointId = "string",
#'           Status = "CREATING"|"DELETING"|"FAILED"|"ERROR"|"SCALING"|"READY",
#'           StatusMessage = "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_vpc_endpoint_association(
#'   VpcEndpointAssociationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_describe_vpc_endpoint_association
#'
#' @aliases networkfirewall_describe_vpc_endpoint_association
networkfirewall_describe_vpc_endpoint_association <- function(VpcEndpointAssociationArn) {
  op <- new_operation(
    name = "DescribeVpcEndpointAssociation",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$describe_vpc_endpoint_association_input(VpcEndpointAssociationArn = VpcEndpointAssociationArn)
  output <- .networkfirewall$describe_vpc_endpoint_association_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$describe_vpc_endpoint_association <- networkfirewall_describe_vpc_endpoint_association

#' Detaches ProxyRuleGroup resources from a ProxyConfiguration
#'
#' @description
#' Detaches ProxyRuleGroup resources from a ProxyConfiguration
#' 
#' A Proxy Configuration defines the monitoring and protection behavior for
#' a Proxy. The details of the behavior are defined in the rule groups that
#' you add to your configuration.
#'
#' @usage
#' networkfirewall_detach_rule_groups_from_proxy_configuration(
#'   ProxyConfigurationName, ProxyConfigurationArn, RuleGroupNames,
#'   RuleGroupArns, UpdateToken)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupNames The proxy rule group names to detach from the proxy configuration
#' @param RuleGroupArns The proxy rule group arns to detach from the proxy configuration
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy configuration. The token marks the
#' state of the proxy configuration resource at the time of the request.
#' 
#' To make changes to the proxy configuration, you provide the token in
#' your request. Network Firewall uses the token to ensure that the proxy
#' configuration hasn't changed since you last retrieved it. If it has
#' changed, the operation fails with an `InvalidTokenException`. If this
#' happens, retrieve the proxy configuration again to get a current copy of
#' it with a current token. Reapply your changes as needed, then try the
#' operation again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfiguration = list(
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     Description = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RuleGroups = list(
#'       list(
#'         ProxyRuleGroupName = "string",
#'         ProxyRuleGroupArn = "string",
#'         Type = "string",
#'         Priority = 123
#'       )
#'     ),
#'     DefaultRulePhaseActions = list(
#'       PreDNS = "ALLOW"|"DENY"|"ALERT",
#'       PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'       PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$detach_rule_groups_from_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string",
#'   RuleGroupNames = list(
#'     "string"
#'   ),
#'   RuleGroupArns = list(
#'     "string"
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_detach_rule_groups_from_proxy_configuration
#'
#' @aliases networkfirewall_detach_rule_groups_from_proxy_configuration
networkfirewall_detach_rule_groups_from_proxy_configuration <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL, RuleGroupNames = NULL, RuleGroupArns = NULL, UpdateToken) {
  op <- new_operation(
    name = "DetachRuleGroupsFromProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$detach_rule_groups_from_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn, RuleGroupNames = RuleGroupNames, RuleGroupArns = RuleGroupArns, UpdateToken = UpdateToken)
  output <- .networkfirewall$detach_rule_groups_from_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$detach_rule_groups_from_proxy_configuration <- networkfirewall_detach_rule_groups_from_proxy_configuration

#' Removes the specified Availability Zone associations from a transit
#' gateway-attached firewall
#'
#' @description
#' Removes the specified Availability Zone associations from a transit
#' gateway-attached firewall. This removes the firewall endpoints from
#' these Availability Zones and stops traffic filtering in those zones.
#' Before removing an Availability Zone, ensure you've updated your transit
#' gateway route tables to redirect traffic appropriately.
#' 
#' If `AvailabilityZoneChangeProtection` is enabled, you must first disable
#' it using
#' [`update_availability_zone_change_protection`][networkfirewall_update_availability_zone_change_protection].
#' 
#' To verify the status of your Availability Zone changes, use
#' [`describe_firewall`][networkfirewall_describe_firewall].
#'
#' @usage
#' networkfirewall_disassociate_availability_zones(UpdateToken,
#'   FirewallArn, FirewallName, AvailabilityZoneMappings)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param AvailabilityZoneMappings &#91;required&#93; Required. The Availability Zones to remove from the firewall's
#' configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneMappings = list(
#'     list(
#'       AvailabilityZone = "string"
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_availability_zones(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneMappings = list(
#'     list(
#'       AvailabilityZone = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_disassociate_availability_zones
#'
#' @aliases networkfirewall_disassociate_availability_zones
networkfirewall_disassociate_availability_zones <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, AvailabilityZoneMappings) {
  op <- new_operation(
    name = "DisassociateAvailabilityZones",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$disassociate_availability_zones_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, AvailabilityZoneMappings = AvailabilityZoneMappings)
  output <- .networkfirewall$disassociate_availability_zones_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$disassociate_availability_zones <- networkfirewall_disassociate_availability_zones

#' Removes the specified subnet associations from the firewall
#'
#' @description
#' Removes the specified subnet associations from the firewall. This
#' removes the firewall endpoints from the subnets and removes any network
#' filtering protections that the endpoints were providing.
#'
#' @usage
#' networkfirewall_disassociate_subnets(UpdateToken, FirewallArn,
#'   FirewallName, SubnetIds)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param SubnetIds &#91;required&#93; The unique identifiers for the subnets that you want to disassociate.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetMappings = list(
#'     list(
#'       SubnetId = "string",
#'       IPAddressType = "DUALSTACK"|"IPV4"|"IPV6"
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_subnets(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_disassociate_subnets
#'
#' @aliases networkfirewall_disassociate_subnets
networkfirewall_disassociate_subnets <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, SubnetIds) {
  op <- new_operation(
    name = "DisassociateSubnets",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$disassociate_subnets_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, SubnetIds = SubnetIds)
  output <- .networkfirewall$disassociate_subnets_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$disassociate_subnets <- networkfirewall_disassociate_subnets

#' The results of a COMPLETED analysis report generated with
#' StartAnalysisReport
#'
#' @description
#' The results of a `COMPLETED` analysis report generated with
#' [`start_analysis_report`][networkfirewall_start_analysis_report].
#' 
#' For more information, see AnalysisTypeReportResult.
#'
#' @usage
#' networkfirewall_get_analysis_report_results(FirewallName,
#'   AnalysisReportId, FirewallArn, NextToken, MaxResults)
#'
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param AnalysisReportId &#91;required&#93; The unique ID of the query that ran when you requested an analysis
#' report.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Status = "string",
#'   StartTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   EndTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   ReportTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   AnalysisType = "TLS_SNI"|"HTTP_HOST",
#'   NextToken = "string",
#'   AnalysisReportResults = list(
#'     list(
#'       Protocol = "string",
#'       FirstAccessed = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       LastAccessed = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Domain = "string",
#'       Hits = list(
#'         Count = 123
#'       ),
#'       UniqueSources = list(
#'         Count = 123
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_analysis_report_results(
#'   FirewallName = "string",
#'   AnalysisReportId = "string",
#'   FirewallArn = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_get_analysis_report_results
#'
#' @aliases networkfirewall_get_analysis_report_results
networkfirewall_get_analysis_report_results <- function(FirewallName = NULL, AnalysisReportId, FirewallArn = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "GetAnalysisReportResults",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "AnalysisReportResults"),
    stream_api = FALSE
  )
  input <- .networkfirewall$get_analysis_report_results_input(FirewallName = FirewallName, AnalysisReportId = AnalysisReportId, FirewallArn = FirewallArn, NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$get_analysis_report_results_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$get_analysis_report_results <- networkfirewall_get_analysis_report_results

#' Returns a list of all traffic analysis reports generated within the last
#' 30 days
#'
#' @description
#' Returns a list of all traffic analysis reports generated within the last
#' 30 days.
#'
#' @usage
#' networkfirewall_list_analysis_reports(FirewallName, FirewallArn,
#'   NextToken, MaxResults)
#'
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AnalysisReports = list(
#'     list(
#'       AnalysisReportId = "string",
#'       AnalysisType = "TLS_SNI"|"HTTP_HOST",
#'       ReportTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       Status = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_analysis_reports(
#'   FirewallName = "string",
#'   FirewallArn = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_analysis_reports
#'
#' @aliases networkfirewall_list_analysis_reports
networkfirewall_list_analysis_reports <- function(FirewallName = NULL, FirewallArn = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListAnalysisReports",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "AnalysisReports"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_analysis_reports_input(FirewallName = FirewallName, FirewallArn = FirewallArn, NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_analysis_reports_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_analysis_reports <- networkfirewall_list_analysis_reports

#' Retrieves the metadata for the firewall policies that you have defined
#'
#' @description
#' Retrieves the metadata for the firewall policies that you have defined.
#' Depending on your setting for max results and the number of firewall
#' policies, a single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_firewall_policies(NextToken, MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   FirewallPolicies = list(
#'     list(
#'       Name = "string",
#'       Arn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_firewall_policies(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_firewall_policies
#'
#' @aliases networkfirewall_list_firewall_policies
networkfirewall_list_firewall_policies <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListFirewallPolicies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "FirewallPolicies"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_firewall_policies_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_firewall_policies_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_firewall_policies <- networkfirewall_list_firewall_policies

#' Retrieves the metadata for the firewalls that you have defined
#'
#' @description
#' Retrieves the metadata for the firewalls that you have defined. If you
#' provide VPC identifiers in your request, this returns only the firewalls
#' for those VPCs.
#' 
#' Depending on your setting for max results and the number of firewalls, a
#' single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_firewalls(NextToken, VpcIds, MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param VpcIds The unique identifiers of the VPCs that you want Network Firewall to
#' retrieve the firewalls for. Leave this blank to retrieve all firewalls
#' that you have defined.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Firewalls = list(
#'     list(
#'       FirewallName = "string",
#'       FirewallArn = "string",
#'       TransitGatewayAttachmentId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_firewalls(
#'   NextToken = "string",
#'   VpcIds = list(
#'     "string"
#'   ),
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_firewalls
#'
#' @aliases networkfirewall_list_firewalls
networkfirewall_list_firewalls <- function(NextToken = NULL, VpcIds = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListFirewalls",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Firewalls"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_firewalls_input(NextToken = NextToken, VpcIds = VpcIds, MaxResults = MaxResults)
  output <- .networkfirewall$list_firewalls_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_firewalls <- networkfirewall_list_firewalls

#' Returns the results of a specific flow operation
#'
#' @description
#' Returns the results of a specific flow operation.
#' 
#' Flow operations let you manage the flows tracked in the flow table, also
#' known as the firewall table.
#' 
#' A flow is network traffic that is monitored by a firewall, either by
#' stateful or stateless rules. For traffic to be considered part of a
#' flow, it must share Destination, DestinationPort, Direction, Protocol,
#' Source, and SourcePort.
#'
#' @usage
#' networkfirewall_list_flow_operation_results(FirewallArn,
#'   FlowOperationId, NextToken, MaxResults, AvailabilityZone, VpcEndpointId,
#'   VpcEndpointAssociationArn)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param FlowOperationId &#91;required&#93; A unique identifier for the flow operation. This ID is returned in the
#' responses to start and list commands. You provide to describe commands.
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#' @param AvailabilityZone The ID of the Availability Zone where the firewall is located. For
#' example, `us-east-2a`.
#' 
#' Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#' @param VpcEndpointId A unique identifier for the primary endpoint associated with a firewall.
#' @param VpcEndpointAssociationArn The Amazon Resource Name (ARN) of a VPC endpoint association.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   FlowOperationId = "string",
#'   FlowOperationStatus = "COMPLETED"|"IN_PROGRESS"|"FAILED"|"COMPLETED_WITH_ERRORS",
#'   StatusMessage = "string",
#'   FlowRequestTimestamp = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   Flows = list(
#'     list(
#'       SourceAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       DestinationAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       SourcePort = "string",
#'       DestinationPort = "string",
#'       Protocol = "string",
#'       Age = 123,
#'       PacketCount = 123,
#'       ByteCount = 123
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_flow_operation_results(
#'   FirewallArn = "string",
#'   FlowOperationId = "string",
#'   NextToken = "string",
#'   MaxResults = 123,
#'   AvailabilityZone = "string",
#'   VpcEndpointId = "string",
#'   VpcEndpointAssociationArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_flow_operation_results
#'
#' @aliases networkfirewall_list_flow_operation_results
networkfirewall_list_flow_operation_results <- function(FirewallArn, FlowOperationId, NextToken = NULL, MaxResults = NULL, AvailabilityZone = NULL, VpcEndpointId = NULL, VpcEndpointAssociationArn = NULL) {
  op <- new_operation(
    name = "ListFlowOperationResults",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Flows"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_flow_operation_results_input(FirewallArn = FirewallArn, FlowOperationId = FlowOperationId, NextToken = NextToken, MaxResults = MaxResults, AvailabilityZone = AvailabilityZone, VpcEndpointId = VpcEndpointId, VpcEndpointAssociationArn = VpcEndpointAssociationArn)
  output <- .networkfirewall$list_flow_operation_results_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_flow_operation_results <- networkfirewall_list_flow_operation_results

#' Returns a list of all flow operations ran in a specific firewall
#'
#' @description
#' Returns a list of all flow operations ran in a specific firewall. You
#' can optionally narrow the request scope by specifying the operation type
#' or Availability Zone associated with a firewall's flow operations.
#' 
#' Flow operations let you manage the flows tracked in the flow table, also
#' known as the firewall table.
#' 
#' A flow is network traffic that is monitored by a firewall, either by
#' stateful or stateless rules. For traffic to be considered part of a
#' flow, it must share Destination, DestinationPort, Direction, Protocol,
#' Source, and SourcePort.
#'
#' @usage
#' networkfirewall_list_flow_operations(FirewallArn, AvailabilityZone,
#'   VpcEndpointAssociationArn, VpcEndpointId, FlowOperationType, NextToken,
#'   MaxResults)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param AvailabilityZone The ID of the Availability Zone where the firewall is located. For
#' example, `us-east-2a`.
#' 
#' Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#' @param VpcEndpointAssociationArn The Amazon Resource Name (ARN) of a VPC endpoint association.
#' @param VpcEndpointId A unique identifier for the primary endpoint associated with a firewall.
#' @param FlowOperationType An optional string that defines whether any or all operation types are
#' returned.
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FlowOperations = list(
#'     list(
#'       FlowOperationId = "string",
#'       FlowOperationType = "FLOW_FLUSH"|"FLOW_CAPTURE",
#'       FlowRequestTimestamp = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       FlowOperationStatus = "COMPLETED"|"IN_PROGRESS"|"FAILED"|"COMPLETED_WITH_ERRORS"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_flow_operations(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   FlowOperationType = "FLOW_FLUSH"|"FLOW_CAPTURE",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_flow_operations
#'
#' @aliases networkfirewall_list_flow_operations
networkfirewall_list_flow_operations <- function(FirewallArn, AvailabilityZone = NULL, VpcEndpointAssociationArn = NULL, VpcEndpointId = NULL, FlowOperationType = NULL, NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListFlowOperations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "FlowOperations"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_flow_operations_input(FirewallArn = FirewallArn, AvailabilityZone = AvailabilityZone, VpcEndpointAssociationArn = VpcEndpointAssociationArn, VpcEndpointId = VpcEndpointId, FlowOperationType = FlowOperationType, NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_flow_operations_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_flow_operations <- networkfirewall_list_flow_operations

#' Retrieves the metadata for the proxies that you have defined
#'
#' @description
#' Retrieves the metadata for the proxies that you have defined. Depending
#' on your setting for max results and the number of proxies, a single call
#' might not return the full list.
#'
#' @usage
#' networkfirewall_list_proxies(NextToken, MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Proxies = list(
#'     list(
#'       Name = "string",
#'       Arn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_proxies(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_proxies
#'
#' @aliases networkfirewall_list_proxies
networkfirewall_list_proxies <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListProxies",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Proxies"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_proxies_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_proxies_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_proxies <- networkfirewall_list_proxies

#' Retrieves the metadata for the proxy configuration that you have defined
#'
#' @description
#' Retrieves the metadata for the proxy configuration that you have
#' defined. Depending on your setting for max results and the number of
#' proxy configurations, a single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_proxy_configurations(NextToken, MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfigurations = list(
#'     list(
#'       Name = "string",
#'       Arn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_proxy_configurations(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_proxy_configurations
#'
#' @aliases networkfirewall_list_proxy_configurations
networkfirewall_list_proxy_configurations <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListProxyConfigurations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ProxyConfigurations"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_proxy_configurations_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_proxy_configurations_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_proxy_configurations <- networkfirewall_list_proxy_configurations

#' Retrieves the metadata for the proxy rule groups that you have defined
#'
#' @description
#' Retrieves the metadata for the proxy rule groups that you have defined.
#' Depending on your setting for max results and the number of proxy rule
#' groups, a single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_proxy_rule_groups(NextToken, MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroups = list(
#'     list(
#'       Name = "string",
#'       Arn = "string"
#'     )
#'   ),
#'   NextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_proxy_rule_groups(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_proxy_rule_groups
#'
#' @aliases networkfirewall_list_proxy_rule_groups
networkfirewall_list_proxy_rule_groups <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListProxyRuleGroups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "ProxyRuleGroups"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_proxy_rule_groups_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_proxy_rule_groups_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_proxy_rule_groups <- networkfirewall_list_proxy_rule_groups

#' Retrieves the metadata for the rule groups that you have defined
#'
#' @description
#' Retrieves the metadata for the rule groups that you have defined.
#' Depending on your setting for max results and the number of rule groups,
#' a single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_rule_groups(NextToken, MaxResults, Scope,
#'   ManagedType, SubscriptionStatus, Type)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#' @param Scope The scope of the request. The default setting of `ACCOUNT` or a setting
#' of `NULL` returns all of the rule groups in your account. A setting of
#' `MANAGED` returns all available managed rule groups.
#' @param ManagedType Indicates the general category of the Amazon Web Services managed rule
#' group.
#' @param SubscriptionStatus Filters the results to show only rule groups with the specified
#' subscription status. Use this to find subscribed or unsubscribed rule
#' groups.
#' @param Type Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   RuleGroups = list(
#'     list(
#'       Name = "string",
#'       Arn = "string",
#'       VendorName = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_rule_groups(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   Scope = "MANAGED"|"ACCOUNT",
#'   ManagedType = "AWS_MANAGED_THREAT_SIGNATURES"|"AWS_MANAGED_DOMAIN_LISTS"|"ACTIVE_THREAT_DEFENSE"|"PARTNER_MANAGED",
#'   SubscriptionStatus = "NOT_SUBSCRIBED"|"SUBSCRIBED",
#'   Type = "STATELESS"|"STATEFUL"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_rule_groups
#'
#' @aliases networkfirewall_list_rule_groups
networkfirewall_list_rule_groups <- function(NextToken = NULL, MaxResults = NULL, Scope = NULL, ManagedType = NULL, SubscriptionStatus = NULL, Type = NULL) {
  op <- new_operation(
    name = "ListRuleGroups",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "RuleGroups"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_rule_groups_input(NextToken = NextToken, MaxResults = MaxResults, Scope = Scope, ManagedType = ManagedType, SubscriptionStatus = SubscriptionStatus, Type = Type)
  output <- .networkfirewall$list_rule_groups_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_rule_groups <- networkfirewall_list_rule_groups

#' Retrieves the metadata for the TLS inspection configurations that you
#' have defined
#'
#' @description
#' Retrieves the metadata for the TLS inspection configurations that you
#' have defined. Depending on your setting for max results and the number
#' of TLS inspection configurations, a single call might not return the
#' full list.
#'
#' @usage
#' networkfirewall_list_tls_inspection_configurations(NextToken,
#'   MaxResults)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   TLSInspectionConfigurations = list(
#'     list(
#'       Name = "string",
#'       Arn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tls_inspection_configurations(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_tls_inspection_configurations
#'
#' @aliases networkfirewall_list_tls_inspection_configurations
networkfirewall_list_tls_inspection_configurations <- function(NextToken = NULL, MaxResults = NULL) {
  op <- new_operation(
    name = "ListTLSInspectionConfigurations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "TLSInspectionConfigurations"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_tls_inspection_configurations_input(NextToken = NextToken, MaxResults = MaxResults)
  output <- .networkfirewall$list_tls_inspection_configurations_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_tls_inspection_configurations <- networkfirewall_list_tls_inspection_configurations

#' Retrieves the tags associated with the specified resource
#'
#' @description
#' Retrieves the tags associated with the specified resource. Tags are
#' key:value pairs that you can use to categorize and manage your
#' resources, for purposes like billing. For example, you might set the tag
#' key to "customer" and the value to the customer name or ID. You can
#' specify one or more tags to add to each Amazon Web Services resource, up
#' to 50 tags for a resource.
#' 
#' You can tag the Amazon Web Services resources that you manage through
#' Network Firewall: firewalls, firewall policies, and rule groups.
#'
#' @usage
#' networkfirewall_list_tags_for_resource(NextToken, MaxResults,
#'   ResourceArn)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   ResourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_tags_for_resource
#'
#' @aliases networkfirewall_list_tags_for_resource
networkfirewall_list_tags_for_resource <- function(NextToken = NULL, MaxResults = NULL, ResourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "Tags"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_tags_for_resource_input(NextToken = NextToken, MaxResults = MaxResults, ResourceArn = ResourceArn)
  output <- .networkfirewall$list_tags_for_resource_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_tags_for_resource <- networkfirewall_list_tags_for_resource

#' Retrieves the metadata for the VPC endpoint associations that you have
#' defined
#'
#' @description
#' Retrieves the metadata for the VPC endpoint associations that you have
#' defined. If you specify a fireawll, this returns only the endpoint
#' associations for that firewall.
#' 
#' Depending on your setting for max results and the number of
#' associations, a single call might not return the full list.
#'
#' @usage
#' networkfirewall_list_vpc_endpoint_associations(NextToken, MaxResults,
#'   FirewallArn)
#'
#' @param NextToken When you request a list of objects with a `MaxResults` setting, if the
#' number of objects that are still available for retrieval exceeds the
#' maximum you requested, Network Firewall returns a `NextToken` value in
#' the response. To retrieve the next batch of objects, use the token
#' returned from the prior request in your next request.
#' @param MaxResults The maximum number of objects that you want Network Firewall to return
#' for this request. If more objects are available, in the response,
#' Network Firewall provides a `NextToken` value that you can use in a
#' subsequent call to get the next batch of objects.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' If you don't specify this, Network Firewall retrieves all VPC endpoint
#' associations that you have defined.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   NextToken = "string",
#'   VpcEndpointAssociations = list(
#'     list(
#'       VpcEndpointAssociationArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_vpc_endpoint_associations(
#'   NextToken = "string",
#'   MaxResults = 123,
#'   FirewallArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_list_vpc_endpoint_associations
#'
#' @aliases networkfirewall_list_vpc_endpoint_associations
networkfirewall_list_vpc_endpoint_associations <- function(NextToken = NULL, MaxResults = NULL, FirewallArn = NULL) {
  op <- new_operation(
    name = "ListVpcEndpointAssociations",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(input_token = "NextToken", output_token = "NextToken", limit_key = "MaxResults", result_key = "VpcEndpointAssociations"),
    stream_api = FALSE
  )
  input <- .networkfirewall$list_vpc_endpoint_associations_input(NextToken = NextToken, MaxResults = MaxResults, FirewallArn = FirewallArn)
  output <- .networkfirewall$list_vpc_endpoint_associations_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$list_vpc_endpoint_associations <- networkfirewall_list_vpc_endpoint_associations

#' Creates or updates an IAM policy for your rule group, firewall policy,
#' or firewall
#'
#' @description
#' Creates or updates an IAM policy for your rule group, firewall policy,
#' or firewall. Use this to share these resources between accounts. This
#' operation works in conjunction with the Amazon Web Services Resource
#' Access Manager (RAM) service to manage resource sharing for Network
#' Firewall.
#' 
#' For information about using sharing with Network Firewall resources, see
#' [Sharing Network Firewall
#' resources](https://docs.aws.amazon.com/network-firewall/latest/developerguide/sharing.html)
#' in the *Network Firewall Developer Guide*.
#' 
#' Use this operation to create or update a resource policy for your
#' Network Firewall rule group, firewall policy, or firewall. In the
#' resource policy, you specify the accounts that you want to share the
#' Network Firewall resource with and the operations that you want the
#' accounts to be able to perform.
#' 
#' When you add an account in the resource policy, you then run the
#' following Resource Access Manager (RAM) operations to access and accept
#' the shared resource.
#' 
#' -   [GetResourceShareInvitations](https://docs.aws.amazon.com/ram/latest/APIReference/API_GetResourceShareInvitations.html) -
#'     Returns the Amazon Resource Names (ARNs) of the resource share
#'     invitations.
#' 
#' -   [AcceptResourceShareInvitation](https://docs.aws.amazon.com/ram/latest/APIReference/API_AcceptResourceShareInvitation.html) -
#'     Accepts the share invitation for a specified resource share.
#' 
#' For additional information about resource sharing using RAM, see
#' [Resource Access Manager User
#' Guide](https://docs.aws.amazon.com/ram/latest/userguide/what-is.html).
#'
#' @usage
#' networkfirewall_put_resource_policy(ResourceArn, Policy)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the account that you want to share
#' your Network Firewall resources with.
#' @param Policy &#91;required&#93; The IAM policy statement that lists the accounts that you want to share
#' your Network Firewall resources with and the operations that you want
#' the accounts to be able to perform.
#' 
#' For a rule group resource, you can specify the following operations in
#' the Actions section of the statement:
#' 
#' -   network-firewall:CreateFirewallPolicy
#' 
#' -   network-firewall:UpdateFirewallPolicy
#' 
#' -   network-firewall:ListRuleGroups
#' 
#' For a firewall policy resource, you can specify the following operations
#' in the Actions section of the statement:
#' 
#' -   network-firewall:AssociateFirewallPolicy
#' 
#' -   network-firewall:ListFirewallPolicies
#' 
#' For a firewall resource, you can specify the following operations in the
#' Actions section of the statement:
#' 
#' -   network-firewall:CreateVpcEndpointAssociation
#' 
#' -   network-firewall:DescribeFirewallMetadata
#' 
#' -   network-firewall:ListFirewalls
#' 
#' In the Resource section of the statement, you specify the ARNs for the
#' Network Firewall resources that you want to share with the account that
#' you specified in `Arn`.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$put_resource_policy(
#'   ResourceArn = "string",
#'   Policy = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_put_resource_policy
#'
#' @aliases networkfirewall_put_resource_policy
networkfirewall_put_resource_policy <- function(ResourceArn, Policy) {
  op <- new_operation(
    name = "PutResourcePolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$put_resource_policy_input(ResourceArn = ResourceArn, Policy = Policy)
  output <- .networkfirewall$put_resource_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$put_resource_policy <- networkfirewall_put_resource_policy

#' Rejects a transit gateway attachment request for Network Firewall
#'
#' @description
#' Rejects a transit gateway attachment request for Network Firewall. When
#' you reject the attachment request, Network Firewall cancels the creation
#' of routing components between the transit gateway and firewall
#' endpoints.
#' 
#' Only the transit gateway owner can reject the attachment. After
#' rejection, no traffic will flow through the firewall endpoints for this
#' attachment.
#' 
#' Use [`describe_firewall`][networkfirewall_describe_firewall] to monitor
#' the rejection status. To accept the attachment instead of rejecting it,
#' use
#' [`accept_network_firewall_transit_gateway_attachment`][networkfirewall_accept_network_firewall_transit_gateway_attachment].
#' 
#' Once rejected, you cannot reverse this action. To establish
#' connectivity, you must create a new transit gateway-attached firewall.
#'
#' @usage
#' networkfirewall_reject_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId)
#'
#' @param TransitGatewayAttachmentId &#91;required&#93; Required. The unique identifier of the transit gateway attachment to
#' reject. This ID is returned in the response when creating a transit
#' gateway-attached firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   TransitGatewayAttachmentId = "string",
#'   TransitGatewayAttachmentStatus = "CREATING"|"DELETING"|"DELETED"|"FAILED"|"ERROR"|"READY"|"PENDING_ACCEPTANCE"|"REJECTING"|"REJECTED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$reject_network_firewall_transit_gateway_attachment(
#'   TransitGatewayAttachmentId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_rejec_netwo_firew_trans_gatew_attac
#'
#' @aliases networkfirewall_reject_network_firewall_transit_gateway_attachment
networkfirewall_reject_network_firewall_transit_gateway_attachment <- function(TransitGatewayAttachmentId) {
  op <- new_operation(
    name = "RejectNetworkFirewallTransitGatewayAttachment",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$reject_network_firewall_transit_gateway_attachment_input(TransitGatewayAttachmentId = TransitGatewayAttachmentId)
  output <- .networkfirewall$reject_network_firewall_transit_gateway_attachment_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$reject_network_firewall_transit_gateway_attachment <- networkfirewall_reject_network_firewall_transit_gateway_attachment

#' Generates a traffic analysis report for the timeframe and traffic type
#' you specify
#'
#' @description
#' Generates a traffic analysis report for the timeframe and traffic type
#' you specify.
#' 
#' For information on the contents of a traffic analysis report, see
#' AnalysisReport.
#'
#' @usage
#' networkfirewall_start_analysis_report(FirewallName, FirewallArn,
#'   AnalysisType)
#'
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param AnalysisType &#91;required&#93; The type of traffic that will be used to generate a report.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   AnalysisReportId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_analysis_report(
#'   FirewallName = "string",
#'   FirewallArn = "string",
#'   AnalysisType = "TLS_SNI"|"HTTP_HOST"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_start_analysis_report
#'
#' @aliases networkfirewall_start_analysis_report
networkfirewall_start_analysis_report <- function(FirewallName = NULL, FirewallArn = NULL, AnalysisType) {
  op <- new_operation(
    name = "StartAnalysisReport",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$start_analysis_report_input(FirewallName = FirewallName, FirewallArn = FirewallArn, AnalysisType = AnalysisType)
  output <- .networkfirewall$start_analysis_report_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$start_analysis_report <- networkfirewall_start_analysis_report

#' Begins capturing the flows in a firewall, according to the filters you
#' define
#'
#' @description
#' Begins capturing the flows in a firewall, according to the filters you
#' define. Captures are similar, but not identical to snapshots. Capture
#' operations provide visibility into flows that are not closed and are
#' tracked by a firewall's flow table. Unlike snapshots, captures are a
#' time-boxed view.
#' 
#' A flow is network traffic that is monitored by a firewall, either by
#' stateful or stateless rules. For traffic to be considered part of a
#' flow, it must share Destination, DestinationPort, Direction, Protocol,
#' Source, and SourcePort.
#' 
#' To avoid encountering operation limits, you should avoid starting
#' captures with broad filters, like wide IP ranges. Instead, we recommend
#' you define more specific criteria with `FlowFilters`, like narrow IP
#' ranges, ports, or protocols.
#'
#' @usage
#' networkfirewall_start_flow_capture(FirewallArn, AvailabilityZone,
#'   VpcEndpointAssociationArn, VpcEndpointId, MinimumFlowAgeInSeconds,
#'   FlowFilters)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param AvailabilityZone The ID of the Availability Zone where the firewall is located. For
#' example, `us-east-2a`.
#' 
#' Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#' @param VpcEndpointAssociationArn The Amazon Resource Name (ARN) of a VPC endpoint association.
#' @param VpcEndpointId A unique identifier for the primary endpoint associated with a firewall.
#' @param MinimumFlowAgeInSeconds The reqested `FlowOperation` ignores flows with an age (in seconds)
#' lower than `MinimumFlowAgeInSeconds`. You provide this for start
#' commands.
#' 
#' We recommend setting this value to at least 1 minute (60 seconds) to
#' reduce chance of capturing flows that are not yet established.
#' @param FlowFilters &#91;required&#93; Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FlowOperationId = "string",
#'   FlowOperationStatus = "COMPLETED"|"IN_PROGRESS"|"FAILED"|"COMPLETED_WITH_ERRORS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_flow_capture(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   MinimumFlowAgeInSeconds = 123,
#'   FlowFilters = list(
#'     list(
#'       SourceAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       DestinationAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       SourcePort = "string",
#'       DestinationPort = "string",
#'       Protocols = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_start_flow_capture
#'
#' @aliases networkfirewall_start_flow_capture
networkfirewall_start_flow_capture <- function(FirewallArn, AvailabilityZone = NULL, VpcEndpointAssociationArn = NULL, VpcEndpointId = NULL, MinimumFlowAgeInSeconds = NULL, FlowFilters) {
  op <- new_operation(
    name = "StartFlowCapture",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$start_flow_capture_input(FirewallArn = FirewallArn, AvailabilityZone = AvailabilityZone, VpcEndpointAssociationArn = VpcEndpointAssociationArn, VpcEndpointId = VpcEndpointId, MinimumFlowAgeInSeconds = MinimumFlowAgeInSeconds, FlowFilters = FlowFilters)
  output <- .networkfirewall$start_flow_capture_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$start_flow_capture <- networkfirewall_start_flow_capture

#' Begins the flushing of traffic from the firewall, according to the
#' filters you define
#'
#' @description
#' Begins the flushing of traffic from the firewall, according to the
#' filters you define. When the operation starts, impacted flows are
#' temporarily marked as timed out before the Suricata engine prunes, or
#' flushes, the flows from the firewall table.
#' 
#' While the flush completes, impacted flows are processed as midstream
#' traffic. This may result in a temporary increase in midstream traffic
#' metrics. We recommend that you double check your stream exception policy
#' before you perform a flush operation.
#'
#' @usage
#' networkfirewall_start_flow_flush(FirewallArn, AvailabilityZone,
#'   VpcEndpointAssociationArn, VpcEndpointId, MinimumFlowAgeInSeconds,
#'   FlowFilters)
#'
#' @param FirewallArn &#91;required&#93; The Amazon Resource Name (ARN) of the firewall.
#' @param AvailabilityZone The ID of the Availability Zone where the firewall is located. For
#' example, `us-east-2a`.
#' 
#' Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#' @param VpcEndpointAssociationArn The Amazon Resource Name (ARN) of a VPC endpoint association.
#' @param VpcEndpointId A unique identifier for the primary endpoint associated with a firewall.
#' @param MinimumFlowAgeInSeconds The reqested `FlowOperation` ignores flows with an age (in seconds)
#' lower than `MinimumFlowAgeInSeconds`. You provide this for start
#' commands.
#' @param FlowFilters &#91;required&#93; Defines the scope a flow operation. You can use up to 20 filters to
#' configure a single flow operation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FlowOperationId = "string",
#'   FlowOperationStatus = "COMPLETED"|"IN_PROGRESS"|"FAILED"|"COMPLETED_WITH_ERRORS"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_flow_flush(
#'   FirewallArn = "string",
#'   AvailabilityZone = "string",
#'   VpcEndpointAssociationArn = "string",
#'   VpcEndpointId = "string",
#'   MinimumFlowAgeInSeconds = 123,
#'   FlowFilters = list(
#'     list(
#'       SourceAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       DestinationAddress = list(
#'         AddressDefinition = "string"
#'       ),
#'       SourcePort = "string",
#'       DestinationPort = "string",
#'       Protocols = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_start_flow_flush
#'
#' @aliases networkfirewall_start_flow_flush
networkfirewall_start_flow_flush <- function(FirewallArn, AvailabilityZone = NULL, VpcEndpointAssociationArn = NULL, VpcEndpointId = NULL, MinimumFlowAgeInSeconds = NULL, FlowFilters) {
  op <- new_operation(
    name = "StartFlowFlush",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$start_flow_flush_input(FirewallArn = FirewallArn, AvailabilityZone = AvailabilityZone, VpcEndpointAssociationArn = VpcEndpointAssociationArn, VpcEndpointId = VpcEndpointId, MinimumFlowAgeInSeconds = MinimumFlowAgeInSeconds, FlowFilters = FlowFilters)
  output <- .networkfirewall$start_flow_flush_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$start_flow_flush <- networkfirewall_start_flow_flush

#' Adds the specified tags to the specified resource
#'
#' @description
#' Adds the specified tags to the specified resource. Tags are key:value
#' pairs that you can use to categorize and manage your resources, for
#' purposes like billing. For example, you might set the tag key to
#' "customer" and the value to the customer name or ID. You can specify one
#' or more tags to add to each Amazon Web Services resource, up to 50 tags
#' for a resource.
#' 
#' You can tag the Amazon Web Services resources that you manage through
#' Network Firewall: firewalls, firewall policies, and rule groups.
#'
#' @usage
#' networkfirewall_tag_resource(ResourceArn, Tags)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource.
#' @param Tags &#91;required&#93; 
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   ResourceArn = "string",
#'   Tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_tag_resource
#'
#' @aliases networkfirewall_tag_resource
networkfirewall_tag_resource <- function(ResourceArn, Tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$tag_resource_input(ResourceArn = ResourceArn, Tags = Tags)
  output <- .networkfirewall$tag_resource_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$tag_resource <- networkfirewall_tag_resource

#' Removes the tags with the specified keys from the specified resource
#'
#' @description
#' Removes the tags with the specified keys from the specified resource.
#' Tags are key:value pairs that you can use to categorize and manage your
#' resources, for purposes like billing. For example, you might set the tag
#' key to "customer" and the value to the customer name or ID. You can
#' specify one or more tags to add to each Amazon Web Services resource, up
#' to 50 tags for a resource.
#' 
#' You can manage tags for the Amazon Web Services resources that you
#' manage through Network Firewall: firewalls, firewall policies, and rule
#' groups.
#'
#' @usage
#' networkfirewall_untag_resource(ResourceArn, TagKeys)
#'
#' @param ResourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource.
#' @param TagKeys &#91;required&#93; 
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   ResourceArn = "string",
#'   TagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_untag_resource
#'
#' @aliases networkfirewall_untag_resource
networkfirewall_untag_resource <- function(ResourceArn, TagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$untag_resource_input(ResourceArn = ResourceArn, TagKeys = TagKeys)
  output <- .networkfirewall$untag_resource_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$untag_resource <- networkfirewall_untag_resource

#' Modifies the AvailabilityZoneChangeProtection setting for a transit
#' gateway-attached firewall
#'
#' @description
#' Modifies the `AvailabilityZoneChangeProtection` setting for a transit
#' gateway-attached firewall. When enabled, this setting prevents
#' accidental changes to the firewall's Availability Zone configuration.
#' This helps protect against disrupting traffic flow in production
#' environments.
#' 
#' When enabled, you must disable this protection before using
#' [`associate_availability_zones`][networkfirewall_associate_availability_zones]
#' or
#' [`disassociate_availability_zones`][networkfirewall_disassociate_availability_zones]
#' to modify the firewall's Availability Zone configuration.
#'
#' @usage
#' networkfirewall_update_availability_zone_change_protection(UpdateToken,
#'   FirewallArn, FirewallName, AvailabilityZoneChangeProtection)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param AvailabilityZoneChangeProtection &#91;required&#93; A setting indicating whether the firewall is protected against changes
#' to the subnet associations. Use this setting to protect against
#' accidentally modifying the subnet associations for a firewall that is in
#' use. When you create a firewall, the operation initializes this setting
#' to `TRUE`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_availability_zone_change_protection(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   AvailabilityZoneChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_availability_zone_change_protection
#'
#' @aliases networkfirewall_update_availability_zone_change_protection
networkfirewall_update_availability_zone_change_protection <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, AvailabilityZoneChangeProtection) {
  op <- new_operation(
    name = "UpdateAvailabilityZoneChangeProtection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_availability_zone_change_protection_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, AvailabilityZoneChangeProtection = AvailabilityZoneChangeProtection)
  output <- .networkfirewall$update_availability_zone_change_protection_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_availability_zone_change_protection <- networkfirewall_update_availability_zone_change_protection

#' Enables specific types of firewall analysis on a specific firewall you
#' define
#'
#' @description
#' Enables specific types of firewall analysis on a specific firewall you
#' define.
#'
#' @usage
#' networkfirewall_update_firewall_analysis_settings(EnabledAnalysisTypes,
#'   FirewallArn, FirewallName, UpdateToken)
#'
#' @param EnabledAnalysisTypes An optional setting indicating the specific traffic analysis types to
#' enable on the firewall.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   EnabledAnalysisTypes = list(
#'     "TLS_SNI"|"HTTP_HOST"
#'   ),
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_analysis_settings(
#'   EnabledAnalysisTypes = list(
#'     "TLS_SNI"|"HTTP_HOST"
#'   ),
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_analysis_settings
#'
#' @aliases networkfirewall_update_firewall_analysis_settings
networkfirewall_update_firewall_analysis_settings <- function(EnabledAnalysisTypes = NULL, FirewallArn = NULL, FirewallName = NULL, UpdateToken = NULL) {
  op <- new_operation(
    name = "UpdateFirewallAnalysisSettings",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_analysis_settings_input(EnabledAnalysisTypes = EnabledAnalysisTypes, FirewallArn = FirewallArn, FirewallName = FirewallName, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_firewall_analysis_settings_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_analysis_settings <- networkfirewall_update_firewall_analysis_settings

#' Modifies the flag, DeleteProtection, which indicates whether it is
#' possible to delete the firewall
#'
#' @description
#' Modifies the flag, `DeleteProtection`, which indicates whether it is
#' possible to delete the firewall. If the flag is set to `TRUE`, the
#' firewall is protected against deletion. This setting helps protect
#' against accidentally deleting a firewall that's in use.
#'
#' @usage
#' networkfirewall_update_firewall_delete_protection(UpdateToken,
#'   FirewallArn, FirewallName, DeleteProtection)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param DeleteProtection &#91;required&#93; A flag indicating whether it is possible to delete the firewall. A
#' setting of `TRUE` indicates that the firewall is protected against
#' deletion. Use this setting to protect against accidentally deleting a
#' firewall that is in use. When you create a firewall, the operation
#' initializes this flag to `TRUE`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   DeleteProtection = TRUE|FALSE,
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_delete_protection(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   DeleteProtection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_delete_protection
#'
#' @aliases networkfirewall_update_firewall_delete_protection
networkfirewall_update_firewall_delete_protection <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, DeleteProtection) {
  op <- new_operation(
    name = "UpdateFirewallDeleteProtection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_delete_protection_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, DeleteProtection = DeleteProtection)
  output <- .networkfirewall$update_firewall_delete_protection_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_delete_protection <- networkfirewall_update_firewall_delete_protection

#' Modifies the description for the specified firewall
#'
#' @description
#' Modifies the description for the specified firewall. Use the description
#' to help you identify the firewall when you're working with it.
#'
#' @usage
#' networkfirewall_update_firewall_description(UpdateToken, FirewallArn,
#'   FirewallName, Description)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param Description The new description for the firewall. If you omit this setting, Network
#' Firewall removes the description for the firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   Description = "string",
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_description(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   Description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_description
#'
#' @aliases networkfirewall_update_firewall_description
networkfirewall_update_firewall_description <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, Description = NULL) {
  op <- new_operation(
    name = "UpdateFirewallDescription",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_description_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, Description = Description)
  output <- .networkfirewall$update_firewall_description_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_description <- networkfirewall_update_firewall_description

#' A complex type that contains settings for encryption of your firewall
#' resources
#'
#' @description
#' A complex type that contains settings for encryption of your firewall
#' resources.
#'
#' @usage
#' networkfirewall_update_firewall_encryption_configuration(UpdateToken,
#'   FirewallArn, FirewallName, EncryptionConfiguration)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' @param EncryptionConfiguration 
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   UpdateToken = "string",
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_encryption_configuration(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_encryption_configuration
#'
#' @aliases networkfirewall_update_firewall_encryption_configuration
networkfirewall_update_firewall_encryption_configuration <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, EncryptionConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateFirewallEncryptionConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_encryption_configuration_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, EncryptionConfiguration = EncryptionConfiguration)
  output <- .networkfirewall$update_firewall_encryption_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_encryption_configuration <- networkfirewall_update_firewall_encryption_configuration

#' Updates the properties of the specified firewall policy
#'
#' @description
#' Updates the properties of the specified firewall policy.
#'
#' @usage
#' networkfirewall_update_firewall_policy(UpdateToken, FirewallPolicyArn,
#'   FirewallPolicyName, FirewallPolicy, Description, DryRun,
#'   EncryptionConfiguration)
#'
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the firewall policy. The token marks the state
#' of the policy resource at the time of the request.
#' 
#' To make changes to the policy, you provide the token in your request.
#' Network Firewall uses the token to ensure that the policy hasn't changed
#' since you last retrieved it. If it has changed, the operation fails with
#' an `InvalidTokenException`. If this happens, retrieve the firewall
#' policy again to get a current copy of it with current token. Reapply
#' your changes as needed, then try the operation again using the new
#' token.
#' @param FirewallPolicyArn The Amazon Resource Name (ARN) of the firewall policy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicyName The descriptive name of the firewall policy. You can't change the name
#' of a firewall policy after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicy &#91;required&#93; The updated firewall policy to use for the firewall. You can't add or
#' remove a TLSInspectionConfiguration after you create a firewall policy.
#' However, you can replace an existing TLS inspection configuration with
#' another `TLSInspectionConfiguration`.
#' @param Description A description of the firewall policy.
#' @param DryRun Indicates whether you want Network Firewall to just check the validity
#' of the request, rather than run the request.
#' 
#' If set to `TRUE`, Network Firewall checks whether the request can run
#' successfully, but doesn't actually make the requested changes. The call
#' returns the value that the request would return if you ran it with dry
#' run set to `FALSE`, but doesn't make additions or changes to your
#' resources. This option allows you to make sure that you have the
#' required permissions to run the request and that your request parameters
#' are valid.
#' 
#' If set to `FALSE`, Network Firewall makes the requested changes to your
#' resources.
#' @param EncryptionConfiguration A complex type that contains settings for encryption of your firewall
#' policy resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallPolicyResponse = list(
#'     FirewallPolicyName = "string",
#'     FirewallPolicyArn = "string",
#'     FirewallPolicyId = "string",
#'     Description = "string",
#'     FirewallPolicyStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedStatelessRuleCapacity = 123,
#'     ConsumedStatefulRuleCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_policy(
#'   UpdateToken = "string",
#'   FirewallPolicyArn = "string",
#'   FirewallPolicyName = "string",
#'   FirewallPolicy = list(
#'     StatelessRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123
#'       )
#'     ),
#'     StatelessDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessFragmentDefaultActions = list(
#'       "string"
#'     ),
#'     StatelessCustomActions = list(
#'       list(
#'         ActionName = "string",
#'         ActionDefinition = list(
#'           PublishMetricAction = list(
#'             Dimensions = list(
#'               list(
#'                 Value = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleGroupReferences = list(
#'       list(
#'         ResourceArn = "string",
#'         Priority = 123,
#'         Override = list(
#'           Action = "DROP_TO_ALERT"
#'         ),
#'         DeepThreatInspection = TRUE|FALSE
#'       )
#'     ),
#'     StatefulDefaultActions = list(
#'       "string"
#'     ),
#'     StatefulEngineOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER",
#'       StreamExceptionPolicy = "DROP"|"CONTINUE"|"REJECT",
#'       FlowTimeouts = list(
#'         TcpIdleTimeoutSeconds = 123
#'       )
#'     ),
#'     TLSInspectionConfigurationArn = "string",
#'     PolicyVariables = list(
#'       RuleVariables = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     EnableTLSSessionHolding = TRUE|FALSE
#'   ),
#'   Description = "string",
#'   DryRun = TRUE|FALSE,
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_policy
#'
#' @aliases networkfirewall_update_firewall_policy
networkfirewall_update_firewall_policy <- function(UpdateToken, FirewallPolicyArn = NULL, FirewallPolicyName = NULL, FirewallPolicy, Description = NULL, DryRun = NULL, EncryptionConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateFirewallPolicy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_policy_input(UpdateToken = UpdateToken, FirewallPolicyArn = FirewallPolicyArn, FirewallPolicyName = FirewallPolicyName, FirewallPolicy = FirewallPolicy, Description = Description, DryRun = DryRun, EncryptionConfiguration = EncryptionConfiguration)
  output <- .networkfirewall$update_firewall_policy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_policy <- networkfirewall_update_firewall_policy

#' Modifies the flag, ChangeProtection, which indicates whether it is
#' possible to change the firewall
#'
#' @description
#' Modifies the flag, `ChangeProtection`, which indicates whether it is
#' possible to change the firewall. If the flag is set to `TRUE`, the
#' firewall is protected from changes. This setting helps protect against
#' accidentally changing a firewall that's in use.
#'
#' @usage
#' networkfirewall_update_firewall_policy_change_protection(UpdateToken,
#'   FirewallArn, FirewallName, FirewallPolicyChangeProtection)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallPolicyChangeProtection &#91;required&#93; A setting indicating whether the firewall is protected against a change
#' to the firewall policy association. Use this setting to protect against
#' accidentally modifying the firewall policy for a firewall that is in
#' use. When you create a firewall, the operation initializes this setting
#' to `TRUE`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   FirewallPolicyChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_firewall_policy_change_protection(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   FirewallPolicyChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_firewall_policy_change_protection
#'
#' @aliases networkfirewall_update_firewall_policy_change_protection
networkfirewall_update_firewall_policy_change_protection <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, FirewallPolicyChangeProtection) {
  op <- new_operation(
    name = "UpdateFirewallPolicyChangeProtection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_firewall_policy_change_protection_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, FirewallPolicyChangeProtection = FirewallPolicyChangeProtection)
  output <- .networkfirewall$update_firewall_policy_change_protection_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_firewall_policy_change_protection <- networkfirewall_update_firewall_policy_change_protection

#' Sets the logging configuration for the specified firewall
#'
#' @description
#' Sets the logging configuration for the specified firewall.
#' 
#' To change the logging configuration, retrieve the LoggingConfiguration
#' by calling
#' [`describe_logging_configuration`][networkfirewall_describe_logging_configuration],
#' then change it and provide the modified object to this update call. You
#' must change the logging configuration one LogDestinationConfig at a time
#' inside the retrieved LoggingConfiguration object.
#' 
#' You can perform only one of the following actions in any call to
#' [`update_logging_configuration`][networkfirewall_update_logging_configuration]:
#' 
#' -   Create a new log destination object by adding a single
#'     `LogDestinationConfig` array element to `LogDestinationConfigs`.
#' 
#' -   Delete a log destination object by removing a single
#'     `LogDestinationConfig` array element from `LogDestinationConfigs`.
#' 
#' -   Change the `LogDestination` setting in a single
#'     `LogDestinationConfig` array element.
#' 
#' You can't change the `LogDestinationType` or `LogType` in a
#' `LogDestinationConfig`. To change these settings, delete the existing
#' `LogDestinationConfig` object and create a new one, using two separate
#' calls to this update operation.
#'
#' @usage
#' networkfirewall_update_logging_configuration(FirewallArn, FirewallName,
#'   LoggingConfiguration, EnableMonitoringDashboard)
#'
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param LoggingConfiguration Defines how Network Firewall performs logging for a firewall. If you
#' omit this setting, Network Firewall disables logging for the firewall.
#' @param EnableMonitoringDashboard A boolean that lets you enable or disable the detailed firewall
#' monitoring dashboard on the firewall.
#' 
#' The monitoring dashboard provides comprehensive visibility into your
#' firewall's flow logs and alert logs. After you enable detailed
#' monitoring, you can access these dashboards directly from the
#' **Monitoring** page of the Network Firewall console.
#' 
#' Specify `TRUE` to enable the the detailed monitoring dashboard on the
#' firewall. Specify `FALSE` to disable the the detailed monitoring
#' dashboard on the firewall.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   LoggingConfiguration = list(
#'     LogDestinationConfigs = list(
#'       list(
#'         LogType = "ALERT"|"FLOW"|"TLS",
#'         LogDestinationType = "S3"|"CloudWatchLogs"|"KinesisDataFirehose",
#'         LogDestination = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   EnableMonitoringDashboard = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_logging_configuration(
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   LoggingConfiguration = list(
#'     LogDestinationConfigs = list(
#'       list(
#'         LogType = "ALERT"|"FLOW"|"TLS",
#'         LogDestinationType = "S3"|"CloudWatchLogs"|"KinesisDataFirehose",
#'         LogDestination = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   EnableMonitoringDashboard = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_logging_configuration
#'
#' @aliases networkfirewall_update_logging_configuration
networkfirewall_update_logging_configuration <- function(FirewallArn = NULL, FirewallName = NULL, LoggingConfiguration = NULL, EnableMonitoringDashboard = NULL) {
  op <- new_operation(
    name = "UpdateLoggingConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_logging_configuration_input(FirewallArn = FirewallArn, FirewallName = FirewallName, LoggingConfiguration = LoggingConfiguration, EnableMonitoringDashboard = EnableMonitoringDashboard)
  output <- .networkfirewall$update_logging_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_logging_configuration <- networkfirewall_update_logging_configuration

#' Updates the properties of the specified proxy
#'
#' @description
#' Updates the properties of the specified proxy.
#'
#' @usage
#' networkfirewall_update_proxy(NatGatewayId, ProxyName, ProxyArn,
#'   ListenerPropertiesToAdd, ListenerPropertiesToRemove,
#'   TlsInterceptProperties, UpdateToken)
#'
#' @param NatGatewayId &#91;required&#93; The NAT Gateway the proxy is attached to.
#' @param ProxyName The descriptive name of the proxy. You can't change the name of a proxy
#' after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyArn The Amazon Resource Name (ARN) of a proxy.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ListenerPropertiesToAdd Listener properties for HTTP and HTTPS traffic to add.
#' @param ListenerPropertiesToRemove Listener properties for HTTP and HTTPS traffic to remove.
#' @param TlsInterceptProperties TLS decryption on traffic to filter on attributes in the HTTP header.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy. The token marks the state of the
#' proxy resource at the time of the request.
#' 
#' To make changes to the proxy, you provide the token in your request.
#' Network Firewall uses the token to ensure that the proxy hasn't changed
#' since you last retrieved it. If it has changed, the operation fails with
#' an `InvalidTokenException`. If this happens, retrieve the proxy again to
#' get a current copy of it with a current token. Reapply your changes as
#' needed, then try the operation again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   Proxy = list(
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     UpdateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     FailureCode = "string",
#'     FailureMessage = "string",
#'     ProxyState = "ATTACHING"|"ATTACHED"|"DETACHING"|"DETACHED"|"ATTACH_FAILED"|"DETACH_FAILED",
#'     ProxyModifyState = "MODIFYING"|"COMPLETED"|"FAILED",
#'     NatGatewayId = "string",
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     ProxyName = "string",
#'     ProxyArn = "string",
#'     ListenerProperties = list(
#'       list(
#'         Port = 123,
#'         Type = "HTTP"|"HTTPS"
#'       )
#'     ),
#'     TlsInterceptProperties = list(
#'       PcaArn = "string",
#'       TlsInterceptMode = "ENABLED"|"DISABLED"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_proxy(
#'   NatGatewayId = "string",
#'   ProxyName = "string",
#'   ProxyArn = "string",
#'   ListenerPropertiesToAdd = list(
#'     list(
#'       Port = 123,
#'       Type = "HTTP"|"HTTPS"
#'     )
#'   ),
#'   ListenerPropertiesToRemove = list(
#'     list(
#'       Port = 123,
#'       Type = "HTTP"|"HTTPS"
#'     )
#'   ),
#'   TlsInterceptProperties = list(
#'     PcaArn = "string",
#'     TlsInterceptMode = "ENABLED"|"DISABLED"
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_proxy
#'
#' @aliases networkfirewall_update_proxy
networkfirewall_update_proxy <- function(NatGatewayId, ProxyName = NULL, ProxyArn = NULL, ListenerPropertiesToAdd = NULL, ListenerPropertiesToRemove = NULL, TlsInterceptProperties = NULL, UpdateToken) {
  op <- new_operation(
    name = "UpdateProxy",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_proxy_input(NatGatewayId = NatGatewayId, ProxyName = ProxyName, ProxyArn = ProxyArn, ListenerPropertiesToAdd = ListenerPropertiesToAdd, ListenerPropertiesToRemove = ListenerPropertiesToRemove, TlsInterceptProperties = TlsInterceptProperties, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_proxy_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_proxy <- networkfirewall_update_proxy

#' Updates the properties of the specified proxy configuration
#'
#' @description
#' Updates the properties of the specified proxy configuration.
#'
#' @usage
#' networkfirewall_update_proxy_configuration(ProxyConfigurationName,
#'   ProxyConfigurationArn, DefaultRulePhaseActions, UpdateToken)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param DefaultRulePhaseActions &#91;required&#93; Evaluation points in the traffic flow where rules are applied. There are
#' three phases in a traffic where the rule match is applied.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy configuration. The token marks the
#' state of the proxy configuration resource at the time of the request.
#' 
#' To make changes to the proxy configuration, you provide the token in
#' your request. Network Firewall uses the token to ensure that the proxy
#' configuration hasn't changed since you last retrieved it. If it has
#' changed, the operation fails with an `InvalidTokenException`. If this
#' happens, retrieve the proxy configuration again to get a current copy of
#' it with a current token. Reapply your changes as needed, then try the
#' operation again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyConfiguration = list(
#'     ProxyConfigurationName = "string",
#'     ProxyConfigurationArn = "string",
#'     Description = "string",
#'     CreateTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     DeleteTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     RuleGroups = list(
#'       list(
#'         ProxyRuleGroupName = "string",
#'         ProxyRuleGroupArn = "string",
#'         Type = "string",
#'         Priority = 123
#'       )
#'     ),
#'     DefaultRulePhaseActions = list(
#'       PreDNS = "ALLOW"|"DENY"|"ALERT",
#'       PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'       PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'     ),
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_proxy_configuration(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string",
#'   DefaultRulePhaseActions = list(
#'     PreDNS = "ALLOW"|"DENY"|"ALERT",
#'     PreREQUEST = "ALLOW"|"DENY"|"ALERT",
#'     PostRESPONSE = "ALLOW"|"DENY"|"ALERT"
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_proxy_configuration
#'
#' @aliases networkfirewall_update_proxy_configuration
networkfirewall_update_proxy_configuration <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL, DefaultRulePhaseActions, UpdateToken) {
  op <- new_operation(
    name = "UpdateProxyConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_proxy_configuration_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn, DefaultRulePhaseActions = DefaultRulePhaseActions, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_proxy_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_proxy_configuration <- networkfirewall_update_proxy_configuration

#' Updates the properties of the specified proxy rule
#'
#' @description
#' Updates the properties of the specified proxy rule.
#'
#' @usage
#' networkfirewall_update_proxy_rule(ProxyRuleGroupName, ProxyRuleGroupArn,
#'   ProxyRuleName, Description, Action, AddConditions, RemoveConditions,
#'   UpdateToken)
#'
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleName &#91;required&#93; The descriptive name of the proxy rule. You can't change the name of a
#' proxy rule after you create it.
#' @param Description A description of the proxy rule.
#' @param Action Depending on the match action, the proxy either stops the evaluation (if
#' the action is terminal - allow or deny), or continues it (if the action
#' is alert) until it matches a rule with a terminal action.
#' @param AddConditions Proxy rule conditions to add. Match criteria that specify what traffic
#' attributes to examine. Conditions include operators (StringEquals,
#' StringLike) and values to match against.
#' @param RemoveConditions Proxy rule conditions to remove. Match criteria that specify what
#' traffic attributes to examine. Conditions include operators
#' (StringEquals, StringLike) and values to match against.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy rule. The token marks the state of
#' the proxy rule resource at the time of the request.
#' 
#' To make changes to the proxy rule, you provide the token in your
#' request. Network Firewall uses the token to ensure that the proxy rule
#' hasn't changed since you last retrieved it. If it has changed, the
#' operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the proxy rule again to get a current copy of it with a current
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRule = list(
#'     ProxyRuleName = "string",
#'     Description = "string",
#'     Action = "ALLOW"|"DENY"|"ALERT",
#'     Conditions = list(
#'       list(
#'         ConditionOperator = "string",
#'         ConditionKey = "string",
#'         ConditionValues = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   RemovedConditions = list(
#'     list(
#'       ConditionOperator = "string",
#'       ConditionKey = "string",
#'       ConditionValues = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_proxy_rule(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string",
#'   ProxyRuleName = "string",
#'   Description = "string",
#'   Action = "ALLOW"|"DENY"|"ALERT",
#'   AddConditions = list(
#'     list(
#'       ConditionOperator = "string",
#'       ConditionKey = "string",
#'       ConditionValues = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   RemoveConditions = list(
#'     list(
#'       ConditionOperator = "string",
#'       ConditionKey = "string",
#'       ConditionValues = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_proxy_rule
#'
#' @aliases networkfirewall_update_proxy_rule
networkfirewall_update_proxy_rule <- function(ProxyRuleGroupName = NULL, ProxyRuleGroupArn = NULL, ProxyRuleName, Description = NULL, Action = NULL, AddConditions = NULL, RemoveConditions = NULL, UpdateToken) {
  op <- new_operation(
    name = "UpdateProxyRule",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_proxy_rule_input(ProxyRuleGroupName = ProxyRuleGroupName, ProxyRuleGroupArn = ProxyRuleGroupArn, ProxyRuleName = ProxyRuleName, Description = Description, Action = Action, AddConditions = AddConditions, RemoveConditions = RemoveConditions, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_proxy_rule_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_proxy_rule <- networkfirewall_update_proxy_rule

#' Updates proxy rule group priorities within a proxy configuration
#'
#' @description
#' Updates proxy rule group priorities within a proxy configuration.
#'
#' @usage
#' networkfirewall_update_proxy_rule_group_priorities(
#'   ProxyConfigurationName, ProxyConfigurationArn, RuleGroups, UpdateToken)
#'
#' @param ProxyConfigurationName The descriptive name of the proxy configuration. You can't change the
#' name of a proxy configuration after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyConfigurationArn The Amazon Resource Name (ARN) of a proxy configuration.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroups &#91;required&#93; proxy rule group resources to update to new positions.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy configuration. The token marks the
#' state of the proxy configuration resource at the time of the request.
#' 
#' To make changes to the proxy configuration, you provide the token in
#' your request. Network Firewall uses the token to ensure that the proxy
#' configuration hasn't changed since you last retrieved it. If it has
#' changed, the operation fails with an `InvalidTokenException`. If this
#' happens, retrieve the proxy configuration again to get a current copy of
#' it with a current token. Reapply your changes as needed, then try the
#' operation again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroups = list(
#'     list(
#'       ProxyRuleGroupName = "string",
#'       Priority = 123
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_proxy_rule_group_priorities(
#'   ProxyConfigurationName = "string",
#'   ProxyConfigurationArn = "string",
#'   RuleGroups = list(
#'     list(
#'       ProxyRuleGroupName = "string",
#'       NewPosition = 123
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_proxy_rule_group_priorities
#'
#' @aliases networkfirewall_update_proxy_rule_group_priorities
networkfirewall_update_proxy_rule_group_priorities <- function(ProxyConfigurationName = NULL, ProxyConfigurationArn = NULL, RuleGroups, UpdateToken) {
  op <- new_operation(
    name = "UpdateProxyRuleGroupPriorities",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_proxy_rule_group_priorities_input(ProxyConfigurationName = ProxyConfigurationName, ProxyConfigurationArn = ProxyConfigurationArn, RuleGroups = RuleGroups, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_proxy_rule_group_priorities_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_proxy_rule_group_priorities <- networkfirewall_update_proxy_rule_group_priorities

#' Updates proxy rule priorities within a proxy rule group
#'
#' @description
#' Updates proxy rule priorities within a proxy rule group.
#'
#' @usage
#' networkfirewall_update_proxy_rule_priorities(ProxyRuleGroupName,
#'   ProxyRuleGroupArn, RuleGroupRequestPhase, Rules, UpdateToken)
#'
#' @param ProxyRuleGroupName The descriptive name of the proxy rule group. You can't change the name
#' of a proxy rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param ProxyRuleGroupArn The Amazon Resource Name (ARN) of a proxy rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupRequestPhase &#91;required&#93; Evaluation points in the traffic flow where rules are applied. There are
#' three phases in a traffic where the rule match is applied.
#' @param Rules &#91;required&#93; proxy rule resources to update to new positions.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the proxy rule group. The token marks the
#' state of the proxy rule group resource at the time of the request.
#' 
#' To make changes to the proxy rule group, you provide the token in your
#' request. Network Firewall uses the token to ensure that the proxy rule
#' group hasn't changed since you last retrieved it. If it has changed, the
#' operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the proxy rule group again to get a current copy of it with a
#' current token. Reapply your changes as needed, then try the operation
#' again using the new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string",
#'   RuleGroupRequestPhase = "PRE_DNS"|"PRE_REQ"|"POST_RES",
#'   Rules = list(
#'     list(
#'       ProxyRuleName = "string",
#'       NewPosition = 123
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_proxy_rule_priorities(
#'   ProxyRuleGroupName = "string",
#'   ProxyRuleGroupArn = "string",
#'   RuleGroupRequestPhase = "PRE_DNS"|"PRE_REQ"|"POST_RES",
#'   Rules = list(
#'     list(
#'       ProxyRuleName = "string",
#'       NewPosition = 123
#'     )
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_proxy_rule_priorities
#'
#' @aliases networkfirewall_update_proxy_rule_priorities
networkfirewall_update_proxy_rule_priorities <- function(ProxyRuleGroupName = NULL, ProxyRuleGroupArn = NULL, RuleGroupRequestPhase, Rules, UpdateToken) {
  op <- new_operation(
    name = "UpdateProxyRulePriorities",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_proxy_rule_priorities_input(ProxyRuleGroupName = ProxyRuleGroupName, ProxyRuleGroupArn = ProxyRuleGroupArn, RuleGroupRequestPhase = RuleGroupRequestPhase, Rules = Rules, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_proxy_rule_priorities_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_proxy_rule_priorities <- networkfirewall_update_proxy_rule_priorities

#' Updates the rule settings for the specified rule group
#'
#' @description
#' Updates the rule settings for the specified rule group. You use a rule
#' group by reference in one or more firewall policies. When you modify a
#' rule group, you modify all firewall policies that use the rule group.
#' 
#' To update a rule group, first call
#' [`describe_rule_group`][networkfirewall_describe_rule_group] to retrieve
#' the current RuleGroup object, update the object as needed, and then
#' provide the updated object to this call.
#'
#' @usage
#' networkfirewall_update_rule_group(UpdateToken, RuleGroupArn,
#'   RuleGroupName, RuleGroup, Rules, Type, Description, DryRun,
#'   EncryptionConfiguration, SourceMetadata, AnalyzeRuleGroup,
#'   SummaryConfiguration)
#'
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the rule group. The token marks the state of
#' the rule group resource at the time of the request.
#' 
#' To make changes to the rule group, you provide the token in your
#' request. Network Firewall uses the token to ensure that the rule group
#' hasn't changed since you last retrieved it. If it has changed, the
#' operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the rule group again to get a current copy of it with a current
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param RuleGroupArn The Amazon Resource Name (ARN) of the rule group.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroupName The descriptive name of the rule group. You can't change the name of a
#' rule group after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param RuleGroup An object that defines the rule group rules.
#' 
#' You must provide either this rule group setting or a `Rules` setting,
#' but not both.
#' @param Rules A string containing stateful rule group rules specifications in Suricata
#' flat format, with one rule per line. Use this to import your existing
#' Suricata compatible rule groups.
#' 
#' You must provide either this rules setting or a populated `RuleGroup`
#' setting, but not both.
#' 
#' You can provide your rule group specification in Suricata flat format
#' through this setting when you create or update your rule group. The call
#' response returns a RuleGroup object that Network Firewall has populated
#' from your string.
#' @param Type Indicates whether the rule group is stateless or stateful. If the rule
#' group is stateless, it contains stateless rules. If it is stateful, it
#' contains stateful rules.
#' 
#' This setting is required for requests that do not include the
#' `RuleGroupARN`.
#' @param Description A description of the rule group.
#' @param DryRun Indicates whether you want Network Firewall to just check the validity
#' of the request, rather than run the request.
#' 
#' If set to `TRUE`, Network Firewall checks whether the request can run
#' successfully, but doesn't actually make the requested changes. The call
#' returns the value that the request would return if you ran it with dry
#' run set to `FALSE`, but doesn't make additions or changes to your
#' resources. This option allows you to make sure that you have the
#' required permissions to run the request and that your request parameters
#' are valid.
#' 
#' If set to `FALSE`, Network Firewall makes the requested changes to your
#' resources.
#' @param EncryptionConfiguration A complex type that contains settings for encryption of your rule group
#' resources.
#' @param SourceMetadata A complex type that contains metadata about the rule group that your own
#' rule group is copied from. You can use the metadata to keep track of
#' updates made to the originating rule group.
#' @param AnalyzeRuleGroup Indicates whether you want Network Firewall to analyze the stateless
#' rules in the rule group for rule behavior such as asymmetric routing. If
#' set to `TRUE`, Network Firewall runs the analysis and then updates the
#' rule group for you. To run the stateless rule group analyzer without
#' updating the rule group, set `DryRun` to `TRUE`.
#' @param SummaryConfiguration Updates the selected summary configuration for a rule group.
#' 
#' Changes affect subsequent responses from
#' [`describe_rule_group_summary`][networkfirewall_describe_rule_group_summary].
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   RuleGroupResponse = list(
#'     RuleGroupArn = "string",
#'     RuleGroupName = "string",
#'     RuleGroupId = "string",
#'     Description = "string",
#'     Type = "STATELESS"|"STATEFUL",
#'     Capacity = 123,
#'     RuleGroupStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     ConsumedCapacity = 123,
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     SourceMetadata = list(
#'       SourceArn = "string",
#'       SourceUpdateToken = "string"
#'     ),
#'     SnsTopic = "string",
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     AnalysisResults = list(
#'       list(
#'         IdentifiedRuleIds = list(
#'           "string"
#'         ),
#'         IdentifiedType = "STATELESS_RULE_FORWARDING_ASYMMETRICALLY"|"STATELESS_RULE_CONTAINS_TCP_FLAGS",
#'         AnalysisDetail = "string"
#'       )
#'     ),
#'     SummaryConfiguration = list(
#'       RuleOptions = list(
#'         "SID"|"MSG"|"METADATA"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_rule_group(
#'   UpdateToken = "string",
#'   RuleGroupArn = "string",
#'   RuleGroupName = "string",
#'   RuleGroup = list(
#'     RuleVariables = list(
#'       IPSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       PortSets = list(
#'         list(
#'           Definition = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ReferenceSets = list(
#'       IPSetReferences = list(
#'         list(
#'           ReferenceArn = "string"
#'         )
#'       )
#'     ),
#'     RulesSource = list(
#'       RulesString = "string",
#'       RulesSourceList = list(
#'         Targets = list(
#'           "string"
#'         ),
#'         TargetTypes = list(
#'           "TLS_SNI"|"HTTP_HOST"
#'         ),
#'         GeneratedRulesType = "ALLOWLIST"|"DENYLIST"|"REJECTLIST"|"ALERTLIST"
#'       ),
#'       StatefulRules = list(
#'         list(
#'           Action = "PASS"|"DROP"|"ALERT"|"REJECT",
#'           Header = list(
#'             Protocol = "IP"|"TCP"|"UDP"|"ICMP"|"HTTP"|"FTP"|"TLS"|"SMB"|"DNS"|"DCERPC"|"SSH"|"SMTP"|"IMAP"|"MSN"|"KRB5"|"IKEV2"|"TFTP"|"NTP"|"DHCP"|"HTTP2"|"QUIC",
#'             Source = "string",
#'             SourcePort = "string",
#'             Direction = "FORWARD"|"ANY",
#'             Destination = "string",
#'             DestinationPort = "string"
#'           ),
#'           RuleOptions = list(
#'             list(
#'               Keyword = "string",
#'               Settings = list(
#'                 "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       StatelessRulesAndCustomActions = list(
#'         StatelessRules = list(
#'           list(
#'             RuleDefinition = list(
#'               MatchAttributes = list(
#'                 Sources = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 Destinations = list(
#'                   list(
#'                     AddressDefinition = "string"
#'                   )
#'                 ),
#'                 SourcePorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 DestinationPorts = list(
#'                   list(
#'                     FromPort = 123,
#'                     ToPort = 123
#'                   )
#'                 ),
#'                 Protocols = list(
#'                   123
#'                 ),
#'                 TCPFlags = list(
#'                   list(
#'                     Flags = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     ),
#'                     Masks = list(
#'                       "FIN"|"SYN"|"RST"|"PSH"|"ACK"|"URG"|"ECE"|"CWR"
#'                     )
#'                   )
#'                 )
#'               ),
#'               Actions = list(
#'                 "string"
#'               )
#'             ),
#'             Priority = 123
#'           )
#'         ),
#'         CustomActions = list(
#'           list(
#'             ActionName = "string",
#'             ActionDefinition = list(
#'               PublishMetricAction = list(
#'                 Dimensions = list(
#'                   list(
#'                     Value = "string"
#'                   )
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     StatefulRuleOptions = list(
#'       RuleOrder = "DEFAULT_ACTION_ORDER"|"STRICT_ORDER"
#'     )
#'   ),
#'   Rules = "string",
#'   Type = "STATELESS"|"STATEFUL",
#'   Description = "string",
#'   DryRun = TRUE|FALSE,
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   ),
#'   SourceMetadata = list(
#'     SourceArn = "string",
#'     SourceUpdateToken = "string"
#'   ),
#'   AnalyzeRuleGroup = TRUE|FALSE,
#'   SummaryConfiguration = list(
#'     RuleOptions = list(
#'       "SID"|"MSG"|"METADATA"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_rule_group
#'
#' @aliases networkfirewall_update_rule_group
networkfirewall_update_rule_group <- function(UpdateToken, RuleGroupArn = NULL, RuleGroupName = NULL, RuleGroup = NULL, Rules = NULL, Type = NULL, Description = NULL, DryRun = NULL, EncryptionConfiguration = NULL, SourceMetadata = NULL, AnalyzeRuleGroup = NULL, SummaryConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateRuleGroup",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_rule_group_input(UpdateToken = UpdateToken, RuleGroupArn = RuleGroupArn, RuleGroupName = RuleGroupName, RuleGroup = RuleGroup, Rules = Rules, Type = Type, Description = Description, DryRun = DryRun, EncryptionConfiguration = EncryptionConfiguration, SourceMetadata = SourceMetadata, AnalyzeRuleGroup = AnalyzeRuleGroup, SummaryConfiguration = SummaryConfiguration)
  output <- .networkfirewall$update_rule_group_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_rule_group <- networkfirewall_update_rule_group

#' Update subnet change protection
#'
#' @description
#' Update subnet change protection
#'
#' @usage
#' networkfirewall_update_subnet_change_protection(UpdateToken,
#'   FirewallArn, FirewallName, SubnetChangeProtection)
#'
#' @param UpdateToken An optional token that you can use for optimistic locking. Network
#' Firewall returns a token to your requests that access the firewall. The
#' token marks the state of the firewall resource at the time of the
#' request.
#' 
#' To make an unconditional change to the firewall, omit the token in your
#' update request. Without the token, Network Firewall performs your
#' updates regardless of whether the firewall has changed since you last
#' retrieved it.
#' 
#' To make a conditional change to the firewall, provide the token in your
#' update request. Network Firewall uses the token to ensure that the
#' firewall hasn't changed since you last retrieved it. If it has changed,
#' the operation fails with an `InvalidTokenException`. If this happens,
#' retrieve the firewall again to get a current copy of it with a new
#' token. Reapply your changes as needed, then try the operation again
#' using the new token.
#' @param FirewallArn The Amazon Resource Name (ARN) of the firewall.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param FirewallName The descriptive name of the firewall. You can't change the name of a
#' firewall after you create it.
#' 
#' You must specify the ARN or the name, and you can specify both.
#' @param SubnetChangeProtection &#91;required&#93; A setting indicating whether the firewall is protected against changes
#' to the subnet associations. Use this setting to protect against
#' accidentally modifying the subnet associations for a firewall that is in
#' use. When you create a firewall, the operation initializes this setting
#' to `TRUE`.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_subnet_change_protection(
#'   UpdateToken = "string",
#'   FirewallArn = "string",
#'   FirewallName = "string",
#'   SubnetChangeProtection = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_subnet_change_protection
#'
#' @aliases networkfirewall_update_subnet_change_protection
networkfirewall_update_subnet_change_protection <- function(UpdateToken = NULL, FirewallArn = NULL, FirewallName = NULL, SubnetChangeProtection) {
  op <- new_operation(
    name = "UpdateSubnetChangeProtection",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_subnet_change_protection_input(UpdateToken = UpdateToken, FirewallArn = FirewallArn, FirewallName = FirewallName, SubnetChangeProtection = SubnetChangeProtection)
  output <- .networkfirewall$update_subnet_change_protection_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_subnet_change_protection <- networkfirewall_update_subnet_change_protection

#' Updates the TLS inspection configuration settings for the specified TLS
#' inspection configuration
#'
#' @description
#' Updates the TLS inspection configuration settings for the specified TLS
#' inspection configuration. You use a TLS inspection configuration by
#' referencing it in one or more firewall policies. When you modify a TLS
#' inspection configuration, you modify all firewall policies that use the
#' TLS inspection configuration.
#' 
#' To update a TLS inspection configuration, first call
#' [`describe_tls_inspection_configuration`][networkfirewall_describe_tls_inspection_configuration]
#' to retrieve the current TLSInspectionConfiguration object, update the
#' object as needed, and then provide the updated object to this call.
#'
#' @usage
#' networkfirewall_update_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn, TLSInspectionConfigurationName,
#'   TLSInspectionConfiguration, Description, EncryptionConfiguration,
#'   UpdateToken)
#'
#' @param TLSInspectionConfigurationArn The Amazon Resource Name (ARN) of the TLS inspection configuration.
#' @param TLSInspectionConfigurationName The descriptive name of the TLS inspection configuration. You can't
#' change the name of a TLS inspection configuration after you create it.
#' @param TLSInspectionConfiguration &#91;required&#93; The object that defines a TLS inspection configuration. This, along with
#' TLSInspectionConfigurationResponse, define the TLS inspection
#' configuration. You can retrieve all objects for a TLS inspection
#' configuration by calling
#' [`describe_tls_inspection_configuration`][networkfirewall_describe_tls_inspection_configuration].
#' 
#' Network Firewall uses a TLS inspection configuration to decrypt traffic.
#' Network Firewall re-encrypts the traffic before sending it to its
#' destination.
#' 
#' To use a TLS inspection configuration, you add it to a new Network
#' Firewall firewall policy, then you apply the firewall policy to a
#' firewall. Network Firewall acts as a proxy service to decrypt and
#' inspect the traffic traveling through your firewalls. You can reference
#' a TLS inspection configuration from more than one firewall policy, and
#' you can use a firewall policy in more than one firewall. For more
#' information about using TLS inspection configurations, see [Inspecting
#' SSL/TLS traffic with TLS inspection
#' configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/)
#' in the *Network Firewall Developer Guide*.
#' @param Description A description of the TLS inspection configuration.
#' @param EncryptionConfiguration A complex type that contains the Amazon Web Services KMS encryption
#' configuration settings for your TLS inspection configuration.
#' @param UpdateToken &#91;required&#93; A token used for optimistic locking. Network Firewall returns a token to
#' your requests that access the TLS inspection configuration. The token
#' marks the state of the TLS inspection configuration resource at the time
#' of the request.
#' 
#' To make changes to the TLS inspection configuration, you provide the
#' token in your request. Network Firewall uses the token to ensure that
#' the TLS inspection configuration hasn't changed since you last retrieved
#' it. If it has changed, the operation fails with an
#' `InvalidTokenException`. If this happens, retrieve the TLS inspection
#' configuration again to get a current copy of it with a current token.
#' Reapply your changes as needed, then try the operation again using the
#' new token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   UpdateToken = "string",
#'   TLSInspectionConfigurationResponse = list(
#'     TLSInspectionConfigurationArn = "string",
#'     TLSInspectionConfigurationName = "string",
#'     TLSInspectionConfigurationId = "string",
#'     TLSInspectionConfigurationStatus = "ACTIVE"|"DELETING"|"ERROR",
#'     Description = "string",
#'     Tags = list(
#'       list(
#'         Key = "string",
#'         Value = "string"
#'       )
#'     ),
#'     LastModifiedTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     NumberOfAssociations = 123,
#'     EncryptionConfiguration = list(
#'       KeyId = "string",
#'       Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'     ),
#'     Certificates = list(
#'       list(
#'         CertificateArn = "string",
#'         CertificateSerial = "string",
#'         Status = "string",
#'         StatusMessage = "string"
#'       )
#'     ),
#'     CertificateAuthority = list(
#'       CertificateArn = "string",
#'       CertificateSerial = "string",
#'       Status = "string",
#'       StatusMessage = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_tls_inspection_configuration(
#'   TLSInspectionConfigurationArn = "string",
#'   TLSInspectionConfigurationName = "string",
#'   TLSInspectionConfiguration = list(
#'     ServerCertificateConfigurations = list(
#'       list(
#'         ServerCertificates = list(
#'           list(
#'             ResourceArn = "string"
#'           )
#'         ),
#'         Scopes = list(
#'           list(
#'             Sources = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             Destinations = list(
#'               list(
#'                 AddressDefinition = "string"
#'               )
#'             ),
#'             SourcePorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             DestinationPorts = list(
#'               list(
#'                 FromPort = 123,
#'                 ToPort = 123
#'               )
#'             ),
#'             Protocols = list(
#'               123
#'             )
#'           )
#'         ),
#'         CertificateAuthorityArn = "string",
#'         CheckCertificateRevocationStatus = list(
#'           RevokedStatusAction = "PASS"|"DROP"|"REJECT",
#'           UnknownStatusAction = "PASS"|"DROP"|"REJECT"
#'         )
#'       )
#'     )
#'   ),
#'   Description = "string",
#'   EncryptionConfiguration = list(
#'     KeyId = "string",
#'     Type = "CUSTOMER_KMS"|"AWS_OWNED_KMS_KEY"
#'   ),
#'   UpdateToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname networkfirewall_update_tls_inspection_configuration
#'
#' @aliases networkfirewall_update_tls_inspection_configuration
networkfirewall_update_tls_inspection_configuration <- function(TLSInspectionConfigurationArn = NULL, TLSInspectionConfigurationName = NULL, TLSInspectionConfiguration, Description = NULL, EncryptionConfiguration = NULL, UpdateToken) {
  op <- new_operation(
    name = "UpdateTLSInspectionConfiguration",
    http_method = "POST",
    http_path = "/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .networkfirewall$update_tls_inspection_configuration_input(TLSInspectionConfigurationArn = TLSInspectionConfigurationArn, TLSInspectionConfigurationName = TLSInspectionConfigurationName, TLSInspectionConfiguration = TLSInspectionConfiguration, Description = Description, EncryptionConfiguration = EncryptionConfiguration, UpdateToken = UpdateToken)
  output <- .networkfirewall$update_tls_inspection_configuration_output()
  config <- get_config()
  svc <- .networkfirewall$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.networkfirewall$operations$update_tls_inspection_configuration <- networkfirewall_update_tls_inspection_configuration

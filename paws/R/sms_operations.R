# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include sms_service.R
NULL

#' Creates an application
#'
#' Creates an application. An application consists of one or more server
#' groups. Each server group contain one or more servers.
#'
#' @usage
#' sms_create_app(name, description, roleName, clientToken, serverGroups,
#'   tags)
#'
#' @param name Name of the new application.
#' @param description Description of the new application
#' @param roleName Name of service role in customer\'s account to be used by AWS SMS.
#' @param clientToken A unique, case-sensitive identifier you provide to ensure idempotency of
#' application creation.
#' @param serverGroups List of server groups to include in the application.
#' @param tags List of tags to be associated with the application.
#'
#' @section Request syntax:
#' ```
#' svc$create_app(
#'   name = "string",
#'   description = "string",
#'   roleName = "string",
#'   clientToken = "string",
#'   serverGroups = list(
#'     list(
#'       serverGroupId = "string",
#'       name = "string",
#'       serverList = list(
#'         list(
#'           serverId = "string",
#'           serverType = "VIRTUAL_MACHINE",
#'           vmServer = list(
#'             vmServerAddress = list(
#'               vmManagerId = "string",
#'               vmId = "string"
#'             ),
#'             vmName = "string",
#'             vmManagerName = "string",
#'             vmManagerType = "VSPHERE"|"SCVMM"|"HYPERV-MANAGER",
#'             vmPath = "string"
#'           ),
#'           replicationJobId = "string",
#'           replicationJobTerminated = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_create_app
sms_create_app <- function(name = NULL, description = NULL, roleName = NULL, clientToken = NULL, serverGroups = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$create_app_input(name = name, description = description, roleName = roleName, clientToken = clientToken, serverGroups = serverGroups, tags = tags)
  output <- .sms$create_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$create_app <- sms_create_app

#' Creates a replication job
#'
#' Creates a replication job. The replication job schedules periodic
#' replication runs to replicate your server to AWS. Each replication run
#' creates an Amazon Machine Image (AMI).
#'
#' @usage
#' sms_create_replication_job(serverId, seedReplicationTime, frequency,
#'   runOnce, licenseType, roleName, description, numberOfRecentAmisToKeep,
#'   encrypted, kmsKeyId)
#'
#' @param serverId &#91;required&#93; The identifier of the server.
#' @param seedReplicationTime &#91;required&#93; The seed replication time.
#' @param frequency The time between consecutive replication runs, in hours.
#' @param runOnce 
#' @param licenseType The license type to be used for the AMI created by a successful
#' replication run.
#' @param roleName The name of the IAM role to be used by the AWS SMS.
#' @param description The description of the replication job.
#' @param numberOfRecentAmisToKeep The maximum number of SMS-created AMIs to retain. The oldest will be
#' deleted once the maximum number is reached and a new AMI is created.
#' @param encrypted When *true*, the replication job produces encrypted AMIs. See also
#' `KmsKeyId` below.
#' @param kmsKeyId KMS key ID for replication jobs that produce encrypted AMIs. Can be any
#' of the following:
#' 
#' -   KMS key ID
#' 
#' -   KMS key alias
#' 
#' -   ARN referring to KMS key ID
#' 
#' -   ARN referring to KMS key alias
#' 
#' If encrypted is *true* but a KMS key id is not specified, the
#' customer\'s default KMS key for EBS is used.
#'
#' @section Request syntax:
#' ```
#' svc$create_replication_job(
#'   serverId = "string",
#'   seedReplicationTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   frequency = 123,
#'   runOnce = TRUE|FALSE,
#'   licenseType = "AWS"|"BYOL",
#'   roleName = "string",
#'   description = "string",
#'   numberOfRecentAmisToKeep = 123,
#'   encrypted = TRUE|FALSE,
#'   kmsKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_create_replication_job
sms_create_replication_job <- function(serverId, seedReplicationTime, frequency = NULL, runOnce = NULL, licenseType = NULL, roleName = NULL, description = NULL, numberOfRecentAmisToKeep = NULL, encrypted = NULL, kmsKeyId = NULL) {
  op <- new_operation(
    name = "CreateReplicationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$create_replication_job_input(serverId = serverId, seedReplicationTime = seedReplicationTime, frequency = frequency, runOnce = runOnce, licenseType = licenseType, roleName = roleName, description = description, numberOfRecentAmisToKeep = numberOfRecentAmisToKeep, encrypted = encrypted, kmsKeyId = kmsKeyId)
  output <- .sms$create_replication_job_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$create_replication_job <- sms_create_replication_job

#' Deletes an existing application
#'
#' Deletes an existing application. Optionally deletes the launched stack
#' associated with the application and all AWS SMS replication jobs for
#' servers in the application.
#'
#' @usage
#' sms_delete_app(appId, forceStopAppReplication, forceTerminateApp)
#'
#' @param appId ID of the application to delete.
#' @param forceStopAppReplication While deleting the application, stop all replication jobs corresponding
#' to the servers in the application.
#' @param forceTerminateApp While deleting the application, terminate the stack corresponding to the
#' application.
#'
#' @section Request syntax:
#' ```
#' svc$delete_app(
#'   appId = "string",
#'   forceStopAppReplication = TRUE|FALSE,
#'   forceTerminateApp = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_delete_app
sms_delete_app <- function(appId = NULL, forceStopAppReplication = NULL, forceTerminateApp = NULL) {
  op <- new_operation(
    name = "DeleteApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$delete_app_input(appId = appId, forceStopAppReplication = forceStopAppReplication, forceTerminateApp = forceTerminateApp)
  output <- .sms$delete_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$delete_app <- sms_delete_app

#' Deletes existing launch configuration for an application
#'
#' Deletes existing launch configuration for an application.
#'
#' @usage
#' sms_delete_app_launch_configuration(appId)
#'
#' @param appId ID of the application associated with the launch configuration.
#'
#' @section Request syntax:
#' ```
#' svc$delete_app_launch_configuration(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_delete_app_launch_configuration
sms_delete_app_launch_configuration <- function(appId = NULL) {
  op <- new_operation(
    name = "DeleteAppLaunchConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$delete_app_launch_configuration_input(appId = appId)
  output <- .sms$delete_app_launch_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$delete_app_launch_configuration <- sms_delete_app_launch_configuration

#' Deletes existing replication configuration for an application
#'
#' Deletes existing replication configuration for an application.
#'
#' @usage
#' sms_delete_app_replication_configuration(appId)
#'
#' @param appId ID of the application associated with the replication configuration.
#'
#' @section Request syntax:
#' ```
#' svc$delete_app_replication_configuration(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_delete_app_replication_configuration
sms_delete_app_replication_configuration <- function(appId = NULL) {
  op <- new_operation(
    name = "DeleteAppReplicationConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$delete_app_replication_configuration_input(appId = appId)
  output <- .sms$delete_app_replication_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$delete_app_replication_configuration <- sms_delete_app_replication_configuration

#' Deletes the specified replication job
#'
#' Deletes the specified replication job.
#' 
#' After you delete a replication job, there are no further replication
#' runs. AWS deletes the contents of the Amazon S3 bucket used to store AWS
#' SMS artifacts. The AMIs created by the replication runs are not deleted.
#'
#' @usage
#' sms_delete_replication_job(replicationJobId)
#'
#' @param replicationJobId &#91;required&#93; The identifier of the replication job.
#'
#' @section Request syntax:
#' ```
#' svc$delete_replication_job(
#'   replicationJobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_delete_replication_job
sms_delete_replication_job <- function(replicationJobId) {
  op <- new_operation(
    name = "DeleteReplicationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$delete_replication_job_input(replicationJobId = replicationJobId)
  output <- .sms$delete_replication_job_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$delete_replication_job <- sms_delete_replication_job

#' Deletes all servers from your server catalog
#'
#' Deletes all servers from your server catalog.
#'
#' @usage
#' sms_delete_server_catalog()
#'
#' @section Request syntax:
#' ```
#' svc$delete_server_catalog()
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_delete_server_catalog
sms_delete_server_catalog <- function() {
  op <- new_operation(
    name = "DeleteServerCatalog",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$delete_server_catalog_input()
  output <- .sms$delete_server_catalog_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$delete_server_catalog <- sms_delete_server_catalog

#' Disassociates the specified connector from AWS SMS
#'
#' Disassociates the specified connector from AWS SMS.
#' 
#' After you disassociate a connector, it is no longer available to support
#' replication jobs.
#'
#' @usage
#' sms_disassociate_connector(connectorId)
#'
#' @param connectorId &#91;required&#93; The identifier of the connector.
#'
#' @section Request syntax:
#' ```
#' svc$disassociate_connector(
#'   connectorId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_disassociate_connector
sms_disassociate_connector <- function(connectorId) {
  op <- new_operation(
    name = "DisassociateConnector",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$disassociate_connector_input(connectorId = connectorId)
  output <- .sms$disassociate_connector_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$disassociate_connector <- sms_disassociate_connector

#' Generates a target change set for a currently launched stack and writes
#' it to an Amazon S3 object in the customerâ€™s Amazon S3 bucket
#'
#' Generates a target change set for a currently launched stack and writes
#' it to an Amazon S3 object in the customer's Amazon S3 bucket.
#'
#' @usage
#' sms_generate_change_set(appId, changesetFormat)
#'
#' @param appId ID of the application associated with the change set.
#' @param changesetFormat Format for the change set.
#'
#' @section Request syntax:
#' ```
#' svc$generate_change_set(
#'   appId = "string",
#'   changesetFormat = "JSON"|"YAML"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_generate_change_set
sms_generate_change_set <- function(appId = NULL, changesetFormat = NULL) {
  op <- new_operation(
    name = "GenerateChangeSet",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$generate_change_set_input(appId = appId, changesetFormat = changesetFormat)
  output <- .sms$generate_change_set_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$generate_change_set <- sms_generate_change_set

#' Generates an Amazon CloudFormation template based on the current launch
#' configuration and writes it to an Amazon S3 object in the customerâ€™s
#' Amazon S3 bucket
#'
#' Generates an Amazon CloudFormation template based on the current launch
#' configuration and writes it to an Amazon S3 object in the customer's
#' Amazon S3 bucket.
#'
#' @usage
#' sms_generate_template(appId, templateFormat)
#'
#' @param appId ID of the application associated with the Amazon CloudFormation
#' template.
#' @param templateFormat Format for generating the Amazon CloudFormation template.
#'
#' @section Request syntax:
#' ```
#' svc$generate_template(
#'   appId = "string",
#'   templateFormat = "JSON"|"YAML"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_generate_template
sms_generate_template <- function(appId = NULL, templateFormat = NULL) {
  op <- new_operation(
    name = "GenerateTemplate",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$generate_template_input(appId = appId, templateFormat = templateFormat)
  output <- .sms$generate_template_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$generate_template <- sms_generate_template

#' Retrieve information about an application
#'
#' Retrieve information about an application.
#'
#' @usage
#' sms_get_app(appId)
#'
#' @param appId ID of the application whose information is being retrieved.
#'
#' @section Request syntax:
#' ```
#' svc$get_app(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_app
sms_get_app <- function(appId = NULL) {
  op <- new_operation(
    name = "GetApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_app_input(appId = appId)
  output <- .sms$get_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_app <- sms_get_app

#' Retrieves the application launch configuration associated with an
#' application
#'
#' Retrieves the application launch configuration associated with an
#' application.
#'
#' @usage
#' sms_get_app_launch_configuration(appId)
#'
#' @param appId ID of the application launch configuration.
#'
#' @section Request syntax:
#' ```
#' svc$get_app_launch_configuration(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_app_launch_configuration
sms_get_app_launch_configuration <- function(appId = NULL) {
  op <- new_operation(
    name = "GetAppLaunchConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_app_launch_configuration_input(appId = appId)
  output <- .sms$get_app_launch_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_app_launch_configuration <- sms_get_app_launch_configuration

#' Retrieves an application replication configuration associatd with an
#' application
#'
#' Retrieves an application replication configuration associatd with an
#' application.
#'
#' @usage
#' sms_get_app_replication_configuration(appId)
#'
#' @param appId ID of the application associated with the replication configuration.
#'
#' @section Request syntax:
#' ```
#' svc$get_app_replication_configuration(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_app_replication_configuration
sms_get_app_replication_configuration <- function(appId = NULL) {
  op <- new_operation(
    name = "GetAppReplicationConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_app_replication_configuration_input(appId = appId)
  output <- .sms$get_app_replication_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_app_replication_configuration <- sms_get_app_replication_configuration

#' Describes the connectors registered with the AWS SMS
#'
#' Describes the connectors registered with the AWS SMS.
#'
#' @usage
#' sms_get_connectors(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return in a single call. The default
#' value is 50. To retrieve the remaining results, make another call with
#' the returned `NextToken` value.
#'
#' @section Request syntax:
#' ```
#' svc$get_connectors(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_connectors
sms_get_connectors <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "GetConnectors",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_connectors_input(nextToken = nextToken, maxResults = maxResults)
  output <- .sms$get_connectors_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_connectors <- sms_get_connectors

#' Describes the specified replication job or all of your replication jobs
#'
#' Describes the specified replication job or all of your replication jobs.
#'
#' @usage
#' sms_get_replication_jobs(replicationJobId, nextToken, maxResults)
#'
#' @param replicationJobId The identifier of the replication job.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return in a single call. The default
#' value is 50. To retrieve the remaining results, make another call with
#' the returned `NextToken` value.
#'
#' @section Request syntax:
#' ```
#' svc$get_replication_jobs(
#'   replicationJobId = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_replication_jobs
sms_get_replication_jobs <- function(replicationJobId = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "GetReplicationJobs",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_replication_jobs_input(replicationJobId = replicationJobId, nextToken = nextToken, maxResults = maxResults)
  output <- .sms$get_replication_jobs_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_replication_jobs <- sms_get_replication_jobs

#' Describes the replication runs for the specified replication job
#'
#' Describes the replication runs for the specified replication job.
#'
#' @usage
#' sms_get_replication_runs(replicationJobId, nextToken, maxResults)
#'
#' @param replicationJobId &#91;required&#93; The identifier of the replication job.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return in a single call. The default
#' value is 50. To retrieve the remaining results, make another call with
#' the returned `NextToken` value.
#'
#' @section Request syntax:
#' ```
#' svc$get_replication_runs(
#'   replicationJobId = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_replication_runs
sms_get_replication_runs <- function(replicationJobId, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "GetReplicationRuns",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_replication_runs_input(replicationJobId = replicationJobId, nextToken = nextToken, maxResults = maxResults)
  output <- .sms$get_replication_runs_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_replication_runs <- sms_get_replication_runs

#' Describes the servers in your server catalog
#'
#' Describes the servers in your server catalog.
#' 
#' Before you can describe your servers, you must import them using
#' ImportServerCatalog.
#'
#' @usage
#' sms_get_servers(nextToken, maxResults, vmServerAddressList)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return in a single call. The default
#' value is 50. To retrieve the remaining results, make another call with
#' the returned `NextToken` value.
#' @param vmServerAddressList List of `VmServerAddress` objects
#'
#' @section Request syntax:
#' ```
#' svc$get_servers(
#'   nextToken = "string",
#'   maxResults = 123,
#'   vmServerAddressList = list(
#'     list(
#'       vmManagerId = "string",
#'       vmId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_get_servers
sms_get_servers <- function(nextToken = NULL, maxResults = NULL, vmServerAddressList = NULL) {
  op <- new_operation(
    name = "GetServers",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$get_servers_input(nextToken = nextToken, maxResults = maxResults, vmServerAddressList = vmServerAddressList)
  output <- .sms$get_servers_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$get_servers <- sms_get_servers

#' Gathers a complete list of on-premises servers
#'
#' Gathers a complete list of on-premises servers. Connectors must be
#' installed and monitoring all servers that you want to import.
#' 
#' This call returns immediately, but might take additional time to
#' retrieve all the servers.
#'
#' @usage
#' sms_import_server_catalog()
#'
#' @section Request syntax:
#' ```
#' svc$import_server_catalog()
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_import_server_catalog
sms_import_server_catalog <- function() {
  op <- new_operation(
    name = "ImportServerCatalog",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$import_server_catalog_input()
  output <- .sms$import_server_catalog_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$import_server_catalog <- sms_import_server_catalog

#' Launches an application stack
#'
#' Launches an application stack.
#'
#' @usage
#' sms_launch_app(appId)
#'
#' @param appId ID of the application to launch.
#'
#' @section Request syntax:
#' ```
#' svc$launch_app(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_launch_app
sms_launch_app <- function(appId = NULL) {
  op <- new_operation(
    name = "LaunchApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$launch_app_input(appId = appId)
  output <- .sms$launch_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$launch_app <- sms_launch_app

#' Returns a list of summaries for all applications
#'
#' Returns a list of summaries for all applications.
#'
#' @usage
#' sms_list_apps(appIds, nextToken, maxResults)
#'
#' @param appIds 
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return in a single call. The default
#' value is 50. To retrieve the remaining results, make another call with
#' the returned `NextToken` value.
#'
#' @section Request syntax:
#' ```
#' svc$list_apps(
#'   appIds = list(
#'     "string"
#'   ),
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_list_apps
sms_list_apps <- function(appIds = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListApps",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$list_apps_input(appIds = appIds, nextToken = nextToken, maxResults = maxResults)
  output <- .sms$list_apps_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$list_apps <- sms_list_apps

#' Creates a launch configuration for an application
#'
#' Creates a launch configuration for an application.
#'
#' @usage
#' sms_put_app_launch_configuration(appId, roleName,
#'   serverGroupLaunchConfigurations)
#'
#' @param appId ID of the application associated with the launch configuration.
#' @param roleName Name of service role in the customer\'s account that Amazon
#' CloudFormation uses to launch the application.
#' @param serverGroupLaunchConfigurations Launch configurations for server groups in the application.
#'
#' @section Request syntax:
#' ```
#' svc$put_app_launch_configuration(
#'   appId = "string",
#'   roleName = "string",
#'   serverGroupLaunchConfigurations = list(
#'     list(
#'       serverGroupId = "string",
#'       launchOrder = 123,
#'       serverLaunchConfigurations = list(
#'         list(
#'           server = list(
#'             serverId = "string",
#'             serverType = "VIRTUAL_MACHINE",
#'             vmServer = list(
#'               vmServerAddress = list(
#'                 vmManagerId = "string",
#'                 vmId = "string"
#'               ),
#'               vmName = "string",
#'               vmManagerName = "string",
#'               vmManagerType = "VSPHERE"|"SCVMM"|"HYPERV-MANAGER",
#'               vmPath = "string"
#'             ),
#'             replicationJobId = "string",
#'             replicationJobTerminated = TRUE|FALSE
#'           ),
#'           logicalId = "string",
#'           vpc = "string",
#'           subnet = "string",
#'           securityGroup = "string",
#'           ec2KeyName = "string",
#'           userData = list(
#'             s3Location = list(
#'               bucket = "string",
#'               key = "string"
#'             )
#'           ),
#'           instanceType = "string",
#'           associatePublicIpAddress = TRUE|FALSE
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_put_app_launch_configuration
sms_put_app_launch_configuration <- function(appId = NULL, roleName = NULL, serverGroupLaunchConfigurations = NULL) {
  op <- new_operation(
    name = "PutAppLaunchConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$put_app_launch_configuration_input(appId = appId, roleName = roleName, serverGroupLaunchConfigurations = serverGroupLaunchConfigurations)
  output <- .sms$put_app_launch_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$put_app_launch_configuration <- sms_put_app_launch_configuration

#' Creates or updates a replication configuration for an application
#'
#' Creates or updates a replication configuration for an application.
#'
#' @usage
#' sms_put_app_replication_configuration(appId,
#'   serverGroupReplicationConfigurations)
#'
#' @param appId ID of the application tassociated with the replication configuration.
#' @param serverGroupReplicationConfigurations Replication configurations for server groups in the application.
#'
#' @section Request syntax:
#' ```
#' svc$put_app_replication_configuration(
#'   appId = "string",
#'   serverGroupReplicationConfigurations = list(
#'     list(
#'       serverGroupId = "string",
#'       serverReplicationConfigurations = list(
#'         list(
#'           server = list(
#'             serverId = "string",
#'             serverType = "VIRTUAL_MACHINE",
#'             vmServer = list(
#'               vmServerAddress = list(
#'                 vmManagerId = "string",
#'                 vmId = "string"
#'               ),
#'               vmName = "string",
#'               vmManagerName = "string",
#'               vmManagerType = "VSPHERE"|"SCVMM"|"HYPERV-MANAGER",
#'               vmPath = "string"
#'             ),
#'             replicationJobId = "string",
#'             replicationJobTerminated = TRUE|FALSE
#'           ),
#'           serverReplicationParameters = list(
#'             seedTime = as.POSIXct(
#'               "2015-01-01"
#'             ),
#'             frequency = 123,
#'             runOnce = TRUE|FALSE,
#'             licenseType = "AWS"|"BYOL",
#'             numberOfRecentAmisToKeep = 123,
#'             encrypted = TRUE|FALSE,
#'             kmsKeyId = "string"
#'           )
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_put_app_replication_configuration
sms_put_app_replication_configuration <- function(appId = NULL, serverGroupReplicationConfigurations = NULL) {
  op <- new_operation(
    name = "PutAppReplicationConfiguration",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$put_app_replication_configuration_input(appId = appId, serverGroupReplicationConfigurations = serverGroupReplicationConfigurations)
  output <- .sms$put_app_replication_configuration_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$put_app_replication_configuration <- sms_put_app_replication_configuration

#' Starts replicating an application
#'
#' Starts replicating an application.
#'
#' @usage
#' sms_start_app_replication(appId)
#'
#' @param appId ID of the application to replicate.
#'
#' @section Request syntax:
#' ```
#' svc$start_app_replication(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_start_app_replication
sms_start_app_replication <- function(appId = NULL) {
  op <- new_operation(
    name = "StartAppReplication",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$start_app_replication_input(appId = appId)
  output <- .sms$start_app_replication_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$start_app_replication <- sms_start_app_replication

#' Starts an on-demand replication run for the specified replication job
#'
#' Starts an on-demand replication run for the specified replication job.
#' This replication run starts immediately. This replication run is in
#' addition to the ones already scheduled.
#' 
#' There is a limit on the number of on-demand replications runs you can
#' request in a 24-hour period.
#'
#' @usage
#' sms_start_on_demand_replication_run(replicationJobId, description)
#'
#' @param replicationJobId &#91;required&#93; The identifier of the replication job.
#' @param description The description of the replication run.
#'
#' @section Request syntax:
#' ```
#' svc$start_on_demand_replication_run(
#'   replicationJobId = "string",
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_start_on_demand_replication_run
sms_start_on_demand_replication_run <- function(replicationJobId, description = NULL) {
  op <- new_operation(
    name = "StartOnDemandReplicationRun",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$start_on_demand_replication_run_input(replicationJobId = replicationJobId, description = description)
  output <- .sms$start_on_demand_replication_run_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$start_on_demand_replication_run <- sms_start_on_demand_replication_run

#' Stops replicating an application
#'
#' Stops replicating an application.
#'
#' @usage
#' sms_stop_app_replication(appId)
#'
#' @param appId ID of the application to stop replicating.
#'
#' @section Request syntax:
#' ```
#' svc$stop_app_replication(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_stop_app_replication
sms_stop_app_replication <- function(appId = NULL) {
  op <- new_operation(
    name = "StopAppReplication",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$stop_app_replication_input(appId = appId)
  output <- .sms$stop_app_replication_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$stop_app_replication <- sms_stop_app_replication

#' Terminates the stack for an application
#'
#' Terminates the stack for an application.
#'
#' @usage
#' sms_terminate_app(appId)
#'
#' @param appId ID of the application to terminate.
#'
#' @section Request syntax:
#' ```
#' svc$terminate_app(
#'   appId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_terminate_app
sms_terminate_app <- function(appId = NULL) {
  op <- new_operation(
    name = "TerminateApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$terminate_app_input(appId = appId)
  output <- .sms$terminate_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$terminate_app <- sms_terminate_app

#' Updates an application
#'
#' Updates an application.
#'
#' @usage
#' sms_update_app(appId, name, description, roleName, serverGroups, tags)
#'
#' @param appId ID of the application to update.
#' @param name New name of the application.
#' @param description New description of the application.
#' @param roleName Name of the service role in the customer\'s account used by AWS SMS.
#' @param serverGroups List of server groups in the application to update.
#' @param tags List of tags to associate with the application.
#'
#' @section Request syntax:
#' ```
#' svc$update_app(
#'   appId = "string",
#'   name = "string",
#'   description = "string",
#'   roleName = "string",
#'   serverGroups = list(
#'     list(
#'       serverGroupId = "string",
#'       name = "string",
#'       serverList = list(
#'         list(
#'           serverId = "string",
#'           serverType = "VIRTUAL_MACHINE",
#'           vmServer = list(
#'             vmServerAddress = list(
#'               vmManagerId = "string",
#'               vmId = "string"
#'             ),
#'             vmName = "string",
#'             vmManagerName = "string",
#'             vmManagerType = "VSPHERE"|"SCVMM"|"HYPERV-MANAGER",
#'             vmPath = "string"
#'           ),
#'           replicationJobId = "string",
#'           replicationJobTerminated = TRUE|FALSE
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       key = "string",
#'       value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_update_app
sms_update_app <- function(appId = NULL, name = NULL, description = NULL, roleName = NULL, serverGroups = NULL, tags = NULL) {
  op <- new_operation(
    name = "UpdateApp",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$update_app_input(appId = appId, name = name, description = description, roleName = roleName, serverGroups = serverGroups, tags = tags)
  output <- .sms$update_app_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$update_app <- sms_update_app

#' Updates the specified settings for the specified replication job
#'
#' Updates the specified settings for the specified replication job.
#'
#' @usage
#' sms_update_replication_job(replicationJobId, frequency,
#'   nextReplicationRunStartTime, licenseType, roleName, description,
#'   numberOfRecentAmisToKeep, encrypted, kmsKeyId)
#'
#' @param replicationJobId &#91;required&#93; The identifier of the replication job.
#' @param frequency The time between consecutive replication runs, in hours.
#' @param nextReplicationRunStartTime The start time of the next replication run.
#' @param licenseType The license type to be used for the AMI created by a successful
#' replication run.
#' @param roleName The name of the IAM role to be used by AWS SMS.
#' @param description The description of the replication job.
#' @param numberOfRecentAmisToKeep The maximum number of SMS-created AMIs to retain. The oldest will be
#' deleted once the maximum number is reached and a new AMI is created.
#' @param encrypted When true, the replication job produces encrypted AMIs . See also
#' `KmsKeyId` below.
#' @param kmsKeyId KMS key ID for replication jobs that produce encrypted AMIs. Can be any
#' of the following:
#' 
#' -   KMS key ID
#' 
#' -   KMS key alias
#' 
#' -   ARN referring to KMS key ID
#' 
#' -   ARN referring to KMS key alias
#' 
#' If encrypted is *true* but a KMS key id is not specified, the
#' customer\'s default KMS key for EBS is used.
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_job(
#'   replicationJobId = "string",
#'   frequency = 123,
#'   nextReplicationRunStartTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   licenseType = "AWS"|"BYOL",
#'   roleName = "string",
#'   description = "string",
#'   numberOfRecentAmisToKeep = 123,
#'   encrypted = TRUE|FALSE,
#'   kmsKeyId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname sms_update_replication_job
sms_update_replication_job <- function(replicationJobId, frequency = NULL, nextReplicationRunStartTime = NULL, licenseType = NULL, roleName = NULL, description = NULL, numberOfRecentAmisToKeep = NULL, encrypted = NULL, kmsKeyId = NULL) {
  op <- new_operation(
    name = "UpdateReplicationJob",
    http_method = "POST",
    http_path = "/",
    paginator = list()
  )
  input <- .sms$update_replication_job_input(replicationJobId = replicationJobId, frequency = frequency, nextReplicationRunStartTime = nextReplicationRunStartTime, licenseType = licenseType, roleName = roleName, description = description, numberOfRecentAmisToKeep = numberOfRecentAmisToKeep, encrypted = encrypted, kmsKeyId = kmsKeyId)
  output <- .sms$update_replication_job_output()
  config <- get_config()
  svc <- .sms$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.sms$operations$update_replication_job <- sms_update_replication_job

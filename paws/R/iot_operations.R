# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include iot_service.R
NULL

#' Accepts a pending certificate transfer
#'
#' @description
#' Accepts a pending certificate transfer. The default state of the
#' certificate is INACTIVE.
#' 
#' To check for pending certificate transfers, call
#' [`list_certificates`][iot_list_certificates] to enumerate your
#' certificates.
#'
#' @usage
#' iot_accept_certificate_transfer(certificateId, setAsActive)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$accept_certificate_transfer(
#'   certificateId = "string",
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_accept_certificate_transfer
iot_accept_certificate_transfer <- function(certificateId, setAsActive = NULL) {
  op <- new_operation(
    name = "AcceptCertificateTransfer",
    http_method = "PATCH",
    http_path = "/accept-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$accept_certificate_transfer_input(certificateId = certificateId, setAsActive = setAsActive)
  output <- .iot$accept_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$accept_certificate_transfer <- iot_accept_certificate_transfer

#' Adds a thing to a billing group
#'
#' @description
#' Adds a thing to a billing group.
#'
#' @usage
#' iot_add_thing_to_billing_group(billingGroupName, billingGroupArn,
#'   thingName, thingArn)
#'
#' @param billingGroupName The name of the billing group.
#' @param billingGroupArn The ARN of the billing group.
#' @param thingName The name of the thing to be added to the billing group.
#' @param thingArn The ARN of the thing to be added to the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$add_thing_to_billing_group(
#'   billingGroupName = "string",
#'   billingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_add_thing_to_billing_group
iot_add_thing_to_billing_group <- function(billingGroupName = NULL, billingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "AddThingToBillingGroup",
    http_method = "PUT",
    http_path = "/billing-groups/addThingToBillingGroup",
    paginator = list()
  )
  input <- .iot$add_thing_to_billing_group_input(billingGroupName = billingGroupName, billingGroupArn = billingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$add_thing_to_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$add_thing_to_billing_group <- iot_add_thing_to_billing_group

#' Adds a thing to a thing group
#'
#' @description
#' Adds a thing to a thing group.
#'
#' @usage
#' iot_add_thing_to_thing_group(thingGroupName, thingGroupArn, thingName,
#'   thingArn, overrideDynamicGroups)
#'
#' @param thingGroupName The name of the group to which you are adding a thing.
#' @param thingGroupArn The ARN of the group to which you are adding a thing.
#' @param thingName The name of the thing to add to a group.
#' @param thingArn The ARN of the thing to add to a group.
#' @param overrideDynamicGroups Override dynamic thing groups with static thing groups when 10-group
#' limit is reached. If a thing belongs to 10 thing groups, and one or more
#' of those groups are dynamic thing groups, adding a thing to a static
#' group removes the thing from the last dynamic group.
#'
#' @section Request syntax:
#' ```
#' svc$add_thing_to_thing_group(
#'   thingGroupName = "string",
#'   thingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string",
#'   overrideDynamicGroups = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_add_thing_to_thing_group
iot_add_thing_to_thing_group <- function(thingGroupName = NULL, thingGroupArn = NULL, thingName = NULL, thingArn = NULL, overrideDynamicGroups = NULL) {
  op <- new_operation(
    name = "AddThingToThingGroup",
    http_method = "PUT",
    http_path = "/thing-groups/addThingToThingGroup",
    paginator = list()
  )
  input <- .iot$add_thing_to_thing_group_input(thingGroupName = thingGroupName, thingGroupArn = thingGroupArn, thingName = thingName, thingArn = thingArn, overrideDynamicGroups = overrideDynamicGroups)
  output <- .iot$add_thing_to_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$add_thing_to_thing_group <- iot_add_thing_to_thing_group

#' Associates a group with a continuous job
#'
#' @description
#' Associates a group with a continuous job. The following criteria must be
#' met:
#' 
#' -   The job must have been created with the `targetSelection` field set
#'     to "CONTINUOUS".
#' 
#' -   The job status must currently be "IN\\_PROGRESS".
#' 
#' -   The total number of targets associated with a job must not
#'     exceed 100.
#'
#' @usage
#' iot_associate_targets_with_job(targets, jobId, comment, namespaceId)
#'
#' @param targets &#91;required&#93; A list of thing group ARNs that define the targets of the job.
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param comment An optional comment string describing why the job was associated with
#' the targets.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$associate_targets_with_job(
#'   targets = list(
#'     "string"
#'   ),
#'   jobId = "string",
#'   comment = "string",
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_associate_targets_with_job
iot_associate_targets_with_job <- function(targets, jobId, comment = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "AssociateTargetsWithJob",
    http_method = "POST",
    http_path = "/jobs/{jobId}/targets",
    paginator = list()
  )
  input <- .iot$associate_targets_with_job_input(targets = targets, jobId = jobId, comment = comment, namespaceId = namespaceId)
  output <- .iot$associate_targets_with_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$associate_targets_with_job <- iot_associate_targets_with_job

#' Attaches a policy to the specified target
#'
#' @description
#' Attaches a policy to the specified target.
#'
#' @usage
#' iot_attach_policy(policyName, target)
#'
#' @param policyName &#91;required&#93; The name of the policy to attach.
#' @param target &#91;required&#93; The
#' [identity](https://docs.aws.amazon.com/iot/latest/developerguide/security-iam.html)
#' to which the policy is attached.
#'
#' @section Request syntax:
#' ```
#' svc$attach_policy(
#'   policyName = "string",
#'   target = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_policy
iot_attach_policy <- function(policyName, target) {
  op <- new_operation(
    name = "AttachPolicy",
    http_method = "PUT",
    http_path = "/target-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$attach_policy_input(policyName = policyName, target = target)
  output <- .iot$attach_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_policy <- iot_attach_policy

#' Attaches the specified policy to the specified principal (certificate or
#' other credential)
#'
#' @description
#' Attaches the specified policy to the specified principal (certificate or
#' other credential).
#' 
#' **Note:** This API is deprecated. Please use
#' [`attach_policy`][iot_attach_policy] instead.
#'
#' @usage
#' iot_attach_principal_policy(policyName, principal)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param principal &#91;required&#93; The principal, which can be a certificate ARN (as returned from the
#' CreateCertificate operation) or an Amazon Cognito ID.
#'
#' @section Request syntax:
#' ```
#' svc$attach_principal_policy(
#'   policyName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_principal_policy
iot_attach_principal_policy <- function(policyName, principal) {
  op <- new_operation(
    name = "AttachPrincipalPolicy",
    http_method = "PUT",
    http_path = "/principal-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$attach_principal_policy_input(policyName = policyName, principal = principal)
  output <- .iot$attach_principal_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_principal_policy <- iot_attach_principal_policy

#' Associates a Device Defender security profile with a thing group or this
#' account
#'
#' @description
#' Associates a Device Defender security profile with a thing group or this
#' account. Each thing group or account can have up to five security
#' profiles associated with it.
#'
#' @usage
#' iot_attach_security_profile(securityProfileName,
#'   securityProfileTargetArn)
#'
#' @param securityProfileName &#91;required&#93; The security profile that is attached.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the target (thing group) to which the security profile is
#' attached.
#'
#' @section Request syntax:
#' ```
#' svc$attach_security_profile(
#'   securityProfileName = "string",
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_security_profile
iot_attach_security_profile <- function(securityProfileName, securityProfileTargetArn) {
  op <- new_operation(
    name = "AttachSecurityProfile",
    http_method = "PUT",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$attach_security_profile_input(securityProfileName = securityProfileName, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$attach_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_security_profile <- iot_attach_security_profile

#' Attaches the specified principal to the specified thing
#'
#' @description
#' Attaches the specified principal to the specified thing. A principal can
#' be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_attach_thing_principal(thingName, principal)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#' @param principal &#91;required&#93; The principal, which can be a certificate ARN (as returned from the
#' CreateCertificate operation) or an Amazon Cognito ID.
#'
#' @section Request syntax:
#' ```
#' svc$attach_thing_principal(
#'   thingName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_attach_thing_principal
iot_attach_thing_principal <- function(thingName, principal) {
  op <- new_operation(
    name = "AttachThingPrincipal",
    http_method = "PUT",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$attach_thing_principal_input(thingName = thingName, principal = principal)
  output <- .iot$attach_thing_principal_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$attach_thing_principal <- iot_attach_thing_principal

#' Cancels a mitigation action task that is in progress
#'
#' @description
#' Cancels a mitigation action task that is in progress. If the task is not
#' in progress, an InvalidRequestException occurs.
#'
#' @usage
#' iot_cancel_audit_mitigation_actions_task(taskId)
#'
#' @param taskId &#91;required&#93; The unique identifier for the task that you want to cancel.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_audit_mitigation_actions_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_audit_mitigation_actions_task
iot_cancel_audit_mitigation_actions_task <- function(taskId) {
  op <- new_operation(
    name = "CancelAuditMitigationActionsTask",
    http_method = "PUT",
    http_path = "/audit/mitigationactions/tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_audit_mitigation_actions_task_input(taskId = taskId)
  output <- .iot$cancel_audit_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_audit_mitigation_actions_task <- iot_cancel_audit_mitigation_actions_task

#' Cancels an audit that is in progress
#'
#' @description
#' Cancels an audit that is in progress. The audit can be either scheduled
#' or on demand. If the audit isn't in progress, an
#' "InvalidRequestException" occurs.
#'
#' @usage
#' iot_cancel_audit_task(taskId)
#'
#' @param taskId &#91;required&#93; The ID of the audit you want to cancel. You can only cancel an audit
#' that is "IN\\_PROGRESS".
#'
#' @section Request syntax:
#' ```
#' svc$cancel_audit_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_audit_task
iot_cancel_audit_task <- function(taskId) {
  op <- new_operation(
    name = "CancelAuditTask",
    http_method = "PUT",
    http_path = "/audit/tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_audit_task_input(taskId = taskId)
  output <- .iot$cancel_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_audit_task <- iot_cancel_audit_task

#' Cancels a pending transfer for the specified certificate
#'
#' @description
#' Cancels a pending transfer for the specified certificate.
#' 
#' **Note** Only the transfer source account can use this operation to
#' cancel a transfer. (Transfer destinations can use
#' [`reject_certificate_transfer`][iot_reject_certificate_transfer]
#' instead.) After transfer, AWS IoT returns the certificate to the source
#' account in the INACTIVE state. After the destination account has
#' accepted the transfer, the transfer cannot be cancelled.
#' 
#' After a certificate transfer is cancelled, the status of the certificate
#' changes from PENDING\\_TRANSFER to INACTIVE.
#'
#' @usage
#' iot_cancel_certificate_transfer(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$cancel_certificate_transfer(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_certificate_transfer
iot_cancel_certificate_transfer <- function(certificateId) {
  op <- new_operation(
    name = "CancelCertificateTransfer",
    http_method = "PATCH",
    http_path = "/cancel-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$cancel_certificate_transfer_input(certificateId = certificateId)
  output <- .iot$cancel_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_certificate_transfer <- iot_cancel_certificate_transfer

#' Cancels a Device Defender ML Detect mitigation action
#'
#' @description
#' Cancels a Device Defender ML Detect mitigation action.
#'
#' @usage
#' iot_cancel_detect_mitigation_actions_task(taskId)
#'
#' @param taskId &#91;required&#93; The unique identifier of the task.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_detect_mitigation_actions_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_detect_mitigation_actions_task
iot_cancel_detect_mitigation_actions_task <- function(taskId) {
  op <- new_operation(
    name = "CancelDetectMitigationActionsTask",
    http_method = "PUT",
    http_path = "/detect/mitigationactions/tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_detect_mitigation_actions_task_input(taskId = taskId)
  output <- .iot$cancel_detect_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_detect_mitigation_actions_task <- iot_cancel_detect_mitigation_actions_task

#' Cancels a job
#'
#' @description
#' Cancels a job.
#'
#' @usage
#' iot_cancel_job(jobId, reasonCode, comment, force)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param reasonCode (Optional)A reason code string that explains why the job was canceled.
#' @param comment An optional comment string describing why the job was canceled.
#' @param force (Optional) If `true` job executions with status "IN\\_PROGRESS" and
#' "QUEUED" are canceled, otherwise only job executions with status
#' "QUEUED" are canceled. The default is `false`.
#' 
#' Canceling a job which is "IN\\_PROGRESS", will cause a device which is
#' executing the job to be unable to update the job execution status. Use
#' caution and ensure that each device executing a job which is canceled is
#' able to recover to a valid state.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job(
#'   jobId = "string",
#'   reasonCode = "string",
#'   comment = "string",
#'   force = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_job
iot_cancel_job <- function(jobId, reasonCode = NULL, comment = NULL, force = NULL) {
  op <- new_operation(
    name = "CancelJob",
    http_method = "PUT",
    http_path = "/jobs/{jobId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_job_input(jobId = jobId, reasonCode = reasonCode, comment = comment, force = force)
  output <- .iot$cancel_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_job <- iot_cancel_job

#' Cancels the execution of a job for a given thing
#'
#' @description
#' Cancels the execution of a job for a given thing.
#'
#' @usage
#' iot_cancel_job_execution(jobId, thingName, force, expectedVersion,
#'   statusDetails)
#'
#' @param jobId &#91;required&#93; The ID of the job to be canceled.
#' @param thingName &#91;required&#93; The name of the thing whose execution of the job will be canceled.
#' @param force (Optional) If `true` the job execution will be canceled if it has status
#' IN\\_PROGRESS or QUEUED, otherwise the job execution will be canceled
#' only if it has status QUEUED. If you attempt to cancel a job execution
#' that is IN\\_PROGRESS, and you do not set `force` to `true`, then an
#' `InvalidStateTransitionException` will be thrown. The default is
#' `false`.
#' 
#' Canceling a job execution which is "IN\\_PROGRESS", will cause the device
#' to be unable to update the job execution status. Use caution and ensure
#' that the device is able to recover to a valid state.
#' @param expectedVersion (Optional) The expected current version of the job execution. Each time
#' you update the job execution, its version is incremented. If the version
#' of the job execution stored in Jobs does not match, the update is
#' rejected with a VersionMismatch error, and an ErrorResponse that
#' contains the current job execution status data is returned. (This makes
#' it unnecessary to perform a separate DescribeJobExecution request in
#' order to obtain the job execution status data.)
#' @param statusDetails A collection of name/value pairs that describe the status of the job
#' execution. If not specified, the statusDetails are unchanged. You can
#' specify at most 10 name/value pairs.
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   force = TRUE|FALSE,
#'   expectedVersion = 123,
#'   statusDetails = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_cancel_job_execution
iot_cancel_job_execution <- function(jobId, thingName, force = NULL, expectedVersion = NULL, statusDetails = NULL) {
  op <- new_operation(
    name = "CancelJobExecution",
    http_method = "PUT",
    http_path = "/things/{thingName}/jobs/{jobId}/cancel",
    paginator = list()
  )
  input <- .iot$cancel_job_execution_input(jobId = jobId, thingName = thingName, force = force, expectedVersion = expectedVersion, statusDetails = statusDetails)
  output <- .iot$cancel_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$cancel_job_execution <- iot_cancel_job_execution

#' Clears the default authorizer
#'
#' @description
#' Clears the default authorizer.
#'
#' @usage
#' iot_clear_default_authorizer()
#'
#' @section Request syntax:
#' ```
#' svc$clear_default_authorizer()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_clear_default_authorizer
iot_clear_default_authorizer <- function() {
  op <- new_operation(
    name = "ClearDefaultAuthorizer",
    http_method = "DELETE",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$clear_default_authorizer_input()
  output <- .iot$clear_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$clear_default_authorizer <- iot_clear_default_authorizer

#' Confirms a topic rule destination
#'
#' @description
#' Confirms a topic rule destination. When you create a rule requiring a
#' destination, AWS IoT sends a confirmation message to the endpoint or
#' base address you specify. The message includes a token which you pass
#' back when calling
#' [`confirm_topic_rule_destination`][iot_confirm_topic_rule_destination]
#' to confirm that you own or have access to the endpoint.
#'
#' @usage
#' iot_confirm_topic_rule_destination(confirmationToken)
#'
#' @param confirmationToken &#91;required&#93; The token used to confirm ownership or access to the topic rule
#' confirmation URL.
#'
#' @section Request syntax:
#' ```
#' svc$confirm_topic_rule_destination(
#'   confirmationToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_confirm_topic_rule_destination
iot_confirm_topic_rule_destination <- function(confirmationToken) {
  op <- new_operation(
    name = "ConfirmTopicRuleDestination",
    http_method = "GET",
    http_path = "/confirmdestination/{confirmationToken+}",
    paginator = list()
  )
  input <- .iot$confirm_topic_rule_destination_input(confirmationToken = confirmationToken)
  output <- .iot$confirm_topic_rule_destination_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$confirm_topic_rule_destination <- iot_confirm_topic_rule_destination

#' Creates a Device Defender audit suppression
#'
#' @description
#' Creates a Device Defender audit suppression.
#'
#' @usage
#' iot_create_audit_suppression(checkName, resourceIdentifier,
#'   expirationDate, suppressIndefinitely, description, clientRequestToken)
#'
#' @param checkName &#91;required&#93; 
#' @param resourceIdentifier &#91;required&#93; 
#' @param expirationDate The epoch timestamp in seconds at which this suppression expires.
#' @param suppressIndefinitely Indicates whether a suppression should exist indefinitely or not.
#' @param description The description of the audit suppression.
#' @param clientRequestToken &#91;required&#93; The epoch timestamp in seconds at which this suppression expires.
#'
#' @section Request syntax:
#' ```
#' svc$create_audit_suppression(
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   ),
#'   expirationDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   suppressIndefinitely = TRUE|FALSE,
#'   description = "string",
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_audit_suppression
iot_create_audit_suppression <- function(checkName, resourceIdentifier, expirationDate = NULL, suppressIndefinitely = NULL, description = NULL, clientRequestToken) {
  op <- new_operation(
    name = "CreateAuditSuppression",
    http_method = "POST",
    http_path = "/audit/suppressions/create",
    paginator = list()
  )
  input <- .iot$create_audit_suppression_input(checkName = checkName, resourceIdentifier = resourceIdentifier, expirationDate = expirationDate, suppressIndefinitely = suppressIndefinitely, description = description, clientRequestToken = clientRequestToken)
  output <- .iot$create_audit_suppression_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_audit_suppression <- iot_create_audit_suppression

#' Creates an authorizer
#'
#' @description
#' Creates an authorizer.
#'
#' @usage
#' iot_create_authorizer(authorizerName, authorizerFunctionArn,
#'   tokenKeyName, tokenSigningPublicKeys, status, tags, signingDisabled)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#' @param authorizerFunctionArn &#91;required&#93; The ARN of the authorizer's Lambda function.
#' @param tokenKeyName The name of the token key used to extract the token from the HTTP
#' headers.
#' @param tokenSigningPublicKeys The public keys used to verify the digital signature returned by your
#' custom authentication service.
#' @param status The status of the create authorizer request.
#' @param tags Metadata which can be used to manage the custom authorizer.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#' @param signingDisabled Specifies whether AWS IoT validates the token signature in an
#' authorization request.
#'
#' @section Request syntax:
#' ```
#' svc$create_authorizer(
#'   authorizerName = "string",
#'   authorizerFunctionArn = "string",
#'   tokenKeyName = "string",
#'   tokenSigningPublicKeys = list(
#'     "string"
#'   ),
#'   status = "ACTIVE"|"INACTIVE",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   signingDisabled = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_authorizer
iot_create_authorizer <- function(authorizerName, authorizerFunctionArn, tokenKeyName = NULL, tokenSigningPublicKeys = NULL, status = NULL, tags = NULL, signingDisabled = NULL) {
  op <- new_operation(
    name = "CreateAuthorizer",
    http_method = "POST",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$create_authorizer_input(authorizerName = authorizerName, authorizerFunctionArn = authorizerFunctionArn, tokenKeyName = tokenKeyName, tokenSigningPublicKeys = tokenSigningPublicKeys, status = status, tags = tags, signingDisabled = signingDisabled)
  output <- .iot$create_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_authorizer <- iot_create_authorizer

#' Creates a billing group
#'
#' @description
#' Creates a billing group.
#'
#' @usage
#' iot_create_billing_group(billingGroupName, billingGroupProperties, tags)
#'
#' @param billingGroupName &#91;required&#93; The name you wish to give to the billing group.
#' @param billingGroupProperties The properties of the billing group.
#' @param tags Metadata which can be used to manage the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_billing_group(
#'   billingGroupName = "string",
#'   billingGroupProperties = list(
#'     billingGroupDescription = "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_billing_group
iot_create_billing_group <- function(billingGroupName, billingGroupProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateBillingGroup",
    http_method = "POST",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$create_billing_group_input(billingGroupName = billingGroupName, billingGroupProperties = billingGroupProperties, tags = tags)
  output <- .iot$create_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_billing_group <- iot_create_billing_group

#' Creates an X
#'
#' @description
#' Creates an X.509 certificate using the specified certificate signing
#' request.
#' 
#' **Note:** The CSR must include a public key that is either an RSA key
#' with a length of at least 2048 bits or an ECC key from NIST P-256 or
#' NIST P-384 curves.
#' 
#' **Note:** Reusing the same certificate signing request (CSR) results in
#' a distinct certificate.
#' 
#' You can create multiple certificates in a batch by creating a directory,
#' copying multiple .csr files into that directory, and then specifying
#' that directory on the command line. The following commands show how to
#' create a batch of certificates given a batch of CSRs.
#' 
#' Assuming a set of CSRs are located inside of the directory
#' my-csr-directory:
#' 
#' On Linux and OS X, the command is:
#' 
#' $ ls my-csr-directory/ | xargs -I \{\} aws iot create-certificate-from-csr
#' --certificate-signing-request file://my-csr-directory/\{\}
#' 
#' This command lists all of the CSRs in my-csr-directory and pipes each
#' CSR file name to the aws iot create-certificate-from-csr AWS CLI command
#' to create a certificate for the corresponding CSR.
#' 
#' The aws iot create-certificate-from-csr part of the command can also be
#' run in parallel to speed up the certificate creation process:
#' 
#' $ ls my-csr-directory/ | xargs -P 10 -I \{\} aws iot
#' create-certificate-from-csr --certificate-signing-request
#' file://my-csr-directory/\{\}
#' 
#' On Windows PowerShell, the command to create certificates for all CSRs
#' in my-csr-directory is:
#' 
#' &gt; ls -Name my-csr-directory | %\{aws iot create-certificate-from-csr
#' --certificate-signing-request file://my-csr-directory/$\\_\}
#' 
#' On a Windows command prompt, the command to create certificates for all
#' CSRs in my-csr-directory is:
#' 
#' &gt; forfiles /p my-csr-directory /c "cmd /c aws iot
#' create-certificate-from-csr --certificate-signing-request file://@@path"
#'
#' @usage
#' iot_create_certificate_from_csr(certificateSigningRequest, setAsActive)
#'
#' @param certificateSigningRequest &#91;required&#93; The certificate signing request (CSR).
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$create_certificate_from_csr(
#'   certificateSigningRequest = "string",
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_certificate_from_csr
iot_create_certificate_from_csr <- function(certificateSigningRequest, setAsActive = NULL) {
  op <- new_operation(
    name = "CreateCertificateFromCsr",
    http_method = "POST",
    http_path = "/certificates",
    paginator = list()
  )
  input <- .iot$create_certificate_from_csr_input(certificateSigningRequest = certificateSigningRequest, setAsActive = setAsActive)
  output <- .iot$create_certificate_from_csr_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_certificate_from_csr <- iot_create_certificate_from_csr

#' Use this API to define a Custom Metric published by your devices to
#' Device Defender
#'
#' @description
#' Use this API to define a Custom Metric published by your devices to
#' Device Defender.
#'
#' @usage
#' iot_create_custom_metric(metricName, displayName, metricType, tags,
#'   clientRequestToken)
#'
#' @param metricName &#91;required&#93; The name of the custom metric. This will be used in the metric report
#' submitted from the device/thing. Shouldn't begin with `aws:`. Cannot be
#' updated once defined.
#' @param displayName Field represents a friendly name in the console for the custom metric;
#' it doesn't have to be unique. Don't use this name as the metric
#' identifier in the device metric report. Can be updated once defined.
#' @param metricType &#91;required&#93; The type of the custom metric. Types include `string-list`,
#' `ip-address-list`, `number-list`, and `number`.
#' @param tags Metadata that can be used to manage the custom metric.
#' @param clientRequestToken &#91;required&#93; Each custom metric must have a unique client request token. If you try
#' to create a new custom metric that already exists with a different
#' token, an exception occurs. If you omit this value, AWS SDKs will
#' automatically generate a unique client request.
#'
#' @section Request syntax:
#' ```
#' svc$create_custom_metric(
#'   metricName = "string",
#'   displayName = "string",
#'   metricType = "string-list"|"ip-address-list"|"number-list"|"number",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_custom_metric
iot_create_custom_metric <- function(metricName, displayName = NULL, metricType, tags = NULL, clientRequestToken) {
  op <- new_operation(
    name = "CreateCustomMetric",
    http_method = "POST",
    http_path = "/custom-metric/{metricName}",
    paginator = list()
  )
  input <- .iot$create_custom_metric_input(metricName = metricName, displayName = displayName, metricType = metricType, tags = tags, clientRequestToken = clientRequestToken)
  output <- .iot$create_custom_metric_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_custom_metric <- iot_create_custom_metric

#' Create a dimension that you can use to limit the scope of a metric used
#' in a security profile for AWS IoT Device Defender
#'
#' @description
#' Create a dimension that you can use to limit the scope of a metric used
#' in a security profile for AWS IoT Device Defender. For example, using a
#' `TOPIC_FILTER` dimension, you can narrow down the scope of the metric
#' only to MQTT topics whose name match the pattern specified in the
#' dimension.
#'
#' @usage
#' iot_create_dimension(name, type, stringValues, tags, clientRequestToken)
#'
#' @param name &#91;required&#93; A unique identifier for the dimension. Choose something that describes
#' the type and value to make it easy to remember what it does.
#' @param type &#91;required&#93; Specifies the type of dimension. Supported types: `TOPIC_FILTER.`
#' @param stringValues &#91;required&#93; Specifies the value or list of values for the dimension. For
#' `TOPIC_FILTER` dimensions, this is a pattern used to match the MQTT
#' topic (for example, "admin/\\#").
#' @param tags Metadata that can be used to manage the dimension.
#' @param clientRequestToken &#91;required&#93; Each dimension must have a unique client request token. If you try to
#' create a new dimension with the same token as a dimension that already
#' exists, an exception occurs. If you omit this value, AWS SDKs will
#' automatically generate a unique client request.
#'
#' @section Request syntax:
#' ```
#' svc$create_dimension(
#'   name = "string",
#'   type = "TOPIC_FILTER",
#'   stringValues = list(
#'     "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_dimension
iot_create_dimension <- function(name, type, stringValues, tags = NULL, clientRequestToken) {
  op <- new_operation(
    name = "CreateDimension",
    http_method = "POST",
    http_path = "/dimensions/{name}",
    paginator = list()
  )
  input <- .iot$create_dimension_input(name = name, type = type, stringValues = stringValues, tags = tags, clientRequestToken = clientRequestToken)
  output <- .iot$create_dimension_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_dimension <- iot_create_dimension

#' Creates a domain configuration
#'
#' @description
#' Creates a domain configuration.
#' 
#' The domain configuration feature is in public preview and is subject to
#' change.
#'
#' @usage
#' iot_create_domain_configuration(domainConfigurationName, domainName,
#'   serverCertificateArns, validationCertificateArn, authorizerConfig,
#'   serviceType, tags)
#'
#' @param domainConfigurationName &#91;required&#93; The name of the domain configuration. This value must be unique to a
#' region.
#' @param domainName The name of the domain.
#' @param serverCertificateArns The ARNs of the certificates that AWS IoT passes to the device during
#' the TLS handshake. Currently you can specify only one certificate ARN.
#' This value is not required for AWS-managed domains.
#' @param validationCertificateArn The certificate used to validate the server certificate and prove domain
#' name ownership. This certificate must be signed by a public certificate
#' authority. This value is not required for AWS-managed domains.
#' @param authorizerConfig An object that specifies the authorization service for a domain.
#' @param serviceType The type of service delivered by the endpoint.
#' 
#' AWS IoT Core currently supports only the `DATA` service type.
#' @param tags Metadata which can be used to manage the domain configuration.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$create_domain_configuration(
#'   domainConfigurationName = "string",
#'   domainName = "string",
#'   serverCertificateArns = list(
#'     "string"
#'   ),
#'   validationCertificateArn = "string",
#'   authorizerConfig = list(
#'     defaultAuthorizerName = "string",
#'     allowAuthorizerOverride = TRUE|FALSE
#'   ),
#'   serviceType = "DATA"|"CREDENTIAL_PROVIDER"|"JOBS",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_domain_configuration
iot_create_domain_configuration <- function(domainConfigurationName, domainName = NULL, serverCertificateArns = NULL, validationCertificateArn = NULL, authorizerConfig = NULL, serviceType = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateDomainConfiguration",
    http_method = "POST",
    http_path = "/domainConfigurations/{domainConfigurationName}",
    paginator = list()
  )
  input <- .iot$create_domain_configuration_input(domainConfigurationName = domainConfigurationName, domainName = domainName, serverCertificateArns = serverCertificateArns, validationCertificateArn = validationCertificateArn, authorizerConfig = authorizerConfig, serviceType = serviceType, tags = tags)
  output <- .iot$create_domain_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_domain_configuration <- iot_create_domain_configuration

#' Creates a dynamic thing group
#'
#' @description
#' Creates a dynamic thing group.
#'
#' @usage
#' iot_create_dynamic_thing_group(thingGroupName, thingGroupProperties,
#'   indexName, queryString, queryVersion, tags)
#'
#' @param thingGroupName &#91;required&#93; The dynamic thing group name to create.
#' @param thingGroupProperties The dynamic thing group properties.
#' @param indexName The dynamic thing group index name.
#' 
#' Currently one index is supported: "AWS\\_Things".
#' @param queryString &#91;required&#93; The dynamic thing group search query string.
#' 
#' See [Query
#' Syntax](https://docs.aws.amazon.com/iot/latest/developerguide/query-syntax.html)
#' for information about query string syntax.
#' @param queryVersion The dynamic thing group query version.
#' 
#' Currently one query version is supported: "2017-09-30". If not
#' specified, the query version defaults to this value.
#' @param tags Metadata which can be used to manage the dynamic thing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_dynamic_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   indexName = "string",
#'   queryString = "string",
#'   queryVersion = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_dynamic_thing_group
iot_create_dynamic_thing_group <- function(thingGroupName, thingGroupProperties = NULL, indexName = NULL, queryString, queryVersion = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateDynamicThingGroup",
    http_method = "POST",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$create_dynamic_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, indexName = indexName, queryString = queryString, queryVersion = queryVersion, tags = tags)
  output <- .iot$create_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_dynamic_thing_group <- iot_create_dynamic_thing_group

#' Creates a job
#'
#' @description
#' Creates a job.
#'
#' @usage
#' iot_create_job(jobId, targets, documentSource, document, description,
#'   presignedUrlConfig, targetSelection, jobExecutionsRolloutConfig,
#'   abortConfig, timeoutConfig, tags, namespaceId)
#'
#' @param jobId &#91;required&#93; A job identifier which must be unique for your AWS account. We recommend
#' using a UUID. Alpha-numeric characters, "-" and "\\_" are valid for use
#' here.
#' @param targets &#91;required&#93; A list of things and thing groups to which the job should be sent.
#' @param documentSource An S3 link to the job document.
#' @param document The job document.
#' 
#' If the job document resides in an S3 bucket, you must use a placeholder
#' link when specifying the document.
#' 
#' The placeholder link is of the following form:
#' 
#' `$\{aws:iot:s3-presigned-url:https://s3.amazonaws.com/bucket/key\}`
#' 
#' where *bucket* is your bucket name and *key* is the object in the bucket
#' to which you are linking.
#' @param description A short text description of the job.
#' @param presignedUrlConfig Configuration information for pre-signed S3 URLs.
#' @param targetSelection Specifies whether the job will continue to run (CONTINUOUS), or will be
#' complete after all those things specified as targets have completed the
#' job (SNAPSHOT). If continuous, the job may also be run on a thing when a
#' change is detected in a target. For example, a job will run on a thing
#' when the thing is added to a target group, even after the job was
#' completed by all things originally in the group.
#' @param jobExecutionsRolloutConfig Allows you to create a staged rollout of the job.
#' @param abortConfig Allows you to create criteria to abort a job.
#' @param timeoutConfig Specifies the amount of time each device has to finish its execution of
#' the job. The timer is started when the job execution status is set to
#' `IN_PROGRESS`. If the job execution status is not set to another
#' terminal state before the time expires, it will be automatically set to
#' `TIMED_OUT`.
#' @param tags Metadata which can be used to manage the job.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$create_job(
#'   jobId = "string",
#'   targets = list(
#'     "string"
#'   ),
#'   documentSource = "string",
#'   document = "string",
#'   description = "string",
#'   presignedUrlConfig = list(
#'     roleArn = "string",
#'     expiresInSec = 123
#'   ),
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   jobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123,
#'     exponentialRate = list(
#'       baseRatePerMinute = 123,
#'       incrementFactor = 123.0,
#'       rateIncreaseCriteria = list(
#'         numberOfNotifiedThings = 123,
#'         numberOfSucceededThings = 123
#'       )
#'     )
#'   ),
#'   abortConfig = list(
#'     criteriaList = list(
#'       list(
#'         failureType = "FAILED"|"REJECTED"|"TIMED_OUT"|"ALL",
#'         action = "CANCEL",
#'         thresholdPercentage = 123.0,
#'         minNumberOfExecutedThings = 123
#'       )
#'     )
#'   ),
#'   timeoutConfig = list(
#'     inProgressTimeoutInMinutes = 123
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   ),
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_job
iot_create_job <- function(jobId, targets, documentSource = NULL, document = NULL, description = NULL, presignedUrlConfig = NULL, targetSelection = NULL, jobExecutionsRolloutConfig = NULL, abortConfig = NULL, timeoutConfig = NULL, tags = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "CreateJob",
    http_method = "PUT",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$create_job_input(jobId = jobId, targets = targets, documentSource = documentSource, document = document, description = description, presignedUrlConfig = presignedUrlConfig, targetSelection = targetSelection, jobExecutionsRolloutConfig = jobExecutionsRolloutConfig, abortConfig = abortConfig, timeoutConfig = timeoutConfig, tags = tags, namespaceId = namespaceId)
  output <- .iot$create_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_job <- iot_create_job

#' Creates a 2048-bit RSA key pair and issues an X
#'
#' @description
#' Creates a 2048-bit RSA key pair and issues an X.509 certificate using
#' the issued public key. You can also call
#' [`create_keys_and_certificate`][iot_create_keys_and_certificate] over
#' MQTT from a device, for more information, see [Provisioning MQTT
#' API](https://docs.aws.amazon.com/iot/latest/developerguide/provision-wo-cert.html#provision-mqtt-api).
#' 
#' **Note** This is the only time AWS IoT issues the private key for this
#' certificate, so it is important to keep it in a secure location.
#'
#' @usage
#' iot_create_keys_and_certificate(setAsActive)
#'
#' @param setAsActive Specifies whether the certificate is active.
#'
#' @section Request syntax:
#' ```
#' svc$create_keys_and_certificate(
#'   setAsActive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_keys_and_certificate
iot_create_keys_and_certificate <- function(setAsActive = NULL) {
  op <- new_operation(
    name = "CreateKeysAndCertificate",
    http_method = "POST",
    http_path = "/keys-and-certificate",
    paginator = list()
  )
  input <- .iot$create_keys_and_certificate_input(setAsActive = setAsActive)
  output <- .iot$create_keys_and_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_keys_and_certificate <- iot_create_keys_and_certificate

#' Defines an action that can be applied to audit findings by using
#' StartAuditMitigationActionsTask
#'
#' @description
#' Defines an action that can be applied to audit findings by using
#' StartAuditMitigationActionsTask. Only certain types of mitigation
#' actions can be applied to specific check names. For more information,
#' see [Mitigation
#' actions](https://docs.aws.amazon.com/iot/latest/developerguide/). Each
#' mitigation action can apply only one type of change.
#'
#' @usage
#' iot_create_mitigation_action(actionName, roleArn, actionParams, tags)
#'
#' @param actionName &#91;required&#93; A friendly name for the action. Choose a friendly name that accurately
#' describes the action (for example, `EnableLoggingAction`).
#' @param roleArn &#91;required&#93; The ARN of the IAM role that is used to apply the mitigation action.
#' @param actionParams &#91;required&#93; Defines the type of action and the parameters for that action.
#' @param tags Metadata that can be used to manage the mitigation action.
#'
#' @section Request syntax:
#' ```
#' svc$create_mitigation_action(
#'   actionName = "string",
#'   roleArn = "string",
#'   actionParams = list(
#'     updateDeviceCertificateParams = list(
#'       action = "DEACTIVATE"
#'     ),
#'     updateCACertificateParams = list(
#'       action = "DEACTIVATE"
#'     ),
#'     addThingsToThingGroupParams = list(
#'       thingGroupNames = list(
#'         "string"
#'       ),
#'       overrideDynamicGroups = TRUE|FALSE
#'     ),
#'     replaceDefaultPolicyVersionParams = list(
#'       templateName = "BLANK_POLICY"
#'     ),
#'     enableIoTLoggingParams = list(
#'       roleArnForLogging = "string",
#'       logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#'     ),
#'     publishFindingToSnsParams = list(
#'       topicArn = "string"
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_mitigation_action
iot_create_mitigation_action <- function(actionName, roleArn, actionParams, tags = NULL) {
  op <- new_operation(
    name = "CreateMitigationAction",
    http_method = "POST",
    http_path = "/mitigationactions/actions/{actionName}",
    paginator = list()
  )
  input <- .iot$create_mitigation_action_input(actionName = actionName, roleArn = roleArn, actionParams = actionParams, tags = tags)
  output <- .iot$create_mitigation_action_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_mitigation_action <- iot_create_mitigation_action

#' Creates an AWS IoT OTAUpdate on a target group of things or groups
#'
#' @description
#' Creates an AWS IoT OTAUpdate on a target group of things or groups.
#'
#' @usage
#' iot_create_ota_update(otaUpdateId, description, targets, protocols,
#'   targetSelection, awsJobExecutionsRolloutConfig,
#'   awsJobPresignedUrlConfig, awsJobAbortConfig, awsJobTimeoutConfig, files,
#'   roleArn, additionalParameters, tags)
#'
#' @param otaUpdateId &#91;required&#93; The ID of the OTA update to be created.
#' @param description The description of the OTA update.
#' @param targets &#91;required&#93; The devices targeted to receive OTA updates.
#' @param protocols The protocol used to transfer the OTA update image. Valid values are
#' \[HTTP\], \[MQTT\], \[HTTP, MQTT\]. When both HTTP and MQTT are
#' specified, the target device can choose the protocol.
#' @param targetSelection Specifies whether the update will continue to run (CONTINUOUS), or will
#' be complete after all the things specified as targets have completed the
#' update (SNAPSHOT). If continuous, the update may also be run on a thing
#' when a change is detected in a target. For example, an update will run
#' on a thing when the thing is added to a target group, even after the
#' update was completed by all things originally in the group. Valid
#' values: CONTINUOUS | SNAPSHOT.
#' @param awsJobExecutionsRolloutConfig Configuration for the rollout of OTA updates.
#' @param awsJobPresignedUrlConfig Configuration information for pre-signed URLs.
#' @param awsJobAbortConfig The criteria that determine when and how a job abort takes place.
#' @param awsJobTimeoutConfig Specifies the amount of time each device has to finish its execution of
#' the job. A timer is started when the job execution status is set to
#' `IN_PROGRESS`. If the job execution status is not set to another
#' terminal state before the timer expires, it will be automatically set to
#' `TIMED_OUT`.
#' @param files &#91;required&#93; The files to be streamed by the OTA update.
#' @param roleArn &#91;required&#93; The IAM role that grants AWS IoT access to the Amazon S3, AWS IoT jobs
#' and AWS Code Signing resources to create an OTA update job.
#' @param additionalParameters A list of additional OTA update parameters which are name-value pairs.
#' @param tags Metadata which can be used to manage updates.
#'
#' @section Request syntax:
#' ```
#' svc$create_ota_update(
#'   otaUpdateId = "string",
#'   description = "string",
#'   targets = list(
#'     "string"
#'   ),
#'   protocols = list(
#'     "MQTT"|"HTTP"
#'   ),
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   awsJobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123,
#'     exponentialRate = list(
#'       baseRatePerMinute = 123,
#'       incrementFactor = 123.0,
#'       rateIncreaseCriteria = list(
#'         numberOfNotifiedThings = 123,
#'         numberOfSucceededThings = 123
#'       )
#'     )
#'   ),
#'   awsJobPresignedUrlConfig = list(
#'     expiresInSec = 123
#'   ),
#'   awsJobAbortConfig = list(
#'     abortCriteriaList = list(
#'       list(
#'         failureType = "FAILED"|"REJECTED"|"TIMED_OUT"|"ALL",
#'         action = "CANCEL",
#'         thresholdPercentage = 123.0,
#'         minNumberOfExecutedThings = 123
#'       )
#'     )
#'   ),
#'   awsJobTimeoutConfig = list(
#'     inProgressTimeoutInMinutes = 123
#'   ),
#'   files = list(
#'     list(
#'       fileName = "string",
#'       fileType = 123,
#'       fileVersion = "string",
#'       fileLocation = list(
#'         stream = list(
#'           streamId = "string",
#'           fileId = 123
#'         ),
#'         s3Location = list(
#'           bucket = "string",
#'           key = "string",
#'           version = "string"
#'         )
#'       ),
#'       codeSigning = list(
#'         awsSignerJobId = "string",
#'         startSigningJobParameter = list(
#'           signingProfileParameter = list(
#'             certificateArn = "string",
#'             platform = "string",
#'             certificatePathOnDevice = "string"
#'           ),
#'           signingProfileName = "string",
#'           destination = list(
#'             s3Destination = list(
#'               bucket = "string",
#'               prefix = "string"
#'             )
#'           )
#'         ),
#'         customCodeSigning = list(
#'           signature = list(
#'             inlineDocument = raw
#'           ),
#'           certificateChain = list(
#'             certificateName = "string",
#'             inlineDocument = "string"
#'           ),
#'           hashAlgorithm = "string",
#'           signatureAlgorithm = "string"
#'         )
#'       ),
#'       attributes = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string",
#'   additionalParameters = list(
#'     "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_ota_update
iot_create_ota_update <- function(otaUpdateId, description = NULL, targets, protocols = NULL, targetSelection = NULL, awsJobExecutionsRolloutConfig = NULL, awsJobPresignedUrlConfig = NULL, awsJobAbortConfig = NULL, awsJobTimeoutConfig = NULL, files, roleArn, additionalParameters = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateOTAUpdate",
    http_method = "POST",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$create_ota_update_input(otaUpdateId = otaUpdateId, description = description, targets = targets, protocols = protocols, targetSelection = targetSelection, awsJobExecutionsRolloutConfig = awsJobExecutionsRolloutConfig, awsJobPresignedUrlConfig = awsJobPresignedUrlConfig, awsJobAbortConfig = awsJobAbortConfig, awsJobTimeoutConfig = awsJobTimeoutConfig, files = files, roleArn = roleArn, additionalParameters = additionalParameters, tags = tags)
  output <- .iot$create_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_ota_update <- iot_create_ota_update

#' Creates an AWS IoT policy
#'
#' @description
#' Creates an AWS IoT policy.
#' 
#' The created policy is the default version for the policy. This operation
#' creates a policy version with a version identifier of **1** and sets
#' **1** as the policy's default version.
#'
#' @usage
#' iot_create_policy(policyName, policyDocument, tags)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyDocument &#91;required&#93; The JSON document that describes the policy. **policyDocument** must
#' have a minimum length of 1, with a maximum length of 2048, excluding
#' whitespace.
#' @param tags Metadata which can be used to manage the policy.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$create_policy(
#'   policyName = "string",
#'   policyDocument = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_policy
iot_create_policy <- function(policyName, policyDocument, tags = NULL) {
  op <- new_operation(
    name = "CreatePolicy",
    http_method = "POST",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$create_policy_input(policyName = policyName, policyDocument = policyDocument, tags = tags)
  output <- .iot$create_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_policy <- iot_create_policy

#' Creates a new version of the specified AWS IoT policy
#'
#' @description
#' Creates a new version of the specified AWS IoT policy. To update a
#' policy, create a new policy version. A managed policy can have up to
#' five versions. If the policy has five versions, you must use
#' [`delete_policy_version`][iot_delete_policy_version] to delete an
#' existing version before you create a new one.
#' 
#' Optionally, you can set the new version as the policy's default version.
#' The default version is the operative version (that is, the version that
#' is in effect for the certificates to which the policy is attached).
#'
#' @usage
#' iot_create_policy_version(policyName, policyDocument, setAsDefault)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyDocument &#91;required&#93; The JSON document that describes the policy. Minimum length of 1.
#' Maximum length of 2048, excluding whitespace.
#' @param setAsDefault Specifies whether the policy version is set as the default. When this
#' parameter is true, the new policy version becomes the operative version
#' (that is, the version that is in effect for the certificates to which
#' the policy is attached).
#'
#' @section Request syntax:
#' ```
#' svc$create_policy_version(
#'   policyName = "string",
#'   policyDocument = "string",
#'   setAsDefault = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_policy_version
iot_create_policy_version <- function(policyName, policyDocument, setAsDefault = NULL) {
  op <- new_operation(
    name = "CreatePolicyVersion",
    http_method = "POST",
    http_path = "/policies/{policyName}/version",
    paginator = list()
  )
  input <- .iot$create_policy_version_input(policyName = policyName, policyDocument = policyDocument, setAsDefault = setAsDefault)
  output <- .iot$create_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_policy_version <- iot_create_policy_version

#' Creates a provisioning claim
#'
#' @description
#' Creates a provisioning claim.
#'
#' @usage
#' iot_create_provisioning_claim(templateName)
#'
#' @param templateName &#91;required&#93; The name of the provisioning template to use.
#'
#' @section Request syntax:
#' ```
#' svc$create_provisioning_claim(
#'   templateName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_provisioning_claim
iot_create_provisioning_claim <- function(templateName) {
  op <- new_operation(
    name = "CreateProvisioningClaim",
    http_method = "POST",
    http_path = "/provisioning-templates/{templateName}/provisioning-claim",
    paginator = list()
  )
  input <- .iot$create_provisioning_claim_input(templateName = templateName)
  output <- .iot$create_provisioning_claim_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_provisioning_claim <- iot_create_provisioning_claim

#' Creates a fleet provisioning template
#'
#' @description
#' Creates a fleet provisioning template.
#'
#' @usage
#' iot_create_provisioning_template(templateName, description,
#'   templateBody, enabled, provisioningRoleArn, preProvisioningHook, tags)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template.
#' @param description The description of the fleet provisioning template.
#' @param templateBody &#91;required&#93; The JSON formatted contents of the fleet provisioning template.
#' @param enabled True to enable the fleet provisioning template, otherwise false.
#' @param provisioningRoleArn &#91;required&#93; The role ARN for the role associated with the fleet provisioning
#' template. This IoT role grants permission to provision a device.
#' @param preProvisioningHook Creates a pre-provisioning hook template.
#' @param tags Metadata which can be used to manage the fleet provisioning template.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$create_provisioning_template(
#'   templateName = "string",
#'   description = "string",
#'   templateBody = "string",
#'   enabled = TRUE|FALSE,
#'   provisioningRoleArn = "string",
#'   preProvisioningHook = list(
#'     payloadVersion = "string",
#'     targetArn = "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_provisioning_template
iot_create_provisioning_template <- function(templateName, description = NULL, templateBody, enabled = NULL, provisioningRoleArn, preProvisioningHook = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateProvisioningTemplate",
    http_method = "POST",
    http_path = "/provisioning-templates",
    paginator = list()
  )
  input <- .iot$create_provisioning_template_input(templateName = templateName, description = description, templateBody = templateBody, enabled = enabled, provisioningRoleArn = provisioningRoleArn, preProvisioningHook = preProvisioningHook, tags = tags)
  output <- .iot$create_provisioning_template_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_provisioning_template <- iot_create_provisioning_template

#' Creates a new version of a fleet provisioning template
#'
#' @description
#' Creates a new version of a fleet provisioning template.
#'
#' @usage
#' iot_create_provisioning_template_version(templateName, templateBody,
#'   setAsDefault)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template.
#' @param templateBody &#91;required&#93; The JSON formatted contents of the fleet provisioning template.
#' @param setAsDefault Sets a fleet provision template version as the default version.
#'
#' @section Request syntax:
#' ```
#' svc$create_provisioning_template_version(
#'   templateName = "string",
#'   templateBody = "string",
#'   setAsDefault = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_provisioning_template_version
iot_create_provisioning_template_version <- function(templateName, templateBody, setAsDefault = NULL) {
  op <- new_operation(
    name = "CreateProvisioningTemplateVersion",
    http_method = "POST",
    http_path = "/provisioning-templates/{templateName}/versions",
    paginator = list()
  )
  input <- .iot$create_provisioning_template_version_input(templateName = templateName, templateBody = templateBody, setAsDefault = setAsDefault)
  output <- .iot$create_provisioning_template_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_provisioning_template_version <- iot_create_provisioning_template_version

#' Creates a role alias
#'
#' @description
#' Creates a role alias.
#'
#' @usage
#' iot_create_role_alias(roleAlias, roleArn, credentialDurationSeconds,
#'   tags)
#'
#' @param roleAlias &#91;required&#93; The role alias that points to a role ARN. This allows you to change the
#' role without having to update the device.
#' @param roleArn &#91;required&#93; The role ARN.
#' @param credentialDurationSeconds How long (in seconds) the credentials will be valid.
#' @param tags Metadata which can be used to manage the role alias.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$create_role_alias(
#'   roleAlias = "string",
#'   roleArn = "string",
#'   credentialDurationSeconds = 123,
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_role_alias
iot_create_role_alias <- function(roleAlias, roleArn, credentialDurationSeconds = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateRoleAlias",
    http_method = "POST",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$create_role_alias_input(roleAlias = roleAlias, roleArn = roleArn, credentialDurationSeconds = credentialDurationSeconds, tags = tags)
  output <- .iot$create_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_role_alias <- iot_create_role_alias

#' Creates a scheduled audit that is run at a specified time interval
#'
#' @description
#' Creates a scheduled audit that is run at a specified time interval.
#'
#' @usage
#' iot_create_scheduled_audit(frequency, dayOfMonth, dayOfWeek,
#'   targetCheckNames, scheduledAuditName, tags)
#'
#' @param frequency &#91;required&#93; How often the scheduled audit takes place, either `DAILY`, `WEEKLY`,
#' `BIWEEKLY` or `MONTHLY`. The start time of each audit is determined by
#' the system.
#' @param dayOfMonth The day of the month on which the scheduled audit takes place. This can
#' be "1" through "31" or "LAST". This field is required if the "frequency"
#' parameter is set to `MONTHLY`. If days 29 to 31 are specified, and the
#' month doesn't have that many days, the audit takes place on the `LAST`
#' day of the month.
#' @param dayOfWeek The day of the week on which the scheduled audit takes place, either
#' `SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, or `SAT`. This field is
#' required if the `frequency` parameter is set to `WEEKLY` or `BIWEEKLY`.
#' @param targetCheckNames &#91;required&#93; Which checks are performed during the scheduled audit. Checks must be
#' enabled for your account. (Use
#' [`describe_account_audit_configuration`][iot_describe_account_audit_configuration]
#' to see the list of all checks, including those that are enabled or use
#' [`update_account_audit_configuration`][iot_update_account_audit_configuration]
#' to select which checks are enabled.)
#' @param scheduledAuditName &#91;required&#93; The name you want to give to the scheduled audit. (Max. 128 chars)
#' @param tags Metadata that can be used to manage the scheduled audit.
#'
#' @section Request syntax:
#' ```
#' svc$create_scheduled_audit(
#'   frequency = "DAILY"|"WEEKLY"|"BIWEEKLY"|"MONTHLY",
#'   dayOfMonth = "string",
#'   dayOfWeek = "SUN"|"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT",
#'   targetCheckNames = list(
#'     "string"
#'   ),
#'   scheduledAuditName = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_scheduled_audit
iot_create_scheduled_audit <- function(frequency, dayOfMonth = NULL, dayOfWeek = NULL, targetCheckNames, scheduledAuditName, tags = NULL) {
  op <- new_operation(
    name = "CreateScheduledAudit",
    http_method = "POST",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$create_scheduled_audit_input(frequency = frequency, dayOfMonth = dayOfMonth, dayOfWeek = dayOfWeek, targetCheckNames = targetCheckNames, scheduledAuditName = scheduledAuditName, tags = tags)
  output <- .iot$create_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_scheduled_audit <- iot_create_scheduled_audit

#' Creates a Device Defender security profile
#'
#' @description
#' Creates a Device Defender security profile.
#'
#' @usage
#' iot_create_security_profile(securityProfileName,
#'   securityProfileDescription, behaviors, alertTargets,
#'   additionalMetricsToRetain, additionalMetricsToRetainV2, tags)
#'
#' @param securityProfileName &#91;required&#93; The name you are giving to the security profile.
#' @param securityProfileDescription A description of the security profile.
#' @param behaviors Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#' @param alertTargets Specifies the destinations to which alerts are sent. (Alerts are always
#' sent to the console.) Alerts are generated when a device (thing)
#' violates a behavior.
#' @param additionalMetricsToRetain *Please use CreateSecurityProfileRequest$additionalMetricsToRetainV2
#' instead.*
#' 
#' A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile's `behaviors`, but it is
#' also retained for any metric specified here. Can be used with custom
#' metrics; cannot be used with dimensions.
#' @param additionalMetricsToRetainV2 A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile's `behaviors`, but it is
#' also retained for any metric specified here. Can be used with custom
#' metrics; cannot be used with dimensions.
#' @param tags Metadata that can be used to manage the security profile.
#'
#' @section Request syntax:
#' ```
#' svc$create_security_profile(
#'   securityProfileName = "string",
#'   securityProfileDescription = "string",
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       metricDimension = list(
#'         dimensionName = "string",
#'         operator = "IN"|"NOT_IN"
#'       ),
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set"|"in-set"|"not-in-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           ),
#'           number = 123.0,
#'           numbers = list(
#'             123.0
#'           ),
#'           strings = list(
#'             "string"
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         ),
#'         mlDetectionConfig = list(
#'           confidenceLevel = "LOW"|"MEDIUM"|"HIGH"
#'         )
#'       ),
#'       suppressAlerts = TRUE|FALSE
#'     )
#'   ),
#'   alertTargets = list(
#'     list(
#'       alertTargetArn = "string",
#'       roleArn = "string"
#'     )
#'   ),
#'   additionalMetricsToRetain = list(
#'     "string"
#'   ),
#'   additionalMetricsToRetainV2 = list(
#'     list(
#'       metric = "string",
#'       metricDimension = list(
#'         dimensionName = "string",
#'         operator = "IN"|"NOT_IN"
#'       )
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_security_profile
iot_create_security_profile <- function(securityProfileName, securityProfileDescription = NULL, behaviors = NULL, alertTargets = NULL, additionalMetricsToRetain = NULL, additionalMetricsToRetainV2 = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateSecurityProfile",
    http_method = "POST",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$create_security_profile_input(securityProfileName = securityProfileName, securityProfileDescription = securityProfileDescription, behaviors = behaviors, alertTargets = alertTargets, additionalMetricsToRetain = additionalMetricsToRetain, additionalMetricsToRetainV2 = additionalMetricsToRetainV2, tags = tags)
  output <- .iot$create_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_security_profile <- iot_create_security_profile

#' Creates a stream for delivering one or more large files in chunks over
#' MQTT
#'
#' @description
#' Creates a stream for delivering one or more large files in chunks over
#' MQTT. A stream transports data bytes in chunks or blocks packaged as
#' MQTT messages from a source like S3. You can have one or more files
#' associated with a stream.
#'
#' @usage
#' iot_create_stream(streamId, description, files, roleArn, tags)
#'
#' @param streamId &#91;required&#93; The stream ID.
#' @param description A description of the stream.
#' @param files &#91;required&#93; The files to stream.
#' @param roleArn &#91;required&#93; An IAM role that allows the IoT service principal assumes to access your
#' S3 files.
#' @param tags Metadata which can be used to manage streams.
#'
#' @section Request syntax:
#' ```
#' svc$create_stream(
#'   streamId = "string",
#'   description = "string",
#'   files = list(
#'     list(
#'       fileId = 123,
#'       s3Location = list(
#'         bucket = "string",
#'         key = "string",
#'         version = "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_stream
iot_create_stream <- function(streamId, description = NULL, files, roleArn, tags = NULL) {
  op <- new_operation(
    name = "CreateStream",
    http_method = "POST",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$create_stream_input(streamId = streamId, description = description, files = files, roleArn = roleArn, tags = tags)
  output <- .iot$create_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_stream <- iot_create_stream

#' Creates a thing record in the registry
#'
#' @description
#' Creates a thing record in the registry. If this call is made multiple
#' times using the same thing name and configuration, the call will
#' succeed. If this call is made with the same thing name but different
#' configuration a `ResourceAlreadyExistsException` is thrown.
#' 
#' This is a control plane operation. See
#' [Authorization](https://docs.aws.amazon.com/iot/latest/developerguide/iot-authorization.html)
#' for information about authorizing control plane actions.
#'
#' @usage
#' iot_create_thing(thingName, thingTypeName, attributePayload,
#'   billingGroupName)
#'
#' @param thingName &#91;required&#93; The name of the thing to create.
#' 
#' You can't change a thing's name after you create it. To change a thing's
#' name, you must create a new thing, give it the new name, and then delete
#' the old thing.
#' @param thingTypeName The name of the thing type associated with the new thing.
#' @param attributePayload The attribute payload, which consists of up to three name/value pairs in
#' a JSON document. For example:
#' 
#' `\{\"attributes\":\{\"string1\":\"string2\"\}\}`
#' @param billingGroupName The name of the billing group the thing will be added to.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing(
#'   thingName = "string",
#'   thingTypeName = "string",
#'   attributePayload = list(
#'     attributes = list(
#'       "string"
#'     ),
#'     merge = TRUE|FALSE
#'   ),
#'   billingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing
iot_create_thing <- function(thingName, thingTypeName = NULL, attributePayload = NULL, billingGroupName = NULL) {
  op <- new_operation(
    name = "CreateThing",
    http_method = "POST",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$create_thing_input(thingName = thingName, thingTypeName = thingTypeName, attributePayload = attributePayload, billingGroupName = billingGroupName)
  output <- .iot$create_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing <- iot_create_thing

#' Create a thing group
#'
#' @description
#' Create a thing group.
#' 
#' This is a control plane operation. See
#' [Authorization](https://docs.aws.amazon.com/iot/latest/developerguide/iot-authorization.html)
#' for information about authorizing control plane actions.
#'
#' @usage
#' iot_create_thing_group(thingGroupName, parentGroupName,
#'   thingGroupProperties, tags)
#'
#' @param thingGroupName &#91;required&#93; The thing group name to create.
#' @param parentGroupName The name of the parent thing group.
#' @param thingGroupProperties The thing group properties.
#' @param tags Metadata which can be used to manage the thing group.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing_group(
#'   thingGroupName = "string",
#'   parentGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing_group
iot_create_thing_group <- function(thingGroupName, parentGroupName = NULL, thingGroupProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateThingGroup",
    http_method = "POST",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$create_thing_group_input(thingGroupName = thingGroupName, parentGroupName = parentGroupName, thingGroupProperties = thingGroupProperties, tags = tags)
  output <- .iot$create_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing_group <- iot_create_thing_group

#' Creates a new thing type
#'
#' @description
#' Creates a new thing type.
#'
#' @usage
#' iot_create_thing_type(thingTypeName, thingTypeProperties, tags)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#' @param thingTypeProperties The ThingTypeProperties for the thing type to create. It contains
#' information about the new thing type including a description, and a list
#' of searchable thing attribute names.
#' @param tags Metadata which can be used to manage the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$create_thing_type(
#'   thingTypeName = "string",
#'   thingTypeProperties = list(
#'     thingTypeDescription = "string",
#'     searchableAttributes = list(
#'       "string"
#'     )
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_thing_type
iot_create_thing_type <- function(thingTypeName, thingTypeProperties = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateThingType",
    http_method = "POST",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$create_thing_type_input(thingTypeName = thingTypeName, thingTypeProperties = thingTypeProperties, tags = tags)
  output <- .iot$create_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_thing_type <- iot_create_thing_type

#' Creates a rule
#'
#' @description
#' Creates a rule. Creating rules is an administrator-level action. Any
#' user who has permission to create rules will be able to access data
#' processed by the rule.
#'
#' @usage
#' iot_create_topic_rule(ruleName, topicRulePayload, tags)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#' @param topicRulePayload &#91;required&#93; The rule payload.
#' @param tags Metadata which can be used to manage the topic rule.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: --tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$create_topic_rule(
#'   ruleName = "string",
#'   topicRulePayload = list(
#'     sql = "string",
#'     description = "string",
#'     actions = list(
#'       list(
#'         dynamoDB = list(
#'           tableName = "string",
#'           roleArn = "string",
#'           operation = "string",
#'           hashKeyField = "string",
#'           hashKeyValue = "string",
#'           hashKeyType = "STRING"|"NUMBER",
#'           rangeKeyField = "string",
#'           rangeKeyValue = "string",
#'           rangeKeyType = "STRING"|"NUMBER",
#'           payloadField = "string"
#'         ),
#'         dynamoDBv2 = list(
#'           roleArn = "string",
#'           putItem = list(
#'             tableName = "string"
#'           )
#'         ),
#'         lambda = list(
#'           functionArn = "string"
#'         ),
#'         sns = list(
#'           targetArn = "string",
#'           roleArn = "string",
#'           messageFormat = "RAW"|"JSON"
#'         ),
#'         sqs = list(
#'           roleArn = "string",
#'           queueUrl = "string",
#'           useBase64 = TRUE|FALSE
#'         ),
#'         kinesis = list(
#'           roleArn = "string",
#'           streamName = "string",
#'           partitionKey = "string"
#'         ),
#'         republish = list(
#'           roleArn = "string",
#'           topic = "string",
#'           qos = 123
#'         ),
#'         s3 = list(
#'           roleArn = "string",
#'           bucketName = "string",
#'           key = "string",
#'           cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'         ),
#'         firehose = list(
#'           roleArn = "string",
#'           deliveryStreamName = "string",
#'           separator = "string",
#'           batchMode = TRUE|FALSE
#'         ),
#'         cloudwatchMetric = list(
#'           roleArn = "string",
#'           metricNamespace = "string",
#'           metricName = "string",
#'           metricValue = "string",
#'           metricUnit = "string",
#'           metricTimestamp = "string"
#'         ),
#'         cloudwatchAlarm = list(
#'           roleArn = "string",
#'           alarmName = "string",
#'           stateReason = "string",
#'           stateValue = "string"
#'         ),
#'         cloudwatchLogs = list(
#'           roleArn = "string",
#'           logGroupName = "string"
#'         ),
#'         elasticsearch = list(
#'           roleArn = "string",
#'           endpoint = "string",
#'           index = "string",
#'           type = "string",
#'           id = "string"
#'         ),
#'         salesforce = list(
#'           token = "string",
#'           url = "string"
#'         ),
#'         iotAnalytics = list(
#'           channelArn = "string",
#'           channelName = "string",
#'           batchMode = TRUE|FALSE,
#'           roleArn = "string"
#'         ),
#'         iotEvents = list(
#'           inputName = "string",
#'           messageId = "string",
#'           batchMode = TRUE|FALSE,
#'           roleArn = "string"
#'         ),
#'         iotSiteWise = list(
#'           putAssetPropertyValueEntries = list(
#'             list(
#'               entryId = "string",
#'               assetId = "string",
#'               propertyId = "string",
#'               propertyAlias = "string",
#'               propertyValues = list(
#'                 list(
#'                   value = list(
#'                     stringValue = "string",
#'                     integerValue = "string",
#'                     doubleValue = "string",
#'                     booleanValue = "string"
#'                   ),
#'                   timestamp = list(
#'                     timeInSeconds = "string",
#'                     offsetInNanos = "string"
#'                   ),
#'                   quality = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           roleArn = "string"
#'         ),
#'         stepFunctions = list(
#'           executionNamePrefix = "string",
#'           stateMachineName = "string",
#'           roleArn = "string"
#'         ),
#'         timestream = list(
#'           roleArn = "string",
#'           databaseName = "string",
#'           tableName = "string",
#'           dimensions = list(
#'             list(
#'               name = "string",
#'               value = "string"
#'             )
#'           ),
#'           timestamp = list(
#'             value = "string",
#'             unit = "string"
#'           )
#'         ),
#'         http = list(
#'           url = "string",
#'           confirmationUrl = "string",
#'           headers = list(
#'             list(
#'               key = "string",
#'               value = "string"
#'             )
#'           ),
#'           auth = list(
#'             sigv4 = list(
#'               signingRegion = "string",
#'               serviceName = "string",
#'               roleArn = "string"
#'             )
#'           )
#'         ),
#'         kafka = list(
#'           destinationArn = "string",
#'           topic = "string",
#'           key = "string",
#'           partition = "string",
#'           clientProperties = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ruleDisabled = TRUE|FALSE,
#'     awsIotSqlVersion = "string",
#'     errorAction = list(
#'       dynamoDB = list(
#'         tableName = "string",
#'         roleArn = "string",
#'         operation = "string",
#'         hashKeyField = "string",
#'         hashKeyValue = "string",
#'         hashKeyType = "STRING"|"NUMBER",
#'         rangeKeyField = "string",
#'         rangeKeyValue = "string",
#'         rangeKeyType = "STRING"|"NUMBER",
#'         payloadField = "string"
#'       ),
#'       dynamoDBv2 = list(
#'         roleArn = "string",
#'         putItem = list(
#'           tableName = "string"
#'         )
#'       ),
#'       lambda = list(
#'         functionArn = "string"
#'       ),
#'       sns = list(
#'         targetArn = "string",
#'         roleArn = "string",
#'         messageFormat = "RAW"|"JSON"
#'       ),
#'       sqs = list(
#'         roleArn = "string",
#'         queueUrl = "string",
#'         useBase64 = TRUE|FALSE
#'       ),
#'       kinesis = list(
#'         roleArn = "string",
#'         streamName = "string",
#'         partitionKey = "string"
#'       ),
#'       republish = list(
#'         roleArn = "string",
#'         topic = "string",
#'         qos = 123
#'       ),
#'       s3 = list(
#'         roleArn = "string",
#'         bucketName = "string",
#'         key = "string",
#'         cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'       ),
#'       firehose = list(
#'         roleArn = "string",
#'         deliveryStreamName = "string",
#'         separator = "string",
#'         batchMode = TRUE|FALSE
#'       ),
#'       cloudwatchMetric = list(
#'         roleArn = "string",
#'         metricNamespace = "string",
#'         metricName = "string",
#'         metricValue = "string",
#'         metricUnit = "string",
#'         metricTimestamp = "string"
#'       ),
#'       cloudwatchAlarm = list(
#'         roleArn = "string",
#'         alarmName = "string",
#'         stateReason = "string",
#'         stateValue = "string"
#'       ),
#'       cloudwatchLogs = list(
#'         roleArn = "string",
#'         logGroupName = "string"
#'       ),
#'       elasticsearch = list(
#'         roleArn = "string",
#'         endpoint = "string",
#'         index = "string",
#'         type = "string",
#'         id = "string"
#'       ),
#'       salesforce = list(
#'         token = "string",
#'         url = "string"
#'       ),
#'       iotAnalytics = list(
#'         channelArn = "string",
#'         channelName = "string",
#'         batchMode = TRUE|FALSE,
#'         roleArn = "string"
#'       ),
#'       iotEvents = list(
#'         inputName = "string",
#'         messageId = "string",
#'         batchMode = TRUE|FALSE,
#'         roleArn = "string"
#'       ),
#'       iotSiteWise = list(
#'         putAssetPropertyValueEntries = list(
#'           list(
#'             entryId = "string",
#'             assetId = "string",
#'             propertyId = "string",
#'             propertyAlias = "string",
#'             propertyValues = list(
#'               list(
#'                 value = list(
#'                   stringValue = "string",
#'                   integerValue = "string",
#'                   doubleValue = "string",
#'                   booleanValue = "string"
#'                 ),
#'                 timestamp = list(
#'                   timeInSeconds = "string",
#'                   offsetInNanos = "string"
#'                 ),
#'                 quality = "string"
#'               )
#'             )
#'           )
#'         ),
#'         roleArn = "string"
#'       ),
#'       stepFunctions = list(
#'         executionNamePrefix = "string",
#'         stateMachineName = "string",
#'         roleArn = "string"
#'       ),
#'       timestream = list(
#'         roleArn = "string",
#'         databaseName = "string",
#'         tableName = "string",
#'         dimensions = list(
#'           list(
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         timestamp = list(
#'           value = "string",
#'           unit = "string"
#'         )
#'       ),
#'       http = list(
#'         url = "string",
#'         confirmationUrl = "string",
#'         headers = list(
#'           list(
#'             key = "string",
#'             value = "string"
#'           )
#'         ),
#'         auth = list(
#'           sigv4 = list(
#'             signingRegion = "string",
#'             serviceName = "string",
#'             roleArn = "string"
#'           )
#'         )
#'       ),
#'       kafka = list(
#'         destinationArn = "string",
#'         topic = "string",
#'         key = "string",
#'         partition = "string",
#'         clientProperties = list(
#'           "string"
#'         )
#'       )
#'     )
#'   ),
#'   tags = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_topic_rule
iot_create_topic_rule <- function(ruleName, topicRulePayload, tags = NULL) {
  op <- new_operation(
    name = "CreateTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$create_topic_rule_input(ruleName = ruleName, topicRulePayload = topicRulePayload, tags = tags)
  output <- .iot$create_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_topic_rule <- iot_create_topic_rule

#' Creates a topic rule destination
#'
#' @description
#' Creates a topic rule destination. The destination must be confirmed
#' prior to use.
#'
#' @usage
#' iot_create_topic_rule_destination(destinationConfiguration)
#'
#' @param destinationConfiguration &#91;required&#93; The topic rule destination configuration.
#'
#' @section Request syntax:
#' ```
#' svc$create_topic_rule_destination(
#'   destinationConfiguration = list(
#'     httpUrlConfiguration = list(
#'       confirmationUrl = "string"
#'     ),
#'     vpcConfiguration = list(
#'       subnetIds = list(
#'         "string"
#'       ),
#'       securityGroups = list(
#'         "string"
#'       ),
#'       vpcId = "string",
#'       roleArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_create_topic_rule_destination
iot_create_topic_rule_destination <- function(destinationConfiguration) {
  op <- new_operation(
    name = "CreateTopicRuleDestination",
    http_method = "POST",
    http_path = "/destinations",
    paginator = list()
  )
  input <- .iot$create_topic_rule_destination_input(destinationConfiguration = destinationConfiguration)
  output <- .iot$create_topic_rule_destination_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$create_topic_rule_destination <- iot_create_topic_rule_destination

#' Restores the default settings for Device Defender audits for this
#' account
#'
#' @description
#' Restores the default settings for Device Defender audits for this
#' account. Any configuration data you entered is deleted and all audit
#' checks are reset to disabled.
#'
#' @usage
#' iot_delete_account_audit_configuration(deleteScheduledAudits)
#'
#' @param deleteScheduledAudits If true, all scheduled audits are deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_account_audit_configuration(
#'   deleteScheduledAudits = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_account_audit_configuration
iot_delete_account_audit_configuration <- function(deleteScheduledAudits = NULL) {
  op <- new_operation(
    name = "DeleteAccountAuditConfiguration",
    http_method = "DELETE",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$delete_account_audit_configuration_input(deleteScheduledAudits = deleteScheduledAudits)
  output <- .iot$delete_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_account_audit_configuration <- iot_delete_account_audit_configuration

#' Deletes a Device Defender audit suppression
#'
#' @description
#' Deletes a Device Defender audit suppression.
#'
#' @usage
#' iot_delete_audit_suppression(checkName, resourceIdentifier)
#'
#' @param checkName &#91;required&#93; 
#' @param resourceIdentifier &#91;required&#93; 
#'
#' @section Request syntax:
#' ```
#' svc$delete_audit_suppression(
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_audit_suppression
iot_delete_audit_suppression <- function(checkName, resourceIdentifier) {
  op <- new_operation(
    name = "DeleteAuditSuppression",
    http_method = "POST",
    http_path = "/audit/suppressions/delete",
    paginator = list()
  )
  input <- .iot$delete_audit_suppression_input(checkName = checkName, resourceIdentifier = resourceIdentifier)
  output <- .iot$delete_audit_suppression_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_audit_suppression <- iot_delete_audit_suppression

#' Deletes an authorizer
#'
#' @description
#' Deletes an authorizer.
#'
#' @usage
#' iot_delete_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The name of the authorizer to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_authorizer
iot_delete_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "DeleteAuthorizer",
    http_method = "DELETE",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$delete_authorizer_input(authorizerName = authorizerName)
  output <- .iot$delete_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_authorizer <- iot_delete_authorizer

#' Deletes the billing group
#'
#' @description
#' Deletes the billing group.
#'
#' @usage
#' iot_delete_billing_group(billingGroupName, expectedVersion)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param expectedVersion The expected version of the billing group. If the version of the billing
#' group does not match the expected version specified in the request, the
#' [`delete_billing_group`][iot_delete_billing_group] request is rejected
#' with a `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$delete_billing_group(
#'   billingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_billing_group
iot_delete_billing_group <- function(billingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteBillingGroup",
    http_method = "DELETE",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_billing_group_input(billingGroupName = billingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_billing_group <- iot_delete_billing_group

#' Deletes a registered CA certificate
#'
#' @description
#' Deletes a registered CA certificate.
#'
#' @usage
#' iot_delete_ca_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate to delete. (The last part of the certificate
#' ARN contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$delete_ca_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_ca_certificate
iot_delete_ca_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DeleteCACertificate",
    http_method = "DELETE",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$delete_ca_certificate_input(certificateId = certificateId)
  output <- .iot$delete_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_ca_certificate <- iot_delete_ca_certificate

#' Deletes the specified certificate
#'
#' @description
#' Deletes the specified certificate.
#' 
#' A certificate cannot be deleted if it has a policy or IoT thing attached
#' to it or if its status is set to ACTIVE. To delete a certificate, first
#' use the [`detach_principal_policy`][iot_detach_principal_policy] API to
#' detach all policies. Next, use the
#' [`update_certificate`][iot_update_certificate] API to set the
#' certificate to the INACTIVE status.
#'
#' @usage
#' iot_delete_certificate(certificateId, forceDelete)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param forceDelete Forces the deletion of a certificate if it is inactive and is not
#' attached to an IoT thing.
#'
#' @section Request syntax:
#' ```
#' svc$delete_certificate(
#'   certificateId = "string",
#'   forceDelete = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_certificate
iot_delete_certificate <- function(certificateId, forceDelete = NULL) {
  op <- new_operation(
    name = "DeleteCertificate",
    http_method = "DELETE",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$delete_certificate_input(certificateId = certificateId, forceDelete = forceDelete)
  output <- .iot$delete_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_certificate <- iot_delete_certificate

#' Before you can delete a custom metric, you must first remove the custom
#' metric from all security profiles it's a part of
#'
#' @description
#' Before you can delete a custom metric, you must first remove the custom
#' metric from all security profiles it's a part of. The security profile
#' associated with the custom metric can be found using the
#' [`list_security_profiles`][iot_list_security_profiles] API with
#' `metricName` set to your custom metric name.
#' 
#' Deletes a Device Defender detect custom metric.
#'
#' @usage
#' iot_delete_custom_metric(metricName)
#'
#' @param metricName &#91;required&#93; The name of the custom metric.
#'
#' @section Request syntax:
#' ```
#' svc$delete_custom_metric(
#'   metricName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_custom_metric
iot_delete_custom_metric <- function(metricName) {
  op <- new_operation(
    name = "DeleteCustomMetric",
    http_method = "DELETE",
    http_path = "/custom-metric/{metricName}",
    paginator = list()
  )
  input <- .iot$delete_custom_metric_input(metricName = metricName)
  output <- .iot$delete_custom_metric_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_custom_metric <- iot_delete_custom_metric

#' Removes the specified dimension from your AWS account
#'
#' @description
#' Removes the specified dimension from your AWS account.
#'
#' @usage
#' iot_delete_dimension(name)
#'
#' @param name &#91;required&#93; The unique identifier for the dimension that you want to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_dimension(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_dimension
iot_delete_dimension <- function(name) {
  op <- new_operation(
    name = "DeleteDimension",
    http_method = "DELETE",
    http_path = "/dimensions/{name}",
    paginator = list()
  )
  input <- .iot$delete_dimension_input(name = name)
  output <- .iot$delete_dimension_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_dimension <- iot_delete_dimension

#' Deletes the specified domain configuration
#'
#' @description
#' Deletes the specified domain configuration.
#' 
#' The domain configuration feature is in public preview and is subject to
#' change.
#'
#' @usage
#' iot_delete_domain_configuration(domainConfigurationName)
#'
#' @param domainConfigurationName &#91;required&#93; The name of the domain configuration to be deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_domain_configuration(
#'   domainConfigurationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_domain_configuration
iot_delete_domain_configuration <- function(domainConfigurationName) {
  op <- new_operation(
    name = "DeleteDomainConfiguration",
    http_method = "DELETE",
    http_path = "/domainConfigurations/{domainConfigurationName}",
    paginator = list()
  )
  input <- .iot$delete_domain_configuration_input(domainConfigurationName = domainConfigurationName)
  output <- .iot$delete_domain_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_domain_configuration <- iot_delete_domain_configuration

#' Deletes a dynamic thing group
#'
#' @description
#' Deletes a dynamic thing group.
#'
#' @usage
#' iot_delete_dynamic_thing_group(thingGroupName, expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the dynamic thing group to delete.
#' @param expectedVersion The expected version of the dynamic thing group to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_dynamic_thing_group(
#'   thingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_dynamic_thing_group
iot_delete_dynamic_thing_group <- function(thingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteDynamicThingGroup",
    http_method = "DELETE",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_dynamic_thing_group_input(thingGroupName = thingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_dynamic_thing_group <- iot_delete_dynamic_thing_group

#' Deletes a job and its related job executions
#'
#' @description
#' Deletes a job and its related job executions.
#' 
#' Deleting a job may take time, depending on the number of job executions
#' created for the job and various other factors. While the job is being
#' deleted, the status of the job will be shown as
#' "DELETION\\_IN\\_PROGRESS". Attempting to delete or cancel a job whose
#' status is already "DELETION\\_IN\\_PROGRESS" will result in an error.
#' 
#' Only 10 jobs may have status "DELETION\\_IN\\_PROGRESS" at the same time,
#' or a LimitExceededException will occur.
#'
#' @usage
#' iot_delete_job(jobId, force, namespaceId)
#'
#' @param jobId &#91;required&#93; The ID of the job to be deleted.
#' 
#' After a job deletion is completed, you may reuse this jobId when you
#' create a new job. However, this is not recommended, and you must ensure
#' that your devices are not using the jobId to refer to the deleted job.
#' @param force (Optional) When true, you can delete a job which is "IN\\_PROGRESS".
#' Otherwise, you can only delete a job which is in a terminal state
#' ("COMPLETED" or "CANCELED") or an exception will occur. The default is
#' false.
#' 
#' Deleting a job which is "IN\\_PROGRESS", will cause a device which is
#' executing the job to be unable to access job information or update the
#' job execution status. Use caution and ensure that each device executing
#' a job which is deleted is able to recover to a valid state.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   jobId = "string",
#'   force = TRUE|FALSE,
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_job
iot_delete_job <- function(jobId, force = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "DELETE",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$delete_job_input(jobId = jobId, force = force, namespaceId = namespaceId)
  output <- .iot$delete_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_job <- iot_delete_job

#' Deletes a job execution
#'
#' @description
#' Deletes a job execution.
#'
#' @usage
#' iot_delete_job_execution(jobId, thingName, executionNumber, force,
#'   namespaceId)
#'
#' @param jobId &#91;required&#93; The ID of the job whose execution on a particular device will be
#' deleted.
#' @param thingName &#91;required&#93; The name of the thing whose job execution will be deleted.
#' @param executionNumber &#91;required&#93; The ID of the job execution to be deleted. The `executionNumber` refers
#' to the execution of a particular job on a particular device.
#' 
#' Note that once a job execution is deleted, the `executionNumber` may be
#' reused by IoT, so be sure you get and use the correct value here.
#' @param force (Optional) When true, you can delete a job execution which is
#' "IN\\_PROGRESS". Otherwise, you can only delete a job execution which is
#' in a terminal state ("SUCCEEDED", "FAILED", "REJECTED", "REMOVED" or
#' "CANCELED") or an exception will occur. The default is false.
#' 
#' Deleting a job execution which is "IN\\_PROGRESS", will cause the device
#' to be unable to access job information or update the job execution
#' status. Use caution and ensure that the device is able to recover to a
#' valid state.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   executionNumber = 123,
#'   force = TRUE|FALSE,
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_job_execution
iot_delete_job_execution <- function(jobId, thingName, executionNumber, force = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "DeleteJobExecution",
    http_method = "DELETE",
    http_path = "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}",
    paginator = list()
  )
  input <- .iot$delete_job_execution_input(jobId = jobId, thingName = thingName, executionNumber = executionNumber, force = force, namespaceId = namespaceId)
  output <- .iot$delete_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_job_execution <- iot_delete_job_execution

#' Deletes a defined mitigation action from your AWS account
#'
#' @description
#' Deletes a defined mitigation action from your AWS account.
#'
#' @usage
#' iot_delete_mitigation_action(actionName)
#'
#' @param actionName &#91;required&#93; The name of the mitigation action that you want to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_mitigation_action(
#'   actionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_mitigation_action
iot_delete_mitigation_action <- function(actionName) {
  op <- new_operation(
    name = "DeleteMitigationAction",
    http_method = "DELETE",
    http_path = "/mitigationactions/actions/{actionName}",
    paginator = list()
  )
  input <- .iot$delete_mitigation_action_input(actionName = actionName)
  output <- .iot$delete_mitigation_action_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_mitigation_action <- iot_delete_mitigation_action

#' Delete an OTA update
#'
#' @description
#' Delete an OTA update.
#'
#' @usage
#' iot_delete_ota_update(otaUpdateId, deleteStream, forceDeleteAWSJob)
#'
#' @param otaUpdateId &#91;required&#93; The ID of the OTA update to delete.
#' @param deleteStream Specifies if the stream associated with an OTA update should be deleted
#' when the OTA update is deleted.
#' @param forceDeleteAWSJob Specifies if the AWS Job associated with the OTA update should be
#' deleted when the OTA update is deleted.
#'
#' @section Request syntax:
#' ```
#' svc$delete_ota_update(
#'   otaUpdateId = "string",
#'   deleteStream = TRUE|FALSE,
#'   forceDeleteAWSJob = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_ota_update
iot_delete_ota_update <- function(otaUpdateId, deleteStream = NULL, forceDeleteAWSJob = NULL) {
  op <- new_operation(
    name = "DeleteOTAUpdate",
    http_method = "DELETE",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$delete_ota_update_input(otaUpdateId = otaUpdateId, deleteStream = deleteStream, forceDeleteAWSJob = forceDeleteAWSJob)
  output <- .iot$delete_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_ota_update <- iot_delete_ota_update

#' Deletes the specified policy
#'
#' @description
#' Deletes the specified policy.
#' 
#' A policy cannot be deleted if it has non-default versions or it is
#' attached to any certificate.
#' 
#' To delete a policy, use the DeletePolicyVersion API to delete all
#' non-default versions of the policy; use the DetachPrincipalPolicy API to
#' detach the policy from any certificate; and then use the DeletePolicy
#' API to delete the policy.
#' 
#' When a policy is deleted using DeletePolicy, its default version is
#' deleted with it.
#'
#' @usage
#' iot_delete_policy(policyName)
#'
#' @param policyName &#91;required&#93; The name of the policy to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_policy
iot_delete_policy <- function(policyName) {
  op <- new_operation(
    name = "DeletePolicy",
    http_method = "DELETE",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$delete_policy_input(policyName = policyName)
  output <- .iot$delete_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_policy <- iot_delete_policy

#' Deletes the specified version of the specified policy
#'
#' @description
#' Deletes the specified version of the specified policy. You cannot delete
#' the default version of a policy using this API. To delete the default
#' version of a policy, use [`delete_policy`][iot_delete_policy]. To find
#' out which version of a policy is marked as the default version, use
#' ListPolicyVersions.
#'
#' @usage
#' iot_delete_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$delete_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_policy_version
iot_delete_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "DeletePolicyVersion",
    http_method = "DELETE",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$delete_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$delete_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_policy_version <- iot_delete_policy_version

#' Deletes a fleet provisioning template
#'
#' @description
#' Deletes a fleet provisioning template.
#'
#' @usage
#' iot_delete_provisioning_template(templateName)
#'
#' @param templateName &#91;required&#93; The name of the fleet provision template to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_provisioning_template(
#'   templateName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_provisioning_template
iot_delete_provisioning_template <- function(templateName) {
  op <- new_operation(
    name = "DeleteProvisioningTemplate",
    http_method = "DELETE",
    http_path = "/provisioning-templates/{templateName}",
    paginator = list()
  )
  input <- .iot$delete_provisioning_template_input(templateName = templateName)
  output <- .iot$delete_provisioning_template_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_provisioning_template <- iot_delete_provisioning_template

#' Deletes a fleet provisioning template version
#'
#' @description
#' Deletes a fleet provisioning template version.
#'
#' @usage
#' iot_delete_provisioning_template_version(templateName, versionId)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template version to delete.
#' @param versionId &#91;required&#93; The fleet provisioning template version ID to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_provisioning_template_version(
#'   templateName = "string",
#'   versionId = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_provisioning_template_version
iot_delete_provisioning_template_version <- function(templateName, versionId) {
  op <- new_operation(
    name = "DeleteProvisioningTemplateVersion",
    http_method = "DELETE",
    http_path = "/provisioning-templates/{templateName}/versions/{versionId}",
    paginator = list()
  )
  input <- .iot$delete_provisioning_template_version_input(templateName = templateName, versionId = versionId)
  output <- .iot$delete_provisioning_template_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_provisioning_template_version <- iot_delete_provisioning_template_version

#' Deletes a CA certificate registration code
#'
#' @description
#' Deletes a CA certificate registration code.
#'
#' @usage
#' iot_delete_registration_code()
#'
#' @section Request syntax:
#' ```
#' svc$delete_registration_code()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_registration_code
iot_delete_registration_code <- function() {
  op <- new_operation(
    name = "DeleteRegistrationCode",
    http_method = "DELETE",
    http_path = "/registrationcode",
    paginator = list()
  )
  input <- .iot$delete_registration_code_input()
  output <- .iot$delete_registration_code_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_registration_code <- iot_delete_registration_code

#' Deletes a role alias
#'
#' @description
#' Deletes a role alias
#'
#' @usage
#' iot_delete_role_alias(roleAlias)
#'
#' @param roleAlias &#91;required&#93; The role alias to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_role_alias(
#'   roleAlias = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_role_alias
iot_delete_role_alias <- function(roleAlias) {
  op <- new_operation(
    name = "DeleteRoleAlias",
    http_method = "DELETE",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$delete_role_alias_input(roleAlias = roleAlias)
  output <- .iot$delete_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_role_alias <- iot_delete_role_alias

#' Deletes a scheduled audit
#'
#' @description
#' Deletes a scheduled audit.
#'
#' @usage
#' iot_delete_scheduled_audit(scheduledAuditName)
#'
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit you want to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_scheduled_audit(
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_scheduled_audit
iot_delete_scheduled_audit <- function(scheduledAuditName) {
  op <- new_operation(
    name = "DeleteScheduledAudit",
    http_method = "DELETE",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$delete_scheduled_audit_input(scheduledAuditName = scheduledAuditName)
  output <- .iot$delete_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_scheduled_audit <- iot_delete_scheduled_audit

#' Deletes a Device Defender security profile
#'
#' @description
#' Deletes a Device Defender security profile.
#'
#' @usage
#' iot_delete_security_profile(securityProfileName, expectedVersion)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile to be deleted.
#' @param expectedVersion The expected version of the security profile. A new version is generated
#' whenever the security profile is updated. If you specify a value that is
#' different from the actual version, a `VersionConflictException` is
#' thrown.
#'
#' @section Request syntax:
#' ```
#' svc$delete_security_profile(
#'   securityProfileName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_security_profile
iot_delete_security_profile <- function(securityProfileName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteSecurityProfile",
    http_method = "DELETE",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$delete_security_profile_input(securityProfileName = securityProfileName, expectedVersion = expectedVersion)
  output <- .iot$delete_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_security_profile <- iot_delete_security_profile

#' Deletes a stream
#'
#' @description
#' Deletes a stream.
#'
#' @usage
#' iot_delete_stream(streamId)
#'
#' @param streamId &#91;required&#93; The stream ID.
#'
#' @section Request syntax:
#' ```
#' svc$delete_stream(
#'   streamId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_stream
iot_delete_stream <- function(streamId) {
  op <- new_operation(
    name = "DeleteStream",
    http_method = "DELETE",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$delete_stream_input(streamId = streamId)
  output <- .iot$delete_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_stream <- iot_delete_stream

#' Deletes the specified thing
#'
#' @description
#' Deletes the specified thing. Returns successfully with no error if the
#' deletion is successful or you specify a thing that doesn't exist.
#'
#' @usage
#' iot_delete_thing(thingName, expectedVersion)
#'
#' @param thingName &#91;required&#93; The name of the thing to delete.
#' @param expectedVersion The expected version of the thing record in the registry. If the version
#' of the record in the registry does not match the expected version
#' specified in the request, the [`delete_thing`][iot_delete_thing] request
#' is rejected with a `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing(
#'   thingName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing
iot_delete_thing <- function(thingName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteThing",
    http_method = "DELETE",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$delete_thing_input(thingName = thingName, expectedVersion = expectedVersion)
  output <- .iot$delete_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing <- iot_delete_thing

#' Deletes a thing group
#'
#' @description
#' Deletes a thing group.
#'
#' @usage
#' iot_delete_thing_group(thingGroupName, expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the thing group to delete.
#' @param expectedVersion The expected version of the thing group to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing_group(
#'   thingGroupName = "string",
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing_group
iot_delete_thing_group <- function(thingGroupName, expectedVersion = NULL) {
  op <- new_operation(
    name = "DeleteThingGroup",
    http_method = "DELETE",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$delete_thing_group_input(thingGroupName = thingGroupName, expectedVersion = expectedVersion)
  output <- .iot$delete_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing_group <- iot_delete_thing_group

#' Deletes the specified thing type
#'
#' @description
#' Deletes the specified thing type. You cannot delete a thing type if it
#' has things associated with it. To delete a thing type, first mark it as
#' deprecated by calling
#' [`deprecate_thing_type`][iot_deprecate_thing_type], then remove any
#' associated things by calling [`update_thing`][iot_update_thing] to
#' change the thing type on any associated thing, and finally use
#' [`delete_thing_type`][iot_delete_thing_type] to delete the thing type.
#'
#' @usage
#' iot_delete_thing_type(thingTypeName)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$delete_thing_type(
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_thing_type
iot_delete_thing_type <- function(thingTypeName) {
  op <- new_operation(
    name = "DeleteThingType",
    http_method = "DELETE",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$delete_thing_type_input(thingTypeName = thingTypeName)
  output <- .iot$delete_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_thing_type <- iot_delete_thing_type

#' Deletes the rule
#'
#' @description
#' Deletes the rule.
#'
#' @usage
#' iot_delete_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#'
#' @section Request syntax:
#' ```
#' svc$delete_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_topic_rule
iot_delete_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "DeleteTopicRule",
    http_method = "DELETE",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$delete_topic_rule_input(ruleName = ruleName)
  output <- .iot$delete_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_topic_rule <- iot_delete_topic_rule

#' Deletes a topic rule destination
#'
#' @description
#' Deletes a topic rule destination.
#'
#' @usage
#' iot_delete_topic_rule_destination(arn)
#'
#' @param arn &#91;required&#93; The ARN of the topic rule destination to delete.
#'
#' @section Request syntax:
#' ```
#' svc$delete_topic_rule_destination(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_topic_rule_destination
iot_delete_topic_rule_destination <- function(arn) {
  op <- new_operation(
    name = "DeleteTopicRuleDestination",
    http_method = "DELETE",
    http_path = "/destinations/{arn+}",
    paginator = list()
  )
  input <- .iot$delete_topic_rule_destination_input(arn = arn)
  output <- .iot$delete_topic_rule_destination_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_topic_rule_destination <- iot_delete_topic_rule_destination

#' Deletes a logging level
#'
#' @description
#' Deletes a logging level.
#'
#' @usage
#' iot_delete_v2_logging_level(targetType, targetName)
#'
#' @param targetType &#91;required&#93; The type of resource for which you are configuring logging. Must be
#' `THING_Group`.
#' @param targetName &#91;required&#93; The name of the resource for which you are configuring logging.
#'
#' @section Request syntax:
#' ```
#' svc$delete_v2_logging_level(
#'   targetType = "DEFAULT"|"THING_GROUP",
#'   targetName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_delete_v2_logging_level
iot_delete_v2_logging_level <- function(targetType, targetName) {
  op <- new_operation(
    name = "DeleteV2LoggingLevel",
    http_method = "DELETE",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$delete_v2_logging_level_input(targetType = targetType, targetName = targetName)
  output <- .iot$delete_v2_logging_level_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$delete_v2_logging_level <- iot_delete_v2_logging_level

#' Deprecates a thing type
#'
#' @description
#' Deprecates a thing type. You can not associate new things with
#' deprecated thing type.
#'
#' @usage
#' iot_deprecate_thing_type(thingTypeName, undoDeprecate)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type to deprecate.
#' @param undoDeprecate Whether to undeprecate a deprecated thing type. If **true**, the thing
#' type will not be deprecated anymore and you can associate it with
#' things.
#'
#' @section Request syntax:
#' ```
#' svc$deprecate_thing_type(
#'   thingTypeName = "string",
#'   undoDeprecate = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_deprecate_thing_type
iot_deprecate_thing_type <- function(thingTypeName, undoDeprecate = NULL) {
  op <- new_operation(
    name = "DeprecateThingType",
    http_method = "POST",
    http_path = "/thing-types/{thingTypeName}/deprecate",
    paginator = list()
  )
  input <- .iot$deprecate_thing_type_input(thingTypeName = thingTypeName, undoDeprecate = undoDeprecate)
  output <- .iot$deprecate_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$deprecate_thing_type <- iot_deprecate_thing_type

#' Gets information about the Device Defender audit settings for this
#' account
#'
#' @description
#' Gets information about the Device Defender audit settings for this
#' account. Settings include how audit notifications are sent and which
#' audit checks are enabled or disabled.
#'
#' @usage
#' iot_describe_account_audit_configuration()
#'
#' @section Request syntax:
#' ```
#' svc$describe_account_audit_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_account_audit_configuration
iot_describe_account_audit_configuration <- function() {
  op <- new_operation(
    name = "DescribeAccountAuditConfiguration",
    http_method = "GET",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$describe_account_audit_configuration_input()
  output <- .iot$describe_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_account_audit_configuration <- iot_describe_account_audit_configuration

#' Gets information about a single audit finding
#'
#' @description
#' Gets information about a single audit finding. Properties include the
#' reason for noncompliance, the severity of the issue, and the start time
#' when the audit that returned the finding.
#'
#' @usage
#' iot_describe_audit_finding(findingId)
#'
#' @param findingId &#91;required&#93; A unique identifier for a single audit finding. You can use this
#' identifier to apply mitigation actions to the finding.
#'
#' @section Request syntax:
#' ```
#' svc$describe_audit_finding(
#'   findingId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_audit_finding
iot_describe_audit_finding <- function(findingId) {
  op <- new_operation(
    name = "DescribeAuditFinding",
    http_method = "GET",
    http_path = "/audit/findings/{findingId}",
    paginator = list()
  )
  input <- .iot$describe_audit_finding_input(findingId = findingId)
  output <- .iot$describe_audit_finding_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_audit_finding <- iot_describe_audit_finding

#' Gets information about an audit mitigation task that is used to apply
#' mitigation actions to a set of audit findings
#'
#' @description
#' Gets information about an audit mitigation task that is used to apply
#' mitigation actions to a set of audit findings. Properties include the
#' actions being applied, the audit checks to which they're being applied,
#' the task status, and aggregated task statistics.
#'
#' @usage
#' iot_describe_audit_mitigation_actions_task(taskId)
#'
#' @param taskId &#91;required&#93; The unique identifier for the audit mitigation task.
#'
#' @section Request syntax:
#' ```
#' svc$describe_audit_mitigation_actions_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_audit_mitigation_actions_task
iot_describe_audit_mitigation_actions_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeAuditMitigationActionsTask",
    http_method = "GET",
    http_path = "/audit/mitigationactions/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_audit_mitigation_actions_task_input(taskId = taskId)
  output <- .iot$describe_audit_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_audit_mitigation_actions_task <- iot_describe_audit_mitigation_actions_task

#' Gets information about a Device Defender audit suppression
#'
#' @description
#' Gets information about a Device Defender audit suppression.
#'
#' @usage
#' iot_describe_audit_suppression(checkName, resourceIdentifier)
#'
#' @param checkName &#91;required&#93; 
#' @param resourceIdentifier &#91;required&#93; 
#'
#' @section Request syntax:
#' ```
#' svc$describe_audit_suppression(
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_audit_suppression
iot_describe_audit_suppression <- function(checkName, resourceIdentifier) {
  op <- new_operation(
    name = "DescribeAuditSuppression",
    http_method = "POST",
    http_path = "/audit/suppressions/describe",
    paginator = list()
  )
  input <- .iot$describe_audit_suppression_input(checkName = checkName, resourceIdentifier = resourceIdentifier)
  output <- .iot$describe_audit_suppression_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_audit_suppression <- iot_describe_audit_suppression

#' Gets information about a Device Defender audit
#'
#' @description
#' Gets information about a Device Defender audit.
#'
#' @usage
#' iot_describe_audit_task(taskId)
#'
#' @param taskId &#91;required&#93; The ID of the audit whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_audit_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_audit_task
iot_describe_audit_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeAuditTask",
    http_method = "GET",
    http_path = "/audit/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_audit_task_input(taskId = taskId)
  output <- .iot$describe_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_audit_task <- iot_describe_audit_task

#' Describes an authorizer
#'
#' @description
#' Describes an authorizer.
#'
#' @usage
#' iot_describe_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The name of the authorizer to describe.
#'
#' @section Request syntax:
#' ```
#' svc$describe_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_authorizer
iot_describe_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "DescribeAuthorizer",
    http_method = "GET",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$describe_authorizer_input(authorizerName = authorizerName)
  output <- .iot$describe_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_authorizer <- iot_describe_authorizer

#' Returns information about a billing group
#'
#' @description
#' Returns information about a billing group.
#'
#' @usage
#' iot_describe_billing_group(billingGroupName)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$describe_billing_group(
#'   billingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_billing_group
iot_describe_billing_group <- function(billingGroupName) {
  op <- new_operation(
    name = "DescribeBillingGroup",
    http_method = "GET",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$describe_billing_group_input(billingGroupName = billingGroupName)
  output <- .iot$describe_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_billing_group <- iot_describe_billing_group

#' Describes a registered CA certificate
#'
#' @description
#' Describes a registered CA certificate.
#'
#' @usage
#' iot_describe_ca_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The CA certificate identifier.
#'
#' @section Request syntax:
#' ```
#' svc$describe_ca_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_ca_certificate
iot_describe_ca_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DescribeCACertificate",
    http_method = "GET",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$describe_ca_certificate_input(certificateId = certificateId)
  output <- .iot$describe_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_ca_certificate <- iot_describe_ca_certificate

#' Gets information about the specified certificate
#'
#' @description
#' Gets information about the specified certificate.
#'
#' @usage
#' iot_describe_certificate(certificateId)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#'
#' @section Request syntax:
#' ```
#' svc$describe_certificate(
#'   certificateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_certificate
iot_describe_certificate <- function(certificateId) {
  op <- new_operation(
    name = "DescribeCertificate",
    http_method = "GET",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$describe_certificate_input(certificateId = certificateId)
  output <- .iot$describe_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_certificate <- iot_describe_certificate

#' Gets information about a Device Defender detect custom metric
#'
#' @description
#' Gets information about a Device Defender detect custom metric.
#'
#' @usage
#' iot_describe_custom_metric(metricName)
#'
#' @param metricName &#91;required&#93; The name of the custom metric.
#'
#' @section Request syntax:
#' ```
#' svc$describe_custom_metric(
#'   metricName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_custom_metric
iot_describe_custom_metric <- function(metricName) {
  op <- new_operation(
    name = "DescribeCustomMetric",
    http_method = "GET",
    http_path = "/custom-metric/{metricName}",
    paginator = list()
  )
  input <- .iot$describe_custom_metric_input(metricName = metricName)
  output <- .iot$describe_custom_metric_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_custom_metric <- iot_describe_custom_metric

#' Describes the default authorizer
#'
#' @description
#' Describes the default authorizer.
#'
#' @usage
#' iot_describe_default_authorizer()
#'
#' @section Request syntax:
#' ```
#' svc$describe_default_authorizer()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_default_authorizer
iot_describe_default_authorizer <- function() {
  op <- new_operation(
    name = "DescribeDefaultAuthorizer",
    http_method = "GET",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$describe_default_authorizer_input()
  output <- .iot$describe_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_default_authorizer <- iot_describe_default_authorizer

#' Gets information about a Device Defender ML Detect mitigation action
#'
#' @description
#' Gets information about a Device Defender ML Detect mitigation action.
#'
#' @usage
#' iot_describe_detect_mitigation_actions_task(taskId)
#'
#' @param taskId &#91;required&#93; The unique identifier of the task.
#'
#' @section Request syntax:
#' ```
#' svc$describe_detect_mitigation_actions_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_detect_mitigation_actions_task
iot_describe_detect_mitigation_actions_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeDetectMitigationActionsTask",
    http_method = "GET",
    http_path = "/detect/mitigationactions/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_detect_mitigation_actions_task_input(taskId = taskId)
  output <- .iot$describe_detect_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_detect_mitigation_actions_task <- iot_describe_detect_mitigation_actions_task

#' Provides details about a dimension that is defined in your AWS account
#'
#' @description
#' Provides details about a dimension that is defined in your AWS account.
#'
#' @usage
#' iot_describe_dimension(name)
#'
#' @param name &#91;required&#93; The unique identifier for the dimension.
#'
#' @section Request syntax:
#' ```
#' svc$describe_dimension(
#'   name = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_dimension
iot_describe_dimension <- function(name) {
  op <- new_operation(
    name = "DescribeDimension",
    http_method = "GET",
    http_path = "/dimensions/{name}",
    paginator = list()
  )
  input <- .iot$describe_dimension_input(name = name)
  output <- .iot$describe_dimension_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_dimension <- iot_describe_dimension

#' Gets summary information about a domain configuration
#'
#' @description
#' Gets summary information about a domain configuration.
#' 
#' The domain configuration feature is in public preview and is subject to
#' change.
#'
#' @usage
#' iot_describe_domain_configuration(domainConfigurationName)
#'
#' @param domainConfigurationName &#91;required&#93; The name of the domain configuration.
#'
#' @section Request syntax:
#' ```
#' svc$describe_domain_configuration(
#'   domainConfigurationName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_domain_configuration
iot_describe_domain_configuration <- function(domainConfigurationName) {
  op <- new_operation(
    name = "DescribeDomainConfiguration",
    http_method = "GET",
    http_path = "/domainConfigurations/{domainConfigurationName}",
    paginator = list()
  )
  input <- .iot$describe_domain_configuration_input(domainConfigurationName = domainConfigurationName)
  output <- .iot$describe_domain_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_domain_configuration <- iot_describe_domain_configuration

#' Returns a unique endpoint specific to the AWS account making the call
#'
#' @description
#' Returns a unique endpoint specific to the AWS account making the call.
#'
#' @usage
#' iot_describe_endpoint(endpointType)
#'
#' @param endpointType The endpoint type. Valid endpoint types include:
#' 
#' -   `iot:Data` - Returns a VeriSign signed data endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:Data-ATS` - Returns an ATS signed data endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:CredentialProvider` - Returns an AWS IoT credentials provider
#'     API endpoint.
#' 
#' <!-- -->
#' 
#' -   `iot:Jobs` - Returns an AWS IoT device management Jobs API endpoint.
#' 
#' We strongly recommend that customers use the newer `iot:Data-ATS`
#' endpoint type to avoid issues related to the widespread distrust of
#' Symantec certificate authorities.
#'
#' @section Request syntax:
#' ```
#' svc$describe_endpoint(
#'   endpointType = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_endpoint
iot_describe_endpoint <- function(endpointType = NULL) {
  op <- new_operation(
    name = "DescribeEndpoint",
    http_method = "GET",
    http_path = "/endpoint",
    paginator = list()
  )
  input <- .iot$describe_endpoint_input(endpointType = endpointType)
  output <- .iot$describe_endpoint_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_endpoint <- iot_describe_endpoint

#' Describes event configurations
#'
#' @description
#' Describes event configurations.
#'
#' @usage
#' iot_describe_event_configurations()
#'
#' @section Request syntax:
#' ```
#' svc$describe_event_configurations()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_event_configurations
iot_describe_event_configurations <- function() {
  op <- new_operation(
    name = "DescribeEventConfigurations",
    http_method = "GET",
    http_path = "/event-configurations",
    paginator = list()
  )
  input <- .iot$describe_event_configurations_input()
  output <- .iot$describe_event_configurations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_event_configurations <- iot_describe_event_configurations

#' Describes a search index
#'
#' @description
#' Describes a search index.
#'
#' @usage
#' iot_describe_index(indexName)
#'
#' @param indexName &#91;required&#93; The index name.
#'
#' @section Request syntax:
#' ```
#' svc$describe_index(
#'   indexName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_index
iot_describe_index <- function(indexName) {
  op <- new_operation(
    name = "DescribeIndex",
    http_method = "GET",
    http_path = "/indices/{indexName}",
    paginator = list()
  )
  input <- .iot$describe_index_input(indexName = indexName)
  output <- .iot$describe_index_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_index <- iot_describe_index

#' Describes a job
#'
#' @description
#' Describes a job.
#'
#' @usage
#' iot_describe_job(jobId)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#'
#' @section Request syntax:
#' ```
#' svc$describe_job(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_job
iot_describe_job <- function(jobId) {
  op <- new_operation(
    name = "DescribeJob",
    http_method = "GET",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$describe_job_input(jobId = jobId)
  output <- .iot$describe_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_job <- iot_describe_job

#' Describes a job execution
#'
#' @description
#' Describes a job execution.
#'
#' @usage
#' iot_describe_job_execution(jobId, thingName, executionNumber)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param thingName &#91;required&#93; The name of the thing on which the job execution is running.
#' @param executionNumber A string (consisting of the digits "0" through "9" which is used to
#' specify a particular job execution on a particular device.
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_execution(
#'   jobId = "string",
#'   thingName = "string",
#'   executionNumber = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_job_execution
iot_describe_job_execution <- function(jobId, thingName, executionNumber = NULL) {
  op <- new_operation(
    name = "DescribeJobExecution",
    http_method = "GET",
    http_path = "/things/{thingName}/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$describe_job_execution_input(jobId = jobId, thingName = thingName, executionNumber = executionNumber)
  output <- .iot$describe_job_execution_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_job_execution <- iot_describe_job_execution

#' Gets information about a mitigation action
#'
#' @description
#' Gets information about a mitigation action.
#'
#' @usage
#' iot_describe_mitigation_action(actionName)
#'
#' @param actionName &#91;required&#93; The friendly name that uniquely identifies the mitigation action.
#'
#' @section Request syntax:
#' ```
#' svc$describe_mitigation_action(
#'   actionName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_mitigation_action
iot_describe_mitigation_action <- function(actionName) {
  op <- new_operation(
    name = "DescribeMitigationAction",
    http_method = "GET",
    http_path = "/mitigationactions/actions/{actionName}",
    paginator = list()
  )
  input <- .iot$describe_mitigation_action_input(actionName = actionName)
  output <- .iot$describe_mitigation_action_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_mitigation_action <- iot_describe_mitigation_action

#' Returns information about a fleet provisioning template
#'
#' @description
#' Returns information about a fleet provisioning template.
#'
#' @usage
#' iot_describe_provisioning_template(templateName)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template.
#'
#' @section Request syntax:
#' ```
#' svc$describe_provisioning_template(
#'   templateName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_provisioning_template
iot_describe_provisioning_template <- function(templateName) {
  op <- new_operation(
    name = "DescribeProvisioningTemplate",
    http_method = "GET",
    http_path = "/provisioning-templates/{templateName}",
    paginator = list()
  )
  input <- .iot$describe_provisioning_template_input(templateName = templateName)
  output <- .iot$describe_provisioning_template_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_provisioning_template <- iot_describe_provisioning_template

#' Returns information about a fleet provisioning template version
#'
#' @description
#' Returns information about a fleet provisioning template version.
#'
#' @usage
#' iot_describe_provisioning_template_version(templateName, versionId)
#'
#' @param templateName &#91;required&#93; The template name.
#' @param versionId &#91;required&#93; The fleet provisioning template version ID.
#'
#' @section Request syntax:
#' ```
#' svc$describe_provisioning_template_version(
#'   templateName = "string",
#'   versionId = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_provisioning_template_version
iot_describe_provisioning_template_version <- function(templateName, versionId) {
  op <- new_operation(
    name = "DescribeProvisioningTemplateVersion",
    http_method = "GET",
    http_path = "/provisioning-templates/{templateName}/versions/{versionId}",
    paginator = list()
  )
  input <- .iot$describe_provisioning_template_version_input(templateName = templateName, versionId = versionId)
  output <- .iot$describe_provisioning_template_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_provisioning_template_version <- iot_describe_provisioning_template_version

#' Describes a role alias
#'
#' @description
#' Describes a role alias.
#'
#' @usage
#' iot_describe_role_alias(roleAlias)
#'
#' @param roleAlias &#91;required&#93; The role alias to describe.
#'
#' @section Request syntax:
#' ```
#' svc$describe_role_alias(
#'   roleAlias = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_role_alias
iot_describe_role_alias <- function(roleAlias) {
  op <- new_operation(
    name = "DescribeRoleAlias",
    http_method = "GET",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$describe_role_alias_input(roleAlias = roleAlias)
  output <- .iot$describe_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_role_alias <- iot_describe_role_alias

#' Gets information about a scheduled audit
#'
#' @description
#' Gets information about a scheduled audit.
#'
#' @usage
#' iot_describe_scheduled_audit(scheduledAuditName)
#'
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_scheduled_audit(
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_scheduled_audit
iot_describe_scheduled_audit <- function(scheduledAuditName) {
  op <- new_operation(
    name = "DescribeScheduledAudit",
    http_method = "GET",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$describe_scheduled_audit_input(scheduledAuditName = scheduledAuditName)
  output <- .iot$describe_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_scheduled_audit <- iot_describe_scheduled_audit

#' Gets information about a Device Defender security profile
#'
#' @description
#' Gets information about a Device Defender security profile.
#'
#' @usage
#' iot_describe_security_profile(securityProfileName)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile whose information you want to get.
#'
#' @section Request syntax:
#' ```
#' svc$describe_security_profile(
#'   securityProfileName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_security_profile
iot_describe_security_profile <- function(securityProfileName) {
  op <- new_operation(
    name = "DescribeSecurityProfile",
    http_method = "GET",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$describe_security_profile_input(securityProfileName = securityProfileName)
  output <- .iot$describe_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_security_profile <- iot_describe_security_profile

#' Gets information about a stream
#'
#' @description
#' Gets information about a stream.
#'
#' @usage
#' iot_describe_stream(streamId)
#'
#' @param streamId &#91;required&#93; The stream ID.
#'
#' @section Request syntax:
#' ```
#' svc$describe_stream(
#'   streamId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_stream
iot_describe_stream <- function(streamId) {
  op <- new_operation(
    name = "DescribeStream",
    http_method = "GET",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$describe_stream_input(streamId = streamId)
  output <- .iot$describe_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_stream <- iot_describe_stream

#' Gets information about the specified thing
#'
#' @description
#' Gets information about the specified thing.
#'
#' @usage
#' iot_describe_thing(thingName)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing(
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing
iot_describe_thing <- function(thingName) {
  op <- new_operation(
    name = "DescribeThing",
    http_method = "GET",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$describe_thing_input(thingName = thingName)
  output <- .iot$describe_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing <- iot_describe_thing

#' Describe a thing group
#'
#' @description
#' Describe a thing group.
#'
#' @usage
#' iot_describe_thing_group(thingGroupName)
#'
#' @param thingGroupName &#91;required&#93; The name of the thing group.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_group(
#'   thingGroupName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_group
iot_describe_thing_group <- function(thingGroupName) {
  op <- new_operation(
    name = "DescribeThingGroup",
    http_method = "GET",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$describe_thing_group_input(thingGroupName = thingGroupName)
  output <- .iot$describe_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_group <- iot_describe_thing_group

#' Describes a bulk thing provisioning task
#'
#' @description
#' Describes a bulk thing provisioning task.
#'
#' @usage
#' iot_describe_thing_registration_task(taskId)
#'
#' @param taskId &#91;required&#93; The task ID.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_registration_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_registration_task
iot_describe_thing_registration_task <- function(taskId) {
  op <- new_operation(
    name = "DescribeThingRegistrationTask",
    http_method = "GET",
    http_path = "/thing-registration-tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$describe_thing_registration_task_input(taskId = taskId)
  output <- .iot$describe_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_registration_task <- iot_describe_thing_registration_task

#' Gets information about the specified thing type
#'
#' @description
#' Gets information about the specified thing type.
#'
#' @usage
#' iot_describe_thing_type(thingTypeName)
#'
#' @param thingTypeName &#91;required&#93; The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$describe_thing_type(
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_describe_thing_type
iot_describe_thing_type <- function(thingTypeName) {
  op <- new_operation(
    name = "DescribeThingType",
    http_method = "GET",
    http_path = "/thing-types/{thingTypeName}",
    paginator = list()
  )
  input <- .iot$describe_thing_type_input(thingTypeName = thingTypeName)
  output <- .iot$describe_thing_type_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$describe_thing_type <- iot_describe_thing_type

#' Detaches a policy from the specified target
#'
#' @description
#' Detaches a policy from the specified target.
#'
#' @usage
#' iot_detach_policy(policyName, target)
#'
#' @param policyName &#91;required&#93; The policy to detach.
#' @param target &#91;required&#93; The target from which the policy will be detached.
#'
#' @section Request syntax:
#' ```
#' svc$detach_policy(
#'   policyName = "string",
#'   target = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_policy
iot_detach_policy <- function(policyName, target) {
  op <- new_operation(
    name = "DetachPolicy",
    http_method = "POST",
    http_path = "/target-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$detach_policy_input(policyName = policyName, target = target)
  output <- .iot$detach_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_policy <- iot_detach_policy

#' Removes the specified policy from the specified certificate
#'
#' @description
#' Removes the specified policy from the specified certificate.
#' 
#' **Note:** This API is deprecated. Please use
#' [`detach_policy`][iot_detach_policy] instead.
#'
#' @usage
#' iot_detach_principal_policy(policyName, principal)
#'
#' @param policyName &#91;required&#93; The name of the policy to detach.
#' @param principal &#91;required&#93; The principal.
#' 
#' Valid principals are CertificateArn
#' (arn:aws:iot:*region*:*accountId*:cert/*certificateId*), thingGroupArn
#' (arn:aws:iot:*region*:*accountId*:thinggroup/*groupName*) and CognitoId
#' (*region*:*id*).
#'
#' @section Request syntax:
#' ```
#' svc$detach_principal_policy(
#'   policyName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_principal_policy
iot_detach_principal_policy <- function(policyName, principal) {
  op <- new_operation(
    name = "DetachPrincipalPolicy",
    http_method = "DELETE",
    http_path = "/principal-policies/{policyName}",
    paginator = list()
  )
  input <- .iot$detach_principal_policy_input(policyName = policyName, principal = principal)
  output <- .iot$detach_principal_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_principal_policy <- iot_detach_principal_policy

#' Disassociates a Device Defender security profile from a thing group or
#' from this account
#'
#' @description
#' Disassociates a Device Defender security profile from a thing group or
#' from this account.
#'
#' @usage
#' iot_detach_security_profile(securityProfileName,
#'   securityProfileTargetArn)
#'
#' @param securityProfileName &#91;required&#93; The security profile that is detached.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the thing group from which the security profile is detached.
#'
#' @section Request syntax:
#' ```
#' svc$detach_security_profile(
#'   securityProfileName = "string",
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_security_profile
iot_detach_security_profile <- function(securityProfileName, securityProfileTargetArn) {
  op <- new_operation(
    name = "DetachSecurityProfile",
    http_method = "DELETE",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$detach_security_profile_input(securityProfileName = securityProfileName, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$detach_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_security_profile <- iot_detach_security_profile

#' Detaches the specified principal from the specified thing
#'
#' @description
#' Detaches the specified principal from the specified thing. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#' 
#' This call is asynchronous. It might take several seconds for the
#' detachment to propagate.
#'
#' @usage
#' iot_detach_thing_principal(thingName, principal)
#'
#' @param thingName &#91;required&#93; The name of the thing.
#' @param principal &#91;required&#93; If the principal is a certificate, this value must be ARN of the
#' certificate. If the principal is an Amazon Cognito identity, this value
#' must be the ID of the Amazon Cognito identity.
#'
#' @section Request syntax:
#' ```
#' svc$detach_thing_principal(
#'   thingName = "string",
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_detach_thing_principal
iot_detach_thing_principal <- function(thingName, principal) {
  op <- new_operation(
    name = "DetachThingPrincipal",
    http_method = "DELETE",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$detach_thing_principal_input(thingName = thingName, principal = principal)
  output <- .iot$detach_thing_principal_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$detach_thing_principal <- iot_detach_thing_principal

#' Disables the rule
#'
#' @description
#' Disables the rule.
#'
#' @usage
#' iot_disable_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule to disable.
#'
#' @section Request syntax:
#' ```
#' svc$disable_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_disable_topic_rule
iot_disable_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "DisableTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}/disable",
    paginator = list()
  )
  input <- .iot$disable_topic_rule_input(ruleName = ruleName)
  output <- .iot$disable_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$disable_topic_rule <- iot_disable_topic_rule

#' Enables the rule
#'
#' @description
#' Enables the rule.
#'
#' @usage
#' iot_enable_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the topic rule to enable.
#'
#' @section Request syntax:
#' ```
#' svc$enable_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_enable_topic_rule
iot_enable_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "EnableTopicRule",
    http_method = "POST",
    http_path = "/rules/{ruleName}/enable",
    paginator = list()
  )
  input <- .iot$enable_topic_rule_input(ruleName = ruleName)
  output <- .iot$enable_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$enable_topic_rule <- iot_enable_topic_rule

#' Returns a Device Defender's ML Detect Security Profile training model's
#' status
#'
#' @description
#' Returns a Device Defender's ML Detect Security Profile training model's
#' status.
#'
#' @usage
#' iot_get_behavior_model_training_summaries(securityProfileName,
#'   maxResults, nextToken)
#'
#' @param securityProfileName The name of the security profile.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$get_behavior_model_training_summaries(
#'   securityProfileName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_behavior_model_training_summaries
iot_get_behavior_model_training_summaries <- function(securityProfileName = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "GetBehaviorModelTrainingSummaries",
    http_method = "GET",
    http_path = "/behavior-model-training/summaries",
    paginator = list()
  )
  input <- .iot$get_behavior_model_training_summaries_input(securityProfileName = securityProfileName, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$get_behavior_model_training_summaries_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_behavior_model_training_summaries <- iot_get_behavior_model_training_summaries

#' Returns the approximate count of unique values that match the query
#'
#' @description
#' Returns the approximate count of unique values that match the query.
#'
#' @usage
#' iot_get_cardinality(indexName, queryString, aggregationField,
#'   queryVersion)
#'
#' @param indexName The name of the index to search.
#' @param queryString &#91;required&#93; The search query.
#' @param aggregationField The field to aggregate.
#' @param queryVersion The query version.
#'
#' @section Request syntax:
#' ```
#' svc$get_cardinality(
#'   indexName = "string",
#'   queryString = "string",
#'   aggregationField = "string",
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_cardinality
iot_get_cardinality <- function(indexName = NULL, queryString, aggregationField = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "GetCardinality",
    http_method = "POST",
    http_path = "/indices/cardinality",
    paginator = list()
  )
  input <- .iot$get_cardinality_input(indexName = indexName, queryString = queryString, aggregationField = aggregationField, queryVersion = queryVersion)
  output <- .iot$get_cardinality_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_cardinality <- iot_get_cardinality

#' Gets a list of the policies that have an effect on the authorization
#' behavior of the specified device when it connects to the AWS IoT device
#' gateway
#'
#' @description
#' Gets a list of the policies that have an effect on the authorization
#' behavior of the specified device when it connects to the AWS IoT device
#' gateway.
#'
#' @usage
#' iot_get_effective_policies(principal, cognitoIdentityPoolId, thingName)
#'
#' @param principal The principal. Valid principals are CertificateArn
#' (arn:aws:iot:*region*:*accountId*:cert/*certificateId*), thingGroupArn
#' (arn:aws:iot:*region*:*accountId*:thinggroup/*groupName*) and CognitoId
#' (*region*:*id*).
#' @param cognitoIdentityPoolId The Cognito identity pool ID.
#' @param thingName The thing name.
#'
#' @section Request syntax:
#' ```
#' svc$get_effective_policies(
#'   principal = "string",
#'   cognitoIdentityPoolId = "string",
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_effective_policies
iot_get_effective_policies <- function(principal = NULL, cognitoIdentityPoolId = NULL, thingName = NULL) {
  op <- new_operation(
    name = "GetEffectivePolicies",
    http_method = "POST",
    http_path = "/effective-policies",
    paginator = list()
  )
  input <- .iot$get_effective_policies_input(principal = principal, cognitoIdentityPoolId = cognitoIdentityPoolId, thingName = thingName)
  output <- .iot$get_effective_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_effective_policies <- iot_get_effective_policies

#' Gets the indexing configuration
#'
#' @description
#' Gets the indexing configuration.
#'
#' @usage
#' iot_get_indexing_configuration()
#'
#' @section Request syntax:
#' ```
#' svc$get_indexing_configuration()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_indexing_configuration
iot_get_indexing_configuration <- function() {
  op <- new_operation(
    name = "GetIndexingConfiguration",
    http_method = "GET",
    http_path = "/indexing/config",
    paginator = list()
  )
  input <- .iot$get_indexing_configuration_input()
  output <- .iot$get_indexing_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_indexing_configuration <- iot_get_indexing_configuration

#' Gets a job document
#'
#' @description
#' Gets a job document.
#'
#' @usage
#' iot_get_job_document(jobId)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#'
#' @section Request syntax:
#' ```
#' svc$get_job_document(
#'   jobId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_job_document
iot_get_job_document <- function(jobId) {
  op <- new_operation(
    name = "GetJobDocument",
    http_method = "GET",
    http_path = "/jobs/{jobId}/job-document",
    paginator = list()
  )
  input <- .iot$get_job_document_input(jobId = jobId)
  output <- .iot$get_job_document_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_job_document <- iot_get_job_document

#' Gets the logging options
#'
#' @description
#' Gets the logging options.
#' 
#' NOTE: use of this command is not recommended. Use
#' [`get_v2_logging_options`][iot_get_v2_logging_options] instead.
#'
#' @usage
#' iot_get_logging_options()
#'
#' @section Request syntax:
#' ```
#' svc$get_logging_options()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_logging_options
iot_get_logging_options <- function() {
  op <- new_operation(
    name = "GetLoggingOptions",
    http_method = "GET",
    http_path = "/loggingOptions",
    paginator = list()
  )
  input <- .iot$get_logging_options_input()
  output <- .iot$get_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_logging_options <- iot_get_logging_options

#' Gets an OTA update
#'
#' @description
#' Gets an OTA update.
#'
#' @usage
#' iot_get_ota_update(otaUpdateId)
#'
#' @param otaUpdateId &#91;required&#93; The OTA update ID.
#'
#' @section Request syntax:
#' ```
#' svc$get_ota_update(
#'   otaUpdateId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_ota_update
iot_get_ota_update <- function(otaUpdateId) {
  op <- new_operation(
    name = "GetOTAUpdate",
    http_method = "GET",
    http_path = "/otaUpdates/{otaUpdateId}",
    paginator = list()
  )
  input <- .iot$get_ota_update_input(otaUpdateId = otaUpdateId)
  output <- .iot$get_ota_update_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_ota_update <- iot_get_ota_update

#' Groups the aggregated values that match the query into percentile
#' groupings
#'
#' @description
#' Groups the aggregated values that match the query into percentile
#' groupings. The default percentile groupings are: 1,5,25,50,75,95,99,
#' although you can specify your own when you call
#' [`get_percentiles`][iot_get_percentiles]. This function returns a value
#' for each percentile group specified (or the default percentile
#' groupings). The percentile group "1" contains the aggregated field value
#' that occurs in approximately one percent of the values that match the
#' query. The percentile group "5" contains the aggregated field value that
#' occurs in approximately five percent of the values that match the query,
#' and so on. The result is an approximation, the more values that match
#' the query, the more accurate the percentile values.
#'
#' @usage
#' iot_get_percentiles(indexName, queryString, aggregationField,
#'   queryVersion, percents)
#'
#' @param indexName The name of the index to search.
#' @param queryString &#91;required&#93; The query string.
#' @param aggregationField The field to aggregate.
#' @param queryVersion The query version.
#' @param percents The percentile groups returned.
#'
#' @section Request syntax:
#' ```
#' svc$get_percentiles(
#'   indexName = "string",
#'   queryString = "string",
#'   aggregationField = "string",
#'   queryVersion = "string",
#'   percents = list(
#'     123.0
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_percentiles
iot_get_percentiles <- function(indexName = NULL, queryString, aggregationField = NULL, queryVersion = NULL, percents = NULL) {
  op <- new_operation(
    name = "GetPercentiles",
    http_method = "POST",
    http_path = "/indices/percentiles",
    paginator = list()
  )
  input <- .iot$get_percentiles_input(indexName = indexName, queryString = queryString, aggregationField = aggregationField, queryVersion = queryVersion, percents = percents)
  output <- .iot$get_percentiles_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_percentiles <- iot_get_percentiles

#' Gets information about the specified policy with the policy document of
#' the default version
#'
#' @description
#' Gets information about the specified policy with the policy document of
#' the default version.
#'
#' @usage
#' iot_get_policy(policyName)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#'
#' @section Request syntax:
#' ```
#' svc$get_policy(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_policy
iot_get_policy <- function(policyName) {
  op <- new_operation(
    name = "GetPolicy",
    http_method = "GET",
    http_path = "/policies/{policyName}",
    paginator = list()
  )
  input <- .iot$get_policy_input(policyName = policyName)
  output <- .iot$get_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_policy <- iot_get_policy

#' Gets information about the specified policy version
#'
#' @description
#' Gets information about the specified policy version.
#'
#' @usage
#' iot_get_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The name of the policy.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$get_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_policy_version
iot_get_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "GetPolicyVersion",
    http_method = "GET",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$get_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$get_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_policy_version <- iot_get_policy_version

#' Gets a registration code used to register a CA certificate with AWS IoT
#'
#' @description
#' Gets a registration code used to register a CA certificate with AWS IoT.
#'
#' @usage
#' iot_get_registration_code()
#'
#' @section Request syntax:
#' ```
#' svc$get_registration_code()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_registration_code
iot_get_registration_code <- function() {
  op <- new_operation(
    name = "GetRegistrationCode",
    http_method = "GET",
    http_path = "/registrationcode",
    paginator = list()
  )
  input <- .iot$get_registration_code_input()
  output <- .iot$get_registration_code_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_registration_code <- iot_get_registration_code

#' Returns the count, average, sum, minimum, maximum, sum of squares,
#' variance, and standard deviation for the specified aggregated field
#'
#' @description
#' Returns the count, average, sum, minimum, maximum, sum of squares,
#' variance, and standard deviation for the specified aggregated field. If
#' the aggregation field is of type `String`, only the count statistic is
#' returned.
#'
#' @usage
#' iot_get_statistics(indexName, queryString, aggregationField,
#'   queryVersion)
#'
#' @param indexName The name of the index to search. The default value is `AWS_Things`.
#' @param queryString &#91;required&#93; The query used to search. You can specify "*" for the query string to
#' get the count of all indexed things in your AWS account.
#' @param aggregationField The aggregation field name.
#' @param queryVersion The version of the query used to search.
#'
#' @section Request syntax:
#' ```
#' svc$get_statistics(
#'   indexName = "string",
#'   queryString = "string",
#'   aggregationField = "string",
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_statistics
iot_get_statistics <- function(indexName = NULL, queryString, aggregationField = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "GetStatistics",
    http_method = "POST",
    http_path = "/indices/statistics",
    paginator = list()
  )
  input <- .iot$get_statistics_input(indexName = indexName, queryString = queryString, aggregationField = aggregationField, queryVersion = queryVersion)
  output <- .iot$get_statistics_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_statistics <- iot_get_statistics

#' Gets information about the rule
#'
#' @description
#' Gets information about the rule.
#'
#' @usage
#' iot_get_topic_rule(ruleName)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#'
#' @section Request syntax:
#' ```
#' svc$get_topic_rule(
#'   ruleName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_topic_rule
iot_get_topic_rule <- function(ruleName) {
  op <- new_operation(
    name = "GetTopicRule",
    http_method = "GET",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$get_topic_rule_input(ruleName = ruleName)
  output <- .iot$get_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_topic_rule <- iot_get_topic_rule

#' Gets information about a topic rule destination
#'
#' @description
#' Gets information about a topic rule destination.
#'
#' @usage
#' iot_get_topic_rule_destination(arn)
#'
#' @param arn &#91;required&#93; The ARN of the topic rule destination.
#'
#' @section Request syntax:
#' ```
#' svc$get_topic_rule_destination(
#'   arn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_topic_rule_destination
iot_get_topic_rule_destination <- function(arn) {
  op <- new_operation(
    name = "GetTopicRuleDestination",
    http_method = "GET",
    http_path = "/destinations/{arn+}",
    paginator = list()
  )
  input <- .iot$get_topic_rule_destination_input(arn = arn)
  output <- .iot$get_topic_rule_destination_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_topic_rule_destination <- iot_get_topic_rule_destination

#' Gets the fine grained logging options
#'
#' @description
#' Gets the fine grained logging options.
#'
#' @usage
#' iot_get_v2_logging_options()
#'
#' @section Request syntax:
#' ```
#' svc$get_v2_logging_options()
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_get_v2_logging_options
iot_get_v2_logging_options <- function() {
  op <- new_operation(
    name = "GetV2LoggingOptions",
    http_method = "GET",
    http_path = "/v2LoggingOptions",
    paginator = list()
  )
  input <- .iot$get_v2_logging_options_input()
  output <- .iot$get_v2_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$get_v2_logging_options <- iot_get_v2_logging_options

#' Lists the active violations for a given Device Defender security profile
#'
#' @description
#' Lists the active violations for a given Device Defender security
#' profile.
#'
#' @usage
#' iot_list_active_violations(thingName, securityProfileName,
#'   behaviorCriteriaType, listSuppressedAlerts, nextToken, maxResults)
#'
#' @param thingName The name of the thing whose active violations are listed.
#' @param securityProfileName The name of the Device Defender security profile for which violations
#' are listed.
#' @param behaviorCriteriaType The criteria for a behavior.
#' @param listSuppressedAlerts A list of all suppressed alerts.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_active_violations(
#'   thingName = "string",
#'   securityProfileName = "string",
#'   behaviorCriteriaType = "STATIC"|"STATISTICAL"|"MACHINE_LEARNING",
#'   listSuppressedAlerts = TRUE|FALSE,
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_active_violations
iot_list_active_violations <- function(thingName = NULL, securityProfileName = NULL, behaviorCriteriaType = NULL, listSuppressedAlerts = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListActiveViolations",
    http_method = "GET",
    http_path = "/active-violations",
    paginator = list()
  )
  input <- .iot$list_active_violations_input(thingName = thingName, securityProfileName = securityProfileName, behaviorCriteriaType = behaviorCriteriaType, listSuppressedAlerts = listSuppressedAlerts, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_active_violations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_active_violations <- iot_list_active_violations

#' Lists the policies attached to the specified thing group
#'
#' @description
#' Lists the policies attached to the specified thing group.
#'
#' @usage
#' iot_list_attached_policies(target, recursive, marker, pageSize)
#'
#' @param target &#91;required&#93; The group or principal for which the policies will be listed. Valid
#' principals are CertificateArn
#' (arn:aws:iot:*region*:*accountId*:cert/*certificateId*), thingGroupArn
#' (arn:aws:iot:*region*:*accountId*:thinggroup/*groupName*) and CognitoId
#' (*region*:*id*).
#' @param recursive When true, recursively list attached policies.
#' @param marker The token to retrieve the next set of results.
#' @param pageSize The maximum number of results to be returned per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_attached_policies(
#'   target = "string",
#'   recursive = TRUE|FALSE,
#'   marker = "string",
#'   pageSize = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_attached_policies
iot_list_attached_policies <- function(target, recursive = NULL, marker = NULL, pageSize = NULL) {
  op <- new_operation(
    name = "ListAttachedPolicies",
    http_method = "POST",
    http_path = "/attached-policies/{target}",
    paginator = list()
  )
  input <- .iot$list_attached_policies_input(target = target, recursive = recursive, marker = marker, pageSize = pageSize)
  output <- .iot$list_attached_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_attached_policies <- iot_list_attached_policies

#' Lists the findings (results) of a Device Defender audit or of the audits
#' performed during a specified time period
#'
#' @description
#' Lists the findings (results) of a Device Defender audit or of the audits
#' performed during a specified time period. (Findings are retained for 90
#' days.)
#'
#' @usage
#' iot_list_audit_findings(taskId, checkName, resourceIdentifier,
#'   maxResults, nextToken, startTime, endTime, listSuppressedFindings)
#'
#' @param taskId A filter to limit results to the audit with the specified ID. You must
#' specify either the taskId or the startTime and endTime, but not both.
#' @param checkName A filter to limit results to the findings for the specified audit check.
#' @param resourceIdentifier Information identifying the noncompliant resource.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#' @param startTime A filter to limit results to those found after the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#' @param endTime A filter to limit results to those found before the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#' @param listSuppressedFindings Boolean flag indicating whether only the suppressed findings or the
#' unsuppressed findings should be listed. If this parameter isn't
#' provided, the response will list both suppressed and unsuppressed
#' findings.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_findings(
#'   taskId = "string",
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   listSuppressedFindings = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_findings
iot_list_audit_findings <- function(taskId = NULL, checkName = NULL, resourceIdentifier = NULL, maxResults = NULL, nextToken = NULL, startTime = NULL, endTime = NULL, listSuppressedFindings = NULL) {
  op <- new_operation(
    name = "ListAuditFindings",
    http_method = "POST",
    http_path = "/audit/findings",
    paginator = list()
  )
  input <- .iot$list_audit_findings_input(taskId = taskId, checkName = checkName, resourceIdentifier = resourceIdentifier, maxResults = maxResults, nextToken = nextToken, startTime = startTime, endTime = endTime, listSuppressedFindings = listSuppressedFindings)
  output <- .iot$list_audit_findings_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_findings <- iot_list_audit_findings

#' Gets the status of audit mitigation action tasks that were executed
#'
#' @description
#' Gets the status of audit mitigation action tasks that were executed.
#'
#' @usage
#' iot_list_audit_mitigation_actions_executions(taskId, actionStatus,
#'   findingId, maxResults, nextToken)
#'
#' @param taskId &#91;required&#93; Specify this filter to limit results to actions for a specific audit
#' mitigation actions task.
#' @param actionStatus Specify this filter to limit results to those with a specific status.
#' @param findingId &#91;required&#93; Specify this filter to limit results to those that were applied to a
#' specific audit finding.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_mitigation_actions_executions(
#'   taskId = "string",
#'   actionStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED"|"CANCELED"|"SKIPPED"|"PENDING",
#'   findingId = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_mitigation_actions_executions
iot_list_audit_mitigation_actions_executions <- function(taskId, actionStatus = NULL, findingId, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListAuditMitigationActionsExecutions",
    http_method = "GET",
    http_path = "/audit/mitigationactions/executions",
    paginator = list()
  )
  input <- .iot$list_audit_mitigation_actions_executions_input(taskId = taskId, actionStatus = actionStatus, findingId = findingId, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_audit_mitigation_actions_executions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_mitigation_actions_executions <- iot_list_audit_mitigation_actions_executions

#' Gets a list of audit mitigation action tasks that match the specified
#' filters
#'
#' @description
#' Gets a list of audit mitigation action tasks that match the specified
#' filters.
#'
#' @usage
#' iot_list_audit_mitigation_actions_tasks(auditTaskId, findingId,
#'   taskStatus, maxResults, nextToken, startTime, endTime)
#'
#' @param auditTaskId Specify this filter to limit results to tasks that were applied to
#' results for a specific audit.
#' @param findingId Specify this filter to limit results to tasks that were applied to a
#' specific audit finding.
#' @param taskStatus Specify this filter to limit results to tasks that are in a specific
#' state.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#' @param startTime &#91;required&#93; Specify this filter to limit results to tasks that began on or after a
#' specific date and time.
#' @param endTime &#91;required&#93; Specify this filter to limit results to tasks that were completed or
#' canceled on or before a specific date and time.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_mitigation_actions_tasks(
#'   auditTaskId = "string",
#'   findingId = "string",
#'   taskStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED"|"CANCELED",
#'   maxResults = 123,
#'   nextToken = "string",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_mitigation_actions_tasks
iot_list_audit_mitigation_actions_tasks <- function(auditTaskId = NULL, findingId = NULL, taskStatus = NULL, maxResults = NULL, nextToken = NULL, startTime, endTime) {
  op <- new_operation(
    name = "ListAuditMitigationActionsTasks",
    http_method = "GET",
    http_path = "/audit/mitigationactions/tasks",
    paginator = list()
  )
  input <- .iot$list_audit_mitigation_actions_tasks_input(auditTaskId = auditTaskId, findingId = findingId, taskStatus = taskStatus, maxResults = maxResults, nextToken = nextToken, startTime = startTime, endTime = endTime)
  output <- .iot$list_audit_mitigation_actions_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_mitigation_actions_tasks <- iot_list_audit_mitigation_actions_tasks

#' Lists your Device Defender audit listings
#'
#' @description
#' Lists your Device Defender audit listings.
#'
#' @usage
#' iot_list_audit_suppressions(checkName, resourceIdentifier,
#'   ascendingOrder, nextToken, maxResults)
#'
#' @param checkName 
#' @param resourceIdentifier 
#' @param ascendingOrder Determines whether suppressions are listed in ascending order by
#' expiration date or not. If parameter isn't provided,
#' `ascendingOrder=true`.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_suppressions(
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   ),
#'   ascendingOrder = TRUE|FALSE,
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_suppressions
iot_list_audit_suppressions <- function(checkName = NULL, resourceIdentifier = NULL, ascendingOrder = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAuditSuppressions",
    http_method = "POST",
    http_path = "/audit/suppressions/list",
    paginator = list()
  )
  input <- .iot$list_audit_suppressions_input(checkName = checkName, resourceIdentifier = resourceIdentifier, ascendingOrder = ascendingOrder, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_audit_suppressions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_suppressions <- iot_list_audit_suppressions

#' Lists the Device Defender audits that have been performed during a given
#' time period
#'
#' @description
#' Lists the Device Defender audits that have been performed during a given
#' time period.
#'
#' @usage
#' iot_list_audit_tasks(startTime, endTime, taskType, taskStatus,
#'   nextToken, maxResults)
#'
#' @param startTime &#91;required&#93; The beginning of the time period. Audit information is retained for a
#' limited time (90 days). Requesting a start time prior to what is
#' retained results in an "InvalidRequestException".
#' @param endTime &#91;required&#93; The end of the time period.
#' @param taskType A filter to limit the output to the specified type of audit: can be one
#' of "ON\\_DEMAND\\_AUDIT\\_TASK" or "SCHEDULED\\_\\_AUDIT\\_TASK".
#' @param taskStatus A filter to limit the output to audits with the specified completion
#' status: can be one of "IN\\_PROGRESS", "COMPLETED", "FAILED", or
#' "CANCELED".
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_audit_tasks(
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   taskType = "ON_DEMAND_AUDIT_TASK"|"SCHEDULED_AUDIT_TASK",
#'   taskStatus = "IN_PROGRESS"|"COMPLETED"|"FAILED"|"CANCELED",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_audit_tasks
iot_list_audit_tasks <- function(startTime, endTime, taskType = NULL, taskStatus = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListAuditTasks",
    http_method = "GET",
    http_path = "/audit/tasks",
    paginator = list()
  )
  input <- .iot$list_audit_tasks_input(startTime = startTime, endTime = endTime, taskType = taskType, taskStatus = taskStatus, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_audit_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_audit_tasks <- iot_list_audit_tasks

#' Lists the authorizers registered in your account
#'
#' @description
#' Lists the authorizers registered in your account.
#'
#' @usage
#' iot_list_authorizers(pageSize, marker, ascendingOrder, status)
#'
#' @param pageSize The maximum number of results to return at one time.
#' @param marker A marker used to get the next set of results.
#' @param ascendingOrder Return the list of authorizers in ascending alphabetical order.
#' @param status The status of the list authorizers request.
#'
#' @section Request syntax:
#' ```
#' svc$list_authorizers(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE,
#'   status = "ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_authorizers
iot_list_authorizers <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL, status = NULL) {
  op <- new_operation(
    name = "ListAuthorizers",
    http_method = "GET",
    http_path = "/authorizers/",
    paginator = list()
  )
  input <- .iot$list_authorizers_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder, status = status)
  output <- .iot$list_authorizers_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_authorizers <- iot_list_authorizers

#' Lists the billing groups you have created
#'
#' @description
#' Lists the billing groups you have created.
#'
#' @usage
#' iot_list_billing_groups(nextToken, maxResults, namePrefixFilter)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return per request.
#' @param namePrefixFilter Limit the results to billing groups whose names have the given prefix.
#'
#' @section Request syntax:
#' ```
#' svc$list_billing_groups(
#'   nextToken = "string",
#'   maxResults = 123,
#'   namePrefixFilter = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_billing_groups
iot_list_billing_groups <- function(nextToken = NULL, maxResults = NULL, namePrefixFilter = NULL) {
  op <- new_operation(
    name = "ListBillingGroups",
    http_method = "GET",
    http_path = "/billing-groups",
    paginator = list()
  )
  input <- .iot$list_billing_groups_input(nextToken = nextToken, maxResults = maxResults, namePrefixFilter = namePrefixFilter)
  output <- .iot$list_billing_groups_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_billing_groups <- iot_list_billing_groups

#' Lists the CA certificates registered for your AWS account
#'
#' @description
#' Lists the CA certificates registered for your AWS account.
#' 
#' The results are paginated with a default page size of 25. You can use
#' the returned marker to retrieve additional results.
#'
#' @usage
#' iot_list_ca_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Determines the order of the results.
#'
#' @section Request syntax:
#' ```
#' svc$list_ca_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_ca_certificates
iot_list_ca_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCACertificates",
    http_method = "GET",
    http_path = "/cacertificates",
    paginator = list()
  )
  input <- .iot$list_ca_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_ca_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_ca_certificates <- iot_list_ca_certificates

#' Lists the certificates registered in your AWS account
#'
#' @description
#' Lists the certificates registered in your AWS account.
#' 
#' The results are paginated with a default page size of 25. You can use
#' the returned marker to retrieve additional results.
#'
#' @usage
#' iot_list_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_certificates
iot_list_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCertificates",
    http_method = "GET",
    http_path = "/certificates",
    paginator = list()
  )
  input <- .iot$list_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_certificates <- iot_list_certificates

#' List the device certificates signed by the specified CA certificate
#'
#' @description
#' List the device certificates signed by the specified CA certificate.
#'
#' @usage
#' iot_list_certificates_by_ca(caCertificateId, pageSize, marker,
#'   ascendingOrder)
#'
#' @param caCertificateId &#91;required&#93; The ID of the CA certificate. This operation will list all registered
#' device certificate that were signed by this CA certificate.
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_certificates_by_ca(
#'   caCertificateId = "string",
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_certificates_by_ca
iot_list_certificates_by_ca <- function(caCertificateId, pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListCertificatesByCA",
    http_method = "GET",
    http_path = "/certificates-by-ca/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$list_certificates_by_ca_input(caCertificateId = caCertificateId, pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_certificates_by_ca_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_certificates_by_ca <- iot_list_certificates_by_ca

#' Lists your Device Defender detect custom metrics
#'
#' @description
#' Lists your Device Defender detect custom metrics.
#'
#' @usage
#' iot_list_custom_metrics(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_custom_metrics(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_custom_metrics
iot_list_custom_metrics <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListCustomMetrics",
    http_method = "GET",
    http_path = "/custom-metrics",
    paginator = list()
  )
  input <- .iot$list_custom_metrics_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_custom_metrics_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_custom_metrics <- iot_list_custom_metrics

#' Lists mitigation actions executions for a Device Defender ML Detect
#' Security Profile
#'
#' @description
#' Lists mitigation actions executions for a Device Defender ML Detect
#' Security Profile.
#'
#' @usage
#' iot_list_detect_mitigation_actions_executions(taskId, violationId,
#'   thingName, startTime, endTime, maxResults, nextToken)
#'
#' @param taskId The unique identifier of the task.
#' @param violationId The unique identifier of the violation.
#' @param thingName The name of the thing whose mitigation actions are listed.
#' @param startTime A filter to limit results to those found after the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#' @param endTime The end of the time period for which ML Detect mitigation actions
#' executions are returned.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_detect_mitigation_actions_executions(
#'   taskId = "string",
#'   violationId = "string",
#'   thingName = "string",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_detect_mitigation_actions_executions
iot_list_detect_mitigation_actions_executions <- function(taskId = NULL, violationId = NULL, thingName = NULL, startTime = NULL, endTime = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListDetectMitigationActionsExecutions",
    http_method = "GET",
    http_path = "/detect/mitigationactions/executions",
    paginator = list()
  )
  input <- .iot$list_detect_mitigation_actions_executions_input(taskId = taskId, violationId = violationId, thingName = thingName, startTime = startTime, endTime = endTime, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_detect_mitigation_actions_executions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_detect_mitigation_actions_executions <- iot_list_detect_mitigation_actions_executions

#' List of Device Defender ML Detect mitigation actions tasks
#'
#' @description
#' List of Device Defender ML Detect mitigation actions tasks.
#'
#' @usage
#' iot_list_detect_mitigation_actions_tasks(maxResults, nextToken,
#'   startTime, endTime)
#'
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#' @param startTime &#91;required&#93; A filter to limit results to those found after the specified time. You
#' must specify either the startTime and endTime or the taskId, but not
#' both.
#' @param endTime &#91;required&#93; The end of the time period for which ML Detect mitigation actions tasks
#' are returned.
#'
#' @section Request syntax:
#' ```
#' svc$list_detect_mitigation_actions_tasks(
#'   maxResults = 123,
#'   nextToken = "string",
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_detect_mitigation_actions_tasks
iot_list_detect_mitigation_actions_tasks <- function(maxResults = NULL, nextToken = NULL, startTime, endTime) {
  op <- new_operation(
    name = "ListDetectMitigationActionsTasks",
    http_method = "GET",
    http_path = "/detect/mitigationactions/tasks",
    paginator = list()
  )
  input <- .iot$list_detect_mitigation_actions_tasks_input(maxResults = maxResults, nextToken = nextToken, startTime = startTime, endTime = endTime)
  output <- .iot$list_detect_mitigation_actions_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_detect_mitigation_actions_tasks <- iot_list_detect_mitigation_actions_tasks

#' List the set of dimensions that are defined for your AWS account
#'
#' @description
#' List the set of dimensions that are defined for your AWS account.
#'
#' @usage
#' iot_list_dimensions(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to retrieve at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_dimensions(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_dimensions
iot_list_dimensions <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListDimensions",
    http_method = "GET",
    http_path = "/dimensions",
    paginator = list()
  )
  input <- .iot$list_dimensions_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_dimensions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_dimensions <- iot_list_dimensions

#' Gets a list of domain configurations for the user
#'
#' @description
#' Gets a list of domain configurations for the user. This list is sorted
#' alphabetically by domain configuration name.
#' 
#' The domain configuration feature is in public preview and is subject to
#' change.
#'
#' @usage
#' iot_list_domain_configurations(marker, pageSize, serviceType)
#'
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param serviceType The type of service delivered by the endpoint.
#'
#' @section Request syntax:
#' ```
#' svc$list_domain_configurations(
#'   marker = "string",
#'   pageSize = 123,
#'   serviceType = "DATA"|"CREDENTIAL_PROVIDER"|"JOBS"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_domain_configurations
iot_list_domain_configurations <- function(marker = NULL, pageSize = NULL, serviceType = NULL) {
  op <- new_operation(
    name = "ListDomainConfigurations",
    http_method = "GET",
    http_path = "/domainConfigurations",
    paginator = list()
  )
  input <- .iot$list_domain_configurations_input(marker = marker, pageSize = pageSize, serviceType = serviceType)
  output <- .iot$list_domain_configurations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_domain_configurations <- iot_list_domain_configurations

#' Lists the search indices
#'
#' @description
#' Lists the search indices.
#'
#' @usage
#' iot_list_indices(nextToken, maxResults)
#'
#' @param nextToken The token used to get the next set of results, or `null` if there are no
#' additional results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_indices(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_indices
iot_list_indices <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListIndices",
    http_method = "GET",
    http_path = "/indices",
    paginator = list()
  )
  input <- .iot$list_indices_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_indices_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_indices <- iot_list_indices

#' Lists the job executions for a job
#'
#' @description
#' Lists the job executions for a job.
#'
#' @usage
#' iot_list_job_executions_for_job(jobId, status, maxResults, nextToken)
#'
#' @param jobId &#91;required&#93; The unique identifier you assigned to this job when it was created.
#' @param status The status of the job.
#' @param maxResults The maximum number of results to be returned per request.
#' @param nextToken The token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_job_executions_for_job(
#'   jobId = "string",
#'   status = "QUEUED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"REJECTED"|"REMOVED"|"CANCELED",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_job_executions_for_job
iot_list_job_executions_for_job <- function(jobId, status = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobExecutionsForJob",
    http_method = "GET",
    http_path = "/jobs/{jobId}/things",
    paginator = list()
  )
  input <- .iot$list_job_executions_for_job_input(jobId = jobId, status = status, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_job_executions_for_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_job_executions_for_job <- iot_list_job_executions_for_job

#' Lists the job executions for the specified thing
#'
#' @description
#' Lists the job executions for the specified thing.
#'
#' @usage
#' iot_list_job_executions_for_thing(thingName, status, namespaceId,
#'   maxResults, nextToken)
#'
#' @param thingName &#91;required&#93; The thing name.
#' @param status An optional filter that lets you search for jobs that have the specified
#' status.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#' @param maxResults The maximum number of results to be returned per request.
#' @param nextToken The token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_job_executions_for_thing(
#'   thingName = "string",
#'   status = "QUEUED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"TIMED_OUT"|"REJECTED"|"REMOVED"|"CANCELED",
#'   namespaceId = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_job_executions_for_thing
iot_list_job_executions_for_thing <- function(thingName, status = NULL, namespaceId = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobExecutionsForThing",
    http_method = "GET",
    http_path = "/things/{thingName}/jobs",
    paginator = list()
  )
  input <- .iot$list_job_executions_for_thing_input(thingName = thingName, status = status, namespaceId = namespaceId, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_job_executions_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_job_executions_for_thing <- iot_list_job_executions_for_thing

#' Lists jobs
#'
#' @description
#' Lists jobs.
#'
#' @usage
#' iot_list_jobs(status, targetSelection, maxResults, nextToken,
#'   thingGroupName, thingGroupId, namespaceId)
#'
#' @param status An optional filter that lets you search for jobs that have the specified
#' status.
#' @param targetSelection Specifies whether the job will continue to run (CONTINUOUS), or will be
#' complete after all those things specified as targets have completed the
#' job (SNAPSHOT). If continuous, the job may also be run on a thing when a
#' change is detected in a target. For example, a job will run on a thing
#' when the thing is added to a target group, even after the job was
#' completed by all things originally in the group.
#' @param maxResults The maximum number of results to return per request.
#' @param nextToken The token to retrieve the next set of results.
#' @param thingGroupName A filter that limits the returned jobs to those for the specified group.
#' @param thingGroupId A filter that limits the returned jobs to those for the specified group.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$list_jobs(
#'   status = "IN_PROGRESS"|"CANCELED"|"COMPLETED"|"DELETION_IN_PROGRESS",
#'   targetSelection = "CONTINUOUS"|"SNAPSHOT",
#'   maxResults = 123,
#'   nextToken = "string",
#'   thingGroupName = "string",
#'   thingGroupId = "string",
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_jobs
iot_list_jobs <- function(status = NULL, targetSelection = NULL, maxResults = NULL, nextToken = NULL, thingGroupName = NULL, thingGroupId = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "ListJobs",
    http_method = "GET",
    http_path = "/jobs",
    paginator = list()
  )
  input <- .iot$list_jobs_input(status = status, targetSelection = targetSelection, maxResults = maxResults, nextToken = nextToken, thingGroupName = thingGroupName, thingGroupId = thingGroupId, namespaceId = namespaceId)
  output <- .iot$list_jobs_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_jobs <- iot_list_jobs

#' Gets a list of all mitigation actions that match the specified filter
#' criteria
#'
#' @description
#' Gets a list of all mitigation actions that match the specified filter
#' criteria.
#'
#' @usage
#' iot_list_mitigation_actions(actionType, maxResults, nextToken)
#'
#' @param actionType Specify a value to limit the result to mitigation actions with a
#' specific action type.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#' @param nextToken The token for the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_mitigation_actions(
#'   actionType = "UPDATE_DEVICE_CERTIFICATE"|"UPDATE_CA_CERTIFICATE"|"ADD_THINGS_TO_THING_GROUP"|"REPLACE_DEFAULT_POLICY_VERSION"|"ENABLE_IOT_LOGGING"|"PUBLISH_FINDING_TO_SNS",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_mitigation_actions
iot_list_mitigation_actions <- function(actionType = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListMitigationActions",
    http_method = "GET",
    http_path = "/mitigationactions/actions",
    paginator = list()
  )
  input <- .iot$list_mitigation_actions_input(actionType = actionType, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_mitigation_actions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_mitigation_actions <- iot_list_mitigation_actions

#' Lists OTA updates
#'
#' @description
#' Lists OTA updates.
#'
#' @usage
#' iot_list_ota_updates(maxResults, nextToken, otaUpdateStatus)
#'
#' @param maxResults The maximum number of results to return at one time.
#' @param nextToken A token used to retrieve the next set of results.
#' @param otaUpdateStatus The OTA update job status.
#'
#' @section Request syntax:
#' ```
#' svc$list_ota_updates(
#'   maxResults = 123,
#'   nextToken = "string",
#'   otaUpdateStatus = "CREATE_PENDING"|"CREATE_IN_PROGRESS"|"CREATE_COMPLETE"|"CREATE_FAILED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_ota_updates
iot_list_ota_updates <- function(maxResults = NULL, nextToken = NULL, otaUpdateStatus = NULL) {
  op <- new_operation(
    name = "ListOTAUpdates",
    http_method = "GET",
    http_path = "/otaUpdates",
    paginator = list()
  )
  input <- .iot$list_ota_updates_input(maxResults = maxResults, nextToken = nextToken, otaUpdateStatus = otaUpdateStatus)
  output <- .iot$list_ota_updates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_ota_updates <- iot_list_ota_updates

#' Lists certificates that are being transferred but not yet accepted
#'
#' @description
#' Lists certificates that are being transferred but not yet accepted.
#'
#' @usage
#' iot_list_outgoing_certificates(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The result page size.
#' @param marker The marker for the next set of results.
#' @param ascendingOrder Specifies the order for results. If True, the results are returned in
#' ascending order, based on the creation date.
#'
#' @section Request syntax:
#' ```
#' svc$list_outgoing_certificates(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_outgoing_certificates
iot_list_outgoing_certificates <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListOutgoingCertificates",
    http_method = "GET",
    http_path = "/certificates-out-going",
    paginator = list()
  )
  input <- .iot$list_outgoing_certificates_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_outgoing_certificates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_outgoing_certificates <- iot_list_outgoing_certificates

#' Lists your policies
#'
#' @description
#' Lists your policies.
#'
#' @usage
#' iot_list_policies(marker, pageSize, ascendingOrder)
#'
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, the results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_policies(
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policies
iot_list_policies <- function(marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPolicies",
    http_method = "GET",
    http_path = "/policies",
    paginator = list()
  )
  input <- .iot$list_policies_input(marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policies <- iot_list_policies

#' Lists the principals associated with the specified policy
#'
#' @description
#' Lists the principals associated with the specified policy.
#' 
#' **Note:** This API is deprecated. Please use
#' [`list_targets_for_policy`][iot_list_targets_for_policy] instead.
#'
#' @usage
#' iot_list_policy_principals(policyName, marker, pageSize, ascendingOrder)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, the results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_principals(
#'   policyName = "string",
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policy_principals
iot_list_policy_principals <- function(policyName, marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPolicyPrincipals",
    http_method = "GET",
    http_path = "/policy-principals",
    paginator = list()
  )
  input <- .iot$list_policy_principals_input(policyName = policyName, marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_policy_principals_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policy_principals <- iot_list_policy_principals

#' Lists the versions of the specified policy and identifies the default
#' version
#'
#' @description
#' Lists the versions of the specified policy and identifies the default
#' version.
#'
#' @usage
#' iot_list_policy_versions(policyName)
#'
#' @param policyName &#91;required&#93; The policy name.
#'
#' @section Request syntax:
#' ```
#' svc$list_policy_versions(
#'   policyName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_policy_versions
iot_list_policy_versions <- function(policyName) {
  op <- new_operation(
    name = "ListPolicyVersions",
    http_method = "GET",
    http_path = "/policies/{policyName}/version",
    paginator = list()
  )
  input <- .iot$list_policy_versions_input(policyName = policyName)
  output <- .iot$list_policy_versions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_policy_versions <- iot_list_policy_versions

#' Lists the policies attached to the specified principal
#'
#' @description
#' Lists the policies attached to the specified principal. If you use an
#' Cognito identity, the ID must be in [AmazonCognito Identity
#' format](https://docs.aws.amazon.com/cognitoidentity/latest/APIReference/API_GetCredentialsForIdentity.html#API_GetCredentialsForIdentity_RequestSyntax).
#' 
#' **Note:** This API is deprecated. Please use
#' [`list_attached_policies`][iot_list_attached_policies] instead.
#'
#' @usage
#' iot_list_principal_policies(principal, marker, pageSize, ascendingOrder)
#'
#' @param principal &#91;required&#93; The principal. Valid principals are CertificateArn
#' (arn:aws:iot:*region*:*accountId*:cert/*certificateId*), thingGroupArn
#' (arn:aws:iot:*region*:*accountId*:thinggroup/*groupName*) and CognitoId
#' (*region*:*id*).
#' @param marker The marker for the next set of results.
#' @param pageSize The result page size.
#' @param ascendingOrder Specifies the order for results. If true, results are returned in
#' ascending creation order.
#'
#' @section Request syntax:
#' ```
#' svc$list_principal_policies(
#'   principal = "string",
#'   marker = "string",
#'   pageSize = 123,
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_principal_policies
iot_list_principal_policies <- function(principal, marker = NULL, pageSize = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListPrincipalPolicies",
    http_method = "GET",
    http_path = "/principal-policies",
    paginator = list()
  )
  input <- .iot$list_principal_policies_input(principal = principal, marker = marker, pageSize = pageSize, ascendingOrder = ascendingOrder)
  output <- .iot$list_principal_policies_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_principal_policies <- iot_list_principal_policies

#' Lists the things associated with the specified principal
#'
#' @description
#' Lists the things associated with the specified principal. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_list_principal_things(nextToken, maxResults, principal)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param principal &#91;required&#93; The principal.
#'
#' @section Request syntax:
#' ```
#' svc$list_principal_things(
#'   nextToken = "string",
#'   maxResults = 123,
#'   principal = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_principal_things
iot_list_principal_things <- function(nextToken = NULL, maxResults = NULL, principal) {
  op <- new_operation(
    name = "ListPrincipalThings",
    http_method = "GET",
    http_path = "/principals/things",
    paginator = list()
  )
  input <- .iot$list_principal_things_input(nextToken = nextToken, maxResults = maxResults, principal = principal)
  output <- .iot$list_principal_things_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_principal_things <- iot_list_principal_things

#' A list of fleet provisioning template versions
#'
#' @description
#' A list of fleet provisioning template versions.
#'
#' @usage
#' iot_list_provisioning_template_versions(templateName, maxResults,
#'   nextToken)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template.
#' @param maxResults The maximum number of results to return at one time.
#' @param nextToken A token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_provisioning_template_versions(
#'   templateName = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_provisioning_template_versions
iot_list_provisioning_template_versions <- function(templateName, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListProvisioningTemplateVersions",
    http_method = "GET",
    http_path = "/provisioning-templates/{templateName}/versions",
    paginator = list()
  )
  input <- .iot$list_provisioning_template_versions_input(templateName = templateName, maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_provisioning_template_versions_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_provisioning_template_versions <- iot_list_provisioning_template_versions

#' Lists the fleet provisioning templates in your AWS account
#'
#' @description
#' Lists the fleet provisioning templates in your AWS account.
#'
#' @usage
#' iot_list_provisioning_templates(maxResults, nextToken)
#'
#' @param maxResults The maximum number of results to return at one time.
#' @param nextToken A token to retrieve the next set of results.
#'
#' @section Request syntax:
#' ```
#' svc$list_provisioning_templates(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_provisioning_templates
iot_list_provisioning_templates <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListProvisioningTemplates",
    http_method = "GET",
    http_path = "/provisioning-templates",
    paginator = list()
  )
  input <- .iot$list_provisioning_templates_input(maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_provisioning_templates_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_provisioning_templates <- iot_list_provisioning_templates

#' Lists the role aliases registered in your account
#'
#' @description
#' Lists the role aliases registered in your account.
#'
#' @usage
#' iot_list_role_aliases(pageSize, marker, ascendingOrder)
#'
#' @param pageSize The maximum number of results to return at one time.
#' @param marker A marker used to get the next set of results.
#' @param ascendingOrder Return the list of role aliases in ascending alphabetical order.
#'
#' @section Request syntax:
#' ```
#' svc$list_role_aliases(
#'   pageSize = 123,
#'   marker = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_role_aliases
iot_list_role_aliases <- function(pageSize = NULL, marker = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListRoleAliases",
    http_method = "GET",
    http_path = "/role-aliases",
    paginator = list()
  )
  input <- .iot$list_role_aliases_input(pageSize = pageSize, marker = marker, ascendingOrder = ascendingOrder)
  output <- .iot$list_role_aliases_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_role_aliases <- iot_list_role_aliases

#' Lists all of your scheduled audits
#'
#' @description
#' Lists all of your scheduled audits.
#'
#' @usage
#' iot_list_scheduled_audits(nextToken, maxResults)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time. The default is 25.
#'
#' @section Request syntax:
#' ```
#' svc$list_scheduled_audits(
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_scheduled_audits
iot_list_scheduled_audits <- function(nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListScheduledAudits",
    http_method = "GET",
    http_path = "/audit/scheduledaudits",
    paginator = list()
  )
  input <- .iot$list_scheduled_audits_input(nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_scheduled_audits_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_scheduled_audits <- iot_list_scheduled_audits

#' Lists the Device Defender security profiles you've created
#'
#' @description
#' Lists the Device Defender security profiles you've created. You can
#' filter security profiles by dimension or custom metric.
#' 
#' `dimensionName` and `metricName` cannot be used in the same request.
#'
#' @usage
#' iot_list_security_profiles(nextToken, maxResults, dimensionName,
#'   metricName)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#' @param dimensionName A filter to limit results to the security profiles that use the defined
#' dimension. Cannot be used with `metricName`
#' @param metricName The name of the custom metric. Cannot be used with `dimensionName`.
#'
#' @section Request syntax:
#' ```
#' svc$list_security_profiles(
#'   nextToken = "string",
#'   maxResults = 123,
#'   dimensionName = "string",
#'   metricName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_security_profiles
iot_list_security_profiles <- function(nextToken = NULL, maxResults = NULL, dimensionName = NULL, metricName = NULL) {
  op <- new_operation(
    name = "ListSecurityProfiles",
    http_method = "GET",
    http_path = "/security-profiles",
    paginator = list()
  )
  input <- .iot$list_security_profiles_input(nextToken = nextToken, maxResults = maxResults, dimensionName = dimensionName, metricName = metricName)
  output <- .iot$list_security_profiles_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_security_profiles <- iot_list_security_profiles

#' Lists the Device Defender security profiles attached to a target (thing
#' group)
#'
#' @description
#' Lists the Device Defender security profiles attached to a target (thing
#' group).
#'
#' @usage
#' iot_list_security_profiles_for_target(nextToken, maxResults, recursive,
#'   securityProfileTargetArn)
#'
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#' @param recursive If true, return child groups too.
#' @param securityProfileTargetArn &#91;required&#93; The ARN of the target (thing group) whose attached security profiles you
#' want to get.
#'
#' @section Request syntax:
#' ```
#' svc$list_security_profiles_for_target(
#'   nextToken = "string",
#'   maxResults = 123,
#'   recursive = TRUE|FALSE,
#'   securityProfileTargetArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_security_profiles_for_target
iot_list_security_profiles_for_target <- function(nextToken = NULL, maxResults = NULL, recursive = NULL, securityProfileTargetArn) {
  op <- new_operation(
    name = "ListSecurityProfilesForTarget",
    http_method = "GET",
    http_path = "/security-profiles-for-target",
    paginator = list()
  )
  input <- .iot$list_security_profiles_for_target_input(nextToken = nextToken, maxResults = maxResults, recursive = recursive, securityProfileTargetArn = securityProfileTargetArn)
  output <- .iot$list_security_profiles_for_target_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_security_profiles_for_target <- iot_list_security_profiles_for_target

#' Lists all of the streams in your AWS account
#'
#' @description
#' Lists all of the streams in your AWS account.
#'
#' @usage
#' iot_list_streams(maxResults, nextToken, ascendingOrder)
#'
#' @param maxResults The maximum number of results to return at a time.
#' @param nextToken A token used to get the next set of results.
#' @param ascendingOrder Set to true to return the list of streams in ascending order.
#'
#' @section Request syntax:
#' ```
#' svc$list_streams(
#'   maxResults = 123,
#'   nextToken = "string",
#'   ascendingOrder = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_streams
iot_list_streams <- function(maxResults = NULL, nextToken = NULL, ascendingOrder = NULL) {
  op <- new_operation(
    name = "ListStreams",
    http_method = "GET",
    http_path = "/streams",
    paginator = list()
  )
  input <- .iot$list_streams_input(maxResults = maxResults, nextToken = nextToken, ascendingOrder = ascendingOrder)
  output <- .iot$list_streams_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_streams <- iot_list_streams

#' Lists the tags (metadata) you have assigned to the resource
#'
#' @description
#' Lists the tags (metadata) you have assigned to the resource.
#'
#' @usage
#' iot_list_tags_for_resource(resourceArn, nextToken)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_tags_for_resource
iot_list_tags_for_resource <- function(resourceArn, nextToken = NULL) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags",
    paginator = list()
  )
  input <- .iot$list_tags_for_resource_input(resourceArn = resourceArn, nextToken = nextToken)
  output <- .iot$list_tags_for_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_tags_for_resource <- iot_list_tags_for_resource

#' List targets for the specified policy
#'
#' @description
#' List targets for the specified policy.
#'
#' @usage
#' iot_list_targets_for_policy(policyName, marker, pageSize)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param marker A marker used to get the next set of results.
#' @param pageSize The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_targets_for_policy(
#'   policyName = "string",
#'   marker = "string",
#'   pageSize = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_targets_for_policy
iot_list_targets_for_policy <- function(policyName, marker = NULL, pageSize = NULL) {
  op <- new_operation(
    name = "ListTargetsForPolicy",
    http_method = "POST",
    http_path = "/policy-targets/{policyName}",
    paginator = list()
  )
  input <- .iot$list_targets_for_policy_input(policyName = policyName, marker = marker, pageSize = pageSize)
  output <- .iot$list_targets_for_policy_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_targets_for_policy <- iot_list_targets_for_policy

#' Lists the targets (thing groups) associated with a given Device Defender
#' security profile
#'
#' @description
#' Lists the targets (thing groups) associated with a given Device Defender
#' security profile.
#'
#' @usage
#' iot_list_targets_for_security_profile(securityProfileName, nextToken,
#'   maxResults)
#'
#' @param securityProfileName &#91;required&#93; The security profile.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_targets_for_security_profile(
#'   securityProfileName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_targets_for_security_profile
iot_list_targets_for_security_profile <- function(securityProfileName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListTargetsForSecurityProfile",
    http_method = "GET",
    http_path = "/security-profiles/{securityProfileName}/targets",
    paginator = list()
  )
  input <- .iot$list_targets_for_security_profile_input(securityProfileName = securityProfileName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_targets_for_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_targets_for_security_profile <- iot_list_targets_for_security_profile

#' List the thing groups in your account
#'
#' @description
#' List the thing groups in your account.
#'
#' @usage
#' iot_list_thing_groups(nextToken, maxResults, parentGroup,
#'   namePrefixFilter, recursive)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return at one time.
#' @param parentGroup A filter that limits the results to those with the specified parent
#' group.
#' @param namePrefixFilter A filter that limits the results to those with the specified name
#' prefix.
#' @param recursive If true, return child groups as well.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_groups(
#'   nextToken = "string",
#'   maxResults = 123,
#'   parentGroup = "string",
#'   namePrefixFilter = "string",
#'   recursive = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_groups
iot_list_thing_groups <- function(nextToken = NULL, maxResults = NULL, parentGroup = NULL, namePrefixFilter = NULL, recursive = NULL) {
  op <- new_operation(
    name = "ListThingGroups",
    http_method = "GET",
    http_path = "/thing-groups",
    paginator = list()
  )
  input <- .iot$list_thing_groups_input(nextToken = nextToken, maxResults = maxResults, parentGroup = parentGroup, namePrefixFilter = namePrefixFilter, recursive = recursive)
  output <- .iot$list_thing_groups_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_groups <- iot_list_thing_groups

#' List the thing groups to which the specified thing belongs
#'
#' @description
#' List the thing groups to which the specified thing belongs.
#'
#' @usage
#' iot_list_thing_groups_for_thing(thingName, nextToken, maxResults)
#'
#' @param thingName &#91;required&#93; The thing name.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_groups_for_thing(
#'   thingName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_groups_for_thing
iot_list_thing_groups_for_thing <- function(thingName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingGroupsForThing",
    http_method = "GET",
    http_path = "/things/{thingName}/thing-groups",
    paginator = list()
  )
  input <- .iot$list_thing_groups_for_thing_input(thingName = thingName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_thing_groups_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_groups_for_thing <- iot_list_thing_groups_for_thing

#' Lists the principals associated with the specified thing
#'
#' @description
#' Lists the principals associated with the specified thing. A principal
#' can be X.509 certificates, IAM users, groups, and roles, Amazon Cognito
#' identities or federated identities.
#'
#' @usage
#' iot_list_thing_principals(nextToken, maxResults, thingName)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param thingName &#91;required&#93; The name of the thing.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_principals(
#'   nextToken = "string",
#'   maxResults = 123,
#'   thingName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_principals
iot_list_thing_principals <- function(nextToken = NULL, maxResults = NULL, thingName) {
  op <- new_operation(
    name = "ListThingPrincipals",
    http_method = "GET",
    http_path = "/things/{thingName}/principals",
    paginator = list()
  )
  input <- .iot$list_thing_principals_input(nextToken = nextToken, maxResults = maxResults, thingName = thingName)
  output <- .iot$list_thing_principals_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_principals <- iot_list_thing_principals

#' Information about the thing registration tasks
#'
#' @description
#' Information about the thing registration tasks.
#'
#' @usage
#' iot_list_thing_registration_task_reports(taskId, reportType, nextToken,
#'   maxResults)
#'
#' @param taskId &#91;required&#93; The id of the task.
#' @param reportType &#91;required&#93; The type of task report.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_registration_task_reports(
#'   taskId = "string",
#'   reportType = "ERRORS"|"RESULTS",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_registration_task_reports
iot_list_thing_registration_task_reports <- function(taskId, reportType, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingRegistrationTaskReports",
    http_method = "GET",
    http_path = "/thing-registration-tasks/{taskId}/reports",
    paginator = list()
  )
  input <- .iot$list_thing_registration_task_reports_input(taskId = taskId, reportType = reportType, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_thing_registration_task_reports_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_registration_task_reports <- iot_list_thing_registration_task_reports

#' List bulk thing provisioning tasks
#'
#' @description
#' List bulk thing provisioning tasks.
#'
#' @usage
#' iot_list_thing_registration_tasks(nextToken, maxResults, status)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return at one time.
#' @param status The status of the bulk thing provisioning task.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_registration_tasks(
#'   nextToken = "string",
#'   maxResults = 123,
#'   status = "InProgress"|"Completed"|"Failed"|"Cancelled"|"Cancelling"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_registration_tasks
iot_list_thing_registration_tasks <- function(nextToken = NULL, maxResults = NULL, status = NULL) {
  op <- new_operation(
    name = "ListThingRegistrationTasks",
    http_method = "GET",
    http_path = "/thing-registration-tasks",
    paginator = list()
  )
  input <- .iot$list_thing_registration_tasks_input(nextToken = nextToken, maxResults = maxResults, status = status)
  output <- .iot$list_thing_registration_tasks_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_registration_tasks <- iot_list_thing_registration_tasks

#' Lists the existing thing types
#'
#' @description
#' Lists the existing thing types.
#'
#' @usage
#' iot_list_thing_types(nextToken, maxResults, thingTypeName)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param thingTypeName The name of the thing type.
#'
#' @section Request syntax:
#' ```
#' svc$list_thing_types(
#'   nextToken = "string",
#'   maxResults = 123,
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_thing_types
iot_list_thing_types <- function(nextToken = NULL, maxResults = NULL, thingTypeName = NULL) {
  op <- new_operation(
    name = "ListThingTypes",
    http_method = "GET",
    http_path = "/thing-types",
    paginator = list()
  )
  input <- .iot$list_thing_types_input(nextToken = nextToken, maxResults = maxResults, thingTypeName = thingTypeName)
  output <- .iot$list_thing_types_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_thing_types <- iot_list_thing_types

#' Lists your things
#'
#' @description
#' Lists your things. Use the **attributeName** and **attributeValue**
#' parameters to filter your things. For example, calling
#' [`list_things`][iot_list_things] with attributeName=Color and
#' attributeValue=Red retrieves all things in the registry that contain an
#' attribute **Color** with the value **Red**.
#' 
#' You will not be charged for calling this API if an `Access denied` error
#' is returned. You will also not be charged if no attributes or pagination
#' token was provided in request and no pagination token and no results
#' were returned.
#'
#' @usage
#' iot_list_things(nextToken, maxResults, attributeName, attributeValue,
#'   thingTypeName)
#'
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return in this operation.
#' @param attributeName The attribute name used to search for things.
#' @param attributeValue The attribute value used to search for things.
#' @param thingTypeName The name of the thing type used to search for things.
#'
#' @section Request syntax:
#' ```
#' svc$list_things(
#'   nextToken = "string",
#'   maxResults = 123,
#'   attributeName = "string",
#'   attributeValue = "string",
#'   thingTypeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things
iot_list_things <- function(nextToken = NULL, maxResults = NULL, attributeName = NULL, attributeValue = NULL, thingTypeName = NULL) {
  op <- new_operation(
    name = "ListThings",
    http_method = "GET",
    http_path = "/things",
    paginator = list()
  )
  input <- .iot$list_things_input(nextToken = nextToken, maxResults = maxResults, attributeName = attributeName, attributeValue = attributeValue, thingTypeName = thingTypeName)
  output <- .iot$list_things_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things <- iot_list_things

#' Lists the things you have added to the given billing group
#'
#' @description
#' Lists the things you have added to the given billing group.
#'
#' @usage
#' iot_list_things_in_billing_group(billingGroupName, nextToken,
#'   maxResults)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return per request.
#'
#' @section Request syntax:
#' ```
#' svc$list_things_in_billing_group(
#'   billingGroupName = "string",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things_in_billing_group
iot_list_things_in_billing_group <- function(billingGroupName, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingsInBillingGroup",
    http_method = "GET",
    http_path = "/billing-groups/{billingGroupName}/things",
    paginator = list()
  )
  input <- .iot$list_things_in_billing_group_input(billingGroupName = billingGroupName, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_things_in_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things_in_billing_group <- iot_list_things_in_billing_group

#' Lists the things in the specified group
#'
#' @description
#' Lists the things in the specified group.
#'
#' @usage
#' iot_list_things_in_thing_group(thingGroupName, recursive, nextToken,
#'   maxResults)
#'
#' @param thingGroupName &#91;required&#93; The thing group name.
#' @param recursive When true, list things in this thing group and in all child groups as
#' well.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_things_in_thing_group(
#'   thingGroupName = "string",
#'   recursive = TRUE|FALSE,
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_things_in_thing_group
iot_list_things_in_thing_group <- function(thingGroupName, recursive = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListThingsInThingGroup",
    http_method = "GET",
    http_path = "/thing-groups/{thingGroupName}/things",
    paginator = list()
  )
  input <- .iot$list_things_in_thing_group_input(thingGroupName = thingGroupName, recursive = recursive, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_things_in_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_things_in_thing_group <- iot_list_things_in_thing_group

#' Lists all the topic rule destinations in your AWS account
#'
#' @description
#' Lists all the topic rule destinations in your AWS account.
#'
#' @usage
#' iot_list_topic_rule_destinations(maxResults, nextToken)
#'
#' @param maxResults The maximum number of results to return at one time.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#'
#' @section Request syntax:
#' ```
#' svc$list_topic_rule_destinations(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_topic_rule_destinations
iot_list_topic_rule_destinations <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListTopicRuleDestinations",
    http_method = "GET",
    http_path = "/destinations",
    paginator = list()
  )
  input <- .iot$list_topic_rule_destinations_input(maxResults = maxResults, nextToken = nextToken)
  output <- .iot$list_topic_rule_destinations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_topic_rule_destinations <- iot_list_topic_rule_destinations

#' Lists the rules for the specific topic
#'
#' @description
#' Lists the rules for the specific topic.
#'
#' @usage
#' iot_list_topic_rules(topic, maxResults, nextToken, ruleDisabled)
#'
#' @param topic The topic.
#' @param maxResults The maximum number of results to return.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param ruleDisabled Specifies whether the rule is disabled.
#'
#' @section Request syntax:
#' ```
#' svc$list_topic_rules(
#'   topic = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   ruleDisabled = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_topic_rules
iot_list_topic_rules <- function(topic = NULL, maxResults = NULL, nextToken = NULL, ruleDisabled = NULL) {
  op <- new_operation(
    name = "ListTopicRules",
    http_method = "GET",
    http_path = "/rules",
    paginator = list()
  )
  input <- .iot$list_topic_rules_input(topic = topic, maxResults = maxResults, nextToken = nextToken, ruleDisabled = ruleDisabled)
  output <- .iot$list_topic_rules_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_topic_rules <- iot_list_topic_rules

#' Lists logging levels
#'
#' @description
#' Lists logging levels.
#'
#' @usage
#' iot_list_v2_logging_levels(targetType, nextToken, maxResults)
#'
#' @param targetType The type of resource for which you are configuring logging. Must be
#' `THING_Group`.
#' @param nextToken To retrieve the next set of results, the `nextToken` value from a
#' previous response; otherwise **null** to receive the first set of
#' results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_v2_logging_levels(
#'   targetType = "DEFAULT"|"THING_GROUP",
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_v2_logging_levels
iot_list_v2_logging_levels <- function(targetType = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListV2LoggingLevels",
    http_method = "GET",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$list_v2_logging_levels_input(targetType = targetType, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_v2_logging_levels_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_v2_logging_levels <- iot_list_v2_logging_levels

#' Lists the Device Defender security profile violations discovered during
#' the given time period
#'
#' @description
#' Lists the Device Defender security profile violations discovered during
#' the given time period. You can use filters to limit the results to those
#' alerts issued for a particular security profile, behavior, or thing
#' (device).
#'
#' @usage
#' iot_list_violation_events(startTime, endTime, thingName,
#'   securityProfileName, behaviorCriteriaType, listSuppressedAlerts,
#'   nextToken, maxResults)
#'
#' @param startTime &#91;required&#93; The start time for the alerts to be listed.
#' @param endTime &#91;required&#93; The end time for the alerts to be listed.
#' @param thingName A filter to limit results to those alerts caused by the specified thing.
#' @param securityProfileName A filter to limit results to those alerts generated by the specified
#' security profile.
#' @param behaviorCriteriaType The criteria for a behavior.
#' @param listSuppressedAlerts A list of all suppressed alerts.
#' @param nextToken The token for the next set of results.
#' @param maxResults The maximum number of results to return at one time.
#'
#' @section Request syntax:
#' ```
#' svc$list_violation_events(
#'   startTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   endTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   thingName = "string",
#'   securityProfileName = "string",
#'   behaviorCriteriaType = "STATIC"|"STATISTICAL"|"MACHINE_LEARNING",
#'   listSuppressedAlerts = TRUE|FALSE,
#'   nextToken = "string",
#'   maxResults = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_list_violation_events
iot_list_violation_events <- function(startTime, endTime, thingName = NULL, securityProfileName = NULL, behaviorCriteriaType = NULL, listSuppressedAlerts = NULL, nextToken = NULL, maxResults = NULL) {
  op <- new_operation(
    name = "ListViolationEvents",
    http_method = "GET",
    http_path = "/violation-events",
    paginator = list()
  )
  input <- .iot$list_violation_events_input(startTime = startTime, endTime = endTime, thingName = thingName, securityProfileName = securityProfileName, behaviorCriteriaType = behaviorCriteriaType, listSuppressedAlerts = listSuppressedAlerts, nextToken = nextToken, maxResults = maxResults)
  output <- .iot$list_violation_events_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$list_violation_events <- iot_list_violation_events

#' Registers a CA certificate with AWS IoT
#'
#' @description
#' Registers a CA certificate with AWS IoT. This CA certificate can then be
#' used to sign device certificates, which can be then registered with AWS
#' IoT. You can register up to 10 CA certificates per AWS account that have
#' the same subject field. This enables you to have up to 10 certificate
#' authorities sign your device certificates. If you have more than one CA
#' certificate registered, make sure you pass the CA certificate when you
#' register your device certificates with the RegisterCertificate API.
#'
#' @usage
#' iot_register_ca_certificate(caCertificate, verificationCertificate,
#'   setAsActive, allowAutoRegistration, registrationConfig, tags)
#'
#' @param caCertificate &#91;required&#93; The CA certificate.
#' @param verificationCertificate &#91;required&#93; The private key verification certificate.
#' @param setAsActive A boolean value that specifies if the CA certificate is set to active.
#' @param allowAutoRegistration Allows this CA certificate to be used for auto registration of device
#' certificates.
#' @param registrationConfig Information about the registration configuration.
#' @param tags Metadata which can be used to manage the CA certificate.
#' 
#' For URI Request parameters use format: ...key1=value1&key2=value2...
#' 
#' For the CLI command-line parameter use format: &&tags
#' "key1=value1&key2=value2..."
#' 
#' For the cli-input-json file use format: "tags":
#' "key1=value1&key2=value2..."
#'
#' @section Request syntax:
#' ```
#' svc$register_ca_certificate(
#'   caCertificate = "string",
#'   verificationCertificate = "string",
#'   setAsActive = TRUE|FALSE,
#'   allowAutoRegistration = TRUE|FALSE,
#'   registrationConfig = list(
#'     templateBody = "string",
#'     roleArn = "string"
#'   ),
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_ca_certificate
iot_register_ca_certificate <- function(caCertificate, verificationCertificate, setAsActive = NULL, allowAutoRegistration = NULL, registrationConfig = NULL, tags = NULL) {
  op <- new_operation(
    name = "RegisterCACertificate",
    http_method = "POST",
    http_path = "/cacertificate",
    paginator = list()
  )
  input <- .iot$register_ca_certificate_input(caCertificate = caCertificate, verificationCertificate = verificationCertificate, setAsActive = setAsActive, allowAutoRegistration = allowAutoRegistration, registrationConfig = registrationConfig, tags = tags)
  output <- .iot$register_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_ca_certificate <- iot_register_ca_certificate

#' Registers a device certificate with AWS IoT
#'
#' @description
#' Registers a device certificate with AWS IoT. If you have more than one
#' CA certificate that has the same subject field, you must specify the CA
#' certificate that was used to sign the device certificate being
#' registered.
#'
#' @usage
#' iot_register_certificate(certificatePem, caCertificatePem, setAsActive,
#'   status)
#'
#' @param certificatePem &#91;required&#93; The certificate data, in PEM format.
#' @param caCertificatePem The CA certificate used to sign the device certificate being registered.
#' @param setAsActive A boolean value that specifies if the certificate is set to active.
#' @param status The status of the register certificate request.
#'
#' @section Request syntax:
#' ```
#' svc$register_certificate(
#'   certificatePem = "string",
#'   caCertificatePem = "string",
#'   setAsActive = TRUE|FALSE,
#'   status = "ACTIVE"|"INACTIVE"|"REVOKED"|"PENDING_TRANSFER"|"REGISTER_INACTIVE"|"PENDING_ACTIVATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_certificate
iot_register_certificate <- function(certificatePem, caCertificatePem = NULL, setAsActive = NULL, status = NULL) {
  op <- new_operation(
    name = "RegisterCertificate",
    http_method = "POST",
    http_path = "/certificate/register",
    paginator = list()
  )
  input <- .iot$register_certificate_input(certificatePem = certificatePem, caCertificatePem = caCertificatePem, setAsActive = setAsActive, status = status)
  output <- .iot$register_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_certificate <- iot_register_certificate

#' Register a certificate that does not have a certificate authority (CA)
#'
#' @description
#' Register a certificate that does not have a certificate authority (CA).
#'
#' @usage
#' iot_register_certificate_without_ca(certificatePem, status)
#'
#' @param certificatePem &#91;required&#93; The certificate data, in PEM format.
#' @param status The status of the register certificate request.
#'
#' @section Request syntax:
#' ```
#' svc$register_certificate_without_ca(
#'   certificatePem = "string",
#'   status = "ACTIVE"|"INACTIVE"|"REVOKED"|"PENDING_TRANSFER"|"REGISTER_INACTIVE"|"PENDING_ACTIVATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_certificate_without_ca
iot_register_certificate_without_ca <- function(certificatePem, status = NULL) {
  op <- new_operation(
    name = "RegisterCertificateWithoutCA",
    http_method = "POST",
    http_path = "/certificate/register-no-ca",
    paginator = list()
  )
  input <- .iot$register_certificate_without_ca_input(certificatePem = certificatePem, status = status)
  output <- .iot$register_certificate_without_ca_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_certificate_without_ca <- iot_register_certificate_without_ca

#' Provisions a thing in the device registry
#'
#' @description
#' Provisions a thing in the device registry. RegisterThing calls other AWS
#' IoT control plane APIs. These calls might exceed your account level [AWS
#' IoT Throttling
#' Limits](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html#limits_iot)
#' and cause throttle errors. Please contact AWS Customer Support to raise
#' your throttling limits if necessary.
#'
#' @usage
#' iot_register_thing(templateBody, parameters)
#'
#' @param templateBody &#91;required&#93; The provisioning template. See [Provisioning Devices That Have Device
#' Certificates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-w-cert.html)
#' for more information.
#' @param parameters The parameters for provisioning a thing. See [Provisioning
#' Templates](https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html)
#' for more information.
#'
#' @section Request syntax:
#' ```
#' svc$register_thing(
#'   templateBody = "string",
#'   parameters = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_register_thing
iot_register_thing <- function(templateBody, parameters = NULL) {
  op <- new_operation(
    name = "RegisterThing",
    http_method = "POST",
    http_path = "/things",
    paginator = list()
  )
  input <- .iot$register_thing_input(templateBody = templateBody, parameters = parameters)
  output <- .iot$register_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$register_thing <- iot_register_thing

#' Rejects a pending certificate transfer
#'
#' @description
#' Rejects a pending certificate transfer. After AWS IoT rejects a
#' certificate transfer, the certificate status changes from
#' **PENDING\\_TRANSFER** to **INACTIVE**.
#' 
#' To check for pending certificate transfers, call
#' [`list_certificates`][iot_list_certificates] to enumerate your
#' certificates.
#' 
#' This operation can only be called by the transfer destination. After it
#' is called, the certificate will be returned to the source's account in
#' the INACTIVE state.
#'
#' @usage
#' iot_reject_certificate_transfer(certificateId, rejectReason)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param rejectReason The reason the certificate transfer was rejected.
#'
#' @section Request syntax:
#' ```
#' svc$reject_certificate_transfer(
#'   certificateId = "string",
#'   rejectReason = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_reject_certificate_transfer
iot_reject_certificate_transfer <- function(certificateId, rejectReason = NULL) {
  op <- new_operation(
    name = "RejectCertificateTransfer",
    http_method = "PATCH",
    http_path = "/reject-certificate-transfer/{certificateId}",
    paginator = list()
  )
  input <- .iot$reject_certificate_transfer_input(certificateId = certificateId, rejectReason = rejectReason)
  output <- .iot$reject_certificate_transfer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$reject_certificate_transfer <- iot_reject_certificate_transfer

#' Removes the given thing from the billing group
#'
#' @description
#' Removes the given thing from the billing group.
#'
#' @usage
#' iot_remove_thing_from_billing_group(billingGroupName, billingGroupArn,
#'   thingName, thingArn)
#'
#' @param billingGroupName The name of the billing group.
#' @param billingGroupArn The ARN of the billing group.
#' @param thingName The name of the thing to be removed from the billing group.
#' @param thingArn The ARN of the thing to be removed from the billing group.
#'
#' @section Request syntax:
#' ```
#' svc$remove_thing_from_billing_group(
#'   billingGroupName = "string",
#'   billingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_remove_thing_from_billing_group
iot_remove_thing_from_billing_group <- function(billingGroupName = NULL, billingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "RemoveThingFromBillingGroup",
    http_method = "PUT",
    http_path = "/billing-groups/removeThingFromBillingGroup",
    paginator = list()
  )
  input <- .iot$remove_thing_from_billing_group_input(billingGroupName = billingGroupName, billingGroupArn = billingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$remove_thing_from_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$remove_thing_from_billing_group <- iot_remove_thing_from_billing_group

#' Remove the specified thing from the specified group
#'
#' @description
#' Remove the specified thing from the specified group.
#' 
#' You must specify either a `thingGroupArn` or a `thingGroupName` to
#' identify the thing group and either a `thingArn` or a `thingName` to
#' identify the thing to remove from the thing group.
#'
#' @usage
#' iot_remove_thing_from_thing_group(thingGroupName, thingGroupArn,
#'   thingName, thingArn)
#'
#' @param thingGroupName The group name.
#' @param thingGroupArn The group ARN.
#' @param thingName The name of the thing to remove from the group.
#' @param thingArn The ARN of the thing to remove from the group.
#'
#' @section Request syntax:
#' ```
#' svc$remove_thing_from_thing_group(
#'   thingGroupName = "string",
#'   thingGroupArn = "string",
#'   thingName = "string",
#'   thingArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_remove_thing_from_thing_group
iot_remove_thing_from_thing_group <- function(thingGroupName = NULL, thingGroupArn = NULL, thingName = NULL, thingArn = NULL) {
  op <- new_operation(
    name = "RemoveThingFromThingGroup",
    http_method = "PUT",
    http_path = "/thing-groups/removeThingFromThingGroup",
    paginator = list()
  )
  input <- .iot$remove_thing_from_thing_group_input(thingGroupName = thingGroupName, thingGroupArn = thingGroupArn, thingName = thingName, thingArn = thingArn)
  output <- .iot$remove_thing_from_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$remove_thing_from_thing_group <- iot_remove_thing_from_thing_group

#' Replaces the rule
#'
#' @description
#' Replaces the rule. You must specify all parameters for the new rule.
#' Creating rules is an administrator-level action. Any user who has
#' permission to create rules will be able to access data processed by the
#' rule.
#'
#' @usage
#' iot_replace_topic_rule(ruleName, topicRulePayload)
#'
#' @param ruleName &#91;required&#93; The name of the rule.
#' @param topicRulePayload &#91;required&#93; The rule payload.
#'
#' @section Request syntax:
#' ```
#' svc$replace_topic_rule(
#'   ruleName = "string",
#'   topicRulePayload = list(
#'     sql = "string",
#'     description = "string",
#'     actions = list(
#'       list(
#'         dynamoDB = list(
#'           tableName = "string",
#'           roleArn = "string",
#'           operation = "string",
#'           hashKeyField = "string",
#'           hashKeyValue = "string",
#'           hashKeyType = "STRING"|"NUMBER",
#'           rangeKeyField = "string",
#'           rangeKeyValue = "string",
#'           rangeKeyType = "STRING"|"NUMBER",
#'           payloadField = "string"
#'         ),
#'         dynamoDBv2 = list(
#'           roleArn = "string",
#'           putItem = list(
#'             tableName = "string"
#'           )
#'         ),
#'         lambda = list(
#'           functionArn = "string"
#'         ),
#'         sns = list(
#'           targetArn = "string",
#'           roleArn = "string",
#'           messageFormat = "RAW"|"JSON"
#'         ),
#'         sqs = list(
#'           roleArn = "string",
#'           queueUrl = "string",
#'           useBase64 = TRUE|FALSE
#'         ),
#'         kinesis = list(
#'           roleArn = "string",
#'           streamName = "string",
#'           partitionKey = "string"
#'         ),
#'         republish = list(
#'           roleArn = "string",
#'           topic = "string",
#'           qos = 123
#'         ),
#'         s3 = list(
#'           roleArn = "string",
#'           bucketName = "string",
#'           key = "string",
#'           cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'         ),
#'         firehose = list(
#'           roleArn = "string",
#'           deliveryStreamName = "string",
#'           separator = "string",
#'           batchMode = TRUE|FALSE
#'         ),
#'         cloudwatchMetric = list(
#'           roleArn = "string",
#'           metricNamespace = "string",
#'           metricName = "string",
#'           metricValue = "string",
#'           metricUnit = "string",
#'           metricTimestamp = "string"
#'         ),
#'         cloudwatchAlarm = list(
#'           roleArn = "string",
#'           alarmName = "string",
#'           stateReason = "string",
#'           stateValue = "string"
#'         ),
#'         cloudwatchLogs = list(
#'           roleArn = "string",
#'           logGroupName = "string"
#'         ),
#'         elasticsearch = list(
#'           roleArn = "string",
#'           endpoint = "string",
#'           index = "string",
#'           type = "string",
#'           id = "string"
#'         ),
#'         salesforce = list(
#'           token = "string",
#'           url = "string"
#'         ),
#'         iotAnalytics = list(
#'           channelArn = "string",
#'           channelName = "string",
#'           batchMode = TRUE|FALSE,
#'           roleArn = "string"
#'         ),
#'         iotEvents = list(
#'           inputName = "string",
#'           messageId = "string",
#'           batchMode = TRUE|FALSE,
#'           roleArn = "string"
#'         ),
#'         iotSiteWise = list(
#'           putAssetPropertyValueEntries = list(
#'             list(
#'               entryId = "string",
#'               assetId = "string",
#'               propertyId = "string",
#'               propertyAlias = "string",
#'               propertyValues = list(
#'                 list(
#'                   value = list(
#'                     stringValue = "string",
#'                     integerValue = "string",
#'                     doubleValue = "string",
#'                     booleanValue = "string"
#'                   ),
#'                   timestamp = list(
#'                     timeInSeconds = "string",
#'                     offsetInNanos = "string"
#'                   ),
#'                   quality = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           roleArn = "string"
#'         ),
#'         stepFunctions = list(
#'           executionNamePrefix = "string",
#'           stateMachineName = "string",
#'           roleArn = "string"
#'         ),
#'         timestream = list(
#'           roleArn = "string",
#'           databaseName = "string",
#'           tableName = "string",
#'           dimensions = list(
#'             list(
#'               name = "string",
#'               value = "string"
#'             )
#'           ),
#'           timestamp = list(
#'             value = "string",
#'             unit = "string"
#'           )
#'         ),
#'         http = list(
#'           url = "string",
#'           confirmationUrl = "string",
#'           headers = list(
#'             list(
#'               key = "string",
#'               value = "string"
#'             )
#'           ),
#'           auth = list(
#'             sigv4 = list(
#'               signingRegion = "string",
#'               serviceName = "string",
#'               roleArn = "string"
#'             )
#'           )
#'         ),
#'         kafka = list(
#'           destinationArn = "string",
#'           topic = "string",
#'           key = "string",
#'           partition = "string",
#'           clientProperties = list(
#'             "string"
#'           )
#'         )
#'       )
#'     ),
#'     ruleDisabled = TRUE|FALSE,
#'     awsIotSqlVersion = "string",
#'     errorAction = list(
#'       dynamoDB = list(
#'         tableName = "string",
#'         roleArn = "string",
#'         operation = "string",
#'         hashKeyField = "string",
#'         hashKeyValue = "string",
#'         hashKeyType = "STRING"|"NUMBER",
#'         rangeKeyField = "string",
#'         rangeKeyValue = "string",
#'         rangeKeyType = "STRING"|"NUMBER",
#'         payloadField = "string"
#'       ),
#'       dynamoDBv2 = list(
#'         roleArn = "string",
#'         putItem = list(
#'           tableName = "string"
#'         )
#'       ),
#'       lambda = list(
#'         functionArn = "string"
#'       ),
#'       sns = list(
#'         targetArn = "string",
#'         roleArn = "string",
#'         messageFormat = "RAW"|"JSON"
#'       ),
#'       sqs = list(
#'         roleArn = "string",
#'         queueUrl = "string",
#'         useBase64 = TRUE|FALSE
#'       ),
#'       kinesis = list(
#'         roleArn = "string",
#'         streamName = "string",
#'         partitionKey = "string"
#'       ),
#'       republish = list(
#'         roleArn = "string",
#'         topic = "string",
#'         qos = 123
#'       ),
#'       s3 = list(
#'         roleArn = "string",
#'         bucketName = "string",
#'         key = "string",
#'         cannedAcl = "private"|"public-read"|"public-read-write"|"aws-exec-read"|"authenticated-read"|"bucket-owner-read"|"bucket-owner-full-control"|"log-delivery-write"
#'       ),
#'       firehose = list(
#'         roleArn = "string",
#'         deliveryStreamName = "string",
#'         separator = "string",
#'         batchMode = TRUE|FALSE
#'       ),
#'       cloudwatchMetric = list(
#'         roleArn = "string",
#'         metricNamespace = "string",
#'         metricName = "string",
#'         metricValue = "string",
#'         metricUnit = "string",
#'         metricTimestamp = "string"
#'       ),
#'       cloudwatchAlarm = list(
#'         roleArn = "string",
#'         alarmName = "string",
#'         stateReason = "string",
#'         stateValue = "string"
#'       ),
#'       cloudwatchLogs = list(
#'         roleArn = "string",
#'         logGroupName = "string"
#'       ),
#'       elasticsearch = list(
#'         roleArn = "string",
#'         endpoint = "string",
#'         index = "string",
#'         type = "string",
#'         id = "string"
#'       ),
#'       salesforce = list(
#'         token = "string",
#'         url = "string"
#'       ),
#'       iotAnalytics = list(
#'         channelArn = "string",
#'         channelName = "string",
#'         batchMode = TRUE|FALSE,
#'         roleArn = "string"
#'       ),
#'       iotEvents = list(
#'         inputName = "string",
#'         messageId = "string",
#'         batchMode = TRUE|FALSE,
#'         roleArn = "string"
#'       ),
#'       iotSiteWise = list(
#'         putAssetPropertyValueEntries = list(
#'           list(
#'             entryId = "string",
#'             assetId = "string",
#'             propertyId = "string",
#'             propertyAlias = "string",
#'             propertyValues = list(
#'               list(
#'                 value = list(
#'                   stringValue = "string",
#'                   integerValue = "string",
#'                   doubleValue = "string",
#'                   booleanValue = "string"
#'                 ),
#'                 timestamp = list(
#'                   timeInSeconds = "string",
#'                   offsetInNanos = "string"
#'                 ),
#'                 quality = "string"
#'               )
#'             )
#'           )
#'         ),
#'         roleArn = "string"
#'       ),
#'       stepFunctions = list(
#'         executionNamePrefix = "string",
#'         stateMachineName = "string",
#'         roleArn = "string"
#'       ),
#'       timestream = list(
#'         roleArn = "string",
#'         databaseName = "string",
#'         tableName = "string",
#'         dimensions = list(
#'           list(
#'             name = "string",
#'             value = "string"
#'           )
#'         ),
#'         timestamp = list(
#'           value = "string",
#'           unit = "string"
#'         )
#'       ),
#'       http = list(
#'         url = "string",
#'         confirmationUrl = "string",
#'         headers = list(
#'           list(
#'             key = "string",
#'             value = "string"
#'           )
#'         ),
#'         auth = list(
#'           sigv4 = list(
#'             signingRegion = "string",
#'             serviceName = "string",
#'             roleArn = "string"
#'           )
#'         )
#'       ),
#'       kafka = list(
#'         destinationArn = "string",
#'         topic = "string",
#'         key = "string",
#'         partition = "string",
#'         clientProperties = list(
#'           "string"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_replace_topic_rule
iot_replace_topic_rule <- function(ruleName, topicRulePayload) {
  op <- new_operation(
    name = "ReplaceTopicRule",
    http_method = "PATCH",
    http_path = "/rules/{ruleName}",
    paginator = list()
  )
  input <- .iot$replace_topic_rule_input(ruleName = ruleName, topicRulePayload = topicRulePayload)
  output <- .iot$replace_topic_rule_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$replace_topic_rule <- iot_replace_topic_rule

#' The query search index
#'
#' @description
#' The query search index.
#'
#' @usage
#' iot_search_index(indexName, queryString, nextToken, maxResults,
#'   queryVersion)
#'
#' @param indexName The search index name.
#' @param queryString &#91;required&#93; The search query string.
#' @param nextToken The token used to get the next set of results, or `null` if there are no
#' additional results.
#' @param maxResults The maximum number of results to return at one time.
#' @param queryVersion The query version.
#'
#' @section Request syntax:
#' ```
#' svc$search_index(
#'   indexName = "string",
#'   queryString = "string",
#'   nextToken = "string",
#'   maxResults = 123,
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_search_index
iot_search_index <- function(indexName = NULL, queryString, nextToken = NULL, maxResults = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "SearchIndex",
    http_method = "POST",
    http_path = "/indices/search",
    paginator = list()
  )
  input <- .iot$search_index_input(indexName = indexName, queryString = queryString, nextToken = nextToken, maxResults = maxResults, queryVersion = queryVersion)
  output <- .iot$search_index_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$search_index <- iot_search_index

#' Sets the default authorizer
#'
#' @description
#' Sets the default authorizer. This will be used if a websocket connection
#' is made without specifying an authorizer.
#'
#' @usage
#' iot_set_default_authorizer(authorizerName)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#'
#' @section Request syntax:
#' ```
#' svc$set_default_authorizer(
#'   authorizerName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_default_authorizer
iot_set_default_authorizer <- function(authorizerName) {
  op <- new_operation(
    name = "SetDefaultAuthorizer",
    http_method = "POST",
    http_path = "/default-authorizer",
    paginator = list()
  )
  input <- .iot$set_default_authorizer_input(authorizerName = authorizerName)
  output <- .iot$set_default_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_default_authorizer <- iot_set_default_authorizer

#' Sets the specified version of the specified policy as the policy's
#' default (operative) version
#'
#' @description
#' Sets the specified version of the specified policy as the policy's
#' default (operative) version. This action affects all certificates to
#' which the policy is attached. To list the principals the policy is
#' attached to, use the ListPrincipalPolicy API.
#'
#' @usage
#' iot_set_default_policy_version(policyName, policyVersionId)
#'
#' @param policyName &#91;required&#93; The policy name.
#' @param policyVersionId &#91;required&#93; The policy version ID.
#'
#' @section Request syntax:
#' ```
#' svc$set_default_policy_version(
#'   policyName = "string",
#'   policyVersionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_default_policy_version
iot_set_default_policy_version <- function(policyName, policyVersionId) {
  op <- new_operation(
    name = "SetDefaultPolicyVersion",
    http_method = "PATCH",
    http_path = "/policies/{policyName}/version/{policyVersionId}",
    paginator = list()
  )
  input <- .iot$set_default_policy_version_input(policyName = policyName, policyVersionId = policyVersionId)
  output <- .iot$set_default_policy_version_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_default_policy_version <- iot_set_default_policy_version

#' Sets the logging options
#'
#' @description
#' Sets the logging options.
#' 
#' NOTE: use of this command is not recommended. Use
#' [`set_v2_logging_options`][iot_set_v2_logging_options] instead.
#'
#' @usage
#' iot_set_logging_options(loggingOptionsPayload)
#'
#' @param loggingOptionsPayload &#91;required&#93; The logging options payload.
#'
#' @section Request syntax:
#' ```
#' svc$set_logging_options(
#'   loggingOptionsPayload = list(
#'     roleArn = "string",
#'     logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_logging_options
iot_set_logging_options <- function(loggingOptionsPayload) {
  op <- new_operation(
    name = "SetLoggingOptions",
    http_method = "POST",
    http_path = "/loggingOptions",
    paginator = list()
  )
  input <- .iot$set_logging_options_input(loggingOptionsPayload = loggingOptionsPayload)
  output <- .iot$set_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_logging_options <- iot_set_logging_options

#' Sets the logging level
#'
#' @description
#' Sets the logging level.
#'
#' @usage
#' iot_set_v2_logging_level(logTarget, logLevel)
#'
#' @param logTarget &#91;required&#93; The log target.
#' @param logLevel &#91;required&#93; The log level.
#'
#' @section Request syntax:
#' ```
#' svc$set_v2_logging_level(
#'   logTarget = list(
#'     targetType = "DEFAULT"|"THING_GROUP",
#'     targetName = "string"
#'   ),
#'   logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_v2_logging_level
iot_set_v2_logging_level <- function(logTarget, logLevel) {
  op <- new_operation(
    name = "SetV2LoggingLevel",
    http_method = "POST",
    http_path = "/v2LoggingLevel",
    paginator = list()
  )
  input <- .iot$set_v2_logging_level_input(logTarget = logTarget, logLevel = logLevel)
  output <- .iot$set_v2_logging_level_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_v2_logging_level <- iot_set_v2_logging_level

#' Sets the logging options for the V2 logging service
#'
#' @description
#' Sets the logging options for the V2 logging service.
#'
#' @usage
#' iot_set_v2_logging_options(roleArn, defaultLogLevel, disableAllLogs)
#'
#' @param roleArn The ARN of the role that allows IoT to write to Cloudwatch logs.
#' @param defaultLogLevel The default logging level.
#' @param disableAllLogs If true all logs are disabled. The default is false.
#'
#' @section Request syntax:
#' ```
#' svc$set_v2_logging_options(
#'   roleArn = "string",
#'   defaultLogLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED",
#'   disableAllLogs = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_set_v2_logging_options
iot_set_v2_logging_options <- function(roleArn = NULL, defaultLogLevel = NULL, disableAllLogs = NULL) {
  op <- new_operation(
    name = "SetV2LoggingOptions",
    http_method = "POST",
    http_path = "/v2LoggingOptions",
    paginator = list()
  )
  input <- .iot$set_v2_logging_options_input(roleArn = roleArn, defaultLogLevel = defaultLogLevel, disableAllLogs = disableAllLogs)
  output <- .iot$set_v2_logging_options_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$set_v2_logging_options <- iot_set_v2_logging_options

#' Starts a task that applies a set of mitigation actions to the specified
#' target
#'
#' @description
#' Starts a task that applies a set of mitigation actions to the specified
#' target.
#'
#' @usage
#' iot_start_audit_mitigation_actions_task(taskId, target,
#'   auditCheckToActionsMapping, clientRequestToken)
#'
#' @param taskId &#91;required&#93; A unique identifier for the task. You can use this identifier to check
#' the status of the task or to cancel it.
#' @param target &#91;required&#93; Specifies the audit findings to which the mitigation actions are
#' applied. You can apply them to a type of audit check, to all findings
#' from an audit, or to a specific set of findings.
#' @param auditCheckToActionsMapping &#91;required&#93; For an audit check, specifies which mitigation actions to apply. Those
#' actions must be defined in your AWS account.
#' @param clientRequestToken &#91;required&#93; Each audit mitigation task must have a unique client request token. If
#' you try to start a new task with the same token as a task that already
#' exists, an exception occurs. If you omit this value, a unique client
#' request token is generated automatically.
#'
#' @section Request syntax:
#' ```
#' svc$start_audit_mitigation_actions_task(
#'   taskId = "string",
#'   target = list(
#'     auditTaskId = "string",
#'     findingIds = list(
#'       "string"
#'     ),
#'     auditCheckToReasonCodeFilter = list(
#'       list(
#'         "string"
#'       )
#'     )
#'   ),
#'   auditCheckToActionsMapping = list(
#'     list(
#'       "string"
#'     )
#'   ),
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_audit_mitigation_actions_task
iot_start_audit_mitigation_actions_task <- function(taskId, target, auditCheckToActionsMapping, clientRequestToken) {
  op <- new_operation(
    name = "StartAuditMitigationActionsTask",
    http_method = "POST",
    http_path = "/audit/mitigationactions/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$start_audit_mitigation_actions_task_input(taskId = taskId, target = target, auditCheckToActionsMapping = auditCheckToActionsMapping, clientRequestToken = clientRequestToken)
  output <- .iot$start_audit_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_audit_mitigation_actions_task <- iot_start_audit_mitigation_actions_task

#' Starts a Device Defender ML Detect mitigation actions task
#'
#' @description
#' Starts a Device Defender ML Detect mitigation actions task.
#'
#' @usage
#' iot_start_detect_mitigation_actions_task(taskId, target, actions,
#'   violationEventOccurrenceRange, includeOnlyActiveViolations,
#'   includeSuppressedAlerts, clientRequestToken)
#'
#' @param taskId &#91;required&#93; The unique identifier of the task.
#' @param target &#91;required&#93; Specifies the ML Detect findings to which the mitigation actions are
#' applied.
#' @param actions &#91;required&#93; The actions to be performed when a device has unexpected behavior.
#' @param violationEventOccurrenceRange Specifies the time period of which violation events occurred between.
#' @param includeOnlyActiveViolations Specifies to list only active violations.
#' @param includeSuppressedAlerts Specifies to include suppressed alerts.
#' @param clientRequestToken &#91;required&#93; Each mitigation action task must have a unique client request token. If
#' you try to create a new task with the same token as a task that already
#' exists, an exception occurs. If you omit this value, AWS SDKs will
#' automatically generate a unique client request.
#'
#' @section Request syntax:
#' ```
#' svc$start_detect_mitigation_actions_task(
#'   taskId = "string",
#'   target = list(
#'     violationIds = list(
#'       "string"
#'     ),
#'     securityProfileName = "string",
#'     behaviorName = "string"
#'   ),
#'   actions = list(
#'     "string"
#'   ),
#'   violationEventOccurrenceRange = list(
#'     startTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     endTime = as.POSIXct(
#'       "2015-01-01"
#'     )
#'   ),
#'   includeOnlyActiveViolations = TRUE|FALSE,
#'   includeSuppressedAlerts = TRUE|FALSE,
#'   clientRequestToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_detect_mitigation_actions_task
iot_start_detect_mitigation_actions_task <- function(taskId, target, actions, violationEventOccurrenceRange = NULL, includeOnlyActiveViolations = NULL, includeSuppressedAlerts = NULL, clientRequestToken) {
  op <- new_operation(
    name = "StartDetectMitigationActionsTask",
    http_method = "PUT",
    http_path = "/detect/mitigationactions/tasks/{taskId}",
    paginator = list()
  )
  input <- .iot$start_detect_mitigation_actions_task_input(taskId = taskId, target = target, actions = actions, violationEventOccurrenceRange = violationEventOccurrenceRange, includeOnlyActiveViolations = includeOnlyActiveViolations, includeSuppressedAlerts = includeSuppressedAlerts, clientRequestToken = clientRequestToken)
  output <- .iot$start_detect_mitigation_actions_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_detect_mitigation_actions_task <- iot_start_detect_mitigation_actions_task

#' Starts an on-demand Device Defender audit
#'
#' @description
#' Starts an on-demand Device Defender audit.
#'
#' @usage
#' iot_start_on_demand_audit_task(targetCheckNames)
#'
#' @param targetCheckNames &#91;required&#93; Which checks are performed during the audit. The checks you specify must
#' be enabled for your account or an exception occurs. Use
#' [`describe_account_audit_configuration`][iot_describe_account_audit_configuration]
#' to see the list of all checks, including those that are enabled or
#' [`update_account_audit_configuration`][iot_update_account_audit_configuration]
#' to select which checks are enabled.
#'
#' @section Request syntax:
#' ```
#' svc$start_on_demand_audit_task(
#'   targetCheckNames = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_on_demand_audit_task
iot_start_on_demand_audit_task <- function(targetCheckNames) {
  op <- new_operation(
    name = "StartOnDemandAuditTask",
    http_method = "POST",
    http_path = "/audit/tasks",
    paginator = list()
  )
  input <- .iot$start_on_demand_audit_task_input(targetCheckNames = targetCheckNames)
  output <- .iot$start_on_demand_audit_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_on_demand_audit_task <- iot_start_on_demand_audit_task

#' Creates a bulk thing provisioning task
#'
#' @description
#' Creates a bulk thing provisioning task.
#'
#' @usage
#' iot_start_thing_registration_task(templateBody, inputFileBucket,
#'   inputFileKey, roleArn)
#'
#' @param templateBody &#91;required&#93; The provisioning template.
#' @param inputFileBucket &#91;required&#93; The S3 bucket that contains the input file.
#' @param inputFileKey &#91;required&#93; The name of input file within the S3 bucket. This file contains a
#' newline delimited JSON file. Each line contains the parameter values to
#' provision one device (thing).
#' @param roleArn &#91;required&#93; The IAM role ARN that grants permission the input file.
#'
#' @section Request syntax:
#' ```
#' svc$start_thing_registration_task(
#'   templateBody = "string",
#'   inputFileBucket = "string",
#'   inputFileKey = "string",
#'   roleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_start_thing_registration_task
iot_start_thing_registration_task <- function(templateBody, inputFileBucket, inputFileKey, roleArn) {
  op <- new_operation(
    name = "StartThingRegistrationTask",
    http_method = "POST",
    http_path = "/thing-registration-tasks",
    paginator = list()
  )
  input <- .iot$start_thing_registration_task_input(templateBody = templateBody, inputFileBucket = inputFileBucket, inputFileKey = inputFileKey, roleArn = roleArn)
  output <- .iot$start_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$start_thing_registration_task <- iot_start_thing_registration_task

#' Cancels a bulk thing provisioning task
#'
#' @description
#' Cancels a bulk thing provisioning task.
#'
#' @usage
#' iot_stop_thing_registration_task(taskId)
#'
#' @param taskId &#91;required&#93; The bulk thing provisioning task ID.
#'
#' @section Request syntax:
#' ```
#' svc$stop_thing_registration_task(
#'   taskId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_stop_thing_registration_task
iot_stop_thing_registration_task <- function(taskId) {
  op <- new_operation(
    name = "StopThingRegistrationTask",
    http_method = "PUT",
    http_path = "/thing-registration-tasks/{taskId}/cancel",
    paginator = list()
  )
  input <- .iot$stop_thing_registration_task_input(taskId = taskId)
  output <- .iot$stop_thing_registration_task_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$stop_thing_registration_task <- iot_stop_thing_registration_task

#' Adds to or modifies the tags of the given resource
#'
#' @description
#' Adds to or modifies the tags of the given resource. Tags are metadata
#' which can be used to manage a resource.
#'
#' @usage
#' iot_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param tags &#91;required&#93; The new or modified tags for the resource.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     list(
#'       Key = "string",
#'       Value = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_tag_resource
iot_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags",
    paginator = list()
  )
  input <- .iot$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .iot$tag_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$tag_resource <- iot_tag_resource

#' Tests if a specified principal is authorized to perform an AWS IoT
#' action on a specified resource
#'
#' @description
#' Tests if a specified principal is authorized to perform an AWS IoT
#' action on a specified resource. Use this to test and debug the
#' authorization behavior of devices that connect to the AWS IoT device
#' gateway.
#'
#' @usage
#' iot_test_authorization(principal, cognitoIdentityPoolId, authInfos,
#'   clientId, policyNamesToAdd, policyNamesToSkip)
#'
#' @param principal The principal. Valid principals are CertificateArn
#' (arn:aws:iot:*region*:*accountId*:cert/*certificateId*), thingGroupArn
#' (arn:aws:iot:*region*:*accountId*:thinggroup/*groupName*) and CognitoId
#' (*region*:*id*).
#' @param cognitoIdentityPoolId The Cognito identity pool ID.
#' @param authInfos &#91;required&#93; A list of authorization info objects. Simulating authorization will
#' create a response for each `authInfo` object in the list.
#' @param clientId The MQTT client ID.
#' @param policyNamesToAdd When testing custom authorization, the policies specified here are
#' treated as if they are attached to the principal being authorized.
#' @param policyNamesToSkip When testing custom authorization, the policies specified here are
#' treated as if they are not attached to the principal being authorized.
#'
#' @section Request syntax:
#' ```
#' svc$test_authorization(
#'   principal = "string",
#'   cognitoIdentityPoolId = "string",
#'   authInfos = list(
#'     list(
#'       actionType = "PUBLISH"|"SUBSCRIBE"|"RECEIVE"|"CONNECT",
#'       resources = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   clientId = "string",
#'   policyNamesToAdd = list(
#'     "string"
#'   ),
#'   policyNamesToSkip = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_test_authorization
iot_test_authorization <- function(principal = NULL, cognitoIdentityPoolId = NULL, authInfos, clientId = NULL, policyNamesToAdd = NULL, policyNamesToSkip = NULL) {
  op <- new_operation(
    name = "TestAuthorization",
    http_method = "POST",
    http_path = "/test-authorization",
    paginator = list()
  )
  input <- .iot$test_authorization_input(principal = principal, cognitoIdentityPoolId = cognitoIdentityPoolId, authInfos = authInfos, clientId = clientId, policyNamesToAdd = policyNamesToAdd, policyNamesToSkip = policyNamesToSkip)
  output <- .iot$test_authorization_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$test_authorization <- iot_test_authorization

#' Tests a custom authorization behavior by invoking a specified custom
#' authorizer
#'
#' @description
#' Tests a custom authorization behavior by invoking a specified custom
#' authorizer. Use this to test and debug the custom authorization behavior
#' of devices that connect to the AWS IoT device gateway.
#'
#' @usage
#' iot_test_invoke_authorizer(authorizerName, token, tokenSignature,
#'   httpContext, mqttContext, tlsContext)
#'
#' @param authorizerName &#91;required&#93; The custom authorizer name.
#' @param token The token returned by your custom authentication service.
#' @param tokenSignature The signature made with the token and your custom authentication
#' service's private key. This value must be Base-64-encoded.
#' @param httpContext Specifies a test HTTP authorization request.
#' @param mqttContext Specifies a test MQTT authorization request.
#' @param tlsContext Specifies a test TLS authorization request.
#'
#' @section Request syntax:
#' ```
#' svc$test_invoke_authorizer(
#'   authorizerName = "string",
#'   token = "string",
#'   tokenSignature = "string",
#'   httpContext = list(
#'     headers = list(
#'       "string"
#'     ),
#'     queryString = "string"
#'   ),
#'   mqttContext = list(
#'     username = "string",
#'     password = raw,
#'     clientId = "string"
#'   ),
#'   tlsContext = list(
#'     serverName = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_test_invoke_authorizer
iot_test_invoke_authorizer <- function(authorizerName, token = NULL, tokenSignature = NULL, httpContext = NULL, mqttContext = NULL, tlsContext = NULL) {
  op <- new_operation(
    name = "TestInvokeAuthorizer",
    http_method = "POST",
    http_path = "/authorizer/{authorizerName}/test",
    paginator = list()
  )
  input <- .iot$test_invoke_authorizer_input(authorizerName = authorizerName, token = token, tokenSignature = tokenSignature, httpContext = httpContext, mqttContext = mqttContext, tlsContext = tlsContext)
  output <- .iot$test_invoke_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$test_invoke_authorizer <- iot_test_invoke_authorizer

#' Transfers the specified certificate to the specified AWS account
#'
#' @description
#' Transfers the specified certificate to the specified AWS account.
#' 
#' You can cancel the transfer until it is acknowledged by the recipient.
#' 
#' No notification is sent to the transfer destination's account. It is up
#' to the caller to notify the transfer target.
#' 
#' The certificate being transferred must not be in the ACTIVE state. You
#' can use the UpdateCertificate API to deactivate it.
#' 
#' The certificate must not have any policies attached to it. You can use
#' the DetachPrincipalPolicy API to detach them.
#'
#' @usage
#' iot_transfer_certificate(certificateId, targetAwsAccount,
#'   transferMessage)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param targetAwsAccount &#91;required&#93; The AWS account.
#' @param transferMessage The transfer message.
#'
#' @section Request syntax:
#' ```
#' svc$transfer_certificate(
#'   certificateId = "string",
#'   targetAwsAccount = "string",
#'   transferMessage = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_transfer_certificate
iot_transfer_certificate <- function(certificateId, targetAwsAccount, transferMessage = NULL) {
  op <- new_operation(
    name = "TransferCertificate",
    http_method = "PATCH",
    http_path = "/transfer-certificate/{certificateId}",
    paginator = list()
  )
  input <- .iot$transfer_certificate_input(certificateId = certificateId, targetAwsAccount = targetAwsAccount, transferMessage = transferMessage)
  output <- .iot$transfer_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$transfer_certificate <- iot_transfer_certificate

#' Removes the given tags (metadata) from the resource
#'
#' @description
#' Removes the given tags (metadata) from the resource.
#'
#' @usage
#' iot_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of the resource.
#' @param tagKeys &#91;required&#93; A list of the keys of the tags to be removed from the resource.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_untag_resource
iot_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "POST",
    http_path = "/untag",
    paginator = list()
  )
  input <- .iot$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .iot$untag_resource_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$untag_resource <- iot_untag_resource

#' Configures or reconfigures the Device Defender audit settings for this
#' account
#'
#' @description
#' Configures or reconfigures the Device Defender audit settings for this
#' account. Settings include how audit notifications are sent and which
#' audit checks are enabled or disabled.
#'
#' @usage
#' iot_update_account_audit_configuration(roleArn,
#'   auditNotificationTargetConfigurations, auditCheckConfigurations)
#'
#' @param roleArn The Amazon Resource Name (ARN) of the role that grants permission to AWS
#' IoT to access information about your devices, policies, certificates,
#' and other items as required when performing an audit.
#' @param auditNotificationTargetConfigurations Information about the targets to which audit notifications are sent.
#' @param auditCheckConfigurations Specifies which audit checks are enabled and disabled for this account.
#' Use
#' [`describe_account_audit_configuration`][iot_describe_account_audit_configuration]
#' to see the list of all checks, including those that are currently
#' enabled.
#' 
#' Some data collection might start immediately when certain checks are
#' enabled. When a check is disabled, any data collected so far in relation
#' to the check is deleted.
#' 
#' You cannot disable a check if it's used by any scheduled audit. You must
#' first delete the check from the scheduled audit or delete the scheduled
#' audit itself.
#' 
#' On the first call to
#' [`update_account_audit_configuration`][iot_update_account_audit_configuration],
#' this parameter is required and must specify at least one enabled check.
#'
#' @section Request syntax:
#' ```
#' svc$update_account_audit_configuration(
#'   roleArn = "string",
#'   auditNotificationTargetConfigurations = list(
#'     list(
#'       targetArn = "string",
#'       roleArn = "string",
#'       enabled = TRUE|FALSE
#'     )
#'   ),
#'   auditCheckConfigurations = list(
#'     list(
#'       enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_account_audit_configuration
iot_update_account_audit_configuration <- function(roleArn = NULL, auditNotificationTargetConfigurations = NULL, auditCheckConfigurations = NULL) {
  op <- new_operation(
    name = "UpdateAccountAuditConfiguration",
    http_method = "PATCH",
    http_path = "/audit/configuration",
    paginator = list()
  )
  input <- .iot$update_account_audit_configuration_input(roleArn = roleArn, auditNotificationTargetConfigurations = auditNotificationTargetConfigurations, auditCheckConfigurations = auditCheckConfigurations)
  output <- .iot$update_account_audit_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_account_audit_configuration <- iot_update_account_audit_configuration

#' Updates a Device Defender audit suppression
#'
#' @description
#' Updates a Device Defender audit suppression.
#'
#' @usage
#' iot_update_audit_suppression(checkName, resourceIdentifier,
#'   expirationDate, suppressIndefinitely, description)
#'
#' @param checkName &#91;required&#93; 
#' @param resourceIdentifier &#91;required&#93; 
#' @param expirationDate The expiration date (epoch timestamp in seconds) that you want the
#' suppression to adhere to.
#' @param suppressIndefinitely Indicates whether a suppression should exist indefinitely or not.
#' @param description The description of the audit suppression.
#'
#' @section Request syntax:
#' ```
#' svc$update_audit_suppression(
#'   checkName = "string",
#'   resourceIdentifier = list(
#'     deviceCertificateId = "string",
#'     caCertificateId = "string",
#'     cognitoIdentityPoolId = "string",
#'     clientId = "string",
#'     policyVersionIdentifier = list(
#'       policyName = "string",
#'       policyVersionId = "string"
#'     ),
#'     account = "string",
#'     iamRoleArn = "string",
#'     roleAliasArn = "string"
#'   ),
#'   expirationDate = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   suppressIndefinitely = TRUE|FALSE,
#'   description = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_audit_suppression
iot_update_audit_suppression <- function(checkName, resourceIdentifier, expirationDate = NULL, suppressIndefinitely = NULL, description = NULL) {
  op <- new_operation(
    name = "UpdateAuditSuppression",
    http_method = "PATCH",
    http_path = "/audit/suppressions/update",
    paginator = list()
  )
  input <- .iot$update_audit_suppression_input(checkName = checkName, resourceIdentifier = resourceIdentifier, expirationDate = expirationDate, suppressIndefinitely = suppressIndefinitely, description = description)
  output <- .iot$update_audit_suppression_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_audit_suppression <- iot_update_audit_suppression

#' Updates an authorizer
#'
#' @description
#' Updates an authorizer.
#'
#' @usage
#' iot_update_authorizer(authorizerName, authorizerFunctionArn,
#'   tokenKeyName, tokenSigningPublicKeys, status)
#'
#' @param authorizerName &#91;required&#93; The authorizer name.
#' @param authorizerFunctionArn The ARN of the authorizer's Lambda function.
#' @param tokenKeyName The key used to extract the token from the HTTP headers.
#' @param tokenSigningPublicKeys The public keys used to verify the token signature.
#' @param status The status of the update authorizer request.
#'
#' @section Request syntax:
#' ```
#' svc$update_authorizer(
#'   authorizerName = "string",
#'   authorizerFunctionArn = "string",
#'   tokenKeyName = "string",
#'   tokenSigningPublicKeys = list(
#'     "string"
#'   ),
#'   status = "ACTIVE"|"INACTIVE"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_authorizer
iot_update_authorizer <- function(authorizerName, authorizerFunctionArn = NULL, tokenKeyName = NULL, tokenSigningPublicKeys = NULL, status = NULL) {
  op <- new_operation(
    name = "UpdateAuthorizer",
    http_method = "PUT",
    http_path = "/authorizer/{authorizerName}",
    paginator = list()
  )
  input <- .iot$update_authorizer_input(authorizerName = authorizerName, authorizerFunctionArn = authorizerFunctionArn, tokenKeyName = tokenKeyName, tokenSigningPublicKeys = tokenSigningPublicKeys, status = status)
  output <- .iot$update_authorizer_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_authorizer <- iot_update_authorizer

#' Updates information about the billing group
#'
#' @description
#' Updates information about the billing group.
#'
#' @usage
#' iot_update_billing_group(billingGroupName, billingGroupProperties,
#'   expectedVersion)
#'
#' @param billingGroupName &#91;required&#93; The name of the billing group.
#' @param billingGroupProperties &#91;required&#93; The properties of the billing group.
#' @param expectedVersion The expected version of the billing group. If the version of the billing
#' group does not match the expected version specified in the request, the
#' [`update_billing_group`][iot_update_billing_group] request is rejected
#' with a `VersionConflictException`.
#'
#' @section Request syntax:
#' ```
#' svc$update_billing_group(
#'   billingGroupName = "string",
#'   billingGroupProperties = list(
#'     billingGroupDescription = "string"
#'   ),
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_billing_group
iot_update_billing_group <- function(billingGroupName, billingGroupProperties, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateBillingGroup",
    http_method = "PATCH",
    http_path = "/billing-groups/{billingGroupName}",
    paginator = list()
  )
  input <- .iot$update_billing_group_input(billingGroupName = billingGroupName, billingGroupProperties = billingGroupProperties, expectedVersion = expectedVersion)
  output <- .iot$update_billing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_billing_group <- iot_update_billing_group

#' Updates a registered CA certificate
#'
#' @description
#' Updates a registered CA certificate.
#'
#' @usage
#' iot_update_ca_certificate(certificateId, newStatus,
#'   newAutoRegistrationStatus, registrationConfig, removeAutoRegistration)
#'
#' @param certificateId &#91;required&#93; The CA certificate identifier.
#' @param newStatus The updated status of the CA certificate.
#' 
#' **Note:** The status value REGISTER\\_INACTIVE is deprecated and should
#' not be used.
#' @param newAutoRegistrationStatus The new value for the auto registration status. Valid values are:
#' "ENABLE" or "DISABLE".
#' @param registrationConfig Information about the registration configuration.
#' @param removeAutoRegistration If true, removes auto registration.
#'
#' @section Request syntax:
#' ```
#' svc$update_ca_certificate(
#'   certificateId = "string",
#'   newStatus = "ACTIVE"|"INACTIVE",
#'   newAutoRegistrationStatus = "ENABLE"|"DISABLE",
#'   registrationConfig = list(
#'     templateBody = "string",
#'     roleArn = "string"
#'   ),
#'   removeAutoRegistration = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_ca_certificate
iot_update_ca_certificate <- function(certificateId, newStatus = NULL, newAutoRegistrationStatus = NULL, registrationConfig = NULL, removeAutoRegistration = NULL) {
  op <- new_operation(
    name = "UpdateCACertificate",
    http_method = "PUT",
    http_path = "/cacertificate/{caCertificateId}",
    paginator = list()
  )
  input <- .iot$update_ca_certificate_input(certificateId = certificateId, newStatus = newStatus, newAutoRegistrationStatus = newAutoRegistrationStatus, registrationConfig = registrationConfig, removeAutoRegistration = removeAutoRegistration)
  output <- .iot$update_ca_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_ca_certificate <- iot_update_ca_certificate

#' Updates the status of the specified certificate
#'
#' @description
#' Updates the status of the specified certificate. This operation is
#' idempotent.
#' 
#' Certificates must be in the ACTIVE state to authenticate devices that
#' use a certificate to connect to AWS IoT.
#' 
#' Within a few minutes of updating a certificate from the ACTIVE state to
#' any other state, AWS IoT disconnects all devices that used that
#' certificate to connect. Devices cannot use a certificate that is not in
#' the ACTIVE state to reconnect.
#'
#' @usage
#' iot_update_certificate(certificateId, newStatus)
#'
#' @param certificateId &#91;required&#93; The ID of the certificate. (The last part of the certificate ARN
#' contains the certificate ID.)
#' @param newStatus &#91;required&#93; The new status.
#' 
#' **Note:** Setting the status to PENDING\\_TRANSFER or PENDING\\_ACTIVATION
#' will result in an exception being thrown. PENDING\\_TRANSFER and
#' PENDING\\_ACTIVATION are statuses used internally by AWS IoT. They are
#' not intended for developer use.
#' 
#' **Note:** The status value REGISTER\\_INACTIVE is deprecated and should
#' not be used.
#'
#' @section Request syntax:
#' ```
#' svc$update_certificate(
#'   certificateId = "string",
#'   newStatus = "ACTIVE"|"INACTIVE"|"REVOKED"|"PENDING_TRANSFER"|"REGISTER_INACTIVE"|"PENDING_ACTIVATION"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_certificate
iot_update_certificate <- function(certificateId, newStatus) {
  op <- new_operation(
    name = "UpdateCertificate",
    http_method = "PUT",
    http_path = "/certificates/{certificateId}",
    paginator = list()
  )
  input <- .iot$update_certificate_input(certificateId = certificateId, newStatus = newStatus)
  output <- .iot$update_certificate_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_certificate <- iot_update_certificate

#' Updates a Device Defender detect custom metric
#'
#' @description
#' Updates a Device Defender detect custom metric.
#'
#' @usage
#' iot_update_custom_metric(metricName, displayName)
#'
#' @param metricName &#91;required&#93; The name of the custom metric. Cannot be updated.
#' @param displayName &#91;required&#93; Field represents a friendly name in the console for the custom metric,
#' it doesn't have to be unique. Don't use this name as the metric
#' identifier in the device metric report. Can be updated.
#'
#' @section Request syntax:
#' ```
#' svc$update_custom_metric(
#'   metricName = "string",
#'   displayName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_custom_metric
iot_update_custom_metric <- function(metricName, displayName) {
  op <- new_operation(
    name = "UpdateCustomMetric",
    http_method = "PATCH",
    http_path = "/custom-metric/{metricName}",
    paginator = list()
  )
  input <- .iot$update_custom_metric_input(metricName = metricName, displayName = displayName)
  output <- .iot$update_custom_metric_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_custom_metric <- iot_update_custom_metric

#' Updates the definition for a dimension
#'
#' @description
#' Updates the definition for a dimension. You cannot change the type of a
#' dimension after it is created (you can delete it and recreate it).
#'
#' @usage
#' iot_update_dimension(name, stringValues)
#'
#' @param name &#91;required&#93; A unique identifier for the dimension. Choose something that describes
#' the type and value to make it easy to remember what it does.
#' @param stringValues &#91;required&#93; Specifies the value or list of values for the dimension. For
#' `TOPIC_FILTER` dimensions, this is a pattern used to match the MQTT
#' topic (for example, "admin/\\#").
#'
#' @section Request syntax:
#' ```
#' svc$update_dimension(
#'   name = "string",
#'   stringValues = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_dimension
iot_update_dimension <- function(name, stringValues) {
  op <- new_operation(
    name = "UpdateDimension",
    http_method = "PATCH",
    http_path = "/dimensions/{name}",
    paginator = list()
  )
  input <- .iot$update_dimension_input(name = name, stringValues = stringValues)
  output <- .iot$update_dimension_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_dimension <- iot_update_dimension

#' Updates values stored in the domain configuration
#'
#' @description
#' Updates values stored in the domain configuration. Domain configurations
#' for default endpoints can't be updated.
#' 
#' The domain configuration feature is in public preview and is subject to
#' change.
#'
#' @usage
#' iot_update_domain_configuration(domainConfigurationName,
#'   authorizerConfig, domainConfigurationStatus, removeAuthorizerConfig)
#'
#' @param domainConfigurationName &#91;required&#93; The name of the domain configuration to be updated.
#' @param authorizerConfig An object that specifies the authorization service for a domain.
#' @param domainConfigurationStatus The status to which the domain configuration should be updated.
#' @param removeAuthorizerConfig Removes the authorization configuration from a domain.
#'
#' @section Request syntax:
#' ```
#' svc$update_domain_configuration(
#'   domainConfigurationName = "string",
#'   authorizerConfig = list(
#'     defaultAuthorizerName = "string",
#'     allowAuthorizerOverride = TRUE|FALSE
#'   ),
#'   domainConfigurationStatus = "ENABLED"|"DISABLED",
#'   removeAuthorizerConfig = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_domain_configuration
iot_update_domain_configuration <- function(domainConfigurationName, authorizerConfig = NULL, domainConfigurationStatus = NULL, removeAuthorizerConfig = NULL) {
  op <- new_operation(
    name = "UpdateDomainConfiguration",
    http_method = "PUT",
    http_path = "/domainConfigurations/{domainConfigurationName}",
    paginator = list()
  )
  input <- .iot$update_domain_configuration_input(domainConfigurationName = domainConfigurationName, authorizerConfig = authorizerConfig, domainConfigurationStatus = domainConfigurationStatus, removeAuthorizerConfig = removeAuthorizerConfig)
  output <- .iot$update_domain_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_domain_configuration <- iot_update_domain_configuration

#' Updates a dynamic thing group
#'
#' @description
#' Updates a dynamic thing group.
#'
#' @usage
#' iot_update_dynamic_thing_group(thingGroupName, thingGroupProperties,
#'   expectedVersion, indexName, queryString, queryVersion)
#'
#' @param thingGroupName &#91;required&#93; The name of the dynamic thing group to update.
#' @param thingGroupProperties &#91;required&#93; The dynamic thing group properties to update.
#' @param expectedVersion The expected version of the dynamic thing group to update.
#' @param indexName The dynamic thing group index to update.
#' 
#' Currently one index is supported: 'AWS\\_Things'.
#' @param queryString The dynamic thing group search query string to update.
#' @param queryVersion The dynamic thing group query version to update.
#' 
#' Currently one query version is supported: "2017-09-30". If not
#' specified, the query version defaults to this value.
#'
#' @section Request syntax:
#' ```
#' svc$update_dynamic_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   expectedVersion = 123,
#'   indexName = "string",
#'   queryString = "string",
#'   queryVersion = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_dynamic_thing_group
iot_update_dynamic_thing_group <- function(thingGroupName, thingGroupProperties, expectedVersion = NULL, indexName = NULL, queryString = NULL, queryVersion = NULL) {
  op <- new_operation(
    name = "UpdateDynamicThingGroup",
    http_method = "PATCH",
    http_path = "/dynamic-thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$update_dynamic_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, expectedVersion = expectedVersion, indexName = indexName, queryString = queryString, queryVersion = queryVersion)
  output <- .iot$update_dynamic_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_dynamic_thing_group <- iot_update_dynamic_thing_group

#' Updates the event configurations
#'
#' @description
#' Updates the event configurations.
#'
#' @usage
#' iot_update_event_configurations(eventConfigurations)
#'
#' @param eventConfigurations The new event configuration values.
#'
#' @section Request syntax:
#' ```
#' svc$update_event_configurations(
#'   eventConfigurations = list(
#'     list(
#'       Enabled = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_event_configurations
iot_update_event_configurations <- function(eventConfigurations = NULL) {
  op <- new_operation(
    name = "UpdateEventConfigurations",
    http_method = "PATCH",
    http_path = "/event-configurations",
    paginator = list()
  )
  input <- .iot$update_event_configurations_input(eventConfigurations = eventConfigurations)
  output <- .iot$update_event_configurations_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_event_configurations <- iot_update_event_configurations

#' Updates the search configuration
#'
#' @description
#' Updates the search configuration.
#'
#' @usage
#' iot_update_indexing_configuration(thingIndexingConfiguration,
#'   thingGroupIndexingConfiguration)
#'
#' @param thingIndexingConfiguration Thing indexing configuration.
#' @param thingGroupIndexingConfiguration Thing group indexing configuration.
#'
#' @section Request syntax:
#' ```
#' svc$update_indexing_configuration(
#'   thingIndexingConfiguration = list(
#'     thingIndexingMode = "OFF"|"REGISTRY"|"REGISTRY_AND_SHADOW",
#'     thingConnectivityIndexingMode = "OFF"|"STATUS",
#'     managedFields = list(
#'       list(
#'         name = "string",
#'         type = "Number"|"String"|"Boolean"
#'       )
#'     ),
#'     customFields = list(
#'       list(
#'         name = "string",
#'         type = "Number"|"String"|"Boolean"
#'       )
#'     )
#'   ),
#'   thingGroupIndexingConfiguration = list(
#'     thingGroupIndexingMode = "OFF"|"ON",
#'     managedFields = list(
#'       list(
#'         name = "string",
#'         type = "Number"|"String"|"Boolean"
#'       )
#'     ),
#'     customFields = list(
#'       list(
#'         name = "string",
#'         type = "Number"|"String"|"Boolean"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_indexing_configuration
iot_update_indexing_configuration <- function(thingIndexingConfiguration = NULL, thingGroupIndexingConfiguration = NULL) {
  op <- new_operation(
    name = "UpdateIndexingConfiguration",
    http_method = "POST",
    http_path = "/indexing/config",
    paginator = list()
  )
  input <- .iot$update_indexing_configuration_input(thingIndexingConfiguration = thingIndexingConfiguration, thingGroupIndexingConfiguration = thingGroupIndexingConfiguration)
  output <- .iot$update_indexing_configuration_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_indexing_configuration <- iot_update_indexing_configuration

#' Updates supported fields of the specified job
#'
#' @description
#' Updates supported fields of the specified job.
#'
#' @usage
#' iot_update_job(jobId, description, presignedUrlConfig,
#'   jobExecutionsRolloutConfig, abortConfig, timeoutConfig, namespaceId)
#'
#' @param jobId &#91;required&#93; The ID of the job to be updated.
#' @param description A short text description of the job.
#' @param presignedUrlConfig Configuration information for pre-signed S3 URLs.
#' @param jobExecutionsRolloutConfig Allows you to create a staged rollout of the job.
#' @param abortConfig Allows you to create criteria to abort a job.
#' @param timeoutConfig Specifies the amount of time each device has to finish its execution of
#' the job. The timer is started when the job execution status is set to
#' `IN_PROGRESS`. If the job execution status is not set to another
#' terminal state before the time expires, it will be automatically set to
#' `TIMED_OUT`.
#' @param namespaceId The namespace used to indicate that a job is a customer-managed job.
#' 
#' When you specify a value for this parameter, AWS IoT Core sends jobs
#' notifications to MQTT topics that contain the value in the following
#' format.
#' 
#' `$aws/things/THING_NAME/jobs/JOB_ID/notify-namespace-NAMESPACE_ID/`
#' 
#' The `namespaceId` feature is in public preview.
#'
#' @section Request syntax:
#' ```
#' svc$update_job(
#'   jobId = "string",
#'   description = "string",
#'   presignedUrlConfig = list(
#'     roleArn = "string",
#'     expiresInSec = 123
#'   ),
#'   jobExecutionsRolloutConfig = list(
#'     maximumPerMinute = 123,
#'     exponentialRate = list(
#'       baseRatePerMinute = 123,
#'       incrementFactor = 123.0,
#'       rateIncreaseCriteria = list(
#'         numberOfNotifiedThings = 123,
#'         numberOfSucceededThings = 123
#'       )
#'     )
#'   ),
#'   abortConfig = list(
#'     criteriaList = list(
#'       list(
#'         failureType = "FAILED"|"REJECTED"|"TIMED_OUT"|"ALL",
#'         action = "CANCEL",
#'         thresholdPercentage = 123.0,
#'         minNumberOfExecutedThings = 123
#'       )
#'     )
#'   ),
#'   timeoutConfig = list(
#'     inProgressTimeoutInMinutes = 123
#'   ),
#'   namespaceId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_job
iot_update_job <- function(jobId, description = NULL, presignedUrlConfig = NULL, jobExecutionsRolloutConfig = NULL, abortConfig = NULL, timeoutConfig = NULL, namespaceId = NULL) {
  op <- new_operation(
    name = "UpdateJob",
    http_method = "PATCH",
    http_path = "/jobs/{jobId}",
    paginator = list()
  )
  input <- .iot$update_job_input(jobId = jobId, description = description, presignedUrlConfig = presignedUrlConfig, jobExecutionsRolloutConfig = jobExecutionsRolloutConfig, abortConfig = abortConfig, timeoutConfig = timeoutConfig, namespaceId = namespaceId)
  output <- .iot$update_job_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_job <- iot_update_job

#' Updates the definition for the specified mitigation action
#'
#' @description
#' Updates the definition for the specified mitigation action.
#'
#' @usage
#' iot_update_mitigation_action(actionName, roleArn, actionParams)
#'
#' @param actionName &#91;required&#93; The friendly name for the mitigation action. You cannot change the name
#' by using [`update_mitigation_action`][iot_update_mitigation_action].
#' Instead, you must delete and recreate the mitigation action with the new
#' name.
#' @param roleArn The ARN of the IAM role that is used to apply the mitigation action.
#' @param actionParams Defines the type of action and the parameters for that action.
#'
#' @section Request syntax:
#' ```
#' svc$update_mitigation_action(
#'   actionName = "string",
#'   roleArn = "string",
#'   actionParams = list(
#'     updateDeviceCertificateParams = list(
#'       action = "DEACTIVATE"
#'     ),
#'     updateCACertificateParams = list(
#'       action = "DEACTIVATE"
#'     ),
#'     addThingsToThingGroupParams = list(
#'       thingGroupNames = list(
#'         "string"
#'       ),
#'       overrideDynamicGroups = TRUE|FALSE
#'     ),
#'     replaceDefaultPolicyVersionParams = list(
#'       templateName = "BLANK_POLICY"
#'     ),
#'     enableIoTLoggingParams = list(
#'       roleArnForLogging = "string",
#'       logLevel = "DEBUG"|"INFO"|"ERROR"|"WARN"|"DISABLED"
#'     ),
#'     publishFindingToSnsParams = list(
#'       topicArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_mitigation_action
iot_update_mitigation_action <- function(actionName, roleArn = NULL, actionParams = NULL) {
  op <- new_operation(
    name = "UpdateMitigationAction",
    http_method = "PATCH",
    http_path = "/mitigationactions/actions/{actionName}",
    paginator = list()
  )
  input <- .iot$update_mitigation_action_input(actionName = actionName, roleArn = roleArn, actionParams = actionParams)
  output <- .iot$update_mitigation_action_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_mitigation_action <- iot_update_mitigation_action

#' Updates a fleet provisioning template
#'
#' @description
#' Updates a fleet provisioning template.
#'
#' @usage
#' iot_update_provisioning_template(templateName, description, enabled,
#'   defaultVersionId, provisioningRoleArn, preProvisioningHook,
#'   removePreProvisioningHook)
#'
#' @param templateName &#91;required&#93; The name of the fleet provisioning template.
#' @param description The description of the fleet provisioning template.
#' @param enabled True to enable the fleet provisioning template, otherwise false.
#' @param defaultVersionId The ID of the default provisioning template version.
#' @param provisioningRoleArn The ARN of the role associated with the provisioning template. This IoT
#' role grants permission to provision a device.
#' @param preProvisioningHook Updates the pre-provisioning hook template.
#' @param removePreProvisioningHook Removes pre-provisioning hook template.
#'
#' @section Request syntax:
#' ```
#' svc$update_provisioning_template(
#'   templateName = "string",
#'   description = "string",
#'   enabled = TRUE|FALSE,
#'   defaultVersionId = 123,
#'   provisioningRoleArn = "string",
#'   preProvisioningHook = list(
#'     payloadVersion = "string",
#'     targetArn = "string"
#'   ),
#'   removePreProvisioningHook = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_provisioning_template
iot_update_provisioning_template <- function(templateName, description = NULL, enabled = NULL, defaultVersionId = NULL, provisioningRoleArn = NULL, preProvisioningHook = NULL, removePreProvisioningHook = NULL) {
  op <- new_operation(
    name = "UpdateProvisioningTemplate",
    http_method = "PATCH",
    http_path = "/provisioning-templates/{templateName}",
    paginator = list()
  )
  input <- .iot$update_provisioning_template_input(templateName = templateName, description = description, enabled = enabled, defaultVersionId = defaultVersionId, provisioningRoleArn = provisioningRoleArn, preProvisioningHook = preProvisioningHook, removePreProvisioningHook = removePreProvisioningHook)
  output <- .iot$update_provisioning_template_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_provisioning_template <- iot_update_provisioning_template

#' Updates a role alias
#'
#' @description
#' Updates a role alias.
#'
#' @usage
#' iot_update_role_alias(roleAlias, roleArn, credentialDurationSeconds)
#'
#' @param roleAlias &#91;required&#93; The role alias to update.
#' @param roleArn The role ARN.
#' @param credentialDurationSeconds The number of seconds the credential will be valid.
#'
#' @section Request syntax:
#' ```
#' svc$update_role_alias(
#'   roleAlias = "string",
#'   roleArn = "string",
#'   credentialDurationSeconds = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_role_alias
iot_update_role_alias <- function(roleAlias, roleArn = NULL, credentialDurationSeconds = NULL) {
  op <- new_operation(
    name = "UpdateRoleAlias",
    http_method = "PUT",
    http_path = "/role-aliases/{roleAlias}",
    paginator = list()
  )
  input <- .iot$update_role_alias_input(roleAlias = roleAlias, roleArn = roleArn, credentialDurationSeconds = credentialDurationSeconds)
  output <- .iot$update_role_alias_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_role_alias <- iot_update_role_alias

#' Updates a scheduled audit, including which checks are performed and how
#' often the audit takes place
#'
#' @description
#' Updates a scheduled audit, including which checks are performed and how
#' often the audit takes place.
#'
#' @usage
#' iot_update_scheduled_audit(frequency, dayOfMonth, dayOfWeek,
#'   targetCheckNames, scheduledAuditName)
#'
#' @param frequency How often the scheduled audit takes place, either `DAILY`, `WEEKLY`,
#' `BIWEEKLY`, or `MONTHLY`. The start time of each audit is determined by
#' the system.
#' @param dayOfMonth The day of the month on which the scheduled audit takes place. This can
#' be `1` through `31` or `LAST`. This field is required if the `frequency`
#' parameter is set to `MONTHLY`. If days 29-31 are specified, and the
#' month does not have that many days, the audit takes place on the "LAST"
#' day of the month.
#' @param dayOfWeek The day of the week on which the scheduled audit takes place. This can
#' be one of `SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, or `SAT`. This field
#' is required if the "frequency" parameter is set to `WEEKLY` or
#' `BIWEEKLY`.
#' @param targetCheckNames Which checks are performed during the scheduled audit. Checks must be
#' enabled for your account. (Use
#' [`describe_account_audit_configuration`][iot_describe_account_audit_configuration]
#' to see the list of all checks, including those that are enabled or use
#' [`update_account_audit_configuration`][iot_update_account_audit_configuration]
#' to select which checks are enabled.)
#' @param scheduledAuditName &#91;required&#93; The name of the scheduled audit. (Max. 128 chars)
#'
#' @section Request syntax:
#' ```
#' svc$update_scheduled_audit(
#'   frequency = "DAILY"|"WEEKLY"|"BIWEEKLY"|"MONTHLY",
#'   dayOfMonth = "string",
#'   dayOfWeek = "SUN"|"MON"|"TUE"|"WED"|"THU"|"FRI"|"SAT",
#'   targetCheckNames = list(
#'     "string"
#'   ),
#'   scheduledAuditName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_scheduled_audit
iot_update_scheduled_audit <- function(frequency = NULL, dayOfMonth = NULL, dayOfWeek = NULL, targetCheckNames = NULL, scheduledAuditName) {
  op <- new_operation(
    name = "UpdateScheduledAudit",
    http_method = "PATCH",
    http_path = "/audit/scheduledaudits/{scheduledAuditName}",
    paginator = list()
  )
  input <- .iot$update_scheduled_audit_input(frequency = frequency, dayOfMonth = dayOfMonth, dayOfWeek = dayOfWeek, targetCheckNames = targetCheckNames, scheduledAuditName = scheduledAuditName)
  output <- .iot$update_scheduled_audit_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_scheduled_audit <- iot_update_scheduled_audit

#' Updates a Device Defender security profile
#'
#' @description
#' Updates a Device Defender security profile.
#'
#' @usage
#' iot_update_security_profile(securityProfileName,
#'   securityProfileDescription, behaviors, alertTargets,
#'   additionalMetricsToRetain, additionalMetricsToRetainV2, deleteBehaviors,
#'   deleteAlertTargets, deleteAdditionalMetricsToRetain, expectedVersion)
#'
#' @param securityProfileName &#91;required&#93; The name of the security profile you want to update.
#' @param securityProfileDescription A description of the security profile.
#' @param behaviors Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#' @param alertTargets Where the alerts are sent. (Alerts are always sent to the console.)
#' @param additionalMetricsToRetain *Please use UpdateSecurityProfileRequest$additionalMetricsToRetainV2
#' instead.*
#' 
#' A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile's `behaviors`, but it is
#' also retained for any metric specified here. Can be used with custom
#' metrics; cannot be used with dimensions.
#' @param additionalMetricsToRetainV2 A list of metrics whose data is retained (stored). By default, data is
#' retained for any metric used in the profile's behaviors, but it is also
#' retained for any metric specified here. Can be used with custom metrics;
#' cannot be used with dimensions.
#' @param deleteBehaviors If true, delete all `behaviors` defined for this security profile. If
#' any `behaviors` are defined in the current invocation, an exception
#' occurs.
#' @param deleteAlertTargets If true, delete all `alertTargets` defined for this security profile. If
#' any `alertTargets` are defined in the current invocation, an exception
#' occurs.
#' @param deleteAdditionalMetricsToRetain If true, delete all `additionalMetricsToRetain` defined for this
#' security profile. If any `additionalMetricsToRetain` are defined in the
#' current invocation, an exception occurs.
#' @param expectedVersion The expected version of the security profile. A new version is generated
#' whenever the security profile is updated. If you specify a value that is
#' different from the actual version, a `VersionConflictException` is
#' thrown.
#'
#' @section Request syntax:
#' ```
#' svc$update_security_profile(
#'   securityProfileName = "string",
#'   securityProfileDescription = "string",
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       metricDimension = list(
#'         dimensionName = "string",
#'         operator = "IN"|"NOT_IN"
#'       ),
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set"|"in-set"|"not-in-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           ),
#'           number = 123.0,
#'           numbers = list(
#'             123.0
#'           ),
#'           strings = list(
#'             "string"
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         ),
#'         mlDetectionConfig = list(
#'           confidenceLevel = "LOW"|"MEDIUM"|"HIGH"
#'         )
#'       ),
#'       suppressAlerts = TRUE|FALSE
#'     )
#'   ),
#'   alertTargets = list(
#'     list(
#'       alertTargetArn = "string",
#'       roleArn = "string"
#'     )
#'   ),
#'   additionalMetricsToRetain = list(
#'     "string"
#'   ),
#'   additionalMetricsToRetainV2 = list(
#'     list(
#'       metric = "string",
#'       metricDimension = list(
#'         dimensionName = "string",
#'         operator = "IN"|"NOT_IN"
#'       )
#'     )
#'   ),
#'   deleteBehaviors = TRUE|FALSE,
#'   deleteAlertTargets = TRUE|FALSE,
#'   deleteAdditionalMetricsToRetain = TRUE|FALSE,
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_security_profile
iot_update_security_profile <- function(securityProfileName, securityProfileDescription = NULL, behaviors = NULL, alertTargets = NULL, additionalMetricsToRetain = NULL, additionalMetricsToRetainV2 = NULL, deleteBehaviors = NULL, deleteAlertTargets = NULL, deleteAdditionalMetricsToRetain = NULL, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateSecurityProfile",
    http_method = "PATCH",
    http_path = "/security-profiles/{securityProfileName}",
    paginator = list()
  )
  input <- .iot$update_security_profile_input(securityProfileName = securityProfileName, securityProfileDescription = securityProfileDescription, behaviors = behaviors, alertTargets = alertTargets, additionalMetricsToRetain = additionalMetricsToRetain, additionalMetricsToRetainV2 = additionalMetricsToRetainV2, deleteBehaviors = deleteBehaviors, deleteAlertTargets = deleteAlertTargets, deleteAdditionalMetricsToRetain = deleteAdditionalMetricsToRetain, expectedVersion = expectedVersion)
  output <- .iot$update_security_profile_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_security_profile <- iot_update_security_profile

#' Updates an existing stream
#'
#' @description
#' Updates an existing stream. The stream version will be incremented by
#' one.
#'
#' @usage
#' iot_update_stream(streamId, description, files, roleArn)
#'
#' @param streamId &#91;required&#93; The stream ID.
#' @param description The description of the stream.
#' @param files The files associated with the stream.
#' @param roleArn An IAM role that allows the IoT service principal assumes to access your
#' S3 files.
#'
#' @section Request syntax:
#' ```
#' svc$update_stream(
#'   streamId = "string",
#'   description = "string",
#'   files = list(
#'     list(
#'       fileId = 123,
#'       s3Location = list(
#'         bucket = "string",
#'         key = "string",
#'         version = "string"
#'       )
#'     )
#'   ),
#'   roleArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_stream
iot_update_stream <- function(streamId, description = NULL, files = NULL, roleArn = NULL) {
  op <- new_operation(
    name = "UpdateStream",
    http_method = "PUT",
    http_path = "/streams/{streamId}",
    paginator = list()
  )
  input <- .iot$update_stream_input(streamId = streamId, description = description, files = files, roleArn = roleArn)
  output <- .iot$update_stream_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_stream <- iot_update_stream

#' Updates the data for a thing
#'
#' @description
#' Updates the data for a thing.
#'
#' @usage
#' iot_update_thing(thingName, thingTypeName, attributePayload,
#'   expectedVersion, removeThingType)
#'
#' @param thingName &#91;required&#93; The name of the thing to update.
#' 
#' You can't change a thing's name. To change a thing's name, you must
#' create a new thing, give it the new name, and then delete the old thing.
#' @param thingTypeName The name of the thing type.
#' @param attributePayload A list of thing attributes, a JSON string containing name-value pairs.
#' For example:
#' 
#' `\{\"attributes\":\{\"name1\":\"value2\"\}\}`
#' 
#' This data is used to add new attributes or update existing attributes.
#' @param expectedVersion The expected version of the thing record in the registry. If the version
#' of the record in the registry does not match the expected version
#' specified in the request, the [`update_thing`][iot_update_thing] request
#' is rejected with a `VersionConflictException`.
#' @param removeThingType Remove a thing type association. If **true**, the association is
#' removed.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing(
#'   thingName = "string",
#'   thingTypeName = "string",
#'   attributePayload = list(
#'     attributes = list(
#'       "string"
#'     ),
#'     merge = TRUE|FALSE
#'   ),
#'   expectedVersion = 123,
#'   removeThingType = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing
iot_update_thing <- function(thingName, thingTypeName = NULL, attributePayload = NULL, expectedVersion = NULL, removeThingType = NULL) {
  op <- new_operation(
    name = "UpdateThing",
    http_method = "PATCH",
    http_path = "/things/{thingName}",
    paginator = list()
  )
  input <- .iot$update_thing_input(thingName = thingName, thingTypeName = thingTypeName, attributePayload = attributePayload, expectedVersion = expectedVersion, removeThingType = removeThingType)
  output <- .iot$update_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing <- iot_update_thing

#' Update a thing group
#'
#' @description
#' Update a thing group.
#'
#' @usage
#' iot_update_thing_group(thingGroupName, thingGroupProperties,
#'   expectedVersion)
#'
#' @param thingGroupName &#91;required&#93; The thing group to update.
#' @param thingGroupProperties &#91;required&#93; The thing group properties.
#' @param expectedVersion The expected version of the thing group. If this does not match the
#' version of the thing group being updated, the update will fail.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing_group(
#'   thingGroupName = "string",
#'   thingGroupProperties = list(
#'     thingGroupDescription = "string",
#'     attributePayload = list(
#'       attributes = list(
#'         "string"
#'       ),
#'       merge = TRUE|FALSE
#'     )
#'   ),
#'   expectedVersion = 123
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing_group
iot_update_thing_group <- function(thingGroupName, thingGroupProperties, expectedVersion = NULL) {
  op <- new_operation(
    name = "UpdateThingGroup",
    http_method = "PATCH",
    http_path = "/thing-groups/{thingGroupName}",
    paginator = list()
  )
  input <- .iot$update_thing_group_input(thingGroupName = thingGroupName, thingGroupProperties = thingGroupProperties, expectedVersion = expectedVersion)
  output <- .iot$update_thing_group_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing_group <- iot_update_thing_group

#' Updates the groups to which the thing belongs
#'
#' @description
#' Updates the groups to which the thing belongs.
#'
#' @usage
#' iot_update_thing_groups_for_thing(thingName, thingGroupsToAdd,
#'   thingGroupsToRemove, overrideDynamicGroups)
#'
#' @param thingName The thing whose group memberships will be updated.
#' @param thingGroupsToAdd The groups to which the thing will be added.
#' @param thingGroupsToRemove The groups from which the thing will be removed.
#' @param overrideDynamicGroups Override dynamic thing groups with static thing groups when 10-group
#' limit is reached. If a thing belongs to 10 thing groups, and one or more
#' of those groups are dynamic thing groups, adding a thing to a static
#' group removes the thing from the last dynamic group.
#'
#' @section Request syntax:
#' ```
#' svc$update_thing_groups_for_thing(
#'   thingName = "string",
#'   thingGroupsToAdd = list(
#'     "string"
#'   ),
#'   thingGroupsToRemove = list(
#'     "string"
#'   ),
#'   overrideDynamicGroups = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_thing_groups_for_thing
iot_update_thing_groups_for_thing <- function(thingName = NULL, thingGroupsToAdd = NULL, thingGroupsToRemove = NULL, overrideDynamicGroups = NULL) {
  op <- new_operation(
    name = "UpdateThingGroupsForThing",
    http_method = "PUT",
    http_path = "/thing-groups/updateThingGroupsForThing",
    paginator = list()
  )
  input <- .iot$update_thing_groups_for_thing_input(thingName = thingName, thingGroupsToAdd = thingGroupsToAdd, thingGroupsToRemove = thingGroupsToRemove, overrideDynamicGroups = overrideDynamicGroups)
  output <- .iot$update_thing_groups_for_thing_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_thing_groups_for_thing <- iot_update_thing_groups_for_thing

#' Updates a topic rule destination
#'
#' @description
#' Updates a topic rule destination. You use this to change the status,
#' endpoint URL, or confirmation URL of the destination.
#'
#' @usage
#' iot_update_topic_rule_destination(arn, status)
#'
#' @param arn &#91;required&#93; The ARN of the topic rule destination.
#' @param status &#91;required&#93; The status of the topic rule destination. Valid values are:
#' 
#' ### IN\\_PROGRESS
#' 
#' A topic rule destination was created but has not been confirmed. You can
#' set `status` to `IN_PROGRESS` by calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination].
#' Calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination]
#' causes a new confirmation challenge to be sent to your confirmation
#' endpoint.
#' 
#' ### ENABLED
#' 
#' Confirmation was completed, and traffic to this destination is allowed.
#' You can set `status` to `DISABLED` by calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination].
#' 
#' ### DISABLED
#' 
#' Confirmation was completed, and traffic to this destination is not
#' allowed. You can set `status` to `ENABLED` by calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination].
#' 
#' ### ERROR
#' 
#' Confirmation could not be completed, for example if the confirmation
#' timed out. You can call
#' [`get_topic_rule_destination`][iot_get_topic_rule_destination] for
#' details about the error. You can set `status` to `IN_PROGRESS` by
#' calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination].
#' Calling
#' [`update_topic_rule_destination`][iot_update_topic_rule_destination]
#' causes a new confirmation challenge to be sent to your confirmation
#' endpoint.
#'
#' @section Request syntax:
#' ```
#' svc$update_topic_rule_destination(
#'   arn = "string",
#'   status = "ENABLED"|"IN_PROGRESS"|"DISABLED"|"ERROR"|"DELETING"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_update_topic_rule_destination
iot_update_topic_rule_destination <- function(arn, status) {
  op <- new_operation(
    name = "UpdateTopicRuleDestination",
    http_method = "PATCH",
    http_path = "/destinations",
    paginator = list()
  )
  input <- .iot$update_topic_rule_destination_input(arn = arn, status = status)
  output <- .iot$update_topic_rule_destination_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$update_topic_rule_destination <- iot_update_topic_rule_destination

#' Validates a Device Defender security profile behaviors specification
#'
#' @description
#' Validates a Device Defender security profile behaviors specification.
#'
#' @usage
#' iot_validate_security_profile_behaviors(behaviors)
#'
#' @param behaviors &#91;required&#93; Specifies the behaviors that, when violated by a device (thing), cause
#' an alert.
#'
#' @section Request syntax:
#' ```
#' svc$validate_security_profile_behaviors(
#'   behaviors = list(
#'     list(
#'       name = "string",
#'       metric = "string",
#'       metricDimension = list(
#'         dimensionName = "string",
#'         operator = "IN"|"NOT_IN"
#'       ),
#'       criteria = list(
#'         comparisonOperator = "less-than"|"less-than-equals"|"greater-than"|"greater-than-equals"|"in-cidr-set"|"not-in-cidr-set"|"in-port-set"|"not-in-port-set"|"in-set"|"not-in-set",
#'         value = list(
#'           count = 123,
#'           cidrs = list(
#'             "string"
#'           ),
#'           ports = list(
#'             123
#'           ),
#'           number = 123.0,
#'           numbers = list(
#'             123.0
#'           ),
#'           strings = list(
#'             "string"
#'           )
#'         ),
#'         durationSeconds = 123,
#'         consecutiveDatapointsToAlarm = 123,
#'         consecutiveDatapointsToClear = 123,
#'         statisticalThreshold = list(
#'           statistic = "string"
#'         ),
#'         mlDetectionConfig = list(
#'           confidenceLevel = "LOW"|"MEDIUM"|"HIGH"
#'         )
#'       ),
#'       suppressAlerts = TRUE|FALSE
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname iot_validate_security_profile_behaviors
iot_validate_security_profile_behaviors <- function(behaviors) {
  op <- new_operation(
    name = "ValidateSecurityProfileBehaviors",
    http_method = "POST",
    http_path = "/security-profile-behaviors/validate",
    paginator = list()
  )
  input <- .iot$validate_security_profile_behaviors_input(behaviors = behaviors)
  output <- .iot$validate_security_profile_behaviors_output()
  config <- get_config()
  svc <- .iot$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.iot$operations$validate_security_profile_behaviors <- iot_validate_security_profile_behaviors

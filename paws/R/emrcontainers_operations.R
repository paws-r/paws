# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include emrcontainers_service.R
NULL

#' Cancels a job run
#'
#' @description
#' Cancels a job run. A job run is a unit of work, such as a Spark jar,
#' PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_cancel_job_run(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the job run to cancel.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which the job run will be canceled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_run(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_cancel_job_run
emrcontainers_cancel_job_run <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "CancelJobRun",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns/{jobRunId}",
    paginator = list()
  )
  input <- .emrcontainers$cancel_job_run_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$cancel_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$cancel_job_run <- emrcontainers_cancel_job_run

#' Creates a managed endpoint
#'
#' @description
#' Creates a managed endpoint. A managed endpoint is a gateway that
#' connects EMR Studio to Amazon EMR on EKS so that EMR Studio can
#' communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_create_managed_endpoint(name, virtualClusterId, type,
#'   releaseLabel, executionRoleArn, certificateArn, configurationOverrides,
#'   clientToken, tags)
#'
#' @param name &#91;required&#93; The name of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which a managed endpoint is created.
#' @param type &#91;required&#93; The type of the managed endpoint.
#' @param releaseLabel &#91;required&#93; The Amazon EMR release version.
#' @param executionRoleArn &#91;required&#93; The ARN of the execution role.
#' @param certificateArn &#91;required&#93; The certificate ARN of the managed endpoint.
#' @param configurationOverrides The configuration settings that will be used to override existing
#' configurations.
#' @param clientToken &#91;required&#93; The client idempotency token for this create call.
#' @param tags The tags of the managed endpoint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_managed_endpoint(
#'   name = "string",
#'   virtualClusterId = "string",
#'   type = "string",
#'   releaseLabel = "string",
#'   executionRoleArn = "string",
#'   certificateArn = "string",
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       persistentAppUI = "ENABLED"|"DISABLED",
#'       cloudWatchMonitoringConfiguration = list(
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string"
#'       ),
#'       s3MonitoringConfiguration = list(
#'         logUri = "string"
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_managed_endpoint
emrcontainers_create_managed_endpoint <- function(name, virtualClusterId, type, releaseLabel, executionRoleArn, certificateArn, configurationOverrides = NULL, clientToken, tags = NULL) {
  op <- new_operation(
    name = "CreateManagedEndpoint",
    http_method = "POST",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints",
    paginator = list()
  )
  input <- .emrcontainers$create_managed_endpoint_input(name = name, virtualClusterId = virtualClusterId, type = type, releaseLabel = releaseLabel, executionRoleArn = executionRoleArn, certificateArn = certificateArn, configurationOverrides = configurationOverrides, clientToken = clientToken, tags = tags)
  output <- .emrcontainers$create_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_managed_endpoint <- emrcontainers_create_managed_endpoint

#' Creates a virtual cluster
#'
#' @description
#' Creates a virtual cluster. Virtual cluster is a managed entity on Amazon
#' EMR on EKS. You can create, describe, list and delete virtual clusters.
#' They do not consume any additional resource in your system. A single
#' virtual cluster maps to a single Kubernetes namespace. Given this
#' relationship, you can model virtual clusters the same way you model
#' Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_create_virtual_cluster(name, containerProvider,
#'   clientToken, tags)
#'
#' @param name &#91;required&#93; The specified name of the virtual cluster.
#' @param containerProvider &#91;required&#93; The container provider of the virtual cluster.
#' @param clientToken &#91;required&#93; The client token of the virtual cluster.
#' @param tags The tags assigned to the virtual cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_virtual_cluster(
#'   name = "string",
#'   containerProvider = list(
#'     type = "EKS",
#'     id = "string",
#'     info = list(
#'       eksInfo = list(
#'         namespace = "string"
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_virtual_cluster
emrcontainers_create_virtual_cluster <- function(name, containerProvider, clientToken, tags = NULL) {
  op <- new_operation(
    name = "CreateVirtualCluster",
    http_method = "POST",
    http_path = "/virtualclusters",
    paginator = list()
  )
  input <- .emrcontainers$create_virtual_cluster_input(name = name, containerProvider = containerProvider, clientToken = clientToken, tags = tags)
  output <- .emrcontainers$create_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_virtual_cluster <- emrcontainers_create_virtual_cluster

#' Deletes a managed endpoint
#'
#' @description
#' Deletes a managed endpoint. A managed endpoint is a gateway that
#' connects EMR Studio to Amazon EMR on EKS so that EMR Studio can
#' communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_delete_managed_endpoint(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the endpoint's virtual cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_managed_endpoint(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_delete_managed_endpoint
emrcontainers_delete_managed_endpoint <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DeleteManagedEndpoint",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints/{endpointId}",
    paginator = list()
  )
  input <- .emrcontainers$delete_managed_endpoint_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$delete_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$delete_managed_endpoint <- emrcontainers_delete_managed_endpoint

#' Deletes a virtual cluster
#'
#' @description
#' Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon
#' EMR on EKS. You can create, describe, list and delete virtual clusters.
#' They do not consume any additional resource in your system. A single
#' virtual cluster maps to a single Kubernetes namespace. Given this
#' relationship, you can model virtual clusters the same way you model
#' Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_delete_virtual_cluster(id)
#'
#' @param id &#91;required&#93; The ID of the virtual cluster that will be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_virtual_cluster(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_delete_virtual_cluster
emrcontainers_delete_virtual_cluster <- function(id) {
  op <- new_operation(
    name = "DeleteVirtualCluster",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}",
    paginator = list()
  )
  input <- .emrcontainers$delete_virtual_cluster_input(id = id)
  output <- .emrcontainers$delete_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$delete_virtual_cluster <- emrcontainers_delete_virtual_cluster

#' Displays detailed information about a job run
#'
#' @description
#' Displays detailed information about a job run. A job run is a unit of
#' work, such as a Spark jar, PySpark script, or SparkSQL query, that you
#' submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_describe_job_run(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the job run request.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which the job run is submitted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRun = list(
#'     id = "string",
#'     name = "string",
#'     virtualClusterId = "string",
#'     arn = "string",
#'     state = "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED",
#'     clientToken = "string",
#'     executionRoleArn = "string",
#'     releaseLabel = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         persistentAppUI = "ENABLED"|"DISABLED",
#'         cloudWatchMonitoringConfiguration = list(
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string"
#'         ),
#'         s3MonitoringConfiguration = list(
#'           logUri = "string"
#'         )
#'       )
#'     ),
#'     jobDriver = list(
#'       sparkSubmitJobDriver = list(
#'         entryPoint = "string",
#'         entryPointArguments = list(
#'           "string"
#'         ),
#'         sparkSubmitParameters = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBy = "string",
#'     finishedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     stateDetails = "string",
#'     failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_run(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_job_run
emrcontainers_describe_job_run <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DescribeJobRun",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns/{jobRunId}",
    paginator = list()
  )
  input <- .emrcontainers$describe_job_run_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$describe_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_job_run <- emrcontainers_describe_job_run

#' Displays detailed information about a managed endpoint
#'
#' @description
#' Displays detailed information about a managed endpoint. A managed
#' endpoint is a gateway that connects EMR Studio to Amazon EMR on EKS so
#' that EMR Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_describe_managed_endpoint(id, virtualClusterId)
#'
#' @param id &#91;required&#93; This output displays ID of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the endpoint's virtual cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   endpoint = list(
#'     id = "string",
#'     name = "string",
#'     arn = "string",
#'     virtualClusterId = "string",
#'     type = "string",
#'     state = "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS",
#'     releaseLabel = "string",
#'     executionRoleArn = "string",
#'     certificateArn = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         persistentAppUI = "ENABLED"|"DISABLED",
#'         cloudWatchMonitoringConfiguration = list(
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string"
#'         ),
#'         s3MonitoringConfiguration = list(
#'           logUri = "string"
#'         )
#'       )
#'     ),
#'     serverUrl = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     securityGroup = "string",
#'     subnetIds = list(
#'       "string"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_managed_endpoint(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_managed_endpoint
emrcontainers_describe_managed_endpoint <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DescribeManagedEndpoint",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints/{endpointId}",
    paginator = list()
  )
  input <- .emrcontainers$describe_managed_endpoint_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$describe_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_managed_endpoint <- emrcontainers_describe_managed_endpoint

#' Displays detailed information about a specified virtual cluster
#'
#' @description
#' Displays detailed information about a specified virtual cluster. Virtual
#' cluster is a managed entity on Amazon EMR on EKS. You can create,
#' describe, list and delete virtual clusters. They do not consume any
#' additional resource in your system. A single virtual cluster maps to a
#' single Kubernetes namespace. Given this relationship, you can model
#' virtual clusters the same way you model Kubernetes namespaces to meet
#' your requirements.
#'
#' @usage
#' emrcontainers_describe_virtual_cluster(id)
#'
#' @param id &#91;required&#93; The ID of the virtual cluster that will be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   virtualCluster = list(
#'     id = "string",
#'     name = "string",
#'     arn = "string",
#'     state = "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED",
#'     containerProvider = list(
#'       type = "EKS",
#'       id = "string",
#'       info = list(
#'         eksInfo = list(
#'           namespace = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_virtual_cluster(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_virtual_cluster
emrcontainers_describe_virtual_cluster <- function(id) {
  op <- new_operation(
    name = "DescribeVirtualCluster",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}",
    paginator = list()
  )
  input <- .emrcontainers$describe_virtual_cluster_input(id = id)
  output <- .emrcontainers$describe_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_virtual_cluster <- emrcontainers_describe_virtual_cluster

#' Lists job runs based on a set of parameters
#'
#' @description
#' Lists job runs based on a set of parameters. A job run is a unit of
#' work, such as a Spark jar, PySpark script, or SparkSQL query, that you
#' submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_list_job_runs(virtualClusterId, createdBefore,
#'   createdAfter, name, states, maxResults, nextToken)
#'
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which to list the job run.
#' @param createdBefore The date and time before which the job runs were submitted.
#' @param createdAfter The date and time after which the job runs were submitted.
#' @param name The name of the job run.
#' @param states The states of the job run.
#' @param maxResults The maximum number of job runs that can be listed.
#' @param nextToken The token for the next set of job runs to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRuns = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       virtualClusterId = "string",
#'       arn = "string",
#'       state = "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED",
#'       clientToken = "string",
#'       executionRoleArn = "string",
#'       releaseLabel = "string",
#'       configurationOverrides = list(
#'         applicationConfiguration = list(
#'           list(
#'             classification = "string",
#'             properties = list(
#'               "string"
#'             ),
#'             configurations = list()
#'           )
#'         ),
#'         monitoringConfiguration = list(
#'           persistentAppUI = "ENABLED"|"DISABLED",
#'           cloudWatchMonitoringConfiguration = list(
#'             logGroupName = "string",
#'             logStreamNamePrefix = "string"
#'           ),
#'           s3MonitoringConfiguration = list(
#'             logUri = "string"
#'           )
#'         )
#'       ),
#'       jobDriver = list(
#'         sparkSubmitJobDriver = list(
#'           entryPoint = "string",
#'           entryPointArguments = list(
#'             "string"
#'           ),
#'           sparkSubmitParameters = "string"
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       finishedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stateDetails = "string",
#'       failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   virtualClusterId = "string",
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   states = list(
#'     "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_job_runs
emrcontainers_list_job_runs <- function(virtualClusterId, createdBefore = NULL, createdAfter = NULL, name = NULL, states = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns",
    paginator = list()
  )
  input <- .emrcontainers$list_job_runs_input(virtualClusterId = virtualClusterId, createdBefore = createdBefore, createdAfter = createdAfter, name = name, states = states, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_job_runs_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_job_runs <- emrcontainers_list_job_runs

#' Lists managed endpoints based on a set of parameters
#'
#' @description
#' Lists managed endpoints based on a set of parameters. A managed endpoint
#' is a gateway that connects EMR Studio to Amazon EMR on EKS so that EMR
#' Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_list_managed_endpoints(virtualClusterId, createdBefore,
#'   createdAfter, types, states, maxResults, nextToken)
#'
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster.
#' @param createdBefore The date and time before which the endpoints are created.
#' @param createdAfter The date and time after which the endpoints are created.
#' @param types The types of the managed endpoints.
#' @param states The states of the managed endpoints.
#' @param maxResults The maximum number of managed endpoints that can be listed.
#' @param nextToken The token for the next set of managed endpoints to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   endpoints = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       virtualClusterId = "string",
#'       type = "string",
#'       state = "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS",
#'       releaseLabel = "string",
#'       executionRoleArn = "string",
#'       certificateArn = "string",
#'       configurationOverrides = list(
#'         applicationConfiguration = list(
#'           list(
#'             classification = "string",
#'             properties = list(
#'               "string"
#'             ),
#'             configurations = list()
#'           )
#'         ),
#'         monitoringConfiguration = list(
#'           persistentAppUI = "ENABLED"|"DISABLED",
#'           cloudWatchMonitoringConfiguration = list(
#'             logGroupName = "string",
#'             logStreamNamePrefix = "string"
#'           ),
#'           s3MonitoringConfiguration = list(
#'             logUri = "string"
#'           )
#'         )
#'       ),
#'       serverUrl = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       securityGroup = "string",
#'       subnetIds = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_managed_endpoints(
#'   virtualClusterId = "string",
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   types = list(
#'     "string"
#'   ),
#'   states = list(
#'     "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_managed_endpoints
emrcontainers_list_managed_endpoints <- function(virtualClusterId, createdBefore = NULL, createdAfter = NULL, types = NULL, states = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListManagedEndpoints",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints",
    paginator = list()
  )
  input <- .emrcontainers$list_managed_endpoints_input(virtualClusterId = virtualClusterId, createdBefore = createdBefore, createdAfter = createdAfter, types = types, states = states, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_managed_endpoints_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_managed_endpoints <- emrcontainers_list_managed_endpoints

#' Lists the tags assigned to the resources
#'
#' @description
#' Lists the tags assigned to the resources.
#'
#' @usage
#' emrcontainers_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_tags_for_resource
emrcontainers_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrcontainers$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .emrcontainers$list_tags_for_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_tags_for_resource <- emrcontainers_list_tags_for_resource

#' Lists information about the specified virtual cluster
#'
#' @description
#' Lists information about the specified virtual cluster. Virtual cluster
#' is a managed entity on Amazon EMR on EKS. You can create, describe, list
#' and delete virtual clusters. They do not consume any additional resource
#' in your system. A single virtual cluster maps to a single Kubernetes
#' namespace. Given this relationship, you can model virtual clusters the
#' same way you model Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_list_virtual_clusters(containerProviderId,
#'   containerProviderType, createdAfter, createdBefore, states, maxResults,
#'   nextToken)
#'
#' @param containerProviderId The container provider ID of the virtual cluster.
#' @param containerProviderType The container provider type of the virtual cluster. EKS is the only
#' supported type as of now.
#' @param createdAfter The date and time after which the virtual clusters are created.
#' @param createdBefore The date and time before which the virtual clusters are created.
#' @param states The states of the requested virtual clusters.
#' @param maxResults The maximum number of virtual clusters that can be listed.
#' @param nextToken The token for the next set of virtual clusters to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   virtualClusters = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       state = "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED",
#'       containerProvider = list(
#'         type = "EKS",
#'         id = "string",
#'         info = list(
#'           eksInfo = list(
#'             namespace = "string"
#'           )
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_virtual_clusters(
#'   containerProviderId = "string",
#'   containerProviderType = "EKS",
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   states = list(
#'     "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_virtual_clusters
emrcontainers_list_virtual_clusters <- function(containerProviderId = NULL, containerProviderType = NULL, createdAfter = NULL, createdBefore = NULL, states = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListVirtualClusters",
    http_method = "GET",
    http_path = "/virtualclusters",
    paginator = list()
  )
  input <- .emrcontainers$list_virtual_clusters_input(containerProviderId = containerProviderId, containerProviderType = containerProviderType, createdAfter = createdAfter, createdBefore = createdBefore, states = states, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_virtual_clusters_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_virtual_clusters <- emrcontainers_list_virtual_clusters

#' Starts a job run
#'
#' @description
#' Starts a job run. A job run is a unit of work, such as a Spark jar,
#' PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_start_job_run(name, virtualClusterId, clientToken,
#'   executionRoleArn, releaseLabel, jobDriver, configurationOverrides, tags)
#'
#' @param name The name of the job run.
#' @param virtualClusterId &#91;required&#93; The virtual cluster ID for which the job run request is submitted.
#' @param clientToken &#91;required&#93; The client idempotency token of the job run request.
#' @param executionRoleArn &#91;required&#93; The execution role ARN for the job run.
#' @param releaseLabel &#91;required&#93; The Amazon EMR release version to use for the job run.
#' @param jobDriver &#91;required&#93; The job driver for the job run.
#' @param configurationOverrides The configuration overrides for the job run.
#' @param tags The tags assigned to job runs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   name = "string",
#'   virtualClusterId = "string",
#'   clientToken = "string",
#'   executionRoleArn = "string",
#'   releaseLabel = "string",
#'   jobDriver = list(
#'     sparkSubmitJobDriver = list(
#'       entryPoint = "string",
#'       entryPointArguments = list(
#'         "string"
#'       ),
#'       sparkSubmitParameters = "string"
#'     )
#'   ),
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       persistentAppUI = "ENABLED"|"DISABLED",
#'       cloudWatchMonitoringConfiguration = list(
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string"
#'       ),
#'       s3MonitoringConfiguration = list(
#'         logUri = "string"
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_start_job_run
emrcontainers_start_job_run <- function(name = NULL, virtualClusterId, clientToken, executionRoleArn, releaseLabel, jobDriver, configurationOverrides = NULL, tags = NULL) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns",
    paginator = list()
  )
  input <- .emrcontainers$start_job_run_input(name = name, virtualClusterId = virtualClusterId, clientToken = clientToken, executionRoleArn = executionRoleArn, releaseLabel = releaseLabel, jobDriver = jobDriver, configurationOverrides = configurationOverrides, tags = tags)
  output <- .emrcontainers$start_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$start_job_run <- emrcontainers_start_job_run

#' Assigns tags to resources
#'
#' @description
#' Assigns tags to resources. A tag is a label that you assign to an AWS
#' resource. Each tag consists of a key and an optional value, both of
#' which you define. Tags enable you to categorize your AWS resources by
#' attributes such as purpose, owner, or environment. When you have many
#' resources of the same type, you can quickly identify a specific resource
#' based on the tags you've assigned to it. For example, you can define a
#' set of tags for your Amazon EMR on EKS clusters to help you track each
#' cluster's owner and stack level. We recommend that you devise a
#' consistent set of tag keys for each resource type. You can then search
#' and filter the resources based on the tags that you add.
#'
#' @usage
#' emrcontainers_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of resources.
#' @param tags &#91;required&#93; The tags assigned to resources.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_tag_resource
emrcontainers_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrcontainers$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .emrcontainers$tag_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$tag_resource <- emrcontainers_tag_resource

#' Removes tags from resources
#'
#' @description
#' Removes tags from resources.
#'
#' @usage
#' emrcontainers_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of resources.
#' @param tagKeys &#91;required&#93; The tag keys of the resources.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_untag_resource
emrcontainers_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .emrcontainers$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .emrcontainers$untag_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$untag_resource <- emrcontainers_untag_resource

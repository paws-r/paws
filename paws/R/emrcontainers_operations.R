# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include emrcontainers_service.R
NULL

#' Cancels a job run
#'
#' @description
#' Cancels a job run. A job run is a unit of work, such as a Spark jar,
#' PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_cancel_job_run(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the job run to cancel.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which the job run will be canceled.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$cancel_job_run(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_cancel_job_run
#'
#' @aliases emrcontainers_cancel_job_run
emrcontainers_cancel_job_run <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "CancelJobRun",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns/{jobRunId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$cancel_job_run_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$cancel_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$cancel_job_run <- emrcontainers_cancel_job_run

#' Creates a job template
#'
#' @description
#' Creates a job template. Job template stores values of StartJobRun API
#' request in a template and can be used to start a job run. Job template
#' allows two use cases: avoid repeating recurring StartJobRun API request
#' values, enforcing certain values in StartJobRun API request.
#'
#' @usage
#' emrcontainers_create_job_template(name, clientToken, jobTemplateData,
#'   tags, kmsKeyArn)
#'
#' @param name &#91;required&#93; The specified name of the job template.
#' @param clientToken &#91;required&#93; The client token of the job template.
#' @param jobTemplateData &#91;required&#93; The job template data which holds values of StartJobRun API request.
#' @param tags The tags that are associated with the job template.
#' @param kmsKeyArn The KMS key ARN used to encrypt the job template.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string",
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_job_template(
#'   name = "string",
#'   clientToken = "string",
#'   jobTemplateData = list(
#'     executionRoleArn = "string",
#'     releaseLabel = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         persistentAppUI = "string",
#'         cloudWatchMonitoringConfiguration = list(
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string"
#'         ),
#'         s3MonitoringConfiguration = list(
#'           logUri = "string"
#'         )
#'       )
#'     ),
#'     jobDriver = list(
#'       sparkSubmitJobDriver = list(
#'         entryPoint = "string",
#'         entryPointArguments = list(
#'           "string"
#'         ),
#'         sparkSubmitParameters = "string"
#'       ),
#'       sparkSqlJobDriver = list(
#'         entryPoint = "string",
#'         sparkSqlParameters = "string"
#'       )
#'     ),
#'     parameterConfiguration = list(
#'       list(
#'         type = "NUMBER"|"STRING",
#'         defaultValue = "string"
#'       )
#'     ),
#'     jobTags = list(
#'       "string"
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   kmsKeyArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_job_template
#'
#' @aliases emrcontainers_create_job_template
emrcontainers_create_job_template <- function(name, clientToken, jobTemplateData, tags = NULL, kmsKeyArn = NULL) {
  op <- new_operation(
    name = "CreateJobTemplate",
    http_method = "POST",
    http_path = "/jobtemplates",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$create_job_template_input(name = name, clientToken = clientToken, jobTemplateData = jobTemplateData, tags = tags, kmsKeyArn = kmsKeyArn)
  output <- .emrcontainers$create_job_template_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_job_template <- emrcontainers_create_job_template

#' Creates a managed endpoint
#'
#' @description
#' Creates a managed endpoint. A managed endpoint is a gateway that
#' connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR
#' Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_create_managed_endpoint(name, virtualClusterId, type,
#'   releaseLabel, executionRoleArn, certificateArn, configurationOverrides,
#'   clientToken, tags)
#'
#' @param name &#91;required&#93; The name of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which a managed endpoint is created.
#' @param type &#91;required&#93; The type of the managed endpoint.
#' @param releaseLabel &#91;required&#93; The Amazon EMR release version.
#' @param executionRoleArn &#91;required&#93; The ARN of the execution role.
#' @param certificateArn The certificate ARN provided by users for the managed endpoint. This
#' field is under deprecation and will be removed in future releases.
#' @param configurationOverrides The configuration settings that will be used to override existing
#' configurations.
#' @param clientToken &#91;required&#93; The client idempotency token for this create call.
#' @param tags The tags of the managed endpoint.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_managed_endpoint(
#'   name = "string",
#'   virtualClusterId = "string",
#'   type = "string",
#'   releaseLabel = "string",
#'   executionRoleArn = "string",
#'   certificateArn = "string",
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       managedLogs = list(
#'         allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'         encryptionKeyArn = "string"
#'       ),
#'       persistentAppUI = "ENABLED"|"DISABLED",
#'       cloudWatchMonitoringConfiguration = list(
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string"
#'       ),
#'       s3MonitoringConfiguration = list(
#'         logUri = "string"
#'       ),
#'       containerLogRotationConfiguration = list(
#'         rotationSize = "string",
#'         maxFilesToKeep = 123
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_managed_endpoint
#'
#' @aliases emrcontainers_create_managed_endpoint
emrcontainers_create_managed_endpoint <- function(name, virtualClusterId, type, releaseLabel, executionRoleArn, certificateArn = NULL, configurationOverrides = NULL, clientToken, tags = NULL) {
  op <- new_operation(
    name = "CreateManagedEndpoint",
    http_method = "POST",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$create_managed_endpoint_input(name = name, virtualClusterId = virtualClusterId, type = type, releaseLabel = releaseLabel, executionRoleArn = executionRoleArn, certificateArn = certificateArn, configurationOverrides = configurationOverrides, clientToken = clientToken, tags = tags)
  output <- .emrcontainers$create_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_managed_endpoint <- emrcontainers_create_managed_endpoint

#' Creates a security configuration
#'
#' @description
#' Creates a security configuration. Security configurations in Amazon EMR
#' on EKS are templates for different security setups. You can use security
#' configurations to configure the Lake Formation integration setup. You
#' can also create a security configuration to re-use a security setup each
#' time you create a virtual cluster.
#'
#' @usage
#' emrcontainers_create_security_configuration(clientToken, name,
#'   containerProvider, securityConfigurationData, tags)
#'
#' @param clientToken &#91;required&#93; The client idempotency token to use when creating the security
#' configuration.
#' @param name &#91;required&#93; The name of the security configuration.
#' @param containerProvider The container provider associated with the security configuration.
#' @param securityConfigurationData &#91;required&#93; Security configuration input for the request.
#' @param tags The tags to add to the security configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_security_configuration(
#'   clientToken = "string",
#'   name = "string",
#'   containerProvider = list(
#'     type = "EKS",
#'     id = "string",
#'     info = list(
#'       eksInfo = list(
#'         namespace = "string",
#'         nodeLabel = "string"
#'       )
#'     )
#'   ),
#'   securityConfigurationData = list(
#'     authorizationConfiguration = list(
#'       lakeFormationConfiguration = list(
#'         authorizedSessionTagValue = "string",
#'         secureNamespaceInfo = list(
#'           clusterId = "string",
#'           namespace = "string"
#'         ),
#'         queryEngineRoleArn = "string"
#'       ),
#'       encryptionConfiguration = list(
#'         inTransitEncryptionConfiguration = list(
#'           tlsCertificateConfiguration = list(
#'             certificateProviderType = "PEM",
#'             publicCertificateSecretArn = "string",
#'             privateCertificateSecretArn = "string"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_security_configuration
#'
#' @aliases emrcontainers_create_security_configuration
emrcontainers_create_security_configuration <- function(clientToken, name, containerProvider = NULL, securityConfigurationData, tags = NULL) {
  op <- new_operation(
    name = "CreateSecurityConfiguration",
    http_method = "POST",
    http_path = "/securityconfigurations",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$create_security_configuration_input(clientToken = clientToken, name = name, containerProvider = containerProvider, securityConfigurationData = securityConfigurationData, tags = tags)
  output <- .emrcontainers$create_security_configuration_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_security_configuration <- emrcontainers_create_security_configuration

#' Creates a virtual cluster
#'
#' @description
#' Creates a virtual cluster. Virtual cluster is a managed entity on Amazon
#' EMR on EKS. You can create, describe, list and delete virtual clusters.
#' They do not consume any additional resource in your system. A single
#' virtual cluster maps to a single Kubernetes namespace. Given this
#' relationship, you can model virtual clusters the same way you model
#' Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_create_virtual_cluster(name, containerProvider,
#'   clientToken, tags, securityConfigurationId)
#'
#' @param name &#91;required&#93; The specified name of the virtual cluster.
#' @param containerProvider &#91;required&#93; The container provider of the virtual cluster.
#' @param clientToken &#91;required&#93; The client token of the virtual cluster.
#' @param tags The tags assigned to the virtual cluster.
#' @param securityConfigurationId The ID of the security configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_virtual_cluster(
#'   name = "string",
#'   containerProvider = list(
#'     type = "EKS",
#'     id = "string",
#'     info = list(
#'       eksInfo = list(
#'         namespace = "string",
#'         nodeLabel = "string"
#'       )
#'     )
#'   ),
#'   clientToken = "string",
#'   tags = list(
#'     "string"
#'   ),
#'   securityConfigurationId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_create_virtual_cluster
#'
#' @aliases emrcontainers_create_virtual_cluster
emrcontainers_create_virtual_cluster <- function(name, containerProvider, clientToken, tags = NULL, securityConfigurationId = NULL) {
  op <- new_operation(
    name = "CreateVirtualCluster",
    http_method = "POST",
    http_path = "/virtualclusters",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$create_virtual_cluster_input(name = name, containerProvider = containerProvider, clientToken = clientToken, tags = tags, securityConfigurationId = securityConfigurationId)
  output <- .emrcontainers$create_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$create_virtual_cluster <- emrcontainers_create_virtual_cluster

#' Deletes a job template
#'
#' @description
#' Deletes a job template. Job template stores values of StartJobRun API
#' request in a template and can be used to start a job run. Job template
#' allows two use cases: avoid repeating recurring StartJobRun API request
#' values, enforcing certain values in StartJobRun API request.
#'
#' @usage
#' emrcontainers_delete_job_template(id)
#'
#' @param id &#91;required&#93; The ID of the job template that will be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_job_template(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_delete_job_template
#'
#' @aliases emrcontainers_delete_job_template
emrcontainers_delete_job_template <- function(id) {
  op <- new_operation(
    name = "DeleteJobTemplate",
    http_method = "DELETE",
    http_path = "/jobtemplates/{templateId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$delete_job_template_input(id = id)
  output <- .emrcontainers$delete_job_template_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$delete_job_template <- emrcontainers_delete_job_template

#' Deletes a managed endpoint
#'
#' @description
#' Deletes a managed endpoint. A managed endpoint is a gateway that
#' connects Amazon EMR Studio to Amazon EMR on EKS so that Amazon EMR
#' Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_delete_managed_endpoint(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the endpoint's virtual cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_managed_endpoint(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_delete_managed_endpoint
#'
#' @aliases emrcontainers_delete_managed_endpoint
emrcontainers_delete_managed_endpoint <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DeleteManagedEndpoint",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints/{endpointId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$delete_managed_endpoint_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$delete_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$delete_managed_endpoint <- emrcontainers_delete_managed_endpoint

#' Deletes a virtual cluster
#'
#' @description
#' Deletes a virtual cluster. Virtual cluster is a managed entity on Amazon
#' EMR on EKS. You can create, describe, list and delete virtual clusters.
#' They do not consume any additional resource in your system. A single
#' virtual cluster maps to a single Kubernetes namespace. Given this
#' relationship, you can model virtual clusters the same way you model
#' Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_delete_virtual_cluster(id)
#'
#' @param id &#91;required&#93; The ID of the virtual cluster that will be deleted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$delete_virtual_cluster(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_delete_virtual_cluster
#'
#' @aliases emrcontainers_delete_virtual_cluster
emrcontainers_delete_virtual_cluster <- function(id) {
  op <- new_operation(
    name = "DeleteVirtualCluster",
    http_method = "DELETE",
    http_path = "/virtualclusters/{virtualClusterId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$delete_virtual_cluster_input(id = id)
  output <- .emrcontainers$delete_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$delete_virtual_cluster <- emrcontainers_delete_virtual_cluster

#' Displays detailed information about a job run
#'
#' @description
#' Displays detailed information about a job run. A job run is a unit of
#' work, such as a Spark jar, PySpark script, or SparkSQL query, that you
#' submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_describe_job_run(id, virtualClusterId)
#'
#' @param id &#91;required&#93; The ID of the job run request.
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which the job run is submitted.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRun = list(
#'     id = "string",
#'     name = "string",
#'     virtualClusterId = "string",
#'     arn = "string",
#'     state = "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED",
#'     clientToken = "string",
#'     executionRoleArn = "string",
#'     releaseLabel = "string",
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         managedLogs = list(
#'           allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'           encryptionKeyArn = "string"
#'         ),
#'         persistentAppUI = "ENABLED"|"DISABLED",
#'         cloudWatchMonitoringConfiguration = list(
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string"
#'         ),
#'         s3MonitoringConfiguration = list(
#'           logUri = "string"
#'         ),
#'         containerLogRotationConfiguration = list(
#'           rotationSize = "string",
#'           maxFilesToKeep = 123
#'         )
#'       )
#'     ),
#'     jobDriver = list(
#'       sparkSubmitJobDriver = list(
#'         entryPoint = "string",
#'         entryPointArguments = list(
#'           "string"
#'         ),
#'         sparkSubmitParameters = "string"
#'       ),
#'       sparkSqlJobDriver = list(
#'         entryPoint = "string",
#'         sparkSqlParameters = "string"
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBy = "string",
#'     finishedAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     stateDetails = "string",
#'     failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'     tags = list(
#'       "string"
#'     ),
#'     retryPolicyConfiguration = list(
#'       maxAttempts = 123
#'     ),
#'     retryPolicyExecution = list(
#'       currentAttemptCount = 123
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_run(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_job_run
#'
#' @aliases emrcontainers_describe_job_run
emrcontainers_describe_job_run <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DescribeJobRun",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns/{jobRunId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$describe_job_run_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$describe_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_job_run <- emrcontainers_describe_job_run

#' Displays detailed information about a specified job template
#'
#' @description
#' Displays detailed information about a specified job template. Job
#' template stores values of StartJobRun API request in a template and can
#' be used to start a job run. Job template allows two use cases: avoid
#' repeating recurring StartJobRun API request values, enforcing certain
#' values in StartJobRun API request.
#'
#' @usage
#' emrcontainers_describe_job_template(id)
#'
#' @param id &#91;required&#93; The ID of the job template that will be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobTemplate = list(
#'     name = "string",
#'     id = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBy = "string",
#'     tags = list(
#'       "string"
#'     ),
#'     jobTemplateData = list(
#'       executionRoleArn = "string",
#'       releaseLabel = "string",
#'       configurationOverrides = list(
#'         applicationConfiguration = list(
#'           list(
#'             classification = "string",
#'             properties = list(
#'               "string"
#'             ),
#'             configurations = list()
#'           )
#'         ),
#'         monitoringConfiguration = list(
#'           persistentAppUI = "string",
#'           cloudWatchMonitoringConfiguration = list(
#'             logGroupName = "string",
#'             logStreamNamePrefix = "string"
#'           ),
#'           s3MonitoringConfiguration = list(
#'             logUri = "string"
#'           )
#'         )
#'       ),
#'       jobDriver = list(
#'         sparkSubmitJobDriver = list(
#'           entryPoint = "string",
#'           entryPointArguments = list(
#'             "string"
#'           ),
#'           sparkSubmitParameters = "string"
#'         ),
#'         sparkSqlJobDriver = list(
#'           entryPoint = "string",
#'           sparkSqlParameters = "string"
#'         )
#'       ),
#'       parameterConfiguration = list(
#'         list(
#'           type = "NUMBER"|"STRING",
#'           defaultValue = "string"
#'         )
#'       ),
#'       jobTags = list(
#'         "string"
#'       )
#'     ),
#'     kmsKeyArn = "string",
#'     decryptionError = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_template(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_job_template
#'
#' @aliases emrcontainers_describe_job_template
emrcontainers_describe_job_template <- function(id) {
  op <- new_operation(
    name = "DescribeJobTemplate",
    http_method = "GET",
    http_path = "/jobtemplates/{templateId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$describe_job_template_input(id = id)
  output <- .emrcontainers$describe_job_template_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_job_template <- emrcontainers_describe_job_template

#' Displays detailed information about a managed endpoint
#'
#' @description
#' Displays detailed information about a managed endpoint. A managed
#' endpoint is a gateway that connects Amazon EMR Studio to Amazon EMR on
#' EKS so that Amazon EMR Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_describe_managed_endpoint(id, virtualClusterId)
#'
#' @param id &#91;required&#93; This output displays ID of the managed endpoint.
#' @param virtualClusterId &#91;required&#93; The ID of the endpoint's virtual cluster.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   endpoint = list(
#'     id = "string",
#'     name = "string",
#'     arn = "string",
#'     virtualClusterId = "string",
#'     type = "string",
#'     state = "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS",
#'     releaseLabel = "string",
#'     executionRoleArn = "string",
#'     certificateArn = "string",
#'     certificateAuthority = list(
#'       certificateArn = "string",
#'       certificateData = "string"
#'     ),
#'     configurationOverrides = list(
#'       applicationConfiguration = list(
#'         list(
#'           classification = "string",
#'           properties = list(
#'             "string"
#'           ),
#'           configurations = list()
#'         )
#'       ),
#'       monitoringConfiguration = list(
#'         managedLogs = list(
#'           allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'           encryptionKeyArn = "string"
#'         ),
#'         persistentAppUI = "ENABLED"|"DISABLED",
#'         cloudWatchMonitoringConfiguration = list(
#'           logGroupName = "string",
#'           logStreamNamePrefix = "string"
#'         ),
#'         s3MonitoringConfiguration = list(
#'           logUri = "string"
#'         ),
#'         containerLogRotationConfiguration = list(
#'           rotationSize = "string",
#'           maxFilesToKeep = 123
#'         )
#'       )
#'     ),
#'     serverUrl = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     securityGroup = "string",
#'     subnetIds = list(
#'       "string"
#'     ),
#'     stateDetails = "string",
#'     failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_managed_endpoint(
#'   id = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_managed_endpoint
#'
#' @aliases emrcontainers_describe_managed_endpoint
emrcontainers_describe_managed_endpoint <- function(id, virtualClusterId) {
  op <- new_operation(
    name = "DescribeManagedEndpoint",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints/{endpointId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$describe_managed_endpoint_input(id = id, virtualClusterId = virtualClusterId)
  output <- .emrcontainers$describe_managed_endpoint_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_managed_endpoint <- emrcontainers_describe_managed_endpoint

#' Displays detailed information about a specified security configuration
#'
#' @description
#' Displays detailed information about a specified security configuration.
#' Security configurations in Amazon EMR on EKS are templates for different
#' security setups. You can use security configurations to configure the
#' Lake Formation integration setup. You can also create a security
#' configuration to re-use a security setup each time you create a virtual
#' cluster.
#'
#' @usage
#' emrcontainers_describe_security_configuration(id)
#'
#' @param id &#91;required&#93; The ID of the security configuration.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   securityConfiguration = list(
#'     id = "string",
#'     name = "string",
#'     arn = "string",
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     createdBy = "string",
#'     securityConfigurationData = list(
#'       authorizationConfiguration = list(
#'         lakeFormationConfiguration = list(
#'           authorizedSessionTagValue = "string",
#'           secureNamespaceInfo = list(
#'             clusterId = "string",
#'             namespace = "string"
#'           ),
#'           queryEngineRoleArn = "string"
#'         ),
#'         encryptionConfiguration = list(
#'           inTransitEncryptionConfiguration = list(
#'             tlsCertificateConfiguration = list(
#'               certificateProviderType = "PEM",
#'               publicCertificateSecretArn = "string",
#'               privateCertificateSecretArn = "string"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     tags = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_security_configuration(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_security_configuration
#'
#' @aliases emrcontainers_describe_security_configuration
emrcontainers_describe_security_configuration <- function(id) {
  op <- new_operation(
    name = "DescribeSecurityConfiguration",
    http_method = "GET",
    http_path = "/securityconfigurations/{securityConfigurationId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$describe_security_configuration_input(id = id)
  output <- .emrcontainers$describe_security_configuration_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_security_configuration <- emrcontainers_describe_security_configuration

#' Displays detailed information about a specified virtual cluster
#'
#' @description
#' Displays detailed information about a specified virtual cluster. Virtual
#' cluster is a managed entity on Amazon EMR on EKS. You can create,
#' describe, list and delete virtual clusters. They do not consume any
#' additional resource in your system. A single virtual cluster maps to a
#' single Kubernetes namespace. Given this relationship, you can model
#' virtual clusters the same way you model Kubernetes namespaces to meet
#' your requirements.
#'
#' @usage
#' emrcontainers_describe_virtual_cluster(id)
#'
#' @param id &#91;required&#93; The ID of the virtual cluster that will be described.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   virtualCluster = list(
#'     id = "string",
#'     name = "string",
#'     arn = "string",
#'     state = "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED",
#'     containerProvider = list(
#'       type = "EKS",
#'       id = "string",
#'       info = list(
#'         eksInfo = list(
#'           namespace = "string",
#'           nodeLabel = "string"
#'         )
#'       )
#'     ),
#'     createdAt = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     tags = list(
#'       "string"
#'     ),
#'     securityConfigurationId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_virtual_cluster(
#'   id = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_describe_virtual_cluster
#'
#' @aliases emrcontainers_describe_virtual_cluster
emrcontainers_describe_virtual_cluster <- function(id) {
  op <- new_operation(
    name = "DescribeVirtualCluster",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$describe_virtual_cluster_input(id = id)
  output <- .emrcontainers$describe_virtual_cluster_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$describe_virtual_cluster <- emrcontainers_describe_virtual_cluster

#' Generate a session token to connect to a managed endpoint
#'
#' @description
#' Generate a session token to connect to a managed endpoint.
#'
#' @usage
#' emrcontainers_get_managed_endpoint_session_credentials(
#'   endpointIdentifier, virtualClusterIdentifier, executionRoleArn,
#'   credentialType, durationInSeconds, logContext, clientToken)
#'
#' @param endpointIdentifier &#91;required&#93; The ARN of the managed endpoint for which the request is submitted.
#' @param virtualClusterIdentifier &#91;required&#93; The ARN of the Virtual Cluster which the Managed Endpoint belongs to.
#' @param executionRoleArn &#91;required&#93; The IAM Execution Role ARN that will be used by the job run.
#' @param credentialType &#91;required&#93; Type of the token requested. Currently supported and default value of
#' this field is “TOKEN.”
#' @param durationInSeconds Duration in seconds for which the session token is valid. The default
#' duration is 15 minutes and the maximum is 12 hours.
#' @param logContext String identifier used to separate sections of the execution logs
#' uploaded to S3.
#' @param clientToken The client idempotency token of the job run request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   credentials = list(
#'     token = "string"
#'   ),
#'   expiresAt = as.POSIXct(
#'     "2015-01-01"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_managed_endpoint_session_credentials(
#'   endpointIdentifier = "string",
#'   virtualClusterIdentifier = "string",
#'   executionRoleArn = "string",
#'   credentialType = "string",
#'   durationInSeconds = 123,
#'   logContext = "string",
#'   clientToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_get_managed_endpoint_session_credentials
#'
#' @aliases emrcontainers_get_managed_endpoint_session_credentials
emrcontainers_get_managed_endpoint_session_credentials <- function(endpointIdentifier, virtualClusterIdentifier, executionRoleArn, credentialType, durationInSeconds = NULL, logContext = NULL, clientToken = NULL) {
  op <- new_operation(
    name = "GetManagedEndpointSessionCredentials",
    http_method = "POST",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints/{endpointId}/credentials",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$get_managed_endpoint_session_credentials_input(endpointIdentifier = endpointIdentifier, virtualClusterIdentifier = virtualClusterIdentifier, executionRoleArn = executionRoleArn, credentialType = credentialType, durationInSeconds = durationInSeconds, logContext = logContext, clientToken = clientToken)
  output <- .emrcontainers$get_managed_endpoint_session_credentials_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$get_managed_endpoint_session_credentials <- emrcontainers_get_managed_endpoint_session_credentials

#' Lists job runs based on a set of parameters
#'
#' @description
#' Lists job runs based on a set of parameters. A job run is a unit of
#' work, such as a Spark jar, PySpark script, or SparkSQL query, that you
#' submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_list_job_runs(virtualClusterId, createdBefore,
#'   createdAfter, name, states, maxResults, nextToken)
#'
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster for which to list the job run.
#' @param createdBefore The date and time before which the job runs were submitted.
#' @param createdAfter The date and time after which the job runs were submitted.
#' @param name The name of the job run.
#' @param states The states of the job run.
#' @param maxResults The maximum number of job runs that can be listed.
#' @param nextToken The token for the next set of job runs to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   jobRuns = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       virtualClusterId = "string",
#'       arn = "string",
#'       state = "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED",
#'       clientToken = "string",
#'       executionRoleArn = "string",
#'       releaseLabel = "string",
#'       configurationOverrides = list(
#'         applicationConfiguration = list(
#'           list(
#'             classification = "string",
#'             properties = list(
#'               "string"
#'             ),
#'             configurations = list()
#'           )
#'         ),
#'         monitoringConfiguration = list(
#'           managedLogs = list(
#'             allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'             encryptionKeyArn = "string"
#'           ),
#'           persistentAppUI = "ENABLED"|"DISABLED",
#'           cloudWatchMonitoringConfiguration = list(
#'             logGroupName = "string",
#'             logStreamNamePrefix = "string"
#'           ),
#'           s3MonitoringConfiguration = list(
#'             logUri = "string"
#'           ),
#'           containerLogRotationConfiguration = list(
#'             rotationSize = "string",
#'             maxFilesToKeep = 123
#'           )
#'         )
#'       ),
#'       jobDriver = list(
#'         sparkSubmitJobDriver = list(
#'           entryPoint = "string",
#'           entryPointArguments = list(
#'             "string"
#'           ),
#'           sparkSubmitParameters = "string"
#'         ),
#'         sparkSqlJobDriver = list(
#'           entryPoint = "string",
#'           sparkSqlParameters = "string"
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       finishedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       stateDetails = "string",
#'       failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'       tags = list(
#'         "string"
#'       ),
#'       retryPolicyConfiguration = list(
#'         maxAttempts = 123
#'       ),
#'       retryPolicyExecution = list(
#'         currentAttemptCount = 123
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_runs(
#'   virtualClusterId = "string",
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   name = "string",
#'   states = list(
#'     "PENDING"|"SUBMITTED"|"RUNNING"|"FAILED"|"CANCELLED"|"CANCEL_PENDING"|"COMPLETED"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_job_runs
#'
#' @aliases emrcontainers_list_job_runs
emrcontainers_list_job_runs <- function(virtualClusterId, createdBefore = NULL, createdAfter = NULL, name = NULL, states = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobRuns",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "jobRuns"),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_job_runs_input(virtualClusterId = virtualClusterId, createdBefore = createdBefore, createdAfter = createdAfter, name = name, states = states, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_job_runs_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_job_runs <- emrcontainers_list_job_runs

#' Lists job templates based on a set of parameters
#'
#' @description
#' Lists job templates based on a set of parameters. Job template stores
#' values of StartJobRun API request in a template and can be used to start
#' a job run. Job template allows two use cases: avoid repeating recurring
#' StartJobRun API request values, enforcing certain values in StartJobRun
#' API request.
#'
#' @usage
#' emrcontainers_list_job_templates(createdAfter, createdBefore,
#'   maxResults, nextToken)
#'
#' @param createdAfter The date and time after which the job templates were created.
#' @param createdBefore The date and time before which the job templates were created.
#' @param maxResults The maximum number of job templates that can be listed.
#' @param nextToken The token for the next set of job templates to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   templates = list(
#'     list(
#'       name = "string",
#'       id = "string",
#'       arn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       tags = list(
#'         "string"
#'       ),
#'       jobTemplateData = list(
#'         executionRoleArn = "string",
#'         releaseLabel = "string",
#'         configurationOverrides = list(
#'           applicationConfiguration = list(
#'             list(
#'               classification = "string",
#'               properties = list(
#'                 "string"
#'               ),
#'               configurations = list()
#'             )
#'           ),
#'           monitoringConfiguration = list(
#'             persistentAppUI = "string",
#'             cloudWatchMonitoringConfiguration = list(
#'               logGroupName = "string",
#'               logStreamNamePrefix = "string"
#'             ),
#'             s3MonitoringConfiguration = list(
#'               logUri = "string"
#'             )
#'           )
#'         ),
#'         jobDriver = list(
#'           sparkSubmitJobDriver = list(
#'             entryPoint = "string",
#'             entryPointArguments = list(
#'               "string"
#'             ),
#'             sparkSubmitParameters = "string"
#'           ),
#'           sparkSqlJobDriver = list(
#'             entryPoint = "string",
#'             sparkSqlParameters = "string"
#'           )
#'         ),
#'         parameterConfiguration = list(
#'           list(
#'             type = "NUMBER"|"STRING",
#'             defaultValue = "string"
#'           )
#'         ),
#'         jobTags = list(
#'           "string"
#'         )
#'       ),
#'       kmsKeyArn = "string",
#'       decryptionError = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_job_templates(
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_job_templates
#'
#' @aliases emrcontainers_list_job_templates
emrcontainers_list_job_templates <- function(createdAfter = NULL, createdBefore = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListJobTemplates",
    http_method = "GET",
    http_path = "/jobtemplates",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "templates"),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_job_templates_input(createdAfter = createdAfter, createdBefore = createdBefore, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_job_templates_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_job_templates <- emrcontainers_list_job_templates

#' Lists managed endpoints based on a set of parameters
#'
#' @description
#' Lists managed endpoints based on a set of parameters. A managed endpoint
#' is a gateway that connects Amazon EMR Studio to Amazon EMR on EKS so
#' that Amazon EMR Studio can communicate with your virtual cluster.
#'
#' @usage
#' emrcontainers_list_managed_endpoints(virtualClusterId, createdBefore,
#'   createdAfter, types, states, maxResults, nextToken)
#'
#' @param virtualClusterId &#91;required&#93; The ID of the virtual cluster.
#' @param createdBefore The date and time before which the endpoints are created.
#' @param createdAfter The date and time after which the endpoints are created.
#' @param types The types of the managed endpoints.
#' @param states The states of the managed endpoints.
#' @param maxResults The maximum number of managed endpoints that can be listed.
#' @param nextToken The token for the next set of managed endpoints to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   endpoints = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       virtualClusterId = "string",
#'       type = "string",
#'       state = "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS",
#'       releaseLabel = "string",
#'       executionRoleArn = "string",
#'       certificateArn = "string",
#'       certificateAuthority = list(
#'         certificateArn = "string",
#'         certificateData = "string"
#'       ),
#'       configurationOverrides = list(
#'         applicationConfiguration = list(
#'           list(
#'             classification = "string",
#'             properties = list(
#'               "string"
#'             ),
#'             configurations = list()
#'           )
#'         ),
#'         monitoringConfiguration = list(
#'           managedLogs = list(
#'             allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'             encryptionKeyArn = "string"
#'           ),
#'           persistentAppUI = "ENABLED"|"DISABLED",
#'           cloudWatchMonitoringConfiguration = list(
#'             logGroupName = "string",
#'             logStreamNamePrefix = "string"
#'           ),
#'           s3MonitoringConfiguration = list(
#'             logUri = "string"
#'           ),
#'           containerLogRotationConfiguration = list(
#'             rotationSize = "string",
#'             maxFilesToKeep = 123
#'           )
#'         )
#'       ),
#'       serverUrl = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       securityGroup = "string",
#'       subnetIds = list(
#'         "string"
#'       ),
#'       stateDetails = "string",
#'       failureReason = "INTERNAL_ERROR"|"USER_ERROR"|"VALIDATION_ERROR"|"CLUSTER_UNAVAILABLE",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_managed_endpoints(
#'   virtualClusterId = "string",
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   types = list(
#'     "string"
#'   ),
#'   states = list(
#'     "CREATING"|"ACTIVE"|"TERMINATING"|"TERMINATED"|"TERMINATED_WITH_ERRORS"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_managed_endpoints
#'
#' @aliases emrcontainers_list_managed_endpoints
emrcontainers_list_managed_endpoints <- function(virtualClusterId, createdBefore = NULL, createdAfter = NULL, types = NULL, states = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListManagedEndpoints",
    http_method = "GET",
    http_path = "/virtualclusters/{virtualClusterId}/endpoints",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "endpoints"),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_managed_endpoints_input(virtualClusterId = virtualClusterId, createdBefore = createdBefore, createdAfter = createdAfter, types = types, states = states, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_managed_endpoints_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_managed_endpoints <- emrcontainers_list_managed_endpoints

#' Lists security configurations based on a set of parameters
#'
#' @description
#' Lists security configurations based on a set of parameters. Security
#' configurations in Amazon EMR on EKS are templates for different security
#' setups. You can use security configurations to configure the Lake
#' Formation integration setup. You can also create a security
#' configuration to re-use a security setup each time you create a virtual
#' cluster.
#'
#' @usage
#' emrcontainers_list_security_configurations(createdAfter, createdBefore,
#'   maxResults, nextToken)
#'
#' @param createdAfter The date and time after which the security configuration was created.
#' @param createdBefore The date and time before which the security configuration was created.
#' @param maxResults The maximum number of security configurations the operation can list.
#' @param nextToken The token for the next set of security configurations to return.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   securityConfigurations = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       createdBy = "string",
#'       securityConfigurationData = list(
#'         authorizationConfiguration = list(
#'           lakeFormationConfiguration = list(
#'             authorizedSessionTagValue = "string",
#'             secureNamespaceInfo = list(
#'               clusterId = "string",
#'               namespace = "string"
#'             ),
#'             queryEngineRoleArn = "string"
#'           ),
#'           encryptionConfiguration = list(
#'             inTransitEncryptionConfiguration = list(
#'               tlsCertificateConfiguration = list(
#'                 certificateProviderType = "PEM",
#'                 publicCertificateSecretArn = "string",
#'                 privateCertificateSecretArn = "string"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_security_configurations(
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_security_configurations
#'
#' @aliases emrcontainers_list_security_configurations
emrcontainers_list_security_configurations <- function(createdAfter = NULL, createdBefore = NULL, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListSecurityConfigurations",
    http_method = "GET",
    http_path = "/securityconfigurations",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "securityConfigurations"),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_security_configurations_input(createdAfter = createdAfter, createdBefore = createdBefore, maxResults = maxResults, nextToken = nextToken)
  output <- .emrcontainers$list_security_configurations_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_security_configurations <- emrcontainers_list_security_configurations

#' Lists the tags assigned to the resources
#'
#' @description
#' Lists the tags assigned to the resources.
#'
#' @usage
#' emrcontainers_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The ARN of tagged resources.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_tags_for_resource
#'
#' @aliases emrcontainers_list_tags_for_resource
emrcontainers_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .emrcontainers$list_tags_for_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_tags_for_resource <- emrcontainers_list_tags_for_resource

#' Lists information about the specified virtual cluster
#'
#' @description
#' Lists information about the specified virtual cluster. Virtual cluster
#' is a managed entity on Amazon EMR on EKS. You can create, describe, list
#' and delete virtual clusters. They do not consume any additional resource
#' in your system. A single virtual cluster maps to a single Kubernetes
#' namespace. Given this relationship, you can model virtual clusters the
#' same way you model Kubernetes namespaces to meet your requirements.
#'
#' @usage
#' emrcontainers_list_virtual_clusters(containerProviderId,
#'   containerProviderType, createdAfter, createdBefore, states, maxResults,
#'   nextToken, eksAccessEntryIntegrated)
#'
#' @param containerProviderId The container provider ID of the virtual cluster.
#' @param containerProviderType The container provider type of the virtual cluster. Amazon EKS is the
#' only supported type as of now.
#' @param createdAfter The date and time after which the virtual clusters are created.
#' @param createdBefore The date and time before which the virtual clusters are created.
#' @param states The states of the requested virtual clusters.
#' @param maxResults The maximum number of virtual clusters that can be listed.
#' @param nextToken The token for the next set of virtual clusters to return.
#' @param eksAccessEntryIntegrated Optional Boolean that specifies whether the operation should return the
#' virtual clusters that have the access entry integration enabled or
#' disabled. If not specified, the operation returns all applicable virtual
#' clusters.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   virtualClusters = list(
#'     list(
#'       id = "string",
#'       name = "string",
#'       arn = "string",
#'       state = "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED",
#'       containerProvider = list(
#'         type = "EKS",
#'         id = "string",
#'         info = list(
#'           eksInfo = list(
#'             namespace = "string",
#'             nodeLabel = "string"
#'           )
#'         )
#'       ),
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       securityConfigurationId = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_virtual_clusters(
#'   containerProviderId = "string",
#'   containerProviderType = "EKS",
#'   createdAfter = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   createdBefore = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   states = list(
#'     "RUNNING"|"TERMINATING"|"TERMINATED"|"ARRESTED"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string",
#'   eksAccessEntryIntegrated = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_list_virtual_clusters
#'
#' @aliases emrcontainers_list_virtual_clusters
emrcontainers_list_virtual_clusters <- function(containerProviderId = NULL, containerProviderType = NULL, createdAfter = NULL, createdBefore = NULL, states = NULL, maxResults = NULL, nextToken = NULL, eksAccessEntryIntegrated = NULL) {
  op <- new_operation(
    name = "ListVirtualClusters",
    http_method = "GET",
    http_path = "/virtualclusters",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "virtualClusters"),
    stream_api = FALSE
  )
  input <- .emrcontainers$list_virtual_clusters_input(containerProviderId = containerProviderId, containerProviderType = containerProviderType, createdAfter = createdAfter, createdBefore = createdBefore, states = states, maxResults = maxResults, nextToken = nextToken, eksAccessEntryIntegrated = eksAccessEntryIntegrated)
  output <- .emrcontainers$list_virtual_clusters_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$list_virtual_clusters <- emrcontainers_list_virtual_clusters

#' Starts a job run
#'
#' @description
#' Starts a job run. A job run is a unit of work, such as a Spark jar,
#' PySpark script, or SparkSQL query, that you submit to Amazon EMR on EKS.
#'
#' @usage
#' emrcontainers_start_job_run(name, virtualClusterId, clientToken,
#'   executionRoleArn, releaseLabel, jobDriver, configurationOverrides, tags,
#'   jobTemplateId, jobTemplateParameters, retryPolicyConfiguration)
#'
#' @param name The name of the job run.
#' @param virtualClusterId &#91;required&#93; The virtual cluster ID for which the job run request is submitted.
#' @param clientToken &#91;required&#93; The client idempotency token of the job run request.
#' @param executionRoleArn The execution role ARN for the job run.
#' @param releaseLabel The Amazon EMR release version to use for the job run.
#' @param jobDriver The job driver for the job run.
#' @param configurationOverrides The configuration overrides for the job run.
#' @param tags The tags assigned to job runs.
#' @param jobTemplateId The job template ID to be used to start the job run.
#' @param jobTemplateParameters The values of job template parameters to start a job run.
#' @param retryPolicyConfiguration The retry policy configuration for the job run.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   id = "string",
#'   name = "string",
#'   arn = "string",
#'   virtualClusterId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_job_run(
#'   name = "string",
#'   virtualClusterId = "string",
#'   clientToken = "string",
#'   executionRoleArn = "string",
#'   releaseLabel = "string",
#'   jobDriver = list(
#'     sparkSubmitJobDriver = list(
#'       entryPoint = "string",
#'       entryPointArguments = list(
#'         "string"
#'       ),
#'       sparkSubmitParameters = "string"
#'     ),
#'     sparkSqlJobDriver = list(
#'       entryPoint = "string",
#'       sparkSqlParameters = "string"
#'     )
#'   ),
#'   configurationOverrides = list(
#'     applicationConfiguration = list(
#'       list(
#'         classification = "string",
#'         properties = list(
#'           "string"
#'         ),
#'         configurations = list()
#'       )
#'     ),
#'     monitoringConfiguration = list(
#'       managedLogs = list(
#'         allowAWSToRetainLogs = "ENABLED"|"DISABLED",
#'         encryptionKeyArn = "string"
#'       ),
#'       persistentAppUI = "ENABLED"|"DISABLED",
#'       cloudWatchMonitoringConfiguration = list(
#'         logGroupName = "string",
#'         logStreamNamePrefix = "string"
#'       ),
#'       s3MonitoringConfiguration = list(
#'         logUri = "string"
#'       ),
#'       containerLogRotationConfiguration = list(
#'         rotationSize = "string",
#'         maxFilesToKeep = 123
#'       )
#'     )
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   jobTemplateId = "string",
#'   jobTemplateParameters = list(
#'     "string"
#'   ),
#'   retryPolicyConfiguration = list(
#'     maxAttempts = 123
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_start_job_run
#'
#' @aliases emrcontainers_start_job_run
emrcontainers_start_job_run <- function(name = NULL, virtualClusterId, clientToken, executionRoleArn = NULL, releaseLabel = NULL, jobDriver = NULL, configurationOverrides = NULL, tags = NULL, jobTemplateId = NULL, jobTemplateParameters = NULL, retryPolicyConfiguration = NULL) {
  op <- new_operation(
    name = "StartJobRun",
    http_method = "POST",
    http_path = "/virtualclusters/{virtualClusterId}/jobruns",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$start_job_run_input(name = name, virtualClusterId = virtualClusterId, clientToken = clientToken, executionRoleArn = executionRoleArn, releaseLabel = releaseLabel, jobDriver = jobDriver, configurationOverrides = configurationOverrides, tags = tags, jobTemplateId = jobTemplateId, jobTemplateParameters = jobTemplateParameters, retryPolicyConfiguration = retryPolicyConfiguration)
  output <- .emrcontainers$start_job_run_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$start_job_run <- emrcontainers_start_job_run

#' Assigns tags to resources
#'
#' @description
#' Assigns tags to resources. A tag is a label that you assign to an Amazon
#' Web Services resource. Each tag consists of a key and an optional value,
#' both of which you define. Tags enable you to categorize your Amazon Web
#' Services resources by attributes such as purpose, owner, or environment.
#' When you have many resources of the same type, you can quickly identify
#' a specific resource based on the tags you've assigned to it. For
#' example, you can define a set of tags for your Amazon EMR on EKS
#' clusters to help you track each cluster's owner and stack level. We
#' recommend that you devise a consistent set of tag keys for each resource
#' type. You can then search and filter the resources based on the tags
#' that you add.
#'
#' @usage
#' emrcontainers_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The ARN of resources.
#' @param tags &#91;required&#93; The tags assigned to resources.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_tag_resource
#'
#' @aliases emrcontainers_tag_resource
emrcontainers_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .emrcontainers$tag_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$tag_resource <- emrcontainers_tag_resource

#' Removes tags from resources
#'
#' @description
#' Removes tags from resources.
#'
#' @usage
#' emrcontainers_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The ARN of resources.
#' @param tagKeys &#91;required&#93; The tag keys of the resources.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname emrcontainers_untag_resource
#'
#' @aliases emrcontainers_untag_resource
emrcontainers_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .emrcontainers$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .emrcontainers$untag_resource_output()
  config <- get_config()
  svc <- .emrcontainers$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.emrcontainers$operations$untag_resource <- emrcontainers_untag_resource

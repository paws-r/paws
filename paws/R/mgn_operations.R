# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include mgn_service.R
NULL

#' Allows the user to set the SourceServer
#'
#' @description
#' Allows the user to set the SourceServer.LifeCycle.state property for
#' specific Source Server IDs to one of the following: READY_FOR_TEST or
#' READY_FOR_CUTOVER. This command only works if the Source Server is
#' already launchable (dataReplicationInfo.lagDuration is not null.)
#'
#' @usage
#' mgn_change_server_life_cycle_state(lifeCycle, sourceServerID)
#'
#' @param lifeCycle &#91;required&#93; The request to change the source server migration lifecycle state.
#' @param sourceServerID &#91;required&#93; The request to change the source server migration lifecycle state by
#' source server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   isArchived = TRUE|FALSE,
#'   launchedInstance = list(
#'     ec2InstanceID = "string",
#'     firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'     jobID = "string"
#'   ),
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastCutover = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string",
#'     lastTest = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'   ),
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$change_server_life_cycle_state(
#'   lifeCycle = list(
#'     state = "READY_FOR_TEST"|"READY_FOR_CUTOVER"|"CUTOVER"
#'   ),
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_change_server_life_cycle_state
mgn_change_server_life_cycle_state <- function(lifeCycle, sourceServerID) {
  op <- new_operation(
    name = "ChangeServerLifeCycleState",
    http_method = "POST",
    http_path = "/ChangeServerLifeCycleState",
    paginator = list()
  )
  input <- .mgn$change_server_life_cycle_state_input(lifeCycle = lifeCycle, sourceServerID = sourceServerID)
  output <- .mgn$change_server_life_cycle_state_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$change_server_life_cycle_state <- mgn_change_server_life_cycle_state

#' Creates a new ReplicationConfigurationTemplate
#'
#' @description
#' Creates a new ReplicationConfigurationTemplate.
#'
#' @usage
#' mgn_create_replication_configuration_template(
#'   associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP,
#'   dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption,
#'   ebsEncryptionKeyArn, replicationServerInstanceType,
#'   replicationServersSecurityGroupsIDs, stagingAreaSubnetId,
#'   stagingAreaTags, tags, useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup &#91;required&#93; Request to associate the default Application Migration Service Security
#' group with the Replication Settings template.
#' @param bandwidthThrottling &#91;required&#93; Request to configure bandwidth throttling during Replication Settings
#' template creation.
#' @param createPublicIP &#91;required&#93; Request to create Public IP during Replication Settings template
#' creation.
#' @param dataPlaneRouting &#91;required&#93; Request to configure data plane routing during Replication Settings
#' template creation.
#' @param defaultLargeStagingDiskType &#91;required&#93; Request to configure the Staging Disk EBS volume type to "gp2" during
#' Replication Settings template creation.
#' @param ebsEncryption &#91;required&#93; Request to configure EBS enryption during Replication Settings template
#' creation.
#' @param ebsEncryptionKeyArn Request to configure an EBS enryption key during Replication Settings
#' template creation.
#' @param replicationServerInstanceType &#91;required&#93; Request to configure the Replication Server instance type during
#' Replication Settings template creation.
#' @param replicationServersSecurityGroupsIDs &#91;required&#93; Request to configure the Replication Server Secuirity group ID during
#' Replication Settings template creation.
#' @param stagingAreaSubnetId &#91;required&#93; Request to configure the Staging Area subnet ID during Replication
#' Settings template creation.
#' @param stagingAreaTags &#91;required&#93; Request to configure Staiging Area tags during Replication Settings
#' template creation.
#' @param tags Request to configure tags during Replication Settings template creation.
#' @param useDedicatedReplicationServer &#91;required&#93; Request to use Dedicated Replication Servers during Replication Settings
#' template creation.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_replication_configuration_template(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_create_replication_configuration_template
mgn_create_replication_configuration_template <- function(associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP, dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn = NULL, replicationServerInstanceType, replicationServersSecurityGroupsIDs, stagingAreaSubnetId, stagingAreaTags, tags = NULL, useDedicatedReplicationServer) {
  op <- new_operation(
    name = "CreateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/CreateReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .mgn$create_replication_configuration_template_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, tags = tags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .mgn$create_replication_configuration_template_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$create_replication_configuration_template <- mgn_create_replication_configuration_template

#' Deletes a single Job by ID
#'
#' @description
#' Deletes a single Job by ID.
#'
#' @usage
#' mgn_delete_job(jobID)
#'
#' @param jobID &#91;required&#93; Request to delete Job from service by Job ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_job(
#'   jobID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_delete_job
mgn_delete_job <- function(jobID) {
  op <- new_operation(
    name = "DeleteJob",
    http_method = "POST",
    http_path = "/DeleteJob",
    paginator = list()
  )
  input <- .mgn$delete_job_input(jobID = jobID)
  output <- .mgn$delete_job_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$delete_job <- mgn_delete_job

#' Deletes a single Replication Configuration Template by ID
#'
#' @description
#' Deletes a single Replication Configuration Template by ID
#'
#' @usage
#' mgn_delete_replication_configuration_template(
#'   replicationConfigurationTemplateID)
#'
#' @param replicationConfigurationTemplateID &#91;required&#93; Request to delete Replication Configuration Template from service by
#' Replication Configuration Template ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_replication_configuration_template(
#'   replicationConfigurationTemplateID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_delete_replication_configuration_template
mgn_delete_replication_configuration_template <- function(replicationConfigurationTemplateID) {
  op <- new_operation(
    name = "DeleteReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/DeleteReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .mgn$delete_replication_configuration_template_input(replicationConfigurationTemplateID = replicationConfigurationTemplateID)
  output <- .mgn$delete_replication_configuration_template_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$delete_replication_configuration_template <- mgn_delete_replication_configuration_template

#' Deletes a single source server by ID
#'
#' @description
#' Deletes a single source server by ID.
#'
#' @usage
#' mgn_delete_source_server(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Request to delete Source Server from service by Server ID.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_source_server(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_delete_source_server
mgn_delete_source_server <- function(sourceServerID) {
  op <- new_operation(
    name = "DeleteSourceServer",
    http_method = "POST",
    http_path = "/DeleteSourceServer",
    paginator = list()
  )
  input <- .mgn$delete_source_server_input(sourceServerID = sourceServerID)
  output <- .mgn$delete_source_server_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$delete_source_server <- mgn_delete_source_server

#' Retrieves detailed Job log with paging
#'
#' @description
#' Retrieves detailed Job log with paging.
#'
#' @usage
#' mgn_describe_job_log_items(jobID, maxResults, nextToken)
#'
#' @param jobID &#91;required&#93; Request to describe Job log job ID.
#' @param maxResults Request to describe Job log item maximum results.
#' @param nextToken Request to describe Job log next token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       event = "JOB_START"|"SERVER_SKIPPED"|"CLEANUP_START"|"CLEANUP_END"|"CLEANUP_FAIL"|"SNAPSHOT_START"|"SNAPSHOT_END"|"SNAPSHOT_FAIL"|"USING_PREVIOUS_SNAPSHOT"|"CONVERSION_START"|"CONVERSION_END"|"CONVERSION_FAIL"|"LAUNCH_START"|"LAUNCH_FAILED"|"JOB_CANCEL"|"JOB_END",
#'       eventData = list(
#'         conversionServerID = "string",
#'         rawError = "string",
#'         sourceServerID = "string",
#'         targetInstanceID = "string"
#'       ),
#'       logDateTime = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_job_log_items(
#'   jobID = "string",
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_describe_job_log_items
mgn_describe_job_log_items <- function(jobID, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobLogItems",
    http_method = "POST",
    http_path = "/DescribeJobLogItems",
    paginator = list()
  )
  input <- .mgn$describe_job_log_items_input(jobID = jobID, maxResults = maxResults, nextToken = nextToken)
  output <- .mgn$describe_job_log_items_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$describe_job_log_items <- mgn_describe_job_log_items

#' Returns a list of Jobs
#'
#' @description
#' Returns a list of Jobs. Use the JobsID and fromDate and toData filters
#' to limit which jobs are returned. The response is sorted by
#' creationDataTime - latest date first. Jobs are normaly created by the
#' StartTest, StartCutover, and TerminateTargetInstances APIs. Jobs are
#' also created by DiagnosticLaunch and TerminateDiagnosticInstances, which
#' are APIs available only to *Support* and only used in response to
#' relevant support tickets.
#'
#' @usage
#' mgn_describe_jobs(filters, maxResults, nextToken)
#'
#' @param filters &#91;required&#93; Request to describe Job log filters.
#' @param maxResults Request to describe Job log by max results.
#' @param nextToken Request to describe Job logby next token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       creationDateTime = "string",
#'       endDateTime = "string",
#'       initiatedBy = "START_TEST"|"START_CUTOVER"|"DIAGNOSTIC"|"TERMINATE",
#'       jobID = "string",
#'       participatingServers = list(
#'         list(
#'           launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'           sourceServerID = "string"
#'         )
#'       ),
#'       status = "PENDING"|"STARTED"|"COMPLETED",
#'       tags = list(
#'         "string"
#'       ),
#'       type = "LAUNCH"|"TERMINATE"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_jobs(
#'   filters = list(
#'     fromDate = "string",
#'     jobIDs = list(
#'       "string"
#'     ),
#'     toDate = "string"
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_describe_jobs
mgn_describe_jobs <- function(filters, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeJobs",
    http_method = "POST",
    http_path = "/DescribeJobs",
    paginator = list()
  )
  input <- .mgn$describe_jobs_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .mgn$describe_jobs_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$describe_jobs <- mgn_describe_jobs

#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs
#'
#' @description
#' Lists all ReplicationConfigurationTemplates, filtered by Source Server
#' IDs.
#'
#' @usage
#' mgn_describe_replication_configuration_templates(maxResults, nextToken,
#'   replicationConfigurationTemplateIDs)
#'
#' @param maxResults Request to describe Replication Configuration template by max results.
#' @param nextToken Request to describe Replication Configuration template by next token.
#' @param replicationConfigurationTemplateIDs &#91;required&#93; Request to describe Replication Configuration template by template IDs.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       associateDefaultSecurityGroup = TRUE|FALSE,
#'       bandwidthThrottling = 123,
#'       createPublicIP = TRUE|FALSE,
#'       dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'       defaultLargeStagingDiskType = "GP2"|"ST1",
#'       ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'       ebsEncryptionKeyArn = "string",
#'       replicationConfigurationTemplateID = "string",
#'       replicationServerInstanceType = "string",
#'       replicationServersSecurityGroupsIDs = list(
#'         "string"
#'       ),
#'       stagingAreaSubnetId = "string",
#'       stagingAreaTags = list(
#'         "string"
#'       ),
#'       tags = list(
#'         "string"
#'       ),
#'       useDedicatedReplicationServer = TRUE|FALSE
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_replication_configuration_templates(
#'   maxResults = 123,
#'   nextToken = "string",
#'   replicationConfigurationTemplateIDs = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_describe_replication_configuration_templates
mgn_describe_replication_configuration_templates <- function(maxResults = NULL, nextToken = NULL, replicationConfigurationTemplateIDs) {
  op <- new_operation(
    name = "DescribeReplicationConfigurationTemplates",
    http_method = "POST",
    http_path = "/DescribeReplicationConfigurationTemplates",
    paginator = list()
  )
  input <- .mgn$describe_replication_configuration_templates_input(maxResults = maxResults, nextToken = nextToken, replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs)
  output <- .mgn$describe_replication_configuration_templates_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$describe_replication_configuration_templates <- mgn_describe_replication_configuration_templates

#' Retrieves all SourceServers or multiple SourceServers by ID
#'
#' @description
#' Retrieves all SourceServers or multiple SourceServers by ID.
#'
#' @usage
#' mgn_describe_source_servers(filters, maxResults, nextToken)
#'
#' @param filters &#91;required&#93; Request to filter Source Servers list.
#' @param maxResults Request to filter Source Servers list by maximum results.
#' @param nextToken Request to filter Source Servers list by next token.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   items = list(
#'     list(
#'       arn = "string",
#'       dataReplicationInfo = list(
#'         dataReplicationError = list(
#'           error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'           rawError = "string"
#'         ),
#'         dataReplicationInitiation = list(
#'           nextAttemptDateTime = "string",
#'           startDateTime = "string",
#'           steps = list(
#'             list(
#'               name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'               status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'             )
#'           )
#'         ),
#'         dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'         etaDateTime = "string",
#'         lagDuration = "string",
#'         replicatedDisks = list(
#'           list(
#'             backloggedStorageBytes = 123,
#'             deviceName = "string",
#'             replicatedStorageBytes = 123,
#'             rescannedStorageBytes = 123,
#'             totalStorageBytes = 123
#'           )
#'         )
#'       ),
#'       isArchived = TRUE|FALSE,
#'       launchedInstance = list(
#'         ec2InstanceID = "string",
#'         firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'         jobID = "string"
#'       ),
#'       lifeCycle = list(
#'         addedToServiceDateTime = "string",
#'         elapsedReplicationDuration = "string",
#'         firstByteDateTime = "string",
#'         lastCutover = list(
#'           finalized = list(
#'             apiCallDateTime = "string"
#'           ),
#'           initiated = list(
#'             apiCallDateTime = "string",
#'             jobID = "string"
#'           ),
#'           reverted = list(
#'             apiCallDateTime = "string"
#'           )
#'         ),
#'         lastSeenByServiceDateTime = "string",
#'         lastTest = list(
#'           finalized = list(
#'             apiCallDateTime = "string"
#'           ),
#'           initiated = list(
#'             apiCallDateTime = "string",
#'             jobID = "string"
#'           ),
#'           reverted = list(
#'             apiCallDateTime = "string"
#'           )
#'         ),
#'         state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'       ),
#'       sourceProperties = list(
#'         cpus = list(
#'           list(
#'             cores = 123,
#'             modelName = "string"
#'           )
#'         ),
#'         disks = list(
#'           list(
#'             bytes = 123,
#'             deviceName = "string"
#'           )
#'         ),
#'         identificationHints = list(
#'           awsInstanceID = "string",
#'           fqdn = "string",
#'           hostname = "string",
#'           vmWareUuid = "string"
#'         ),
#'         lastUpdatedDateTime = "string",
#'         networkInterfaces = list(
#'           list(
#'             ips = list(
#'               "string"
#'             ),
#'             isPrimary = TRUE|FALSE,
#'             macAddress = "string"
#'           )
#'         ),
#'         os = list(
#'           fullString = "string"
#'         ),
#'         ramBytes = 123,
#'         recommendedInstanceType = "string"
#'       ),
#'       sourceServerID = "string",
#'       tags = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$describe_source_servers(
#'   filters = list(
#'     isArchived = TRUE|FALSE,
#'     sourceServerIDs = list(
#'       "string"
#'     )
#'   ),
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_describe_source_servers
mgn_describe_source_servers <- function(filters, maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "DescribeSourceServers",
    http_method = "POST",
    http_path = "/DescribeSourceServers",
    paginator = list()
  )
  input <- .mgn$describe_source_servers_input(filters = filters, maxResults = maxResults, nextToken = nextToken)
  output <- .mgn$describe_source_servers_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$describe_source_servers <- mgn_describe_source_servers

#' Disconnects specific Source Servers from Application Migration Service
#'
#' @description
#' Disconnects specific Source Servers from Application Migration Service.
#' Data replication is stopped immediately. All AWS resources created by
#' Application Migration Service for enabling the replication of these
#' source servers will be terminated / deleted within 90 minutes. Launched
#' Test or Cutover instances will NOT be terminated. If the agent on the
#' source server has not been prevented from communciating with the
#' Application Migration Service service, then it will receive a command to
#' uninstall itself (within approximately 10 minutes). The following
#' properties of the SourceServer will be changed immediately:
#' dataReplicationInfo.dataReplicationState will be set to DISCONNECTED;
#' The totalStorageBytes property for each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDurationwill
#' be nullified.
#'
#' @usage
#' mgn_disconnect_from_service(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Request to disconnect Source Server from service by Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   isArchived = TRUE|FALSE,
#'   launchedInstance = list(
#'     ec2InstanceID = "string",
#'     firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'     jobID = "string"
#'   ),
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastCutover = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string",
#'     lastTest = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'   ),
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$disconnect_from_service(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_disconnect_from_service
mgn_disconnect_from_service <- function(sourceServerID) {
  op <- new_operation(
    name = "DisconnectFromService",
    http_method = "POST",
    http_path = "/DisconnectFromService",
    paginator = list()
  )
  input <- .mgn$disconnect_from_service_input(sourceServerID = sourceServerID)
  output <- .mgn$disconnect_from_service_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$disconnect_from_service <- mgn_disconnect_from_service

#' Finalizes the cutover immediately for specific Source Servers
#'
#' @description
#' Finalizes the cutover immediately for specific Source Servers. All AWS
#' resources created by Application Migration Service for enabling the
#' replication of these source servers will be terminated / deleted within
#' 90 minutes. Launched Test or Cutover instances will NOT be terminated.
#' The AWS Replication Agent will receive a command to uninstall itself
#' (within 10 minutes). The following properties of the SourceServer will
#' be changed immediately: dataReplicationInfo.dataReplicationState will be
#' to DISCONNECTED; The SourceServer.lifeCycle.state will be changed to
#' CUTOVER; The totalStorageBytes property fo each of
#' dataReplicationInfo.replicatedDisks will be set to zero;
#' dataReplicationInfo.lagDuration and dataReplicationInfo.lagDurationwill
#' be nullified.
#'
#' @usage
#' mgn_finalize_cutover(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Request to finalize Cutover by Soure Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   isArchived = TRUE|FALSE,
#'   launchedInstance = list(
#'     ec2InstanceID = "string",
#'     firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'     jobID = "string"
#'   ),
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastCutover = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string",
#'     lastTest = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'   ),
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$finalize_cutover(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_finalize_cutover
mgn_finalize_cutover <- function(sourceServerID) {
  op <- new_operation(
    name = "FinalizeCutover",
    http_method = "POST",
    http_path = "/FinalizeCutover",
    paginator = list()
  )
  input <- .mgn$finalize_cutover_input(sourceServerID = sourceServerID)
  output <- .mgn$finalize_cutover_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$finalize_cutover <- mgn_finalize_cutover

#' Lists all LaunchConfigurations available, filtered by Source Server IDs
#'
#' @description
#' Lists all LaunchConfigurations available, filtered by Source Server IDs.
#'
#' @usage
#' mgn_get_launch_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Request to get Launch Configuration information by Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_launch_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_get_launch_configuration
mgn_get_launch_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetLaunchConfiguration",
    http_method = "POST",
    http_path = "/GetLaunchConfiguration",
    paginator = list()
  )
  input <- .mgn$get_launch_configuration_input(sourceServerID = sourceServerID)
  output <- .mgn$get_launch_configuration_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$get_launch_configuration <- mgn_get_launch_configuration

#' Lists all ReplicationConfigurations, filtered by Source Server ID
#'
#' @description
#' Lists all ReplicationConfigurations, filtered by Source Server ID.
#'
#' @usage
#' mgn_get_replication_configuration(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Request to get Replication Configuaration by Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       stagingDiskType = "AUTO"|"GP2"|"IO1"|"SC1"|"ST1"|"STANDARD"
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_replication_configuration(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_get_replication_configuration
mgn_get_replication_configuration <- function(sourceServerID) {
  op <- new_operation(
    name = "GetReplicationConfiguration",
    http_method = "POST",
    http_path = "/GetReplicationConfiguration",
    paginator = list()
  )
  input <- .mgn$get_replication_configuration_input(sourceServerID = sourceServerID)
  output <- .mgn$get_replication_configuration_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$get_replication_configuration <- mgn_get_replication_configuration

#' Initialize Application Migration Service
#'
#' @description
#' Initialize Application Migration Service.
#'
#' @usage
#' mgn_initialize_service()
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$initialize_service()
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_initialize_service
mgn_initialize_service <- function() {
  op <- new_operation(
    name = "InitializeService",
    http_method = "POST",
    http_path = "/InitializeService",
    paginator = list()
  )
  input <- .mgn$initialize_service_input()
  output <- .mgn$initialize_service_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$initialize_service <- mgn_initialize_service

#' List all tags for your Application Migration Service resources
#'
#' @description
#' List all tags for your Application Migration Service resources.
#'
#' @usage
#' mgn_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; List tags for resource request by ARN.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_list_tags_for_resource
mgn_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .mgn$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .mgn$list_tags_for_resource_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$list_tags_for_resource <- mgn_list_tags_for_resource

#' Archives specific Source Servers by setting the SourceServer
#'
#' @description
#' Archives specific Source Servers by setting the SourceServer.isArchived
#' property to true for specified SourceServers by ID. This command only
#' works for SourceServers with a lifecycle.state which equals DISCONNECTED
#' or CUTOVER.
#'
#' @usage
#' mgn_mark_as_archived(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Mark as archived by Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   isArchived = TRUE|FALSE,
#'   launchedInstance = list(
#'     ec2InstanceID = "string",
#'     firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'     jobID = "string"
#'   ),
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastCutover = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string",
#'     lastTest = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'   ),
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$mark_as_archived(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_mark_as_archived
mgn_mark_as_archived <- function(sourceServerID) {
  op <- new_operation(
    name = "MarkAsArchived",
    http_method = "POST",
    http_path = "/MarkAsArchived",
    paginator = list()
  )
  input <- .mgn$mark_as_archived_input(sourceServerID = sourceServerID)
  output <- .mgn$mark_as_archived_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$mark_as_archived <- mgn_mark_as_archived

#' Causes the data replication initiation sequence to begin immediately
#' upon next Handshake for specified SourceServer IDs, regardless of when
#' the previous initiation started
#'
#' @description
#' Causes the data replication initiation sequence to begin immediately
#' upon next Handshake for specified SourceServer IDs, regardless of when
#' the previous initiation started. This command will not work if the
#' SourceServer is not stalled or is in a DISCONNECTED or STOPPED state.
#'
#' @usage
#' mgn_retry_data_replication(sourceServerID)
#'
#' @param sourceServerID &#91;required&#93; Retry data replication for Source Server ID.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   dataReplicationInfo = list(
#'     dataReplicationError = list(
#'       error = "AGENT_NOT_SEEN"|"SNAPSHOTS_FAILURE"|"NOT_CONVERGING"|"UNSTABLE_NETWORK"|"FAILED_TO_CREATE_SECURITY_GROUP"|"FAILED_TO_LAUNCH_REPLICATION_SERVER"|"FAILED_TO_BOOT_REPLICATION_SERVER"|"FAILED_TO_AUTHENTICATE_WITH_SERVICE"|"FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"|"FAILED_TO_CREATE_STAGING_DISKS"|"FAILED_TO_ATTACH_STAGING_DISKS"|"FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"|"FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"|"FAILED_TO_START_DATA_TRANSFER",
#'       rawError = "string"
#'     ),
#'     dataReplicationInitiation = list(
#'       nextAttemptDateTime = "string",
#'       startDateTime = "string",
#'       steps = list(
#'         list(
#'           name = "WAIT"|"CREATE_SECURITY_GROUP"|"LAUNCH_REPLICATION_SERVER"|"BOOT_REPLICATION_SERVER"|"AUTHENTICATE_WITH_SERVICE"|"DOWNLOAD_REPLICATION_SOFTWARE"|"CREATE_STAGING_DISKS"|"ATTACH_STAGING_DISKS"|"PAIR_REPLICATION_SERVER_WITH_AGENT"|"CONNECT_AGENT_TO_REPLICATION_SERVER"|"START_DATA_TRANSFER",
#'           status = "NOT_STARTED"|"IN_PROGRESS"|"SUCCEEDED"|"FAILED"|"SKIPPED"
#'         )
#'       )
#'     ),
#'     dataReplicationState = "STOPPED"|"INITIATING"|"INITIAL_SYNC"|"BACKLOG"|"CREATING_SNAPSHOT"|"CONTINUOUS"|"PAUSED"|"RESCAN"|"STALLED"|"DISCONNECTED",
#'     etaDateTime = "string",
#'     lagDuration = "string",
#'     replicatedDisks = list(
#'       list(
#'         backloggedStorageBytes = 123,
#'         deviceName = "string",
#'         replicatedStorageBytes = 123,
#'         rescannedStorageBytes = 123,
#'         totalStorageBytes = 123
#'       )
#'     )
#'   ),
#'   isArchived = TRUE|FALSE,
#'   launchedInstance = list(
#'     ec2InstanceID = "string",
#'     firstBoot = "WAITING"|"SUCCEEDED"|"UNKNOWN"|"STOPPED",
#'     jobID = "string"
#'   ),
#'   lifeCycle = list(
#'     addedToServiceDateTime = "string",
#'     elapsedReplicationDuration = "string",
#'     firstByteDateTime = "string",
#'     lastCutover = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     lastSeenByServiceDateTime = "string",
#'     lastTest = list(
#'       finalized = list(
#'         apiCallDateTime = "string"
#'       ),
#'       initiated = list(
#'         apiCallDateTime = "string",
#'         jobID = "string"
#'       ),
#'       reverted = list(
#'         apiCallDateTime = "string"
#'       )
#'     ),
#'     state = "STOPPED"|"NOT_READY"|"READY_FOR_TEST"|"TESTING"|"READY_FOR_CUTOVER"|"CUTTING_OVER"|"CUTOVER"|"DISCONNECTED"
#'   ),
#'   sourceProperties = list(
#'     cpus = list(
#'       list(
#'         cores = 123,
#'         modelName = "string"
#'       )
#'     ),
#'     disks = list(
#'       list(
#'         bytes = 123,
#'         deviceName = "string"
#'       )
#'     ),
#'     identificationHints = list(
#'       awsInstanceID = "string",
#'       fqdn = "string",
#'       hostname = "string",
#'       vmWareUuid = "string"
#'     ),
#'     lastUpdatedDateTime = "string",
#'     networkInterfaces = list(
#'       list(
#'         ips = list(
#'           "string"
#'         ),
#'         isPrimary = TRUE|FALSE,
#'         macAddress = "string"
#'       )
#'     ),
#'     os = list(
#'       fullString = "string"
#'     ),
#'     ramBytes = 123,
#'     recommendedInstanceType = "string"
#'   ),
#'   sourceServerID = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retry_data_replication(
#'   sourceServerID = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_retry_data_replication
mgn_retry_data_replication <- function(sourceServerID) {
  op <- new_operation(
    name = "RetryDataReplication",
    http_method = "POST",
    http_path = "/RetryDataReplication",
    paginator = list()
  )
  input <- .mgn$retry_data_replication_input(sourceServerID = sourceServerID)
  output <- .mgn$retry_data_replication_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$retry_data_replication <- mgn_retry_data_replication

#' Launches a Cutover Instance for specific Source Servers
#'
#' @description
#' Launches a Cutover Instance for specific Source Servers. This command
#' starts a LAUNCH job whose initiatedBy property is StartCutover and
#' changes the SourceServer.lifeCycle.state property to CUTTING_OVER.
#'
#' @usage
#' mgn_start_cutover(sourceServerIDs, tags)
#'
#' @param sourceServerIDs &#91;required&#93; Start Cutover by Source Server IDs.
#' @param tags Start Cutover by Tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_TEST"|"START_CUTOVER"|"DIAGNOSTIC"|"TERMINATE",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_cutover(
#'   sourceServerIDs = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_start_cutover
mgn_start_cutover <- function(sourceServerIDs, tags = NULL) {
  op <- new_operation(
    name = "StartCutover",
    http_method = "POST",
    http_path = "/StartCutover",
    paginator = list()
  )
  input <- .mgn$start_cutover_input(sourceServerIDs = sourceServerIDs, tags = tags)
  output <- .mgn$start_cutover_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$start_cutover <- mgn_start_cutover

#' Lauches a Test Instance for specific Source Servers
#'
#' @description
#' Lauches a Test Instance for specific Source Servers. This command starts
#' a LAUNCH job whose initiatedBy property is StartTest and changes the
#' SourceServer.lifeCycle.state property to TESTING.
#'
#' @usage
#' mgn_start_test(sourceServerIDs, tags)
#'
#' @param sourceServerIDs &#91;required&#93; Start Test for Source Server IDs.
#' @param tags Start Test by Tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_TEST"|"START_CUTOVER"|"DIAGNOSTIC"|"TERMINATE",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$start_test(
#'   sourceServerIDs = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_start_test
mgn_start_test <- function(sourceServerIDs, tags = NULL) {
  op <- new_operation(
    name = "StartTest",
    http_method = "POST",
    http_path = "/StartTest",
    paginator = list()
  )
  input <- .mgn$start_test_input(sourceServerIDs = sourceServerIDs, tags = tags)
  output <- .mgn$start_test_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$start_test <- mgn_start_test

#' Adds or overwrites only the specified tags for the specified Application
#' Migration Service resource or resources
#'
#' @description
#' Adds or overwrites only the specified tags for the specified Application
#' Migration Service resource or resources. When you specify an existing
#' tag key, the value is overwritten with the new value. Each resource can
#' have a maximum of 50 tags. Each tag consists of a key and optional
#' value.
#'
#' @usage
#' mgn_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; Tag resource by ARN.
#' @param tags &#91;required&#93; Tag resource by Tags.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_tag_resource
mgn_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .mgn$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .mgn$tag_resource_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$tag_resource <- mgn_tag_resource

#' Starts a job that terminates specific launched EC2 Test and Cutover
#' instances
#'
#' @description
#' Starts a job that terminates specific launched EC2 Test and Cutover
#' instances. This command will not work for any Source Server with a
#' lifecycle.state of TESTING, CUTTING_OVER, or CUTOVER.
#'
#' @usage
#' mgn_terminate_target_instances(sourceServerIDs, tags)
#'
#' @param sourceServerIDs &#91;required&#93; Terminate Target instance by Source Server IDs.
#' @param tags Terminate Target instance by Tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   job = list(
#'     arn = "string",
#'     creationDateTime = "string",
#'     endDateTime = "string",
#'     initiatedBy = "START_TEST"|"START_CUTOVER"|"DIAGNOSTIC"|"TERMINATE",
#'     jobID = "string",
#'     participatingServers = list(
#'       list(
#'         launchStatus = "PENDING"|"IN_PROGRESS"|"LAUNCHED"|"FAILED"|"TERMINATED",
#'         sourceServerID = "string"
#'       )
#'     ),
#'     status = "PENDING"|"STARTED"|"COMPLETED",
#'     tags = list(
#'       "string"
#'     ),
#'     type = "LAUNCH"|"TERMINATE"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$terminate_target_instances(
#'   sourceServerIDs = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_terminate_target_instances
mgn_terminate_target_instances <- function(sourceServerIDs, tags = NULL) {
  op <- new_operation(
    name = "TerminateTargetInstances",
    http_method = "POST",
    http_path = "/TerminateTargetInstances",
    paginator = list()
  )
  input <- .mgn$terminate_target_instances_input(sourceServerIDs = sourceServerIDs, tags = tags)
  output <- .mgn$terminate_target_instances_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$terminate_target_instances <- mgn_terminate_target_instances

#' Deletes the specified set of tags from the specified set of Application
#' Migration Service resources
#'
#' @description
#' Deletes the specified set of tags from the specified set of Application
#' Migration Service resources.
#'
#' @usage
#' mgn_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; Untag resource by ARN.
#' @param tagKeys &#91;required&#93; Untag resource by Keys.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_untag_resource
mgn_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    paginator = list()
  )
  input <- .mgn$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .mgn$untag_resource_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$untag_resource <- mgn_untag_resource

#' Updates multiple LaunchConfigurations by Source Server ID
#'
#' @description
#' Updates multiple LaunchConfigurations by Source Server ID.
#'
#' @usage
#' mgn_update_launch_configuration(copyPrivateIp, copyTags,
#'   launchDisposition, licensing, name, sourceServerID,
#'   targetInstanceTypeRightSizingMethod)
#'
#' @param copyPrivateIp Update Launch configuration copy Private IP request.
#' @param copyTags Update Launch configuration copy Tags request.
#' @param launchDisposition Update Launch configuration launch disposition request.
#' @param licensing Update Launch configuration licensing request.
#' @param name Update Launch configuration name request.
#' @param sourceServerID &#91;required&#93; Update Launch configuration by Source Server ID request.
#' @param targetInstanceTypeRightSizingMethod Update Launch configuration Target instance right sizing request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   ec2LaunchTemplateID = "string",
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_launch_configuration(
#'   copyPrivateIp = TRUE|FALSE,
#'   copyTags = TRUE|FALSE,
#'   launchDisposition = "STOPPED"|"STARTED",
#'   licensing = list(
#'     osByol = TRUE|FALSE
#'   ),
#'   name = "string",
#'   sourceServerID = "string",
#'   targetInstanceTypeRightSizingMethod = "NONE"|"BASIC"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_update_launch_configuration
mgn_update_launch_configuration <- function(copyPrivateIp = NULL, copyTags = NULL, launchDisposition = NULL, licensing = NULL, name = NULL, sourceServerID, targetInstanceTypeRightSizingMethod = NULL) {
  op <- new_operation(
    name = "UpdateLaunchConfiguration",
    http_method = "POST",
    http_path = "/UpdateLaunchConfiguration",
    paginator = list()
  )
  input <- .mgn$update_launch_configuration_input(copyPrivateIp = copyPrivateIp, copyTags = copyTags, launchDisposition = launchDisposition, licensing = licensing, name = name, sourceServerID = sourceServerID, targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod)
  output <- .mgn$update_launch_configuration_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$update_launch_configuration <- mgn_update_launch_configuration

#' Allows you to update multiple ReplicationConfigurations by Source Server
#' ID
#'
#' @description
#' Allows you to update multiple ReplicationConfigurations by Source Server
#' ID.
#'
#' @usage
#' mgn_update_replication_configuration(associateDefaultSecurityGroup,
#'   bandwidthThrottling, createPublicIP, dataPlaneRouting,
#'   defaultLargeStagingDiskType, ebsEncryption, ebsEncryptionKeyArn, name,
#'   replicatedDisks, replicationServerInstanceType,
#'   replicationServersSecurityGroupsIDs, sourceServerID,
#'   stagingAreaSubnetId, stagingAreaTags, useDedicatedReplicationServer)
#'
#' @param associateDefaultSecurityGroup Update replication configuration associate default Application Migration
#' Service Security group request.
#' @param bandwidthThrottling Update replication configuration bandwidth throttling request.
#' @param createPublicIP Update replication configuration create Public IP request.
#' @param dataPlaneRouting Update replication configuration data plane routing request.
#' @param defaultLargeStagingDiskType Update replication configuration use default large Staging Disk type
#' request.
#' @param ebsEncryption Update replication configuration EBS encryption request.
#' @param ebsEncryptionKeyArn Update replication configuration EBS encryption key ARN request.
#' @param name Update replication configuration name request.
#' @param replicatedDisks Update replication configuration replicated disks request.
#' @param replicationServerInstanceType Update replication configuration Replication Server instance type
#' request.
#' @param replicationServersSecurityGroupsIDs Update replication configuration Replication Server Security Groups IDs
#' request.
#' @param sourceServerID &#91;required&#93; Update replication configuration Source Server ID request.
#' @param stagingAreaSubnetId Update replication configuration Staging Area subnet request.
#' @param stagingAreaTags Update replication configuration Staging Area Tags request.
#' @param useDedicatedReplicationServer Update replication configuration use dedicated Replication Server
#' request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       stagingDiskType = "AUTO"|"GP2"|"IO1"|"SC1"|"ST1"|"STANDARD"
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration(
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   name = "string",
#'   replicatedDisks = list(
#'     list(
#'       deviceName = "string",
#'       iops = 123,
#'       isBootDisk = TRUE|FALSE,
#'       stagingDiskType = "AUTO"|"GP2"|"IO1"|"SC1"|"ST1"|"STANDARD"
#'     )
#'   ),
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   sourceServerID = "string",
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_update_replication_configuration
mgn_update_replication_configuration <- function(associateDefaultSecurityGroup = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, name = NULL, replicatedDisks = NULL, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, sourceServerID, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfiguration",
    http_method = "POST",
    http_path = "/UpdateReplicationConfiguration",
    paginator = list()
  )
  input <- .mgn$update_replication_configuration_input(associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, name = name, replicatedDisks = replicatedDisks, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, sourceServerID = sourceServerID, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .mgn$update_replication_configuration_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$update_replication_configuration <- mgn_update_replication_configuration

#' Updates multiple ReplicationConfigurationTemplates by ID
#'
#' @description
#' Updates multiple ReplicationConfigurationTemplates by ID.
#'
#' @usage
#' mgn_update_replication_configuration_template(arn,
#'   associateDefaultSecurityGroup, bandwidthThrottling, createPublicIP,
#'   dataPlaneRouting, defaultLargeStagingDiskType, ebsEncryption,
#'   ebsEncryptionKeyArn, replicationConfigurationTemplateID,
#'   replicationServerInstanceType, replicationServersSecurityGroupsIDs,
#'   stagingAreaSubnetId, stagingAreaTags, useDedicatedReplicationServer)
#'
#' @param arn Update replication configuration template ARN request.
#' @param associateDefaultSecurityGroup Update replication configuration template associate default Application
#' Migration Service Security group request.
#' @param bandwidthThrottling Update replication configuration template bandwidth throttling request.
#' @param createPublicIP Update replication configuration template create Public IP request.
#' @param dataPlaneRouting Update replication configuration template data plane routing request.
#' @param defaultLargeStagingDiskType Update replication configuration template use default large Staging Disk
#' type request.
#' @param ebsEncryption Update replication configuration template EBS encryption request.
#' @param ebsEncryptionKeyArn Update replication configuration template EBS encryption key ARN
#' request.
#' @param replicationConfigurationTemplateID &#91;required&#93; Update replication configuration template template ID request.
#' @param replicationServerInstanceType Update replication configuration template Replication Server instance
#' type request.
#' @param replicationServersSecurityGroupsIDs Update replication configuration template Replication Server Security
#' groups IDs request.
#' @param stagingAreaSubnetId Update replication configuration template Staging Area subnet ID
#' request.
#' @param stagingAreaTags Update replication configuration template Staging Area Tags request.
#' @param useDedicatedReplicationServer Update replication configuration template use dedicated Replication
#' Server request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_replication_configuration_template(
#'   arn = "string",
#'   associateDefaultSecurityGroup = TRUE|FALSE,
#'   bandwidthThrottling = 123,
#'   createPublicIP = TRUE|FALSE,
#'   dataPlaneRouting = "PRIVATE_IP"|"PUBLIC_IP",
#'   defaultLargeStagingDiskType = "GP2"|"ST1",
#'   ebsEncryption = "NONE"|"DEFAULT"|"CUSTOM",
#'   ebsEncryptionKeyArn = "string",
#'   replicationConfigurationTemplateID = "string",
#'   replicationServerInstanceType = "string",
#'   replicationServersSecurityGroupsIDs = list(
#'     "string"
#'   ),
#'   stagingAreaSubnetId = "string",
#'   stagingAreaTags = list(
#'     "string"
#'   ),
#'   useDedicatedReplicationServer = TRUE|FALSE
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname mgn_update_replication_configuration_template
mgn_update_replication_configuration_template <- function(arn = NULL, associateDefaultSecurityGroup = NULL, bandwidthThrottling = NULL, createPublicIP = NULL, dataPlaneRouting = NULL, defaultLargeStagingDiskType = NULL, ebsEncryption = NULL, ebsEncryptionKeyArn = NULL, replicationConfigurationTemplateID, replicationServerInstanceType = NULL, replicationServersSecurityGroupsIDs = NULL, stagingAreaSubnetId = NULL, stagingAreaTags = NULL, useDedicatedReplicationServer = NULL) {
  op <- new_operation(
    name = "UpdateReplicationConfigurationTemplate",
    http_method = "POST",
    http_path = "/UpdateReplicationConfigurationTemplate",
    paginator = list()
  )
  input <- .mgn$update_replication_configuration_template_input(arn = arn, associateDefaultSecurityGroup = associateDefaultSecurityGroup, bandwidthThrottling = bandwidthThrottling, createPublicIP = createPublicIP, dataPlaneRouting = dataPlaneRouting, defaultLargeStagingDiskType = defaultLargeStagingDiskType, ebsEncryption = ebsEncryption, ebsEncryptionKeyArn = ebsEncryptionKeyArn, replicationConfigurationTemplateID = replicationConfigurationTemplateID, replicationServerInstanceType = replicationServerInstanceType, replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs, stagingAreaSubnetId = stagingAreaSubnetId, stagingAreaTags = stagingAreaTags, useDedicatedReplicationServer = useDedicatedReplicationServer)
  output <- .mgn$update_replication_configuration_template_output()
  config <- get_config()
  svc <- .mgn$service(config)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.mgn$operations$update_replication_configuration_template <- mgn_update_replication_configuration_template

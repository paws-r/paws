# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common get_config new_operation new_request send_request
#' @include bedrockagentruntime_service.R
NULL

#' Creates a new invocation within a session
#'
#' @description
#' Creates a new invocation within a session. An invocation groups the
#' related invocation steps that store the content from a conversation. For
#' more information about sessions, see [Store and retrieve conversation
#' history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#' 
#' Related APIs
#' 
#' -   [`list_invocations`][bedrockagentruntime_list_invocations]
#' 
#' -   [`list_sessions`][bedrockagentruntime_list_sessions]
#' 
#' -   [`get_session`][bedrockagentruntime_get_session]
#'
#' @usage
#' bedrockagentruntime_create_invocation(description, invocationId,
#'   sessionIdentifier)
#'
#' @param description A description for the interactions in the invocation. For example, "User
#' asking about weather in Seattle".
#' @param invocationId A unique identifier for the invocation in UUID format.
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the associated session for the invocation. You
#' can specify either the session's `sessionId` or its Amazon Resource Name
#' (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   invocationId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_invocation(
#'   description = "string",
#'   invocationId = "string",
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_create_invocation
#'
#' @aliases bedrockagentruntime_create_invocation
bedrockagentruntime_create_invocation <- function(description = NULL, invocationId = NULL, sessionIdentifier) {
  op <- new_operation(
    name = "CreateInvocation",
    http_method = "PUT",
    http_path = "/sessions/{sessionIdentifier}/invocations/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$create_invocation_input(description = description, invocationId = invocationId, sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$create_invocation_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$create_invocation <- bedrockagentruntime_create_invocation

#' Creates a session to temporarily store conversations for generative AI
#' (GenAI) applications built with open-source frameworks such as LangGraph
#' and LlamaIndex
#'
#' @description
#' Creates a session to temporarily store conversations for generative AI
#' (GenAI) applications built with open-source frameworks such as LangGraph
#' and LlamaIndex. Sessions enable you to save the state of conversations
#' at checkpoints, with the added security and infrastructure of Amazon Web
#' Services. For more information, see [Store and retrieve conversation
#' history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#' 
#' By default, Amazon Bedrock uses Amazon Web Services-managed keys for
#' session encryption, including session metadata, or you can use your own
#' KMS key. For more information, see [Amazon Bedrock session
#' encryption](https://docs.aws.amazon.com/bedrock/latest/userguide/).
#' 
#' You use a session to store state and conversation history for generative
#' AI applications built with open-source frameworks. For Amazon Bedrock
#' Agents, the service automatically manages conversation context and
#' associates them with the agent-specific sessionId you specify in the
#' [`invoke_agent`][bedrockagentruntime_invoke_agent] API operation.
#' 
#' Related APIs:
#' 
#' -   [`list_sessions`][bedrockagentruntime_list_sessions]
#' 
#' -   [`get_session`][bedrockagentruntime_get_session]
#' 
#' -   [`end_session`][bedrockagentruntime_end_session]
#' 
#' -   [`delete_session`][bedrockagentruntime_delete_session]
#'
#' @usage
#' bedrockagentruntime_create_session(encryptionKeyArn, sessionMetadata,
#'   tags)
#'
#' @param encryptionKeyArn The Amazon Resource Name (ARN) of the KMS key to use to encrypt the
#' session data. The user or role creating the session must have permission
#' to use the key. For more information, see [Amazon Bedrock session
#' encryption](https://docs.aws.amazon.com/bedrock/latest/userguide/).
#' @param sessionMetadata A map of key-value pairs containing attributes to be persisted across
#' the session. For example, the user's ID, their language preference, and
#' the type of device they are using.
#' @param tags Specify the key-value pairs for the tags that you want to attach to the
#' session.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sessionArn = "string",
#'   sessionId = "string",
#'   sessionStatus = "ACTIVE"|"EXPIRED"|"ENDED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$create_session(
#'   encryptionKeyArn = "string",
#'   sessionMetadata = list(
#'     "string"
#'   ),
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_create_session
#'
#' @aliases bedrockagentruntime_create_session
bedrockagentruntime_create_session <- function(encryptionKeyArn = NULL, sessionMetadata = NULL, tags = NULL) {
  op <- new_operation(
    name = "CreateSession",
    http_method = "PUT",
    http_path = "/sessions/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$create_session_input(encryptionKeyArn = encryptionKeyArn, sessionMetadata = sessionMetadata, tags = tags)
  output <- .bedrockagentruntime$create_session_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$create_session <- bedrockagentruntime_create_session

#' Deletes memory from the specified memory identifier
#'
#' @description
#' Deletes memory from the specified memory identifier.
#'
#' @usage
#' bedrockagentruntime_delete_agent_memory(agentAliasId, agentId, memoryId,
#'   sessionId)
#'
#' @param agentAliasId &#91;required&#93; The unique identifier of an alias of an agent.
#' @param agentId &#91;required&#93; The unique identifier of the agent to which the alias belongs.
#' @param memoryId The unique identifier of the memory.
#' @param sessionId The unique session identifier of the memory.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_agent_memory(
#'   agentAliasId = "string",
#'   agentId = "string",
#'   memoryId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_delete_agent_memory
#'
#' @aliases bedrockagentruntime_delete_agent_memory
bedrockagentruntime_delete_agent_memory <- function(agentAliasId, agentId, memoryId = NULL, sessionId = NULL) {
  op <- new_operation(
    name = "DeleteAgentMemory",
    http_method = "DELETE",
    http_path = "/agents/{agentId}/agentAliases/{agentAliasId}/memories",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$delete_agent_memory_input(agentAliasId = agentAliasId, agentId = agentId, memoryId = memoryId, sessionId = sessionId)
  output <- .bedrockagentruntime$delete_agent_memory_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$delete_agent_memory <- bedrockagentruntime_delete_agent_memory

#' Deletes a session that you ended
#'
#' @description
#' Deletes a session that you ended. You can't delete a session with an
#' `ACTIVE` status. To delete an active session, you must first end it with
#' the [`end_session`][bedrockagentruntime_end_session] API operation. For
#' more information about sessions, see [Store and retrieve conversation
#' history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_delete_session(sessionIdentifier)
#'
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the session to be deleted. You can specify
#' either the session's `sessionId` or its Amazon Resource Name (ARN).
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$delete_session(
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_delete_session
#'
#' @aliases bedrockagentruntime_delete_session
bedrockagentruntime_delete_session <- function(sessionIdentifier) {
  op <- new_operation(
    name = "DeleteSession",
    http_method = "DELETE",
    http_path = "/sessions/{sessionIdentifier}/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$delete_session_input(sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$delete_session_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$delete_session <- bedrockagentruntime_delete_session

#' Ends the session
#'
#' @description
#' Ends the session. After you end a session, you can still access its
#' content but you canâ€™t add to it. To delete the session and it's content,
#' you use the DeleteSession API operation. For more information about
#' sessions, see [Store and retrieve conversation history and context with
#' Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_end_session(sessionIdentifier)
#'
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the session to end. You can specify either the
#' session's `sessionId` or its Amazon Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sessionArn = "string",
#'   sessionId = "string",
#'   sessionStatus = "ACTIVE"|"EXPIRED"|"ENDED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$end_session(
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_end_session
#'
#' @aliases bedrockagentruntime_end_session
bedrockagentruntime_end_session <- function(sessionIdentifier) {
  op <- new_operation(
    name = "EndSession",
    http_method = "PATCH",
    http_path = "/sessions/{sessionIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$end_session_input(sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$end_session_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$end_session <- bedrockagentruntime_end_session

#' Generates an SQL query from a natural language query
#'
#' @description
#' Generates an SQL query from a natural language query. For more
#' information, see [Generate a query for structured
#' data](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-generate-query.html)
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrockagentruntime_generate_query(queryGenerationInput,
#'   transformationConfiguration)
#'
#' @param queryGenerationInput &#91;required&#93; Specifies information about a natural language query to transform into
#' SQL.
#' @param transformationConfiguration &#91;required&#93; Specifies configurations for transforming the natural language query
#' into SQL.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   queries = list(
#'     list(
#'       sql = "string",
#'       type = "REDSHIFT_SQL"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$generate_query(
#'   queryGenerationInput = list(
#'     text = "string",
#'     type = "TEXT"
#'   ),
#'   transformationConfiguration = list(
#'     mode = "TEXT_TO_SQL",
#'     textToSqlConfiguration = list(
#'       knowledgeBaseConfiguration = list(
#'         knowledgeBaseArn = "string"
#'       ),
#'       type = "KNOWLEDGE_BASE"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_generate_query
#'
#' @aliases bedrockagentruntime_generate_query
bedrockagentruntime_generate_query <- function(queryGenerationInput, transformationConfiguration) {
  op <- new_operation(
    name = "GenerateQuery",
    http_method = "POST",
    http_path = "/generateQuery",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$generate_query_input(queryGenerationInput = queryGenerationInput, transformationConfiguration = transformationConfiguration)
  output <- .bedrockagentruntime$generate_query_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$generate_query <- bedrockagentruntime_generate_query

#' Gets the sessions stored in the memory of the agent
#'
#' @description
#' Gets the sessions stored in the memory of the agent.
#'
#' @usage
#' bedrockagentruntime_get_agent_memory(agentAliasId, agentId, maxItems,
#'   memoryId, memoryType, nextToken)
#'
#' @param agentAliasId &#91;required&#93; The unique identifier of an alias of an agent.
#' @param agentId &#91;required&#93; The unique identifier of the agent to which the alias belongs.
#' @param maxItems The maximum number of items to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param memoryId &#91;required&#93; The unique identifier of the memory.
#' @param memoryType &#91;required&#93; The type of memory.
#' @param nextToken If the total number of results is greater than the maxItems value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   memoryContents = list(
#'     list(
#'       sessionSummary = list(
#'         memoryId = "string",
#'         sessionExpiryTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         sessionId = "string",
#'         sessionStartTime = as.POSIXct(
#'           "2015-01-01"
#'         ),
#'         summaryText = "string"
#'       )
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_agent_memory(
#'   agentAliasId = "string",
#'   agentId = "string",
#'   maxItems = 123,
#'   memoryId = "string",
#'   memoryType = "SESSION_SUMMARY",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_get_agent_memory
#'
#' @aliases bedrockagentruntime_get_agent_memory
bedrockagentruntime_get_agent_memory <- function(agentAliasId, agentId, maxItems = NULL, memoryId, memoryType, nextToken = NULL) {
  op <- new_operation(
    name = "GetAgentMemory",
    http_method = "GET",
    http_path = "/agents/{agentId}/agentAliases/{agentAliasId}/memories",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxItems", result_key = "memoryContents"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$get_agent_memory_input(agentAliasId = agentAliasId, agentId = agentId, maxItems = maxItems, memoryId = memoryId, memoryType = memoryType, nextToken = nextToken)
  output <- .bedrockagentruntime$get_agent_memory_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$get_agent_memory <- bedrockagentruntime_get_agent_memory

#' Retrieves the details of a specific invocation step within an invocation
#' in a session
#'
#' @description
#' Retrieves the details of a specific invocation step within an invocation
#' in a session. For more information about sessions, see [Store and
#' retrieve conversation history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_get_invocation_step(invocationIdentifier,
#'   invocationStepId, sessionIdentifier)
#'
#' @param invocationIdentifier &#91;required&#93; The unique identifier for the invocation in UUID format.
#' @param invocationStepId &#91;required&#93; The unique identifier (in UUID format) for the specific invocation step
#' to retrieve.
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the invocation step's associated session. You
#' can specify either the session's `sessionId` or its Amazon Resource Name
#' (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   invocationStep = list(
#'     invocationId = "string",
#'     invocationStepId = "string",
#'     invocationStepTime = as.POSIXct(
#'       "2015-01-01"
#'     ),
#'     payload = list(
#'       contentBlocks = list(
#'         list(
#'           image = list(
#'             format = "png"|"jpeg"|"gif"|"webp",
#'             source = list(
#'               bytes = raw,
#'               s3Location = list(
#'                 uri = "string"
#'               )
#'             )
#'           ),
#'           text = "string"
#'         )
#'       )
#'     ),
#'     sessionId = "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_invocation_step(
#'   invocationIdentifier = "string",
#'   invocationStepId = "string",
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_get_invocation_step
#'
#' @aliases bedrockagentruntime_get_invocation_step
bedrockagentruntime_get_invocation_step <- function(invocationIdentifier, invocationStepId, sessionIdentifier) {
  op <- new_operation(
    name = "GetInvocationStep",
    http_method = "POST",
    http_path = "/sessions/{sessionIdentifier}/invocationSteps/{invocationStepId}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$get_invocation_step_input(invocationIdentifier = invocationIdentifier, invocationStepId = invocationStepId, sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$get_invocation_step_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$get_invocation_step <- bedrockagentruntime_get_invocation_step

#' Retrieves details about a specific session
#'
#' @description
#' Retrieves details about a specific session. For more information about
#' sessions, see [Store and retrieve conversation history and context with
#' Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_get_session(sessionIdentifier)
#'
#' @param sessionIdentifier &#91;required&#93; A unique identifier for the session to retrieve. You can specify either
#' the session's `sessionId` or its Amazon Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   encryptionKeyArn = "string",
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sessionArn = "string",
#'   sessionId = "string",
#'   sessionMetadata = list(
#'     "string"
#'   ),
#'   sessionStatus = "ACTIVE"|"EXPIRED"|"ENDED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$get_session(
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_get_session
#'
#' @aliases bedrockagentruntime_get_session
bedrockagentruntime_get_session <- function(sessionIdentifier) {
  op <- new_operation(
    name = "GetSession",
    http_method = "GET",
    http_path = "/sessions/{sessionIdentifier}/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$get_session_input(sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$get_session_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$get_session <- bedrockagentruntime_get_session

#' Sends a prompt for the agent to process and respond to
#'
#' @description
#' Sends a prompt for the agent to process and respond to. Note the
#' following fields for the request:
#' 
#' -   To continue the same conversation with an agent, use the same
#'     `sessionId` value in the request.
#' 
#' -   To activate trace enablement, turn `enableTrace` to `true`. Trace
#'     enablement helps you follow the agent's reasoning process that led
#'     it to the information it processed, the actions it took, and the
#'     final result it yielded. For more information, see [Trace
#'     enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-events).
#' 
#' -   End a conversation by setting `endSession` to `true`.
#' 
#' -   In the `sessionState` object, you can include attributes for the
#'     session or prompt or, if you configured an action group to return
#'     control, results from invocation of the action group.
#' 
#' The response contains both **chunk** and **trace** attributes.
#' 
#' The final response is returned in the `bytes` field of the `chunk`
#' object. The [`invoke_agent`][bedrockagentruntime_invoke_agent] returns
#' one chunk for the entire interaction.
#' 
#' -   The `attribution` object contains citations for parts of the
#'     response.
#' 
#' -   If you set `enableTrace` to `true` in the request, you can trace the
#'     agent's steps and reasoning process that led it to the response.
#' 
#' -   If the action predicted was configured to return control, the
#'     response returns parameters for the action, elicited from the user,
#'     in the `returnControl` field.
#' 
#' -   Errors are also surfaced in the response.
#'
#' @usage
#' bedrockagentruntime_invoke_agent(agentAliasId, agentId,
#'   bedrockModelConfigurations, enableTrace, endSession, inputText,
#'   memoryId, sessionId, sessionState, sourceArn, streamingConfigurations)
#'
#' @param agentAliasId &#91;required&#93; The alias of the agent to use.
#' @param agentId &#91;required&#93; The unique identifier of the agent to use.
#' @param bedrockModelConfigurations Model performance settings for the request.
#' @param enableTrace Specifies whether to turn on the trace or not to track the agent's
#' reasoning process. For more information, see [Trace
#' enablement](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-test.html#trace-events).
#' @param endSession Specifies whether to end the session with the agent or not.
#' @param inputText The prompt text to send the agent.
#' 
#' If you include `returnControlInvocationResults` in the `sessionState`
#' field, the `inputText` field will be ignored.
#' @param memoryId The unique identifier of the agent memory.
#' @param sessionId &#91;required&#93; The unique identifier of the session. Use the same value across requests
#' to continue the same conversation.
#' @param sessionState Contains parameters that specify various attributes of the session. For
#' more information, see [Control session
#' context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
#' 
#' If you include `returnControlInvocationResults` in the `sessionState`
#' field, the `inputText` field will be ignored.
#' @param sourceArn The ARN of the resource making the request.
#' @param streamingConfigurations Specifies the configurations for streaming.
#' 
#' To use agent streaming, you need permissions to perform the
#' `bedrock:InvokeModelWithResponseStream` action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   completion = list(
#'     accessDeniedException = list(
#'       message = "string"
#'     ),
#'     badGatewayException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     chunk = list(
#'       attribution = list(
#'         citations = list(
#'           list(
#'             generatedResponsePart = list(
#'               textResponsePart = list(
#'                 span = list(
#'                   end = 123,
#'                   start = 123
#'                 ),
#'                 text = "string"
#'               )
#'             ),
#'             retrievedReferences = list(
#'               list(
#'                 content = list(
#'                   byteContent = "string",
#'                   row = list(
#'                     list(
#'                       columnName = "string",
#'                       columnValue = "string",
#'                       type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                     )
#'                   ),
#'                   text = "string",
#'                   type = "TEXT"|"IMAGE"|"ROW"
#'                 ),
#'                 location = list(
#'                   confluenceLocation = list(
#'                     url = "string"
#'                   ),
#'                   customDocumentLocation = list(
#'                     id = "string"
#'                   ),
#'                   kendraDocumentLocation = list(
#'                     uri = "string"
#'                   ),
#'                   s3Location = list(
#'                     uri = "string"
#'                   ),
#'                   salesforceLocation = list(
#'                     url = "string"
#'                   ),
#'                   sharePointLocation = list(
#'                     url = "string"
#'                   ),
#'                   sqlLocation = list(
#'                     query = "string"
#'                   ),
#'                   type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                   webLocation = list(
#'                     url = "string"
#'                   )
#'                 ),
#'                 metadata = list(
#'                   list()
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       bytes = raw
#'     ),
#'     conflictException = list(
#'       message = "string"
#'     ),
#'     dependencyFailedException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     files = list(
#'       files = list(
#'         list(
#'           bytes = raw,
#'           name = "string",
#'           type = "string"
#'         )
#'       )
#'     ),
#'     internalServerException = list(
#'       message = "string",
#'       reason = "string"
#'     ),
#'     modelNotReadyException = list(
#'       message = "string"
#'     ),
#'     resourceNotFoundException = list(
#'       message = "string"
#'     ),
#'     returnControl = list(
#'       invocationId = "string",
#'       invocationInputs = list(
#'         list(
#'           apiInvocationInput = list(
#'             actionGroup = "string",
#'             actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'             agentId = "string",
#'             apiPath = "string",
#'             collaboratorName = "string",
#'             httpMethod = "string",
#'             parameters = list(
#'               list(
#'                 name = "string",
#'                 type = "string",
#'                 value = "string"
#'               )
#'             ),
#'             requestBody = list(
#'               content = list(
#'                 list(
#'                   properties = list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           functionInvocationInput = list(
#'             actionGroup = "string",
#'             actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'             agentId = "string",
#'             collaboratorName = "string",
#'             function = "string",
#'             parameters = list(
#'               list(
#'                 name = "string",
#'                 type = "string",
#'                 value = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     serviceQuotaExceededException = list(
#'       message = "string"
#'     ),
#'     throttlingException = list(
#'       message = "string"
#'     ),
#'     trace = list(
#'       agentAliasId = "string",
#'       agentId = "string",
#'       agentVersion = "string",
#'       callerChain = list(
#'         list(
#'           agentAliasArn = "string"
#'         )
#'       ),
#'       collaboratorName = "string",
#'       eventTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       sessionId = "string",
#'       trace = list(
#'         customOrchestrationTrace = list(
#'           event = list(
#'             text = "string"
#'           ),
#'           traceId = "string"
#'         ),
#'         failureTrace = list(
#'           failureReason = "string",
#'           traceId = "string"
#'         ),
#'         guardrailTrace = list(
#'           action = "INTERVENED"|"NONE",
#'           inputAssessments = list(
#'             list(
#'               contentPolicy = list(
#'                 filters = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     confidence = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'                     type = "INSULTS"|"HATE"|"SEXUAL"|"VIOLENCE"|"MISCONDUCT"|"PROMPT_ATTACK"
#'                   )
#'                 )
#'               ),
#'               sensitiveInformationPolicy = list(
#'                 piiEntities = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER"
#'                   )
#'                 ),
#'                 regexes = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     name = "string",
#'                     regex = "string"
#'                   )
#'                 )
#'               ),
#'               topicPolicy = list(
#'                 topics = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     name = "string",
#'                     type = "DENY"
#'                   )
#'                 )
#'               ),
#'               wordPolicy = list(
#'                 customWords = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string"
#'                   )
#'                 ),
#'                 managedWordLists = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string",
#'                     type = "PROFANITY"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           outputAssessments = list(
#'             list(
#'               contentPolicy = list(
#'                 filters = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     confidence = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'                     type = "INSULTS"|"HATE"|"SEXUAL"|"VIOLENCE"|"MISCONDUCT"|"PROMPT_ATTACK"
#'                   )
#'                 )
#'               ),
#'               sensitiveInformationPolicy = list(
#'                 piiEntities = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER"
#'                   )
#'                 ),
#'                 regexes = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     name = "string",
#'                     regex = "string"
#'                   )
#'                 )
#'               ),
#'               topicPolicy = list(
#'                 topics = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     name = "string",
#'                     type = "DENY"
#'                   )
#'                 )
#'               ),
#'               wordPolicy = list(
#'                 customWords = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string"
#'                   )
#'                 ),
#'                 managedWordLists = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string",
#'                     type = "PROFANITY"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           traceId = "string"
#'         ),
#'         orchestrationTrace = list(
#'           invocationInput = list(
#'             actionGroupInvocationInput = list(
#'               actionGroupName = "string",
#'               apiPath = "string",
#'               executionType = "LAMBDA"|"RETURN_CONTROL",
#'               function = "string",
#'               invocationId = "string",
#'               parameters = list(
#'                 list(
#'                   name = "string",
#'                   type = "string",
#'                   value = "string"
#'                 )
#'               ),
#'               requestBody = list(
#'                 content = list(
#'                   list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               verb = "string"
#'             ),
#'             agentCollaboratorInvocationInput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               input = list(
#'                 returnControlResults = list(
#'                   invocationId = "string",
#'                   returnControlInvocationResults = list(
#'                     list(
#'                       apiResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         httpMethod = "string",
#'                         httpStatusCode = 123,
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       ),
#'                       functionResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         function = "string",
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationInput = list(
#'               code = "string",
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             invocationType = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"FINISH"|"ACTION_GROUP_CODE_INTERPRETER"|"AGENT_COLLABORATOR",
#'             knowledgeBaseLookupInput = list(
#'               knowledgeBaseId = "string",
#'               text = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           ),
#'           observation = list(
#'             actionGroupInvocationOutput = list(
#'               text = "string"
#'             ),
#'             agentCollaboratorInvocationOutput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               output = list(
#'                 returnControlPayload = list(
#'                   invocationId = "string",
#'                   invocationInputs = list(
#'                     list(
#'                       apiInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         collaboratorName = "string",
#'                         httpMethod = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         ),
#'                         requestBody = list(
#'                           content = list(
#'                             list(
#'                               properties = list(
#'                                 list(
#'                                   name = "string",
#'                                   type = "string",
#'                                   value = "string"
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         )
#'                       ),
#'                       functionInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         collaboratorName = "string",
#'                         function = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationOutput = list(
#'               executionError = "string",
#'               executionOutput = "string",
#'               executionTimeout = TRUE|FALSE,
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             finalResponse = list(
#'               text = "string"
#'             ),
#'             knowledgeBaseLookupOutput = list(
#'               retrievedReferences = list(
#'                 list(
#'                   content = list(
#'                     byteContent = "string",
#'                     row = list(
#'                       list(
#'                         columnName = "string",
#'                         columnValue = "string",
#'                         type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                       )
#'                     ),
#'                     text = "string",
#'                     type = "TEXT"|"IMAGE"|"ROW"
#'                   ),
#'                   location = list(
#'                     confluenceLocation = list(
#'                       url = "string"
#'                     ),
#'                     customDocumentLocation = list(
#'                       id = "string"
#'                     ),
#'                     kendraDocumentLocation = list(
#'                       uri = "string"
#'                     ),
#'                     s3Location = list(
#'                       uri = "string"
#'                     ),
#'                     salesforceLocation = list(
#'                       url = "string"
#'                     ),
#'                     sharePointLocation = list(
#'                       url = "string"
#'                     ),
#'                     sqlLocation = list(
#'                       query = "string"
#'                     ),
#'                     type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                     webLocation = list(
#'                       url = "string"
#'                     )
#'                   ),
#'                   metadata = list(
#'                     list()
#'                   )
#'                 )
#'               )
#'             ),
#'             repromptResponse = list(
#'               source = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"PARSER",
#'               text = "string"
#'             ),
#'             traceId = "string",
#'             type = "ACTION_GROUP"|"AGENT_COLLABORATOR"|"KNOWLEDGE_BASE"|"FINISH"|"ASK_USER"|"REPROMPT"
#'           ),
#'           rationale = list(
#'             text = "string",
#'             traceId = "string"
#'           )
#'         ),
#'         postProcessingTrace = list(
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             parsedResponse = list(
#'               text = "string"
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           )
#'         ),
#'         preProcessingTrace = list(
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             parsedResponse = list(
#'               isValid = TRUE|FALSE,
#'               rationale = "string"
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           )
#'         ),
#'         routingClassifierTrace = list(
#'           invocationInput = list(
#'             actionGroupInvocationInput = list(
#'               actionGroupName = "string",
#'               apiPath = "string",
#'               executionType = "LAMBDA"|"RETURN_CONTROL",
#'               function = "string",
#'               invocationId = "string",
#'               parameters = list(
#'                 list(
#'                   name = "string",
#'                   type = "string",
#'                   value = "string"
#'                 )
#'               ),
#'               requestBody = list(
#'                 content = list(
#'                   list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               verb = "string"
#'             ),
#'             agentCollaboratorInvocationInput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               input = list(
#'                 returnControlResults = list(
#'                   invocationId = "string",
#'                   returnControlInvocationResults = list(
#'                     list(
#'                       apiResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         httpMethod = "string",
#'                         httpStatusCode = 123,
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       ),
#'                       functionResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         function = "string",
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationInput = list(
#'               code = "string",
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             invocationType = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"FINISH"|"ACTION_GROUP_CODE_INTERPRETER"|"AGENT_COLLABORATOR",
#'             knowledgeBaseLookupInput = list(
#'               knowledgeBaseId = "string",
#'               text = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           observation = list(
#'             actionGroupInvocationOutput = list(
#'               text = "string"
#'             ),
#'             agentCollaboratorInvocationOutput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               output = list(
#'                 returnControlPayload = list(
#'                   invocationId = "string",
#'                   invocationInputs = list(
#'                     list(
#'                       apiInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         collaboratorName = "string",
#'                         httpMethod = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         ),
#'                         requestBody = list(
#'                           content = list(
#'                             list(
#'                               properties = list(
#'                                 list(
#'                                   name = "string",
#'                                   type = "string",
#'                                   value = "string"
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         )
#'                       ),
#'                       functionInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         collaboratorName = "string",
#'                         function = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationOutput = list(
#'               executionError = "string",
#'               executionOutput = "string",
#'               executionTimeout = TRUE|FALSE,
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             finalResponse = list(
#'               text = "string"
#'             ),
#'             knowledgeBaseLookupOutput = list(
#'               retrievedReferences = list(
#'                 list(
#'                   content = list(
#'                     byteContent = "string",
#'                     row = list(
#'                       list(
#'                         columnName = "string",
#'                         columnValue = "string",
#'                         type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                       )
#'                     ),
#'                     text = "string",
#'                     type = "TEXT"|"IMAGE"|"ROW"
#'                   ),
#'                   location = list(
#'                     confluenceLocation = list(
#'                       url = "string"
#'                     ),
#'                     customDocumentLocation = list(
#'                       id = "string"
#'                     ),
#'                     kendraDocumentLocation = list(
#'                       uri = "string"
#'                     ),
#'                     s3Location = list(
#'                       uri = "string"
#'                     ),
#'                     salesforceLocation = list(
#'                       url = "string"
#'                     ),
#'                     sharePointLocation = list(
#'                       url = "string"
#'                     ),
#'                     sqlLocation = list(
#'                       query = "string"
#'                     ),
#'                     type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                     webLocation = list(
#'                       url = "string"
#'                     )
#'                   ),
#'                   metadata = list(
#'                     list()
#'                   )
#'                 )
#'               )
#'             ),
#'             repromptResponse = list(
#'               source = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"PARSER",
#'               text = "string"
#'             ),
#'             traceId = "string",
#'             type = "ACTION_GROUP"|"AGENT_COLLABORATOR"|"KNOWLEDGE_BASE"|"FINISH"|"ASK_USER"|"REPROMPT"
#'           )
#'         )
#'       )
#'     ),
#'     validationException = list(
#'       message = "string"
#'     )
#'   ),
#'   contentType = "string",
#'   memoryId = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke_agent(
#'   agentAliasId = "string",
#'   agentId = "string",
#'   bedrockModelConfigurations = list(
#'     performanceConfig = list(
#'       latency = "standard"|"optimized"
#'     )
#'   ),
#'   enableTrace = TRUE|FALSE,
#'   endSession = TRUE|FALSE,
#'   inputText = "string",
#'   memoryId = "string",
#'   sessionId = "string",
#'   sessionState = list(
#'     conversationHistory = list(
#'       messages = list(
#'         list(
#'           content = list(
#'             list(
#'               text = "string"
#'             )
#'           ),
#'           role = "user"|"assistant"
#'         )
#'       )
#'     ),
#'     files = list(
#'       list(
#'         name = "string",
#'         source = list(
#'           byteContent = list(
#'             data = raw,
#'             mediaType = "string"
#'           ),
#'           s3Location = list(
#'             uri = "string"
#'           ),
#'           sourceType = "S3"|"BYTE_CONTENT"
#'         ),
#'         useCase = "CODE_INTERPRETER"|"CHAT"
#'       )
#'     ),
#'     invocationId = "string",
#'     knowledgeBaseConfigurations = list(
#'       list(
#'         knowledgeBaseId = "string",
#'         retrievalConfiguration = list(
#'           vectorSearchConfiguration = list(
#'             filter = list(
#'               andAll = list(
#'                 list()
#'               ),
#'               equals = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               greaterThan = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               greaterThanOrEquals = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               in = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               lessThan = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               lessThanOrEquals = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               listContains = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               notEquals = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               notIn = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               orAll = list(
#'                 list()
#'               ),
#'               startsWith = list(
#'                 key = "string",
#'                 value = list()
#'               ),
#'               stringContains = list(
#'                 key = "string",
#'                 value = list()
#'               )
#'             ),
#'             implicitFilterConfiguration = list(
#'               metadataAttributes = list(
#'                 list(
#'                   description = "string",
#'                   key = "string",
#'                   type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'                 )
#'               ),
#'               modelArn = "string"
#'             ),
#'             numberOfResults = 123,
#'             overrideSearchType = "HYBRID"|"SEMANTIC",
#'             rerankingConfiguration = list(
#'               bedrockRerankingConfiguration = list(
#'                 metadataConfiguration = list(
#'                   selectionMode = "SELECTIVE"|"ALL",
#'                   selectiveModeConfiguration = list(
#'                     fieldsToExclude = list(
#'                       list(
#'                         fieldName = "string"
#'                       )
#'                     ),
#'                     fieldsToInclude = list(
#'                       list(
#'                         fieldName = "string"
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 modelConfiguration = list(
#'                   additionalModelRequestFields = list(
#'                     list()
#'                   ),
#'                   modelArn = "string"
#'                 ),
#'                 numberOfRerankedResults = 123
#'               ),
#'               type = "BEDROCK_RERANKING_MODEL"
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     promptSessionAttributes = list(
#'       "string"
#'     ),
#'     returnControlInvocationResults = list(
#'       list(
#'         apiResult = list(
#'           actionGroup = "string",
#'           agentId = "string",
#'           apiPath = "string",
#'           confirmationState = "CONFIRM"|"DENY",
#'           httpMethod = "string",
#'           httpStatusCode = 123,
#'           responseBody = list(
#'             list(
#'               body = "string",
#'               images = list(
#'                 list(
#'                   format = "png"|"jpeg"|"gif"|"webp",
#'                   source = list(
#'                     bytes = raw
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           responseState = "FAILURE"|"REPROMPT"
#'         ),
#'         functionResult = list(
#'           actionGroup = "string",
#'           agentId = "string",
#'           confirmationState = "CONFIRM"|"DENY",
#'           function = "string",
#'           responseBody = list(
#'             list(
#'               body = "string",
#'               images = list(
#'                 list(
#'                   format = "png"|"jpeg"|"gif"|"webp",
#'                   source = list(
#'                     bytes = raw
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           responseState = "FAILURE"|"REPROMPT"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     )
#'   ),
#'   sourceArn = "string",
#'   streamingConfigurations = list(
#'     applyGuardrailInterval = 123,
#'     streamFinalResponse = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_invoke_agent
#'
#' @aliases bedrockagentruntime_invoke_agent
bedrockagentruntime_invoke_agent <- function(agentAliasId, agentId, bedrockModelConfigurations = NULL, enableTrace = NULL, endSession = NULL, inputText = NULL, memoryId = NULL, sessionId, sessionState = NULL, sourceArn = NULL, streamingConfigurations = NULL) {
  op <- new_operation(
    name = "InvokeAgent",
    http_method = "POST",
    http_path = "/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .bedrockagentruntime$invoke_agent_input(agentAliasId = agentAliasId, agentId = agentId, bedrockModelConfigurations = bedrockModelConfigurations, enableTrace = enableTrace, endSession = endSession, inputText = inputText, memoryId = memoryId, sessionId = sessionId, sessionState = sessionState, sourceArn = sourceArn, streamingConfigurations = streamingConfigurations)
  output <- .bedrockagentruntime$invoke_agent_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$invoke_agent <- bedrockagentruntime_invoke_agent

#' Invokes an alias of a flow to run the inputs that you specify and return
#' the output of each node as a stream
#'
#' @description
#' Invokes an alias of a flow to run the inputs that you specify and return
#' the output of each node as a stream. If there's an error, the error is
#' returned. For more information, see [Test a flow in Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-test.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#' 
#' The CLI doesn't support streaming operations in Amazon Bedrock,
#' including [`invoke_flow`][bedrockagentruntime_invoke_flow].
#'
#' @usage
#' bedrockagentruntime_invoke_flow(enableTrace, executionId,
#'   flowAliasIdentifier, flowIdentifier, inputs,
#'   modelPerformanceConfiguration)
#'
#' @param enableTrace Specifies whether to return the trace for the flow or not. Traces track
#' inputs and outputs for nodes in the flow. For more information, see
#' [Track each step in your prompt flow by viewing its trace in Amazon
#' Bedrock](https://docs.aws.amazon.com/bedrock/latest/userguide/flows-trace.html).
#' @param executionId The unique identifier for the current flow execution. If you don't
#' provide a value, Amazon Bedrock creates the identifier for you.
#' @param flowAliasIdentifier &#91;required&#93; The unique identifier of the flow alias.
#' @param flowIdentifier &#91;required&#93; The unique identifier of the flow.
#' @param inputs &#91;required&#93; A list of objects, each containing information about an input into the
#' flow.
#' @param modelPerformanceConfiguration Model performance settings for the request.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   executionId = "string",
#'   responseStream = list(
#'     accessDeniedException = list(
#'       message = "string"
#'     ),
#'     badGatewayException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     conflictException = list(
#'       message = "string"
#'     ),
#'     dependencyFailedException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     flowCompletionEvent = list(
#'       completionReason = "SUCCESS"|"INPUT_REQUIRED"
#'     ),
#'     flowMultiTurnInputRequestEvent = list(
#'       content = list(
#'         document = list()
#'       ),
#'       nodeName = "string",
#'       nodeType = "FlowInputNode"|"FlowOutputNode"|"LambdaFunctionNode"|"KnowledgeBaseNode"|"PromptNode"|"ConditionNode"|"LexNode"
#'     ),
#'     flowOutputEvent = list(
#'       content = list(
#'         document = list()
#'       ),
#'       nodeName = "string",
#'       nodeType = "FlowInputNode"|"FlowOutputNode"|"LambdaFunctionNode"|"KnowledgeBaseNode"|"PromptNode"|"ConditionNode"|"LexNode"
#'     ),
#'     flowTraceEvent = list(
#'       trace = list(
#'         conditionNodeResultTrace = list(
#'           nodeName = "string",
#'           satisfiedConditions = list(
#'             list(
#'               conditionName = "string"
#'             )
#'           ),
#'           timestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         nodeActionTrace = list(
#'           nodeName = "string",
#'           operationName = "string",
#'           requestId = "string",
#'           serviceName = "string",
#'           timestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         nodeInputTrace = list(
#'           fields = list(
#'             list(
#'               content = list(
#'                 document = list()
#'               ),
#'               nodeInputName = "string"
#'             )
#'           ),
#'           nodeName = "string",
#'           timestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         ),
#'         nodeOutputTrace = list(
#'           fields = list(
#'             list(
#'               content = list(
#'                 document = list()
#'               ),
#'               nodeOutputName = "string"
#'             )
#'           ),
#'           nodeName = "string",
#'           timestamp = as.POSIXct(
#'             "2015-01-01"
#'           )
#'         )
#'       )
#'     ),
#'     internalServerException = list(
#'       message = "string",
#'       reason = "string"
#'     ),
#'     resourceNotFoundException = list(
#'       message = "string"
#'     ),
#'     serviceQuotaExceededException = list(
#'       message = "string"
#'     ),
#'     throttlingException = list(
#'       message = "string"
#'     ),
#'     validationException = list(
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke_flow(
#'   enableTrace = TRUE|FALSE,
#'   executionId = "string",
#'   flowAliasIdentifier = "string",
#'   flowIdentifier = "string",
#'   inputs = list(
#'     list(
#'       content = list(
#'         document = list()
#'       ),
#'       nodeInputName = "string",
#'       nodeName = "string",
#'       nodeOutputName = "string"
#'     )
#'   ),
#'   modelPerformanceConfiguration = list(
#'     performanceConfig = list(
#'       latency = "standard"|"optimized"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_invoke_flow
#'
#' @aliases bedrockagentruntime_invoke_flow
bedrockagentruntime_invoke_flow <- function(enableTrace = NULL, executionId = NULL, flowAliasIdentifier, flowIdentifier, inputs, modelPerformanceConfiguration = NULL) {
  op <- new_operation(
    name = "InvokeFlow",
    http_method = "POST",
    http_path = "/flows/{flowIdentifier}/aliases/{flowAliasIdentifier}",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .bedrockagentruntime$invoke_flow_input(enableTrace = enableTrace, executionId = executionId, flowAliasIdentifier = flowAliasIdentifier, flowIdentifier = flowIdentifier, inputs = inputs, modelPerformanceConfiguration = modelPerformanceConfiguration)
  output <- .bedrockagentruntime$invoke_flow_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$invoke_flow <- bedrockagentruntime_invoke_flow

#' Invokes an inline Amazon Bedrock agent using the configurations you
#' provide with the request
#'
#' @description
#' Invokes an inline Amazon Bedrock agent using the configurations you
#' provide with the request.
#' 
#' -   Specify the following fields for security purposes.
#' 
#'     -   (Optional) `customerEncryptionKeyArn` â€“ The Amazon Resource Name
#'         (ARN) of a KMS key to encrypt the creation of the agent.
#' 
#'     -   (Optional) `idleSessionTTLinSeconds` â€“ Specify the number of
#'         seconds for which the agent should maintain session information.
#'         After this time expires, the subsequent
#'         [`invoke_inline_agent`][bedrockagentruntime_invoke_inline_agent]
#'         request begins a new session.
#' 
#' -   To override the default prompt behavior for agent orchestration and
#'     to use advanced prompts, include a `promptOverrideConfiguration`
#'     object. For more information, see [Advanced
#'     prompts](https://docs.aws.amazon.com/bedrock/latest/userguide/advanced-prompts.html).
#' 
#' -   The agent instructions will not be honored if your agent has only
#'     one knowledge base, uses default prompts, has no action group, and
#'     user input is disabled.
#'
#' @usage
#' bedrockagentruntime_invoke_inline_agent(actionGroups,
#'   agentCollaboration, agentName, bedrockModelConfigurations,
#'   collaboratorConfigurations, collaborators, customOrchestration,
#'   customerEncryptionKeyArn, enableTrace, endSession, foundationModel,
#'   guardrailConfiguration, idleSessionTTLInSeconds, inlineSessionState,
#'   inputText, instruction, knowledgeBases, orchestrationType,
#'   promptOverrideConfiguration, sessionId, streamingConfigurations)
#'
#' @param actionGroups A list of action groups with each action group defining the action the
#' inline agent needs to carry out.
#' @param agentCollaboration Defines how the inline collaborator agent handles information across
#' multiple collaborator agents to coordinate a final response. The inline
#' collaborator agent can also be the supervisor.
#' @param agentName The name for the agent.
#' @param bedrockModelConfigurations Model settings for the request.
#' @param collaboratorConfigurations Settings for an inline agent collaborator called with
#' [`invoke_inline_agent`][bedrockagentruntime_invoke_inline_agent].
#' @param collaborators List of collaborator inline agents.
#' @param customOrchestration Contains details of the custom orchestration configured for the agent.
#' @param customerEncryptionKeyArn The Amazon Resource Name (ARN) of the Amazon Web Services KMS key to use
#' to encrypt your inline agent.
#' @param enableTrace Specifies whether to turn on the trace or not to track the agent's
#' reasoning process. For more information, see [Using
#' trace](https://docs.aws.amazon.com/bedrock/latest/userguide/trace-events.html).
#' @param endSession Specifies whether to end the session with the inline agent or not.
#' @param foundationModel &#91;required&#93; The [model identifier
#' (ID)](https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html#model-ids-arns)
#' of the model to use for orchestration by the inline agent. For example,
#' `meta.llama3-1-70b-instruct-v1:0`.
#' @param guardrailConfiguration The
#' [guardrails](https://docs.aws.amazon.com/bedrock/latest/userguide/guardrails.html)
#' to assign to the inline agent.
#' @param idleSessionTTLInSeconds The number of seconds for which the inline agent should maintain session
#' information. After this time expires, the subsequent
#' [`invoke_inline_agent`][bedrockagentruntime_invoke_inline_agent] request
#' begins a new session.
#' 
#' A user interaction remains active for the amount of time specified. If
#' no conversation occurs during this time, the session expires and the
#' data provided before the timeout is deleted.
#' @param inlineSessionState Parameters that specify the various attributes of a sessions. You can
#' include attributes for the session or prompt or, if you configured an
#' action group to return control, results from invocation of the action
#' group. For more information, see [Control session
#' context](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-session-state.html).
#' 
#' If you include `returnControlInvocationResults` in the `sessionState`
#' field, the `inputText` field will be ignored.
#' @param inputText The prompt text to send to the agent.
#' 
#' If you include `returnControlInvocationResults` in the `sessionState`
#' field, the `inputText` field will be ignored.
#' @param instruction &#91;required&#93; The instructions that tell the inline agent what it should do and how it
#' should interact with users.
#' @param knowledgeBases Contains information of the knowledge bases to associate with.
#' @param orchestrationType Specifies the type of orchestration strategy for the agent. This is set
#' to DEFAULT orchestration type, by default.
#' @param promptOverrideConfiguration Configurations for advanced prompts used to override the default prompts
#' to enhance the accuracy of the inline agent.
#' @param sessionId &#91;required&#93; The unique identifier of the session. Use the same value across requests
#' to continue the same conversation.
#' @param streamingConfigurations Specifies the configurations for streaming.
#' 
#' To use agent streaming, you need permissions to perform the
#' `bedrock:InvokeModelWithResponseStream` action.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   completion = list(
#'     accessDeniedException = list(
#'       message = "string"
#'     ),
#'     badGatewayException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     chunk = list(
#'       attribution = list(
#'         citations = list(
#'           list(
#'             generatedResponsePart = list(
#'               textResponsePart = list(
#'                 span = list(
#'                   end = 123,
#'                   start = 123
#'                 ),
#'                 text = "string"
#'               )
#'             ),
#'             retrievedReferences = list(
#'               list(
#'                 content = list(
#'                   byteContent = "string",
#'                   row = list(
#'                     list(
#'                       columnName = "string",
#'                       columnValue = "string",
#'                       type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                     )
#'                   ),
#'                   text = "string",
#'                   type = "TEXT"|"IMAGE"|"ROW"
#'                 ),
#'                 location = list(
#'                   confluenceLocation = list(
#'                     url = "string"
#'                   ),
#'                   customDocumentLocation = list(
#'                     id = "string"
#'                   ),
#'                   kendraDocumentLocation = list(
#'                     uri = "string"
#'                   ),
#'                   s3Location = list(
#'                     uri = "string"
#'                   ),
#'                   salesforceLocation = list(
#'                     url = "string"
#'                   ),
#'                   sharePointLocation = list(
#'                     url = "string"
#'                   ),
#'                   sqlLocation = list(
#'                     query = "string"
#'                   ),
#'                   type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                   webLocation = list(
#'                     url = "string"
#'                   )
#'                 ),
#'                 metadata = list(
#'                   list()
#'                 )
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       bytes = raw
#'     ),
#'     conflictException = list(
#'       message = "string"
#'     ),
#'     dependencyFailedException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     files = list(
#'       files = list(
#'         list(
#'           bytes = raw,
#'           name = "string",
#'           type = "string"
#'         )
#'       )
#'     ),
#'     internalServerException = list(
#'       message = "string",
#'       reason = "string"
#'     ),
#'     resourceNotFoundException = list(
#'       message = "string"
#'     ),
#'     returnControl = list(
#'       invocationId = "string",
#'       invocationInputs = list(
#'         list(
#'           apiInvocationInput = list(
#'             actionGroup = "string",
#'             actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'             agentId = "string",
#'             apiPath = "string",
#'             collaboratorName = "string",
#'             httpMethod = "string",
#'             parameters = list(
#'               list(
#'                 name = "string",
#'                 type = "string",
#'                 value = "string"
#'               )
#'             ),
#'             requestBody = list(
#'               content = list(
#'                 list(
#'                   properties = list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           functionInvocationInput = list(
#'             actionGroup = "string",
#'             actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'             agentId = "string",
#'             collaboratorName = "string",
#'             function = "string",
#'             parameters = list(
#'               list(
#'                 name = "string",
#'                 type = "string",
#'                 value = "string"
#'               )
#'             )
#'           )
#'         )
#'       )
#'     ),
#'     serviceQuotaExceededException = list(
#'       message = "string"
#'     ),
#'     throttlingException = list(
#'       message = "string"
#'     ),
#'     trace = list(
#'       callerChain = list(
#'         list(
#'           agentAliasArn = "string"
#'         )
#'       ),
#'       collaboratorName = "string",
#'       eventTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       sessionId = "string",
#'       trace = list(
#'         customOrchestrationTrace = list(
#'           event = list(
#'             text = "string"
#'           ),
#'           traceId = "string"
#'         ),
#'         failureTrace = list(
#'           failureReason = "string",
#'           traceId = "string"
#'         ),
#'         guardrailTrace = list(
#'           action = "INTERVENED"|"NONE",
#'           inputAssessments = list(
#'             list(
#'               contentPolicy = list(
#'                 filters = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     confidence = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'                     type = "INSULTS"|"HATE"|"SEXUAL"|"VIOLENCE"|"MISCONDUCT"|"PROMPT_ATTACK"
#'                   )
#'                 )
#'               ),
#'               sensitiveInformationPolicy = list(
#'                 piiEntities = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER"
#'                   )
#'                 ),
#'                 regexes = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     name = "string",
#'                     regex = "string"
#'                   )
#'                 )
#'               ),
#'               topicPolicy = list(
#'                 topics = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     name = "string",
#'                     type = "DENY"
#'                   )
#'                 )
#'               ),
#'               wordPolicy = list(
#'                 customWords = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string"
#'                   )
#'                 ),
#'                 managedWordLists = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string",
#'                     type = "PROFANITY"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           outputAssessments = list(
#'             list(
#'               contentPolicy = list(
#'                 filters = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     confidence = "NONE"|"LOW"|"MEDIUM"|"HIGH",
#'                     type = "INSULTS"|"HATE"|"SEXUAL"|"VIOLENCE"|"MISCONDUCT"|"PROMPT_ATTACK"
#'                   )
#'                 )
#'               ),
#'               sensitiveInformationPolicy = list(
#'                 piiEntities = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     type = "ADDRESS"|"AGE"|"AWS_ACCESS_KEY"|"AWS_SECRET_KEY"|"CA_HEALTH_NUMBER"|"CA_SOCIAL_INSURANCE_NUMBER"|"CREDIT_DEBIT_CARD_CVV"|"CREDIT_DEBIT_CARD_EXPIRY"|"CREDIT_DEBIT_CARD_NUMBER"|"DRIVER_ID"|"EMAIL"|"INTERNATIONAL_BANK_ACCOUNT_NUMBER"|"IP_ADDRESS"|"LICENSE_PLATE"|"MAC_ADDRESS"|"NAME"|"PASSWORD"|"PHONE"|"PIN"|"SWIFT_CODE"|"UK_NATIONAL_HEALTH_SERVICE_NUMBER"|"UK_NATIONAL_INSURANCE_NUMBER"|"UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"|"URL"|"USERNAME"|"US_BANK_ACCOUNT_NUMBER"|"US_BANK_ROUTING_NUMBER"|"US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"|"US_PASSPORT_NUMBER"|"US_SOCIAL_SECURITY_NUMBER"|"VEHICLE_IDENTIFICATION_NUMBER"
#'                   )
#'                 ),
#'                 regexes = list(
#'                   list(
#'                     action = "BLOCKED"|"ANONYMIZED",
#'                     match = "string",
#'                     name = "string",
#'                     regex = "string"
#'                   )
#'                 )
#'               ),
#'               topicPolicy = list(
#'                 topics = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     name = "string",
#'                     type = "DENY"
#'                   )
#'                 )
#'               ),
#'               wordPolicy = list(
#'                 customWords = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string"
#'                   )
#'                 ),
#'                 managedWordLists = list(
#'                   list(
#'                     action = "BLOCKED",
#'                     match = "string",
#'                     type = "PROFANITY"
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           traceId = "string"
#'         ),
#'         orchestrationTrace = list(
#'           invocationInput = list(
#'             actionGroupInvocationInput = list(
#'               actionGroupName = "string",
#'               apiPath = "string",
#'               executionType = "LAMBDA"|"RETURN_CONTROL",
#'               function = "string",
#'               invocationId = "string",
#'               parameters = list(
#'                 list(
#'                   name = "string",
#'                   type = "string",
#'                   value = "string"
#'                 )
#'               ),
#'               requestBody = list(
#'                 content = list(
#'                   list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               verb = "string"
#'             ),
#'             agentCollaboratorInvocationInput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               input = list(
#'                 returnControlResults = list(
#'                   invocationId = "string",
#'                   returnControlInvocationResults = list(
#'                     list(
#'                       apiResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         httpMethod = "string",
#'                         httpStatusCode = 123,
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       ),
#'                       functionResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         function = "string",
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationInput = list(
#'               code = "string",
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             invocationType = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"FINISH"|"ACTION_GROUP_CODE_INTERPRETER"|"AGENT_COLLABORATOR",
#'             knowledgeBaseLookupInput = list(
#'               knowledgeBaseId = "string",
#'               text = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           ),
#'           observation = list(
#'             actionGroupInvocationOutput = list(
#'               text = "string"
#'             ),
#'             agentCollaboratorInvocationOutput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               output = list(
#'                 returnControlPayload = list(
#'                   invocationId = "string",
#'                   invocationInputs = list(
#'                     list(
#'                       apiInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         collaboratorName = "string",
#'                         httpMethod = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         ),
#'                         requestBody = list(
#'                           content = list(
#'                             list(
#'                               properties = list(
#'                                 list(
#'                                   name = "string",
#'                                   type = "string",
#'                                   value = "string"
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         )
#'                       ),
#'                       functionInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         collaboratorName = "string",
#'                         function = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationOutput = list(
#'               executionError = "string",
#'               executionOutput = "string",
#'               executionTimeout = TRUE|FALSE,
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             finalResponse = list(
#'               text = "string"
#'             ),
#'             knowledgeBaseLookupOutput = list(
#'               retrievedReferences = list(
#'                 list(
#'                   content = list(
#'                     byteContent = "string",
#'                     row = list(
#'                       list(
#'                         columnName = "string",
#'                         columnValue = "string",
#'                         type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                       )
#'                     ),
#'                     text = "string",
#'                     type = "TEXT"|"IMAGE"|"ROW"
#'                   ),
#'                   location = list(
#'                     confluenceLocation = list(
#'                       url = "string"
#'                     ),
#'                     customDocumentLocation = list(
#'                       id = "string"
#'                     ),
#'                     kendraDocumentLocation = list(
#'                       uri = "string"
#'                     ),
#'                     s3Location = list(
#'                       uri = "string"
#'                     ),
#'                     salesforceLocation = list(
#'                       url = "string"
#'                     ),
#'                     sharePointLocation = list(
#'                       url = "string"
#'                     ),
#'                     sqlLocation = list(
#'                       query = "string"
#'                     ),
#'                     type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                     webLocation = list(
#'                       url = "string"
#'                     )
#'                   ),
#'                   metadata = list(
#'                     list()
#'                   )
#'                 )
#'               )
#'             ),
#'             repromptResponse = list(
#'               source = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"PARSER",
#'               text = "string"
#'             ),
#'             traceId = "string",
#'             type = "ACTION_GROUP"|"AGENT_COLLABORATOR"|"KNOWLEDGE_BASE"|"FINISH"|"ASK_USER"|"REPROMPT"
#'           ),
#'           rationale = list(
#'             text = "string",
#'             traceId = "string"
#'           )
#'         ),
#'         postProcessingTrace = list(
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             parsedResponse = list(
#'               text = "string"
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           )
#'         ),
#'         preProcessingTrace = list(
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             parsedResponse = list(
#'               isValid = TRUE|FALSE,
#'               rationale = "string"
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             reasoningContent = list(
#'               reasoningText = list(
#'                 signature = "string",
#'                 text = "string"
#'               ),
#'               redactedContent = raw
#'             ),
#'             traceId = "string"
#'           )
#'         ),
#'         routingClassifierTrace = list(
#'           invocationInput = list(
#'             actionGroupInvocationInput = list(
#'               actionGroupName = "string",
#'               apiPath = "string",
#'               executionType = "LAMBDA"|"RETURN_CONTROL",
#'               function = "string",
#'               invocationId = "string",
#'               parameters = list(
#'                 list(
#'                   name = "string",
#'                   type = "string",
#'                   value = "string"
#'                 )
#'               ),
#'               requestBody = list(
#'                 content = list(
#'                   list(
#'                     list(
#'                       name = "string",
#'                       type = "string",
#'                       value = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               verb = "string"
#'             ),
#'             agentCollaboratorInvocationInput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               input = list(
#'                 returnControlResults = list(
#'                   invocationId = "string",
#'                   returnControlInvocationResults = list(
#'                     list(
#'                       apiResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         httpMethod = "string",
#'                         httpStatusCode = 123,
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       ),
#'                       functionResult = list(
#'                         actionGroup = "string",
#'                         agentId = "string",
#'                         confirmationState = "CONFIRM"|"DENY",
#'                         function = "string",
#'                         responseBody = list(
#'                           list(
#'                             body = "string",
#'                             images = list(
#'                               list(
#'                                 format = "png"|"jpeg"|"gif"|"webp",
#'                                 source = list(
#'                                   bytes = raw
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         ),
#'                         responseState = "FAILURE"|"REPROMPT"
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationInput = list(
#'               code = "string",
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             invocationType = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"FINISH"|"ACTION_GROUP_CODE_INTERPRETER"|"AGENT_COLLABORATOR",
#'             knowledgeBaseLookupInput = list(
#'               knowledgeBaseId = "string",
#'               text = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           modelInvocationInput = list(
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             overrideLambda = "string",
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             text = "string",
#'             traceId = "string",
#'             type = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           ),
#'           modelInvocationOutput = list(
#'             metadata = list(
#'               usage = list(
#'                 inputTokens = 123,
#'                 outputTokens = 123
#'               )
#'             ),
#'             rawResponse = list(
#'               content = "string"
#'             ),
#'             traceId = "string"
#'           ),
#'           observation = list(
#'             actionGroupInvocationOutput = list(
#'               text = "string"
#'             ),
#'             agentCollaboratorInvocationOutput = list(
#'               agentCollaboratorAliasArn = "string",
#'               agentCollaboratorName = "string",
#'               output = list(
#'                 returnControlPayload = list(
#'                   invocationId = "string",
#'                   invocationInputs = list(
#'                     list(
#'                       apiInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         apiPath = "string",
#'                         collaboratorName = "string",
#'                         httpMethod = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         ),
#'                         requestBody = list(
#'                           content = list(
#'                             list(
#'                               properties = list(
#'                                 list(
#'                                   name = "string",
#'                                   type = "string",
#'                                   value = "string"
#'                                 )
#'                               )
#'                             )
#'                           )
#'                         )
#'                       ),
#'                       functionInvocationInput = list(
#'                         actionGroup = "string",
#'                         actionInvocationType = "RESULT"|"USER_CONFIRMATION"|"USER_CONFIRMATION_AND_RESULT",
#'                         agentId = "string",
#'                         collaboratorName = "string",
#'                         function = "string",
#'                         parameters = list(
#'                           list(
#'                             name = "string",
#'                             type = "string",
#'                             value = "string"
#'                           )
#'                         )
#'                       )
#'                     )
#'                   )
#'                 ),
#'                 text = "string",
#'                 type = "TEXT"|"RETURN_CONTROL"
#'               )
#'             ),
#'             codeInterpreterInvocationOutput = list(
#'               executionError = "string",
#'               executionOutput = "string",
#'               executionTimeout = TRUE|FALSE,
#'               files = list(
#'                 "string"
#'               )
#'             ),
#'             finalResponse = list(
#'               text = "string"
#'             ),
#'             knowledgeBaseLookupOutput = list(
#'               retrievedReferences = list(
#'                 list(
#'                   content = list(
#'                     byteContent = "string",
#'                     row = list(
#'                       list(
#'                         columnName = "string",
#'                         columnValue = "string",
#'                         type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                       )
#'                     ),
#'                     text = "string",
#'                     type = "TEXT"|"IMAGE"|"ROW"
#'                   ),
#'                   location = list(
#'                     confluenceLocation = list(
#'                       url = "string"
#'                     ),
#'                     customDocumentLocation = list(
#'                       id = "string"
#'                     ),
#'                     kendraDocumentLocation = list(
#'                       uri = "string"
#'                     ),
#'                     s3Location = list(
#'                       uri = "string"
#'                     ),
#'                     salesforceLocation = list(
#'                       url = "string"
#'                     ),
#'                     sharePointLocation = list(
#'                       url = "string"
#'                     ),
#'                     sqlLocation = list(
#'                       query = "string"
#'                     ),
#'                     type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'                     webLocation = list(
#'                       url = "string"
#'                     )
#'                   ),
#'                   metadata = list(
#'                     list()
#'                   )
#'                 )
#'               )
#'             ),
#'             repromptResponse = list(
#'               source = "ACTION_GROUP"|"KNOWLEDGE_BASE"|"PARSER",
#'               text = "string"
#'             ),
#'             traceId = "string",
#'             type = "ACTION_GROUP"|"AGENT_COLLABORATOR"|"KNOWLEDGE_BASE"|"FINISH"|"ASK_USER"|"REPROMPT"
#'           )
#'         )
#'       )
#'     ),
#'     validationException = list(
#'       message = "string"
#'     )
#'   ),
#'   contentType = "string",
#'   sessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$invoke_inline_agent(
#'   actionGroups = list(
#'     list(
#'       actionGroupExecutor = list(
#'         customControl = "RETURN_CONTROL",
#'         lambda = "string"
#'       ),
#'       actionGroupName = "string",
#'       apiSchema = list(
#'         payload = "string",
#'         s3 = list(
#'           s3BucketName = "string",
#'           s3ObjectKey = "string"
#'         )
#'       ),
#'       description = "string",
#'       functionSchema = list(
#'         functions = list(
#'           list(
#'             description = "string",
#'             name = "string",
#'             parameters = list(
#'               list(
#'                 description = "string",
#'                 required = TRUE|FALSE,
#'                 type = "string"|"number"|"integer"|"boolean"|"array"
#'               )
#'             ),
#'             requireConfirmation = "ENABLED"|"DISABLED"
#'           )
#'         )
#'       ),
#'       parentActionGroupSignature = "AMAZON.UserInput"|"AMAZON.CodeInterpreter"|"ANTHROPIC.Computer"|"ANTHROPIC.Bash"|"ANTHROPIC.TextEditor",
#'       parentActionGroupSignatureParams = list(
#'         "string"
#'       )
#'     )
#'   ),
#'   agentCollaboration = "SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED",
#'   agentName = "string",
#'   bedrockModelConfigurations = list(
#'     performanceConfig = list(
#'       latency = "standard"|"optimized"
#'     )
#'   ),
#'   collaboratorConfigurations = list(
#'     list(
#'       agentAliasArn = "string",
#'       collaboratorInstruction = "string",
#'       collaboratorName = "string",
#'       relayConversationHistory = "TO_COLLABORATOR"|"DISABLED"
#'     )
#'   ),
#'   collaborators = list(
#'     list(
#'       actionGroups = list(
#'         list(
#'           actionGroupExecutor = list(
#'             customControl = "RETURN_CONTROL",
#'             lambda = "string"
#'           ),
#'           actionGroupName = "string",
#'           apiSchema = list(
#'             payload = "string",
#'             s3 = list(
#'               s3BucketName = "string",
#'               s3ObjectKey = "string"
#'             )
#'           ),
#'           description = "string",
#'           functionSchema = list(
#'             functions = list(
#'               list(
#'                 description = "string",
#'                 name = "string",
#'                 parameters = list(
#'                   list(
#'                     description = "string",
#'                     required = TRUE|FALSE,
#'                     type = "string"|"number"|"integer"|"boolean"|"array"
#'                   )
#'                 ),
#'                 requireConfirmation = "ENABLED"|"DISABLED"
#'               )
#'             )
#'           ),
#'           parentActionGroupSignature = "AMAZON.UserInput"|"AMAZON.CodeInterpreter"|"ANTHROPIC.Computer"|"ANTHROPIC.Bash"|"ANTHROPIC.TextEditor",
#'           parentActionGroupSignatureParams = list(
#'             "string"
#'           )
#'         )
#'       ),
#'       agentCollaboration = "SUPERVISOR"|"SUPERVISOR_ROUTER"|"DISABLED",
#'       agentName = "string",
#'       collaboratorConfigurations = list(
#'         list(
#'           agentAliasArn = "string",
#'           collaboratorInstruction = "string",
#'           collaboratorName = "string",
#'           relayConversationHistory = "TO_COLLABORATOR"|"DISABLED"
#'         )
#'       ),
#'       customerEncryptionKeyArn = "string",
#'       foundationModel = "string",
#'       guardrailConfiguration = list(
#'         guardrailIdentifier = "string",
#'         guardrailVersion = "string"
#'       ),
#'       idleSessionTTLInSeconds = 123,
#'       instruction = "string",
#'       knowledgeBases = list(
#'         list(
#'           description = "string",
#'           knowledgeBaseId = "string",
#'           retrievalConfiguration = list(
#'             vectorSearchConfiguration = list(
#'               filter = list(
#'                 andAll = list(
#'                   list()
#'                 ),
#'                 equals = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 greaterThan = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 greaterThanOrEquals = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 in = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 lessThan = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 lessThanOrEquals = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 listContains = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 notEquals = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 notIn = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 orAll = list(
#'                   list()
#'                 ),
#'                 startsWith = list(
#'                   key = "string",
#'                   value = list()
#'                 ),
#'                 stringContains = list(
#'                   key = "string",
#'                   value = list()
#'                 )
#'               ),
#'               implicitFilterConfiguration = list(
#'                 metadataAttributes = list(
#'                   list(
#'                     description = "string",
#'                     key = "string",
#'                     type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'                   )
#'                 ),
#'                 modelArn = "string"
#'               ),
#'               numberOfResults = 123,
#'               overrideSearchType = "HYBRID"|"SEMANTIC",
#'               rerankingConfiguration = list(
#'                 bedrockRerankingConfiguration = list(
#'                   metadataConfiguration = list(
#'                     selectionMode = "SELECTIVE"|"ALL",
#'                     selectiveModeConfiguration = list(
#'                       fieldsToExclude = list(
#'                         list(
#'                           fieldName = "string"
#'                         )
#'                       ),
#'                       fieldsToInclude = list(
#'                         list(
#'                           fieldName = "string"
#'                         )
#'                       )
#'                     )
#'                   ),
#'                   modelConfiguration = list(
#'                     additionalModelRequestFields = list(
#'                       list()
#'                     ),
#'                     modelArn = "string"
#'                   ),
#'                   numberOfRerankedResults = 123
#'                 ),
#'                 type = "BEDROCK_RERANKING_MODEL"
#'               )
#'             )
#'           )
#'         )
#'       ),
#'       promptOverrideConfiguration = list(
#'         overrideLambda = "string",
#'         promptConfigurations = list(
#'           list(
#'             additionalModelRequestFields = list(),
#'             basePromptTemplate = "string",
#'             foundationModel = "string",
#'             inferenceConfiguration = list(
#'               maximumLength = 123,
#'               stopSequences = list(
#'                 "string"
#'               ),
#'               temperature = 123.0,
#'               topK = 123,
#'               topP = 123.0
#'             ),
#'             parserMode = "DEFAULT"|"OVERRIDDEN",
#'             promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'             promptState = "ENABLED"|"DISABLED",
#'             promptType = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   customOrchestration = list(
#'     executor = list(
#'       lambda = "string"
#'     )
#'   ),
#'   customerEncryptionKeyArn = "string",
#'   enableTrace = TRUE|FALSE,
#'   endSession = TRUE|FALSE,
#'   foundationModel = "string",
#'   guardrailConfiguration = list(
#'     guardrailIdentifier = "string",
#'     guardrailVersion = "string"
#'   ),
#'   idleSessionTTLInSeconds = 123,
#'   inlineSessionState = list(
#'     conversationHistory = list(
#'       messages = list(
#'         list(
#'           content = list(
#'             list(
#'               text = "string"
#'             )
#'           ),
#'           role = "user"|"assistant"
#'         )
#'       )
#'     ),
#'     files = list(
#'       list(
#'         name = "string",
#'         source = list(
#'           byteContent = list(
#'             data = raw,
#'             mediaType = "string"
#'           ),
#'           s3Location = list(
#'             uri = "string"
#'           ),
#'           sourceType = "S3"|"BYTE_CONTENT"
#'         ),
#'         useCase = "CODE_INTERPRETER"|"CHAT"
#'       )
#'     ),
#'     invocationId = "string",
#'     promptSessionAttributes = list(
#'       "string"
#'     ),
#'     returnControlInvocationResults = list(
#'       list(
#'         apiResult = list(
#'           actionGroup = "string",
#'           agentId = "string",
#'           apiPath = "string",
#'           confirmationState = "CONFIRM"|"DENY",
#'           httpMethod = "string",
#'           httpStatusCode = 123,
#'           responseBody = list(
#'             list(
#'               body = "string",
#'               images = list(
#'                 list(
#'                   format = "png"|"jpeg"|"gif"|"webp",
#'                   source = list(
#'                     bytes = raw
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           responseState = "FAILURE"|"REPROMPT"
#'         ),
#'         functionResult = list(
#'           actionGroup = "string",
#'           agentId = "string",
#'           confirmationState = "CONFIRM"|"DENY",
#'           function = "string",
#'           responseBody = list(
#'             list(
#'               body = "string",
#'               images = list(
#'                 list(
#'                   format = "png"|"jpeg"|"gif"|"webp",
#'                   source = list(
#'                     bytes = raw
#'                   )
#'                 )
#'               )
#'             )
#'           ),
#'           responseState = "FAILURE"|"REPROMPT"
#'         )
#'       )
#'     ),
#'     sessionAttributes = list(
#'       "string"
#'     )
#'   ),
#'   inputText = "string",
#'   instruction = "string",
#'   knowledgeBases = list(
#'     list(
#'       description = "string",
#'       knowledgeBaseId = "string",
#'       retrievalConfiguration = list(
#'         vectorSearchConfiguration = list(
#'           filter = list(
#'             andAll = list(
#'               list()
#'             ),
#'             equals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             in = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             listContains = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notIn = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             orAll = list(
#'               list()
#'             ),
#'             startsWith = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             stringContains = list(
#'               key = "string",
#'               value = list()
#'             )
#'           ),
#'           implicitFilterConfiguration = list(
#'             metadataAttributes = list(
#'               list(
#'                 description = "string",
#'                 key = "string",
#'                 type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'               )
#'             ),
#'             modelArn = "string"
#'           ),
#'           numberOfResults = 123,
#'           overrideSearchType = "HYBRID"|"SEMANTIC",
#'           rerankingConfiguration = list(
#'             bedrockRerankingConfiguration = list(
#'               metadataConfiguration = list(
#'                 selectionMode = "SELECTIVE"|"ALL",
#'                 selectiveModeConfiguration = list(
#'                   fieldsToExclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   ),
#'                   fieldsToInclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               modelConfiguration = list(
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 ),
#'                 modelArn = "string"
#'               ),
#'               numberOfRerankedResults = 123
#'             ),
#'             type = "BEDROCK_RERANKING_MODEL"
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   orchestrationType = "DEFAULT"|"CUSTOM_ORCHESTRATION",
#'   promptOverrideConfiguration = list(
#'     overrideLambda = "string",
#'     promptConfigurations = list(
#'       list(
#'         additionalModelRequestFields = list(),
#'         basePromptTemplate = "string",
#'         foundationModel = "string",
#'         inferenceConfiguration = list(
#'           maximumLength = 123,
#'           stopSequences = list(
#'             "string"
#'           ),
#'           temperature = 123.0,
#'           topK = 123,
#'           topP = 123.0
#'         ),
#'         parserMode = "DEFAULT"|"OVERRIDDEN",
#'         promptCreationMode = "DEFAULT"|"OVERRIDDEN",
#'         promptState = "ENABLED"|"DISABLED",
#'         promptType = "PRE_PROCESSING"|"ORCHESTRATION"|"KNOWLEDGE_BASE_RESPONSE_GENERATION"|"POST_PROCESSING"|"ROUTING_CLASSIFIER"
#'       )
#'     )
#'   ),
#'   sessionId = "string",
#'   streamingConfigurations = list(
#'     applyGuardrailInterval = 123,
#'     streamFinalResponse = TRUE|FALSE
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_invoke_inline_agent
#'
#' @aliases bedrockagentruntime_invoke_inline_agent
bedrockagentruntime_invoke_inline_agent <- function(actionGroups = NULL, agentCollaboration = NULL, agentName = NULL, bedrockModelConfigurations = NULL, collaboratorConfigurations = NULL, collaborators = NULL, customOrchestration = NULL, customerEncryptionKeyArn = NULL, enableTrace = NULL, endSession = NULL, foundationModel, guardrailConfiguration = NULL, idleSessionTTLInSeconds = NULL, inlineSessionState = NULL, inputText = NULL, instruction, knowledgeBases = NULL, orchestrationType = NULL, promptOverrideConfiguration = NULL, sessionId, streamingConfigurations = NULL) {
  op <- new_operation(
    name = "InvokeInlineAgent",
    http_method = "POST",
    http_path = "/agents/{sessionId}",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .bedrockagentruntime$invoke_inline_agent_input(actionGroups = actionGroups, agentCollaboration = agentCollaboration, agentName = agentName, bedrockModelConfigurations = bedrockModelConfigurations, collaboratorConfigurations = collaboratorConfigurations, collaborators = collaborators, customOrchestration = customOrchestration, customerEncryptionKeyArn = customerEncryptionKeyArn, enableTrace = enableTrace, endSession = endSession, foundationModel = foundationModel, guardrailConfiguration = guardrailConfiguration, idleSessionTTLInSeconds = idleSessionTTLInSeconds, inlineSessionState = inlineSessionState, inputText = inputText, instruction = instruction, knowledgeBases = knowledgeBases, orchestrationType = orchestrationType, promptOverrideConfiguration = promptOverrideConfiguration, sessionId = sessionId, streamingConfigurations = streamingConfigurations)
  output <- .bedrockagentruntime$invoke_inline_agent_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$invoke_inline_agent <- bedrockagentruntime_invoke_inline_agent

#' Lists all invocation steps associated with a session and optionally, an
#' invocation within the session
#'
#' @description
#' Lists all invocation steps associated with a session and optionally, an
#' invocation within the session. For more information about sessions, see
#' [Store and retrieve conversation history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_list_invocation_steps(invocationIdentifier,
#'   maxResults, nextToken, sessionIdentifier)
#'
#' @param invocationIdentifier The unique identifier (in UUID format) for the invocation to list
#' invocation steps for.
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the session associated with the invocation
#' steps. You can specify either the session's `sessionId` or its Amazon
#' Resource Name (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   invocationStepSummaries = list(
#'     list(
#'       invocationId = "string",
#'       invocationStepId = "string",
#'       invocationStepTime = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       sessionId = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_invocation_steps(
#'   invocationIdentifier = "string",
#'   maxResults = 123,
#'   nextToken = "string",
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_list_invocation_steps
#'
#' @aliases bedrockagentruntime_list_invocation_steps
bedrockagentruntime_list_invocation_steps <- function(invocationIdentifier = NULL, maxResults = NULL, nextToken = NULL, sessionIdentifier) {
  op <- new_operation(
    name = "ListInvocationSteps",
    http_method = "POST",
    http_path = "/sessions/{sessionIdentifier}/invocationSteps/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "invocationStepSummaries"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$list_invocation_steps_input(invocationIdentifier = invocationIdentifier, maxResults = maxResults, nextToken = nextToken, sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$list_invocation_steps_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$list_invocation_steps <- bedrockagentruntime_list_invocation_steps

#' Lists all invocations associated with a specific session
#'
#' @description
#' Lists all invocations associated with a specific session. For more
#' information about sessions, see [Store and retrieve conversation history
#' and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_list_invocations(maxResults, nextToken,
#'   sessionIdentifier)
#'
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the session to list invocations for. You can
#' specify either the session's `sessionId` or its Amazon Resource Name
#' (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   invocationSummaries = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       invocationId = "string",
#'       sessionId = "string"
#'     )
#'   ),
#'   nextToken = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_invocations(
#'   maxResults = 123,
#'   nextToken = "string",
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_list_invocations
#'
#' @aliases bedrockagentruntime_list_invocations
bedrockagentruntime_list_invocations <- function(maxResults = NULL, nextToken = NULL, sessionIdentifier) {
  op <- new_operation(
    name = "ListInvocations",
    http_method = "POST",
    http_path = "/sessions/{sessionIdentifier}/invocations/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "invocationSummaries"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$list_invocations_input(maxResults = maxResults, nextToken = nextToken, sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$list_invocations_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$list_invocations <- bedrockagentruntime_list_invocations

#' Lists all sessions in your Amazon Web Services account
#'
#' @description
#' Lists all sessions in your Amazon Web Services account. For more
#' information about sessions, see [Store and retrieve conversation history
#' and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_list_sessions(maxResults, nextToken)
#'
#' @param maxResults The maximum number of results to return in the response. If the total
#' number of results is greater than this value, use the token returned in
#' the response in the `nextToken` field when making another request to
#' return the next batch of results.
#' @param nextToken If the total number of results is greater than the `maxResults` value
#' provided in the request, enter the token returned in the `nextToken`
#' field in the response in this field to return the next batch of results.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   sessionSummaries = list(
#'     list(
#'       createdAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       lastUpdatedAt = as.POSIXct(
#'         "2015-01-01"
#'       ),
#'       sessionArn = "string",
#'       sessionId = "string",
#'       sessionStatus = "ACTIVE"|"EXPIRED"|"ENDED"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_sessions(
#'   maxResults = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_list_sessions
#'
#' @aliases bedrockagentruntime_list_sessions
bedrockagentruntime_list_sessions <- function(maxResults = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListSessions",
    http_method = "POST",
    http_path = "/sessions/",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", limit_key = "maxResults", result_key = "sessionSummaries"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$list_sessions_input(maxResults = maxResults, nextToken = nextToken)
  output <- .bedrockagentruntime$list_sessions_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$list_sessions <- bedrockagentruntime_list_sessions

#' List all the tags for the resource you specify
#'
#' @description
#' List all the tags for the resource you specify.
#'
#' @usage
#' bedrockagentruntime_list_tags_for_resource(resourceArn)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource for which to list tags.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$list_tags_for_resource(
#'   resourceArn = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_list_tags_for_resource
#'
#' @aliases bedrockagentruntime_list_tags_for_resource
bedrockagentruntime_list_tags_for_resource <- function(resourceArn) {
  op <- new_operation(
    name = "ListTagsForResource",
    http_method = "GET",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$list_tags_for_resource_input(resourceArn = resourceArn)
  output <- .bedrockagentruntime$list_tags_for_resource_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$list_tags_for_resource <- bedrockagentruntime_list_tags_for_resource

#' Optimizes a prompt for the task that you specify
#'
#' @description
#' Optimizes a prompt for the task that you specify. For more information,
#' see [Optimize a
#' prompt](https://docs.aws.amazon.com/bedrock/latest/userguide/prompt-management-optimize.html)
#' in the [Amazon Bedrock User
#' Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html).
#'
#' @usage
#' bedrockagentruntime_optimize_prompt(input, targetModelId)
#'
#' @param input &#91;required&#93; Contains the prompt to optimize.
#' @param targetModelId &#91;required&#93; The unique identifier of the model that you want to optimize the prompt
#' for.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   optimizedPrompt = list(
#'     accessDeniedException = list(
#'       message = "string"
#'     ),
#'     analyzePromptEvent = list(
#'       message = "string"
#'     ),
#'     badGatewayException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     dependencyFailedException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     internalServerException = list(
#'       message = "string",
#'       reason = "string"
#'     ),
#'     optimizedPromptEvent = list(
#'       optimizedPrompt = list(
#'         textPrompt = list(
#'           text = "string"
#'         )
#'       )
#'     ),
#'     throttlingException = list(
#'       message = "string"
#'     ),
#'     validationException = list(
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$optimize_prompt(
#'   input = list(
#'     textPrompt = list(
#'       text = "string"
#'     )
#'   ),
#'   targetModelId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_optimize_prompt
#'
#' @aliases bedrockagentruntime_optimize_prompt
bedrockagentruntime_optimize_prompt <- function(input, targetModelId) {
  op <- new_operation(
    name = "OptimizePrompt",
    http_method = "POST",
    http_path = "/optimize-prompt",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .bedrockagentruntime$optimize_prompt_input(input = input, targetModelId = targetModelId)
  output <- .bedrockagentruntime$optimize_prompt_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$optimize_prompt <- bedrockagentruntime_optimize_prompt

#' Add an invocation step to an invocation in a session
#'
#' @description
#' Add an invocation step to an invocation in a session. An invocation step
#' stores fine-grained state checkpoints, including text and images, for
#' each interaction. For more information about sessions, see [Store and
#' retrieve conversation history and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#' 
#' Related APIs:
#' 
#' -   [`get_invocation_step`][bedrockagentruntime_get_invocation_step]
#' 
#' -   [`list_invocation_steps`][bedrockagentruntime_list_invocation_steps]
#' 
#' -   [`list_invocations`][bedrockagentruntime_list_invocations]
#' 
#' -   [`list_sessions`][bedrockagentruntime_list_sessions]
#'
#' @usage
#' bedrockagentruntime_put_invocation_step(invocationIdentifier,
#'   invocationStepId, invocationStepTime, payload, sessionIdentifier)
#'
#' @param invocationIdentifier &#91;required&#93; The unique identifier (in UUID format) of the invocation to add the
#' invocation step to.
#' @param invocationStepId The unique identifier of the invocation step in UUID format.
#' @param invocationStepTime &#91;required&#93; The timestamp for when the invocation step occurred.
#' @param payload &#91;required&#93; The payload for the invocation step, including text and images for the
#' interaction.
#' @param sessionIdentifier &#91;required&#93; The unique identifier for the session to add the invocation step to. You
#' can specify either the session's `sessionId` or its Amazon Resource Name
#' (ARN).
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   invocationStepId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$put_invocation_step(
#'   invocationIdentifier = "string",
#'   invocationStepId = "string",
#'   invocationStepTime = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   payload = list(
#'     contentBlocks = list(
#'       list(
#'         image = list(
#'           format = "png"|"jpeg"|"gif"|"webp",
#'           source = list(
#'             bytes = raw,
#'             s3Location = list(
#'               uri = "string"
#'             )
#'           )
#'         ),
#'         text = "string"
#'       )
#'     )
#'   ),
#'   sessionIdentifier = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_put_invocation_step
#'
#' @aliases bedrockagentruntime_put_invocation_step
bedrockagentruntime_put_invocation_step <- function(invocationIdentifier, invocationStepId = NULL, invocationStepTime, payload, sessionIdentifier) {
  op <- new_operation(
    name = "PutInvocationStep",
    http_method = "PUT",
    http_path = "/sessions/{sessionIdentifier}/invocationSteps/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$put_invocation_step_input(invocationIdentifier = invocationIdentifier, invocationStepId = invocationStepId, invocationStepTime = invocationStepTime, payload = payload, sessionIdentifier = sessionIdentifier)
  output <- .bedrockagentruntime$put_invocation_step_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$put_invocation_step <- bedrockagentruntime_put_invocation_step

#' Reranks the relevance of sources based on queries
#'
#' @description
#' Reranks the relevance of sources based on queries. For more information,
#' see [Improve the relevance of query responses with a reranker
#' model](https://docs.aws.amazon.com/bedrock/latest/userguide/rerank.html).
#'
#' @usage
#' bedrockagentruntime_rerank(nextToken, queries, rerankingConfiguration,
#'   sources)
#'
#' @param nextToken If the total number of results was greater than could fit in a response,
#' a token is returned in the `nextToken` field. You can enter that token
#' in this field to return the next batch of results.
#' @param queries &#91;required&#93; An array of objects, each of which contains information about a query to
#' submit to the reranker model.
#' @param rerankingConfiguration &#91;required&#93; Contains configurations for reranking.
#' @param sources &#91;required&#93; An array of objects, each of which contains information about the
#' sources to rerank.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   nextToken = "string",
#'   results = list(
#'     list(
#'       document = list(
#'         jsonDocument = list(),
#'         textDocument = list(
#'           text = "string"
#'         ),
#'         type = "TEXT"|"JSON"
#'       ),
#'       index = 123,
#'       relevanceScore = 123.0
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$rerank(
#'   nextToken = "string",
#'   queries = list(
#'     list(
#'       textQuery = list(
#'         text = "string"
#'       ),
#'       type = "TEXT"
#'     )
#'   ),
#'   rerankingConfiguration = list(
#'     bedrockRerankingConfiguration = list(
#'       modelConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         modelArn = "string"
#'       ),
#'       numberOfResults = 123
#'     ),
#'     type = "BEDROCK_RERANKING_MODEL"
#'   ),
#'   sources = list(
#'     list(
#'       inlineDocumentSource = list(
#'         jsonDocument = list(),
#'         textDocument = list(
#'           text = "string"
#'         ),
#'         type = "TEXT"|"JSON"
#'       ),
#'       type = "INLINE"
#'     )
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_rerank
#'
#' @aliases bedrockagentruntime_rerank
bedrockagentruntime_rerank <- function(nextToken = NULL, queries, rerankingConfiguration, sources) {
  op <- new_operation(
    name = "Rerank",
    http_method = "POST",
    http_path = "/rerank",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", result_key = "results"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$rerank_input(nextToken = nextToken, queries = queries, rerankingConfiguration = rerankingConfiguration, sources = sources)
  output <- .bedrockagentruntime$rerank_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$rerank <- bedrockagentruntime_rerank

#' Queries a knowledge base and retrieves information from it
#'
#' @description
#' Queries a knowledge base and retrieves information from it.
#'
#' @usage
#' bedrockagentruntime_retrieve(guardrailConfiguration, knowledgeBaseId,
#'   nextToken, retrievalConfiguration, retrievalQuery)
#'
#' @param guardrailConfiguration Guardrail settings.
#' @param knowledgeBaseId &#91;required&#93; The unique identifier of the knowledge base to query.
#' @param nextToken If there are more results than can fit in the response, the response
#' returns a `nextToken`. Use this token in the `nextToken` field of
#' another request to retrieve the next batch of results.
#' @param retrievalConfiguration Contains configurations for the knowledge base query and retrieval
#' process. For more information, see [Query
#' configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
#' @param retrievalQuery &#91;required&#93; Contains the query to send the knowledge base.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   guardrailAction = "INTERVENED"|"NONE",
#'   nextToken = "string",
#'   retrievalResults = list(
#'     list(
#'       content = list(
#'         byteContent = "string",
#'         row = list(
#'           list(
#'             columnName = "string",
#'             columnValue = "string",
#'             type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'           )
#'         ),
#'         text = "string",
#'         type = "TEXT"|"IMAGE"|"ROW"
#'       ),
#'       location = list(
#'         confluenceLocation = list(
#'           url = "string"
#'         ),
#'         customDocumentLocation = list(
#'           id = "string"
#'         ),
#'         kendraDocumentLocation = list(
#'           uri = "string"
#'         ),
#'         s3Location = list(
#'           uri = "string"
#'         ),
#'         salesforceLocation = list(
#'           url = "string"
#'         ),
#'         sharePointLocation = list(
#'           url = "string"
#'         ),
#'         sqlLocation = list(
#'           query = "string"
#'         ),
#'         type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'         webLocation = list(
#'           url = "string"
#'         )
#'       ),
#'       metadata = list(
#'         list()
#'       ),
#'       score = 123.0
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retrieve(
#'   guardrailConfiguration = list(
#'     guardrailId = "string",
#'     guardrailVersion = "string"
#'   ),
#'   knowledgeBaseId = "string",
#'   nextToken = "string",
#'   retrievalConfiguration = list(
#'     vectorSearchConfiguration = list(
#'       filter = list(
#'         andAll = list(
#'           list()
#'         ),
#'         equals = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         greaterThan = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         greaterThanOrEquals = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         in = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         lessThan = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         lessThanOrEquals = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         listContains = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         notEquals = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         notIn = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         orAll = list(
#'           list()
#'         ),
#'         startsWith = list(
#'           key = "string",
#'           value = list()
#'         ),
#'         stringContains = list(
#'           key = "string",
#'           value = list()
#'         )
#'       ),
#'       implicitFilterConfiguration = list(
#'         metadataAttributes = list(
#'           list(
#'             description = "string",
#'             key = "string",
#'             type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'           )
#'         ),
#'         modelArn = "string"
#'       ),
#'       numberOfResults = 123,
#'       overrideSearchType = "HYBRID"|"SEMANTIC",
#'       rerankingConfiguration = list(
#'         bedrockRerankingConfiguration = list(
#'           metadataConfiguration = list(
#'             selectionMode = "SELECTIVE"|"ALL",
#'             selectiveModeConfiguration = list(
#'               fieldsToExclude = list(
#'                 list(
#'                   fieldName = "string"
#'                 )
#'               ),
#'               fieldsToInclude = list(
#'                 list(
#'                   fieldName = "string"
#'                 )
#'               )
#'             )
#'           ),
#'           modelConfiguration = list(
#'             additionalModelRequestFields = list(
#'               list()
#'             ),
#'             modelArn = "string"
#'           ),
#'           numberOfRerankedResults = 123
#'         ),
#'         type = "BEDROCK_RERANKING_MODEL"
#'       )
#'     )
#'   ),
#'   retrievalQuery = list(
#'     text = "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_retrieve
#'
#' @aliases bedrockagentruntime_retrieve
bedrockagentruntime_retrieve <- function(guardrailConfiguration = NULL, knowledgeBaseId, nextToken = NULL, retrievalConfiguration = NULL, retrievalQuery) {
  op <- new_operation(
    name = "Retrieve",
    http_method = "POST",
    http_path = "/knowledgebases/{knowledgeBaseId}/retrieve",
    host_prefix = "",
    paginator = list(input_token = "nextToken", output_token = "nextToken", result_key = "retrievalResults"),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$retrieve_input(guardrailConfiguration = guardrailConfiguration, knowledgeBaseId = knowledgeBaseId, nextToken = nextToken, retrievalConfiguration = retrievalConfiguration, retrievalQuery = retrievalQuery)
  output <- .bedrockagentruntime$retrieve_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$retrieve <- bedrockagentruntime_retrieve

#' Queries a knowledge base and generates responses based on the retrieved
#' results and using the specified foundation model or inference profile
#'
#' @description
#' Queries a knowledge base and generates responses based on the retrieved
#' results and using the specified foundation model or [inference
#' profile](https://docs.aws.amazon.com/bedrock/latest/userguide/cross-region-inference.html).
#' The response only cites sources that are relevant to the query.
#'
#' @usage
#' bedrockagentruntime_retrieve_and_generate(input,
#'   retrieveAndGenerateConfiguration, sessionConfiguration, sessionId)
#'
#' @param input &#91;required&#93; Contains the query to be made to the knowledge base.
#' @param retrieveAndGenerateConfiguration Contains configurations for the knowledge base query and retrieval
#' process. For more information, see [Query
#' configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
#' @param sessionConfiguration Contains details about the session with the knowledge base.
#' @param sessionId The unique identifier of the session. When you first make a
#' [`retrieve_and_generate`][bedrockagentruntime_retrieve_and_generate]
#' request, Amazon Bedrock automatically generates this value. You must
#' reuse this value for all subsequent requests in the same conversational
#' session. This value allows Amazon Bedrock to maintain context and
#' knowledge from previous interactions. You can't explicitly set the
#' `sessionId` yourself.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   citations = list(
#'     list(
#'       generatedResponsePart = list(
#'         textResponsePart = list(
#'           span = list(
#'             end = 123,
#'             start = 123
#'           ),
#'           text = "string"
#'         )
#'       ),
#'       retrievedReferences = list(
#'         list(
#'           content = list(
#'             byteContent = "string",
#'             row = list(
#'               list(
#'                 columnName = "string",
#'                 columnValue = "string",
#'                 type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'               )
#'             ),
#'             text = "string",
#'             type = "TEXT"|"IMAGE"|"ROW"
#'           ),
#'           location = list(
#'             confluenceLocation = list(
#'               url = "string"
#'             ),
#'             customDocumentLocation = list(
#'               id = "string"
#'             ),
#'             kendraDocumentLocation = list(
#'               uri = "string"
#'             ),
#'             s3Location = list(
#'               uri = "string"
#'             ),
#'             salesforceLocation = list(
#'               url = "string"
#'             ),
#'             sharePointLocation = list(
#'               url = "string"
#'             ),
#'             sqlLocation = list(
#'               query = "string"
#'             ),
#'             type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'             webLocation = list(
#'               url = "string"
#'             )
#'           ),
#'           metadata = list(
#'             list()
#'           )
#'         )
#'       )
#'     )
#'   ),
#'   guardrailAction = "INTERVENED"|"NONE",
#'   output = list(
#'     text = "string"
#'   ),
#'   sessionId = "string"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retrieve_and_generate(
#'   input = list(
#'     text = "string"
#'   ),
#'   retrieveAndGenerateConfiguration = list(
#'     externalSourcesConfiguration = list(
#'       generationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         guardrailConfiguration = list(
#'           guardrailId = "string",
#'           guardrailVersion = "string"
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         )
#'       ),
#'       modelArn = "string",
#'       sources = list(
#'         list(
#'           byteContent = list(
#'             contentType = "string",
#'             data = raw,
#'             identifier = "string"
#'           ),
#'           s3Location = list(
#'             uri = "string"
#'           ),
#'           sourceType = "S3"|"BYTE_CONTENT"
#'         )
#'       )
#'     ),
#'     knowledgeBaseConfiguration = list(
#'       generationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         guardrailConfiguration = list(
#'           guardrailId = "string",
#'           guardrailVersion = "string"
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         )
#'       ),
#'       knowledgeBaseId = "string",
#'       modelArn = "string",
#'       orchestrationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         ),
#'         queryTransformationConfiguration = list(
#'           type = "QUERY_DECOMPOSITION"
#'         )
#'       ),
#'       retrievalConfiguration = list(
#'         vectorSearchConfiguration = list(
#'           filter = list(
#'             andAll = list(
#'               list()
#'             ),
#'             equals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             in = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             listContains = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notIn = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             orAll = list(
#'               list()
#'             ),
#'             startsWith = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             stringContains = list(
#'               key = "string",
#'               value = list()
#'             )
#'           ),
#'           implicitFilterConfiguration = list(
#'             metadataAttributes = list(
#'               list(
#'                 description = "string",
#'                 key = "string",
#'                 type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'               )
#'             ),
#'             modelArn = "string"
#'           ),
#'           numberOfResults = 123,
#'           overrideSearchType = "HYBRID"|"SEMANTIC",
#'           rerankingConfiguration = list(
#'             bedrockRerankingConfiguration = list(
#'               metadataConfiguration = list(
#'                 selectionMode = "SELECTIVE"|"ALL",
#'                 selectiveModeConfiguration = list(
#'                   fieldsToExclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   ),
#'                   fieldsToInclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               modelConfiguration = list(
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 ),
#'                 modelArn = "string"
#'               ),
#'               numberOfRerankedResults = 123
#'             ),
#'             type = "BEDROCK_RERANKING_MODEL"
#'           )
#'         )
#'       )
#'     ),
#'     type = "KNOWLEDGE_BASE"|"EXTERNAL_SOURCES"
#'   ),
#'   sessionConfiguration = list(
#'     kmsKeyArn = "string"
#'   ),
#'   sessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_retrieve_and_generate
#'
#' @aliases bedrockagentruntime_retrieve_and_generate
bedrockagentruntime_retrieve_and_generate <- function(input, retrieveAndGenerateConfiguration = NULL, sessionConfiguration = NULL, sessionId = NULL) {
  op <- new_operation(
    name = "RetrieveAndGenerate",
    http_method = "POST",
    http_path = "/retrieveAndGenerate",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$retrieve_and_generate_input(input = input, retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration, sessionConfiguration = sessionConfiguration, sessionId = sessionId)
  output <- .bedrockagentruntime$retrieve_and_generate_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$retrieve_and_generate <- bedrockagentruntime_retrieve_and_generate

#' Queries a knowledge base and generates responses based on the retrieved
#' results, with output in streaming format
#'
#' @description
#' Queries a knowledge base and generates responses based on the retrieved
#' results, with output in streaming format.
#' 
#' The CLI doesn't support streaming operations in Amazon Bedrock,
#' including `InvokeModelWithResponseStream`.
#' 
#' This operation requires permission for the
#' ` bedrock:RetrieveAndGenerate` action.
#'
#' @usage
#' bedrockagentruntime_retrieve_and_generate_stream(input,
#'   retrieveAndGenerateConfiguration, sessionConfiguration, sessionId)
#'
#' @param input &#91;required&#93; Contains the query to be made to the knowledge base.
#' @param retrieveAndGenerateConfiguration Contains configurations for the knowledge base query and retrieval
#' process. For more information, see [Query
#' configurations](https://docs.aws.amazon.com/bedrock/latest/userguide/kb-test-config.html).
#' @param sessionConfiguration Contains details about the session with the knowledge base.
#' @param sessionId The unique identifier of the session. When you first make a
#' [`retrieve_and_generate`][bedrockagentruntime_retrieve_and_generate]
#' request, Amazon Bedrock automatically generates this value. You must
#' reuse this value for all subsequent requests in the same conversational
#' session. This value allows Amazon Bedrock to maintain context and
#' knowledge from previous interactions. You can't explicitly set the
#' `sessionId` yourself.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   sessionId = "string",
#'   stream = list(
#'     accessDeniedException = list(
#'       message = "string"
#'     ),
#'     badGatewayException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     citation = list(
#'       citation = list(
#'         generatedResponsePart = list(
#'           textResponsePart = list(
#'             span = list(
#'               end = 123,
#'               start = 123
#'             ),
#'             text = "string"
#'           )
#'         ),
#'         retrievedReferences = list(
#'           list(
#'             content = list(
#'               byteContent = "string",
#'               row = list(
#'                 list(
#'                   columnName = "string",
#'                   columnValue = "string",
#'                   type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'                 )
#'               ),
#'               text = "string",
#'               type = "TEXT"|"IMAGE"|"ROW"
#'             ),
#'             location = list(
#'               confluenceLocation = list(
#'                 url = "string"
#'               ),
#'               customDocumentLocation = list(
#'                 id = "string"
#'               ),
#'               kendraDocumentLocation = list(
#'                 uri = "string"
#'               ),
#'               s3Location = list(
#'                 uri = "string"
#'               ),
#'               salesforceLocation = list(
#'                 url = "string"
#'               ),
#'               sharePointLocation = list(
#'                 url = "string"
#'               ),
#'               sqlLocation = list(
#'                 query = "string"
#'               ),
#'               type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'               webLocation = list(
#'                 url = "string"
#'               )
#'             ),
#'             metadata = list(
#'               list()
#'             )
#'           )
#'         )
#'       ),
#'       generatedResponsePart = list(
#'         textResponsePart = list(
#'           span = list(
#'             end = 123,
#'             start = 123
#'           ),
#'           text = "string"
#'         )
#'       ),
#'       retrievedReferences = list(
#'         list(
#'           content = list(
#'             byteContent = "string",
#'             row = list(
#'               list(
#'                 columnName = "string",
#'                 columnValue = "string",
#'                 type = "BLOB"|"BOOLEAN"|"DOUBLE"|"NULL"|"LONG"|"STRING"
#'               )
#'             ),
#'             text = "string",
#'             type = "TEXT"|"IMAGE"|"ROW"
#'           ),
#'           location = list(
#'             confluenceLocation = list(
#'               url = "string"
#'             ),
#'             customDocumentLocation = list(
#'               id = "string"
#'             ),
#'             kendraDocumentLocation = list(
#'               uri = "string"
#'             ),
#'             s3Location = list(
#'               uri = "string"
#'             ),
#'             salesforceLocation = list(
#'               url = "string"
#'             ),
#'             sharePointLocation = list(
#'               url = "string"
#'             ),
#'             sqlLocation = list(
#'               query = "string"
#'             ),
#'             type = "S3"|"WEB"|"CONFLUENCE"|"SALESFORCE"|"SHAREPOINT"|"CUSTOM"|"KENDRA"|"SQL",
#'             webLocation = list(
#'               url = "string"
#'             )
#'           ),
#'           metadata = list(
#'             list()
#'           )
#'         )
#'       )
#'     ),
#'     conflictException = list(
#'       message = "string"
#'     ),
#'     dependencyFailedException = list(
#'       message = "string",
#'       resourceName = "string"
#'     ),
#'     guardrail = list(
#'       action = "INTERVENED"|"NONE"
#'     ),
#'     internalServerException = list(
#'       message = "string",
#'       reason = "string"
#'     ),
#'     output = list(
#'       text = "string"
#'     ),
#'     resourceNotFoundException = list(
#'       message = "string"
#'     ),
#'     serviceQuotaExceededException = list(
#'       message = "string"
#'     ),
#'     throttlingException = list(
#'       message = "string"
#'     ),
#'     validationException = list(
#'       message = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$retrieve_and_generate_stream(
#'   input = list(
#'     text = "string"
#'   ),
#'   retrieveAndGenerateConfiguration = list(
#'     externalSourcesConfiguration = list(
#'       generationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         guardrailConfiguration = list(
#'           guardrailId = "string",
#'           guardrailVersion = "string"
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         )
#'       ),
#'       modelArn = "string",
#'       sources = list(
#'         list(
#'           byteContent = list(
#'             contentType = "string",
#'             data = raw,
#'             identifier = "string"
#'           ),
#'           s3Location = list(
#'             uri = "string"
#'           ),
#'           sourceType = "S3"|"BYTE_CONTENT"
#'         )
#'       )
#'     ),
#'     knowledgeBaseConfiguration = list(
#'       generationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         guardrailConfiguration = list(
#'           guardrailId = "string",
#'           guardrailVersion = "string"
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         )
#'       ),
#'       knowledgeBaseId = "string",
#'       modelArn = "string",
#'       orchestrationConfiguration = list(
#'         additionalModelRequestFields = list(
#'           list()
#'         ),
#'         inferenceConfig = list(
#'           textInferenceConfig = list(
#'             maxTokens = 123,
#'             stopSequences = list(
#'               "string"
#'             ),
#'             temperature = 123.0,
#'             topP = 123.0
#'           )
#'         ),
#'         performanceConfig = list(
#'           latency = "standard"|"optimized"
#'         ),
#'         promptTemplate = list(
#'           textPromptTemplate = "string"
#'         ),
#'         queryTransformationConfiguration = list(
#'           type = "QUERY_DECOMPOSITION"
#'         )
#'       ),
#'       retrievalConfiguration = list(
#'         vectorSearchConfiguration = list(
#'           filter = list(
#'             andAll = list(
#'               list()
#'             ),
#'             equals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             greaterThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             in = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThan = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             lessThanOrEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             listContains = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notEquals = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             notIn = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             orAll = list(
#'               list()
#'             ),
#'             startsWith = list(
#'               key = "string",
#'               value = list()
#'             ),
#'             stringContains = list(
#'               key = "string",
#'               value = list()
#'             )
#'           ),
#'           implicitFilterConfiguration = list(
#'             metadataAttributes = list(
#'               list(
#'                 description = "string",
#'                 key = "string",
#'                 type = "STRING"|"NUMBER"|"BOOLEAN"|"STRING_LIST"
#'               )
#'             ),
#'             modelArn = "string"
#'           ),
#'           numberOfResults = 123,
#'           overrideSearchType = "HYBRID"|"SEMANTIC",
#'           rerankingConfiguration = list(
#'             bedrockRerankingConfiguration = list(
#'               metadataConfiguration = list(
#'                 selectionMode = "SELECTIVE"|"ALL",
#'                 selectiveModeConfiguration = list(
#'                   fieldsToExclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   ),
#'                   fieldsToInclude = list(
#'                     list(
#'                       fieldName = "string"
#'                     )
#'                   )
#'                 )
#'               ),
#'               modelConfiguration = list(
#'                 additionalModelRequestFields = list(
#'                   list()
#'                 ),
#'                 modelArn = "string"
#'               ),
#'               numberOfRerankedResults = 123
#'             ),
#'             type = "BEDROCK_RERANKING_MODEL"
#'           )
#'         )
#'       )
#'     ),
#'     type = "KNOWLEDGE_BASE"|"EXTERNAL_SOURCES"
#'   ),
#'   sessionConfiguration = list(
#'     kmsKeyArn = "string"
#'   ),
#'   sessionId = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_retrieve_and_generate_stream
#'
#' @aliases bedrockagentruntime_retrieve_and_generate_stream
bedrockagentruntime_retrieve_and_generate_stream <- function(input, retrieveAndGenerateConfiguration = NULL, sessionConfiguration = NULL, sessionId = NULL) {
  op <- new_operation(
    name = "RetrieveAndGenerateStream",
    http_method = "POST",
    http_path = "/retrieveAndGenerateStream",
    host_prefix = "",
    paginator = list(),
    stream_api = TRUE
  )
  input <- .bedrockagentruntime$retrieve_and_generate_stream_input(input = input, retrieveAndGenerateConfiguration = retrieveAndGenerateConfiguration, sessionConfiguration = sessionConfiguration, sessionId = sessionId)
  output <- .bedrockagentruntime$retrieve_and_generate_stream_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$retrieve_and_generate_stream <- bedrockagentruntime_retrieve_and_generate_stream

#' Associate tags with a resource
#'
#' @description
#' Associate tags with a resource. For more information, see [Tagging
#' resources](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-bedrock.html)
#' in the Amazon Bedrock User Guide.
#'
#' @usage
#' bedrockagentruntime_tag_resource(resourceArn, tags)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource to tag.
#' @param tags &#91;required&#93; An object containing key-value pairs that define the tags to attach to
#' the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$tag_resource(
#'   resourceArn = "string",
#'   tags = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_tag_resource
#'
#' @aliases bedrockagentruntime_tag_resource
bedrockagentruntime_tag_resource <- function(resourceArn, tags) {
  op <- new_operation(
    name = "TagResource",
    http_method = "POST",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$tag_resource_input(resourceArn = resourceArn, tags = tags)
  output <- .bedrockagentruntime$tag_resource_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$tag_resource <- bedrockagentruntime_tag_resource

#' Remove tags from a resource
#'
#' @description
#' Remove tags from a resource.
#'
#' @usage
#' bedrockagentruntime_untag_resource(resourceArn, tagKeys)
#'
#' @param resourceArn &#91;required&#93; The Amazon Resource Name (ARN) of the resource from which to remove
#' tags.
#' @param tagKeys &#91;required&#93; A list of keys of the tags to remove from the resource.
#'
#' @return
#' An empty list.
#'
#' @section Request syntax:
#' ```
#' svc$untag_resource(
#'   resourceArn = "string",
#'   tagKeys = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_untag_resource
#'
#' @aliases bedrockagentruntime_untag_resource
bedrockagentruntime_untag_resource <- function(resourceArn, tagKeys) {
  op <- new_operation(
    name = "UntagResource",
    http_method = "DELETE",
    http_path = "/tags/{resourceArn}",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$untag_resource_input(resourceArn = resourceArn, tagKeys = tagKeys)
  output <- .bedrockagentruntime$untag_resource_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$untag_resource <- bedrockagentruntime_untag_resource

#' Updates the metadata or encryption settings of a session
#'
#' @description
#' Updates the metadata or encryption settings of a session. For more
#' information about sessions, see [Store and retrieve conversation history
#' and context with Amazon Bedrock
#' sessions](https://docs.aws.amazon.com/bedrock/latest/userguide/sessions.html).
#'
#' @usage
#' bedrockagentruntime_update_session(sessionIdentifier, sessionMetadata)
#'
#' @param sessionIdentifier &#91;required&#93; The unique identifier of the session to modify. You can specify either
#' the session's `sessionId` or its Amazon Resource Name (ARN).
#' @param sessionMetadata A map of key-value pairs containing attributes to be persisted across
#' the session. For example the user's ID, their language preference, and
#' the type of device they are using.
#'
#' @return
#' A list with the following syntax:
#' ```
#' list(
#'   createdAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   lastUpdatedAt = as.POSIXct(
#'     "2015-01-01"
#'   ),
#'   sessionArn = "string",
#'   sessionId = "string",
#'   sessionStatus = "ACTIVE"|"EXPIRED"|"ENDED"
#' )
#' ```
#'
#' @section Request syntax:
#' ```
#' svc$update_session(
#'   sessionIdentifier = "string",
#'   sessionMetadata = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname bedrockagentruntime_update_session
#'
#' @aliases bedrockagentruntime_update_session
bedrockagentruntime_update_session <- function(sessionIdentifier, sessionMetadata = NULL) {
  op <- new_operation(
    name = "UpdateSession",
    http_method = "PUT",
    http_path = "/sessions/{sessionIdentifier}/",
    host_prefix = "",
    paginator = list(),
    stream_api = FALSE
  )
  input <- .bedrockagentruntime$update_session_input(sessionIdentifier = sessionIdentifier, sessionMetadata = sessionMetadata)
  output <- .bedrockagentruntime$update_session_output()
  config <- get_config()
  svc <- .bedrockagentruntime$service(config, op)
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.bedrockagentruntime$operations$update_session <- bedrockagentruntime_update_session

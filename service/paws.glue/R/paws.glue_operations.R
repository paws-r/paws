# This file is generated by make.paws. Please do not edit here.

#' @importFrom paws.common new_operation new_request send_request
NULL

#' Creates one or more partitions in a batch operation
#'
#' Creates one or more partitions in a batch operation.
#'
#' @section Accepted Parameters:
#' ```
#' batch_create_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionInputList = list(
#'     list(
#'       Values = list(
#'         "string"
#'       ),
#'       LastAccessTime = as.POSIXct("2015-01-01"),
#'       StorageDescriptor = list(
#'         Columns = list(
#'           list(
#'             Name = "string",
#'             Type = "string",
#'             Comment = "string"
#'           )
#'         ),
#'         Location = "string",
#'         InputFormat = "string",
#'         OutputFormat = "string",
#'         Compressed = TRUE|FALSE,
#'         NumberOfBuckets = 123,
#'         SerdeInfo = list(
#'           Name = "string",
#'           SerializationLibrary = "string",
#'           Parameters = list(
#'             "string"
#'           )
#'         ),
#'         BucketColumns = list(
#'           "string"
#'         ),
#'         SortColumns = list(
#'           list(
#'             Column = "string",
#'             SortOrder = 123
#'           )
#'         ),
#'         Parameters = list(
#'           "string"
#'         ),
#'         SkewedInfo = list(
#'           SkewedColumnNames = list(
#'             "string"
#'           ),
#'           SkewedColumnValues = list(
#'             "string"
#'           ),
#'           SkewedColumnValueLocationMaps = list(
#'             "string"
#'           )
#'         ),
#'         StoredAsSubDirectories = TRUE|FALSE
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       LastAnalyzedTime = as.POSIXct("2015-01-01")
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
#' @param DatabaseName &#91;required&#93; The name of the metadata database in which the partition is to be created.
#' @param TableName &#91;required&#93; The name of the metadata table in which the partition is to be created.
#' @param PartitionInputList &#91;required&#93; A list of `PartitionInput` structures that define the partitions to be created.
#'
#' @export
batch_create_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionInputList) 
{
    op <- new_operation(name = "BatchCreatePartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_create_partition_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, PartitionInputList = PartitionInputList)
    output <- batch_create_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a list of connection definitions from the Data Catalog
#'
#' Deletes a list of connection definitions from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' batch_delete_connection(
#'   CatalogId = "string",
#'   ConnectionNameList = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.
#' @param ConnectionNameList &#91;required&#93; A list of names of the connections to delete.
#'
#' @export
batch_delete_connection <- function (CatalogId = NULL, ConnectionNameList) 
{
    op <- new_operation(name = "BatchDeleteConnection", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_delete_connection_input(CatalogId = CatalogId, 
        ConnectionNameList = ConnectionNameList)
    output <- batch_delete_connection_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes one or more partitions in a batch operation
#'
#' Deletes one or more partitions in a batch operation.
#'
#' @section Accepted Parameters:
#' ```
#' batch_delete_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionsToDelete = list(
#'     list(
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table where the partitions to be deleted is located.
#' @param PartitionsToDelete &#91;required&#93; A list of `PartitionInput` structures that define the partitions to be deleted.
#'
#' @export
batch_delete_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionsToDelete) 
{
    op <- new_operation(name = "BatchDeletePartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_delete_partition_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, PartitionsToDelete = PartitionsToDelete)
    output <- batch_delete_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes multiple tables at once
#'
#' Deletes multiple tables at once.
#' 
#' After completing this operation, you will no longer have access to the table versions and partitions that belong to the deleted table. AWS Glue deletes these \"orphaned\" resources asynchronously in a timely manner, at the discretion of the service.
#' 
#' To ensure immediate deletion of all related resources, before calling `BatchDeleteTable`, use `DeleteTableVersion` or `BatchDeleteTableVersion`, and `DeletePartition` or `BatchDeletePartition`, to delete any resources that belong to the table.
#'
#' @section Accepted Parameters:
#' ```
#' batch_delete_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TablesToDelete = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the tables to delete reside. For Hive compatibility, this name is entirely lowercase.
#' @param TablesToDelete &#91;required&#93; A list of the table to delete.
#'
#' @export
batch_delete_table <- function (CatalogId = NULL, DatabaseName, 
    TablesToDelete) 
{
    op <- new_operation(name = "BatchDeleteTable", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_delete_table_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TablesToDelete = TablesToDelete)
    output <- batch_delete_table_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified batch of versions of a table
#'
#' Deletes a specified batch of versions of a table.
#'
#' @section Accepted Parameters:
#' ```
#' batch_delete_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely lowercase.
#' @param VersionIds &#91;required&#93; A list of the IDs of versions to be deleted. A `VersionId` is a string representation of an integer. Each version is incremented by 1.
#'
#' @export
batch_delete_table_version <- function (CatalogId = NULL, DatabaseName, 
    TableName, VersionIds) 
{
    op <- new_operation(name = "BatchDeleteTableVersion", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_delete_table_version_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, VersionIds = VersionIds)
    output <- batch_delete_table_version_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves partitions in a batch request
#'
#' Retrieves partitions in a batch request.
#'
#' @section Accepted Parameters:
#' ```
#' batch_get_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionsToGet = list(
#'     list(
#'       Values = list(
#'         "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions\' table.
#' @param PartitionsToGet &#91;required&#93; A list of partition values identifying the partitions to retrieve.
#'
#' @export
batch_get_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionsToGet) 
{
    op <- new_operation(name = "BatchGetPartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_get_partition_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, PartitionsToGet = PartitionsToGet)
    output <- batch_get_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Stops one or more job runs for a specified job definition
#'
#' Stops one or more job runs for a specified job definition.
#'
#' @section Accepted Parameters:
#' ```
#' batch_stop_job_run(
#'   JobName = "string",
#'   JobRunIds = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job definition for which to stop job runs.
#' @param JobRunIds &#91;required&#93; A list of the JobRunIds that should be stopped for that job definition.
#'
#' @export
batch_stop_job_run <- function (JobName, JobRunIds) 
{
    op <- new_operation(name = "BatchStopJobRun", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- batch_stop_job_run_input(JobName = JobName, JobRunIds = JobRunIds)
    output <- batch_stop_job_run_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a classifier in the user's account
#'
#' Creates a classifier in the user\'s account. This may be a `GrokClassifier`, an `XMLClassifier`, or abbrev `JsonClassifier`, depending on which field of the request is present.
#'
#' @section Accepted Parameters:
#' ```
#' create_classifier(
#'   GrokClassifier = list(
#'     Classification = "string",
#'     Name = "string",
#'     GrokPattern = "string",
#'     CustomPatterns = "string"
#'   ),
#'   XMLClassifier = list(
#'     Classification = "string",
#'     Name = "string",
#'     RowTag = "string"
#'   ),
#'   JsonClassifier = list(
#'     Name = "string",
#'     JsonPath = "string"
#'   )
#' )
#' ```
#'
#' @param GrokClassifier A `GrokClassifier` object specifying the classifier to create.
#' @param XMLClassifier An `XMLClassifier` object specifying the classifier to create.
#' @param JsonClassifier A `JsonClassifier` object specifying the classifier to create.
#'
#' @export
create_classifier <- function (GrokClassifier = NULL, XMLClassifier = NULL, 
    JsonClassifier = NULL) 
{
    op <- new_operation(name = "CreateClassifier", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_classifier_input(GrokClassifier = GrokClassifier, 
        XMLClassifier = XMLClassifier, JsonClassifier = JsonClassifier)
    output <- create_classifier_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a connection definition in the Data Catalog
#'
#' Creates a connection definition in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' create_connection(
#'   CatalogId = "string",
#'   ConnectionInput = list(
#'     Name = "string",
#'     Description = "string",
#'     ConnectionType = "JDBC"|"SFTP",
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     PhysicalConnectionRequirements = list(
#'       SubnetId = "string",
#'       SecurityGroupIdList = list(
#'         "string"
#'       ),
#'       AvailabilityZone = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.
#' @param ConnectionInput &#91;required&#93; A `ConnectionInput` object defining the connection to create.
#'
#' @export
create_connection <- function (CatalogId = NULL, ConnectionInput) 
{
    op <- new_operation(name = "CreateConnection", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_connection_input(CatalogId = CatalogId, ConnectionInput = ConnectionInput)
    output <- create_connection_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new crawler with specified targets, role, configuration, and optional schedule
#'
#' Creates a new crawler with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in the *s3Targets* field, the *jdbcTargets* field, or the *DynamoDBTargets* field.
#'
#' @section Accepted Parameters:
#' ```
#' create_crawler(
#'   Name = "string",
#'   Role = "string",
#'   DatabaseName = "string",
#'   Description = "string",
#'   Targets = list(
#'     S3Targets = list(
#'       list(
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     JdbcTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     DynamoDBTargets = list(
#'       list(
#'         Path = "string"
#'       )
#'     )
#'   ),
#'   Schedule = "string",
#'   Classifiers = list(
#'     "string"
#'   ),
#'   TablePrefix = "string",
#'   SchemaChangePolicy = list(
#'     UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'     DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'   ),
#'   Configuration = "string",
#'   CrawlerSecurityConfiguration = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the new crawler.
#' @param Role &#91;required&#93; The IAM role (or ARN of an IAM role) used by the new crawler to access customer resources.
#' @param DatabaseName &#91;required&#93; The AWS Glue database where results are written, such as: `arn:aws:daylight:us-east-1::database/sometable/*`.
#' @param Description A description of the new crawler.
#' @param Targets &#91;required&#93; A list of collection of targets to crawl.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](http://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: `cron(15 12 * * ? *)`.
#' @param Classifiers A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
#' @param TablePrefix The table prefix used for catalog tables that are created.
#' @param SchemaChangePolicy Policy for the crawler\'s update and deletion behavior.
#' @param Configuration Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler\'s behavior. For more information, see [Configuring a Crawler](http://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
#' @param CrawlerSecurityConfiguration The name of the SecurityConfiguration structure to be used by this Crawler.
#'
#' @export
create_crawler <- function (Name, Role, DatabaseName, Description = NULL, 
    Targets, Schedule = NULL, Classifiers = NULL, TablePrefix = NULL, 
    SchemaChangePolicy = NULL, Configuration = NULL, CrawlerSecurityConfiguration = NULL) 
{
    op <- new_operation(name = "CreateCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_crawler_input(Name = Name, Role = Role, DatabaseName = DatabaseName, 
        Description = Description, Targets = Targets, Schedule = Schedule, 
        Classifiers = Classifiers, TablePrefix = TablePrefix, 
        SchemaChangePolicy = SchemaChangePolicy, Configuration = Configuration, 
        CrawlerSecurityConfiguration = CrawlerSecurityConfiguration)
    output <- create_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new database in a Data Catalog
#'
#' Creates a new database in a Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' create_database(
#'   CatalogId = "string",
#'   DatabaseInput = list(
#'     Name = "string",
#'     Description = "string",
#'     LocationUri = "string",
#'     Parameters = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which to create the database. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseInput &#91;required&#93; A `DatabaseInput` object defining the metadata database to create in the catalog.
#'
#' @export
create_database <- function (CatalogId = NULL, DatabaseInput) 
{
    op <- new_operation(name = "CreateDatabase", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_database_input(CatalogId = CatalogId, DatabaseInput = DatabaseInput)
    output <- create_database_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new DevEndpoint
#'
#' Creates a new DevEndpoint.
#'
#' @section Accepted Parameters:
#' ```
#' create_dev_endpoint(
#'   EndpointName = "string",
#'   RoleArn = "string",
#'   SecurityGroupIds = list(
#'     "string"
#'   ),
#'   SubnetId = "string",
#'   PublicKey = "string",
#'   PublicKeys = list(
#'     "string"
#'   ),
#'   NumberOfNodes = 123,
#'   ExtraPythonLibsS3Path = "string",
#'   ExtraJarsS3Path = "string",
#'   SecurityConfiguration = "string"
#' )
#' ```
#'
#' @param EndpointName &#91;required&#93; The name to be assigned to the new DevEndpoint.
#' @param RoleArn &#91;required&#93; The IAM role for the DevEndpoint.
#' @param SecurityGroupIds Security group IDs for the security groups to be used by the new DevEndpoint.
#' @param SubnetId The subnet ID for the new DevEndpoint to use.
#' @param PublicKey The public key to be used by this DevEndpoint for authentication. This attribute is provided for backward compatibility, as the recommended attribute to use is public keys.
#' @param PublicKeys A list of public keys to be used by the DevEndpoints for authentication. The use of this attribute is preferred over a single public key because the public keys allow you to have a different private key per client.
#' 
#' If you previously created an endpoint with a public key, you must remove that key to be able to set a list of public keys: call the `UpdateDevEndpoint` API with the public key content in the `deletePublicKeys` attribute, and the list of new keys in the `addPublicKeys` attribute.
#' @param NumberOfNodes The number of AWS Glue Data Processing Units (DPUs) to allocate to this DevEndpoint.
#' @param ExtraPythonLibsS3Path Path(s) to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint. Multiple values must be complete paths separated by a comma.
#' 
#' Please note that only pure Python libraries can currently be used on a DevEndpoint. Libraries that rely on C extensions, such as the [pandas](http://pandas.pydata.org/) Python data analysis library, are not yet supported.
#' @param ExtraJarsS3Path Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.
#' @param SecurityConfiguration The name of the SecurityConfiguration structure to be used with this DevEndpoint.
#'
#' @export
create_dev_endpoint <- function (EndpointName, RoleArn, SecurityGroupIds = NULL, 
    SubnetId = NULL, PublicKey = NULL, PublicKeys = NULL, NumberOfNodes = NULL, 
    ExtraPythonLibsS3Path = NULL, ExtraJarsS3Path = NULL, SecurityConfiguration = NULL) 
{
    op <- new_operation(name = "CreateDevEndpoint", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_dev_endpoint_input(EndpointName = EndpointName, 
        RoleArn = RoleArn, SecurityGroupIds = SecurityGroupIds, 
        SubnetId = SubnetId, PublicKey = PublicKey, PublicKeys = PublicKeys, 
        NumberOfNodes = NumberOfNodes, ExtraPythonLibsS3Path = ExtraPythonLibsS3Path, 
        ExtraJarsS3Path = ExtraJarsS3Path, SecurityConfiguration = SecurityConfiguration)
    output <- create_dev_endpoint_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new job definition
#'
#' Creates a new job definition.
#'
#' @section Accepted Parameters:
#' ```
#' create_job(
#'   Name = "string",
#'   Description = "string",
#'   LogUri = "string",
#'   Role = "string",
#'   ExecutionProperty = list(
#'     MaxConcurrentRuns = 123
#'   ),
#'   Command = list(
#'     Name = "string",
#'     ScriptLocation = "string"
#'   ),
#'   DefaultArguments = list(
#'     "string"
#'   ),
#'   Connections = list(
#'     Connections = list(
#'       "string"
#'     )
#'   ),
#'   MaxRetries = 123,
#'   AllocatedCapacity = 123,
#'   Timeout = 123,
#'   MaxCapacity = 123.0,
#'   NotificationProperty = list(
#'     NotifyDelayAfter = 123
#'   ),
#'   SecurityConfiguration = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name you assign to this job definition. It must be unique in your account.
#' @param Description Description of the job being defined.
#' @param LogUri This field is reserved for future use.
#' @param Role &#91;required&#93; The name or ARN of the IAM role associated with this job.
#' @param ExecutionProperty An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.
#' @param Command &#91;required&#93; The JobCommand that executes this job.
#' @param DefaultArguments The default arguments for this job.
#' 
#' You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
#' 
#' For information about how to specify and consume your own Job arguments, see the [Calling AWS Glue APIs in Python](http://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide.
#' 
#' For information about the key-value pairs that AWS Glue consumes to set up your job, see the [Special Parameters Used by AWS Glue](http://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide.
#' @param Connections The connections used for this job.
#' @param MaxRetries The maximum number of times to retry this job if it fails.
#' @param AllocatedCapacity This parameter is deprecated. Use `MaxCapacity` instead.
#' 
#' The number of AWS Glue data processing units (DPUs) to allocate to this Job. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [AWS Glue pricing page](https://aws.amazon.com/glue/pricing/).
#' @param Timeout The job timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters `TIMEOUT` status. The default is 2,880 minutes (48 hours).
#' @param MaxCapacity AWS Glue supports running jobs on a `JobCommand.Name`=\"pythonshell\" with allocated processing as low as 0.0625 DPU, which can be specified using `MaxCapacity`. Glue ETL jobs running in any other way cannot have fractional DPU allocations.
#' @param NotificationProperty Specifies configuration properties of a job notification.
#' @param SecurityConfiguration The name of the SecurityConfiguration structure to be used with this job.
#'
#' @export
create_job <- function (Name, Description = NULL, LogUri = NULL, 
    Role, ExecutionProperty = NULL, Command, DefaultArguments = NULL, 
    Connections = NULL, MaxRetries = NULL, AllocatedCapacity = NULL, 
    Timeout = NULL, MaxCapacity = NULL, NotificationProperty = NULL, 
    SecurityConfiguration = NULL) 
{
    op <- new_operation(name = "CreateJob", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_job_input(Name = Name, Description = Description, 
        LogUri = LogUri, Role = Role, ExecutionProperty = ExecutionProperty, 
        Command = Command, DefaultArguments = DefaultArguments, 
        Connections = Connections, MaxRetries = MaxRetries, AllocatedCapacity = AllocatedCapacity, 
        Timeout = Timeout, MaxCapacity = MaxCapacity, NotificationProperty = NotificationProperty, 
        SecurityConfiguration = SecurityConfiguration)
    output <- create_job_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new partition
#'
#' Creates a new partition.
#'
#' @section Accepted Parameters:
#' ```
#' create_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionInput = list(
#'     Values = list(
#'       "string"
#'     ),
#'     LastAccessTime = as.POSIXct("2015-01-01"),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       Location = "string",
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct("2015-01-01")
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.
#' @param DatabaseName &#91;required&#93; The name of the metadata database in which the partition is to be created.
#' @param TableName &#91;required&#93; The name of the metadata table in which the partition is to be created.
#' @param PartitionInput &#91;required&#93; A `PartitionInput` structure defining the partition to be created.
#'
#' @export
create_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionInput) 
{
    op <- new_operation(name = "CreatePartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, PartitionInput = PartitionInput)
    output <- create_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Transforms a directed acyclic graph (DAG) into code
#'
#' Transforms a directed acyclic graph (DAG) into code.
#'
#' @section Accepted Parameters:
#' ```
#' create_script(
#'   DagNodes = list(
#'     list(
#'       Id = "string",
#'       NodeType = "string",
#'       Args = list(
#'         list(
#'           Name = "string",
#'           Value = "string",
#'           Param = TRUE|FALSE
#'         )
#'       ),
#'       LineNumber = 123
#'     )
#'   ),
#'   DagEdges = list(
#'     list(
#'       Source = "string",
#'       Target = "string",
#'       TargetParameter = "string"
#'     )
#'   ),
#'   Language = "PYTHON"|"SCALA"
#' )
#' ```
#'
#' @param DagNodes A list of the nodes in the DAG.
#' @param DagEdges A list of the edges in the DAG.
#' @param Language The programming language of the resulting code from the DAG.
#'
#' @export
create_script <- function (DagNodes = NULL, DagEdges = NULL, 
    Language = NULL) 
{
    op <- new_operation(name = "CreateScript", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_script_input(DagNodes = DagNodes, DagEdges = DagEdges, 
        Language = Language)
    output <- create_script_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new security configuration
#'
#' Creates a new security configuration.
#'
#' @section Accepted Parameters:
#' ```
#' create_security_configuration(
#'   Name = "string",
#'   EncryptionConfiguration = list(
#'     S3Encryption = list(
#'       list(
#'         S3EncryptionMode = "DISABLED"|"SSE-KMS"|"SSE-S3",
#'         KmsKeyArn = "string"
#'       )
#'     ),
#'     CloudWatchEncryption = list(
#'       CloudWatchEncryptionMode = "DISABLED"|"SSE-KMS",
#'       KmsKeyArn = "string"
#'     ),
#'     JobBookmarksEncryption = list(
#'       JobBookmarksEncryptionMode = "DISABLED"|"CSE-KMS",
#'       KmsKeyArn = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name for the new security configuration.
#' @param EncryptionConfiguration &#91;required&#93; The encryption configuration for the new security configuration.
#'
#' @export
create_security_configuration <- function (Name, EncryptionConfiguration) 
{
    op <- new_operation(name = "CreateSecurityConfiguration", 
        http_method = "POST", http_path = "/", paginator = list())
    input <- create_security_configuration_input(Name = Name, 
        EncryptionConfiguration = EncryptionConfiguration)
    output <- create_security_configuration_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new table definition in the Data Catalog
#'
#' Creates a new table definition in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' create_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableInput = list(
#'     Name = "string",
#'     Description = "string",
#'     Owner = "string",
#'     LastAccessTime = as.POSIXct("2015-01-01"),
#'     LastAnalyzedTime = as.POSIXct("2015-01-01"),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       Location = "string",
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string"
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which to create the `Table`. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The catalog database in which to create the new table. For Hive compatibility, this name is entirely lowercase.
#' @param TableInput &#91;required&#93; The `TableInput` object that defines the metadata table to create in the catalog.
#'
#' @export
create_table <- function (CatalogId = NULL, DatabaseName, TableInput) 
{
    op <- new_operation(name = "CreateTable", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableInput = TableInput)
    output <- create_table_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new trigger
#'
#' Creates a new trigger.
#'
#' @section Accepted Parameters:
#' ```
#' create_trigger(
#'   Name = "string",
#'   Type = "SCHEDULED"|"CONDITIONAL"|"ON_DEMAND",
#'   Schedule = "string",
#'   Predicate = list(
#'     Logical = "AND"|"ANY",
#'     Conditions = list(
#'       list(
#'         LogicalOperator = "EQUALS",
#'         JobName = "string",
#'         State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"
#'       )
#'     )
#'   ),
#'   Actions = list(
#'     list(
#'       JobName = "string",
#'       Arguments = list(
#'         "string"
#'       ),
#'       Timeout = 123,
#'       NotificationProperty = list(
#'         NotifyDelayAfter = 123
#'       ),
#'       SecurityConfiguration = "string"
#'     )
#'   ),
#'   Description = "string",
#'   StartOnCreation = TRUE|FALSE
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger.
#' @param Type &#91;required&#93; The type of the new trigger.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](http://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: `cron(15 12 * * ? *)`.
#' 
#' This field is required when the trigger type is SCHEDULED.
#' @param Predicate A predicate to specify when the new trigger should fire.
#' 
#' This field is required when the trigger type is CONDITIONAL.
#' @param Actions &#91;required&#93; The actions initiated by this trigger when it fires.
#' @param Description A description of the new trigger.
#' @param StartOnCreation Set to true to start SCHEDULED and CONDITIONAL triggers when created. True not supported for ON\_DEMAND triggers.
#'
#' @export
create_trigger <- function (Name, Type, Schedule = NULL, Predicate = NULL, 
    Actions, Description = NULL, StartOnCreation = NULL) 
{
    op <- new_operation(name = "CreateTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_trigger_input(Name = Name, Type = Type, Schedule = Schedule, 
        Predicate = Predicate, Actions = Actions, Description = Description, 
        StartOnCreation = StartOnCreation)
    output <- create_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new function definition in the Data Catalog
#'
#' Creates a new function definition in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' create_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionInput = list(
#'     FunctionName = "string",
#'     ClassName = "string",
#'     OwnerName = "string",
#'     OwnerType = "USER"|"ROLE"|"GROUP",
#'     ResourceUris = list(
#'       list(
#'         ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'         Uri = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which to create the function. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which to create the function.
#' @param FunctionInput &#91;required&#93; A `FunctionInput` object that defines the function to create in the Data Catalog.
#'
#' @export
create_user_defined_function <- function (CatalogId = NULL, DatabaseName, 
    FunctionInput) 
{
    op <- new_operation(name = "CreateUserDefinedFunction", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- create_user_defined_function_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, FunctionInput = FunctionInput)
    output <- create_user_defined_function_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Removes a classifier from the Data Catalog
#'
#' Removes a classifier from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' delete_classifier(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the classifier to remove.
#'
#' @export
delete_classifier <- function (Name) 
{
    op <- new_operation(name = "DeleteClassifier", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_classifier_input(Name = Name)
    output <- delete_classifier_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a connection from the Data Catalog
#'
#' Deletes a connection from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' delete_connection(
#'   CatalogId = "string",
#'   ConnectionName = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
#' @param ConnectionName &#91;required&#93; The name of the connection to delete.
#'
#' @export
delete_connection <- function (CatalogId = NULL, ConnectionName) 
{
    op <- new_operation(name = "DeleteConnection", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_connection_input(CatalogId = CatalogId, ConnectionName = ConnectionName)
    output <- delete_connection_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Removes a specified crawler from the Data Catalog, unless the crawler state is RUNNING
#'
#' Removes a specified crawler from the Data Catalog, unless the crawler state is `RUNNING`.
#'
#' @section Accepted Parameters:
#' ```
#' delete_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the crawler to remove.
#'
#' @export
delete_crawler <- function (Name) 
{
    op <- new_operation(name = "DeleteCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_crawler_input(Name = Name)
    output <- delete_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Removes a specified Database from a Data Catalog
#'
#' Removes a specified Database from a Data Catalog.
#' 
#' After completing this operation, you will no longer have access to the tables (and all table versions and partitions that might belong to the tables) and the user-defined functions in the deleted database. AWS Glue deletes these \"orphaned\" resources asynchronously in a timely manner, at the discretion of the service.
#' 
#' To ensure immediate deletion of all related resources, before calling `DeleteDatabase`, use `DeleteTableVersion` or `BatchDeleteTableVersion`, `DeletePartition` or `BatchDeletePartition`, `DeleteUserDefinedFunction`, and `DeleteTable` or `BatchDeleteTable`, to delete any resources that belong to the database.
#'
#' @section Accepted Parameters:
#' ```
#' delete_database(
#'   CatalogId = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
#' @param Name &#91;required&#93; The name of the Database to delete. For Hive compatibility, this must be all lowercase.
#'
#' @export
delete_database <- function (CatalogId = NULL, Name) 
{
    op <- new_operation(name = "DeleteDatabase", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_database_input(CatalogId = CatalogId, Name = Name)
    output <- delete_database_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified DevEndpoint
#'
#' Deletes a specified DevEndpoint.
#'
#' @section Accepted Parameters:
#' ```
#' delete_dev_endpoint(
#'   EndpointName = "string"
#' )
#' ```
#'
#' @param EndpointName &#91;required&#93; The name of the DevEndpoint.
#'
#' @export
delete_dev_endpoint <- function (EndpointName) 
{
    op <- new_operation(name = "DeleteDevEndpoint", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_dev_endpoint_input(EndpointName = EndpointName)
    output <- delete_dev_endpoint_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified job definition
#'
#' Deletes a specified job definition. If the job definition is not found, no exception is thrown.
#'
#' @section Accepted Parameters:
#' ```
#' delete_job(
#'   JobName = "string"
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job definition to delete.
#'
#' @export
delete_job <- function (JobName) 
{
    op <- new_operation(name = "DeleteJob", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_job_input(JobName = JobName)
    output <- delete_job_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified partition
#'
#' Deletes a specified partition.
#'
#' @section Accepted Parameters:
#' ```
#' delete_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table where the partition to be deleted is located.
#' @param PartitionValues &#91;required&#93; The values that define the partition.
#'
#' @export
delete_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionValues) 
{
    op <- new_operation(name = "DeletePartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, PartitionValues = PartitionValues)
    output <- delete_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified policy
#'
#' Deletes a specified policy.
#'
#' @section Accepted Parameters:
#' ```
#' delete_resource_policy(
#'   PolicyHashCondition = "string"
#' )
#' ```
#'
#' @param PolicyHashCondition The hash value returned when this policy was set.
#'
#' @export
delete_resource_policy <- function (PolicyHashCondition = NULL) 
{
    op <- new_operation(name = "DeleteResourcePolicy", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_resource_policy_input(PolicyHashCondition = PolicyHashCondition)
    output <- delete_resource_policy_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified security configuration
#'
#' Deletes a specified security configuration.
#'
#' @section Accepted Parameters:
#' ```
#' delete_security_configuration(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the security configuration to delete.
#'
#' @export
delete_security_configuration <- function (Name) 
{
    op <- new_operation(name = "DeleteSecurityConfiguration", 
        http_method = "POST", http_path = "/", paginator = list())
    input <- delete_security_configuration_input(Name = Name)
    output <- delete_security_configuration_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Removes a table definition from the Data Catalog
#'
#' Removes a table definition from the Data Catalog.
#' 
#' After completing this operation, you will no longer have access to the table versions and partitions that belong to the deleted table. AWS Glue deletes these \"orphaned\" resources asynchronously in a timely manner, at the discretion of the service.
#' 
#' To ensure immediate deletion of all related resources, before calling `DeleteTable`, use `DeleteTableVersion` or `BatchDeleteTableVersion`, and `DeletePartition` or `BatchDeletePartition`, to delete any resources that belong to the table.
#'
#' @section Accepted Parameters:
#' ```
#' delete_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param Name &#91;required&#93; The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.
#'
#' @export
delete_table <- function (CatalogId = NULL, DatabaseName, Name) 
{
    op <- new_operation(name = "DeleteTable", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        Name = Name)
    output <- delete_table_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified version of a table
#'
#' Deletes a specified version of a table.
#'
#' @section Accepted Parameters:
#' ```
#' delete_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionId = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely lowercase.
#' @param VersionId &#91;required&#93; The ID of the table version to be deleted. A `VersionID` is a string representation of an integer. Each version is incremented by 1.
#'
#' @export
delete_table_version <- function (CatalogId = NULL, DatabaseName, 
    TableName, VersionId) 
{
    op <- new_operation(name = "DeleteTableVersion", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_table_version_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, VersionId = VersionId)
    output <- delete_table_version_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes a specified trigger
#'
#' Deletes a specified trigger. If the trigger is not found, no exception is thrown.
#'
#' @section Accepted Parameters:
#' ```
#' delete_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger to delete.
#'
#' @export
delete_trigger <- function (Name) 
{
    op <- new_operation(name = "DeleteTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_trigger_input(Name = Name)
    output <- delete_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes an existing function definition from the Data Catalog
#'
#' Deletes an existing function definition from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' delete_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function is located.
#' @param FunctionName &#91;required&#93; The name of the function definition to be deleted.
#'
#' @export
delete_user_defined_function <- function (CatalogId = NULL, DatabaseName, 
    FunctionName) 
{
    op <- new_operation(name = "DeleteUserDefinedFunction", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_user_defined_function_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, FunctionName = FunctionName)
    output <- delete_user_defined_function_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the status of a migration operation
#'
#' Retrieves the status of a migration operation.
#'
#' @section Accepted Parameters:
#' ```
#' get_catalog_import_status(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the catalog to migrate. Currently, this should be the AWS account ID.
#'
#' @export
get_catalog_import_status <- function (CatalogId = NULL) 
{
    op <- new_operation(name = "GetCatalogImportStatus", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_catalog_import_status_input(CatalogId = CatalogId)
    output <- get_catalog_import_status_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieve a classifier by name
#'
#' Retrieve a classifier by name.
#'
#' @section Accepted Parameters:
#' ```
#' get_classifier(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the classifier to retrieve.
#'
#' @export
get_classifier <- function (Name) 
{
    op <- new_operation(name = "GetClassifier", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_classifier_input(Name = Name)
    output <- get_classifier_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Lists all classifier objects in the Data Catalog
#'
#' Lists all classifier objects in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_classifiers(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @param MaxResults Size of the list to return (optional).
#' @param NextToken An optional continuation token.
#'
#' @export
get_classifiers <- function (MaxResults = NULL, NextToken = NULL) 
{
    op <- new_operation(name = "GetClassifiers", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_classifiers_input(MaxResults = MaxResults, NextToken = NextToken)
    output <- get_classifiers_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a connection definition from the Data Catalog
#'
#' Retrieves a connection definition from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_connection(
#'   CatalogId = "string",
#'   Name = "string",
#'   HidePassword = TRUE|FALSE
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
#' @param Name &#91;required&#93; The name of the connection definition to retrieve.
#' @param HidePassword Allow you to retrieve the connection metadata without displaying the password. For instance, the AWS Glue console uses this flag to retrieve connections, since the console does not display passwords. Set this parameter where the caller may not have permission to use the KMS key to decrypt the password, but does have permission to access the rest of the connection metadata (that is, the other connection properties).
#'
#' @export
get_connection <- function (CatalogId = NULL, Name, HidePassword = NULL) 
{
    op <- new_operation(name = "GetConnection", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_connection_input(CatalogId = CatalogId, Name = Name, 
        HidePassword = HidePassword)
    output <- get_connection_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a list of connection definitions from the Data Catalog
#'
#' Retrieves a list of connection definitions from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_connections(
#'   CatalogId = "string",
#'   Filter = list(
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionType = "JDBC"|"SFTP"
#'   ),
#'   HidePassword = TRUE|FALSE,
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.
#' @param Filter A filter that controls which connections will be returned.
#' @param HidePassword Allow you to retrieve the connection metadata without displaying the password. For instance, the AWS Glue console uses this flag to retrieve connections, since the console does not display passwords. Set this parameter where the caller may not have permission to use the KMS key to decrypt the password, but does have permission to access the rest of the connection metadata (that is, the other connection properties).
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of connections to return in one response.
#'
#' @export
get_connections <- function (CatalogId = NULL, Filter = NULL, 
    HidePassword = NULL, NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetConnections", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_connections_input(CatalogId = CatalogId, Filter = Filter, 
        HidePassword = HidePassword, NextToken = NextToken, MaxResults = MaxResults)
    output <- get_connections_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves metadata for a specified crawler
#'
#' Retrieves metadata for a specified crawler.
#'
#' @section Accepted Parameters:
#' ```
#' get_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the crawler to retrieve metadata for.
#'
#' @export
get_crawler <- function (Name) 
{
    op <- new_operation(name = "GetCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_crawler_input(Name = Name)
    output <- get_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves metrics about specified crawlers
#'
#' Retrieves metrics about specified crawlers.
#'
#' @section Accepted Parameters:
#' ```
#' get_crawler_metrics(
#'   CrawlerNameList = list(
#'     "string"
#'   ),
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @param CrawlerNameList A list of the names of crawlers about which to retrieve metrics.
#' @param MaxResults The maximum size of a list to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @export
get_crawler_metrics <- function (CrawlerNameList = NULL, MaxResults = NULL, 
    NextToken = NULL) 
{
    op <- new_operation(name = "GetCrawlerMetrics", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_crawler_metrics_input(CrawlerNameList = CrawlerNameList, 
        MaxResults = MaxResults, NextToken = NextToken)
    output <- get_crawler_metrics_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves metadata for all crawlers defined in the customer account
#'
#' Retrieves metadata for all crawlers defined in the customer account.
#'
#' @section Accepted Parameters:
#' ```
#' get_crawlers(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @param MaxResults The number of crawlers to return on each call.
#' @param NextToken A continuation token, if this is a continuation request.
#'
#' @export
get_crawlers <- function (MaxResults = NULL, NextToken = NULL) 
{
    op <- new_operation(name = "GetCrawlers", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_crawlers_input(MaxResults = MaxResults, NextToken = NextToken)
    output <- get_crawlers_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the security configuration for a specified catalog
#'
#' Retrieves the security configuration for a specified catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_data_catalog_encryption_settings(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog for which to retrieve the security configuration. If none is supplied, the AWS account ID is used by default.
#'
#' @export
get_data_catalog_encryption_settings <- function (CatalogId = NULL) 
{
    op <- new_operation(name = "GetDataCatalogEncryptionSettings", 
        http_method = "POST", http_path = "/", paginator = list())
    input <- get_data_catalog_encryption_settings_input(CatalogId = CatalogId)
    output <- get_data_catalog_encryption_settings_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the definition of a specified database
#'
#' Retrieves the definition of a specified database.
#'
#' @section Accepted Parameters:
#' ```
#' get_database(
#'   CatalogId = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.
#' @param Name &#91;required&#93; The name of the database to retrieve. For Hive compatibility, this should be all lowercase.
#'
#' @export
get_database <- function (CatalogId = NULL, Name) 
{
    op <- new_operation(name = "GetDatabase", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_database_input(CatalogId = CatalogId, Name = Name)
    output <- get_database_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves all Databases defined in a given Data Catalog
#'
#' Retrieves all Databases defined in a given Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_databases(
#'   CatalogId = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog from which to retrieve `Databases`. If none is supplied, the AWS account ID is used by default.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of databases to return in one response.
#'
#' @export
get_databases <- function (CatalogId = NULL, NextToken = NULL, 
    MaxResults = NULL) 
{
    op <- new_operation(name = "GetDatabases", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_databases_input(CatalogId = CatalogId, NextToken = NextToken, 
        MaxResults = MaxResults)
    output <- get_databases_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Transforms a Python script into a directed acyclic graph (DAG)
#'
#' Transforms a Python script into a directed acyclic graph (DAG).
#'
#' @section Accepted Parameters:
#' ```
#' get_dataflow_graph(
#'   PythonScript = "string"
#' )
#' ```
#'
#' @param PythonScript The Python script to transform.
#'
#' @export
get_dataflow_graph <- function (PythonScript = NULL) 
{
    op <- new_operation(name = "GetDataflowGraph", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_dataflow_graph_input(PythonScript = PythonScript)
    output <- get_dataflow_graph_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves information about a specified DevEndpoint
#'
#' Retrieves information about a specified DevEndpoint.
#' 
#' When you create a development endpoint in a virtual private cloud (VPC), AWS Glue returns only a private IP address, and the public IP address field is not populated. When you create a non-VPC development endpoint, AWS Glue returns only a public IP address.
#'
#' @section Accepted Parameters:
#' ```
#' get_dev_endpoint(
#'   EndpointName = "string"
#' )
#' ```
#'
#' @param EndpointName &#91;required&#93; Name of the DevEndpoint for which to retrieve information.
#'
#' @export
get_dev_endpoint <- function (EndpointName) 
{
    op <- new_operation(name = "GetDevEndpoint", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_dev_endpoint_input(EndpointName = EndpointName)
    output <- get_dev_endpoint_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves all the DevEndpoints in this AWS account
#'
#' Retrieves all the DevEndpoints in this AWS account.
#' 
#' When you create a development endpoint in a virtual private cloud (VPC), AWS Glue returns only a private IP address and the public IP address field is not populated. When you create a non-VPC development endpoint, AWS Glue returns only a public IP address.
#'
#' @section Accepted Parameters:
#' ```
#' get_dev_endpoints(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @param MaxResults The maximum size of information to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @export
get_dev_endpoints <- function (MaxResults = NULL, NextToken = NULL) 
{
    op <- new_operation(name = "GetDevEndpoints", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_dev_endpoints_input(MaxResults = MaxResults, 
        NextToken = NextToken)
    output <- get_dev_endpoints_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves an existing job definition
#'
#' Retrieves an existing job definition.
#'
#' @section Accepted Parameters:
#' ```
#' get_job(
#'   JobName = "string"
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job definition to retrieve.
#'
#' @export
get_job <- function (JobName) 
{
    op <- new_operation(name = "GetJob", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_job_input(JobName = JobName)
    output <- get_job_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the metadata for a given job run
#'
#' Retrieves the metadata for a given job run.
#'
#' @section Accepted Parameters:
#' ```
#' get_job_run(
#'   JobName = "string",
#'   RunId = "string",
#'   PredecessorsIncluded = TRUE|FALSE
#' )
#' ```
#'
#' @param JobName &#91;required&#93; Name of the job definition being run.
#' @param RunId &#91;required&#93; The ID of the job run.
#' @param PredecessorsIncluded True if a list of predecessor runs should be returned.
#'
#' @export
get_job_run <- function (JobName, RunId, PredecessorsIncluded = NULL) 
{
    op <- new_operation(name = "GetJobRun", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_job_run_input(JobName = JobName, RunId = RunId, 
        PredecessorsIncluded = PredecessorsIncluded)
    output <- get_job_run_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves metadata for all runs of a given job definition
#'
#' Retrieves metadata for all runs of a given job definition.
#'
#' @section Accepted Parameters:
#' ```
#' get_job_runs(
#'   JobName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job definition for which to retrieve all job runs.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum size of the response.
#'
#' @export
get_job_runs <- function (JobName, NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetJobRuns", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_job_runs_input(JobName = JobName, NextToken = NextToken, 
        MaxResults = MaxResults)
    output <- get_job_runs_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves all current job definitions
#'
#' Retrieves all current job definitions.
#'
#' @section Accepted Parameters:
#' ```
#' get_jobs(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum size of the response.
#'
#' @export
get_jobs <- function (NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetJobs", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_jobs_input(NextToken = NextToken, MaxResults = MaxResults)
    output <- get_jobs_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates mappings
#'
#' Creates mappings.
#'
#' @section Accepted Parameters:
#' ```
#' get_mapping(
#'   Source = list(
#'     DatabaseName = "string",
#'     TableName = "string"
#'   ),
#'   Sinks = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string"
#'     )
#'   ),
#'   Location = list(
#'     Jdbc = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     S3 = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDB = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param Source &#91;required&#93; Specifies the source table.
#' @param Sinks A list of target tables.
#' @param Location Parameters for the mapping.
#'
#' @export
get_mapping <- function (Source, Sinks = NULL, Location = NULL) 
{
    op <- new_operation(name = "GetMapping", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_mapping_input(Source = Source, Sinks = Sinks, 
        Location = Location)
    output <- get_mapping_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves information about a specified partition
#'
#' Retrieves information about a specified partition.
#'
#' @section Accepted Parameters:
#' ```
#' get_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValues = list(
#'     "string"
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partition in question resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partition resides.
#' @param TableName &#91;required&#93; The name of the partition\'s table.
#' @param PartitionValues &#91;required&#93; The values that define the partition.
#'
#' @export
get_partition <- function (CatalogId = NULL, DatabaseName, TableName, 
    PartitionValues) 
{
    op <- new_operation(name = "GetPartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, PartitionValues = PartitionValues)
    output <- get_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves information about the partitions in a table
#'
#' Retrieves information about the partitions in a table.
#'
#' @section Accepted Parameters:
#' ```
#' get_partitions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   Expression = "string",
#'   NextToken = "string",
#'   Segment = list(
#'     SegmentNumber = 123,
#'     TotalSegments = 123
#'   ),
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the partitions reside.
#' @param TableName &#91;required&#93; The name of the partitions\' table.
#' @param Expression An expression filtering the partitions to be returned.
#' 
#' The expression uses SQL syntax similar to the SQL `WHERE` filter clause. The SQL statement parser [JSQLParser](http://jsqlparser.sourceforge.net/home.php) parses the expression.
#' 
#' *Operators*: The following are the operators that you can use in the `Expression` API call:
#' 
#' =
#' 
#' :   Checks if the values of the two operands are equal or not; if yes, then the condition becomes true.
#' 
#'     Example: Assume \'variable a\' holds 10 and \'variable b\' holds 20.
#' 
#'     (a = b) is not true.
#' 
#' \< \>
#' 
#' :   Checks if the values of two operands are equal or not; if the values are not equal, then the condition becomes true.
#' 
#'     Example: (a \< \> b) is true.
#' 
#' \>
#' 
#' :   Checks if the value of the left operand is greater than the value of the right operand; if yes, then the condition becomes true.
#' 
#'     Example: (a \> b) is not true.
#' 
#' \<
#' 
#' :   Checks if the value of the left operand is less than the value of the right operand; if yes, then the condition becomes true.
#' 
#'     Example: (a \< b) is true.
#' 
#' \>=
#' 
#' :   Checks if the value of the left operand is greater than or equal to the value of the right operand; if yes, then the condition becomes true.
#' 
#'     Example: (a \>= b) is not true.
#' 
#' \<=
#' 
#' :   Checks if the value of the left operand is less than or equal to the value of the right operand; if yes, then the condition becomes true.
#' 
#'     Example: (a \<= b) is true.
#' 
#' AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL
#' 
#' :   Logical operators.
#' 
#' *Supported Partition Key Types*: The following are the the supported partition keys.
#' 
#' -   `string`
#' 
#' -   `date`
#' 
#' -   `timestamp`
#' 
#' -   `int`
#' 
#' -   `bigint`
#' 
#' -   `long`
#' 
#' -   `tinyint`
#' 
#' -   `smallint`
#' 
#' -   `decimal`
#' 
#' If an invalid type is encountered, an exception is thrown.
#' 
#' The following list shows the valid operators on each type. When you define a crawler, the `partitionKey` type is created as a `STRING`, to be compatible with the catalog partitions.
#' 
#' *Sample API Call*:
#' @param NextToken A continuation token, if this is not the first call to retrieve these partitions.
#' @param Segment The segment of the table\'s partitions to scan in this request.
#' @param MaxResults The maximum number of partitions to return in a single response.
#'
#' @export
get_partitions <- function (CatalogId = NULL, DatabaseName, TableName, 
    Expression = NULL, NextToken = NULL, Segment = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetPartitions", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_partitions_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, Expression = Expression, NextToken = NextToken, 
        Segment = Segment, MaxResults = MaxResults)
    output <- get_partitions_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Gets code to perform a specified mapping
#'
#' Gets code to perform a specified mapping.
#'
#' @section Accepted Parameters:
#' ```
#' get_plan(
#'   Mapping = list(
#'     list(
#'       SourceTable = "string",
#'       SourcePath = "string",
#'       SourceType = "string",
#'       TargetTable = "string",
#'       TargetPath = "string",
#'       TargetType = "string"
#'     )
#'   ),
#'   Source = list(
#'     DatabaseName = "string",
#'     TableName = "string"
#'   ),
#'   Sinks = list(
#'     list(
#'       DatabaseName = "string",
#'       TableName = "string"
#'     )
#'   ),
#'   Location = list(
#'     Jdbc = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     S3 = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     ),
#'     DynamoDB = list(
#'       list(
#'         Name = "string",
#'         Value = "string",
#'         Param = TRUE|FALSE
#'       )
#'     )
#'   ),
#'   Language = "PYTHON"|"SCALA"
#' )
#' ```
#'
#' @param Mapping &#91;required&#93; The list of mappings from a source table to target tables.
#' @param Source &#91;required&#93; The source table.
#' @param Sinks The target tables.
#' @param Location Parameters for the mapping.
#' @param Language The programming language of the code to perform the mapping.
#'
#' @export
get_plan <- function (Mapping, Source, Sinks = NULL, Location = NULL, 
    Language = NULL) 
{
    op <- new_operation(name = "GetPlan", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_plan_input(Mapping = Mapping, Source = Source, 
        Sinks = Sinks, Location = Location, Language = Language)
    output <- get_plan_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a specified resource policy
#'
#' Retrieves a specified resource policy.
#'
#' @section Accepted Parameters:
#' ```
#' get_resource_policy()
#' ```
#'
#' @export
get_resource_policy <- function () 
{
    op <- new_operation(name = "GetResourcePolicy", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_resource_policy_input()
    output <- get_resource_policy_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a specified security configuration
#'
#' Retrieves a specified security configuration.
#'
#' @section Accepted Parameters:
#' ```
#' get_security_configuration(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the security configuration to retrieve.
#'
#' @export
get_security_configuration <- function (Name) 
{
    op <- new_operation(name = "GetSecurityConfiguration", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_security_configuration_input(Name = Name)
    output <- get_security_configuration_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a list of all security configurations
#'
#' Retrieves a list of all security configurations.
#'
#' @section Accepted Parameters:
#' ```
#' get_security_configurations(
#'   MaxResults = 123,
#'   NextToken = "string"
#' )
#' ```
#'
#' @param MaxResults The maximum number of results to return.
#' @param NextToken A continuation token, if this is a continuation call.
#'
#' @export
get_security_configurations <- function (MaxResults = NULL, NextToken = NULL) 
{
    op <- new_operation(name = "GetSecurityConfigurations", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_security_configurations_input(MaxResults = MaxResults, 
        NextToken = NextToken)
    output <- get_security_configurations_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the Table definition in a Data Catalog for a specified table
#'
#' Retrieves the `Table` definition in a Data Catalog for a specified table.
#'
#' @section Accepted Parameters:
#' ```
#' get_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Name = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param Name &#91;required&#93; The name of the table for which to retrieve the definition. For Hive compatibility, this name is entirely lowercase.
#'
#' @export
get_table <- function (CatalogId = NULL, DatabaseName, Name) 
{
    op <- new_operation(name = "GetTable", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        Name = Name)
    output <- get_table_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a specified version of a table
#'
#' Retrieves a specified version of a table.
#'
#' @section Accepted Parameters:
#' ```
#' get_table_version(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   VersionId = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely lowercase.
#' @param VersionId The ID value of the table version to be retrieved. A `VersionID` is a string representation of an integer. Each version is incremented by 1.
#'
#' @export
get_table_version <- function (CatalogId = NULL, DatabaseName, 
    TableName, VersionId = NULL) 
{
    op <- new_operation(name = "GetTableVersion", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_table_version_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, VersionId = VersionId)
    output <- get_table_version_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a list of strings that identify available versions of a specified table
#'
#' Retrieves a list of strings that identify available versions of a specified table.
#'
#' @section Accepted Parameters:
#' ```
#' get_table_versions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param TableName &#91;required&#93; The name of the table. For Hive compatibility, this name is entirely lowercase.
#' @param NextToken A continuation token, if this is not the first call.
#' @param MaxResults The maximum number of table versions to return in one response.
#'
#' @export
get_table_versions <- function (CatalogId = NULL, DatabaseName, 
    TableName, NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetTableVersions", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_table_versions_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, TableName = TableName, NextToken = NextToken, 
        MaxResults = MaxResults)
    output <- get_table_versions_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the definitions of some or all of the tables in a given Database
#'
#' Retrieves the definitions of some or all of the tables in a given `Database`.
#'
#' @section Accepted Parameters:
#' ```
#' get_tables(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Expression = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The database in the catalog whose tables to list. For Hive compatibility, this name is entirely lowercase.
#' @param Expression A regular expression pattern. If present, only those tables whose names match the pattern are returned.
#' @param NextToken A continuation token, included if this is a continuation call.
#' @param MaxResults The maximum number of tables to return in a single response.
#'
#' @export
get_tables <- function (CatalogId = NULL, DatabaseName, Expression = NULL, 
    NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetTables", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_tables_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        Expression = Expression, NextToken = NextToken, MaxResults = MaxResults)
    output <- get_tables_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves the definition of a trigger
#'
#' Retrieves the definition of a trigger.
#'
#' @section Accepted Parameters:
#' ```
#' get_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger to retrieve.
#'
#' @export
get_trigger <- function (Name) 
{
    op <- new_operation(name = "GetTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_trigger_input(Name = Name)
    output <- get_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Gets all the triggers associated with a job
#'
#' Gets all the triggers associated with a job.
#'
#' @section Accepted Parameters:
#' ```
#' get_triggers(
#'   NextToken = "string",
#'   DependentJobName = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param NextToken A continuation token, if this is a continuation call.
#' @param DependentJobName The name of the job for which to retrieve triggers. The trigger that can start this job will be returned, and if there is no such trigger, all triggers will be returned.
#' @param MaxResults The maximum size of the response.
#'
#' @export
get_triggers <- function (NextToken = NULL, DependentJobName = NULL, 
    MaxResults = NULL) 
{
    op <- new_operation(name = "GetTriggers", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_triggers_input(NextToken = NextToken, DependentJobName = DependentJobName, 
        MaxResults = MaxResults)
    output <- get_triggers_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a specified function definition from the Data Catalog
#'
#' Retrieves a specified function definition from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the function to be retrieved is located. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function is located.
#' @param FunctionName &#91;required&#93; The name of the function.
#'
#' @export
get_user_defined_function <- function (CatalogId = NULL, DatabaseName, 
    FunctionName) 
{
    op <- new_operation(name = "GetUserDefinedFunction", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_user_defined_function_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, FunctionName = FunctionName)
    output <- get_user_defined_function_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a multiple function definitions from the Data Catalog
#'
#' Retrieves a multiple function definitions from the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' get_user_defined_functions(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   Pattern = "string",
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the functions to be retrieved are located. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the functions are located.
#' @param Pattern &#91;required&#93; An optional function-name pattern string that filters the function definitions returned.
#' @param NextToken A continuation token, if this is a continuation call.
#' @param MaxResults The maximum number of functions to return in one response.
#'
#' @export
get_user_defined_functions <- function (CatalogId = NULL, DatabaseName, 
    Pattern, NextToken = NULL, MaxResults = NULL) 
{
    op <- new_operation(name = "GetUserDefinedFunctions", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_user_defined_functions_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, Pattern = Pattern, NextToken = NextToken, 
        MaxResults = MaxResults)
    output <- get_user_defined_functions_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Imports an existing Athena Data Catalog to AWS Glue
#'
#' Imports an existing Athena Data Catalog to AWS Glue
#'
#' @section Accepted Parameters:
#' ```
#' import_catalog_to_glue(
#'   CatalogId = "string"
#' )
#' ```
#'
#' @param CatalogId The ID of the catalog to import. Currently, this should be the AWS account ID.
#'
#' @export
import_catalog_to_glue <- function (CatalogId = NULL) 
{
    op <- new_operation(name = "ImportCatalogToGlue", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- import_catalog_to_glue_input(CatalogId = CatalogId)
    output <- import_catalog_to_glue_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Sets the security configuration for a specified catalog
#'
#' Sets the security configuration for a specified catalog. Once the configuration has been set, the specified encryption is applied to every catalog write thereafter.
#'
#' @section Accepted Parameters:
#' ```
#' put_data_catalog_encryption_settings(
#'   CatalogId = "string",
#'   DataCatalogEncryptionSettings = list(
#'     EncryptionAtRest = list(
#'       CatalogEncryptionMode = "DISABLED"|"SSE-KMS",
#'       SseAwsKmsKeyId = "string"
#'     ),
#'     ConnectionPasswordEncryption = list(
#'       ReturnConnectionPasswordEncrypted = TRUE|FALSE,
#'       AwsKmsKeyId = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog for which to set the security configuration. If none is supplied, the AWS account ID is used by default.
#' @param DataCatalogEncryptionSettings &#91;required&#93; The security configuration to set.
#'
#' @export
put_data_catalog_encryption_settings <- function (CatalogId = NULL, 
    DataCatalogEncryptionSettings) 
{
    op <- new_operation(name = "PutDataCatalogEncryptionSettings", 
        http_method = "POST", http_path = "/", paginator = list())
    input <- put_data_catalog_encryption_settings_input(CatalogId = CatalogId, 
        DataCatalogEncryptionSettings = DataCatalogEncryptionSettings)
    output <- put_data_catalog_encryption_settings_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Sets the Data Catalog resource policy for access control
#'
#' Sets the Data Catalog resource policy for access control.
#'
#' @section Accepted Parameters:
#' ```
#' put_resource_policy(
#'   PolicyInJson = "string",
#'   PolicyHashCondition = "string",
#'   PolicyExistsCondition = "MUST_EXIST"|"NOT_EXIST"|"NONE"
#' )
#' ```
#'
#' @param PolicyInJson &#91;required&#93; Contains the policy document to set, in JSON format.
#' @param PolicyHashCondition This is the hash value returned when the previous policy was set using PutResourcePolicy. Its purpose is to prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has been set.
#' @param PolicyExistsCondition A value of `MUST_EXIST` is used to update a policy. A value of `NOT_EXIST` is used to create a new policy. If a value of `NONE` or a null value is used, the call will not depend on the existence of a policy.
#'
#' @export
put_resource_policy <- function (PolicyInJson, PolicyHashCondition = NULL, 
    PolicyExistsCondition = NULL) 
{
    op <- new_operation(name = "PutResourcePolicy", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- put_resource_policy_input(PolicyInJson = PolicyInJson, 
        PolicyHashCondition = PolicyHashCondition, PolicyExistsCondition = PolicyExistsCondition)
    output <- put_resource_policy_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Resets a bookmark entry
#'
#' Resets a bookmark entry.
#'
#' @section Accepted Parameters:
#' ```
#' reset_job_bookmark(
#'   JobName = "string"
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job in question.
#'
#' @export
reset_job_bookmark <- function (JobName) 
{
    op <- new_operation(name = "ResetJobBookmark", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- reset_job_bookmark_input(JobName = JobName)
    output <- reset_job_bookmark_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Starts a crawl using the specified crawler, regardless of what is scheduled
#'
#' Starts a crawl using the specified crawler, regardless of what is scheduled. If the crawler is already running, returns a [CrawlerRunningException](https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-exceptions.html#aws-glue-api-exceptions-CrawlerRunningException).
#'
#' @section Accepted Parameters:
#' ```
#' start_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the crawler to start.
#'
#' @export
start_crawler <- function (Name) 
{
    op <- new_operation(name = "StartCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- start_crawler_input(Name = Name)
    output <- start_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Changes the schedule state of the specified crawler to SCHEDULED, unless the crawler is already running or the schedule state is already SCHEDULED
#'
#' Changes the schedule state of the specified crawler to `SCHEDULED`, unless the crawler is already running or the schedule state is already `SCHEDULED`.
#'
#' @section Accepted Parameters:
#' ```
#' start_crawler_schedule(
#'   CrawlerName = "string"
#' )
#' ```
#'
#' @param CrawlerName &#91;required&#93; Name of the crawler to schedule.
#'
#' @export
start_crawler_schedule <- function (CrawlerName) 
{
    op <- new_operation(name = "StartCrawlerSchedule", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- start_crawler_schedule_input(CrawlerName = CrawlerName)
    output <- start_crawler_schedule_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Starts a job run using a job definition
#'
#' Starts a job run using a job definition.
#'
#' @section Accepted Parameters:
#' ```
#' start_job_run(
#'   JobName = "string",
#'   JobRunId = "string",
#'   Arguments = list(
#'     "string"
#'   ),
#'   AllocatedCapacity = 123,
#'   Timeout = 123,
#'   MaxCapacity = 123.0,
#'   NotificationProperty = list(
#'     NotifyDelayAfter = 123
#'   ),
#'   SecurityConfiguration = "string"
#' )
#' ```
#'
#' @param JobName &#91;required&#93; The name of the job definition to use.
#' @param JobRunId The ID of a previous JobRun to retry.
#' @param Arguments The job arguments specifically for this run. They override the equivalent default arguments set for in the job definition itself.
#' 
#' You can specify arguments here that your own job-execution script consumes, as well as arguments that AWS Glue itself consumes.
#' 
#' For information about how to specify and consume your own Job arguments, see the [Calling AWS Glue APIs in Python](http://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-calling.html) topic in the developer guide.
#' 
#' For information about the key-value pairs that AWS Glue consumes to set up your job, see the [Special Parameters Used by AWS Glue](http://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-etl-glue-arguments.html) topic in the developer guide.
#' @param AllocatedCapacity This field is deprecated, use `MaxCapacity` instead.
#' 
#' The number of AWS Glue data processing units (DPUs) to allocate to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see the [AWS Glue pricing page](https://aws.amazon.com/glue/pricing/).
#' @param Timeout The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before it is terminated and enters `TIMEOUT` status. The default is 2,880 minutes (48 hours). This overrides the timeout value set in the parent job.
#' @param MaxCapacity AWS Glue supports running jobs on a `JobCommand.Name`=\"pythonshell\" with allocated processing as low as 0.0625 DPU, which can be specified using `MaxCapacity`. Glue ETL jobs running in any other way cannot have fractional DPU allocations.
#' @param NotificationProperty Specifies configuration properties of a job run notification.
#' @param SecurityConfiguration The name of the SecurityConfiguration structure to be used with this job run.
#'
#' @export
start_job_run <- function (JobName, JobRunId = NULL, Arguments = NULL, 
    AllocatedCapacity = NULL, Timeout = NULL, MaxCapacity = NULL, 
    NotificationProperty = NULL, SecurityConfiguration = NULL) 
{
    op <- new_operation(name = "StartJobRun", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- start_job_run_input(JobName = JobName, JobRunId = JobRunId, 
        Arguments = Arguments, AllocatedCapacity = AllocatedCapacity, 
        Timeout = Timeout, MaxCapacity = MaxCapacity, NotificationProperty = NotificationProperty, 
        SecurityConfiguration = SecurityConfiguration)
    output <- start_job_run_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Starts an existing trigger
#'
#' Starts an existing trigger. See [Triggering Jobs](http://docs.aws.amazon.com/glue/latest/dg/trigger-job.html) for information about how different types of trigger are started.
#'
#' @section Accepted Parameters:
#' ```
#' start_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger to start.
#'
#' @export
start_trigger <- function (Name) 
{
    op <- new_operation(name = "StartTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- start_trigger_input(Name = Name)
    output <- start_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' If the specified crawler is running, stops the crawl
#'
#' If the specified crawler is running, stops the crawl.
#'
#' @section Accepted Parameters:
#' ```
#' stop_crawler(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the crawler to stop.
#'
#' @export
stop_crawler <- function (Name) 
{
    op <- new_operation(name = "StopCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- stop_crawler_input(Name = Name)
    output <- stop_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Sets the schedule state of the specified crawler to NOT_SCHEDULED, but does not stop the crawler if it is already running
#'
#' Sets the schedule state of the specified crawler to `NOT_SCHEDULED`, but does not stop the crawler if it is already running.
#'
#' @section Accepted Parameters:
#' ```
#' stop_crawler_schedule(
#'   CrawlerName = "string"
#' )
#' ```
#'
#' @param CrawlerName &#91;required&#93; Name of the crawler whose schedule state to set.
#'
#' @export
stop_crawler_schedule <- function (CrawlerName) 
{
    op <- new_operation(name = "StopCrawlerSchedule", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- stop_crawler_schedule_input(CrawlerName = CrawlerName)
    output <- stop_crawler_schedule_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Stops a specified trigger
#'
#' Stops a specified trigger.
#'
#' @section Accepted Parameters:
#' ```
#' stop_trigger(
#'   Name = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger to stop.
#'
#' @export
stop_trigger <- function (Name) 
{
    op <- new_operation(name = "StopTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- stop_trigger_input(Name = Name)
    output <- stop_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Modifies an existing classifier (a GrokClassifier, XMLClassifier, or JsonClassifier, depending on which field is present)
#'
#' Modifies an existing classifier (a `GrokClassifier`, `XMLClassifier`, or `JsonClassifier`, depending on which field is present).
#'
#' @section Accepted Parameters:
#' ```
#' update_classifier(
#'   GrokClassifier = list(
#'     Name = "string",
#'     Classification = "string",
#'     GrokPattern = "string",
#'     CustomPatterns = "string"
#'   ),
#'   XMLClassifier = list(
#'     Name = "string",
#'     Classification = "string",
#'     RowTag = "string"
#'   ),
#'   JsonClassifier = list(
#'     Name = "string",
#'     JsonPath = "string"
#'   )
#' )
#' ```
#'
#' @param GrokClassifier A `GrokClassifier` object with updated fields.
#' @param XMLClassifier An `XMLClassifier` object with updated fields.
#' @param JsonClassifier A `JsonClassifier` object with updated fields.
#'
#' @export
update_classifier <- function (GrokClassifier = NULL, XMLClassifier = NULL, 
    JsonClassifier = NULL) 
{
    op <- new_operation(name = "UpdateClassifier", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_classifier_input(GrokClassifier = GrokClassifier, 
        XMLClassifier = XMLClassifier, JsonClassifier = JsonClassifier)
    output <- update_classifier_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a connection definition in the Data Catalog
#'
#' Updates a connection definition in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' update_connection(
#'   CatalogId = "string",
#'   Name = "string",
#'   ConnectionInput = list(
#'     Name = "string",
#'     Description = "string",
#'     ConnectionType = "JDBC"|"SFTP",
#'     MatchCriteria = list(
#'       "string"
#'     ),
#'     ConnectionProperties = list(
#'       "string"
#'     ),
#'     PhysicalConnectionRequirements = list(
#'       SubnetId = "string",
#'       SecurityGroupIdList = list(
#'         "string"
#'       ),
#'       AvailabilityZone = "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.
#' @param Name &#91;required&#93; The name of the connection definition to update.
#' @param ConnectionInput &#91;required&#93; A `ConnectionInput` object that redefines the connection in question.
#'
#' @export
update_connection <- function (CatalogId = NULL, Name, ConnectionInput) 
{
    op <- new_operation(name = "UpdateConnection", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_connection_input(CatalogId = CatalogId, Name = Name, 
        ConnectionInput = ConnectionInput)
    output <- update_connection_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a crawler
#'
#' Updates a crawler. If a crawler is running, you must stop it using `StopCrawler` before updating it.
#'
#' @section Accepted Parameters:
#' ```
#' update_crawler(
#'   Name = "string",
#'   Role = "string",
#'   DatabaseName = "string",
#'   Description = "string",
#'   Targets = list(
#'     S3Targets = list(
#'       list(
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     JdbcTargets = list(
#'       list(
#'         ConnectionName = "string",
#'         Path = "string",
#'         Exclusions = list(
#'           "string"
#'         )
#'       )
#'     ),
#'     DynamoDBTargets = list(
#'       list(
#'         Path = "string"
#'       )
#'     )
#'   ),
#'   Schedule = "string",
#'   Classifiers = list(
#'     "string"
#'   ),
#'   TablePrefix = "string",
#'   SchemaChangePolicy = list(
#'     UpdateBehavior = "LOG"|"UPDATE_IN_DATABASE",
#'     DeleteBehavior = "LOG"|"DELETE_FROM_DATABASE"|"DEPRECATE_IN_DATABASE"
#'   ),
#'   Configuration = "string",
#'   CrawlerSecurityConfiguration = "string"
#' )
#' ```
#'
#' @param Name &#91;required&#93; Name of the new crawler.
#' @param Role The IAM role (or ARN of an IAM role) used by the new crawler to access customer resources.
#' @param DatabaseName The AWS Glue database where results are stored, such as: `arn:aws:daylight:us-east-1::database/sometable/*`.
#' @param Description A description of the new crawler.
#' @param Targets A list of targets to crawl.
#' @param Schedule A `cron` expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](http://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: `cron(15 12 * * ? *)`.
#' @param Classifiers A list of custom classifiers that the user has registered. By default, all built-in classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.
#' @param TablePrefix The table prefix used for catalog tables that are created.
#' @param SchemaChangePolicy Policy for the crawler\'s update and deletion behavior.
#' @param Configuration Crawler configuration information. This versioned JSON string allows users to specify aspects of a crawler\'s behavior. For more information, see [Configuring a Crawler](http://docs.aws.amazon.com/glue/latest/dg/crawler-configuration.html).
#' @param CrawlerSecurityConfiguration The name of the SecurityConfiguration structure to be used by this Crawler.
#'
#' @export
update_crawler <- function (Name, Role = NULL, DatabaseName = NULL, 
    Description = NULL, Targets = NULL, Schedule = NULL, Classifiers = NULL, 
    TablePrefix = NULL, SchemaChangePolicy = NULL, Configuration = NULL, 
    CrawlerSecurityConfiguration = NULL) 
{
    op <- new_operation(name = "UpdateCrawler", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_crawler_input(Name = Name, Role = Role, DatabaseName = DatabaseName, 
        Description = Description, Targets = Targets, Schedule = Schedule, 
        Classifiers = Classifiers, TablePrefix = TablePrefix, 
        SchemaChangePolicy = SchemaChangePolicy, Configuration = Configuration, 
        CrawlerSecurityConfiguration = CrawlerSecurityConfiguration)
    output <- update_crawler_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates the schedule of a crawler using a cron expression
#'
#' Updates the schedule of a crawler using a `cron` expression.
#'
#' @section Accepted Parameters:
#' ```
#' update_crawler_schedule(
#'   CrawlerName = "string",
#'   Schedule = "string"
#' )
#' ```
#'
#' @param CrawlerName &#91;required&#93; Name of the crawler whose schedule to update.
#' @param Schedule The updated `cron` expression used to specify the schedule (see [Time-Based Schedules for Jobs and Crawlers](http://docs.aws.amazon.com/glue/latest/dg/monitor-data-warehouse-schedule.html). For example, to run something every day at 12:15 UTC, you would specify: `cron(15 12 * * ? *)`.
#'
#' @export
update_crawler_schedule <- function (CrawlerName, Schedule = NULL) 
{
    op <- new_operation(name = "UpdateCrawlerSchedule", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_crawler_schedule_input(CrawlerName = CrawlerName, 
        Schedule = Schedule)
    output <- update_crawler_schedule_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing database definition in a Data Catalog
#'
#' Updates an existing database definition in a Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' update_database(
#'   CatalogId = "string",
#'   Name = "string",
#'   DatabaseInput = list(
#'     Name = "string",
#'     Description = "string",
#'     LocationUri = "string",
#'     Parameters = list(
#'       "string"
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog in which the metadata database resides. If none is supplied, the AWS account ID is used by default.
#' @param Name &#91;required&#93; The name of the database to update in the catalog. For Hive compatibility, this is folded to lowercase.
#' @param DatabaseInput &#91;required&#93; A `DatabaseInput` object specifying the new definition of the metadata database in the catalog.
#'
#' @export
update_database <- function (CatalogId = NULL, Name, DatabaseInput) 
{
    op <- new_operation(name = "UpdateDatabase", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_database_input(CatalogId = CatalogId, Name = Name, 
        DatabaseInput = DatabaseInput)
    output <- update_database_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a specified DevEndpoint
#'
#' Updates a specified DevEndpoint.
#'
#' @section Accepted Parameters:
#' ```
#' update_dev_endpoint(
#'   EndpointName = "string",
#'   PublicKey = "string",
#'   AddPublicKeys = list(
#'     "string"
#'   ),
#'   DeletePublicKeys = list(
#'     "string"
#'   ),
#'   CustomLibraries = list(
#'     ExtraPythonLibsS3Path = "string",
#'     ExtraJarsS3Path = "string"
#'   ),
#'   UpdateEtlLibraries = TRUE|FALSE
#' )
#' ```
#'
#' @param EndpointName &#91;required&#93; The name of the DevEndpoint to be updated.
#' @param PublicKey The public key for the DevEndpoint to use.
#' @param AddPublicKeys The list of public keys for the DevEndpoint to use.
#' @param DeletePublicKeys The list of public keys to be deleted from the DevEndpoint.
#' @param CustomLibraries Custom Python or Java libraries to be loaded in the DevEndpoint.
#' @param UpdateEtlLibraries True if the list of custom libraries to be loaded in the development endpoint needs to be updated, or False otherwise.
#'
#' @export
update_dev_endpoint <- function (EndpointName, PublicKey = NULL, 
    AddPublicKeys = NULL, DeletePublicKeys = NULL, CustomLibraries = NULL, 
    UpdateEtlLibraries = NULL) 
{
    op <- new_operation(name = "UpdateDevEndpoint", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_dev_endpoint_input(EndpointName = EndpointName, 
        PublicKey = PublicKey, AddPublicKeys = AddPublicKeys, 
        DeletePublicKeys = DeletePublicKeys, CustomLibraries = CustomLibraries, 
        UpdateEtlLibraries = UpdateEtlLibraries)
    output <- update_dev_endpoint_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing job definition
#'
#' Updates an existing job definition.
#'
#' @section Accepted Parameters:
#' ```
#' update_job(
#'   JobName = "string",
#'   JobUpdate = list(
#'     Description = "string",
#'     LogUri = "string",
#'     Role = "string",
#'     ExecutionProperty = list(
#'       MaxConcurrentRuns = 123
#'     ),
#'     Command = list(
#'       Name = "string",
#'       ScriptLocation = "string"
#'     ),
#'     DefaultArguments = list(
#'       "string"
#'     ),
#'     Connections = list(
#'       Connections = list(
#'         "string"
#'       )
#'     ),
#'     MaxRetries = 123,
#'     AllocatedCapacity = 123,
#'     Timeout = 123,
#'     MaxCapacity = 123.0,
#'     NotificationProperty = list(
#'       NotifyDelayAfter = 123
#'     ),
#'     SecurityConfiguration = "string"
#'   )
#' )
#' ```
#'
#' @param JobName &#91;required&#93; Name of the job definition to update.
#' @param JobUpdate &#91;required&#93; Specifies the values with which to update the job definition.
#'
#' @export
update_job <- function (JobName, JobUpdate) 
{
    op <- new_operation(name = "UpdateJob", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_job_input(JobName = JobName, JobUpdate = JobUpdate)
    output <- update_job_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a partition
#'
#' Updates a partition.
#'
#' @section Accepted Parameters:
#' ```
#' update_partition(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableName = "string",
#'   PartitionValueList = list(
#'     "string"
#'   ),
#'   PartitionInput = list(
#'     Values = list(
#'       "string"
#'     ),
#'     LastAccessTime = as.POSIXct("2015-01-01"),
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       Location = "string",
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE
#'     ),
#'     Parameters = list(
#'       "string"
#'     ),
#'     LastAnalyzedTime = as.POSIXct("2015-01-01")
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the partition to be updated resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table in question resides.
#' @param TableName &#91;required&#93; The name of the table where the partition to be updated is located.
#' @param PartitionValueList &#91;required&#93; A list of the values defining the partition.
#' @param PartitionInput &#91;required&#93; The new partition object to which to update the partition.
#'
#' @export
update_partition <- function (CatalogId = NULL, DatabaseName, 
    TableName, PartitionValueList, PartitionInput) 
{
    op <- new_operation(name = "UpdatePartition", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_partition_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableName = TableName, PartitionValueList = PartitionValueList, 
        PartitionInput = PartitionInput)
    output <- update_partition_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a metadata table in the Data Catalog
#'
#' Updates a metadata table in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' update_table(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   TableInput = list(
#'     Name = "string",
#'     Description = "string",
#'     Owner = "string",
#'     LastAccessTime = as.POSIXct("2015-01-01"),
#'     LastAnalyzedTime = as.POSIXct("2015-01-01"),
#'     Retention = 123,
#'     StorageDescriptor = list(
#'       Columns = list(
#'         list(
#'           Name = "string",
#'           Type = "string",
#'           Comment = "string"
#'         )
#'       ),
#'       Location = "string",
#'       InputFormat = "string",
#'       OutputFormat = "string",
#'       Compressed = TRUE|FALSE,
#'       NumberOfBuckets = 123,
#'       SerdeInfo = list(
#'         Name = "string",
#'         SerializationLibrary = "string",
#'         Parameters = list(
#'           "string"
#'         )
#'       ),
#'       BucketColumns = list(
#'         "string"
#'       ),
#'       SortColumns = list(
#'         list(
#'           Column = "string",
#'           SortOrder = 123
#'         )
#'       ),
#'       Parameters = list(
#'         "string"
#'       ),
#'       SkewedInfo = list(
#'         SkewedColumnNames = list(
#'           "string"
#'         ),
#'         SkewedColumnValues = list(
#'           "string"
#'         ),
#'         SkewedColumnValueLocationMaps = list(
#'           "string"
#'         )
#'       ),
#'       StoredAsSubDirectories = TRUE|FALSE
#'     ),
#'     PartitionKeys = list(
#'       list(
#'         Name = "string",
#'         Type = "string",
#'         Comment = "string"
#'       )
#'     ),
#'     ViewOriginalText = "string",
#'     ViewExpandedText = "string",
#'     TableType = "string",
#'     Parameters = list(
#'       "string"
#'     )
#'   ),
#'   SkipArchive = TRUE|FALSE
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database in which the table resides. For Hive compatibility, this name is entirely lowercase.
#' @param TableInput &#91;required&#93; An updated `TableInput` object to define the metadata table in the catalog.
#' @param SkipArchive By default, `UpdateTable` always creates an archived version of the table before updating it. If `skipArchive` is set to true, however, `UpdateTable` does not create the archived version.
#'
#' @export
update_table <- function (CatalogId = NULL, DatabaseName, TableInput, 
    SkipArchive = NULL) 
{
    op <- new_operation(name = "UpdateTable", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_table_input(CatalogId = CatalogId, DatabaseName = DatabaseName, 
        TableInput = TableInput, SkipArchive = SkipArchive)
    output <- update_table_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates a trigger definition
#'
#' Updates a trigger definition.
#'
#' @section Accepted Parameters:
#' ```
#' update_trigger(
#'   Name = "string",
#'   TriggerUpdate = list(
#'     Name = "string",
#'     Description = "string",
#'     Schedule = "string",
#'     Actions = list(
#'       list(
#'         JobName = "string",
#'         Arguments = list(
#'           "string"
#'         ),
#'         Timeout = 123,
#'         NotificationProperty = list(
#'           NotifyDelayAfter = 123
#'         ),
#'         SecurityConfiguration = "string"
#'       )
#'     ),
#'     Predicate = list(
#'       Logical = "AND"|"ANY",
#'       Conditions = list(
#'         list(
#'           LogicalOperator = "EQUALS",
#'           JobName = "string",
#'           State = "STARTING"|"RUNNING"|"STOPPING"|"STOPPED"|"SUCCEEDED"|"FAILED"|"TIMEOUT"
#'         )
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param Name &#91;required&#93; The name of the trigger to update.
#' @param TriggerUpdate &#91;required&#93; The new values with which to update the trigger.
#'
#' @export
update_trigger <- function (Name, TriggerUpdate) 
{
    op <- new_operation(name = "UpdateTrigger", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_trigger_input(Name = Name, TriggerUpdate = TriggerUpdate)
    output <- update_trigger_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing function definition in the Data Catalog
#'
#' Updates an existing function definition in the Data Catalog.
#'
#' @section Accepted Parameters:
#' ```
#' update_user_defined_function(
#'   CatalogId = "string",
#'   DatabaseName = "string",
#'   FunctionName = "string",
#'   FunctionInput = list(
#'     FunctionName = "string",
#'     ClassName = "string",
#'     OwnerName = "string",
#'     OwnerType = "USER"|"ROLE"|"GROUP",
#'     ResourceUris = list(
#'       list(
#'         ResourceType = "JAR"|"FILE"|"ARCHIVE",
#'         Uri = "string"
#'       )
#'     )
#'   )
#' )
#' ```
#'
#' @param CatalogId The ID of the Data Catalog where the function to be updated is located. If none is supplied, the AWS account ID is used by default.
#' @param DatabaseName &#91;required&#93; The name of the catalog database where the function to be updated is located.
#' @param FunctionName &#91;required&#93; The name of the function.
#' @param FunctionInput &#91;required&#93; A `FunctionInput` object that re-defines the function in the Data Catalog.
#'
#' @export
update_user_defined_function <- function (CatalogId = NULL, DatabaseName, 
    FunctionName, FunctionInput) 
{
    op <- new_operation(name = "UpdateUserDefinedFunction", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- update_user_defined_function_input(CatalogId = CatalogId, 
        DatabaseName = DatabaseName, FunctionName = FunctionName, 
        FunctionInput = FunctionInput)
    output <- update_user_defined_function_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

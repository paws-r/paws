# This file is generated by make.paws. Please do not edit here.

#' @importFrom paws.common populate
NULL

accept_match_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        PlayerIds = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "list")), 
        AcceptanceType = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT", "REJECT")))), tags = list(type = "structure"))
    return(populate(args, shape))
}

accept_match_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_alias_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L, pattern = ".*\\S.*")), Description = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_alias_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Alias = structure(list(AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L, pattern = ".*\\S.*")), AliasArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), Description = structure(logical(0), 
            tags = list(type = "string")), RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_build_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L)), Version = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        StorageLocation = structure(list(Bucket = structure(logical(0), 
            tags = list(type = "string", min = 1L)), Key = structure(logical(0), 
            tags = list(type = "string", min = 1L)), RoleArn = structure(logical(0), 
            tags = list(type = "string", min = 1L))), tags = list(type = "structure")), 
        OperatingSystem = structure(logical(0), tags = list(type = "string", 
            enum = c("WINDOWS_2012", "AMAZON_LINUX")))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_build_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Build = structure(list(BuildId = structure(logical(0), 
        tags = list(type = "string", pattern = "^build-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string")), 
        Version = structure(logical(0), tags = list(type = "string")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("INITIALIZED", "READY", "FAILED"))), SizeOnDisk = structure(logical(0), 
            tags = list(type = "long", min = 1L)), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure")), 
        UploadCredentials = structure(list(AccessKeyId = structure(logical(0), 
            tags = list(type = "string", min = 1L)), SecretAccessKey = structure(logical(0), 
            tags = list(type = "string", min = 1L)), SessionToken = structure(logical(0), 
            tags = list(type = "string", min = 1L))), tags = list(type = "structure", 
            sensitive = TRUE)), StorageLocation = structure(list(Bucket = structure(logical(0), 
            tags = list(type = "string", min = 1L)), Key = structure(logical(0), 
            tags = list(type = "string", min = 1L)), RoleArn = structure(logical(0), 
            tags = list(type = "string", min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_fleet_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L)), Description = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        BuildId = structure(logical(0), tags = list(type = "string", 
            pattern = "^build-\\S+")), ServerLaunchPath = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        ServerLaunchParameters = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), LogPaths = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L))), 
            tags = list(type = "list")), EC2InstanceType = structure(logical(0), 
            tags = list(type = "string", enum = c("t2.micro", 
                "t2.small", "t2.medium", "t2.large", "c3.large", 
                "c3.xlarge", "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", 
                "c4.large", "c4.xlarge", "c4.2xlarge", "c4.4xlarge", 
                "c4.8xlarge", "r3.large", "r3.xlarge", "r3.2xlarge", 
                "r3.4xlarge", "r3.8xlarge", "r4.large", "r4.xlarge", 
                "r4.2xlarge", "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", 
                "m3.medium", "m3.large", "m3.xlarge", "m3.2xlarge", 
                "m4.large", "m4.xlarge", "m4.2xlarge", "m4.4xlarge", 
                "m4.10xlarge"))), EC2InboundPermissions = structure(list(structure(list(FromPort = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
            ToPort = structure(logical(0), tags = list(type = "integer", 
                max = 60000L, min = 1L)), IpRange = structure(logical(0), 
                tags = list(type = "string", pattern = "[^\\s]+")), 
            Protocol = structure(logical(0), tags = list(type = "string", 
                enum = c("TCP", "UDP")))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 50L)), NewGameSessionProtectionPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("NoProtection", 
                "FullProtection"))), RuntimeConfiguration = structure(list(ServerProcesses = structure(list(structure(list(LaunchPath = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            Parameters = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L)), ConcurrentExecutions = structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 50L, min = 1L)), 
            MaxConcurrentGameSessionActivations = structure(logical(0), 
                tags = list(type = "integer", max = 2147483647L, 
                  min = 1L)), GameSessionActivationTimeoutSeconds = structure(logical(0), 
                tags = list(type = "integer", max = 600L, min = 1L))), 
            tags = list(type = "structure")), ResourceCreationLimitPolicy = structure(list(NewGameSessionsPerCreator = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyPeriodInMinutes = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure")), 
        MetricGroups = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 255L, min = 1L))), tags = list(type = "list", 
            max = 1L)), PeerVpcAwsAccountId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetType = structure(logical(0), 
            tags = list(type = "string", enum = c("ON_DEMAND", 
                "SPOT")))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_fleet_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetAttributes = structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        FleetArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        FleetType = structure(logical(0), tags = list(type = "string", 
            enum = c("ON_DEMAND", "SPOT"))), InstanceType = structure(logical(0), 
            tags = list(type = "string", enum = c("t2.micro", 
                "t2.small", "t2.medium", "t2.large", "c3.large", 
                "c3.xlarge", "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", 
                "c4.large", "c4.xlarge", "c4.2xlarge", "c4.4xlarge", 
                "c4.8xlarge", "r3.large", "r3.xlarge", "r3.2xlarge", 
                "r3.4xlarge", "r3.8xlarge", "r4.large", "r4.xlarge", 
                "r4.2xlarge", "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", 
                "m3.medium", "m3.large", "m3.xlarge", "m3.2xlarge", 
                "m4.large", "m4.xlarge", "m4.2xlarge", "m4.4xlarge", 
                "m4.10xlarge"))), Description = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), TerminationTime = structure(logical(0), 
            tags = list(type = "timestamp")), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("NEW", "DOWNLOADING", 
                "VALIDATING", "BUILDING", "ACTIVATING", "ACTIVE", 
                "DELETING", "ERROR", "TERMINATED"))), BuildId = structure(logical(0), 
            tags = list(type = "string", pattern = "^build-\\S+")), 
        ServerLaunchPath = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), ServerLaunchParameters = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        LogPaths = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "list")), 
        NewGameSessionProtectionPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("NoProtection", 
                "FullProtection"))), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), ResourceCreationLimitPolicy = structure(list(NewGameSessionsPerCreator = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyPeriodInMinutes = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure")), 
        MetricGroups = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 255L, min = 1L))), tags = list(type = "list", 
            max = 1L)), StoppedActions = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = "AUTO_SCALING"))), 
            tags = list(type = "list", max = 1L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_game_session_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        MaximumPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionId = structure(logical(0), tags = list(type = "string", 
            max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        IdempotencyToken = structure(logical(0), tags = list(type = "string", 
            max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_game_session_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSession = structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetId = structure(logical(0), 
            tags = list(type = "string", pattern = "^fleet-\\S+")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        TerminationTime = structure(logical(0), tags = list(type = "timestamp")), 
        CurrentPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "ACTIVATING", 
                "TERMINATED", "TERMINATING", "ERROR"))), StatusReason = structure(logical(0), 
            tags = list(type = "string", enum = "INTERRUPTED")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerSessionCreationPolicy = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT_ALL", "DENY_ALL"))), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L)), MatchmakerData = structure(logical(0), 
            tags = list(type = "string", max = 390000L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_game_session_queue_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), TimeoutInSeconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), PlayerLatencyPolicies = structure(list(structure(list(MaximumIndividualPlayerLatencyMilliseconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), PolicyDurationSeconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
        tags = list(type = "list")), Destinations = structure(list(structure(list(DestinationArn = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+"))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_game_session_queue_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionQueue = structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        TimeoutInSeconds = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), PlayerLatencyPolicies = structure(list(structure(list(MaximumIndividualPlayerLatencyMilliseconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyDurationSeconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
            tags = list(type = "list")), Destinations = structure(list(structure(list(DestinationArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_matchmaking_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionQueueArns = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "list")), 
        RequestTimeoutSeconds = structure(logical(0), tags = list(type = "integer", 
            max = 43200L, min = 1L)), AcceptanceTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L)), 
        AcceptanceRequired = structure(logical(0), tags = list(type = "boolean")), 
        RuleSetName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        NotificationTarget = structure(logical(0), tags = list(type = "string", 
            max = 300L, min = 0L, pattern = "[a-zA-Z0-9:_/-]*")), 
        AdditionalPlayerCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), CustomEventData = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 0L)), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_matchmaking_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Configuration = structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionQueueArns = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "list")), 
        RequestTimeoutSeconds = structure(logical(0), tags = list(type = "integer", 
            max = 43200L, min = 1L)), AcceptanceTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L)), 
        AcceptanceRequired = structure(logical(0), tags = list(type = "boolean")), 
        RuleSetName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        NotificationTarget = structure(logical(0), tags = list(type = "string", 
            max = 300L, min = 0L, pattern = "[a-zA-Z0-9:_/-]*")), 
        AdditionalPlayerCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), CustomEventData = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 0L)), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_matchmaking_rule_set_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        RuleSetBody = structure(logical(0), tags = list(type = "string", 
            max = 65535L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_matchmaking_rule_set_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RuleSet = structure(list(RuleSetName = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        RuleSetBody = structure(logical(0), tags = list(type = "string", 
            max = 65535L, min = 1L)), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_player_session_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        PlayerId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerData = structure(logical(0), 
            tags = list(type = "string", max = 2048L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_player_session_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlayerSession = structure(list(PlayerSessionId = structure(logical(0), 
        tags = list(type = "string", pattern = "^psess-\\S+")), 
        PlayerId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        FleetId = structure(logical(0), tags = list(type = "string", 
            pattern = "^fleet-\\S+")), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), TerminationTime = structure(logical(0), 
            tags = list(type = "timestamp")), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("RESERVED", 
                "ACTIVE", "COMPLETED", "TIMEDOUT"))), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerData = structure(logical(0), tags = list(type = "string", 
            max = 2048L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

create_player_sessions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        PlayerIds = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "list", 
            max = 25L, min = 1L)), PlayerDataMap = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 2048L, min = 1L))), 
            tags = list(type = "map"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_player_sessions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlayerSessions = structure(list(structure(list(PlayerSessionId = structure(logical(0), 
        tags = list(type = "string", pattern = "^psess-\\S+")), 
        PlayerId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        FleetId = structure(logical(0), tags = list(type = "string", 
            pattern = "^fleet-\\S+")), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), TerminationTime = structure(logical(0), 
            tags = list(type = "timestamp")), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("RESERVED", 
                "ACTIVE", "COMPLETED", "TIMEDOUT"))), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerData = structure(logical(0), tags = list(type = "string", 
            max = 2048L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_vpc_peering_authorization_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameLiftAwsAccountId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_vpc_peering_authorization_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(VpcPeeringAuthorization = structure(list(GameLiftAwsAccountId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcAwsAccountId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PeerVpcId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        ExpirationTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_vpc_peering_connection_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), PeerVpcAwsAccountId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

create_vpc_peering_connection_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_alias_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AliasId = structure(logical(0), tags = list(type = "string", 
        pattern = "^alias-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_alias_output <- function () 
{
    return(list())
}

delete_build_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BuildId = structure(logical(0), tags = list(type = "string", 
        pattern = "^build-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_build_output <- function () 
{
    return(list())
}

delete_fleet_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_fleet_output <- function () 
{
    return(list())
}

delete_game_session_queue_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_game_session_queue_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_matchmaking_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_matchmaking_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_scaling_policy_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L)), FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_scaling_policy_output <- function () 
{
    return(list())
}

delete_vpc_peering_authorization_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameLiftAwsAccountId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_vpc_peering_authorization_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_vpc_peering_connection_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), VpcPeeringConnectionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_vpc_peering_connection_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_alias_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AliasId = structure(logical(0), tags = list(type = "string", 
        pattern = "^alias-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_alias_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Alias = structure(list(AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L, pattern = ".*\\S.*")), AliasArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), Description = structure(logical(0), 
            tags = list(type = "string")), RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_build_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BuildId = structure(logical(0), tags = list(type = "string", 
        pattern = "^build-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_build_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Build = structure(list(BuildId = structure(logical(0), 
        tags = list(type = "string", pattern = "^build-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string")), 
        Version = structure(logical(0), tags = list(type = "string")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("INITIALIZED", "READY", "FAILED"))), SizeOnDisk = structure(logical(0), 
            tags = list(type = "long", min = 1L)), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_ec2_instance_limits_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(EC2InstanceType = structure(logical(0), 
        tags = list(type = "string", enum = c("t2.micro", "t2.small", 
            "t2.medium", "t2.large", "c3.large", "c3.xlarge", 
            "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", "c4.large", 
            "c4.xlarge", "c4.2xlarge", "c4.4xlarge", "c4.8xlarge", 
            "r3.large", "r3.xlarge", "r3.2xlarge", "r3.4xlarge", 
            "r3.8xlarge", "r4.large", "r4.xlarge", "r4.2xlarge", 
            "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", "m3.medium", 
            "m3.large", "m3.xlarge", "m3.2xlarge", "m4.large", 
            "m4.xlarge", "m4.2xlarge", "m4.4xlarge", "m4.10xlarge")))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_ec2_instance_limits_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(EC2InstanceLimits = structure(list(structure(list(EC2InstanceType = structure(logical(0), 
        tags = list(type = "string", enum = c("t2.micro", "t2.small", 
            "t2.medium", "t2.large", "c3.large", "c3.xlarge", 
            "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", "c4.large", 
            "c4.xlarge", "c4.2xlarge", "c4.4xlarge", "c4.8xlarge", 
            "r3.large", "r3.xlarge", "r3.2xlarge", "r3.4xlarge", 
            "r3.8xlarge", "r4.large", "r4.xlarge", "r4.2xlarge", 
            "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", "m3.medium", 
            "m3.large", "m3.xlarge", "m3.2xlarge", "m4.large", 
            "m4.xlarge", "m4.2xlarge", "m4.4xlarge", "m4.10xlarge"))), 
        CurrentInstances = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), InstanceLimit = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_attributes_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetIds = structure(list(structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+"))), 
        tags = list(type = "list", min = 1L)), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_attributes_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetAttributes = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        FleetArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        FleetType = structure(logical(0), tags = list(type = "string", 
            enum = c("ON_DEMAND", "SPOT"))), InstanceType = structure(logical(0), 
            tags = list(type = "string", enum = c("t2.micro", 
                "t2.small", "t2.medium", "t2.large", "c3.large", 
                "c3.xlarge", "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", 
                "c4.large", "c4.xlarge", "c4.2xlarge", "c4.4xlarge", 
                "c4.8xlarge", "r3.large", "r3.xlarge", "r3.2xlarge", 
                "r3.4xlarge", "r3.8xlarge", "r4.large", "r4.xlarge", 
                "r4.2xlarge", "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", 
                "m3.medium", "m3.large", "m3.xlarge", "m3.2xlarge", 
                "m4.large", "m4.xlarge", "m4.2xlarge", "m4.4xlarge", 
                "m4.10xlarge"))), Description = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), TerminationTime = structure(logical(0), 
            tags = list(type = "timestamp")), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("NEW", "DOWNLOADING", 
                "VALIDATING", "BUILDING", "ACTIVATING", "ACTIVE", 
                "DELETING", "ERROR", "TERMINATED"))), BuildId = structure(logical(0), 
            tags = list(type = "string", pattern = "^build-\\S+")), 
        ServerLaunchPath = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), ServerLaunchParameters = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        LogPaths = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "list")), 
        NewGameSessionProtectionPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("NoProtection", 
                "FullProtection"))), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), ResourceCreationLimitPolicy = structure(list(NewGameSessionsPerCreator = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyPeriodInMinutes = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure")), 
        MetricGroups = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 255L, min = 1L))), tags = list(type = "list", 
            max = 1L)), StoppedActions = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = "AUTO_SCALING"))), 
            tags = list(type = "list", max = 1L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_capacity_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetIds = structure(list(structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+"))), 
        tags = list(type = "list", min = 1L)), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_capacity_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetCapacity = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        InstanceType = structure(logical(0), tags = list(type = "string", 
            enum = c("t2.micro", "t2.small", "t2.medium", "t2.large", 
                "c3.large", "c3.xlarge", "c3.2xlarge", "c3.4xlarge", 
                "c3.8xlarge", "c4.large", "c4.xlarge", "c4.2xlarge", 
                "c4.4xlarge", "c4.8xlarge", "r3.large", "r3.xlarge", 
                "r3.2xlarge", "r3.4xlarge", "r3.8xlarge", "r4.large", 
                "r4.xlarge", "r4.2xlarge", "r4.4xlarge", "r4.8xlarge", 
                "r4.16xlarge", "m3.medium", "m3.large", "m3.xlarge", 
                "m3.2xlarge", "m4.large", "m4.xlarge", "m4.2xlarge", 
                "m4.4xlarge", "m4.10xlarge"))), InstanceCounts = structure(list(DESIRED = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), MINIMUM = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), MAXIMUM = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PENDING = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), ACTIVE = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), IDLE = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), TERMINATING = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_events_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), StartTime = structure(logical(0), 
        tags = list(type = "timestamp")), EndTime = structure(logical(0), 
        tags = list(type = "timestamp")), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_events_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Events = structure(list(structure(list(EventId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), EventCode = structure(logical(0), 
            tags = list(type = "string", enum = c("GENERIC_EVENT", 
                "FLEET_CREATED", "FLEET_DELETED", "FLEET_SCALING_EVENT", 
                "FLEET_STATE_DOWNLOADING", "FLEET_STATE_VALIDATING", 
                "FLEET_STATE_BUILDING", "FLEET_STATE_ACTIVATING", 
                "FLEET_STATE_ACTIVE", "FLEET_STATE_ERROR", "FLEET_INITIALIZATION_FAILED", 
                "FLEET_BINARY_DOWNLOAD_FAILED", "FLEET_VALIDATION_LAUNCH_PATH_NOT_FOUND", 
                "FLEET_VALIDATION_EXECUTABLE_RUNTIME_FAILURE", 
                "FLEET_VALIDATION_TIMED_OUT", "FLEET_ACTIVATION_FAILED", 
                "FLEET_ACTIVATION_FAILED_NO_INSTANCES", "FLEET_NEW_GAME_SESSION_PROTECTION_POLICY_UPDATED", 
                "SERVER_PROCESS_INVALID_PATH", "SERVER_PROCESS_SDK_INITIALIZATION_TIMEOUT", 
                "SERVER_PROCESS_PROCESS_READY_TIMEOUT", "SERVER_PROCESS_CRASHED", 
                "SERVER_PROCESS_TERMINATED_UNHEALTHY", "SERVER_PROCESS_FORCE_TERMINATED", 
                "SERVER_PROCESS_PROCESS_EXIT_TIMEOUT", "GAME_SESSION_ACTIVATION_TIMEOUT", 
                "FLEET_CREATION_EXTRACTING_BUILD", "FLEET_CREATION_RUNNING_INSTALLER", 
                "FLEET_CREATION_VALIDATING_RUNTIME_CONFIG", "FLEET_VPC_PEERING_SUCCEEDED", 
                "FLEET_VPC_PEERING_FAILED", "FLEET_VPC_PEERING_DELETED", 
                "INSTANCE_INTERRUPTED"))), Message = structure(logical(0), 
            tags = list(type = "string", min = 1L)), EventTime = structure(logical(0), 
            tags = list(type = "timestamp")), PreSignedLogUrl = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_port_settings_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_port_settings_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(InboundPermissions = structure(list(structure(list(FromPort = structure(logical(0), 
        tags = list(type = "integer", max = 60000L, min = 1L)), 
        ToPort = structure(logical(0), tags = list(type = "integer", 
            max = 60000L, min = 1L)), IpRange = structure(logical(0), 
            tags = list(type = "string", pattern = "[^\\s]+")), 
        Protocol = structure(logical(0), tags = list(type = "string", 
            enum = c("TCP", "UDP")))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_utilization_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetIds = structure(list(structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+"))), 
        tags = list(type = "list", min = 1L)), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_fleet_utilization_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetUtilization = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        ActiveServerProcessCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), ActiveGameSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), CurrentPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_details_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        AliasId = structure(logical(0), tags = list(type = "string", 
            pattern = "^alias-\\S+")), StatusFilter = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_details_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionDetails = structure(list(structure(list(GameSession = structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetId = structure(logical(0), 
            tags = list(type = "string", pattern = "^fleet-\\S+")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        TerminationTime = structure(logical(0), tags = list(type = "timestamp")), 
        CurrentPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "ACTIVATING", 
                "TERMINATED", "TERMINATING", "ERROR"))), StatusReason = structure(logical(0), 
            tags = list(type = "string", enum = "INTERRUPTED")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerSessionCreationPolicy = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT_ALL", "DENY_ALL"))), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L)), MatchmakerData = structure(logical(0), 
            tags = list(type = "string", max = 390000L, min = 1L))), 
        tags = list(type = "structure")), ProtectionPolicy = structure(logical(0), 
        tags = list(type = "string", enum = c("NoProtection", 
            "FullProtection")))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_placement_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_placement_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionPlacement = structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("PENDING", "FULFILLED", "CANCELLED", "TIMED_OUT"))), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), GameSessionName = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionRegion = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerLatencies = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            RegionIdentifier = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L)), LatencyInMilliseconds = structure(logical(0), 
                tags = list(type = "float"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlacedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L)), 
        MatchmakerData = structure(logical(0), tags = list(type = "string", 
            max = 390000L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_queues_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Names = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+"))), 
        tags = list(type = "list")), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_session_queues_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionQueues = structure(list(structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        TimeoutInSeconds = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), PlayerLatencyPolicies = structure(list(structure(list(MaximumIndividualPlayerLatencyMilliseconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyDurationSeconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
            tags = list(type = "list")), Destinations = structure(list(structure(list(DestinationArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_sessions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        AliasId = structure(logical(0), tags = list(type = "string", 
            pattern = "^alias-\\S+")), StatusFilter = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_game_sessions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessions = structure(list(structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetId = structure(logical(0), 
            tags = list(type = "string", pattern = "^fleet-\\S+")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        TerminationTime = structure(logical(0), tags = list(type = "timestamp")), 
        CurrentPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "ACTIVATING", 
                "TERMINATED", "TERMINATING", "ERROR"))), StatusReason = structure(logical(0), 
            tags = list(type = "string", enum = "INTERRUPTED")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerSessionCreationPolicy = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT_ALL", "DENY_ALL"))), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L)), MatchmakerData = structure(logical(0), 
            tags = list(type = "string", max = 390000L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_instances_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), InstanceId = structure(logical(0), 
        tags = list(type = "string", pattern = "[a-zA-Z0-9\\.-]+")), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_instances_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Instances = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        InstanceId = structure(logical(0), tags = list(type = "string", 
            pattern = "[a-zA-Z0-9\\.-]+")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), Type = structure(logical(0), 
            tags = list(type = "string", enum = c("t2.micro", 
                "t2.small", "t2.medium", "t2.large", "c3.large", 
                "c3.xlarge", "c3.2xlarge", "c3.4xlarge", "c3.8xlarge", 
                "c4.large", "c4.xlarge", "c4.2xlarge", "c4.4xlarge", 
                "c4.8xlarge", "r3.large", "r3.xlarge", "r3.2xlarge", 
                "r3.4xlarge", "r3.8xlarge", "r4.large", "r4.xlarge", 
                "r4.2xlarge", "r4.4xlarge", "r4.8xlarge", "r4.16xlarge", 
                "m3.medium", "m3.large", "m3.xlarge", "m3.2xlarge", 
                "m4.large", "m4.xlarge", "m4.2xlarge", "m4.4xlarge", 
                "m4.10xlarge"))), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("PENDING", 
                "ACTIVE", "TERMINATING"))), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketIds = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketList = structure(list(structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        ConfigurationName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("CANCELLED", "COMPLETED", "FAILED", "PLACING", 
                "QUEUED", "REQUIRES_ACCEPTANCE", "SEARCHING", 
                "TIMED_OUT"))), StatusReason = structure(logical(0), 
            tags = list(type = "string")), StatusMessage = structure(logical(0), 
            tags = list(type = "string")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), Players = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerAttributes = structure(list(structure(list(S = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
                N = structure(logical(0), tags = list(type = "double")), 
                SL = structure(list(structure(logical(0), tags = list(type = "string", 
                  max = 1024L, min = 1L))), tags = list(type = "list")), 
                SDM = structure(list(structure(logical(0), tags = list(type = "double"))), 
                  tags = list(type = "map"))), tags = list(type = "structure"))), 
                tags = list(type = "map")), Team = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
            LatencyInMs = structure(list(structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "map"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        GameSessionConnectionInfo = structure(list(GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", min = 1L)), MatchedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure")), 
        EstimatedWaitTime = structure(logical(0), tags = list(type = "integer", 
            min = 0L))), tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_configurations_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Names = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+"))), 
        tags = list(type = "list")), RuleSetName = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_configurations_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Configurations = structure(list(structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionQueueArns = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "list")), 
        RequestTimeoutSeconds = structure(logical(0), tags = list(type = "integer", 
            max = 43200L, min = 1L)), AcceptanceTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L)), 
        AcceptanceRequired = structure(logical(0), tags = list(type = "boolean")), 
        RuleSetName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        NotificationTarget = structure(logical(0), tags = list(type = "string", 
            max = 300L, min = 0L, pattern = "[a-zA-Z0-9:_/-]*")), 
        AdditionalPlayerCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), CustomEventData = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 0L)), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_rule_sets_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Names = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+"))), 
        tags = list(type = "list", max = 10L, min = 1L)), Limit = structure(logical(0), 
        tags = list(type = "integer", max = 10L, min = 1L)), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_matchmaking_rule_sets_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RuleSets = structure(list(structure(list(RuleSetName = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        RuleSetBody = structure(logical(0), tags = list(type = "string", 
            max = 65535L, min = 1L)), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_player_sessions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        PlayerId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerSessionId = structure(logical(0), 
            tags = list(type = "string", pattern = "^psess-\\S+")), 
        PlayerSessionStatusFilter = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), Limit = structure(logical(0), 
            tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_player_sessions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlayerSessions = structure(list(structure(list(PlayerSessionId = structure(logical(0), 
        tags = list(type = "string", pattern = "^psess-\\S+")), 
        PlayerId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        FleetId = structure(logical(0), tags = list(type = "string", 
            pattern = "^fleet-\\S+")), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), TerminationTime = structure(logical(0), 
            tags = list(type = "timestamp")), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("RESERVED", 
                "ACTIVE", "COMPLETED", "TIMEDOUT"))), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerData = structure(logical(0), tags = list(type = "string", 
            max = 2048L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_runtime_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_runtime_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RuntimeConfiguration = structure(list(ServerProcesses = structure(list(structure(list(LaunchPath = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Parameters = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), ConcurrentExecutions = structure(logical(0), 
            tags = list(type = "integer", min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L, min = 1L)), MaxConcurrentGameSessionActivations = structure(logical(0), 
        tags = list(type = "integer", max = 2147483647L, min = 1L)), 
        GameSessionActivationTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_scaling_policies_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), StatusFilter = structure(logical(0), 
        tags = list(type = "string", enum = c("ACTIVE", "UPDATE_REQUESTED", 
            "UPDATING", "DELETE_REQUESTED", "DELETING", "DELETED", 
            "ERROR"))), Limit = structure(logical(0), tags = list(type = "integer", 
        min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_scaling_policies_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ScalingPolicies = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "UPDATE_REQUESTED", 
                "UPDATING", "DELETE_REQUESTED", "DELETING", "DELETED", 
                "ERROR"))), ScalingAdjustment = structure(logical(0), 
            tags = list(type = "integer")), ScalingAdjustmentType = structure(logical(0), 
            tags = list(type = "string", enum = c("ChangeInCapacity", 
                "ExactCapacity", "PercentChangeInCapacity"))), 
        ComparisonOperator = structure(logical(0), tags = list(type = "string", 
            enum = c("GreaterThanOrEqualToThreshold", "GreaterThanThreshold", 
                "LessThanThreshold", "LessThanOrEqualToThreshold"))), 
        Threshold = structure(logical(0), tags = list(type = "double")), 
        EvaluationPeriods = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), MetricName = structure(logical(0), tags = list(type = "string", 
            enum = c("ActivatingGameSessions", "ActiveGameSessions", 
                "ActiveInstances", "AvailableGameSessions", "AvailablePlayerSessions", 
                "CurrentPlayerSessions", "IdleInstances", "PercentAvailableGameSessions", 
                "PercentIdleInstances", "QueueDepth", "WaitTime"))), 
        PolicyType = structure(logical(0), tags = list(type = "string", 
            enum = c("RuleBased", "TargetBased"))), TargetConfiguration = structure(list(TargetValue = structure(logical(0), 
            tags = list(type = "double"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_vpc_peering_authorizations_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_vpc_peering_authorizations_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(VpcPeeringAuthorizations = structure(list(structure(list(GameLiftAwsAccountId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        PeerVpcAwsAccountId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PeerVpcId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        ExpirationTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_vpc_peering_connections_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_vpc_peering_connections_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(VpcPeeringConnections = structure(list(structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        IpV4CidrBlock = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), VpcPeeringConnectionId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Status = structure(list(Code = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            Message = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L))), tags = list(type = "structure")), 
        PeerVpcId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameLiftVpcId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_game_session_log_url_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_game_session_log_url_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PreSignedUrl = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_instance_access_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), InstanceId = structure(logical(0), 
        tags = list(type = "string", pattern = "[a-zA-Z0-9\\.-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_instance_access_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(InstanceAccess = structure(list(FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        InstanceId = structure(logical(0), tags = list(type = "string", 
            pattern = "[a-zA-Z0-9\\.-]+")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), Credentials = structure(list(UserName = structure(logical(0), 
            tags = list(type = "string", min = 1L)), Secret = structure(logical(0), 
            tags = list(type = "string", min = 1L))), tags = list(type = "structure", 
            sensitive = TRUE))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

list_aliases_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RoutingStrategyType = structure(logical(0), 
        tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
        Name = structure(logical(0), tags = list(type = "string", 
            min = 1L)), Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

list_aliases_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Aliases = structure(list(structure(list(AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L, pattern = ".*\\S.*")), AliasArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), Description = structure(logical(0), 
            tags = list(type = "string")), RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

list_builds_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Status = structure(logical(0), tags = list(type = "string", 
        enum = c("INITIALIZED", "READY", "FAILED"))), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

list_builds_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Builds = structure(list(structure(list(BuildId = structure(logical(0), 
        tags = list(type = "string", pattern = "^build-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string")), 
        Version = structure(logical(0), tags = list(type = "string")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("INITIALIZED", "READY", "FAILED"))), SizeOnDisk = structure(logical(0), 
            tags = list(type = "long", min = 1L)), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string", min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

list_fleets_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BuildId = structure(logical(0), tags = list(type = "string", 
        pattern = "^build-\\S+")), Limit = structure(logical(0), 
        tags = list(type = "integer", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

list_fleets_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetIds = structure(list(structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+"))), 
        tags = list(type = "list", min = 1L)), NextToken = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_scaling_policy_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L)), FleetId = structure(logical(0), 
        tags = list(type = "string", pattern = "^fleet-\\S+")), 
        ScalingAdjustment = structure(logical(0), tags = list(type = "integer")), 
        ScalingAdjustmentType = structure(logical(0), tags = list(type = "string", 
            enum = c("ChangeInCapacity", "ExactCapacity", "PercentChangeInCapacity"))), 
        Threshold = structure(logical(0), tags = list(type = "double")), 
        ComparisonOperator = structure(logical(0), tags = list(type = "string", 
            enum = c("GreaterThanOrEqualToThreshold", "GreaterThanThreshold", 
                "LessThanThreshold", "LessThanOrEqualToThreshold"))), 
        EvaluationPeriods = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), MetricName = structure(logical(0), tags = list(type = "string", 
            enum = c("ActivatingGameSessions", "ActiveGameSessions", 
                "ActiveInstances", "AvailableGameSessions", "AvailablePlayerSessions", 
                "CurrentPlayerSessions", "IdleInstances", "PercentAvailableGameSessions", 
                "PercentIdleInstances", "QueueDepth", "WaitTime"))), 
        PolicyType = structure(logical(0), tags = list(type = "string", 
            enum = c("RuleBased", "TargetBased"))), TargetConfiguration = structure(list(TargetValue = structure(logical(0), 
            tags = list(type = "double"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_scaling_policy_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

request_upload_credentials_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BuildId = structure(logical(0), tags = list(type = "string", 
        pattern = "^build-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

request_upload_credentials_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(UploadCredentials = structure(list(AccessKeyId = structure(logical(0), 
        tags = list(type = "string", min = 1L)), SecretAccessKey = structure(logical(0), 
        tags = list(type = "string", min = 1L)), SessionToken = structure(logical(0), 
        tags = list(type = "string", min = 1L))), tags = list(type = "structure", 
        sensitive = TRUE)), StorageLocation = structure(list(Bucket = structure(logical(0), 
        tags = list(type = "string", min = 1L)), Key = structure(logical(0), 
        tags = list(type = "string", min = 1L)), RoleArn = structure(logical(0), 
        tags = list(type = "string", min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

resolve_alias_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AliasId = structure(logical(0), tags = list(type = "string", 
        pattern = "^alias-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

resolve_alias_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

search_game_sessions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        FilterExpression = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), SortExpression = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

search_game_sessions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessions = structure(list(structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetId = structure(logical(0), 
            tags = list(type = "string", pattern = "^fleet-\\S+")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        TerminationTime = structure(logical(0), tags = list(type = "timestamp")), 
        CurrentPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "ACTIVATING", 
                "TERMINATED", "TERMINATING", "ERROR"))), StatusReason = structure(logical(0), 
            tags = list(type = "string", enum = "INTERRUPTED")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerSessionCreationPolicy = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT_ALL", "DENY_ALL"))), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L)), MatchmakerData = structure(logical(0), 
            tags = list(type = "string", max = 390000L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_fleet_actions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), Actions = structure(list(structure(logical(0), 
        tags = list(type = "string", enum = "AUTO_SCALING"))), 
        tags = list(type = "list", max = 1L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_fleet_actions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_game_session_placement_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), GameSessionName = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        PlayerLatencies = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            RegionIdentifier = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L)), LatencyInMilliseconds = structure(logical(0), 
                tags = list(type = "float"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), DesiredPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerData = structure(logical(0), tags = list(type = "string", 
                max = 2048L, min = 1L))), tags = list(type = "structure"))), 
            tags = list(type = "list")), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_game_session_placement_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionPlacement = structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("PENDING", "FULFILLED", "CANCELLED", "TIMED_OUT"))), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), GameSessionName = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionRegion = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerLatencies = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            RegionIdentifier = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L)), LatencyInMilliseconds = structure(logical(0), 
                tags = list(type = "float"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlacedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L)), 
        MatchmakerData = structure(logical(0), tags = list(type = "string", 
            max = 390000L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_match_backfill_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        ConfigurationName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        GameSessionArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        Players = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerAttributes = structure(list(structure(list(S = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
                N = structure(logical(0), tags = list(type = "double")), 
                SL = structure(list(structure(logical(0), tags = list(type = "string", 
                  max = 1024L, min = 1L))), tags = list(type = "list")), 
                SDM = structure(list(structure(logical(0), tags = list(type = "double"))), 
                  tags = list(type = "map"))), tags = list(type = "structure"))), 
                tags = list(type = "map")), Team = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
            LatencyInMs = structure(list(structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "map"))), 
            tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_match_backfill_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(MatchmakingTicket = structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        ConfigurationName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("CANCELLED", "COMPLETED", "FAILED", "PLACING", 
                "QUEUED", "REQUIRES_ACCEPTANCE", "SEARCHING", 
                "TIMED_OUT"))), StatusReason = structure(logical(0), 
            tags = list(type = "string")), StatusMessage = structure(logical(0), 
            tags = list(type = "string")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), Players = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerAttributes = structure(list(structure(list(S = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
                N = structure(logical(0), tags = list(type = "double")), 
                SL = structure(list(structure(logical(0), tags = list(type = "string", 
                  max = 1024L, min = 1L))), tags = list(type = "list")), 
                SDM = structure(list(structure(logical(0), tags = list(type = "double"))), 
                  tags = list(type = "map"))), tags = list(type = "structure"))), 
                tags = list(type = "map")), Team = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
            LatencyInMs = structure(list(structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "map"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        GameSessionConnectionInfo = structure(list(GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", min = 1L)), MatchedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure")), 
        EstimatedWaitTime = structure(logical(0), tags = list(type = "integer", 
            min = 0L))), tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_matchmaking_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        ConfigurationName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Players = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerAttributes = structure(list(structure(list(S = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
                N = structure(logical(0), tags = list(type = "double")), 
                SL = structure(list(structure(logical(0), tags = list(type = "string", 
                  max = 1024L, min = 1L))), tags = list(type = "list")), 
                SDM = structure(list(structure(logical(0), tags = list(type = "double"))), 
                  tags = list(type = "map"))), tags = list(type = "structure"))), 
                tags = list(type = "map")), Team = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
            LatencyInMs = structure(list(structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "map"))), 
            tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_matchmaking_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(MatchmakingTicket = structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        ConfigurationName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("CANCELLED", "COMPLETED", "FAILED", "PLACING", 
                "QUEUED", "REQUIRES_ACCEPTANCE", "SEARCHING", 
                "TIMED_OUT"))), StatusReason = structure(logical(0), 
            tags = list(type = "string")), StatusMessage = structure(logical(0), 
            tags = list(type = "string")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), Players = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerAttributes = structure(list(structure(list(S = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
                N = structure(logical(0), tags = list(type = "double")), 
                SL = structure(list(structure(logical(0), tags = list(type = "string", 
                  max = 1024L, min = 1L))), tags = list(type = "list")), 
                SDM = structure(list(structure(logical(0), tags = list(type = "double"))), 
                  tags = list(type = "map"))), tags = list(type = "structure"))), 
                tags = list(type = "map")), Team = structure(logical(0), 
                tags = list(type = "string", max = 1024L, min = 1L)), 
            LatencyInMs = structure(list(structure(logical(0), 
                tags = list(type = "integer", min = 1L))), tags = list(type = "map"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        GameSessionConnectionInfo = structure(list(GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", min = 1L)), MatchedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure")), 
        EstimatedWaitTime = structure(logical(0), tags = list(type = "integer", 
            min = 0L))), tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_fleet_actions_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), Actions = structure(list(structure(logical(0), 
        tags = list(type = "string", enum = "AUTO_SCALING"))), 
        tags = list(type = "list", max = 1L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_fleet_actions_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_game_session_placement_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_game_session_placement_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionPlacement = structure(list(PlacementId = structure(logical(0), 
        tags = list(type = "string", max = 48L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("PENDING", "FULFILLED", "CANCELLED", "TIMED_OUT"))), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), GameSessionName = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionId = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionArn = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionRegion = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerLatencies = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            RegionIdentifier = structure(logical(0), tags = list(type = "string", 
                max = 1024L, min = 1L)), LatencyInMilliseconds = structure(logical(0), 
                tags = list(type = "float"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), StartTime = structure(logical(0), 
            tags = list(type = "timestamp")), EndTime = structure(logical(0), 
            tags = list(type = "timestamp")), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlacedPlayerSessions = structure(list(structure(list(PlayerId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
            PlayerSessionId = structure(logical(0), tags = list(type = "string", 
                pattern = "^psess-\\S+"))), tags = list(type = "structure"))), 
            tags = list(type = "list")), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L)), 
        MatchmakerData = structure(logical(0), tags = list(type = "string", 
            max = 390000L, min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_matchmaking_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TicketId = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_matchmaking_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_alias_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AliasId = structure(logical(0), tags = list(type = "string", 
        pattern = "^alias-\\S+")), Name = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L, pattern = ".*\\S.*")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

update_alias_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Alias = structure(list(AliasId = structure(logical(0), 
        tags = list(type = "string", pattern = "^alias-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L, pattern = ".*\\S.*")), AliasArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+")), Description = structure(logical(0), 
            tags = list(type = "string")), RoutingStrategy = structure(list(Type = structure(logical(0), 
            tags = list(type = "string", enum = c("SIMPLE", "TERMINAL"))), 
            FleetId = structure(logical(0), tags = list(type = "string", 
                pattern = "^fleet-\\S+")), Message = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_build_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BuildId = structure(logical(0), tags = list(type = "string", 
        pattern = "^build-\\S+")), Name = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Version = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_build_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Build = structure(list(BuildId = structure(logical(0), 
        tags = list(type = "string", pattern = "^build-\\S+")), 
        Name = structure(logical(0), tags = list(type = "string")), 
        Version = structure(logical(0), tags = list(type = "string")), 
        Status = structure(logical(0), tags = list(type = "string", 
            enum = c("INITIALIZED", "READY", "FAILED"))), SizeOnDisk = structure(logical(0), 
            tags = list(type = "long", min = 1L)), OperatingSystem = structure(logical(0), 
            tags = list(type = "string", enum = c("WINDOWS_2012", 
                "AMAZON_LINUX"))), CreationTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_attributes_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), Name = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), NewGameSessionProtectionPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("NoProtection", 
                "FullProtection"))), ResourceCreationLimitPolicy = structure(list(NewGameSessionsPerCreator = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyPeriodInMinutes = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure")), 
        MetricGroups = structure(list(structure(logical(0), tags = list(type = "string", 
            max = 255L, min = 1L))), tags = list(type = "list", 
            max = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_attributes_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_capacity_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), DesiredInstances = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), MinSize = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), MaxSize = structure(logical(0), 
        tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_capacity_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_port_settings_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), InboundPermissionAuthorizations = structure(list(structure(list(FromPort = structure(logical(0), 
        tags = list(type = "integer", max = 60000L, min = 1L)), 
        ToPort = structure(logical(0), tags = list(type = "integer", 
            max = 60000L, min = 1L)), IpRange = structure(logical(0), 
            tags = list(type = "string", pattern = "[^\\s]+")), 
        Protocol = structure(logical(0), tags = list(type = "string", 
            enum = c("TCP", "UDP")))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L)), InboundPermissionRevocations = structure(list(structure(list(FromPort = structure(logical(0), 
        tags = list(type = "integer", max = 60000L, min = 1L)), 
        ToPort = structure(logical(0), tags = list(type = "integer", 
            max = 60000L, min = 1L)), IpRange = structure(logical(0), 
            tags = list(type = "string", pattern = "[^\\s]+")), 
        Protocol = structure(logical(0), tags = list(type = "string", 
            enum = c("TCP", "UDP")))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_fleet_port_settings_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_game_session_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        MaximumPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), PlayerSessionCreationPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("ACCEPT_ALL", 
                "DENY_ALL"))), ProtectionPolicy = structure(logical(0), 
            tags = list(type = "string", enum = c("NoProtection", 
                "FullProtection")))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_game_session_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSession = structure(list(GameSessionId = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Name = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), FleetId = structure(logical(0), 
            tags = list(type = "string", pattern = "^fleet-\\S+")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        TerminationTime = structure(logical(0), tags = list(type = "timestamp")), 
        CurrentPlayerSessionCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), MaximumPlayerSessionCount = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), Status = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "ACTIVATING", 
                "TERMINATED", "TERMINATING", "ERROR"))), StatusReason = structure(logical(0), 
            tags = list(type = "string", enum = "INTERRUPTED")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), IpAddress = structure(logical(0), 
            tags = list(type = "string")), Port = structure(logical(0), 
            tags = list(type = "integer", max = 60000L, min = 1L)), 
        PlayerSessionCreationPolicy = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCEPT_ALL", "DENY_ALL"))), CreatorId = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        GameSessionData = structure(logical(0), tags = list(type = "string", 
            max = 4096L, min = 1L)), MatchmakerData = structure(logical(0), 
            tags = list(type = "string", max = 390000L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_game_session_queue_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), TimeoutInSeconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), PlayerLatencyPolicies = structure(list(structure(list(MaximumIndividualPlayerLatencyMilliseconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L)), PolicyDurationSeconds = structure(logical(0), 
        tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
        tags = list(type = "list")), Destinations = structure(list(structure(list(DestinationArn = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+"))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

update_game_session_queue_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GameSessionQueue = structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-]+")), 
        GameSessionQueueArn = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L, pattern = "[a-zA-Z0-9:/-]+")), 
        TimeoutInSeconds = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), PlayerLatencyPolicies = structure(list(structure(list(MaximumIndividualPlayerLatencyMilliseconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L)), PolicyDurationSeconds = structure(logical(0), 
            tags = list(type = "integer", min = 0L))), tags = list(type = "structure"))), 
            tags = list(type = "list")), Destinations = structure(list(structure(list(DestinationArn = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

update_matchmaking_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Name = structure(logical(0), tags = list(type = "string", 
        max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionQueueArns = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "list")), 
        RequestTimeoutSeconds = structure(logical(0), tags = list(type = "integer", 
            max = 43200L, min = 1L)), AcceptanceTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L)), 
        AcceptanceRequired = structure(logical(0), tags = list(type = "boolean")), 
        RuleSetName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        NotificationTarget = structure(logical(0), tags = list(type = "string", 
            max = 300L, min = 0L, pattern = "[a-zA-Z0-9:_/-]*")), 
        AdditionalPlayerCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), CustomEventData = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 0L)), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

update_matchmaking_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Configuration = structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        Description = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), GameSessionQueueArns = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L, 
                pattern = "[a-zA-Z0-9:/-]+"))), tags = list(type = "list")), 
        RequestTimeoutSeconds = structure(logical(0), tags = list(type = "integer", 
            max = 43200L, min = 1L)), AcceptanceTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L)), 
        AcceptanceRequired = structure(logical(0), tags = list(type = "boolean")), 
        RuleSetName = structure(logical(0), tags = list(type = "string", 
            max = 128L, min = 1L, pattern = "[a-zA-Z0-9-\\.]+")), 
        NotificationTarget = structure(logical(0), tags = list(type = "string", 
            max = 300L, min = 0L, pattern = "[a-zA-Z0-9:_/-]*")), 
        AdditionalPlayerCount = structure(logical(0), tags = list(type = "integer", 
            min = 0L)), CustomEventData = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 0L)), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        GameProperties = structure(list(structure(list(Key = structure(logical(0), 
            tags = list(type = "string", max = 32L)), Value = structure(logical(0), 
            tags = list(type = "string", max = 96L))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 16L)), GameSessionData = structure(logical(0), 
            tags = list(type = "string", max = 4096L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_runtime_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FleetId = structure(logical(0), tags = list(type = "string", 
        pattern = "^fleet-\\S+")), RuntimeConfiguration = structure(list(ServerProcesses = structure(list(structure(list(LaunchPath = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Parameters = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), ConcurrentExecutions = structure(logical(0), 
            tags = list(type = "integer", min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L, min = 1L)), MaxConcurrentGameSessionActivations = structure(logical(0), 
        tags = list(type = "integer", max = 2147483647L, min = 1L)), 
        GameSessionActivationTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

update_runtime_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RuntimeConfiguration = structure(list(ServerProcesses = structure(list(structure(list(LaunchPath = structure(logical(0), 
        tags = list(type = "string", max = 1024L, min = 1L)), 
        Parameters = structure(logical(0), tags = list(type = "string", 
            max = 1024L, min = 1L)), ConcurrentExecutions = structure(logical(0), 
            tags = list(type = "integer", min = 1L))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 50L, min = 1L)), MaxConcurrentGameSessionActivations = structure(logical(0), 
        tags = list(type = "integer", max = 2147483647L, min = 1L)), 
        GameSessionActivationTimeoutSeconds = structure(logical(0), 
            tags = list(type = "integer", max = 600L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

validate_matchmaking_rule_set_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RuleSetBody = structure(logical(0), 
        tags = list(type = "string", max = 65535L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

validate_matchmaking_rule_set_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Valid = structure(logical(0), tags = list(type = "boolean"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

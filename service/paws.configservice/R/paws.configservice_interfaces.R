# This file is generated by make.paws. Please do not edit here.

#' @importFrom paws.common populate
NULL

batch_get_aggregate_resource_config_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ResourceIdentifiers = structure(list(structure(list(SourceAccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            SourceRegion = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L)), ResourceId = structure(logical(0), 
                tags = list(type = "string", max = 768L, min = 1L)), 
            ResourceType = structure(logical(0), tags = list(type = "string", 
                enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                  "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                  "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                  "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                  "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                  "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                  "AWS::EC2::VPNGateway", "AWS::IAM::Group", 
                  "AWS::IAM::Policy", "AWS::IAM::Role", "AWS::IAM::User", 
                  "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                  "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                  "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                  "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                  "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                  "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                  "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                  "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                  "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                  "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                  "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                  "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                  "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                  "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                  "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                  "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                  "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                  "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                  "AWS::ElasticBeanstalk::ApplicationVersion", 
                  "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                  "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                  "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                  "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                  "AWS::CodePipeline::Pipeline"))), ResourceName = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure"))), 
            tags = list(type = "list", max = 100L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

batch_get_aggregate_resource_config_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(BaseConfigurationItems = structure(list(structure(list(version = structure(logical(0), 
        tags = list(type = "string")), accountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), configurationItemCaptureTime = structure(logical(0), 
        tags = list(type = "timestamp")), configurationItemStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("OK", "ResourceDiscovered", 
            "ResourceNotRecorded", "ResourceDeleted", "ResourceDeletedNotRecorded"))), 
        configurationStateId = structure(logical(0), tags = list(type = "string")), 
        arn = structure(logical(0), tags = list(type = "string")), 
        resourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
        resourceName = structure(logical(0), tags = list(type = "string")), 
        awsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), availabilityZone = structure(logical(0), 
            tags = list(type = "string")), resourceCreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), configuration = structure(logical(0), 
            tags = list(type = "string")), supplementaryConfiguration = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        UnprocessedResourceIdentifiers = structure(list(structure(list(SourceAccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            SourceRegion = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L)), ResourceId = structure(logical(0), 
                tags = list(type = "string", max = 768L, min = 1L)), 
            ResourceType = structure(logical(0), tags = list(type = "string", 
                enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                  "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                  "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                  "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                  "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                  "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                  "AWS::EC2::VPNGateway", "AWS::IAM::Group", 
                  "AWS::IAM::Policy", "AWS::IAM::Role", "AWS::IAM::User", 
                  "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                  "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                  "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                  "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                  "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                  "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                  "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                  "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                  "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                  "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                  "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                  "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                  "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                  "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                  "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                  "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                  "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                  "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                  "AWS::ElasticBeanstalk::ApplicationVersion", 
                  "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                  "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                  "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                  "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                  "AWS::CodePipeline::Pipeline"))), ResourceName = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure"))), 
            tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

batch_get_resource_config_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(resourceKeys = structure(list(structure(list(resourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
            "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
            "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
            "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
            "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
            "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
            "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
            "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
            "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
            "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
            "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
            "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
            "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
            "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
            "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
            "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
            "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
            "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
            "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
            "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", "AWS::WAF::WebACL", 
            "AWS::WAFRegional::RateBasedRule", "AWS::WAFRegional::Rule", 
            "AWS::WAFRegional::WebACL", "AWS::CloudFront::Distribution", 
            "AWS::CloudFront::StreamingDistribution", "AWS::WAF::RuleGroup", 
            "AWS::WAFRegional::RuleGroup", "AWS::Lambda::Function", 
            "AWS::ElasticBeanstalk::Application", "AWS::ElasticBeanstalk::ApplicationVersion", 
            "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
            "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
            "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
            "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
            "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
        tags = list(type = "string", max = 768L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list", 
        max = 100L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

batch_get_resource_config_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(baseConfigurationItems = structure(list(structure(list(version = structure(logical(0), 
        tags = list(type = "string")), accountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), configurationItemCaptureTime = structure(logical(0), 
        tags = list(type = "timestamp")), configurationItemStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("OK", "ResourceDiscovered", 
            "ResourceNotRecorded", "ResourceDeleted", "ResourceDeletedNotRecorded"))), 
        configurationStateId = structure(logical(0), tags = list(type = "string")), 
        arn = structure(logical(0), tags = list(type = "string")), 
        resourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
        resourceName = structure(logical(0), tags = list(type = "string")), 
        awsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), availabilityZone = structure(logical(0), 
            tags = list(type = "string")), resourceCreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), configuration = structure(logical(0), 
            tags = list(type = "string")), supplementaryConfiguration = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        unprocessedResourceKeys = structure(list(structure(list(resourceType = structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L))), 
            tags = list(type = "structure"))), tags = list(type = "list", 
            max = 100L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_aggregation_authorization_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AuthorizedAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), AuthorizedAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_aggregation_authorization_output <- function () 
{
    return(list())
}

delete_config_rule_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_config_rule_output <- function () 
{
    return(list())
}

delete_configuration_aggregator_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_configuration_aggregator_output <- function () 
{
    return(list())
}

delete_configuration_recorder_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorderName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_configuration_recorder_output <- function () 
{
    return(list())
}

delete_delivery_channel_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannelName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_delivery_channel_output <- function () 
{
    return(list())
}

delete_evaluation_results_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_evaluation_results_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_pending_aggregation_request_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RequesterAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), RequesterAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_pending_aggregation_request_output <- function () 
{
    return(list())
}

delete_retention_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RetentionConfigurationName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

delete_retention_configuration_output <- function () 
{
    return(list())
}

deliver_config_snapshot_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(deliveryChannelName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

deliver_config_snapshot_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(configSnapshotId = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_aggregate_compliance_by_config_rules_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        Filters = structure(list(ConfigRuleName = structure(logical(0), 
            tags = list(type = "string", max = 64L, min = 1L)), 
            ComplianceType = structure(logical(0), tags = list(type = "string", 
                enum = c("COMPLIANT", "NON_COMPLIANT", "NOT_APPLICABLE", 
                  "INSUFFICIENT_DATA"))), AccountId = structure(logical(0), 
                tags = list(type = "string", pattern = "\\d{12}")), 
            AwsRegion = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L))), tags = list(type = "structure")), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            max = 1000L, min = 0L)), NextToken = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_aggregate_compliance_by_config_rules_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AggregateComplianceByConfigRules = structure(list(structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), Compliance = structure(list(ComplianceType = structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), ComplianceContributorCount = structure(list(CappedCount = structure(logical(0), 
        tags = list(type = "integer")), CapExceeded = structure(logical(0), 
        tags = list(type = "boolean"))), tags = list(type = "structure"))), 
        tags = list(type = "structure")), AccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), AwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_aggregation_authorizations_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Limit = structure(logical(0), tags = list(type = "integer", 
        max = 100L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_aggregation_authorizations_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AggregationAuthorizations = structure(list(structure(list(AggregationAuthorizationArn = structure(logical(0), 
        tags = list(type = "string")), AuthorizedAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), AuthorizedAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), CreationTime = structure(logical(0), 
        tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_compliance_by_config_rule_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "list", max = 25L, min = 0L)), ComplianceTypes = structure(list(structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA")))), tags = list(type = "list", 
        max = 3L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_compliance_by_config_rule_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ComplianceByConfigRules = structure(list(structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), Compliance = structure(list(ComplianceType = structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), ComplianceContributorCount = structure(list(CappedCount = structure(logical(0), 
        tags = list(type = "integer")), CapExceeded = structure(logical(0), 
        tags = list(type = "boolean"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_compliance_by_resource_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L)), ComplianceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA")))), 
            tags = list(type = "list", max = 3L, min = 0L)), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            max = 100L, min = 0L)), NextToken = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_compliance_by_resource_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ComplianceByResources = structure(list(structure(list(ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L)), Compliance = structure(list(ComplianceType = structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), 
            ComplianceContributorCount = structure(list(CappedCount = structure(logical(0), 
                tags = list(type = "integer")), CapExceeded = structure(logical(0), 
                tags = list(type = "boolean"))), tags = list(type = "structure"))), 
            tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_config_rule_evaluation_status_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "list", max = 25L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string")), Limit = structure(logical(0), 
        tags = list(type = "integer", max = 50L, min = 0L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_config_rule_evaluation_status_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRulesEvaluationStatus = structure(list(structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ConfigRuleArn = structure(logical(0), 
        tags = list(type = "string")), ConfigRuleId = structure(logical(0), 
        tags = list(type = "string")), LastSuccessfulInvocationTime = structure(logical(0), 
        tags = list(type = "timestamp")), LastFailedInvocationTime = structure(logical(0), 
        tags = list(type = "timestamp")), LastSuccessfulEvaluationTime = structure(logical(0), 
        tags = list(type = "timestamp")), LastFailedEvaluationTime = structure(logical(0), 
        tags = list(type = "timestamp")), FirstActivatedTime = structure(logical(0), 
        tags = list(type = "timestamp")), LastErrorCode = structure(logical(0), 
        tags = list(type = "string")), LastErrorMessage = structure(logical(0), 
        tags = list(type = "string")), FirstEvaluationStarted = structure(logical(0), 
        tags = list(type = "boolean"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_config_rules_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "list", max = 25L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_config_rules_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRules = structure(list(structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ConfigRuleArn = structure(logical(0), 
        tags = list(type = "string")), ConfigRuleId = structure(logical(0), 
        tags = list(type = "string")), Description = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 0L)), 
        Scope = structure(list(ComplianceResourceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L))), 
            tags = list(type = "list", max = 100L, min = 0L)), 
            TagKey = structure(logical(0), tags = list(type = "string", 
                max = 128L, min = 1L)), TagValue = structure(logical(0), 
                tags = list(type = "string", max = 256L, min = 1L)), 
            ComplianceResourceId = structure(logical(0), tags = list(type = "string", 
                max = 768L, min = 1L))), tags = list(type = "structure")), 
        Source = structure(list(Owner = structure(logical(0), 
            tags = list(type = "string", enum = c("CUSTOM_LAMBDA", 
                "AWS"))), SourceIdentifier = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L)), 
            SourceDetails = structure(list(structure(list(EventSource = structure(logical(0), 
                tags = list(type = "string", enum = "aws.config")), 
                MessageType = structure(logical(0), tags = list(type = "string", 
                  enum = c("ConfigurationItemChangeNotification", 
                    "ConfigurationSnapshotDeliveryCompleted", 
                    "ScheduledNotification", "OversizedConfigurationItemChangeNotification"))), 
                MaximumExecutionFrequency = structure(logical(0), 
                  tags = list(type = "string", enum = c("One_Hour", 
                    "Three_Hours", "Six_Hours", "Twelve_Hours", 
                    "TwentyFour_Hours")))), tags = list(type = "structure"))), 
                tags = list(type = "list", max = 25L, min = 0L))), 
            tags = list(type = "structure")), InputParameters = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        MaximumExecutionFrequency = structure(logical(0), tags = list(type = "string", 
            enum = c("One_Hour", "Three_Hours", "Six_Hours", 
                "Twelve_Hours", "TwentyFour_Hours"))), ConfigRuleState = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "DELETING", 
                "DELETING_RESULTS", "EVALUATING"))), CreatedBy = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_aggregator_sources_status_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        UpdateStatus = structure(list(structure(logical(0), tags = list(type = "string", 
            enum = c("FAILED", "SUCCEEDED", "OUTDATED")))), tags = list(type = "list", 
            min = 1L)), NextToken = structure(logical(0), tags = list(type = "string")), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            max = 100L, min = 0L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_aggregator_sources_status_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AggregatedSourceStatusList = structure(list(structure(list(SourceId = structure(logical(0), 
        tags = list(type = "string")), SourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("ACCOUNT", "ORGANIZATION"))), 
        AwsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), LastUpdateStatus = structure(logical(0), 
            tags = list(type = "string", enum = c("FAILED", "SUCCEEDED", 
                "OUTDATED"))), LastUpdateTime = structure(logical(0), 
            tags = list(type = "timestamp")), LastErrorCode = structure(logical(0), 
            tags = list(type = "string")), LastErrorMessage = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_aggregators_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+"))), 
        tags = list(type = "list", max = 10L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string")), Limit = structure(logical(0), 
        tags = list(type = "integer", max = 100L, min = 0L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_aggregators_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregators = structure(list(structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ConfigurationAggregatorArn = structure(logical(0), tags = list(type = "string", 
            pattern = "arn:aws[a-z\\-]*:config:[a-z\\-\\d]+:\\d+:config-aggregator/config-aggregator-[a-z\\d]+")), 
        AccountAggregationSources = structure(list(structure(list(AccountIds = structure(list(structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}"))), 
            tags = list(type = "list", min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L))), tags = list(type = "structure"))), tags = list(type = "list", 
            max = 1L, min = 0L)), OrganizationAggregationSource = structure(list(RoleArn = structure(logical(0), 
            tags = list(type = "string")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_recorder_status_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorderNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_recorder_status_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecordersStatus = structure(list(structure(list(name = structure(logical(0), 
        tags = list(type = "string")), lastStartTime = structure(logical(0), 
        tags = list(type = "timestamp")), lastStopTime = structure(logical(0), 
        tags = list(type = "timestamp")), recording = structure(logical(0), 
        tags = list(type = "boolean")), lastStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("Pending", "Success", 
            "Failure"))), lastErrorCode = structure(logical(0), 
        tags = list(type = "string")), lastErrorMessage = structure(logical(0), 
        tags = list(type = "string")), lastStatusChangeTime = structure(logical(0), 
        tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_recorders_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorderNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_configuration_recorders_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorders = structure(list(structure(list(name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        roleARN = structure(logical(0), tags = list(type = "string")), 
        recordingGroup = structure(list(allSupported = structure(logical(0), 
            tags = list(type = "boolean")), includeGlobalResourceTypes = structure(logical(0), 
            tags = list(type = "boolean")), resourceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline")))), tags = list(type = "list"))), 
            tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_delivery_channel_status_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannelNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_delivery_channel_status_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannelsStatus = structure(list(structure(list(name = structure(logical(0), 
        tags = list(type = "string")), configSnapshotDeliveryInfo = structure(list(lastStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("Success", "Failure", 
            "Not_Applicable"))), lastErrorCode = structure(logical(0), 
        tags = list(type = "string")), lastErrorMessage = structure(logical(0), 
        tags = list(type = "string")), lastAttemptTime = structure(logical(0), 
        tags = list(type = "timestamp")), lastSuccessfulTime = structure(logical(0), 
        tags = list(type = "timestamp")), nextDeliveryTime = structure(logical(0), 
        tags = list(type = "timestamp"))), tags = list(type = "structure")), 
        configHistoryDeliveryInfo = structure(list(lastStatus = structure(logical(0), 
            tags = list(type = "string", enum = c("Success", 
                "Failure", "Not_Applicable"))), lastErrorCode = structure(logical(0), 
            tags = list(type = "string")), lastErrorMessage = structure(logical(0), 
            tags = list(type = "string")), lastAttemptTime = structure(logical(0), 
            tags = list(type = "timestamp")), lastSuccessfulTime = structure(logical(0), 
            tags = list(type = "timestamp")), nextDeliveryTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure")), 
        configStreamDeliveryInfo = structure(list(lastStatus = structure(logical(0), 
            tags = list(type = "string", enum = c("Success", 
                "Failure", "Not_Applicable"))), lastErrorCode = structure(logical(0), 
            tags = list(type = "string")), lastErrorMessage = structure(logical(0), 
            tags = list(type = "string")), lastStatusChangeTime = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_delivery_channels_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannelNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_delivery_channels_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannels = structure(list(structure(list(name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        s3BucketName = structure(logical(0), tags = list(type = "string")), 
        s3KeyPrefix = structure(logical(0), tags = list(type = "string")), 
        snsTopicARN = structure(logical(0), tags = list(type = "string")), 
        configSnapshotDeliveryProperties = structure(list(deliveryFrequency = structure(logical(0), 
            tags = list(type = "string", enum = c("One_Hour", 
                "Three_Hours", "Six_Hours", "Twelve_Hours", "TwentyFour_Hours")))), 
            tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "list"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_pending_aggregation_requests_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Limit = structure(logical(0), tags = list(type = "integer", 
        max = 20L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_pending_aggregation_requests_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(PendingAggregationRequests = structure(list(structure(list(RequesterAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), RequesterAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_retention_configurations_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RetentionConfigurationNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+"))), 
        tags = list(type = "list", max = 1L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

describe_retention_configurations_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RetentionConfigurations = structure(list(structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        RetentionPeriodInDays = structure(logical(0), tags = list(type = "integer", 
            max = 2557L, min = 30L))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_compliance_details_by_config_rule_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ConfigRuleName = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), AccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
        AwsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), ComplianceType = structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            max = 100L, min = 0L)), NextToken = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_compliance_details_by_config_rule_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AggregateEvaluationResults = structure(list(structure(list(EvaluationResultIdentifier = structure(list(EvaluationResultQualifier = structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L))), tags = list(type = "structure")), 
        OrderingTimestamp = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure")), ComplianceType = structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), ResultRecordedTime = structure(logical(0), 
        tags = list(type = "timestamp")), ConfigRuleInvokedTime = structure(logical(0), 
        tags = list(type = "timestamp")), Annotation = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        AccountId = structure(logical(0), tags = list(type = "string", 
            pattern = "\\d{12}")), AwsRegion = structure(logical(0), 
            tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_config_rule_compliance_summary_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        Filters = structure(list(AccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            AwsRegion = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L))), tags = list(type = "structure")), 
        GroupByKey = structure(logical(0), tags = list(type = "string", 
            enum = c("ACCOUNT_ID", "AWS_REGION"))), Limit = structure(logical(0), 
            tags = list(type = "integer", max = 1000L, min = 0L)), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_config_rule_compliance_summary_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(GroupByKey = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        AggregateComplianceCounts = structure(list(structure(list(GroupName = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L)), 
            ComplianceSummary = structure(list(CompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
                tags = list(type = "integer")), CapExceeded = structure(logical(0), 
                tags = list(type = "boolean"))), tags = list(type = "structure")), 
                NonCompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
                  tags = list(type = "integer")), CapExceeded = structure(logical(0), 
                  tags = list(type = "boolean"))), tags = list(type = "structure")), 
                ComplianceSummaryTimestamp = structure(logical(0), 
                  tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_discovered_resource_counts_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        Filters = structure(list(ResourceType = structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), AccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            Region = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L))), tags = list(type = "structure")), 
        GroupByKey = structure(logical(0), tags = list(type = "string", 
            enum = c("RESOURCE_TYPE", "ACCOUNT_ID", "AWS_REGION"))), 
        Limit = structure(logical(0), tags = list(type = "integer", 
            max = 1000L, min = 0L)), NextToken = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_discovered_resource_counts_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(TotalDiscoveredResources = structure(logical(0), 
        tags = list(type = "long")), GroupByKey = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        GroupedResourceCounts = structure(list(structure(list(GroupName = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L)), 
            ResourceCount = structure(logical(0), tags = list(type = "long"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_resource_config_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ResourceIdentifier = structure(list(SourceAccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            SourceRegion = structure(logical(0), tags = list(type = "string", 
                max = 64L, min = 1L)), ResourceId = structure(logical(0), 
                tags = list(type = "string", max = 768L, min = 1L)), 
            ResourceType = structure(logical(0), tags = list(type = "string", 
                enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                  "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                  "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                  "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                  "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                  "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                  "AWS::EC2::VPNGateway", "AWS::IAM::Group", 
                  "AWS::IAM::Policy", "AWS::IAM::Role", "AWS::IAM::User", 
                  "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                  "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                  "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                  "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                  "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                  "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                  "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                  "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                  "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                  "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                  "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                  "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                  "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                  "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                  "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                  "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                  "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                  "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                  "AWS::ElasticBeanstalk::ApplicationVersion", 
                  "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                  "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                  "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                  "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                  "AWS::CodePipeline::Pipeline"))), ResourceName = structure(logical(0), 
                tags = list(type = "string"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_aggregate_resource_config_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationItem = structure(list(version = structure(logical(0), 
        tags = list(type = "string")), accountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), configurationItemCaptureTime = structure(logical(0), 
        tags = list(type = "timestamp")), configurationItemStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("OK", "ResourceDiscovered", 
            "ResourceNotRecorded", "ResourceDeleted", "ResourceDeletedNotRecorded"))), 
        configurationStateId = structure(logical(0), tags = list(type = "string")), 
        configurationItemMD5Hash = structure(logical(0), tags = list(type = "string")), 
        arn = structure(logical(0), tags = list(type = "string")), 
        resourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
        resourceName = structure(logical(0), tags = list(type = "string")), 
        awsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), availabilityZone = structure(logical(0), 
            tags = list(type = "string")), resourceCreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), tags = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map")), 
        relatedEvents = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list")), 
        relationships = structure(list(structure(list(resourceType = structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
            resourceName = structure(logical(0), tags = list(type = "string")), 
            relationshipName = structure(logical(0), tags = list(type = "string"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        configuration = structure(logical(0), tags = list(type = "string")), 
        supplementaryConfiguration = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_details_by_config_rule_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ComplianceTypes = structure(list(structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA")))), tags = list(type = "list", 
        max = 3L, min = 0L)), Limit = structure(logical(0), tags = list(type = "integer", 
        max = 100L, min = 0L)), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_details_by_config_rule_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(EvaluationResults = structure(list(structure(list(EvaluationResultIdentifier = structure(list(EvaluationResultQualifier = structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L))), tags = list(type = "structure")), 
        OrderingTimestamp = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure")), ComplianceType = structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), ResultRecordedTime = structure(logical(0), 
        tags = list(type = "timestamp")), ConfigRuleInvokedTime = structure(logical(0), 
        tags = list(type = "timestamp")), Annotation = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResultToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_details_by_resource_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L)), ComplianceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA")))), 
            tags = list(type = "list", max = 3L, min = 0L)), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_details_by_resource_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(EvaluationResults = structure(list(structure(list(EvaluationResultIdentifier = structure(list(EvaluationResultQualifier = structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L))), tags = list(type = "structure")), 
        OrderingTimestamp = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure")), ComplianceType = structure(logical(0), 
        tags = list(type = "string", enum = c("COMPLIANT", "NON_COMPLIANT", 
            "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), ResultRecordedTime = structure(logical(0), 
        tags = list(type = "timestamp")), ConfigRuleInvokedTime = structure(logical(0), 
        tags = list(type = "timestamp")), Annotation = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ResultToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_summary_by_config_rule_input <- function () 
{
    return(list())
}

get_compliance_summary_by_config_rule_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ComplianceSummary = structure(list(CompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
        tags = list(type = "integer")), CapExceeded = structure(logical(0), 
        tags = list(type = "boolean"))), tags = list(type = "structure")), 
        NonCompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
            tags = list(type = "integer")), CapExceeded = structure(logical(0), 
            tags = list(type = "boolean"))), tags = list(type = "structure")), 
        ComplianceSummaryTimestamp = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_summary_by_resource_type_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ResourceTypes = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list", max = 20L, min = 0L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_compliance_summary_by_resource_type_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ComplianceSummariesByResourceType = structure(list(structure(list(ResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ComplianceSummary = structure(list(CompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
            tags = list(type = "integer")), CapExceeded = structure(logical(0), 
            tags = list(type = "boolean"))), tags = list(type = "structure")), 
            NonCompliantResourceCount = structure(list(CappedCount = structure(logical(0), 
                tags = list(type = "integer")), CapExceeded = structure(logical(0), 
                tags = list(type = "boolean"))), tags = list(type = "structure")), 
            ComplianceSummaryTimestamp = structure(logical(0), 
                tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))), tags = list(type = "list"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_discovered_resource_counts_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(resourceTypes = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "list", max = 20L, min = 0L)), limit = structure(logical(0), 
        tags = list(type = "integer", max = 100L, min = 0L)), 
        nextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_discovered_resource_counts_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(totalDiscoveredResources = structure(logical(0), 
        tags = list(type = "long")), resourceCounts = structure(list(structure(list(resourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
            "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
            "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
            "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
            "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
            "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
            "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
            "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
            "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
            "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
            "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
            "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
            "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
            "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
            "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
            "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
            "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
            "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
            "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
            "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", "AWS::WAF::WebACL", 
            "AWS::WAFRegional::RateBasedRule", "AWS::WAFRegional::Rule", 
            "AWS::WAFRegional::WebACL", "AWS::CloudFront::Distribution", 
            "AWS::CloudFront::StreamingDistribution", "AWS::WAF::RuleGroup", 
            "AWS::WAFRegional::RuleGroup", "AWS::Lambda::Function", 
            "AWS::ElasticBeanstalk::Application", "AWS::ElasticBeanstalk::ApplicationVersion", 
            "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
            "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
            "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
            "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
            "AWS::CodePipeline::Pipeline"))), count = structure(logical(0), 
        tags = list(type = "long"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), nextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

get_resource_config_history_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(resourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
            "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
            "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
            "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
            "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
            "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
            "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
            "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
            "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
            "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
            "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
            "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
            "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
            "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
            "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
            "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
            "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
            "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
            "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
            "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", "AWS::WAF::WebACL", 
            "AWS::WAFRegional::RateBasedRule", "AWS::WAFRegional::Rule", 
            "AWS::WAFRegional::WebACL", "AWS::CloudFront::Distribution", 
            "AWS::CloudFront::StreamingDistribution", "AWS::WAF::RuleGroup", 
            "AWS::WAFRegional::RuleGroup", "AWS::Lambda::Function", 
            "AWS::ElasticBeanstalk::Application", "AWS::ElasticBeanstalk::ApplicationVersion", 
            "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
            "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
            "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
            "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
            "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
        tags = list(type = "string", max = 768L, min = 1L)), 
        laterTime = structure(logical(0), tags = list(type = "timestamp")), 
        earlierTime = structure(logical(0), tags = list(type = "timestamp")), 
        chronologicalOrder = structure(logical(0), tags = list(type = "string", 
            enum = c("Reverse", "Forward"))), limit = structure(logical(0), 
            tags = list(type = "integer", max = 100L, min = 0L)), 
        nextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

get_resource_config_history_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(configurationItems = structure(list(structure(list(version = structure(logical(0), 
        tags = list(type = "string")), accountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), configurationItemCaptureTime = structure(logical(0), 
        tags = list(type = "timestamp")), configurationItemStatus = structure(logical(0), 
        tags = list(type = "string", enum = c("OK", "ResourceDiscovered", 
            "ResourceNotRecorded", "ResourceDeleted", "ResourceDeletedNotRecorded"))), 
        configurationStateId = structure(logical(0), tags = list(type = "string")), 
        configurationItemMD5Hash = structure(logical(0), tags = list(type = "string")), 
        arn = structure(logical(0), tags = list(type = "string")), 
        resourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
        resourceName = structure(logical(0), tags = list(type = "string")), 
        awsRegion = structure(logical(0), tags = list(type = "string", 
            max = 64L, min = 1L)), availabilityZone = structure(logical(0), 
            tags = list(type = "string")), resourceCreationTime = structure(logical(0), 
            tags = list(type = "timestamp")), tags = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map")), 
        relatedEvents = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list")), 
        relationships = structure(list(structure(list(resourceType = structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
            tags = list(type = "string", max = 768L, min = 1L)), 
            resourceName = structure(logical(0), tags = list(type = "string")), 
            relationshipName = structure(logical(0), tags = list(type = "string"))), 
            tags = list(type = "structure"))), tags = list(type = "list")), 
        configuration = structure(logical(0), tags = list(type = "string")), 
        supplementaryConfiguration = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "map"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        nextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

list_aggregate_discovered_resources_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ResourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), Filters = structure(list(AccountId = structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}")), 
            ResourceId = structure(logical(0), tags = list(type = "string", 
                max = 768L, min = 1L)), ResourceName = structure(logical(0), 
                tags = list(type = "string")), Region = structure(logical(0), 
                tags = list(type = "string", max = 64L, min = 1L))), 
            tags = list(type = "structure")), Limit = structure(logical(0), 
            tags = list(type = "integer", max = 100L, min = 0L)), 
        NextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

list_aggregate_discovered_resources_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ResourceIdentifiers = structure(list(structure(list(SourceAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), SourceRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ResourceId = structure(logical(0), 
        tags = list(type = "string", max = 768L, min = 1L)), 
        ResourceType = structure(logical(0), tags = list(type = "string", 
            enum = c("AWS::EC2::CustomerGateway", "AWS::EC2::EIP", 
                "AWS::EC2::Host", "AWS::EC2::Instance", "AWS::EC2::InternetGateway", 
                "AWS::EC2::NetworkAcl", "AWS::EC2::NetworkInterface", 
                "AWS::EC2::RouteTable", "AWS::EC2::SecurityGroup", 
                "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
                "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
                "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
                "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
                "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
                "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
                "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline"))), ResourceName = structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "structure"))), 
        tags = list(type = "list")), NextToken = structure(logical(0), 
        tags = list(type = "string"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

list_discovered_resources_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(resourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
            "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
            "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
            "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
            "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
            "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
            "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
            "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
            "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
            "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
            "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
            "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
            "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
            "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
            "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
            "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
            "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
            "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
            "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
            "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", "AWS::WAF::WebACL", 
            "AWS::WAFRegional::RateBasedRule", "AWS::WAFRegional::Rule", 
            "AWS::WAFRegional::WebACL", "AWS::CloudFront::Distribution", 
            "AWS::CloudFront::StreamingDistribution", "AWS::WAF::RuleGroup", 
            "AWS::WAFRegional::RuleGroup", "AWS::Lambda::Function", 
            "AWS::ElasticBeanstalk::Application", "AWS::ElasticBeanstalk::ApplicationVersion", 
            "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
            "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
            "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
            "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
            "AWS::CodePipeline::Pipeline"))), resourceIds = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 768L, min = 1L))), 
        tags = list(type = "list")), resourceName = structure(logical(0), 
        tags = list(type = "string")), limit = structure(logical(0), 
        tags = list(type = "integer", max = 100L, min = 0L)), 
        includeDeletedResources = structure(logical(0), tags = list(type = "boolean")), 
        nextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

list_discovered_resources_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(resourceIdentifiers = structure(list(structure(list(resourceType = structure(logical(0), 
        tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
            "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
            "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
            "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
            "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", "AWS::CloudTrail::Trail", 
            "AWS::EC2::Volume", "AWS::EC2::VPC", "AWS::EC2::VPNConnection", 
            "AWS::EC2::VPNGateway", "AWS::IAM::Group", "AWS::IAM::Policy", 
            "AWS::IAM::Role", "AWS::IAM::User", "AWS::ACM::Certificate", 
            "AWS::RDS::DBInstance", "AWS::RDS::DBSubnetGroup", 
            "AWS::RDS::DBSecurityGroup", "AWS::RDS::DBSnapshot", 
            "AWS::RDS::EventSubscription", "AWS::ElasticLoadBalancingV2::LoadBalancer", 
            "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
            "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
            "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
            "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
            "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
            "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
            "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
            "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
            "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", "AWS::WAF::WebACL", 
            "AWS::WAFRegional::RateBasedRule", "AWS::WAFRegional::Rule", 
            "AWS::WAFRegional::WebACL", "AWS::CloudFront::Distribution", 
            "AWS::CloudFront::StreamingDistribution", "AWS::WAF::RuleGroup", 
            "AWS::WAFRegional::RuleGroup", "AWS::Lambda::Function", 
            "AWS::ElasticBeanstalk::Application", "AWS::ElasticBeanstalk::ApplicationVersion", 
            "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
            "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
            "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
            "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
            "AWS::CodePipeline::Pipeline"))), resourceId = structure(logical(0), 
        tags = list(type = "string", max = 768L, min = 1L)), 
        resourceName = structure(logical(0), tags = list(type = "string")), 
        resourceDeletionTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "list")), 
        nextToken = structure(logical(0), tags = list(type = "string"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_aggregation_authorization_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AuthorizedAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), AuthorizedAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_aggregation_authorization_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(AggregationAuthorization = structure(list(AggregationAuthorizationArn = structure(logical(0), 
        tags = list(type = "string")), AuthorizedAccountId = structure(logical(0), 
        tags = list(type = "string", pattern = "\\d{12}")), AuthorizedAwsRegion = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), CreationTime = structure(logical(0), 
        tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_config_rule_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRule = structure(list(ConfigRuleName = structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L)), ConfigRuleArn = structure(logical(0), 
        tags = list(type = "string")), ConfigRuleId = structure(logical(0), 
        tags = list(type = "string")), Description = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 0L)), 
        Scope = structure(list(ComplianceResourceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L))), 
            tags = list(type = "list", max = 100L, min = 0L)), 
            TagKey = structure(logical(0), tags = list(type = "string", 
                max = 128L, min = 1L)), TagValue = structure(logical(0), 
                tags = list(type = "string", max = 256L, min = 1L)), 
            ComplianceResourceId = structure(logical(0), tags = list(type = "string", 
                max = 768L, min = 1L))), tags = list(type = "structure")), 
        Source = structure(list(Owner = structure(logical(0), 
            tags = list(type = "string", enum = c("CUSTOM_LAMBDA", 
                "AWS"))), SourceIdentifier = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L)), 
            SourceDetails = structure(list(structure(list(EventSource = structure(logical(0), 
                tags = list(type = "string", enum = "aws.config")), 
                MessageType = structure(logical(0), tags = list(type = "string", 
                  enum = c("ConfigurationItemChangeNotification", 
                    "ConfigurationSnapshotDeliveryCompleted", 
                    "ScheduledNotification", "OversizedConfigurationItemChangeNotification"))), 
                MaximumExecutionFrequency = structure(logical(0), 
                  tags = list(type = "string", enum = c("One_Hour", 
                    "Three_Hours", "Six_Hours", "Twelve_Hours", 
                    "TwentyFour_Hours")))), tags = list(type = "structure"))), 
                tags = list(type = "list", max = 25L, min = 0L))), 
            tags = list(type = "structure")), InputParameters = structure(logical(0), 
            tags = list(type = "string", max = 1024L, min = 1L)), 
        MaximumExecutionFrequency = structure(logical(0), tags = list(type = "string", 
            enum = c("One_Hour", "Three_Hours", "Six_Hours", 
                "Twelve_Hours", "TwentyFour_Hours"))), ConfigRuleState = structure(logical(0), 
            tags = list(type = "string", enum = c("ACTIVE", "DELETING", 
                "DELETING_RESULTS", "EVALUATING"))), CreatedBy = structure(logical(0), 
            tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

put_config_rule_output <- function () 
{
    return(list())
}

put_configuration_aggregator_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        AccountAggregationSources = structure(list(structure(list(AccountIds = structure(list(structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}"))), 
            tags = list(type = "list", min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L))), tags = list(type = "structure"))), tags = list(type = "list", 
            max = 1L, min = 0L)), OrganizationAggregationSource = structure(list(RoleArn = structure(logical(0), 
            tags = list(type = "string")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_configuration_aggregator_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationAggregator = structure(list(ConfigurationAggregatorName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        ConfigurationAggregatorArn = structure(logical(0), tags = list(type = "string", 
            pattern = "arn:aws[a-z\\-]*:config:[a-z\\-\\d]+:\\d+:config-aggregator/config-aggregator-[a-z\\d]+")), 
        AccountAggregationSources = structure(list(structure(list(AccountIds = structure(list(structure(logical(0), 
            tags = list(type = "string", pattern = "\\d{12}"))), 
            tags = list(type = "list", min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L))), tags = list(type = "structure"))), tags = list(type = "list", 
            max = 1L, min = 0L)), OrganizationAggregationSource = structure(list(RoleArn = structure(logical(0), 
            tags = list(type = "string")), AwsRegions = structure(list(structure(logical(0), 
            tags = list(type = "string"))), tags = list(type = "list", 
            min = 1L)), AllAwsRegions = structure(logical(0), 
            tags = list(type = "boolean"))), tags = list(type = "structure")), 
        CreationTime = structure(logical(0), tags = list(type = "timestamp")), 
        LastUpdatedTime = structure(logical(0), tags = list(type = "timestamp"))), 
        tags = list(type = "structure"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

put_configuration_recorder_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorder = structure(list(name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        roleARN = structure(logical(0), tags = list(type = "string")), 
        recordingGroup = structure(list(allSupported = structure(logical(0), 
            tags = list(type = "boolean")), includeGlobalResourceTypes = structure(logical(0), 
            tags = list(type = "boolean")), resourceTypes = structure(list(structure(logical(0), 
            tags = list(type = "string", enum = c("AWS::EC2::CustomerGateway", 
                "AWS::EC2::EIP", "AWS::EC2::Host", "AWS::EC2::Instance", 
                "AWS::EC2::InternetGateway", "AWS::EC2::NetworkAcl", 
                "AWS::EC2::NetworkInterface", "AWS::EC2::RouteTable", 
                "AWS::EC2::SecurityGroup", "AWS::EC2::Subnet", 
                "AWS::CloudTrail::Trail", "AWS::EC2::Volume", 
                "AWS::EC2::VPC", "AWS::EC2::VPNConnection", "AWS::EC2::VPNGateway", 
                "AWS::IAM::Group", "AWS::IAM::Policy", "AWS::IAM::Role", 
                "AWS::IAM::User", "AWS::ACM::Certificate", "AWS::RDS::DBInstance", 
                "AWS::RDS::DBSubnetGroup", "AWS::RDS::DBSecurityGroup", 
                "AWS::RDS::DBSnapshot", "AWS::RDS::EventSubscription", 
                "AWS::ElasticLoadBalancingV2::LoadBalancer", 
                "AWS::S3::Bucket", "AWS::SSM::ManagedInstanceInventory", 
                "AWS::Redshift::Cluster", "AWS::Redshift::ClusterSnapshot", 
                "AWS::Redshift::ClusterParameterGroup", "AWS::Redshift::ClusterSecurityGroup", 
                "AWS::Redshift::ClusterSubnetGroup", "AWS::Redshift::EventSubscription", 
                "AWS::CloudWatch::Alarm", "AWS::CloudFormation::Stack", 
                "AWS::DynamoDB::Table", "AWS::AutoScaling::AutoScalingGroup", 
                "AWS::AutoScaling::LaunchConfiguration", "AWS::AutoScaling::ScalingPolicy", 
                "AWS::AutoScaling::ScheduledAction", "AWS::CodeBuild::Project", 
                "AWS::WAF::RateBasedRule", "AWS::WAF::Rule", 
                "AWS::WAF::WebACL", "AWS::WAFRegional::RateBasedRule", 
                "AWS::WAFRegional::Rule", "AWS::WAFRegional::WebACL", 
                "AWS::CloudFront::Distribution", "AWS::CloudFront::StreamingDistribution", 
                "AWS::WAF::RuleGroup", "AWS::WAFRegional::RuleGroup", 
                "AWS::Lambda::Function", "AWS::ElasticBeanstalk::Application", 
                "AWS::ElasticBeanstalk::ApplicationVersion", 
                "AWS::ElasticBeanstalk::Environment", "AWS::ElasticLoadBalancing::LoadBalancer", 
                "AWS::XRay::EncryptionConfig", "AWS::SSM::AssociationCompliance", 
                "AWS::SSM::PatchCompliance", "AWS::Shield::Protection", 
                "AWS::ShieldRegional::Protection", "AWS::Config::ResourceCompliance", 
                "AWS::CodePipeline::Pipeline")))), tags = list(type = "list"))), 
            tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_configuration_recorder_output <- function () 
{
    return(list())
}

put_delivery_channel_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(DeliveryChannel = structure(list(name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        s3BucketName = structure(logical(0), tags = list(type = "string")), 
        s3KeyPrefix = structure(logical(0), tags = list(type = "string")), 
        snsTopicARN = structure(logical(0), tags = list(type = "string")), 
        configSnapshotDeliveryProperties = structure(list(deliveryFrequency = structure(logical(0), 
            tags = list(type = "string", enum = c("One_Hour", 
                "Three_Hours", "Six_Hours", "Twelve_Hours", "TwentyFour_Hours")))), 
            tags = list(type = "structure"))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_delivery_channel_output <- function () 
{
    return(list())
}

put_evaluations_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(Evaluations = structure(list(structure(list(ComplianceResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ComplianceResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L)), ComplianceType = structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), 
        Annotation = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L)), OrderingTimestamp = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 100L, min = 0L)), ResultToken = structure(logical(0), 
        tags = list(type = "string")), TestMode = structure(logical(0), 
        tags = list(type = "boolean"))), tags = list(type = "structure"))
    return(populate(args, shape))
}

put_evaluations_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(FailedEvaluations = structure(list(structure(list(ComplianceResourceType = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L)), 
        ComplianceResourceId = structure(logical(0), tags = list(type = "string", 
            max = 768L, min = 1L)), ComplianceType = structure(logical(0), 
            tags = list(type = "string", enum = c("COMPLIANT", 
                "NON_COMPLIANT", "NOT_APPLICABLE", "INSUFFICIENT_DATA"))), 
        Annotation = structure(logical(0), tags = list(type = "string", 
            max = 256L, min = 1L)), OrderingTimestamp = structure(logical(0), 
            tags = list(type = "timestamp"))), tags = list(type = "structure"))), 
        tags = list(type = "list", max = 100L, min = 0L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

put_retention_configuration_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RetentionPeriodInDays = structure(logical(0), 
        tags = list(type = "integer", max = 2557L, min = 30L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

put_retention_configuration_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(RetentionConfiguration = structure(list(Name = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L, pattern = "[\\w\\-]+")), 
        RetentionPeriodInDays = structure(logical(0), tags = list(type = "integer", 
            max = 2557L, min = 30L))), tags = list(type = "structure"))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_config_rules_evaluation_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigRuleNames = structure(list(structure(logical(0), 
        tags = list(type = "string", max = 64L, min = 1L))), 
        tags = list(type = "list", max = 25L, min = 1L))), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_config_rules_evaluation_output <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(), tags = list(type = "structure"))
    return(populate(args, shape))
}

start_configuration_recorder_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorderName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

start_configuration_recorder_output <- function () 
{
    return(list())
}

stop_configuration_recorder_input <- function (...) 
{
    args <- c(as.list(environment()), list(...))
    shape <- structure(list(ConfigurationRecorderName = structure(logical(0), 
        tags = list(type = "string", max = 256L, min = 1L))), 
        tags = list(type = "structure"))
    return(populate(args, shape))
}

stop_configuration_recorder_output <- function () 
{
    return(list())
}

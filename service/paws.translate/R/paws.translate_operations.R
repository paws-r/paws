# This file is generated by make.paws. Please do not edit here.

#' A synchronous action that deletes a custom terminology
#'
#' A synchronous action that deletes a custom terminology.
#'
#' @usage
#' delete_terminology(
#'   Name = "string"
#' )
#'
#' @param Name &#91;required&#93; The name of the custom terminology being deleted.
#'
#' @examples
#'
#' @export
delete_terminology <- function (Name) 
{
    op <- Operation(name = "DeleteTerminology", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- delete_terminology_input(Name = Name)
    output <- delete_terminology_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Retrieves a custom terminology
#'
#' Retrieves a custom terminology.
#'
#' @usage
#' get_terminology(
#'   Name = "string",
#'   TerminologyDataFormat = "CSV"|"TMX"
#' )
#'
#' @param Name &#91;required&#93; The name of the custom terminology being retrieved.
#' @param TerminologyDataFormat &#91;required&#93; The data format of the custom terminology being retrieved, either CSV or TMX.
#'
#' @examples
#'
#' @export
get_terminology <- function (Name, TerminologyDataFormat) 
{
    op <- Operation(name = "GetTerminology", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- get_terminology_input(Name = Name, TerminologyDataFormat = TerminologyDataFormat)
    output <- get_terminology_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates or updates a custom terminology, depending on whether or not one already exists for the given terminology name
#'
#' Creates or updates a custom terminology, depending on whether or not one already exists for the given terminology name. Importing a terminology with the same name as an existing one will merge the terminologies based on the chosen merge strategy. Currently, the only supported merge strategy is OVERWRITE, and so the imported terminology will overwrite an existing terminology of the same name.
#' 
#' If you import a terminology that overwrites an existing one, the new terminology take up to 10 minutes to fully propagate and be available for use in a translation due to cache policies with the DataPlane service that performs the translations.
#'
#' @usage
#' import_terminology(
#'   Name = "string",
#'   MergeStrategy = "OVERWRITE",
#'   Description = "string",
#'   TerminologyData = list(
#'     File = raw,
#'     Format = "CSV"|"TMX"
#'   ),
#'   EncryptionKey = list(
#'     Type = "KMS",
#'     Id = "string"
#'   )
#' )
#'
#' @param Name &#91;required&#93; The name of the custom terminology being imported.
#' @param MergeStrategy &#91;required&#93; The merge strategy of the custom terminology being imported. Currently, only the OVERWRITE merge strategy is supported. In this case, the imported terminology will overwrite an existing terminology of the same name.
#' @param Description The description of the custom terminology being imported.
#' @param TerminologyData &#91;required&#93; The terminology data for the custom terminology being imported.
#' @param EncryptionKey The encryption key for the custom terminology being imported.
#'
#' @examples
#'
#' @export
import_terminology <- function (Name, MergeStrategy, Description = NULL, 
    TerminologyData, EncryptionKey = NULL) 
{
    op <- Operation(name = "ImportTerminology", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- import_terminology_input(Name = Name, MergeStrategy = MergeStrategy, 
        Description = Description, TerminologyData = TerminologyData, 
        EncryptionKey = EncryptionKey)
    output <- import_terminology_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Provides a list of custom terminologies associated with your account
#'
#' Provides a list of custom terminologies associated with your account.
#'
#' @usage
#' list_terminologies(
#'   NextToken = "string",
#'   MaxResults = 123
#' )
#'
#' @param NextToken If the result of the request to ListTerminologies was truncated, include the NextToken to fetch the next group of custom terminologies.
#' @param MaxResults The maximum number of custom terminologies returned per list request.
#'
#' @examples
#'
#' @export
list_terminologies <- function (NextToken = NULL, MaxResults = NULL) 
{
    op <- Operation(name = "ListTerminologies", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- list_terminologies_input(NextToken = NextToken, 
        MaxResults = MaxResults)
    output <- list_terminologies_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Translates input text from the source language to the target language
#'
#' Translates input text from the source language to the target language. It is not necessary to use English (en) as either the source or the target language but not all language combinations are supported by Amazon Translate. For more information, see [Supported Language Pairs](http://docs.aws.amazon.com/translate/latest/dg/pairs.html).
#' 
#' -   Arabic (ar)
#' 
#' -   Chinese (Simplified) (zh)
#' 
#' -   Chinese (Traditional) (zh-TW)
#' 
#' -   Czech (cs)
#' 
#' -   Danish (da)
#' 
#' -   Dutch (nl)
#' 
#' -   English (en)
#' 
#' -   Finnish (fi)
#' 
#' -   French (fr)
#' 
#' -   German (de)
#' 
#' -   Hebrew (he)
#' 
#' -   Indonesian (id)
#' 
#' -   Italian (it)
#' 
#' -   Japanese (ja)
#' 
#' -   Korean (ko)
#' 
#' -   Polish (pl)
#' 
#' -   Portuguese (pt)
#' 
#' -   Russian (ru)
#' 
#' -   Spanish (es)
#' 
#' -   Swedish (sv)
#' 
#' -   Turkish (tr)
#' 
#' To have Amazon Translate determine the source language of your text, you can specify `auto` in the `SourceLanguageCode` field. If you specify `auto`, Amazon Translate will call Amazon Comprehend to determine the source language.
#'
#' @usage
#' translate_text(
#'   Text = "string",
#'   TerminologyNames = list(
#'     "string"
#'   ),
#'   SourceLanguageCode = "string",
#'   TargetLanguageCode = "string"
#' )
#'
#' @param Text &#91;required&#93; The text to translate. The text string can be a maximum of 5,000 bytes long. Depending on your character set, this may be fewer than 5,000 characters.
#' @param TerminologyNames The TerminologyNames list that is taken as input to the TranslateText request. This has a minimum length of 0 and a maximum length of 1.
#' @param SourceLanguageCode &#91;required&#93; The language code for the language of the source text. The language must be a language supported by Amazon Translate.
#' 
#' To have Amazon Translate determine the source language of your text, you can specify `auto` in the `SourceLanguageCode` field. If you specify `auto`, Amazon Translate will call Amazon Comprehend to determine the source language.
#' @param TargetLanguageCode &#91;required&#93; The language code requested for the language of the target text. The language must be a language supported by Amazon Translate.
#'
#' @examples
#'
#' @export
translate_text <- function (Text, TerminologyNames = NULL, SourceLanguageCode, 
    TargetLanguageCode) 
{
    op <- Operation(name = "TranslateText", http_method = "POST", 
        http_path = "/", paginator = list())
    input <- translate_text_input(Text = Text, TerminologyNames = TerminologyNames, 
        SourceLanguageCode = SourceLanguageCode, TargetLanguageCode = TargetLanguageCode)
    output <- translate_text_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

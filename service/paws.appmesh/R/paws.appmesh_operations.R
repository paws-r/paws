# This file is generated by make.paws. Please do not edit here.

#' @importFrom paws.common new_operation new_request send_request
NULL

#' Creates a new service mesh
#'
#' Creates a new service mesh. A service mesh is a logical boundary for network traffic between the services that reside within it.
#' 
#' After you create your service mesh, you can create virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh.
#'
#' @section Accepted Parameters:
#' ```
#' create_mesh(
#'   clientToken = "string",
#'   meshName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name to use for the service mesh.
#'
#' @export
create_mesh <- function (clientToken = NULL, meshName) 
{
    op <- new_operation(name = "CreateMesh", http_method = "PUT", 
        http_path = "/meshes", paginator = list())
    input <- create_mesh_input(clientToken = clientToken, meshName = meshName)
    output <- create_mesh_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new route that is associated with a virtual router
#'
#' Creates a new route that is associated with a virtual router.
#' 
#' You can use the `prefix` parameter in your route specification for path-based routing of requests. For example, if your virtual router service name is `my-service.local`, and you want the route to match requests to `my-service.local/metrics`, then your prefix should be `/metrics`.
#' 
#' If your route matches a request, you can distribute traffic to one or more target virtual nodes with relative weighting.
#'
#' @section Accepted Parameters:
#' ```
#' create_route(
#'   clientToken = "string",
#'   meshName = "string",
#'   routeName = "string",
#'   spec = list(
#'     httpRoute = list(
#'       action = list(
#'         weightedTargets = list(
#'           list(
#'             virtualNode = "string",
#'             weight = 123
#'           )
#'         )
#'       ),
#'       match = list(
#'         prefix = "string"
#'       )
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the route.
#' @param routeName &#91;required&#93; The name to use for the route.
#' @param spec &#91;required&#93; The route specification to apply.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to create the route.
#'
#' @export
create_route <- function (clientToken = NULL, meshName, routeName, 
    spec, virtualRouterName) 
{
    op <- new_operation(name = "CreateRoute", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes", 
        paginator = list())
    input <- create_route_input(clientToken = clientToken, meshName = meshName, 
        routeName = routeName, spec = spec, virtualRouterName = virtualRouterName)
    output <- create_route_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new virtual node within a service mesh
#'
#' Creates a new virtual node within a service mesh.
#' 
#' A virtual node acts as logical pointer to a particular task group, such as an Amazon ECS service or a Kubernetes deployment. When you create a virtual node, you must specify the DNS service discovery name for your task group.
#' 
#' Any inbound traffic that your virtual node expects should be specified as a `listener`. Any outbound traffic that your virtual node expects to reach should be specified as a `backend`.
#' 
#' The response metadata for your new virtual node contains the `arn` that is associated with the virtual node. Set this value (either the full ARN or the truncated resource name, for example, `mesh/default/virtualNode/simpleapp`, as the `APPMESH_VIRTUAL_NODE_NAME` environment variable for your task group\'s Envoy proxy container in your task definition or pod spec. This is then mapped to the `node.id` and `node.cluster` Envoy parameters.
#' 
#' If you require your Envoy stats or tracing to use a different name, you can override the `node.cluster` value that is set by `APPMESH_VIRTUAL_NODE_NAME` with the `APPMESH_VIRTUAL_NODE_CLUSTER` environment variable.
#'
#' @section Accepted Parameters:
#' ```
#' create_virtual_node(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     backends = list(
#'       "string"
#'     ),
#'     listeners = list(
#'       list(
#'         healthCheck = list(
#'           healthyThreshold = 123,
#'           intervalMillis = 123,
#'           path = "string",
#'           port = 123,
#'           protocol = "http"|"tcp",
#'           timeoutMillis = 123,
#'           unhealthyThreshold = 123
#'         ),
#'         portMapping = list(
#'           port = 123,
#'           protocol = "http"|"tcp"
#'         )
#'       )
#'     ),
#'     serviceDiscovery = list(
#'       dns = list(
#'         serviceName = "string"
#'       )
#'     )
#'   ),
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the virtual node.
#' @param spec &#91;required&#93; The virtual node specification to apply.
#' @param virtualNodeName &#91;required&#93; The name to use for the virtual node.
#'
#' @export
create_virtual_node <- function (clientToken = NULL, meshName, 
    spec, virtualNodeName) 
{
    op <- new_operation(name = "CreateVirtualNode", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualNodes", paginator = list())
    input <- create_virtual_node_input(clientToken = clientToken, 
        meshName = meshName, spec = spec, virtualNodeName = virtualNodeName)
    output <- create_virtual_node_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Creates a new virtual router within a service mesh
#'
#' Creates a new virtual router within a service mesh.
#' 
#' Virtual routers handle traffic for one or more service names within your mesh. After you create your virtual router, create and associate routes for your virtual router that direct incoming requests to different virtual nodes.
#'
#' @section Accepted Parameters:
#' ```
#' create_virtual_router(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     serviceNames = list(
#'       "string"
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the virtual router.
#' @param spec &#91;required&#93; The virtual router specification to apply.
#' @param virtualRouterName &#91;required&#93; The name to use for the virtual router.
#'
#' @export
create_virtual_router <- function (clientToken = NULL, meshName, 
    spec, virtualRouterName) 
{
    op <- new_operation(name = "CreateVirtualRouter", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualRouters", paginator = list())
    input <- create_virtual_router_input(clientToken = clientToken, 
        meshName = meshName, spec = spec, virtualRouterName = virtualRouterName)
    output <- create_virtual_router_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes an existing service mesh
#'
#' Deletes an existing service mesh.
#' 
#' You must delete all resources (routes, virtual routers, virtual nodes) in the service mesh before you can delete the mesh itself.
#'
#' @section Accepted Parameters:
#' ```
#' delete_mesh(
#'   meshName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh to delete.
#'
#' @export
delete_mesh <- function (meshName) 
{
    op <- new_operation(name = "DeleteMesh", http_method = "DELETE", 
        http_path = "/meshes/{meshName}", paginator = list())
    input <- delete_mesh_input(meshName = meshName)
    output <- delete_mesh_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes an existing route
#'
#' Deletes an existing route.
#'
#' @section Accepted Parameters:
#' ```
#' delete_route(
#'   meshName = "string",
#'   routeName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the route.
#' @param routeName &#91;required&#93; The name of the route to delete.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to delete the route.
#'
#' @export
delete_route <- function (meshName, routeName, virtualRouterName) 
{
    op <- new_operation(name = "DeleteRoute", http_method = "DELETE", 
        http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
        paginator = list())
    input <- delete_route_input(meshName = meshName, routeName = routeName, 
        virtualRouterName = virtualRouterName)
    output <- delete_route_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes an existing virtual node
#'
#' Deletes an existing virtual node.
#'
#' @section Accepted Parameters:
#' ```
#' delete_virtual_node(
#'   meshName = "string",
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the virtual node.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to delete.
#'
#' @export
delete_virtual_node <- function (meshName, virtualNodeName) 
{
    op <- new_operation(name = "DeleteVirtualNode", http_method = "DELETE", 
        http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
        paginator = list())
    input <- delete_virtual_node_input(meshName = meshName, virtualNodeName = virtualNodeName)
    output <- delete_virtual_node_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Deletes an existing virtual router
#'
#' Deletes an existing virtual router.
#' 
#' You must delete any routes associated with the virtual router before you can delete the router itself.
#'
#' @section Accepted Parameters:
#' ```
#' delete_virtual_router(
#'   meshName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the virtual router.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to delete.
#'
#' @export
delete_virtual_router <- function (meshName, virtualRouterName) 
{
    op <- new_operation(name = "DeleteVirtualRouter", http_method = "DELETE", 
        http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
        paginator = list())
    input <- delete_virtual_router_input(meshName = meshName, 
        virtualRouterName = virtualRouterName)
    output <- delete_virtual_router_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Describes an existing service mesh
#'
#' Describes an existing service mesh.
#'
#' @section Accepted Parameters:
#' ```
#' describe_mesh(
#'   meshName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh to describe.
#'
#' @export
describe_mesh <- function (meshName) 
{
    op <- new_operation(name = "DescribeMesh", http_method = "GET", 
        http_path = "/meshes/{meshName}", paginator = list())
    input <- describe_mesh_input(meshName = meshName)
    output <- describe_mesh_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Describes an existing route
#'
#' Describes an existing route.
#'
#' @section Accepted Parameters:
#' ```
#' describe_route(
#'   meshName = "string",
#'   routeName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the route resides.
#' @param routeName &#91;required&#93; The name of the route to describe.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router with which the route is associated.
#'
#' @export
describe_route <- function (meshName, routeName, virtualRouterName) 
{
    op <- new_operation(name = "DescribeRoute", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
        paginator = list())
    input <- describe_route_input(meshName = meshName, routeName = routeName, 
        virtualRouterName = virtualRouterName)
    output <- describe_route_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Describes an existing virtual node
#'
#' Describes an existing virtual node.
#'
#' @section Accepted Parameters:
#' ```
#' describe_virtual_node(
#'   meshName = "string",
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual node resides.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to describe.
#'
#' @export
describe_virtual_node <- function (meshName, virtualNodeName) 
{
    op <- new_operation(name = "DescribeVirtualNode", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
        paginator = list())
    input <- describe_virtual_node_input(meshName = meshName, 
        virtualNodeName = virtualNodeName)
    output <- describe_virtual_node_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Describes an existing virtual router
#'
#' Describes an existing virtual router.
#'
#' @section Accepted Parameters:
#' ```
#' describe_virtual_router(
#'   meshName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual router resides.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to describe.
#'
#' @export
describe_virtual_router <- function (meshName, virtualRouterName) 
{
    op <- new_operation(name = "DescribeVirtualRouter", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
        paginator = list())
    input <- describe_virtual_router_input(meshName = meshName, 
        virtualRouterName = virtualRouterName)
    output <- describe_virtual_router_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Returns a list of existing service meshes
#'
#' Returns a list of existing service meshes.
#'
#' @section Accepted Parameters:
#' ```
#' list_meshes(
#'   limit = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @param limit The maximum number of mesh results returned by `ListMeshes` in paginated output. When this parameter is used, `ListMeshes` only returns `limit` results in a single page along with a `nextToken` response element. The remaining results of the initial request can be seen by sending another `ListMeshes` request with the returned `nextToken` value. This value can be between 1 and 100. If this parameter is not used, then `ListMeshes` returns up to 100 results and a `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListMeshes` request where `limit` was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
#'
#' @export
list_meshes <- function (limit = NULL, nextToken = NULL) 
{
    op <- new_operation(name = "ListMeshes", http_method = "GET", 
        http_path = "/meshes", paginator = list())
    input <- list_meshes_input(limit = limit, nextToken = nextToken)
    output <- list_meshes_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Returns a list of existing routes in a service mesh
#'
#' Returns a list of existing routes in a service mesh.
#'
#' @section Accepted Parameters:
#' ```
#' list_routes(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param limit The maximum number of mesh results returned by `ListRoutes` in paginated output. When this parameter is used, `ListRoutes` only returns `limit` results in a single page along with a `nextToken` response element. The remaining results of the initial request can be seen by sending another `ListRoutes` request with the returned `nextToken` value. This value can be between 1 and 100. If this parameter is not used, then `ListRoutes` returns up to 100 results and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list routes.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListRoutes` request where `limit` was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the `nextToken` value.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to list routes.
#'
#' @export
list_routes <- function (limit = NULL, meshName, nextToken = NULL, 
    virtualRouterName) 
{
    op <- new_operation(name = "ListRoutes", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes", 
        paginator = list())
    input <- list_routes_input(limit = limit, meshName = meshName, 
        nextToken = nextToken, virtualRouterName = virtualRouterName)
    output <- list_routes_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Returns a list of existing virtual nodes
#'
#' Returns a list of existing virtual nodes.
#'
#' @section Accepted Parameters:
#' ```
#' list_virtual_nodes(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @param limit The maximum number of mesh results returned by `ListVirtualNodes` in paginated output. When this parameter is used, `ListVirtualNodes` only returns `limit` results in a single page along with a `nextToken` response element. The remaining results of the initial request can be seen by sending another `ListVirtualNodes` request with the returned `nextToken` value. This value can be between 1 and 100. If this parameter is not used, then `ListVirtualNodes` returns up to 100 results and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list virtual nodes.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListVirtualNodes` request where `limit` was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the `nextToken` value.
#'
#' @export
list_virtual_nodes <- function (limit = NULL, meshName, nextToken = NULL) 
{
    op <- new_operation(name = "ListVirtualNodes", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualNodes", paginator = list())
    input <- list_virtual_nodes_input(limit = limit, meshName = meshName, 
        nextToken = nextToken)
    output <- list_virtual_nodes_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Returns a list of existing virtual routers in a service mesh
#'
#' Returns a list of existing virtual routers in a service mesh.
#'
#' @section Accepted Parameters:
#' ```
#' list_virtual_routers(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @param limit The maximum number of mesh results returned by `ListVirtualRouters` in paginated output. When this parameter is used, `ListVirtualRouters` only returns `limit` results in a single page along with a `nextToken` response element. The remaining results of the initial request can be seen by sending another `ListVirtualRouters` request with the returned `nextToken` value. This value can be between 1 and 100. If this parameter is not used, then `ListVirtualRouters` returns up to 100 results and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list virtual routers.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListVirtualRouters` request where `limit` was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the `nextToken` value.
#'
#' @export
list_virtual_routers <- function (limit = NULL, meshName, nextToken = NULL) 
{
    op <- new_operation(name = "ListVirtualRouters", http_method = "GET", 
        http_path = "/meshes/{meshName}/virtualRouters", paginator = list())
    input <- list_virtual_routers_input(limit = limit, meshName = meshName, 
        nextToken = nextToken)
    output <- list_virtual_routers_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing route for a specified service mesh and virtual router
#'
#' Updates an existing route for a specified service mesh and virtual router.
#'
#' @section Accepted Parameters:
#' ```
#' update_route(
#'   clientToken = "string",
#'   meshName = "string",
#'   routeName = "string",
#'   spec = list(
#'     httpRoute = list(
#'       action = list(
#'         weightedTargets = list(
#'           list(
#'             virtualNode = "string",
#'             weight = 123
#'           )
#'         )
#'       ),
#'       match = list(
#'         prefix = "string"
#'       )
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the route resides.
#' @param routeName &#91;required&#93; The name of the route to update.
#' @param spec &#91;required&#93; The new route specification to apply. This overwrites the existing data.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router with which the route is associated.
#'
#' @export
update_route <- function (clientToken = NULL, meshName, routeName, 
    spec, virtualRouterName) 
{
    op <- new_operation(name = "UpdateRoute", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}", 
        paginator = list())
    input <- update_route_input(clientToken = clientToken, meshName = meshName, 
        routeName = routeName, spec = spec, virtualRouterName = virtualRouterName)
    output <- update_route_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing virtual node in a specified service mesh
#'
#' Updates an existing virtual node in a specified service mesh.
#'
#' @section Accepted Parameters:
#' ```
#' update_virtual_node(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     backends = list(
#'       "string"
#'     ),
#'     listeners = list(
#'       list(
#'         healthCheck = list(
#'           healthyThreshold = 123,
#'           intervalMillis = 123,
#'           path = "string",
#'           port = 123,
#'           protocol = "http"|"tcp",
#'           timeoutMillis = 123,
#'           unhealthyThreshold = 123
#'         ),
#'         portMapping = list(
#'           port = 123,
#'           protocol = "http"|"tcp"
#'         )
#'       )
#'     ),
#'     serviceDiscovery = list(
#'       dns = list(
#'         serviceName = "string"
#'       )
#'     )
#'   ),
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual node resides.
#' @param spec &#91;required&#93; The new virtual node specification to apply. This overwrites the existing data.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to update.
#'
#' @export
update_virtual_node <- function (clientToken = NULL, meshName, 
    spec, virtualNodeName) 
{
    op <- new_operation(name = "UpdateVirtualNode", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}", 
        paginator = list())
    input <- update_virtual_node_input(clientToken = clientToken, 
        meshName = meshName, spec = spec, virtualNodeName = virtualNodeName)
    output <- update_virtual_node_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}

#' Updates an existing virtual router in a specified service mesh
#'
#' Updates an existing virtual router in a specified service mesh.
#'
#' @section Accepted Parameters:
#' ```
#' update_virtual_router(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     serviceNames = list(
#'       "string"
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up to 36 letters, numbers, hyphens, and underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual router resides.
#' @param spec &#91;required&#93; The new virtual router specification to apply. This overwrites the existing data.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to update.
#'
#' @export
update_virtual_router <- function (clientToken = NULL, meshName, 
    spec, virtualRouterName) 
{
    op <- new_operation(name = "UpdateVirtualRouter", http_method = "PUT", 
        http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}", 
        paginator = list())
    input <- update_virtual_router_input(clientToken = clientToken, 
        meshName = meshName, spec = spec, virtualRouterName = virtualRouterName)
    output <- update_virtual_router_output()
    svc <- service()
    request <- new_request(svc, op, input, output)
    response <- send_request(request)
    return(response)
}
